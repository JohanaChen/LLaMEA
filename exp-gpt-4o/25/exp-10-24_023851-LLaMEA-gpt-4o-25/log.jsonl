{"id": "7a410758-3b62-4caa-83f2-617c43bf86fc", "solution": "import numpy as np\n\nclass HybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):  # Limit the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                for i in range(min(3, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridDELocalSearch", "description": "A hybrid metaheuristic combining Differential Evolution and Local Search to balance global exploration and local exploitation.", "configspace": "", "generation": 0, "fitness": 0.1859031367776774, "feedback": "The algorithm HybridDELocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": null, "metadata": {"aucs": [0.4589574146912734, 0.4224973754097576, 0.403714395022177, 0.4431234239120325, 0.40914136064683004, 0.39884066880488267, 0.38922869100533075, 0.3892800679978251, 0.40605005621558277, 0.035648349435746796, 0.02991498833397832, 0.03151095536837201, 0.03638913582073622, 0.029915797518140774, 0.029699074500826983, 0.05076605655902422, 0.03765546250707974, 0.033054643801542105, 0.07832767749820269, 0.10025544422970156, 0.09090430650076375, 0.11697084221290444, 0.07725649043903426, 0.10118801898324414, 0.15744472114567165, 0.09308381738233451, 0.08158697076413823, 0.07202030845070528, 0.06584617468222553, 0.05613604772652414, 0.08833186976005347, 0.07068626699135838, 0.0768848860170227, 0.07834774079666218, 0.07452464080410537, 0.05683727726095256, 0.8906817862671983, 0.7774965084112204, 0.837168634260098, 0.7932412847934738, 0.7838443871401783, 0.7954785558036581, 0.8701147142098796, 0.7943518134588949, 0.7931654736108256, 0.2179718477355721, 0.1944826193954372, 0.2766616047617777, 0.19856904346502247, 0.19328785296463025, 0.21240305590861286, 0.23266944588372485, 0.22535425737982973, 0.2409834567482798, 0.17651701947042797, 0.2167668815568089, 0.20280177478862937, 0.21467477719451544, 0.2366479413707493, 0.22091838826324972, 0.1674207623917704, 0.18737197690054685, 0.21560535007509607, 0.1911922590302042, 0.1633416565586866, 0.11495162159631855, 0.15505475510935884, 0.11791989620757881, 0.10794258198335738, 0.1426962322251637, 0.18269539876398322, 0.1170203512041329, 0.12513087931329914, 0.13036429804190253, 0.14853578020720137, 0.1262818347372846, 0.17099693551951278, 0.11711235380676077, 0.11980303167355344, 0.1187272287483766, 0.14394605538292704, 9.999999999998899e-05, 0.02970090802013914, 9.999999999998899e-05, 9.999999999998899e-05, 0.005758307038200128, 0.002989895277938248, 0.00881386732093492, 0.0007871847363177809, 9.999999999998899e-05, 0.09559846471969358, 0.05687011439389167, 0.07716705774313559, 0.077985115402468, 0.08813131656991591, 0.058057215254956995, 0.07306128143901058, 0.0812135293205336, 0.10459529401344392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008975407584127959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10059748181544947, 0.071814561338852, 0.0739147360440211, 0.0610917700297996, 0.09982071229808531, 0.09862645225571864, 0.09726990419496817, 0.07195521801796478, 0.07092727693726919, 0.4040933900081022, 0.3988843362143166, 0.36850850343935304, 0.38325362956419295, 0.34673092178207776, 0.36949217528294354, 0.38930859605775536, 0.3375924507466349, 0.3834278485984163, 0.1076194318910042, 0.10864147895721399, 0.11669132281896932, 0.08951352089079445, 0.09142267162077078, 0.08902007281519186, 0.11153794435700148, 0.10223516227261065, 0.11805554787018446, 0.16491230386605715, 0.20281779366442498, 0.19081601802242365, 0.23898993025366466, 0.2131430572708234, 0.2168041131705729, 0.19310612526642734, 0.2930590822183089, 0.16494847525752176, 0.1955828368635777, 0.18136286214545594, 0.2057665070356708, 0.18971667204046805, 0.19867210032997396, 0.19614139508374573, 0.19780342113138527, 0.2318032264715868, 0.22357256547880588, 0.14728143011793893, 0.1674746128518827, 0.1409666802818932, 0.14894785228892993, 0.15031354485441606, 0.15259499469371351, 0.15253180600941318, 0.16412786475560492, 0.16869440458256646, 0.17409200618326937, 0.179175929885663, 0.16246410105444886, 0.18839996326624364, 0.15733957235749219, 0.1932031632464668, 0.21446659221024145, 0.16628895301383273, 0.18582867574659878, 0.1778332976120206, 0.179765873833458, 0.19013597095199264, 0.17216515986789804, 0.1641519811321387, 0.17267233578077557, 0.16881782330434691, 0.21849735936557868, 0.1760204321583989, 0.1954102484761724, 0.2875027510863931, 0.3517841274135832, 0.19628447050909892, 0.19752023703292676, 0.43939291734907404, 0.1718069346969172, 0.16670044385161875, 0.1970121522280247, 0.38785573000035034, 0.22319801610721646, 0.28838640164318896, 0.1801377058195236, 0.46048450597588264, 0.20567316330480379, 0.19187404080956172, 0.2065413529321074, 0.20576319958189715, 0.1661568521255714, 0.19472622699182307, 0.17501408557962694, 0.17070180764325837, 0.1853007556540479, 0.17239578636076514, 0.17490298559157724, 0.17434456316293911, 0.1840847286191618, 0.06969937321697339, 0.06796125699093014, 0.0711831551458908, 0.07426553489272014, 0.0682094961880968, 0.06706258374568075, 0.06890186075983185, 0.05825353571072178, 0.059975829331417096]}, "mutation_prompt": null}
{"id": "161892d2-ad72-463c-8b81-fe1c71b5b56e", "solution": "import numpy as np\n\nclass HybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):  # Limit the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                for i in range(min(3, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridDELocalSearch", "description": "A hybrid metaheuristic combining Differential Evolution and Local Search to balance global exploration and local exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7a410758-3b62-4caa-83f2-617c43bf86fc", "metadata": {"aucs": [0.4589574146912734, 0.4224973754097576, 0.403714395022177, 0.4431234239120325, 0.40914136064683004, 0.39884066880488267, 0.38922869100533075, 0.3892800679978251, 0.40605005621558277, 0.035648349435746796, 0.02991498833397832, 0.03151095536837201, 0.03638913582073622, 0.029915797518140774, 0.029699074500826983, 0.05076605655902422, 0.03765546250707974, 0.033054643801542105, 0.07832767749820269, 0.10025544422970156, 0.09090430650076375, 0.11697084221290444, 0.07725649043903426, 0.10118801898324414, 0.15744472114567165, 0.09308381738233451, 0.08158697076413823, 0.07202030845070528, 0.06584617468222553, 0.05613604772652414, 0.08833186976005347, 0.07068626699135838, 0.0768848860170227, 0.07834774079666218, 0.07452464080410537, 0.05683727726095256, 0.8906817862671983, 0.7774965084112204, 0.837168634260098, 0.7932412847934738, 0.7838443871401783, 0.7954785558036581, 0.8701147142098796, 0.7943518134588949, 0.7931654736108256, 0.2179718477355721, 0.1944826193954372, 0.2766616047617777, 0.19856904346502247, 0.19328785296463025, 0.21240305590861286, 0.23266944588372485, 0.22535425737982973, 0.2409834567482798, 0.17651701947042797, 0.2167668815568089, 0.20280177478862937, 0.21467477719451544, 0.2366479413707493, 0.22091838826324972, 0.1674207623917704, 0.18737197690054685, 0.21560535007509607, 0.1911922590302042, 0.1633416565586866, 0.11495162159631855, 0.15505475510935884, 0.11791989620757881, 0.10794258198335738, 0.1426962322251637, 0.18269539876398322, 0.1170203512041329, 0.12513087931329914, 0.13036429804190253, 0.14853578020720137, 0.1262818347372846, 0.17099693551951278, 0.11711235380676077, 0.11980303167355344, 0.1187272287483766, 0.14394605538292704, 9.999999999998899e-05, 0.02970090802013914, 9.999999999998899e-05, 9.999999999998899e-05, 0.005758307038200128, 0.002989895277938248, 0.00881386732093492, 0.0007871847363177809, 9.999999999998899e-05, 0.09559846471969358, 0.05687011439389167, 0.07716705774313559, 0.077985115402468, 0.08813131656991591, 0.058057215254956995, 0.07306128143901058, 0.0812135293205336, 0.10459529401344392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008975407584127959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10059748181544947, 0.071814561338852, 0.0739147360440211, 0.0610917700297996, 0.09982071229808531, 0.09862645225571864, 0.09726990419496817, 0.07195521801796478, 0.07092727693726919, 0.4040933900081022, 0.3988843362143166, 0.36850850343935304, 0.38325362956419295, 0.34673092178207776, 0.36949217528294354, 0.38930859605775536, 0.3375924507466349, 0.3834278485984163, 0.1076194318910042, 0.10864147895721399, 0.11669132281896932, 0.08951352089079445, 0.09142267162077078, 0.08902007281519186, 0.11153794435700148, 0.10223516227261065, 0.11805554787018446, 0.16491230386605715, 0.20281779366442498, 0.19081601802242365, 0.23898993025366466, 0.2131430572708234, 0.2168041131705729, 0.19310612526642734, 0.2930590822183089, 0.16494847525752176, 0.1955828368635777, 0.18136286214545594, 0.2057665070356708, 0.18971667204046805, 0.19867210032997396, 0.19614139508374573, 0.19780342113138527, 0.2318032264715868, 0.22357256547880588, 0.14728143011793893, 0.1674746128518827, 0.1409666802818932, 0.14894785228892993, 0.15031354485441606, 0.15259499469371351, 0.15253180600941318, 0.16412786475560492, 0.16869440458256646, 0.17409200618326937, 0.179175929885663, 0.16246410105444886, 0.18839996326624364, 0.15733957235749219, 0.1932031632464668, 0.21446659221024145, 0.16628895301383273, 0.18582867574659878, 0.1778332976120206, 0.179765873833458, 0.19013597095199264, 0.17216515986789804, 0.1641519811321387, 0.17267233578077557, 0.16881782330434691, 0.21849735936557868, 0.1760204321583989, 0.1954102484761724, 0.2875027510863931, 0.3517841274135832, 0.19628447050909892, 0.19752023703292676, 0.43939291734907404, 0.1718069346969172, 0.16670044385161875, 0.1970121522280247, 0.38785573000035034, 0.22319801610721646, 0.28838640164318896, 0.1801377058195236, 0.46048450597588264, 0.20567316330480379, 0.19187404080956172, 0.2065413529321074, 0.20576319958189715, 0.1661568521255714, 0.19472622699182307, 0.17501408557962694, 0.17070180764325837, 0.1853007556540479, 0.17239578636076514, 0.17490298559157724, 0.17434456316293911, 0.1840847286191618, 0.06969937321697339, 0.06796125699093014, 0.0711831551458908, 0.07426553489272014, 0.0682094961880968, 0.06706258374568075, 0.06890186075983185, 0.05825353571072178, 0.059975829331417096]}, "mutation_prompt": null}
{"id": "6d5cb9c9-b511-4f67-bc2e-40fb89cdd291", "solution": "import numpy as np\n\nclass HybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):  # Limit the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                for i in range(min(3, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridDELocalSearch", "description": "A hybrid metaheuristic combining Differential Evolution and Local Search to balance global exploration and local exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7a410758-3b62-4caa-83f2-617c43bf86fc", "metadata": {"aucs": [0.4589574146912734, 0.4224973754097576, 0.403714395022177, 0.4431234239120325, 0.40914136064683004, 0.39884066880488267, 0.38922869100533075, 0.3892800679978251, 0.40605005621558277, 0.035648349435746796, 0.02991498833397832, 0.03151095536837201, 0.03638913582073622, 0.029915797518140774, 0.029699074500826983, 0.05076605655902422, 0.03765546250707974, 0.033054643801542105, 0.07832767749820269, 0.10025544422970156, 0.09090430650076375, 0.11697084221290444, 0.07725649043903426, 0.10118801898324414, 0.15744472114567165, 0.09308381738233451, 0.08158697076413823, 0.07202030845070528, 0.06584617468222553, 0.05613604772652414, 0.08833186976005347, 0.07068626699135838, 0.0768848860170227, 0.07834774079666218, 0.07452464080410537, 0.05683727726095256, 0.8906817862671983, 0.7774965084112204, 0.837168634260098, 0.7932412847934738, 0.7838443871401783, 0.7954785558036581, 0.8701147142098796, 0.7943518134588949, 0.7931654736108256, 0.2179718477355721, 0.1944826193954372, 0.2766616047617777, 0.19856904346502247, 0.19328785296463025, 0.21240305590861286, 0.23266944588372485, 0.22535425737982973, 0.2409834567482798, 0.17651701947042797, 0.2167668815568089, 0.20280177478862937, 0.21467477719451544, 0.2366479413707493, 0.22091838826324972, 0.1674207623917704, 0.18737197690054685, 0.21560535007509607, 0.1911922590302042, 0.1633416565586866, 0.11495162159631855, 0.15505475510935884, 0.11791989620757881, 0.10794258198335738, 0.1426962322251637, 0.18269539876398322, 0.1170203512041329, 0.12513087931329914, 0.13036429804190253, 0.14853578020720137, 0.1262818347372846, 0.17099693551951278, 0.11711235380676077, 0.11980303167355344, 0.1187272287483766, 0.14394605538292704, 9.999999999998899e-05, 0.02970090802013914, 9.999999999998899e-05, 9.999999999998899e-05, 0.005758307038200128, 0.002989895277938248, 0.00881386732093492, 0.0007871847363177809, 9.999999999998899e-05, 0.09559846471969358, 0.05687011439389167, 0.07716705774313559, 0.077985115402468, 0.08813131656991591, 0.058057215254956995, 0.07306128143901058, 0.0812135293205336, 0.10459529401344392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008975407584127959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10059748181544947, 0.071814561338852, 0.0739147360440211, 0.0610917700297996, 0.09982071229808531, 0.09862645225571864, 0.09726990419496817, 0.07195521801796478, 0.07092727693726919, 0.4040933900081022, 0.3988843362143166, 0.36850850343935304, 0.38325362956419295, 0.34673092178207776, 0.36949217528294354, 0.38930859605775536, 0.3375924507466349, 0.3834278485984163, 0.1076194318910042, 0.10864147895721399, 0.11669132281896932, 0.08951352089079445, 0.09142267162077078, 0.08902007281519186, 0.11153794435700148, 0.10223516227261065, 0.11805554787018446, 0.16491230386605715, 0.20281779366442498, 0.19081601802242365, 0.23898993025366466, 0.2131430572708234, 0.2168041131705729, 0.19310612526642734, 0.2930590822183089, 0.16494847525752176, 0.1955828368635777, 0.18136286214545594, 0.2057665070356708, 0.18971667204046805, 0.19867210032997396, 0.19614139508374573, 0.19780342113138527, 0.2318032264715868, 0.22357256547880588, 0.14728143011793893, 0.1674746128518827, 0.1409666802818932, 0.14894785228892993, 0.15031354485441606, 0.15259499469371351, 0.15253180600941318, 0.16412786475560492, 0.16869440458256646, 0.17409200618326937, 0.179175929885663, 0.16246410105444886, 0.18839996326624364, 0.15733957235749219, 0.1932031632464668, 0.21446659221024145, 0.16628895301383273, 0.18582867574659878, 0.1778332976120206, 0.179765873833458, 0.19013597095199264, 0.17216515986789804, 0.1641519811321387, 0.17267233578077557, 0.16881782330434691, 0.21849735936557868, 0.1760204321583989, 0.1954102484761724, 0.2875027510863931, 0.3517841274135832, 0.19628447050909892, 0.19752023703292676, 0.43939291734907404, 0.1718069346969172, 0.16670044385161875, 0.1970121522280247, 0.38785573000035034, 0.22319801610721646, 0.28838640164318896, 0.1801377058195236, 0.46048450597588264, 0.20567316330480379, 0.19187404080956172, 0.2065413529321074, 0.20576319958189715, 0.1661568521255714, 0.19472622699182307, 0.17501408557962694, 0.17070180764325837, 0.1853007556540479, 0.17239578636076514, 0.17490298559157724, 0.17434456316293911, 0.1840847286191618, 0.06969937321697339, 0.06796125699093014, 0.0711831551458908, 0.07426553489272014, 0.0682094961880968, 0.06706258374568075, 0.06890186075983185, 0.05825353571072178, 0.059975829331417096]}, "mutation_prompt": null}
{"id": "5cc7c87b-e79f-4b51-90e0-52bdf71c1421", "solution": "import numpy as np\n\nclass HybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):  # Limit the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                for i in range(min(3, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridDELocalSearch", "description": "A hybrid metaheuristic combining Differential Evolution and Local Search to balance global exploration and local exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7a410758-3b62-4caa-83f2-617c43bf86fc", "metadata": {"aucs": [0.4589574146912734, 0.4224973754097576, 0.403714395022177, 0.4431234239120325, 0.40914136064683004, 0.39884066880488267, 0.38922869100533075, 0.3892800679978251, 0.40605005621558277, 0.035648349435746796, 0.02991498833397832, 0.03151095536837201, 0.03638913582073622, 0.029915797518140774, 0.029699074500826983, 0.05076605655902422, 0.03765546250707974, 0.033054643801542105, 0.07832767749820269, 0.10025544422970156, 0.09090430650076375, 0.11697084221290444, 0.07725649043903426, 0.10118801898324414, 0.15744472114567165, 0.09308381738233451, 0.08158697076413823, 0.07202030845070528, 0.06584617468222553, 0.05613604772652414, 0.08833186976005347, 0.07068626699135838, 0.0768848860170227, 0.07834774079666218, 0.07452464080410537, 0.05683727726095256, 0.8906817862671983, 0.7774965084112204, 0.837168634260098, 0.7932412847934738, 0.7838443871401783, 0.7954785558036581, 0.8701147142098796, 0.7943518134588949, 0.7931654736108256, 0.2179718477355721, 0.1944826193954372, 0.2766616047617777, 0.19856904346502247, 0.19328785296463025, 0.21240305590861286, 0.23266944588372485, 0.22535425737982973, 0.2409834567482798, 0.17651701947042797, 0.2167668815568089, 0.20280177478862937, 0.21467477719451544, 0.2366479413707493, 0.22091838826324972, 0.1674207623917704, 0.18737197690054685, 0.21560535007509607, 0.1911922590302042, 0.1633416565586866, 0.11495162159631855, 0.15505475510935884, 0.11791989620757881, 0.10794258198335738, 0.1426962322251637, 0.18269539876398322, 0.1170203512041329, 0.12513087931329914, 0.13036429804190253, 0.14853578020720137, 0.1262818347372846, 0.17099693551951278, 0.11711235380676077, 0.11980303167355344, 0.1187272287483766, 0.14394605538292704, 9.999999999998899e-05, 0.02970090802013914, 9.999999999998899e-05, 9.999999999998899e-05, 0.005758307038200128, 0.002989895277938248, 0.00881386732093492, 0.0007871847363177809, 9.999999999998899e-05, 0.09559846471969358, 0.05687011439389167, 0.07716705774313559, 0.077985115402468, 0.08813131656991591, 0.058057215254956995, 0.07306128143901058, 0.0812135293205336, 0.10459529401344392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008975407584127959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10059748181544947, 0.071814561338852, 0.0739147360440211, 0.0610917700297996, 0.09982071229808531, 0.09862645225571864, 0.09726990419496817, 0.07195521801796478, 0.07092727693726919, 0.4040933900081022, 0.3988843362143166, 0.36850850343935304, 0.38325362956419295, 0.34673092178207776, 0.36949217528294354, 0.38930859605775536, 0.3375924507466349, 0.3834278485984163, 0.1076194318910042, 0.10864147895721399, 0.11669132281896932, 0.08951352089079445, 0.09142267162077078, 0.08902007281519186, 0.11153794435700148, 0.10223516227261065, 0.11805554787018446, 0.16491230386605715, 0.20281779366442498, 0.19081601802242365, 0.23898993025366466, 0.2131430572708234, 0.2168041131705729, 0.19310612526642734, 0.2930590822183089, 0.16494847525752176, 0.1955828368635777, 0.18136286214545594, 0.2057665070356708, 0.18971667204046805, 0.19867210032997396, 0.19614139508374573, 0.19780342113138527, 0.2318032264715868, 0.22357256547880588, 0.14728143011793893, 0.1674746128518827, 0.1409666802818932, 0.14894785228892993, 0.15031354485441606, 0.15259499469371351, 0.15253180600941318, 0.16412786475560492, 0.16869440458256646, 0.17409200618326937, 0.179175929885663, 0.16246410105444886, 0.18839996326624364, 0.15733957235749219, 0.1932031632464668, 0.21446659221024145, 0.16628895301383273, 0.18582867574659878, 0.1778332976120206, 0.179765873833458, 0.19013597095199264, 0.17216515986789804, 0.1641519811321387, 0.17267233578077557, 0.16881782330434691, 0.21849735936557868, 0.1760204321583989, 0.1954102484761724, 0.2875027510863931, 0.3517841274135832, 0.19628447050909892, 0.19752023703292676, 0.43939291734907404, 0.1718069346969172, 0.16670044385161875, 0.1970121522280247, 0.38785573000035034, 0.22319801610721646, 0.28838640164318896, 0.1801377058195236, 0.46048450597588264, 0.20567316330480379, 0.19187404080956172, 0.2065413529321074, 0.20576319958189715, 0.1661568521255714, 0.19472622699182307, 0.17501408557962694, 0.17070180764325837, 0.1853007556540479, 0.17239578636076514, 0.17490298559157724, 0.17434456316293911, 0.1840847286191618, 0.06969937321697339, 0.06796125699093014, 0.0711831551458908, 0.07426553489272014, 0.0682094961880968, 0.06706258374568075, 0.06890186075983185, 0.05825353571072178, 0.059975829331417096]}, "mutation_prompt": null}
{"id": "b0117675-ba28-4565-acaa-be9e03e23aff", "solution": "import numpy as np\n\nclass HybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):  # Limit the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                for i in range(min(3, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridDELocalSearch", "description": "A hybrid metaheuristic combining Differential Evolution and Local Search to balance global exploration and local exploitation.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7a410758-3b62-4caa-83f2-617c43bf86fc", "metadata": {"aucs": [0.4589574146912734, 0.4224973754097576, 0.403714395022177, 0.4431234239120325, 0.40914136064683004, 0.39884066880488267, 0.38922869100533075, 0.3892800679978251, 0.40605005621558277, 0.035648349435746796, 0.02991498833397832, 0.03151095536837201, 0.03638913582073622, 0.029915797518140774, 0.029699074500826983, 0.05076605655902422, 0.03765546250707974, 0.033054643801542105, 0.07832767749820269, 0.10025544422970156, 0.09090430650076375, 0.11697084221290444, 0.07725649043903426, 0.10118801898324414, 0.15744472114567165, 0.09308381738233451, 0.08158697076413823, 0.07202030845070528, 0.06584617468222553, 0.05613604772652414, 0.08833186976005347, 0.07068626699135838, 0.0768848860170227, 0.07834774079666218, 0.07452464080410537, 0.05683727726095256, 0.8906817862671983, 0.7774965084112204, 0.837168634260098, 0.7932412847934738, 0.7838443871401783, 0.7954785558036581, 0.8701147142098796, 0.7943518134588949, 0.7931654736108256, 0.2179718477355721, 0.1944826193954372, 0.2766616047617777, 0.19856904346502247, 0.19328785296463025, 0.21240305590861286, 0.23266944588372485, 0.22535425737982973, 0.2409834567482798, 0.17651701947042797, 0.2167668815568089, 0.20280177478862937, 0.21467477719451544, 0.2366479413707493, 0.22091838826324972, 0.1674207623917704, 0.18737197690054685, 0.21560535007509607, 0.1911922590302042, 0.1633416565586866, 0.11495162159631855, 0.15505475510935884, 0.11791989620757881, 0.10794258198335738, 0.1426962322251637, 0.18269539876398322, 0.1170203512041329, 0.12513087931329914, 0.13036429804190253, 0.14853578020720137, 0.1262818347372846, 0.17099693551951278, 0.11711235380676077, 0.11980303167355344, 0.1187272287483766, 0.14394605538292704, 9.999999999998899e-05, 0.02970090802013914, 9.999999999998899e-05, 9.999999999998899e-05, 0.005758307038200128, 0.002989895277938248, 0.00881386732093492, 0.0007871847363177809, 9.999999999998899e-05, 0.09559846471969358, 0.05687011439389167, 0.07716705774313559, 0.077985115402468, 0.08813131656991591, 0.058057215254956995, 0.07306128143901058, 0.0812135293205336, 0.10459529401344392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008975407584127959, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10059748181544947, 0.071814561338852, 0.0739147360440211, 0.0610917700297996, 0.09982071229808531, 0.09862645225571864, 0.09726990419496817, 0.07195521801796478, 0.07092727693726919, 0.4040933900081022, 0.3988843362143166, 0.36850850343935304, 0.38325362956419295, 0.34673092178207776, 0.36949217528294354, 0.38930859605775536, 0.3375924507466349, 0.3834278485984163, 0.1076194318910042, 0.10864147895721399, 0.11669132281896932, 0.08951352089079445, 0.09142267162077078, 0.08902007281519186, 0.11153794435700148, 0.10223516227261065, 0.11805554787018446, 0.16491230386605715, 0.20281779366442498, 0.19081601802242365, 0.23898993025366466, 0.2131430572708234, 0.2168041131705729, 0.19310612526642734, 0.2930590822183089, 0.16494847525752176, 0.1955828368635777, 0.18136286214545594, 0.2057665070356708, 0.18971667204046805, 0.19867210032997396, 0.19614139508374573, 0.19780342113138527, 0.2318032264715868, 0.22357256547880588, 0.14728143011793893, 0.1674746128518827, 0.1409666802818932, 0.14894785228892993, 0.15031354485441606, 0.15259499469371351, 0.15253180600941318, 0.16412786475560492, 0.16869440458256646, 0.17409200618326937, 0.179175929885663, 0.16246410105444886, 0.18839996326624364, 0.15733957235749219, 0.1932031632464668, 0.21446659221024145, 0.16628895301383273, 0.18582867574659878, 0.1778332976120206, 0.179765873833458, 0.19013597095199264, 0.17216515986789804, 0.1641519811321387, 0.17267233578077557, 0.16881782330434691, 0.21849735936557868, 0.1760204321583989, 0.1954102484761724, 0.2875027510863931, 0.3517841274135832, 0.19628447050909892, 0.19752023703292676, 0.43939291734907404, 0.1718069346969172, 0.16670044385161875, 0.1970121522280247, 0.38785573000035034, 0.22319801610721646, 0.28838640164318896, 0.1801377058195236, 0.46048450597588264, 0.20567316330480379, 0.19187404080956172, 0.2065413529321074, 0.20576319958189715, 0.1661568521255714, 0.19472622699182307, 0.17501408557962694, 0.17070180764325837, 0.1853007556540479, 0.17239578636076514, 0.17490298559157724, 0.17434456316293911, 0.1840847286191618, 0.06969937321697339, 0.06796125699093014, 0.0711831551458908, 0.07426553489272014, 0.0682094961880968, 0.06706258374568075, 0.06890186075983185, 0.05825353571072178, 0.059975829331417096]}, "mutation_prompt": null}
{"id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 5, "fitness": 0.21068387041312414, "feedback": "The algorithm RefinedHybridDELocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.16.", "error": "", "parent_id": "7a410758-3b62-4caa-83f2-617c43bf86fc", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "c02eb280-f4ac-484d-96fc-1983f8c0c25d", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "988d3f4b-8611-4992-b231-cf53c3758d02", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "c0637d24-f2e9-4236-9b34-a56ac681863a", "solution": "import numpy as np\n\nclass EnhancedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Updated adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                # Enhanced mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c + d), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.004  # Slightly decreased step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):  # Increased the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 15)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedHybridDELocalSearch", "description": "A hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search with enhanced mutation dynamics for robust exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.1744535836023387, "feedback": "The algorithm EnhancedHybridDELocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.19.", "error": "", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.4070329445429419, 0.37628862612061353, 0.4346977002326864, 0.4103981564525174, 0.3924839623462544, 0.3801075835548485, 0.38950352149351497, 0.37127026951206576, 0.38389221932969664, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004292908653105276, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1259434790099323, 0.05482132133049922, 0.1245220088295731, 0.052193817101819695, 0.08177548796166978, 0.06459730347545123, 0.07699052964401032, 0.10206655402208531, 0.038475260125999, 0.07288469158671906, 0.07472995974047714, 0.06444882944346542, 0.06065829497102293, 0.058362895318914365, 0.06661782084336432, 0.029975220595362395, 0.033486191745514815, 0.06328369872217987, 0.9027985339620126, 0.9102226243160084, 0.9633005502444102, 0.9478856331172104, 0.8854858669309056, 0.9305607157889666, 0.9269261760131166, 0.9635835924446223, 0.9495623463945774, 0.138844954707816, 0.12516553555461085, 0.073582175395553, 0.13399352077371207, 0.12402822357210785, 0.08953288614818666, 0.13634154837869805, 0.16115197837981488, 0.1448603467492896, 0.20112394774193865, 0.14829229647477582, 0.1189196194770068, 0.1300850349216398, 0.15191398889144125, 0.14637386906648697, 0.09918568945306794, 0.08655324173307022, 0.13775672058094313, 0.179747748537762, 0.16287895727720514, 0.09307340031388045, 0.11440865569376912, 0.17466301245638094, 0.12471262837477826, 0.14521393554196604, 0.10104611665372032, 0.06244914948500446, 0.10240484854219944, 0.1805661268545924, 0.12764574188593236, 0.10460336035194528, 0.10173772379967938, 0.10186608651817464, 0.1647753705546009, 0.13866597148804083, 0.16490228799667106, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011592270206184696, 0.11461134110148619, 0.0380723683776083, 0.06456950228584168, 0.0645603463910418, 0.06981587536193457, 0.06068071657422203, 0.07911446426174684, 0.05197170557342978, 0.04303090915144514, 0.004309542302458058, 0.009176883618299714, 0.0023309768601235126, 0.04227181166635452, 0.0020104312091731025, 0.0012051978138303276, 0.018387550211985904, 0.024082538332237724, 9.999999999998899e-05, 0.08793041261935453, 0.07872166700899175, 0.06307479579115538, 0.038407621268698455, 0.048013515634738324, 0.10783932586099332, 0.07485534140275996, 0.06123668325193865, 0.06766212300724306, 0.33587465067349, 0.34378317060732067, 0.35543215604185174, 0.3446480728873872, 0.33451376879524497, 0.341662759641329, 0.35247530191890086, 0.34372898461972146, 0.3760812976865806, 0.04993971044850354, 0.0765273156046693, 0.09284057157497427, 0.10586267383550896, 0.08985535327083705, 0.07488879317737407, 0.06564236467061424, 0.08191948538541327, 0.07188701153214483, 0.17317113401447637, 0.1840734154957564, 0.16909100506091823, 0.3109284000874931, 0.1672959970919965, 0.15531273936730972, 0.16140286494481937, 0.18809835758321825, 0.13037335589838073, 0.18603731052770967, 0.17940747028259452, 0.1877049773702264, 0.1735101219163524, 0.18849722398635194, 0.1875710487687231, 0.17182317161803407, 0.1841629121321866, 0.17506730556714678, 0.14343616879745036, 0.14840752340868024, 0.12168005625735057, 0.14232119217813655, 0.14187084491286261, 0.13974689410453067, 0.11018385791231067, 0.12093834639596335, 0.12063134167168532, 0.19091078670498207, 0.18622881661412372, 0.18419390623172271, 0.19606823822889363, 0.1555094096433458, 0.156480674426543, 0.18467098847494023, 0.17594142941951485, 0.18680052544207182, 0.19574831310747354, 0.1646080630999155, 0.17229738181930765, 0.20013918024173427, 0.1757073612320984, 0.157215654231726, 0.19548782771380058, 0.16474092251928374, 0.22997079970763656, 0.18536895207082138, 0.18580204096394737, 0.20036090997613654, 0.15223322335762457, 0.19864107654186014, 0.3273814198935291, 0.41343689257114535, 0.545319678800182, 0.17002680805713322, 0.3657172095026112, 0.19113102329680975, 0.28005909078307234, 0.18022615304948908, 0.18336678818077834, 0.23924501795649344, 0.24759720631838877, 0.18964427796118066, 0.1975842969965541, 0.20003425396407082, 0.20770279338382303, 0.21400174528925942, 0.18865343590664907, 0.19523421375700445, 0.18531342540950047, 0.20580181977514045, 0.18866259229771554, 0.2153656935681646, 0.08100150407133677, 0.08271600803736001, 0.09263659638128152, 0.06039054471585792, 0.09164334974118249, 0.06945362470971539, 0.06655205376339124, 0.06593017159858916, 0.044279493483844856]}, "mutation_prompt": null}
{"id": "43999561-ceb5-43fc-aa66-2217310df922", "solution": "import numpy as np\n\nclass DynamicAdaptationDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Adjusted adaptive mutation factor\n        self.adaptive_crossover_factor = 0.7  # New adaptive crossover factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation and crossover step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                if np.random.rand() < 0.5:\n                    self.crossover_rate = self.adaptive_crossover_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.004  # Adjusted step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):  # Adjusted number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 18)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "DynamicAdaptationDELocalSearch", "description": "Dynamic Adaptation of Mutation and Crossover in Hybrid DE with Local Search leveraging adaptive control for enhanced convergence.", "configspace": "", "generation": 9, "fitness": 0.18613696331643595, "feedback": "The algorithm DynamicAdaptationDELocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.4434417698063118, 0.43322720425417927, 0.3699388674627665, 0.4235359583105237, 0.41161541311247196, 0.4251429380326105, 0.4330915518693721, 0.4352546563924883, 0.4384104064573179, 0.03479013451748869, 0.05397256418873053, 0.06771107564528611, 0.09730863031785353, 0.04152295216398927, 0.0331400339239144, 0.0534655680234386, 0.03725617079628596, 0.05528640395591555, 0.09850176077586748, 0.12280509660098782, 0.11805947542920636, 0.10787178375483542, 0.1054154684850922, 0.0976566541206938, 0.09744239315074388, 0.10931303969055439, 0.10439075214826532, 0.0928522049066165, 0.07923046833509484, 0.09823049207149592, 0.12229222948247864, 0.14026668494558858, 0.11538788326288452, 0.10751642567212272, 0.0879187795340356, 0.08163943335856727, 0.8129034370919894, 0.7685081618413313, 0.833714576894842, 0.7688290395732826, 0.7419495550087984, 0.8636266764295807, 0.829996774761809, 0.8423788060259654, 0.8629197815227669, 0.21899962030965248, 0.11314949100266747, 0.14653154810591817, 0.17129164676371433, 0.21799433468647045, 0.12469500520154286, 0.1650078309706925, 0.14312723321579668, 0.15760435049425192, 0.1708651549394441, 0.16868492274437852, 0.18225815894447683, 0.22343004416532342, 0.1871387869785126, 0.14779744542572804, 0.19368323413605915, 0.17997725325668212, 0.20245889269292427, 0.11317373292110955, 0.11379152265278314, 0.09279585179388306, 0.1945663827714117, 0.13167676298235986, 0.12693668661533375, 0.14927269738388527, 0.1891941888182409, 0.1345103226347294, 0.1223132435427089, 0.2076219134446332, 0.1610494452869643, 0.1424096182843525, 0.1439102740260596, 0.11289867101858453, 0.15090028381773468, 0.10074087874661841, 0.09398771061455513, 0.0003720345177525841, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.028776880739633803, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00042373405489581906, 0.07941751066175495, 0.08079998876099803, 0.07177673165730869, 0.08431098921112135, 0.08154034416972467, 0.09942304358657128, 0.0794691960356747, 0.058627250449006296, 0.07395413308945264, 0.0043413618890656425, 0.0015523548266497267, 0.005074751715543946, 0.0030511026917799944, 9.999999999998899e-05, 0.03217824929688595, 9.999999999998899e-05, 0.011834726865058487, 0.0018027561854910834, 0.08958670268285973, 0.10359660625717282, 0.097107042034557, 0.050998813775694596, 0.11329161008781252, 0.07292188593462812, 0.05648746034620822, 0.09751910683229204, 0.10183297472218711, 0.31894127829983565, 0.33395588295538325, 0.35443318216400044, 0.4274603726223739, 0.33896696529708825, 0.3770639906920692, 0.369783653456629, 0.3853716716679172, 0.35252064870755817, 0.10152497954771644, 0.10211509740343516, 0.10735160940499211, 0.09574579270716532, 0.11649284295968121, 0.1262435491259214, 0.08978238868164368, 0.093650271997754, 0.10330569129310407, 0.16179950853919234, 0.25378240809505814, 0.16978375756545194, 0.17599100688661362, 0.13181453681960975, 0.2073035549325678, 0.1860145510677701, 0.20497924084791963, 0.18525032393257113, 0.21138683367069555, 0.18757427077911115, 0.21125384167679084, 0.18635528221637832, 0.21132683793766405, 0.23605938389665226, 0.21831577753038556, 0.22264755912661816, 0.20019320792949458, 0.12712841826565213, 0.14198347715912496, 0.1501767574682954, 0.1701128513068112, 0.13482071389019834, 0.1661227938405303, 0.16293909688504105, 0.18867163527132103, 0.14634401333520997, 0.1755894026367537, 0.1769299226388279, 0.17001060436196824, 0.180363813967643, 0.1863238878826835, 0.17367829472004992, 0.18508396060188292, 0.18864452146334265, 0.16930227544201149, 0.16411397611800893, 0.18832239691075037, 0.20958294705152225, 0.18324512955288796, 0.17795641104657645, 0.19688702464926555, 0.1722164887845571, 0.18523460377251144, 0.17604892749856027, 0.528527078041944, 0.342662301567494, 0.24423304190980255, 0.17242622498659388, 0.19268260361029443, 0.23715335292029638, 0.19963471249124998, 0.22744782254547102, 0.2773523514861558, 0.33473904989384184, 0.20262154562082046, 0.2872413142787291, 0.1722800675656594, 0.2762280629206951, 0.23337759883107123, 0.27204109656153386, 0.3114119182490416, 0.2075432933542649, 0.17363003160487955, 0.1835564713310418, 0.18722598001962332, 0.18344462645987636, 0.20661985283983564, 0.1899167049878372, 0.18250642430724884, 0.20550085959774333, 0.18513462964701743, 0.085320131320616, 0.07636215422836956, 0.08036448787053108, 0.059546321721829165, 0.0763159573360701, 0.08359881186778984, 0.09643953351523282, 0.08023937532350589, 0.06683756800494434]}, "mutation_prompt": null}
{"id": "dec5b1ba-d845-4e86-ad02-88cae21f95ee", "solution": "import numpy as np\n\nclass EnhancedHybridDEDynamicPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n        self.dynamic_population_factor = 0.1\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n            \n            # Dynamic Population Resizing\n            if self.evaluations > self.budget * 0.75:\n                new_size = max(4, int(self.population_size * (1 - self.dynamic_population_factor)))\n                population = population[:new_size]\n                self.population_size = new_size\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedHybridDEDynamicPopulation", "description": "An enhanced hybrid algorithm combining Differential Evolution, Adaptive Mutation, Local Search, and Dynamic Population Resizing for adaptive exploration and exploitation.", "configspace": "", "generation": 10, "fitness": 0.21068387041312414, "feedback": "The algorithm EnhancedHybridDEDynamicPopulation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.16.", "error": "", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "c09085c8-bbfb-412f-9ff1-690604e6688b", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "fe2abd72-12b3-4125-b2f7-2b36f3d1e6a1", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "44694555-79a3-42e4-a280-d1da3ad78ba6", "solution": "import numpy as np\n\nclass NovelHybridDEAdaptiveDynamicSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Modified mutation factor\n        self.crossover_rate = 0.85  # Modified crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Enhanced adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Strategic Adaptive Mutation\n                self.mutation_factor = self.adaptive_mutation_factor if np.random.rand() < 0.6 else self.mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.004  # Adjusted step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):  # Enhanced the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Dynamic Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 15)  # Enhanced best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "NovelHybridDEAdaptiveDynamicSearch", "description": "A novel hybrid algorithm combining Differential Evolution with Strategic Adaptive Mutation and Dynamic Local Search for efficient problem-solving.", "configspace": "", "generation": 13, "fitness": 0.18704502122605848, "feedback": "The algorithm NovelHybridDEAdaptiveDynamicSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.4138679027970753, 0.3883921165740345, 0.4207844401981998, 0.42389813442030566, 0.4326409085186226, 0.39999605730272825, 0.44666336283861874, 0.39103175778515376, 0.41260082932661013, 0.03937723282894445, 0.07394007413352888, 0.03757633349413425, 0.04036711005096927, 0.037148645421611226, 0.0410017209458341, 0.03896444586396608, 0.028399186618481176, 0.03539189339072202, 0.10231422846917781, 0.1156179978941877, 0.105642188203807, 0.11728642829334335, 0.11180893059559271, 0.09241352585398654, 0.11473114548949037, 0.1384580292624985, 0.11525884297070699, 0.08389434878956703, 0.09073373046167255, 0.09233616041011394, 0.11756671385169559, 0.0777305417024925, 0.07642079142005809, 0.08190309112899918, 0.09314013739752425, 0.08137275116151954, 0.774386690832179, 0.8040289367260096, 0.8414021048748885, 0.623550898583837, 0.7636808304094787, 0.7049965893716185, 0.778219689360594, 0.751291174746282, 0.723742817781908, 0.1746928882881028, 0.20565902436456185, 0.18719291412240646, 0.15422871976459263, 0.2334041883006266, 0.14747710593366248, 0.15719314758492364, 0.1763944704202156, 0.14345276838879295, 0.19197447063814632, 0.22677122544643347, 0.1765885973216269, 0.33506650069233224, 0.17854726232710294, 0.20691557964084162, 0.19225276638846656, 0.17625691446255898, 0.19633587175723577, 0.15872824553183962, 0.16325866878618656, 0.14717904723094166, 0.12197221809684033, 0.17389634910467944, 0.21310523661988123, 0.17836985811985817, 0.1299489618810965, 0.11303712879809313, 0.12808923072930556, 0.12088552328276492, 0.12300794224571165, 0.13960601563678776, 0.1378874588120822, 0.1263401334878983, 0.16039737798540332, 0.1480436368296254, 0.09571725700406808, 0.07280525516054315, 0.002585460924846794, 0.0009835977707749466, 0.0628872832573556, 0.010309186043128693, 0.005142256343486751, 0.005912036261472298, 0.002821515358964133, 0.00015518007430515013, 0.075781184572291, 0.09655067756872227, 0.09212681096688646, 0.07630036438077792, 0.08329705153626343, 0.07488051541574536, 0.09654533737712478, 0.124766529203867, 0.08062507591083956, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004983134080157603, 0.0031076846218431875, 9.999999999998899e-05, 0.014562350958371106, 0.008650739279880693, 9.999999999998899e-05, 9.999999999998899e-05, 0.09454770848515637, 0.09178919256910145, 0.09828731974745697, 0.11865850041361681, 0.09808111374550732, 0.10040047795016904, 0.09787737627087467, 0.09978810163010143, 0.12158255800144946, 0.3555054888903464, 0.3594938306135511, 0.3379460620583352, 0.37241128427840897, 0.3614411045908239, 0.36069951364573805, 0.37795200413034913, 0.35439739440479945, 0.3971486449479562, 0.07489438067402565, 0.09879661807194517, 0.0954057964598134, 0.12475968106854984, 0.09654858807987399, 0.1306417532153249, 0.09622082741901938, 0.10014276856848903, 0.1120170599382011, 0.19704354601947782, 0.1841353930946097, 0.20352894712085834, 0.17348443952644943, 0.14832595770814727, 0.1681578009069672, 0.1768524312059644, 0.18158571798146228, 0.1579257963182854, 0.20872694707304196, 0.2089055716589211, 0.20838560075120027, 0.20292338679531952, 0.20111774722450604, 0.19917220402354907, 0.23988162349152597, 0.21873611969938278, 0.20523449396180637, 0.15577405319882687, 0.1564652097590501, 0.1593779948615751, 0.16765371035970877, 0.13960819183597029, 0.18681864515842384, 0.1425360002560625, 0.1613560610236593, 0.1739452383494099, 0.17399507975055983, 0.18778197957293252, 0.18483087857028935, 0.18140651293940446, 0.1829326160899264, 0.1812088900279517, 0.17352533889724853, 0.18827696652904524, 0.1921441627140934, 0.1704626052203999, 0.19379882536980153, 0.17502140102360186, 0.1892850240836761, 0.18099481649883398, 0.18292339680368586, 0.17074636968564827, 0.16413726317589772, 0.16784342953859854, 0.29768545465038154, 0.16073878270686093, 0.16406058923129607, 0.18206320354473238, 0.5468363305714008, 0.16184406594007084, 0.3361389356048591, 0.5063184925293982, 0.4142361311565179, 0.3698036712346324, 0.3262495212918787, 0.1832383233084829, 0.18609979695057677, 0.16630004759098005, 0.21671104333085445, 0.19751842035700584, 0.26454598258358997, 0.2719813571997739, 0.20026880241229905, 0.20687829397415647, 0.19637849389188589, 0.19154904014688823, 0.19077346353149538, 0.18473147427364078, 0.1792868375834441, 0.19195524469046454, 0.1955557039436785, 0.08363656034263656, 0.08242716307691533, 0.07408424680791725, 0.09644314165994039, 0.07313875432636252, 0.07099514194389589, 0.0725354084472738, 0.08668137577911317, 0.06798517151462424]}, "mutation_prompt": null}
{"id": "87652452-cdb2-4bb7-bf75-020f1f3e9439", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "f95c67df-7610-44ab-85f5-9c7c80aab0e5", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "d676fc10-e073-4853-b672-100a6af54243", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "5a690076-e9af-4055-8271-0317ef4e5f01", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "dbf3563b-3319-4707-8805-66eb055e6d92", "solution": "import numpy as np\n\nclass EnhancedHybridDEStochasticLocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.evaluations = 0\n        self.dynamic_mutation_factor = 0.55  # Renamed adaptive mutation factor for clarity\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.dynamic_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def stochastic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.007  # Adjusted step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(6):  # Adjusted the number of local search steps\n                perturbation = np.random.normal(0, step_size, self.dim)  # Changed to normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 15)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = stochastic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedHybridDEStochasticLocalSearch", "description": "A stochastic adaptive metaheuristic fusing Enhanced Differential Evolution, Dynamic Mutation, and Stochastic Local Search for optimal exploration-exploitation balance.", "configspace": "", "generation": 18, "fitness": 0.19328335987433162, "feedback": "The algorithm EnhancedHybridDEStochasticLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.38619327622335975, 0.36341249224622685, 0.40618376369445097, 0.38948908206389554, 0.4065719045750825, 0.40381302410142506, 0.4038399222621192, 0.38350487660924804, 0.4141615520444031, 0.057675005464333795, 0.07358035464606327, 0.0655683293444268, 0.07511391398243483, 0.05454798505138336, 0.07461423651427102, 0.04976120954306884, 0.07818614197122498, 0.05247930524550648, 0.10147782972713959, 0.10192424143936618, 0.10644649872527712, 0.09782461905606177, 0.11309458796878658, 0.10626136403294606, 0.1083723887976008, 0.10926970722682527, 0.10264573189019188, 0.08773446918890693, 0.08250030325151436, 0.07785410694672823, 0.09117464633356553, 0.08742698801582482, 0.08555157108027356, 0.08953236170203871, 0.08295390880747877, 0.08908641123739691, 0.8185865121567982, 0.861999079794322, 0.7822183188309537, 0.8060403052112028, 0.77136635694259, 0.7027209769275073, 0.775319643676761, 0.7529692448249938, 0.7522960605201895, 0.2101647979430451, 0.22623843559922852, 0.18297323142639266, 0.19801787589112463, 0.14959895977665694, 0.20260864903609477, 0.1791353671104009, 0.21407442373777708, 0.18610155470479284, 0.2336194181447684, 0.2807176352450904, 0.21632050167328076, 0.2608716715043624, 0.25916740500717206, 0.24010608332915673, 0.22555431843793516, 0.26284870591450593, 0.2288934288681398, 0.12105828076035907, 0.15427998692050138, 0.12297198582196289, 0.13759461502808024, 0.12526830979285364, 0.1420239587820542, 0.13618585702264485, 0.13408984056495377, 0.17446094113255406, 0.11576962085676146, 0.10472249048532789, 0.12409310834292864, 0.1404463177088483, 0.1370860003847556, 0.11779032788040478, 0.12148296838139927, 0.1477623235503468, 0.14421800816056385, 0.003398208118030155, 0.007793181874939714, 0.004607833354447255, 0.0399996519512551, 0.004849036223246506, 0.0029565154193809118, 0.004990573280341248, 0.012278984847855612, 0.006070546776253627, 0.08318765057528743, 0.10327667818425346, 0.08993493786291296, 0.09265429292205918, 0.09645959192345854, 0.08938345357522304, 0.07443447081380505, 0.1262431315175554, 0.10649038980704206, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09258622209311729, 0.07349210430968378, 0.09079110431674597, 0.06843594342379178, 0.08976311914265167, 0.08430022908785106, 0.08377044975795378, 0.09379720073654807, 0.0850948768083335, 0.3430694962146621, 0.35205071375747143, 0.36573441849651167, 0.3602116922025195, 0.3444789123515617, 0.35600121940208107, 0.37652837840040365, 0.3356523803927769, 0.41881080620358857, 0.09378702090128466, 0.10336784640993124, 0.09472654958072058, 0.09741373468624448, 0.0973307232897348, 0.13147099383581384, 0.08393883219549281, 0.08127840427643584, 0.12088044317483726, 0.16068902623744852, 0.22815395775741898, 0.17139771477339705, 0.17572294733092808, 0.21970706062057532, 0.1914759368057254, 0.22966628481460727, 0.15856616214318253, 0.19253197292931323, 0.23778447149350868, 0.23068123824749953, 0.2514161014583488, 0.22506027809538354, 0.2201497170876946, 0.218594694813513, 0.24233471216705693, 0.24789229714351946, 0.22484636982073003, 0.17265344619288503, 0.16910748436462486, 0.1797964188855642, 0.18175125967039762, 0.15654609263096952, 0.167246022593745, 0.16194477411347785, 0.18365314101635122, 0.18219772340309914, 0.19372377260628604, 0.18136983926895056, 0.17984429295037263, 0.17605075058490127, 0.18953699854810324, 0.18725766696501756, 0.16436885263783918, 0.19368906214054515, 0.20947428902284138, 0.1799531360005907, 0.1794110692341201, 0.16105214664431133, 0.19115012071689252, 0.22118393201196973, 0.172021523139553, 0.17829947328275486, 0.21808625326169673, 0.1783945715058335, 0.4454312608243223, 0.34919759005143014, 0.20046832963523142, 0.4811856187739074, 0.5139205000319368, 0.45137626808355213, 0.30675773994631494, 0.4250961778327724, 0.16948380946258346, 0.3883631049085716, 0.3403810578538874, 0.21064201901783752, 0.20228339167418696, 0.220873998348305, 0.22583314083543093, 0.19734193573523984, 0.22984365345139235, 0.20126578018454255, 0.20984603452066708, 0.18435800252383427, 0.18412186960432764, 0.19726769609331163, 0.19133911836113016, 0.1758859509995605, 0.17945467934961656, 0.18764677612405845, 0.17977168628929974, 0.06782169246829528, 0.06610612664819404, 0.06657166456999308, 0.07366918029808056, 0.06714410070303367, 0.06467367755319342, 0.09364493541279284, 0.08066084111502692, 0.07270630713673376]}, "mutation_prompt": null}
{"id": "0c6d2a22-7028-4c14-b123-98dfe3e09c91", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "ae8fcd70-4604-4e5f-a7ab-5042d5fd7636", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "bfa0208f-3410-4b8f-b67d-483abd50fc47", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "f1a6aad5-7ced-4ca6-8187-960e16a2e4c2", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "4e12559f-8f39-489d-a8bb-334bdf3acd25", "solution": "import numpy as np\n\nclass RefinedHybridDELocalSearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Added adaptive mutation factor\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Adaptive mutation step\n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):  # Adjusted the number of local search steps\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        # Initialize random population\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            # Perform Differential Evolution\n            population = differential_evolution(population)\n            \n            # Apply Local Search to the best individuals\n            if self.evaluations < self.budget / 2:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 20)  # Adjusted best individuals count\n                for i in range(min(best_count, len(population))):\n                    population[i] = local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        # Return the best solution found\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedHybridDELocalSearch", "description": "A refined hybrid metaheuristic combining Differential Evolution, Adaptive Mutation, and Local Search for improved exploration and exploitation.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46002989805289074, 0.45858976028822585, 0.4756235685670709, 0.4833930731641438, 0.45177271570829525, 0.46014796163103555, 0.45804238732947855, 0.45322296766599535, 0.4565463769271215, 0.14178020708259942, 0.15278198934877296, 0.09781079994647768, 0.10426184431826713, 0.11336730463023414, 0.09783575705014069, 0.10858561317242166, 0.11672711687491555, 0.12270510177691629, 0.09583417989476506, 0.10823765916611805, 0.13678091319566776, 0.09753584542072735, 0.114761252167484, 0.09605437629316893, 0.09819141934631226, 0.09874676685870576, 0.10701189910041253, 0.1152994156792454, 0.08982007788402058, 0.08718708205281478, 0.10117455890251748, 0.09773333668003237, 0.11329508800386734, 0.1008707835982472, 0.11249640117845716, 0.09180689925425034, 0.6432479871882977, 0.7821600530068112, 0.683700761760674, 0.8005091732812981, 0.7676028404775079, 0.7495148163546616, 0.7099964986519349, 0.7214924496792919, 0.8437786553674955, 0.2895146811855628, 0.1851215552809563, 0.18068777781958578, 0.21760932237527109, 0.22671483381003965, 0.25437850305778875, 0.2896217892517906, 0.22091028060805906, 0.21017761069314378, 0.3061945116821033, 0.4643259826253827, 0.2780995808293397, 0.33293185713930873, 0.2548755060124006, 0.30083640598920025, 0.28464361589980225, 0.33460863145237496, 0.29283781911672924, 0.12912768192167956, 0.12422124540111856, 0.10976323810211164, 0.12416025800809671, 0.13940255185532913, 0.12530348365408972, 0.19556875471103596, 0.17942481999811588, 0.14193730811772565, 0.14549063164281129, 0.13612040867842534, 0.1375855233893879, 0.17015868840022907, 0.16539317464705472, 0.18395349390250582, 0.15792249525013502, 0.12826257352794912, 0.16954007885465194, 0.030691890698885116, 0.040664913314747864, 0.0874333569630924, 0.03549109010196139, 0.028292237692458366, 0.03196654023349477, 0.05829076612450901, 0.03755853443027901, 0.02867640232683244, 0.18474837450453674, 0.13411020481597002, 0.12225176871609578, 0.11592091227998502, 0.17633790565957574, 0.1454117959272767, 0.16887893725248015, 0.18675778145117505, 0.15571426693668633, 0.0038592252302187546, 0.01081749938781773, 0.012439755883734138, 0.0024052650139853027, 9.999999999998899e-05, 0.038177374178617884, 0.015944532648999865, 0.0005909231306699958, 0.006440412748104252, 0.1336357698221522, 0.09045020897203015, 0.09671963743088285, 0.09246288232923328, 0.0937722660861755, 0.12301873595991397, 0.1004039077531419, 0.10080594624986439, 0.10082481845675151, 0.3667354848198676, 0.3644633093170979, 0.3939537027625052, 0.39166546966497373, 0.42066680206987495, 0.3515849673275776, 0.4011605113758395, 0.3481186412067585, 0.388622661077769, 0.08903348641858688, 0.10169918362586683, 0.11972456137648224, 0.14457395589003408, 0.10582989203124749, 0.15506162709233484, 0.10481681666094611, 0.11444091800450129, 0.10591818138631592, 0.2828581538581265, 0.17304857057858025, 0.19375182427796211, 0.14965455201750721, 0.20348156922342675, 0.21932310457331317, 0.1790382407041694, 0.1980368665534945, 0.19321562382871194, 0.26359945439325916, 0.23787672872786758, 0.27325600335274935, 0.22805848245785054, 0.2463773443027184, 0.2195591212589355, 0.24642390198940867, 0.24786079673772288, 0.24848268036867416, 0.18147518484964598, 0.16824809094339777, 0.1902059624883442, 0.18868132235513402, 0.17720328173004274, 0.16482671015397632, 0.1826825414134211, 0.2087772502575297, 0.19129553406928923, 0.17928249162579235, 0.18034382206320299, 0.21931675938069606, 0.21243580239171556, 0.19651648179647463, 0.22535602685023515, 0.16833709199126878, 0.20313478387478434, 0.17248058506546926, 0.1816132155962118, 0.20960330015920925, 0.1983557377716446, 0.2110389600225563, 0.17427260936144062, 0.19658863419071326, 0.19639093644074979, 0.17916479801357832, 0.1960965369848987, 0.5543335907636153, 0.1741909851641119, 0.18988814298557122, 0.6174426438678045, 0.19459330012732012, 0.45553559422992074, 0.3889677802582544, 0.4175841825684259, 0.20116668620053146, 0.3756566409961172, 0.20454998224470633, 0.22681978932561908, 0.22393119088548474, 0.20436975440556238, 0.1949706385544916, 0.1488630824865833, 0.14599733101486578, 0.3983582284240742, 0.17642967763551043, 0.17821372209907582, 0.2020089999274831, 0.18354817039556248, 0.1906697030346579, 0.17391650235495215, 0.19134626866803917, 0.21886390367819664, 0.18133083224106628, 0.07322620731404861, 0.07857959786063018, 0.07779619975658147, 0.08263194218073755, 0.0901695958534281, 0.07479707415253001, 0.0761379217819449, 0.08224577508419884, 0.07532757797521195]}, "mutation_prompt": null}
{"id": "19f6e3d2-0ae8-46ad-9382-b8d213a2cc11", "solution": "import numpy as np\n\nclass AdaptiveNeighborhoodDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.007\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 18)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "AdaptiveNeighborhoodDE", "description": "An adaptive differential evolution with integrated neighborhood search and dynamic population adjustment for versatile optimization.", "configspace": "", "generation": 24, "fitness": 0.2180514099219028, "feedback": "The algorithm AdaptiveNeighborhoodDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "63e543de-9a4c-4ccc-b9e0-662205fa3c21", "metadata": {"aucs": [0.46462004312208605, 0.4858421023622024, 0.4733841383814551, 0.45571985092416434, 0.4852937590847748, 0.45573773199718803, 0.4422590032313568, 0.4842413604201925, 0.47840248066080704, 0.08417833047748502, 0.09104049390775693, 0.11487575304712483, 0.12896923093938528, 0.10813588283982445, 0.1206466937184636, 0.09887113025699257, 0.10585731553110855, 0.10277435965905002, 0.14286858299698035, 0.08216636663636145, 0.1339041975508808, 0.12613898407345037, 0.10883659186308525, 0.14791590154988243, 0.11516174301646864, 0.12019964684808815, 0.09217145517470804, 0.10101079148687409, 0.09385845322499842, 0.09186433759490298, 0.09500269484915191, 0.09105321570791025, 0.10311506724808173, 0.08381624968408774, 0.09527436162234004, 0.11531622675971498, 0.792962441651647, 0.8735386532366285, 0.7250211646595326, 0.795854121382654, 0.8860392894692736, 0.8086081892006043, 0.7606463919261882, 0.8491190796378981, 0.8109013417968202, 0.2968560784190346, 0.2263251691125956, 0.22743332967847674, 0.2833681240967074, 0.21502175471912555, 0.25969022203574144, 0.27728211907129985, 0.23203234362542258, 0.2461613602033389, 0.23944668618164378, 0.34589776527248783, 0.23553112530948261, 0.5260483642578033, 0.37062914329010677, 0.24750279199150604, 0.30788589910669084, 0.2717620393654768, 0.25898907951836025, 0.18216444990539993, 0.1318636708031663, 0.20183557309347877, 0.1935463038820744, 0.15121729746633306, 0.2131634031051972, 0.1812017842431749, 0.15035148095533313, 0.1595656907876657, 0.20022431171088662, 0.13697508223856325, 0.17793027888227553, 0.13883272448174844, 0.14093171416320516, 0.14674972247136098, 0.15900921608549456, 0.1550892562049816, 0.12478680085932115, 0.07797214528511098, 0.013980123624510843, 0.0451747127066503, 0.03805016887421386, 0.007331735365790015, 0.0028350466557518494, 0.023036279793197, 0.029344907552549704, 0.02012575968775987, 0.14863724653286225, 0.11237794010887736, 0.09444897637840755, 0.1174380356625494, 0.07561572262071281, 0.1389538177405748, 0.1567801978078298, 0.11343315828909584, 0.13357143622921708, 9.999999999998899e-05, 0.0008696625810095115, 9.999999999998899e-05, 9.999999999998899e-05, 0.003145176015766249, 0.014302919392596425, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09650471106528125, 0.10235233134643129, 0.10986025500208074, 0.08571096495174513, 0.09751473620670237, 0.10456708362586198, 0.10949527011589366, 0.09884265506465739, 0.126011569238636, 0.40079478910209443, 0.3727383974212807, 0.4234603628476731, 0.39759075028806135, 0.4412181021605922, 0.41939172674566716, 0.40994269657287696, 0.3977031998772508, 0.4092402029831693, 0.07777082195716534, 0.11005273277088634, 0.10184471740594614, 0.10160603429869375, 0.11867078149628685, 0.1475291468696982, 0.07497711343782443, 0.09537306707782423, 0.13031066586949125, 0.21828670730848343, 0.15417344439928604, 0.3380551715151683, 0.1470603043190586, 0.23774068686858085, 0.18846116369104593, 0.18912241425574006, 0.15671552952857382, 0.17581121734470584, 0.21520884660020445, 0.24130376876061288, 0.26525645792715324, 0.22619417328477764, 0.27713354489183994, 0.25525369845312773, 0.2410835135726812, 0.2629089499409575, 0.23947399722013119, 0.17560928745277216, 0.21152648118373385, 0.19006005730236286, 0.16986205659380016, 0.15786984308844143, 0.18897376350381523, 0.18194615843565032, 0.21046560831549954, 0.22277228331670718, 0.20660928972834292, 0.20941520113282885, 0.16791459842642475, 0.16551715685856194, 0.17646511448900237, 0.18674273313702106, 0.1863076734538739, 0.1729452191768467, 0.20188304114578615, 0.18404801169454776, 0.18447434684384012, 0.3127871214450625, 0.18764769108969248, 0.16988659162717745, 0.20156273890733567, 0.2163779518194403, 0.18589393199301485, 0.21344826889047752, 0.4473708571155356, 0.5775220367677258, 0.4906255322541786, 0.6573407762383779, 0.19761045627489626, 0.18851672803797648, 0.16652624365017688, 0.4079886494714894, 0.17143048552717133, 0.5226245146534678, 0.35234677120464564, 0.28854607391495446, 0.18591029572797801, 0.18900902202164038, 0.3668644519513342, 0.3605936409027304, 0.20646630000278288, 0.27961894134410636, 0.17865106832249, 0.19110320574559514, 0.19075685456096103, 0.19433138224622137, 0.20907762222592696, 0.1722745825028671, 0.1820911408518272, 0.18128220993842536, 0.1723610149221737, 0.08228834661893014, 0.07330411613034504, 0.08211152678890199, 0.07763445863901364, 0.09206111628103941, 0.08483231050585949, 0.07351617123167908, 0.08165813052651816, 0.08898428438647299]}, "mutation_prompt": null}
{"id": "7ff282ef-71c9-45e5-8446-bfe42ad6f1ff", "solution": "import numpy as np\n\nclass AdaptiveNeighborhoodDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.007\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 18)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "AdaptiveNeighborhoodDE", "description": "An adaptive differential evolution with integrated neighborhood search and dynamic population adjustment for versatile optimization.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "19f6e3d2-0ae8-46ad-9382-b8d213a2cc11", "metadata": {"aucs": [0.46462004312208605, 0.4858421023622024, 0.4733841383814551, 0.45571985092416434, 0.4852937590847748, 0.45573773199718803, 0.4422590032313568, 0.4842413604201925, 0.47840248066080704, 0.08417833047748502, 0.09104049390775693, 0.11487575304712483, 0.12896923093938528, 0.10813588283982445, 0.1206466937184636, 0.09887113025699257, 0.10585731553110855, 0.10277435965905002, 0.14286858299698035, 0.08216636663636145, 0.1339041975508808, 0.12613898407345037, 0.10883659186308525, 0.14791590154988243, 0.11516174301646864, 0.12019964684808815, 0.09217145517470804, 0.10101079148687409, 0.09385845322499842, 0.09186433759490298, 0.09500269484915191, 0.09105321570791025, 0.10311506724808173, 0.08381624968408774, 0.09527436162234004, 0.11531622675971498, 0.792962441651647, 0.8735386532366285, 0.7250211646595326, 0.795854121382654, 0.8860392894692736, 0.8086081892006043, 0.7606463919261882, 0.8491190796378981, 0.8109013417968202, 0.2968560784190346, 0.2263251691125956, 0.22743332967847674, 0.2833681240967074, 0.21502175471912555, 0.25969022203574144, 0.27728211907129985, 0.23203234362542258, 0.2461613602033389, 0.23944668618164378, 0.34589776527248783, 0.23553112530948261, 0.5260483642578033, 0.37062914329010677, 0.24750279199150604, 0.30788589910669084, 0.2717620393654768, 0.25898907951836025, 0.18216444990539993, 0.1318636708031663, 0.20183557309347877, 0.1935463038820744, 0.15121729746633306, 0.2131634031051972, 0.1812017842431749, 0.15035148095533313, 0.1595656907876657, 0.20022431171088662, 0.13697508223856325, 0.17793027888227553, 0.13883272448174844, 0.14093171416320516, 0.14674972247136098, 0.15900921608549456, 0.1550892562049816, 0.12478680085932115, 0.07797214528511098, 0.013980123624510843, 0.0451747127066503, 0.03805016887421386, 0.007331735365790015, 0.0028350466557518494, 0.023036279793197, 0.029344907552549704, 0.02012575968775987, 0.14863724653286225, 0.11237794010887736, 0.09444897637840755, 0.1174380356625494, 0.07561572262071281, 0.1389538177405748, 0.1567801978078298, 0.11343315828909584, 0.13357143622921708, 9.999999999998899e-05, 0.0008696625810095115, 9.999999999998899e-05, 9.999999999998899e-05, 0.003145176015766249, 0.014302919392596425, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09650471106528125, 0.10235233134643129, 0.10986025500208074, 0.08571096495174513, 0.09751473620670237, 0.10456708362586198, 0.10949527011589366, 0.09884265506465739, 0.126011569238636, 0.40079478910209443, 0.3727383974212807, 0.4234603628476731, 0.39759075028806135, 0.4412181021605922, 0.41939172674566716, 0.40994269657287696, 0.3977031998772508, 0.4092402029831693, 0.07777082195716534, 0.11005273277088634, 0.10184471740594614, 0.10160603429869375, 0.11867078149628685, 0.1475291468696982, 0.07497711343782443, 0.09537306707782423, 0.13031066586949125, 0.21828670730848343, 0.15417344439928604, 0.3380551715151683, 0.1470603043190586, 0.23774068686858085, 0.18846116369104593, 0.18912241425574006, 0.15671552952857382, 0.17581121734470584, 0.21520884660020445, 0.24130376876061288, 0.26525645792715324, 0.22619417328477764, 0.27713354489183994, 0.25525369845312773, 0.2410835135726812, 0.2629089499409575, 0.23947399722013119, 0.17560928745277216, 0.21152648118373385, 0.19006005730236286, 0.16986205659380016, 0.15786984308844143, 0.18897376350381523, 0.18194615843565032, 0.21046560831549954, 0.22277228331670718, 0.20660928972834292, 0.20941520113282885, 0.16791459842642475, 0.16551715685856194, 0.17646511448900237, 0.18674273313702106, 0.1863076734538739, 0.1729452191768467, 0.20188304114578615, 0.18404801169454776, 0.18447434684384012, 0.3127871214450625, 0.18764769108969248, 0.16988659162717745, 0.20156273890733567, 0.2163779518194403, 0.18589393199301485, 0.21344826889047752, 0.4473708571155356, 0.5775220367677258, 0.4906255322541786, 0.6573407762383779, 0.19761045627489626, 0.18851672803797648, 0.16652624365017688, 0.4079886494714894, 0.17143048552717133, 0.5226245146534678, 0.35234677120464564, 0.28854607391495446, 0.18591029572797801, 0.18900902202164038, 0.3668644519513342, 0.3605936409027304, 0.20646630000278288, 0.27961894134410636, 0.17865106832249, 0.19110320574559514, 0.19075685456096103, 0.19433138224622137, 0.20907762222592696, 0.1722745825028671, 0.1820911408518272, 0.18128220993842536, 0.1723610149221737, 0.08228834661893014, 0.07330411613034504, 0.08211152678890199, 0.07763445863901364, 0.09206111628103941, 0.08483231050585949, 0.07351617123167908, 0.08165813052651816, 0.08898428438647299]}, "mutation_prompt": null}
{"id": "eb805d07-75c2-4f53-b061-59962717c1e6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n        self.diversity_threshold = 0.1\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                self.mutation_factor = self.adaptive_mutation_factor if np.random.rand() < 0.5 else self.mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def probabilistic_neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.007\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n        \n        def preserve_diversity(population):\n            diversity = np.std(population, axis=0)\n            if np.any(diversity < self.diversity_threshold):\n                additional_population = np.random.uniform(*self.bounds, (self.population_size // 5, self.dim))\n                population = np.vstack((population, additional_population))\n                population = population[:self.population_size]\n            return population\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            population = preserve_diversity(population)\n            \n            if self.evaluations < self.budget * 0.6:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 18)\n                for i in range(min(best_count, len(population))):\n                    population[i] = probabilistic_neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive DE with probabilistic neighborhood and dynamic diversity preservation for robust optimization.", "configspace": "", "generation": 26, "fitness": 0.21734447189618086, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "19f6e3d2-0ae8-46ad-9382-b8d213a2cc11", "metadata": {"aucs": [0.46534814648507283, 0.482693887385519, 0.4712024552010776, 0.4746461192006518, 0.4737137470678995, 0.4474549924689595, 0.4451095030797708, 0.48303853269013175, 0.47420101824751126, 0.09089212011412273, 0.1104818632610377, 0.08871979258089902, 0.12338203349516608, 0.11759102157174217, 0.105047488674329, 0.10339954493421155, 0.10727636416376995, 0.1317935370808656, 0.14286858299698035, 0.08216636663636145, 0.1339041975508808, 0.12613898407345037, 0.10883659186308525, 0.14791590154988243, 0.11516174301646864, 0.12019964684808815, 0.09217145517470804, 0.10101079148687409, 0.09385845322499842, 0.09186433759490298, 0.09500269484915191, 0.09105321570791025, 0.10311506724808173, 0.08381624968408774, 0.09527436162234004, 0.11531622675971498, 0.792962441651647, 0.8735386532366285, 0.7418679011735906, 0.7497369598182837, 0.8860392894692736, 0.8086081892006043, 0.7422811988700516, 0.8491190796378981, 0.8108877188850484, 0.2968560784190346, 0.2263251691125956, 0.22743332967847674, 0.2833681240967074, 0.21502175471912555, 0.25969022203574144, 0.27728211907129985, 0.23346413895741103, 0.2461613602033389, 0.23944668618164378, 0.34589776527248783, 0.23553112530948261, 0.5260483642578033, 0.37062914329010677, 0.24750279199150604, 0.2768160236213809, 0.2717620393654768, 0.2596608943153622, 0.18216444990539993, 0.13185801840653288, 0.20183557309347877, 0.1935463038820744, 0.14870708185478432, 0.2131634031051972, 0.18108657578355447, 0.15213642766822955, 0.1595656907876657, 0.2002703736841488, 0.13686825955363513, 0.17793027888227553, 0.13908607733203737, 0.14129372035364007, 0.14674972247136098, 0.15900921608549456, 0.15337982261693728, 0.12478680085932115, 0.07797214528511098, 0.013980123624510843, 0.0451747127066503, 0.03805016887421386, 0.007331735365790015, 0.0028350466557518494, 0.023036279793197, 0.029344907552549704, 0.02012575968775987, 0.14863724653286225, 0.11237794010887736, 0.09444897637840755, 0.1174380356625494, 0.07561572262071281, 0.1389538177405748, 0.1567801978078298, 0.11343315828909584, 0.13357143622921708, 9.999999999998899e-05, 0.0008696625810095115, 9.999999999998899e-05, 9.999999999998899e-05, 0.003145176015766249, 0.014302919392596425, 9.999999999998899e-05, 0.002224208188700283, 9.999999999998899e-05, 0.1022011863282205, 0.10221472676115995, 0.10724648686288807, 0.082389323383812, 0.09348315473848778, 0.10169392267579136, 0.10949527011589366, 0.09884265506465739, 0.12582654684042194, 0.37814438923080895, 0.3642904811630827, 0.42150210974759006, 0.3871679410813126, 0.43017454484857975, 0.42957336335723784, 0.4058395143022915, 0.38680333720923465, 0.4086597464788445, 0.07777082195716534, 0.11005273277088634, 0.10184471740594614, 0.10160603429869375, 0.11867078149628685, 0.1475291468696982, 0.07497711343782443, 0.09537306707782423, 0.13031066586949125, 0.21828670730848343, 0.15417344439928604, 0.3380551715151683, 0.1470603043190586, 0.23774068686858085, 0.18846116369104593, 0.18912241425574006, 0.15671552952857382, 0.17581121734470584, 0.21520884660020445, 0.24130376876061288, 0.26525645792715324, 0.22619417328477764, 0.27713354489183994, 0.25525369845312773, 0.24023215563499645, 0.2629089499409575, 0.23947399722013119, 0.17560928745277216, 0.21152648118373385, 0.19006005730236286, 0.16986205659380016, 0.15786984308844143, 0.18897376350381523, 0.18194615843565032, 0.21107782603060155, 0.22277228331670718, 0.20660928972834292, 0.20941520113282885, 0.16791459842642475, 0.16551715685856194, 0.17646511448900237, 0.18674273313702106, 0.1863076734538739, 0.1729452191768467, 0.20188304114578615, 0.18404801169454776, 0.18447434684384012, 0.3127871214450625, 0.18764769108969248, 0.16988659162717745, 0.20156273890733567, 0.2163779518194403, 0.18589393199301485, 0.21344826889047752, 0.4473708571155356, 0.5698955852336363, 0.4906255322541786, 0.6573407762383779, 0.19761045627489626, 0.18851672803797648, 0.16652624365017688, 0.4079886494714894, 0.17143048552717133, 0.5226245146534678, 0.35234677120464564, 0.28854607391495446, 0.18591029572797801, 0.18900860399488661, 0.3668644519513342, 0.3605936409027304, 0.2064643266635885, 0.2635291713948451, 0.17865106832249, 0.19110320574559514, 0.19075685456096103, 0.19433138224622137, 0.20907762222592696, 0.1722745825028671, 0.1820911408518272, 0.18128220993842536, 0.1723610149221737, 0.08228834661893014, 0.07330411613034504, 0.08211152678890199, 0.07763445863901364, 0.09206111628103941, 0.08483231050585949, 0.07351617123167908, 0.08165813052651816, 0.08898428438647299]}, "mutation_prompt": null}
{"id": "a19efede-6a19-4416-8a37-3d8a73b98495", "solution": "import numpy as np\n\nclass AdaptiveNeighborhoodDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.007\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 18)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "AdaptiveNeighborhoodDE", "description": "An adaptive differential evolution with integrated neighborhood search and dynamic population adjustment for versatile optimization.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "19f6e3d2-0ae8-46ad-9382-b8d213a2cc11", "metadata": {"aucs": [0.46462004312208605, 0.4858421023622024, 0.4733841383814551, 0.45571985092416434, 0.4852937590847748, 0.45573773199718803, 0.4422590032313568, 0.4842413604201925, 0.47840248066080704, 0.08417833047748502, 0.09104049390775693, 0.11487575304712483, 0.12896923093938528, 0.10813588283982445, 0.1206466937184636, 0.09887113025699257, 0.10585731553110855, 0.10277435965905002, 0.14286858299698035, 0.08216636663636145, 0.1339041975508808, 0.12613898407345037, 0.10883659186308525, 0.14791590154988243, 0.11516174301646864, 0.12019964684808815, 0.09217145517470804, 0.10101079148687409, 0.09385845322499842, 0.09186433759490298, 0.09500269484915191, 0.09105321570791025, 0.10311506724808173, 0.08381624968408774, 0.09527436162234004, 0.11531622675971498, 0.792962441651647, 0.8735386532366285, 0.7250211646595326, 0.795854121382654, 0.8860392894692736, 0.8086081892006043, 0.7606463919261882, 0.8491190796378981, 0.8109013417968202, 0.2968560784190346, 0.2263251691125956, 0.22743332967847674, 0.2833681240967074, 0.21502175471912555, 0.25969022203574144, 0.27728211907129985, 0.23203234362542258, 0.2461613602033389, 0.23944668618164378, 0.34589776527248783, 0.23553112530948261, 0.5260483642578033, 0.37062914329010677, 0.24750279199150604, 0.30788589910669084, 0.2717620393654768, 0.25898907951836025, 0.18216444990539993, 0.1318636708031663, 0.20183557309347877, 0.1935463038820744, 0.15121729746633306, 0.2131634031051972, 0.1812017842431749, 0.15035148095533313, 0.1595656907876657, 0.20022431171088662, 0.13697508223856325, 0.17793027888227553, 0.13883272448174844, 0.14093171416320516, 0.14674972247136098, 0.15900921608549456, 0.1550892562049816, 0.12478680085932115, 0.07797214528511098, 0.013980123624510843, 0.0451747127066503, 0.03805016887421386, 0.007331735365790015, 0.0028350466557518494, 0.023036279793197, 0.029344907552549704, 0.02012575968775987, 0.14863724653286225, 0.11237794010887736, 0.09444897637840755, 0.1174380356625494, 0.07561572262071281, 0.1389538177405748, 0.1567801978078298, 0.11343315828909584, 0.13357143622921708, 9.999999999998899e-05, 0.0008696625810095115, 9.999999999998899e-05, 9.999999999998899e-05, 0.003145176015766249, 0.014302919392596425, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09650471106528125, 0.10235233134643129, 0.10986025500208074, 0.08571096495174513, 0.09751473620670237, 0.10456708362586198, 0.10949527011589366, 0.09884265506465739, 0.126011569238636, 0.40079478910209443, 0.3727383974212807, 0.4234603628476731, 0.39759075028806135, 0.4412181021605922, 0.41939172674566716, 0.40994269657287696, 0.3977031998772508, 0.4092402029831693, 0.07777082195716534, 0.11005273277088634, 0.10184471740594614, 0.10160603429869375, 0.11867078149628685, 0.1475291468696982, 0.07497711343782443, 0.09537306707782423, 0.13031066586949125, 0.21828670730848343, 0.15417344439928604, 0.3380551715151683, 0.1470603043190586, 0.23774068686858085, 0.18846116369104593, 0.18912241425574006, 0.15671552952857382, 0.17581121734470584, 0.21520884660020445, 0.24130376876061288, 0.26525645792715324, 0.22619417328477764, 0.27713354489183994, 0.25525369845312773, 0.2410835135726812, 0.2629089499409575, 0.23947399722013119, 0.17560928745277216, 0.21152648118373385, 0.19006005730236286, 0.16986205659380016, 0.15786984308844143, 0.18897376350381523, 0.18194615843565032, 0.21046560831549954, 0.22277228331670718, 0.20660928972834292, 0.20941520113282885, 0.16791459842642475, 0.16551715685856194, 0.17646511448900237, 0.18674273313702106, 0.1863076734538739, 0.1729452191768467, 0.20188304114578615, 0.18404801169454776, 0.18447434684384012, 0.3127871214450625, 0.18764769108969248, 0.16988659162717745, 0.20156273890733567, 0.2163779518194403, 0.18589393199301485, 0.21344826889047752, 0.4473708571155356, 0.5775220367677258, 0.4906255322541786, 0.6573407762383779, 0.19761045627489626, 0.18851672803797648, 0.16652624365017688, 0.4079886494714894, 0.17143048552717133, 0.5226245146534678, 0.35234677120464564, 0.28854607391495446, 0.18591029572797801, 0.18900902202164038, 0.3668644519513342, 0.3605936409027304, 0.20646630000278288, 0.27961894134410636, 0.17865106832249, 0.19110320574559514, 0.19075685456096103, 0.19433138224622137, 0.20907762222592696, 0.1722745825028671, 0.1820911408518272, 0.18128220993842536, 0.1723610149221737, 0.08228834661893014, 0.07330411613034504, 0.08211152678890199, 0.07763445863901364, 0.09206111628103941, 0.08483231050585949, 0.07351617123167908, 0.08165813052651816, 0.08898428438647299]}, "mutation_prompt": null}
{"id": "204166a3-85ca-49ec-9e81-1bb5a0e9d161", "solution": "import numpy as np\n\nclass AdaptiveNeighborhoodDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.007\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 18)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "AdaptiveNeighborhoodDE", "description": "An adaptive differential evolution with integrated neighborhood search and dynamic population adjustment for versatile optimization.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "19f6e3d2-0ae8-46ad-9382-b8d213a2cc11", "metadata": {"aucs": [0.46462004312208605, 0.4858421023622024, 0.4733841383814551, 0.45571985092416434, 0.4852937590847748, 0.45573773199718803, 0.4422590032313568, 0.4842413604201925, 0.47840248066080704, 0.08417833047748502, 0.09104049390775693, 0.11487575304712483, 0.12896923093938528, 0.10813588283982445, 0.1206466937184636, 0.09887113025699257, 0.10585731553110855, 0.10277435965905002, 0.14286858299698035, 0.08216636663636145, 0.1339041975508808, 0.12613898407345037, 0.10883659186308525, 0.14791590154988243, 0.11516174301646864, 0.12019964684808815, 0.09217145517470804, 0.10101079148687409, 0.09385845322499842, 0.09186433759490298, 0.09500269484915191, 0.09105321570791025, 0.10311506724808173, 0.08381624968408774, 0.09527436162234004, 0.11531622675971498, 0.792962441651647, 0.8735386532366285, 0.7250211646595326, 0.795854121382654, 0.8860392894692736, 0.8086081892006043, 0.7606463919261882, 0.8491190796378981, 0.8109013417968202, 0.2968560784190346, 0.2263251691125956, 0.22743332967847674, 0.2833681240967074, 0.21502175471912555, 0.25969022203574144, 0.27728211907129985, 0.23203234362542258, 0.2461613602033389, 0.23944668618164378, 0.34589776527248783, 0.23553112530948261, 0.5260483642578033, 0.37062914329010677, 0.24750279199150604, 0.30788589910669084, 0.2717620393654768, 0.25898907951836025, 0.18216444990539993, 0.1318636708031663, 0.20183557309347877, 0.1935463038820744, 0.15121729746633306, 0.2131634031051972, 0.1812017842431749, 0.15035148095533313, 0.1595656907876657, 0.20022431171088662, 0.13697508223856325, 0.17793027888227553, 0.13883272448174844, 0.14093171416320516, 0.14674972247136098, 0.15900921608549456, 0.1550892562049816, 0.12478680085932115, 0.07797214528511098, 0.013980123624510843, 0.0451747127066503, 0.03805016887421386, 0.007331735365790015, 0.0028350466557518494, 0.023036279793197, 0.029344907552549704, 0.02012575968775987, 0.14863724653286225, 0.11237794010887736, 0.09444897637840755, 0.1174380356625494, 0.07561572262071281, 0.1389538177405748, 0.1567801978078298, 0.11343315828909584, 0.13357143622921708, 9.999999999998899e-05, 0.0008696625810095115, 9.999999999998899e-05, 9.999999999998899e-05, 0.003145176015766249, 0.014302919392596425, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09650471106528125, 0.10235233134643129, 0.10986025500208074, 0.08571096495174513, 0.09751473620670237, 0.10456708362586198, 0.10949527011589366, 0.09884265506465739, 0.126011569238636, 0.40079478910209443, 0.3727383974212807, 0.4234603628476731, 0.39759075028806135, 0.4412181021605922, 0.41939172674566716, 0.40994269657287696, 0.3977031998772508, 0.4092402029831693, 0.07777082195716534, 0.11005273277088634, 0.10184471740594614, 0.10160603429869375, 0.11867078149628685, 0.1475291468696982, 0.07497711343782443, 0.09537306707782423, 0.13031066586949125, 0.21828670730848343, 0.15417344439928604, 0.3380551715151683, 0.1470603043190586, 0.23774068686858085, 0.18846116369104593, 0.18912241425574006, 0.15671552952857382, 0.17581121734470584, 0.21520884660020445, 0.24130376876061288, 0.26525645792715324, 0.22619417328477764, 0.27713354489183994, 0.25525369845312773, 0.2410835135726812, 0.2629089499409575, 0.23947399722013119, 0.17560928745277216, 0.21152648118373385, 0.19006005730236286, 0.16986205659380016, 0.15786984308844143, 0.18897376350381523, 0.18194615843565032, 0.21046560831549954, 0.22277228331670718, 0.20660928972834292, 0.20941520113282885, 0.16791459842642475, 0.16551715685856194, 0.17646511448900237, 0.18674273313702106, 0.1863076734538739, 0.1729452191768467, 0.20188304114578615, 0.18404801169454776, 0.18447434684384012, 0.3127871214450625, 0.18764769108969248, 0.16988659162717745, 0.20156273890733567, 0.2163779518194403, 0.18589393199301485, 0.21344826889047752, 0.4473708571155356, 0.5775220367677258, 0.4906255322541786, 0.6573407762383779, 0.19761045627489626, 0.18851672803797648, 0.16652624365017688, 0.4079886494714894, 0.17143048552717133, 0.5226245146534678, 0.35234677120464564, 0.28854607391495446, 0.18591029572797801, 0.18900902202164038, 0.3668644519513342, 0.3605936409027304, 0.20646630000278288, 0.27961894134410636, 0.17865106832249, 0.19110320574559514, 0.19075685456096103, 0.19433138224622137, 0.20907762222592696, 0.1722745825028671, 0.1820911408518272, 0.18128220993842536, 0.1723610149221737, 0.08228834661893014, 0.07330411613034504, 0.08211152678890199, 0.07763445863901364, 0.09206111628103941, 0.08483231050585949, 0.07351617123167908, 0.08165813052651816, 0.08898428438647299]}, "mutation_prompt": null}
{"id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control and stochastic perturbation for robust optimization.", "configspace": "", "generation": 29, "fitness": 0.2183079052314086, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "19f6e3d2-0ae8-46ad-9382-b8d213a2cc11", "metadata": {"aucs": [0.46349311938485205, 0.45573029579144053, 0.44178594923404757, 0.45132867936012, 0.4666546876583595, 0.4463370385880451, 0.45550942877604084, 0.45398991414136025, 0.45183452276841585, 0.0850945946530497, 0.08018340325888784, 0.09470780997427797, 0.0813865628732503, 0.07519116165979955, 0.10103808670116199, 0.07112938033755667, 0.09603938787229616, 0.09672433200899178, 0.12492408218721773, 0.11960057650798628, 0.1125363577280648, 0.12121842558212026, 0.087835612158074, 0.09144423985368977, 0.10178449886943453, 0.12729899115833743, 0.1184131948821181, 0.10780779604257262, 0.10030918782611131, 0.09064439854365114, 0.09560232554025261, 0.08636911907783962, 0.09185817014302189, 0.11192253446688483, 0.11570896563778366, 0.10176251520208102, 0.7298838412743398, 0.7655591070005325, 0.783451140397938, 0.7437997241233434, 0.8081971311051066, 0.6689912075320137, 0.7636966694275198, 0.7686382322035197, 0.7702129398425329, 0.2846409045558387, 0.2773552701049584, 0.1959760987534369, 0.20302709581766898, 0.22480799296892606, 0.22141840616762243, 0.24169171725038574, 0.235598352071149, 0.22789492938170652, 0.5444082632033935, 0.265218668733607, 0.2812442156209385, 0.2574288028171662, 0.248242830796641, 0.26041522739944223, 0.5178665258542174, 0.38060516283001555, 0.6921147282783475, 0.19620061631653196, 0.1948390186760044, 0.13855856219703855, 0.18948045475110686, 0.12262180509183995, 0.12159202158663263, 0.16749793681448244, 0.17827699239452355, 0.154311834023094, 0.22221853865984165, 0.12496133382911245, 0.212804531746846, 0.18864534968242974, 0.21438147305734856, 0.15409155726307222, 0.16462446871507042, 0.13164492990004562, 0.12847905644717816, 0.01322654626345543, 0.06397603704764554, 0.028875106860125732, 0.030569405876631928, 0.03159296437517911, 0.026737192938114496, 0.060321276925884404, 0.025126676197182896, 0.04249964735128464, 0.12865633822979305, 0.09636707600128536, 0.149722475211703, 0.13540773403465867, 0.13846895096370315, 0.1186820793059109, 0.13735101882107925, 0.14756899918475974, 0.1338606966104402, 9.999999999998899e-05, 0.0035321447188063626, 0.007456553917736364, 0.011038712476612256, 9.999999999998899e-05, 0.00233458327167535, 0.0007959064472157218, 0.0258610655375352, 0.0001103006377516369, 0.1079850852843105, 0.1120040797723344, 0.13991753388015826, 0.10574370744969341, 0.09894996007354162, 0.11447896778773903, 0.09641935194031537, 0.11896313854926388, 0.1396768128371274, 0.4016370880782053, 0.40629887492902284, 0.39104056761254746, 0.38303149995573227, 0.37734957137392144, 0.417846292043092, 0.42390756253164097, 0.36548566501233504, 0.3953396704204707, 0.0983007330765413, 0.10980095759317665, 0.14061812434034893, 0.11134172401381892, 0.11725881319318321, 0.1471303782850738, 0.10278355460708499, 0.12625155963867052, 0.12366695481074352, 0.1490805443025809, 0.23600200825560136, 0.22208864349813562, 0.33297554793228035, 0.17197884759285298, 0.17300473677925288, 0.16387099658670068, 0.18567758126636247, 0.18364850081817496, 0.22279931498292893, 0.24179063816142832, 0.23840299166514223, 0.2744121951147368, 0.22197858930613357, 0.23195495710765257, 0.2332901972259721, 0.2485539752721858, 0.23688460188899585, 0.1947487284597692, 0.1706200786465355, 0.19313883127171094, 0.1772502838989234, 0.206623886094212, 0.15827430187038094, 0.17588423027771527, 0.20940763978508736, 0.18134971558601565, 0.20708095587254582, 0.17119502708868273, 0.1797549852321858, 0.18239095681796313, 0.19012857048062592, 0.20727085664013156, 0.20530462814036687, 0.18433827959254823, 0.19869506799894676, 0.19396444457402873, 0.18457539530762468, 0.19466906295307695, 0.20500109174692116, 0.17625195251636583, 0.18298647626678144, 0.19555495096807485, 0.20620750665718557, 0.17882174773220072, 0.6992679229550403, 0.2081089062641156, 0.4622401294339563, 0.6159912363398703, 0.19886536112657227, 0.4992037562378465, 0.17039445316306046, 0.24610529384635838, 0.4911964563233596, 0.404207145374439, 0.2012316776141706, 0.3412903686447033, 0.553635513548889, 0.1875699461891931, 0.21878571906978095, 0.1865665879582492, 0.360552778832649, 0.219798272653568, 0.17691817228978213, 0.20188183101454393, 0.19901412369287041, 0.1834779321440968, 0.18046692142682352, 0.19760312609706865, 0.18407593246175158, 0.17465610462328096, 0.18752340260800704, 0.08260058057927122, 0.09382255279377605, 0.0888925549510251, 0.08958824022019762, 0.07216623104078057, 0.07514853449642467, 0.08265043208190237, 0.07969064632097833, 0.08305143392216541]}, "mutation_prompt": null}
{"id": "0dc028e9-3caf-43bc-8337-c84fd92aeb43", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.7\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n        self.noise_threshold = 0.01  # To handle noisy evaluations\n        self.reinit_probability = 0.1  # Probability to reinitialize a candidate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                if np.random.rand() < self.reinit_probability:\n                    trial = np.random.uniform(*self.bounds, self.dim)  # Reinitialize some trials\n                else:\n                    trial = np.copy(population[i])\n                    crossover = np.random.rand(self.dim) < self.crossover_rate\n                    trial[crossover] = mutant[crossover]\n                \n                trial_val = func(trial)\n                current_val = func(population[i])\n                if trial_val < current_val - self.noise_threshold:\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):  # Reduced to increase diversity\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val - self.noise_threshold:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 20)  # Adjusted to focus on fewer but better candidates\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDE", "description": "A refined differential evolution incorporating adaptive noise handling and stochastic reinitialization for enhanced exploration and robustness.", "configspace": "", "generation": 30, "fitness": 0.18896466078338925, "feedback": "The algorithm RefinedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.16.", "error": "", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.41485965713766926, 0.424373846567099, 0.4073572500328181, 0.3796982592005206, 0.44072007587511075, 0.4189121240792951, 0.4218467224695279, 0.39039090470148685, 0.4212567836252551, 0.04442543072617011, 0.06776831166430164, 0.08655132925116982, 0.048056478211256026, 0.06611535671102864, 0.0691814175552774, 0.06881661750935997, 0.06086839033179381, 0.06694609717030275, 0.13174137295082988, 0.10137715268746417, 0.10590479377735829, 0.15667882052097815, 0.12165425579257894, 0.0982692949890065, 0.10876144212061067, 0.12209371949671699, 0.1150106406890673, 0.09471170395614681, 0.0795606835240944, 0.11368816538831872, 0.11064484010709841, 0.08815669372283552, 0.09141557533434863, 0.10574364227544097, 0.09368519312134527, 0.11438036536640761, 0.8016942363041886, 0.7879457212973536, 0.7758798030094073, 0.6867982065203514, 0.7868367180167819, 0.710716168313628, 0.8851736498135279, 0.9063091921985541, 0.8084022257608676, 0.23853626810319306, 0.1861520311167063, 0.1875537080940387, 0.1886470062788499, 0.19879305522325041, 0.22797547739355573, 0.1628703402263404, 0.21551583610537184, 0.1854976226266034, 0.16709514670922032, 0.18312002782973247, 0.20757649461555128, 0.23533719225251992, 0.23530965175553908, 0.2843492563094614, 0.1755381203335643, 0.2301499570817499, 0.17587201088192106, 0.1668832155312422, 0.13804577868075685, 0.20364799357109187, 0.14606724545009542, 0.11904772328055024, 0.15385366040797854, 0.19728078148974004, 0.13315186748486207, 0.1383434995194992, 0.2386288019876982, 0.15992556767932198, 0.17575720557439223, 0.18109161413251074, 0.11977850634468179, 0.13750187433241967, 0.10798682630642775, 0.1282531189855255, 0.1615034904847754, 0.013354510696946043, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007239884320732193, 0.009566394042774151, 0.002608088967064548, 0.0003902790051324434, 0.0866662356047575, 0.05964475444522255, 0.07641084792128716, 0.08564383900323758, 0.07970898142346905, 0.04729767573053978, 0.13655035616346833, 0.06097716436715728, 0.06464198843410707, 9.999999999998899e-05, 0.010283526888853145, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029192581447899935, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029116050679424132, 9.999999999998899e-05, 0.08658055923629837, 0.09979111031445376, 0.09817876391010594, 0.09352255729119552, 0.10420253660173562, 0.0993367726011033, 0.07985528089469296, 0.1087600913331126, 0.10975733546482658, 0.3625472535605584, 0.3516611438347431, 0.3393320582372118, 0.36357953116569675, 0.330345524464428, 0.34708460030791377, 0.3639061832669652, 0.3552146491523702, 0.3421097868724593, 0.10553982361942871, 0.10380875183810112, 0.08340580276122078, 0.13321345778160465, 0.09297212079212547, 0.08881342050796392, 0.09140575880034463, 0.07742059916594934, 0.11694399506571695, 0.17869305601330832, 0.15797785376685536, 0.17966695648768416, 0.1914186382266998, 0.22387492880611348, 0.13887597959056308, 0.1609935636449662, 0.17991477704183811, 0.2944043774255317, 0.21664680081614585, 0.1977078674206607, 0.2185860358377646, 0.23112790553037732, 0.19889243202774676, 0.26572849717127034, 0.2065386905631016, 0.22385925841845278, 0.2044443826990332, 0.16764902395740244, 0.1624499222261362, 0.1628518733483878, 0.14612351501874565, 0.15656556704453428, 0.15133162994558302, 0.18176995743547075, 0.1796780400570116, 0.16919239644842943, 0.20064681418123242, 0.18989035724817427, 0.19376737545278677, 0.17158318214363666, 0.17485971372991793, 0.1957603450066746, 0.17159546516588475, 0.1853624567275216, 0.18554713896941943, 0.1869260753750731, 0.18464211690582555, 0.18501781954858798, 0.17349434228504546, 0.181096135008446, 0.1791851501494759, 0.1860565512767981, 0.190710630449627, 0.17215952504573795, 0.17476791764229782, 0.2078199192808855, 0.20349747152783093, 0.255478976410746, 0.19486166127131588, 0.3191996262094561, 0.27496752801518065, 0.20901411840323536, 0.3267424668279926, 0.337920101960969, 0.22089982311394796, 0.24394569420810397, 0.28405449981512376, 0.1714916751834773, 0.2406038444092211, 0.17213853662127143, 0.38330137287538724, 0.18196655241002657, 0.173832734839655, 0.20367031943266134, 0.17833423908488766, 0.18207568167115784, 0.19260330316158625, 0.19738329461286064, 0.20723354480990286, 0.1768274312191883, 0.1832771013737875, 0.07824651146684425, 0.0860920460404484, 0.07370179232905538, 0.09467430604773419, 0.07365783863783615, 0.07468212832822207, 0.0801111790234762, 0.068416065099978, 0.0690040369700129]}, "mutation_prompt": null}
{"id": "3f4caf63-98d4-4344-8d76-4f864c45a007", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.003\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.65:\n                population = sorted(population, key=func)\n                best_count = max(5, self.population_size // 14)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "A dual-strategy adaptive differential evolution with dynamic parameter tuning and local search for enhanced convergence.", "configspace": "", "generation": 31, "fitness": 0.1837567816243766, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.15.", "error": "", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.4186924067672393, 0.3829187683392893, 0.41934494225192254, 0.4003584285401691, 0.4390541954158037, 0.4104615447206863, 0.43538518400012804, 0.4053865676755899, 0.4083910780277811, 0.04568881179756534, 0.06971257397402264, 0.09902959534322342, 0.05992348807724612, 0.041350047154540714, 0.06699238119901074, 0.07018571369763649, 0.0512244932185707, 0.03796216991105816, 0.10357726016594171, 0.10903176238097967, 0.1000955307607595, 0.11789791654591497, 0.09624827957618765, 0.10831312836702423, 0.11228083416144041, 0.127670928073371, 0.11956314520352884, 0.08676029587545886, 0.07714420944726552, 0.08181320989545438, 0.07155018272144154, 0.08661582513314625, 0.08185262332706211, 0.08823254074335851, 0.09081769486970603, 0.08604960284686602, 0.8497323727266504, 0.7051505247529501, 0.7652528831683326, 0.6990244276465385, 0.649402498965469, 0.7516322107310525, 0.7484030425193977, 0.7816227776140791, 0.6855247163047189, 0.12196211175754867, 0.16456889811667585, 0.11812827882158383, 0.13285512541505284, 0.1627066001405959, 0.14123525370438894, 0.1970406684311813, 0.13277711442286289, 0.1524800613195082, 0.20295210083009596, 0.20876467840977175, 0.17553349967799747, 0.2124504876486708, 0.24091878550726897, 0.1989544301168502, 0.20570565327959134, 0.25262233157894187, 0.20314563270327868, 0.13857795660868066, 0.10016009624292854, 0.13456486284850122, 0.11697830139156884, 0.13706582008585588, 0.110667504754141, 0.15422956840354818, 0.14673396957994578, 0.12121521035304417, 0.10923894872613127, 0.14183601899725873, 0.14389389006027264, 0.149994765091497, 0.1512743285514747, 0.16968008054635575, 0.21588934702125162, 0.17739289156321014, 0.13520007424774427, 0.018487623099849193, 9.999999999998899e-05, 0.04549300189167238, 0.018075567551328664, 9.999999999998899e-05, 0.0029878970617499556, 0.00032484617290540196, 0.006311326920283689, 0.01821033935390093, 0.07124729132806318, 0.09460884365104161, 0.08269161318118645, 0.08536866117839159, 0.10271706215716148, 0.08047381236020867, 0.10533833586642216, 0.07816594004174682, 0.0900649183145209, 0.03059274533867995, 0.002506197435240609, 0.016400003664255203, 0.009396431990823295, 0.04306492963175734, 0.025316183536788772, 0.02243422645077031, 0.012735074992161532, 0.010057623850885267, 0.09566509715662119, 0.07301187541227228, 0.10590442644817899, 0.08256720323424582, 0.07628437273469868, 0.10571816578668991, 0.10896015929460079, 0.08942860933186658, 0.1311612583935623, 0.31177522180639894, 0.34005208194204295, 0.3907172224025921, 0.323541193001153, 0.33514024435842216, 0.3731050657793178, 0.3474821435115746, 0.34686094904570863, 0.3531161671368679, 0.09970068437565494, 0.12008090512442482, 0.09666485948893655, 0.12390555029542027, 0.10293911089177199, 0.102551552418219, 0.1162927298583083, 0.08293295425464198, 0.10519829861877461, 0.15584241382969433, 0.16662743029118887, 0.20020140639642559, 0.2263550500413688, 0.14244524774822354, 0.14314455098240864, 0.1664048888311438, 0.20798640129854962, 0.21487320169676227, 0.19968555508542518, 0.21201613502713346, 0.1937229581638248, 0.20946698063614755, 0.2058442197669209, 0.20639223662708417, 0.21200676660130735, 0.2023872507323321, 0.22252014440432444, 0.15125011511411524, 0.14978220524122554, 0.16200546962493645, 0.12701639399412257, 0.15147273623235846, 0.15633965150228757, 0.1337077949305231, 0.16607551596624348, 0.18184096391201887, 0.18536494472275977, 0.21613635514752982, 0.22365146056855956, 0.1906884476720847, 0.1947221688951598, 0.17812563377374446, 0.18255284137895555, 0.20785037428570308, 0.18175535213400307, 0.1677427425899245, 0.17698783856530498, 0.17741202802528955, 0.16547043158887842, 0.21070055855230108, 0.16847870930513142, 0.17501096144067252, 0.1766530149465776, 0.16823535299736414, 0.26113824128201546, 0.18535168883014164, 0.17074709196536353, 0.17044375828803515, 0.21939558877659115, 0.4124587580370821, 0.34014621054380045, 0.16860643709852285, 0.49952028144112215, 0.426414003528087, 0.281387539111977, 0.19796633893832216, 0.18559301866204192, 0.1951049991646192, 0.1774641728566081, 0.2156203844946578, 0.2228810737989585, 0.19990698452361844, 0.20166561920805492, 0.20068142873222206, 0.19130630866344311, 0.20087842377989096, 0.20862961633516874, 0.1956770841708495, 0.19315426705476324, 0.19479549278792552, 0.20073332588739046, 0.09129517712541624, 0.08022583841866904, 0.0622372100303864, 0.07403895637516722, 0.08595562663631895, 0.07732869554552979, 0.08884836719452927, 0.08069696701547624, 0.08147019257891952]}, "mutation_prompt": null}
{"id": "844c3cb9-c2ba-43d0-9662-47759289c32c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n        self.exploration_phase = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.exploration_phase:\n                    self.mutation_factor = self.adaptive_mutation_factor + 0.3 * np.random.rand()\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.75:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE_Refined", "description": "A refined adaptive differential evolution with dual-phase exploration and exploitation for enhanced convergence.", "configspace": "", "generation": 32, "fitness": 0.19673543132333826, "feedback": "The algorithm EnhancedAdaptiveDE_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.4287152988430881, 0.4049347839908298, 0.4249255563028823, 0.42219821296866067, 0.42714275756028386, 0.3978057274138026, 0.4265798534750409, 0.45548841368052306, 0.4373445417600116, 0.04283627023352132, 0.05238062911870989, 0.06508236993657024, 0.05479835070667882, 0.052617216044013704, 0.06121487287509497, 0.06081931356694892, 0.055297181012433194, 0.069107722190488, 0.09798005486686001, 0.11362464430991115, 0.09871204831996983, 0.09312113575848913, 0.09840228144644914, 0.1268713514049743, 0.10264509669132571, 0.11086830145006732, 0.11127027464307016, 0.0752160568591067, 0.09307081000212092, 0.0875124328657717, 0.13718102229396756, 0.10412213580059781, 0.07412398277256849, 0.097838719404159, 0.10287953542595374, 0.08442178512466303, 0.7545610655010332, 0.6979863325413282, 0.6228148925850501, 0.7322148717831076, 0.7805619471579263, 0.7493994898799244, 0.7865381381729686, 0.6938035452601858, 0.716173867446923, 0.1984451912551437, 0.23749993627886457, 0.21101581533752067, 0.16778663852136322, 0.18856839707685602, 0.22823543117645817, 0.1890654146319639, 0.20440364804153055, 0.28095385642095916, 0.240274351064245, 0.18755714548026425, 0.1959468555357774, 0.2161955918910884, 0.4377430619893262, 0.321654412607816, 0.23140397359228904, 0.33848483603496315, 0.26626880955202115, 0.21510685740677493, 0.12525114017582906, 0.2345871767814487, 0.10770682084939032, 0.12858457673983936, 0.16958996820717676, 0.15062210976654533, 0.16250822581239777, 0.13473818309184538, 0.15437750800191585, 0.1315701237823671, 0.17188496286687427, 0.24146345858148865, 0.15690580768589557, 0.16423325260183697, 0.13640884731714797, 0.10575842780835576, 0.11236723358203071, 0.007285916034793227, 0.03361248821129814, 0.014996842780114483, 0.0196496978854791, 0.01427691705967793, 0.011259300857508259, 0.013745978853644036, 0.02045836477918095, 0.030927909893219807, 0.08975720744573723, 0.10081184265271237, 0.12139377165648935, 0.10681923551729311, 0.06889755636092743, 0.09890398708017478, 0.08286393529482283, 0.11031519179718985, 0.11825625098202963, 0.022195842941920674, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007195206122347031, 0.003317385015104035, 0.011112004780919449, 9.999999999998899e-05, 0.0023851638079303017, 0.07870223328296433, 0.11041886434096615, 0.12795383677935712, 0.11587343916543846, 0.087357166427941, 0.10172762648990796, 0.1097771510921488, 0.08641434629742761, 0.09762998990446847, 0.3959769694016916, 0.3700480047798963, 0.3876100348602878, 0.37027270848621974, 0.4138750273069288, 0.38662889589431937, 0.3824732133563373, 0.3313096536524056, 0.40376157864626605, 0.08925839831032012, 0.12452456757752883, 0.08412903722180887, 0.09518032162972012, 0.11603205558218566, 0.12023833896257252, 0.11293529277480863, 0.09117962908768118, 0.1430654473463393, 0.14822102482032973, 0.16021943879868872, 0.15919004915946044, 0.23102908211157624, 0.16659696954587233, 0.1638747733586049, 0.18084901320043434, 0.1999289323769491, 0.18374393643223608, 0.22845366491676466, 0.20952380699817597, 0.2050197582579094, 0.22690777435036824, 0.2065536427441259, 0.24221056748323622, 0.21592543616928428, 0.22482556548899724, 0.20704784988786418, 0.15911617054907323, 0.15723110554308584, 0.16969526020388692, 0.14751425140229169, 0.15053963593161812, 0.17444737660842435, 0.1382960220511068, 0.1799071192121352, 0.18074994271635192, 0.19419505953610783, 0.2376622862976847, 0.18509963254695505, 0.2013621369675691, 0.177399371072673, 0.19394887079782408, 0.18956870196693965, 0.173457503626405, 0.19472696663003675, 0.18482661722117877, 0.1569815088065044, 0.19500184268817033, 0.16167303321284165, 0.18971080737009882, 0.1786703249529099, 0.18281111231012714, 0.20923047275838946, 0.1869901049176257, 0.4399326764617706, 0.26963154785660104, 0.6193757039772192, 0.4602485061295858, 0.19210274197318733, 0.5362257588857834, 0.3643448398303274, 0.34539991230343015, 0.21023209631934636, 0.3981491562542685, 0.1972279211685959, 0.1985538215819741, 0.1807996655571722, 0.17850755372350413, 0.2017497239124355, 0.20159437856016327, 0.23714955678971605, 0.190709681887136, 0.18706338914357834, 0.18964919469493868, 0.18730633014497444, 0.1755434155367417, 0.18779187518322416, 0.1811035897518226, 0.18957959790295487, 0.19827538729198668, 0.1892195177757965, 0.07883930929945926, 0.09019155368710419, 0.08837506699277997, 0.08027945137043424, 0.07649300909794643, 0.07140332390759307, 0.07643675055267107, 0.06635453970801086, 0.07451333116381487]}, "mutation_prompt": null}
{"id": "d05661a2-5594-42e9-a259-7f76f48594ef", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control and stochastic perturbation for robust optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.46349311938485205, 0.45573029579144053, 0.44178594923404757, 0.45132867936012, 0.4666546876583595, 0.4463370385880451, 0.45550942877604084, 0.45398991414136025, 0.45183452276841585, 0.0850945946530497, 0.08018340325888784, 0.09470780997427797, 0.0813865628732503, 0.07519116165979955, 0.10103808670116199, 0.07112938033755667, 0.09603938787229616, 0.09672433200899178, 0.12492408218721773, 0.11960057650798628, 0.1125363577280648, 0.12121842558212026, 0.087835612158074, 0.09144423985368977, 0.10178449886943453, 0.12729899115833743, 0.1184131948821181, 0.10780779604257262, 0.10030918782611131, 0.09064439854365114, 0.09560232554025261, 0.08636911907783962, 0.09185817014302189, 0.11192253446688483, 0.11570896563778366, 0.10176251520208102, 0.7298838412743398, 0.7655591070005325, 0.783451140397938, 0.7437997241233434, 0.8081971311051066, 0.6689912075320137, 0.7636966694275198, 0.7686382322035197, 0.7702129398425329, 0.2846409045558387, 0.2773552701049584, 0.1959760987534369, 0.20302709581766898, 0.22480799296892606, 0.22141840616762243, 0.24169171725038574, 0.235598352071149, 0.22789492938170652, 0.5444082632033935, 0.265218668733607, 0.2812442156209385, 0.2574288028171662, 0.248242830796641, 0.26041522739944223, 0.5178665258542174, 0.38060516283001555, 0.6921147282783475, 0.19620061631653196, 0.1948390186760044, 0.13855856219703855, 0.18948045475110686, 0.12262180509183995, 0.12159202158663263, 0.16749793681448244, 0.17827699239452355, 0.154311834023094, 0.22221853865984165, 0.12496133382911245, 0.212804531746846, 0.18864534968242974, 0.21438147305734856, 0.15409155726307222, 0.16462446871507042, 0.13164492990004562, 0.12847905644717816, 0.01322654626345543, 0.06397603704764554, 0.028875106860125732, 0.030569405876631928, 0.03159296437517911, 0.026737192938114496, 0.060321276925884404, 0.025126676197182896, 0.04249964735128464, 0.12865633822979305, 0.09636707600128536, 0.149722475211703, 0.13540773403465867, 0.13846895096370315, 0.1186820793059109, 0.13735101882107925, 0.14756899918475974, 0.1338606966104402, 9.999999999998899e-05, 0.0035321447188063626, 0.007456553917736364, 0.011038712476612256, 9.999999999998899e-05, 0.00233458327167535, 0.0007959064472157218, 0.0258610655375352, 0.0001103006377516369, 0.1079850852843105, 0.1120040797723344, 0.13991753388015826, 0.10574370744969341, 0.09894996007354162, 0.11447896778773903, 0.09641935194031537, 0.11896313854926388, 0.1396768128371274, 0.4016370880782053, 0.40629887492902284, 0.39104056761254746, 0.38303149995573227, 0.37734957137392144, 0.417846292043092, 0.42390756253164097, 0.36548566501233504, 0.3953396704204707, 0.0983007330765413, 0.10980095759317665, 0.14061812434034893, 0.11134172401381892, 0.11725881319318321, 0.1471303782850738, 0.10278355460708499, 0.12625155963867052, 0.12366695481074352, 0.1490805443025809, 0.23600200825560136, 0.22208864349813562, 0.33297554793228035, 0.17197884759285298, 0.17300473677925288, 0.16387099658670068, 0.18567758126636247, 0.18364850081817496, 0.22279931498292893, 0.24179063816142832, 0.23840299166514223, 0.2744121951147368, 0.22197858930613357, 0.23195495710765257, 0.2332901972259721, 0.2485539752721858, 0.23688460188899585, 0.1947487284597692, 0.1706200786465355, 0.19313883127171094, 0.1772502838989234, 0.206623886094212, 0.15827430187038094, 0.17588423027771527, 0.20940763978508736, 0.18134971558601565, 0.20708095587254582, 0.17119502708868273, 0.1797549852321858, 0.18239095681796313, 0.19012857048062592, 0.20727085664013156, 0.20530462814036687, 0.18433827959254823, 0.19869506799894676, 0.19396444457402873, 0.18457539530762468, 0.19466906295307695, 0.20500109174692116, 0.17625195251636583, 0.18298647626678144, 0.19555495096807485, 0.20620750665718557, 0.17882174773220072, 0.6992679229550403, 0.2081089062641156, 0.4622401294339563, 0.6159912363398703, 0.19886536112657227, 0.4992037562378465, 0.17039445316306046, 0.24610529384635838, 0.4911964563233596, 0.404207145374439, 0.2012316776141706, 0.3412903686447033, 0.553635513548889, 0.1875699461891931, 0.21878571906978095, 0.1865665879582492, 0.360552778832649, 0.219798272653568, 0.17691817228978213, 0.20188183101454393, 0.19901412369287041, 0.1834779321440968, 0.18046692142682352, 0.19760312609706865, 0.18407593246175158, 0.17465610462328096, 0.18752340260800704, 0.08260058057927122, 0.09382255279377605, 0.0888925549510251, 0.08958824022019762, 0.07216623104078057, 0.07514853449642467, 0.08265043208190237, 0.07969064632097833, 0.08305143392216541]}, "mutation_prompt": null}
{"id": "7cb4d5a7-cbae-4585-9378-aef5e6ab7fde", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control and stochastic perturbation for robust optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.46349311938485205, 0.45573029579144053, 0.44178594923404757, 0.45132867936012, 0.4666546876583595, 0.4463370385880451, 0.45550942877604084, 0.45398991414136025, 0.45183452276841585, 0.0850945946530497, 0.08018340325888784, 0.09470780997427797, 0.0813865628732503, 0.07519116165979955, 0.10103808670116199, 0.07112938033755667, 0.09603938787229616, 0.09672433200899178, 0.12492408218721773, 0.11960057650798628, 0.1125363577280648, 0.12121842558212026, 0.087835612158074, 0.09144423985368977, 0.10178449886943453, 0.12729899115833743, 0.1184131948821181, 0.10780779604257262, 0.10030918782611131, 0.09064439854365114, 0.09560232554025261, 0.08636911907783962, 0.09185817014302189, 0.11192253446688483, 0.11570896563778366, 0.10176251520208102, 0.7298838412743398, 0.7655591070005325, 0.783451140397938, 0.7437997241233434, 0.8081971311051066, 0.6689912075320137, 0.7636966694275198, 0.7686382322035197, 0.7702129398425329, 0.2846409045558387, 0.2773552701049584, 0.1959760987534369, 0.20302709581766898, 0.22480799296892606, 0.22141840616762243, 0.24169171725038574, 0.235598352071149, 0.22789492938170652, 0.5444082632033935, 0.265218668733607, 0.2812442156209385, 0.2574288028171662, 0.248242830796641, 0.26041522739944223, 0.5178665258542174, 0.38060516283001555, 0.6921147282783475, 0.19620061631653196, 0.1948390186760044, 0.13855856219703855, 0.18948045475110686, 0.12262180509183995, 0.12159202158663263, 0.16749793681448244, 0.17827699239452355, 0.154311834023094, 0.22221853865984165, 0.12496133382911245, 0.212804531746846, 0.18864534968242974, 0.21438147305734856, 0.15409155726307222, 0.16462446871507042, 0.13164492990004562, 0.12847905644717816, 0.01322654626345543, 0.06397603704764554, 0.028875106860125732, 0.030569405876631928, 0.03159296437517911, 0.026737192938114496, 0.060321276925884404, 0.025126676197182896, 0.04249964735128464, 0.12865633822979305, 0.09636707600128536, 0.149722475211703, 0.13540773403465867, 0.13846895096370315, 0.1186820793059109, 0.13735101882107925, 0.14756899918475974, 0.1338606966104402, 9.999999999998899e-05, 0.0035321447188063626, 0.007456553917736364, 0.011038712476612256, 9.999999999998899e-05, 0.00233458327167535, 0.0007959064472157218, 0.0258610655375352, 0.0001103006377516369, 0.1079850852843105, 0.1120040797723344, 0.13991753388015826, 0.10574370744969341, 0.09894996007354162, 0.11447896778773903, 0.09641935194031537, 0.11896313854926388, 0.1396768128371274, 0.4016370880782053, 0.40629887492902284, 0.39104056761254746, 0.38303149995573227, 0.37734957137392144, 0.417846292043092, 0.42390756253164097, 0.36548566501233504, 0.3953396704204707, 0.0983007330765413, 0.10980095759317665, 0.14061812434034893, 0.11134172401381892, 0.11725881319318321, 0.1471303782850738, 0.10278355460708499, 0.12625155963867052, 0.12366695481074352, 0.1490805443025809, 0.23600200825560136, 0.22208864349813562, 0.33297554793228035, 0.17197884759285298, 0.17300473677925288, 0.16387099658670068, 0.18567758126636247, 0.18364850081817496, 0.22279931498292893, 0.24179063816142832, 0.23840299166514223, 0.2744121951147368, 0.22197858930613357, 0.23195495710765257, 0.2332901972259721, 0.2485539752721858, 0.23688460188899585, 0.1947487284597692, 0.1706200786465355, 0.19313883127171094, 0.1772502838989234, 0.206623886094212, 0.15827430187038094, 0.17588423027771527, 0.20940763978508736, 0.18134971558601565, 0.20708095587254582, 0.17119502708868273, 0.1797549852321858, 0.18239095681796313, 0.19012857048062592, 0.20727085664013156, 0.20530462814036687, 0.18433827959254823, 0.19869506799894676, 0.19396444457402873, 0.18457539530762468, 0.19466906295307695, 0.20500109174692116, 0.17625195251636583, 0.18298647626678144, 0.19555495096807485, 0.20620750665718557, 0.17882174773220072, 0.6992679229550403, 0.2081089062641156, 0.4622401294339563, 0.6159912363398703, 0.19886536112657227, 0.4992037562378465, 0.17039445316306046, 0.24610529384635838, 0.4911964563233596, 0.404207145374439, 0.2012316776141706, 0.3412903686447033, 0.553635513548889, 0.1875699461891931, 0.21878571906978095, 0.1865665879582492, 0.360552778832649, 0.219798272653568, 0.17691817228978213, 0.20188183101454393, 0.19901412369287041, 0.1834779321440968, 0.18046692142682352, 0.19760312609706865, 0.18407593246175158, 0.17465610462328096, 0.18752340260800704, 0.08260058057927122, 0.09382255279377605, 0.0888925549510251, 0.08958824022019762, 0.07216623104078057, 0.07514853449642467, 0.08265043208190237, 0.07969064632097833, 0.08305143392216541]}, "mutation_prompt": null}
{"id": "6f30b3f4-2e10-4692-9fd9-1ec4c32e5d57", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control and stochastic perturbation for robust optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.46349311938485205, 0.45573029579144053, 0.44178594923404757, 0.45132867936012, 0.4666546876583595, 0.4463370385880451, 0.45550942877604084, 0.45398991414136025, 0.45183452276841585, 0.0850945946530497, 0.08018340325888784, 0.09470780997427797, 0.0813865628732503, 0.07519116165979955, 0.10103808670116199, 0.07112938033755667, 0.09603938787229616, 0.09672433200899178, 0.12492408218721773, 0.11960057650798628, 0.1125363577280648, 0.12121842558212026, 0.087835612158074, 0.09144423985368977, 0.10178449886943453, 0.12729899115833743, 0.1184131948821181, 0.10780779604257262, 0.10030918782611131, 0.09064439854365114, 0.09560232554025261, 0.08636911907783962, 0.09185817014302189, 0.11192253446688483, 0.11570896563778366, 0.10176251520208102, 0.7298838412743398, 0.7655591070005325, 0.783451140397938, 0.7437997241233434, 0.8081971311051066, 0.6689912075320137, 0.7636966694275198, 0.7686382322035197, 0.7702129398425329, 0.2846409045558387, 0.2773552701049584, 0.1959760987534369, 0.20302709581766898, 0.22480799296892606, 0.22141840616762243, 0.24169171725038574, 0.235598352071149, 0.22789492938170652, 0.5444082632033935, 0.265218668733607, 0.2812442156209385, 0.2574288028171662, 0.248242830796641, 0.26041522739944223, 0.5178665258542174, 0.38060516283001555, 0.6921147282783475, 0.19620061631653196, 0.1948390186760044, 0.13855856219703855, 0.18948045475110686, 0.12262180509183995, 0.12159202158663263, 0.16749793681448244, 0.17827699239452355, 0.154311834023094, 0.22221853865984165, 0.12496133382911245, 0.212804531746846, 0.18864534968242974, 0.21438147305734856, 0.15409155726307222, 0.16462446871507042, 0.13164492990004562, 0.12847905644717816, 0.01322654626345543, 0.06397603704764554, 0.028875106860125732, 0.030569405876631928, 0.03159296437517911, 0.026737192938114496, 0.060321276925884404, 0.025126676197182896, 0.04249964735128464, 0.12865633822979305, 0.09636707600128536, 0.149722475211703, 0.13540773403465867, 0.13846895096370315, 0.1186820793059109, 0.13735101882107925, 0.14756899918475974, 0.1338606966104402, 9.999999999998899e-05, 0.0035321447188063626, 0.007456553917736364, 0.011038712476612256, 9.999999999998899e-05, 0.00233458327167535, 0.0007959064472157218, 0.0258610655375352, 0.0001103006377516369, 0.1079850852843105, 0.1120040797723344, 0.13991753388015826, 0.10574370744969341, 0.09894996007354162, 0.11447896778773903, 0.09641935194031537, 0.11896313854926388, 0.1396768128371274, 0.4016370880782053, 0.40629887492902284, 0.39104056761254746, 0.38303149995573227, 0.37734957137392144, 0.417846292043092, 0.42390756253164097, 0.36548566501233504, 0.3953396704204707, 0.0983007330765413, 0.10980095759317665, 0.14061812434034893, 0.11134172401381892, 0.11725881319318321, 0.1471303782850738, 0.10278355460708499, 0.12625155963867052, 0.12366695481074352, 0.1490805443025809, 0.23600200825560136, 0.22208864349813562, 0.33297554793228035, 0.17197884759285298, 0.17300473677925288, 0.16387099658670068, 0.18567758126636247, 0.18364850081817496, 0.22279931498292893, 0.24179063816142832, 0.23840299166514223, 0.2744121951147368, 0.22197858930613357, 0.23195495710765257, 0.2332901972259721, 0.2485539752721858, 0.23688460188899585, 0.1947487284597692, 0.1706200786465355, 0.19313883127171094, 0.1772502838989234, 0.206623886094212, 0.15827430187038094, 0.17588423027771527, 0.20940763978508736, 0.18134971558601565, 0.20708095587254582, 0.17119502708868273, 0.1797549852321858, 0.18239095681796313, 0.19012857048062592, 0.20727085664013156, 0.20530462814036687, 0.18433827959254823, 0.19869506799894676, 0.19396444457402873, 0.18457539530762468, 0.19466906295307695, 0.20500109174692116, 0.17625195251636583, 0.18298647626678144, 0.19555495096807485, 0.20620750665718557, 0.17882174773220072, 0.6992679229550403, 0.2081089062641156, 0.4622401294339563, 0.6159912363398703, 0.19886536112657227, 0.4992037562378465, 0.17039445316306046, 0.24610529384635838, 0.4911964563233596, 0.404207145374439, 0.2012316776141706, 0.3412903686447033, 0.553635513548889, 0.1875699461891931, 0.21878571906978095, 0.1865665879582492, 0.360552778832649, 0.219798272653568, 0.17691817228978213, 0.20188183101454393, 0.19901412369287041, 0.1834779321440968, 0.18046692142682352, 0.19760312609706865, 0.18407593246175158, 0.17465610462328096, 0.18752340260800704, 0.08260058057927122, 0.09382255279377605, 0.0888925549510251, 0.08958824022019762, 0.07216623104078057, 0.07514853449642467, 0.08265043208190237, 0.07969064632097833, 0.08305143392216541]}, "mutation_prompt": null}
{"id": "7a20d455-a2bd-40c3-807f-8a71f6ceaab8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n        self.dynamic_local_search_prob = 0.1  # New parameter for dynamic local search\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        def dynamic_local_search(population):\n            for i in range(len(population)):\n                if np.random.rand() < self.dynamic_local_search_prob:\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n            return population\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n            # Apply dynamic local search to some individuals\n            population = dynamic_local_search(population)\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control, stochastic perturbation, and dynamic local search for robust optimization.", "configspace": "", "generation": 36, "fitness": 0.19420681956460445, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.15.", "error": "", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.40705310873734046, 0.39695974889608854, 0.42143167551182437, 0.40444313703270274, 0.4433448074150844, 0.4514976318664974, 0.4155398348217517, 0.39908532024221055, 0.4061564691310312, 0.06867803428380781, 0.06470833015329358, 0.05138713710161069, 0.0472649192657324, 0.04932147266593989, 0.05388295165905388, 0.03852408204348834, 0.06830855342130471, 0.05761218291963344, 0.10748216609893047, 0.12578969158737197, 0.09437587707363615, 0.11576903714986542, 0.10230962425733048, 0.10127626731133654, 0.09935848104536804, 0.12029295106353621, 0.12736218350750173, 0.0928425075334417, 0.09272472993924041, 0.07781849317557843, 0.08619828651428929, 0.09215316906041571, 0.07094342512536023, 0.08962623896841482, 0.09898412005189361, 0.08468989083161937, 0.5532774717858499, 0.7902679468286093, 0.6675870167010524, 0.5750481668160785, 0.6520815277455663, 0.7204511094861231, 0.6352947862127027, 0.6043763859237479, 0.6838074077961236, 0.21545261089319734, 0.18968435901761183, 0.14260796115181607, 0.18810812670090182, 0.22717519288084276, 0.18419157462624802, 0.22623409267959382, 0.19620464868729526, 0.16551122817863584, 0.21272776842581875, 0.2029582568104522, 0.17530922948557437, 0.2568656435331984, 0.2591218970942204, 0.22111593176914457, 0.246733446130046, 0.20790264021690086, 0.19951803832360404, 0.2405580151459814, 0.14911471980897983, 0.12280875391130253, 0.12086586757954432, 0.10752620643162158, 0.2069018827464757, 0.14717865883756276, 0.12384284876386575, 0.1321820637022878, 0.10391376913714945, 0.0788885252953423, 0.20705567437418793, 0.12144086411451771, 0.13668584025640518, 0.176217761938126, 0.10428981690524197, 0.13450544414845733, 0.1339287680802097, 0.011354124853549363, 0.036437380865554925, 0.023867589057724237, 0.036960393016618354, 0.010285880420353943, 0.018270621757662253, 0.06796522772746116, 0.027302386095790054, 0.009690668464647945, 0.12995790502420368, 0.12573983058757532, 0.159779439493411, 0.12555624457717518, 0.13598685714404524, 0.12428392011714295, 0.10407378296890579, 0.12336809140466398, 0.14499149587243498, 9.999999999998899e-05, 9.999999999998899e-05, 0.003934742954108117, 0.007774471378219294, 0.0005863165389596858, 0.006084363147156546, 0.007428827644329394, 0.003203759585096111, 0.026494447732737125, 0.11009300444818304, 0.10528453313219455, 0.1165487864414747, 0.07814905035565667, 0.085446639735136, 0.13734817630510276, 0.09013595910623917, 0.09482689793803789, 0.09074931053173929, 0.3599339897008992, 0.39473462713453245, 0.37993798345079155, 0.3783038166040308, 0.3503587000797963, 0.3743643676380566, 0.4014858927546463, 0.323787350204784, 0.3701856174376429, 0.09161385623708884, 0.09507225942662012, 0.09502169730132559, 0.1282356338520313, 0.09971732178206116, 0.09137048434147454, 0.08897594169967138, 0.10958112041550228, 0.11427172042966882, 0.18853333983846865, 0.17599353536313955, 0.23132021247264067, 0.23459529210526864, 0.2453093562171823, 0.1734545184390206, 0.21588965802329452, 0.18515638851885363, 0.15342738220258856, 0.20057526548935134, 0.19597657942266533, 0.20626695717315902, 0.21303004307000073, 0.18966713383202516, 0.1876629901990522, 0.20019623812176013, 0.22255787360750634, 0.19162237114294212, 0.16542649259144548, 0.13148183847157868, 0.16132790876376146, 0.16546356998233225, 0.14058338644337787, 0.15275123567209392, 0.13069762771004023, 0.14800706943753306, 0.15147501233240035, 0.1908730459864778, 0.18522190995489762, 0.19278550134139127, 0.19574976773570407, 0.17325622981232447, 0.2211387797570059, 0.20941248643803834, 0.18257264528305572, 0.19009730519706558, 0.1852853688072944, 0.17911348146229944, 0.1753622002619648, 0.18820321651210226, 0.16867306387039038, 0.1855402922887197, 0.19044421314643456, 0.20801953841559284, 0.21164018428081943, 0.6651066984746059, 0.36425192960676855, 0.4330139899877501, 0.5186411671750016, 0.19224831546724885, 0.2587425335800303, 0.5054978934920122, 0.16419810881327446, 0.5257387622176182, 0.38654435626231787, 0.2619345382045971, 0.530455542493224, 0.2295974309561477, 0.24334801496154268, 0.250197575597189, 0.18469224427532838, 0.2643784244859575, 0.3068719190735517, 0.18882488365788286, 0.18197995092602826, 0.1877576468126333, 0.2045784883752675, 0.2012110233429264, 0.188026913031753, 0.19983656468848288, 0.2014558161475546, 0.18569237360726543, 0.08088913167403111, 0.09007490955964226, 0.08328075857572714, 0.07375690195284335, 0.08480261379499865, 0.08797024668939812, 0.07554432032050351, 0.07485365488943607, 0.08100888413330487]}, "mutation_prompt": null}
{"id": "c10a2698-3dca-492d-8007-d30699129012", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control and stochastic perturbation for robust optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.46349311938485205, 0.45573029579144053, 0.44178594923404757, 0.45132867936012, 0.4666546876583595, 0.4463370385880451, 0.45550942877604084, 0.45398991414136025, 0.45183452276841585, 0.0850945946530497, 0.08018340325888784, 0.09470780997427797, 0.0813865628732503, 0.07519116165979955, 0.10103808670116199, 0.07112938033755667, 0.09603938787229616, 0.09672433200899178, 0.12492408218721773, 0.11960057650798628, 0.1125363577280648, 0.12121842558212026, 0.087835612158074, 0.09144423985368977, 0.10178449886943453, 0.12729899115833743, 0.1184131948821181, 0.10780779604257262, 0.10030918782611131, 0.09064439854365114, 0.09560232554025261, 0.08636911907783962, 0.09185817014302189, 0.11192253446688483, 0.11570896563778366, 0.10176251520208102, 0.7298838412743398, 0.7655591070005325, 0.783451140397938, 0.7437997241233434, 0.8081971311051066, 0.6689912075320137, 0.7636966694275198, 0.7686382322035197, 0.7702129398425329, 0.2846409045558387, 0.2773552701049584, 0.1959760987534369, 0.20302709581766898, 0.22480799296892606, 0.22141840616762243, 0.24169171725038574, 0.235598352071149, 0.22789492938170652, 0.5444082632033935, 0.265218668733607, 0.2812442156209385, 0.2574288028171662, 0.248242830796641, 0.26041522739944223, 0.5178665258542174, 0.38060516283001555, 0.6921147282783475, 0.19620061631653196, 0.1948390186760044, 0.13855856219703855, 0.18948045475110686, 0.12262180509183995, 0.12159202158663263, 0.16749793681448244, 0.17827699239452355, 0.154311834023094, 0.22221853865984165, 0.12496133382911245, 0.212804531746846, 0.18864534968242974, 0.21438147305734856, 0.15409155726307222, 0.16462446871507042, 0.13164492990004562, 0.12847905644717816, 0.01322654626345543, 0.06397603704764554, 0.028875106860125732, 0.030569405876631928, 0.03159296437517911, 0.026737192938114496, 0.060321276925884404, 0.025126676197182896, 0.04249964735128464, 0.12865633822979305, 0.09636707600128536, 0.149722475211703, 0.13540773403465867, 0.13846895096370315, 0.1186820793059109, 0.13735101882107925, 0.14756899918475974, 0.1338606966104402, 9.999999999998899e-05, 0.0035321447188063626, 0.007456553917736364, 0.011038712476612256, 9.999999999998899e-05, 0.00233458327167535, 0.0007959064472157218, 0.0258610655375352, 0.0001103006377516369, 0.1079850852843105, 0.1120040797723344, 0.13991753388015826, 0.10574370744969341, 0.09894996007354162, 0.11447896778773903, 0.09641935194031537, 0.11896313854926388, 0.1396768128371274, 0.4016370880782053, 0.40629887492902284, 0.39104056761254746, 0.38303149995573227, 0.37734957137392144, 0.417846292043092, 0.42390756253164097, 0.36548566501233504, 0.3953396704204707, 0.0983007330765413, 0.10980095759317665, 0.14061812434034893, 0.11134172401381892, 0.11725881319318321, 0.1471303782850738, 0.10278355460708499, 0.12625155963867052, 0.12366695481074352, 0.1490805443025809, 0.23600200825560136, 0.22208864349813562, 0.33297554793228035, 0.17197884759285298, 0.17300473677925288, 0.16387099658670068, 0.18567758126636247, 0.18364850081817496, 0.22279931498292893, 0.24179063816142832, 0.23840299166514223, 0.2744121951147368, 0.22197858930613357, 0.23195495710765257, 0.2332901972259721, 0.2485539752721858, 0.23688460188899585, 0.1947487284597692, 0.1706200786465355, 0.19313883127171094, 0.1772502838989234, 0.206623886094212, 0.15827430187038094, 0.17588423027771527, 0.20940763978508736, 0.18134971558601565, 0.20708095587254582, 0.17119502708868273, 0.1797549852321858, 0.18239095681796313, 0.19012857048062592, 0.20727085664013156, 0.20530462814036687, 0.18433827959254823, 0.19869506799894676, 0.19396444457402873, 0.18457539530762468, 0.19466906295307695, 0.20500109174692116, 0.17625195251636583, 0.18298647626678144, 0.19555495096807485, 0.20620750665718557, 0.17882174773220072, 0.6992679229550403, 0.2081089062641156, 0.4622401294339563, 0.6159912363398703, 0.19886536112657227, 0.4992037562378465, 0.17039445316306046, 0.24610529384635838, 0.4911964563233596, 0.404207145374439, 0.2012316776141706, 0.3412903686447033, 0.553635513548889, 0.1875699461891931, 0.21878571906978095, 0.1865665879582492, 0.360552778832649, 0.219798272653568, 0.17691817228978213, 0.20188183101454393, 0.19901412369287041, 0.1834779321440968, 0.18046692142682352, 0.19760312609706865, 0.18407593246175158, 0.17465610462328096, 0.18752340260800704, 0.08260058057927122, 0.09382255279377605, 0.0888925549510251, 0.08958824022019762, 0.07216623104078057, 0.07514853449642467, 0.08265043208190237, 0.07969064632097833, 0.08305143392216541]}, "mutation_prompt": null}
{"id": "856d813b-03ff-4429-8e20-bb139fec1822", "solution": "import numpy as np\n\nclass HybridEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.evaluations = 0\n        self.dynamic_mutation_factor = 0.3\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < 0.4:\n                    self.mutation_factor = self.dynamic_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def local_intensification(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.004\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:\n                population = sorted(population, key=func)\n                top_count = max(5, self.population_size // 12)\n                for i in range(min(top_count, len(population))):\n                    population[i] = local_intensification(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridEnhancedDE", "description": "A hybrid enhanced differential evolution with adaptive dynamic scaling and local intensification for improved global exploration and local exploitation.", "configspace": "", "generation": 38, "fitness": 0.212153795575629, "feedback": "The algorithm HybridEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.15.", "error": "", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.44412582501930986, 0.42314277054213467, 0.4543733911379725, 0.4677102250604317, 0.4571693221154741, 0.4601299818336494, 0.4513149452297722, 0.46508587153701275, 0.46195229914062474, 0.1041870704290182, 0.09781639167539014, 0.12241523736865989, 0.10869407534194309, 0.1013769459221392, 0.12695551795532234, 0.11005938750026323, 0.09781185329923991, 0.12486986950423107, 0.11303534053702025, 0.149672184402723, 0.11766924054113082, 0.12499646233361295, 0.1562416370892934, 0.11777132089710818, 0.13540160583351768, 0.11005796609254581, 0.1144096578297833, 0.11138434297473121, 0.09245125335564586, 0.09264794363058282, 0.14933169723036954, 0.11276975128714817, 0.09247591716420889, 0.10187633860111545, 0.11677889079816228, 0.08849043176139981, 0.8787156686780886, 0.6305232357706735, 0.5425916394325903, 0.6072556968267725, 0.7381432406874684, 0.6494998373543877, 0.5701758723366153, 0.7172030908951755, 0.7426099640117726, 0.20776677511391706, 0.21190124914178254, 0.2535361623890213, 0.2068832674168063, 0.17047194767625629, 0.21791956984374394, 0.23781580479765907, 0.18803166171396313, 0.26867102078745697, 0.33492935414852465, 0.24875675821339538, 0.2158265677170158, 0.34462926282771567, 0.4211593374104593, 0.5438105094122421, 0.3522994331739596, 0.2925247161517295, 0.2701507637424546, 0.11333381375542573, 0.15390943788809586, 0.22228925543026035, 0.12413220354811383, 0.15480680582159, 0.1647633679706083, 0.229258972759523, 0.21284251245431496, 0.21074299002121966, 0.1331767772161384, 0.1527545428210222, 0.12726285610150267, 0.1092457355508506, 0.19455473507294352, 0.1441546629262379, 0.13383476107166903, 0.1521083115790003, 0.1424048327318096, 0.04672371110066742, 0.00541218142728217, 0.06398303632208191, 0.07019211901242794, 0.032617800252673246, 0.05469296463521256, 0.0125925642788145, 0.01968300001510548, 0.03114981062424127, 0.1591402700192186, 0.1260863118169775, 0.14163979625185252, 0.10426923740580185, 0.1526731302355343, 0.07292206053593286, 0.13759870448135847, 0.14797888109859125, 0.14433633239470967, 0.00024388760435833934, 0.001028818009060739, 0.01827121189492087, 0.004142720477437578, 0.0317263957626448, 0.004913390486922298, 0.007406355197818959, 0.02201827382917032, 0.0033244150500628677, 0.10494040221505041, 0.10155492304077485, 0.1089409292997281, 0.11008273452608741, 0.10962746131635281, 0.10812795445203971, 0.11042701951425793, 0.11166675843553964, 0.1130887795523966, 0.3846828396604959, 0.37405867132577797, 0.39243629927419577, 0.39055349020145913, 0.360707056968976, 0.4094081185349603, 0.3764717535078874, 0.36884532133341497, 0.3924755609717697, 0.12293417903351289, 0.07347632339061094, 0.10086470501108447, 0.08884842948178862, 0.10502160511151082, 0.15641927600760097, 0.11308522371439345, 0.1076261385403321, 0.09007650977546933, 0.21202971685134953, 0.14440858035370185, 0.17276441961502442, 0.18602175424536382, 0.18723654298270087, 0.20877043667933726, 0.22596937556561458, 0.18580889879012052, 0.1507798519576793, 0.23337376019408218, 0.22479857781209822, 0.268890351203118, 0.24857757999092334, 0.25257597451738156, 0.2398322773217375, 0.24797325111426938, 0.2875718135726988, 0.2511005413962659, 0.17839110115850165, 0.17436950557895237, 0.17747795437339886, 0.19840690014781381, 0.16571617404730532, 0.17908499334342287, 0.19019917977145862, 0.21382099462315363, 0.18967458028721096, 0.20816048198075343, 0.18203411282435544, 0.20756793954735941, 0.1991588374300156, 0.2013780615001357, 0.1939718845812073, 0.18746805573949443, 0.2399514297932518, 0.20244146927753093, 0.22689376125160965, 0.20464785354547377, 0.1769092927830236, 0.2104062745312537, 0.18569839786075804, 0.18728932691988243, 0.1772705650746932, 0.17156978333824768, 0.18565140525410195, 0.168156461086711, 0.3373718693093166, 0.47647777677912884, 0.48558295882671587, 0.1900812491517383, 0.5542221592697896, 0.34659324947605696, 0.3868146724454238, 0.6568030753495627, 0.3788665413129082, 0.3409142194202206, 0.23421583772300714, 0.1846417057218398, 0.18119767938926812, 0.3435680271064868, 0.21756215981336569, 0.3452575892670092, 0.18777129490977518, 0.2028517659256569, 0.19459204982014455, 0.17918188876432428, 0.20014164320883587, 0.1959270139434245, 0.21191044380284774, 0.19085188972138634, 0.1950914475919321, 0.19722265418988894, 0.08812317558061478, 0.07936026354765491, 0.08324351815750564, 0.08468402970149636, 0.08228002275214763, 0.07169103243006081, 0.1107937574886062, 0.09881600769143284, 0.07901690314873433]}, "mutation_prompt": null}
{"id": "5e7e4eea-81cf-4f73-a827-f0f7f9977de5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control and stochastic perturbation for robust optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.46349311938485205, 0.45573029579144053, 0.44178594923404757, 0.45132867936012, 0.4666546876583595, 0.4463370385880451, 0.45550942877604084, 0.45398991414136025, 0.45183452276841585, 0.0850945946530497, 0.08018340325888784, 0.09470780997427797, 0.0813865628732503, 0.07519116165979955, 0.10103808670116199, 0.07112938033755667, 0.09603938787229616, 0.09672433200899178, 0.12492408218721773, 0.11960057650798628, 0.1125363577280648, 0.12121842558212026, 0.087835612158074, 0.09144423985368977, 0.10178449886943453, 0.12729899115833743, 0.1184131948821181, 0.10780779604257262, 0.10030918782611131, 0.09064439854365114, 0.09560232554025261, 0.08636911907783962, 0.09185817014302189, 0.11192253446688483, 0.11570896563778366, 0.10176251520208102, 0.7298838412743398, 0.7655591070005325, 0.783451140397938, 0.7437997241233434, 0.8081971311051066, 0.6689912075320137, 0.7636966694275198, 0.7686382322035197, 0.7702129398425329, 0.2846409045558387, 0.2773552701049584, 0.1959760987534369, 0.20302709581766898, 0.22480799296892606, 0.22141840616762243, 0.24169171725038574, 0.235598352071149, 0.22789492938170652, 0.5444082632033935, 0.265218668733607, 0.2812442156209385, 0.2574288028171662, 0.248242830796641, 0.26041522739944223, 0.5178665258542174, 0.38060516283001555, 0.6921147282783475, 0.19620061631653196, 0.1948390186760044, 0.13855856219703855, 0.18948045475110686, 0.12262180509183995, 0.12159202158663263, 0.16749793681448244, 0.17827699239452355, 0.154311834023094, 0.22221853865984165, 0.12496133382911245, 0.212804531746846, 0.18864534968242974, 0.21438147305734856, 0.15409155726307222, 0.16462446871507042, 0.13164492990004562, 0.12847905644717816, 0.01322654626345543, 0.06397603704764554, 0.028875106860125732, 0.030569405876631928, 0.03159296437517911, 0.026737192938114496, 0.060321276925884404, 0.025126676197182896, 0.04249964735128464, 0.12865633822979305, 0.09636707600128536, 0.149722475211703, 0.13540773403465867, 0.13846895096370315, 0.1186820793059109, 0.13735101882107925, 0.14756899918475974, 0.1338606966104402, 9.999999999998899e-05, 0.0035321447188063626, 0.007456553917736364, 0.011038712476612256, 9.999999999998899e-05, 0.00233458327167535, 0.0007959064472157218, 0.0258610655375352, 0.0001103006377516369, 0.1079850852843105, 0.1120040797723344, 0.13991753388015826, 0.10574370744969341, 0.09894996007354162, 0.11447896778773903, 0.09641935194031537, 0.11896313854926388, 0.1396768128371274, 0.4016370880782053, 0.40629887492902284, 0.39104056761254746, 0.38303149995573227, 0.37734957137392144, 0.417846292043092, 0.42390756253164097, 0.36548566501233504, 0.3953396704204707, 0.0983007330765413, 0.10980095759317665, 0.14061812434034893, 0.11134172401381892, 0.11725881319318321, 0.1471303782850738, 0.10278355460708499, 0.12625155963867052, 0.12366695481074352, 0.1490805443025809, 0.23600200825560136, 0.22208864349813562, 0.33297554793228035, 0.17197884759285298, 0.17300473677925288, 0.16387099658670068, 0.18567758126636247, 0.18364850081817496, 0.22279931498292893, 0.24179063816142832, 0.23840299166514223, 0.2744121951147368, 0.22197858930613357, 0.23195495710765257, 0.2332901972259721, 0.2485539752721858, 0.23688460188899585, 0.1947487284597692, 0.1706200786465355, 0.19313883127171094, 0.1772502838989234, 0.206623886094212, 0.15827430187038094, 0.17588423027771527, 0.20940763978508736, 0.18134971558601565, 0.20708095587254582, 0.17119502708868273, 0.1797549852321858, 0.18239095681796313, 0.19012857048062592, 0.20727085664013156, 0.20530462814036687, 0.18433827959254823, 0.19869506799894676, 0.19396444457402873, 0.18457539530762468, 0.19466906295307695, 0.20500109174692116, 0.17625195251636583, 0.18298647626678144, 0.19555495096807485, 0.20620750665718557, 0.17882174773220072, 0.6992679229550403, 0.2081089062641156, 0.4622401294339563, 0.6159912363398703, 0.19886536112657227, 0.4992037562378465, 0.17039445316306046, 0.24610529384635838, 0.4911964563233596, 0.404207145374439, 0.2012316776141706, 0.3412903686447033, 0.553635513548889, 0.1875699461891931, 0.21878571906978095, 0.1865665879582492, 0.360552778832649, 0.219798272653568, 0.17691817228978213, 0.20188183101454393, 0.19901412369287041, 0.1834779321440968, 0.18046692142682352, 0.19760312609706865, 0.18407593246175158, 0.17465610462328096, 0.18752340260800704, 0.08260058057927122, 0.09382255279377605, 0.0888925549510251, 0.08958824022019762, 0.07216623104078057, 0.07514853449642467, 0.08265043208190237, 0.07969064632097833, 0.08305143392216541]}, "mutation_prompt": null}
{"id": "09ec8daf-afb2-4088-884b-eb9a10bd791a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveCED:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = np.random.uniform(0.4, 1.0)  # Adjusted mutation factor strategy\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.6 * (d - b), *self.bounds)  # Increased perturbation\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01  # Adjusted step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):  # Reduced iterations for neighborhood search\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        def cooperative_coevolution(population):\n            segments = 3  # Divide dimensions into segments for cooperative search\n            seg_dim = self.dim // segments\n            for start in range(0, self.dim, seg_dim):\n                end = start + seg_dim\n                for individual in population:\n                    sub_vector = individual[start:end]\n                    sub_vector = neighborhood_search(sub_vector)\n                    individual[start:end] = sub_vector\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                cooperative_coevolution(population)\n                population = sorted(population, key=func)\n                best_count = max(5, self.population_size // 10)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveCED", "description": "A refined differential evolution with adaptive strategies and stochastic perturbations complemented by a cooperative co-evolutionary approach.", "configspace": "", "generation": 40, "fitness": 0.08098745218833843, "feedback": "The algorithm EnhancedAdaptiveCED got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.06.", "error": "", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.14040219377350716, 0.11940141000115712, 0.1258849683704446, 0.12926078598994972, 0.13982868226685785, 0.132470992264917, 0.15165698440858633, 0.14249620501994464, 0.11447746784551727, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.051514555342838886, 0.0526936605477345, 0.05010673820994649, 0.04017560480610649, 0.025199893062330947, 0.0300237475568228, 0.030897508550378316, 0.04473270903752513, 0.027032108200252924, 0.06580930409366448, 0.06488280300485205, 0.06661679706127033, 0.029486341464509347, 0.026537020291045654, 0.027135303649335918, 0.017668871910551442, 0.009971992948428654, 0.011757917622276404, 0.13174174475485345, 0.09044031436379718, 0.08827724709641493, 0.17600492409061863, 0.09832063498575283, 0.09957865616959005, 0.08537381645601327, 0.13782016494518978, 0.0830475883141738, 0.06893693689143898, 0.020124090320211896, 0.02152708381139634, 0.022095449784413912, 0.02096369885309901, 0.023342361889945096, 0.027051196775878417, 0.027082575855001068, 0.014577972402440742, 0.13164312296791647, 0.15224726399083321, 0.1257997784330277, 0.1297833892864082, 0.09027718661492123, 0.06636575111563947, 0.05078853857387822, 0.0923157788699035, 0.05667520345406707, 0.002418308510979128, 0.0021380677344717824, 0.0029332214755558583, 0.003018949396549564, 0.0031902321000271128, 0.0035339614036056233, 0.005352503332860192, 0.003098252139432267, 0.00026705395218018513, 0.07797696368283691, 0.07659999996531497, 0.07649369570157738, 0.06653652117332443, 0.06691112710414959, 0.07283935025373156, 0.06673774095488794, 0.07269194680017177, 0.07129026881739631, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09000639636451102, 0.029662219024200187, 0.06494364299970024, 0.06680253008315862, 0.050617187483682935, 0.058282445551294804, 0.039608195534294066, 0.020919023115195667, 0.010022244841976113, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017255332702071913, 0.00022605448090651237, 0.0021069701648935846, 0.0007621918561322438, 0.00048820645755409675, 0.00234834197968381, 0.0005251432995638794, 0.0003899361529416945, 0.001359085813381511, 0.13196473114153728, 0.17842211169769417, 0.1692190437372888, 0.1725274964689274, 0.13838942461574755, 0.13418999900516315, 0.20163328467291963, 0.15919646342249416, 0.16317903957124213, 0.028271881114829145, 0.018748520139257874, 0.041096469492293175, 0.06232390908771812, 0.057437889282787036, 0.05914644325126395, 0.04889175663407663, 0.03548675866902762, 0.047379500687676934, 0.10690396811988834, 0.10780175442523199, 0.14700117267175228, 0.16571862712177954, 0.12293891262819912, 0.1240452657436445, 0.13869078955796066, 0.10920388664094338, 0.12627184912170653, 0.13518576981680286, 0.13078979332637575, 0.1618602958647809, 0.15110144240924162, 0.15636586703558475, 0.1508863163485188, 0.1553805648717791, 0.17962215995171738, 0.1647288757704446, 0.07810310665018638, 0.09837302145795146, 0.09828880014164387, 0.10777631424554479, 0.10220120597634286, 0.10782821062302606, 0.09394649755957196, 0.11580247729546123, 0.09047742828651639, 0.20979832356336614, 0.2621048483926983, 0.1970846170031375, 0.2150663377225671, 0.214087100319718, 0.22022514977232222, 0.19884516153019316, 0.20981152803780145, 0.22837471997813896, 0.03520579703890103, 0.027875662742555818, 0.11430190131442919, 0.15610904356298305, 0.1550389558888846, 0.15755518326789586, 0.15700064606967756, 0.15328126670142916, 0.1569760712611583, 0.10925260751388555, 0.10223539305711005, 0.09786309027228157, 0.11692038484317802, 0.13448413384422453, 0.1137786623204885, 0.12303078539894796, 0.12116445460612335, 0.1033735797055042, 0.16274608398994383, 0.1294323079841201, 0.10022633418654969, 0.09903075249337256, 0.07907738641619289, 0.11315405265592193, 0.0695949205384121, 0.09647056585951364, 0.09722386180966036, 0.1849190556382253, 0.17761914407718382, 0.18171048399968903, 0.17535078689354666, 0.18540266678985895, 0.1853653724042137, 0.18261501313883233, 0.17878031939543493, 0.17753979950096366, 0.04599517490098348, 0.04192796276012645, 0.04472334116748611, 0.04534209773052156, 0.04547649275482202, 0.04162599810428236, 0.05706010686882712, 0.054985678789363224, 0.05640085840899989]}, "mutation_prompt": null}
{"id": "c8a756f9-c414-4665-a034-498f83943639", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control and stochastic perturbation for robust optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.46349311938485205, 0.45573029579144053, 0.44178594923404757, 0.45132867936012, 0.4666546876583595, 0.4463370385880451, 0.45550942877604084, 0.45398991414136025, 0.45183452276841585, 0.0850945946530497, 0.08018340325888784, 0.09470780997427797, 0.0813865628732503, 0.07519116165979955, 0.10103808670116199, 0.07112938033755667, 0.09603938787229616, 0.09672433200899178, 0.12492408218721773, 0.11960057650798628, 0.1125363577280648, 0.12121842558212026, 0.087835612158074, 0.09144423985368977, 0.10178449886943453, 0.12729899115833743, 0.1184131948821181, 0.10780779604257262, 0.10030918782611131, 0.09064439854365114, 0.09560232554025261, 0.08636911907783962, 0.09185817014302189, 0.11192253446688483, 0.11570896563778366, 0.10176251520208102, 0.7298838412743398, 0.7655591070005325, 0.783451140397938, 0.7437997241233434, 0.8081971311051066, 0.6689912075320137, 0.7636966694275198, 0.7686382322035197, 0.7702129398425329, 0.2846409045558387, 0.2773552701049584, 0.1959760987534369, 0.20302709581766898, 0.22480799296892606, 0.22141840616762243, 0.24169171725038574, 0.235598352071149, 0.22789492938170652, 0.5444082632033935, 0.265218668733607, 0.2812442156209385, 0.2574288028171662, 0.248242830796641, 0.26041522739944223, 0.5178665258542174, 0.38060516283001555, 0.6921147282783475, 0.19620061631653196, 0.1948390186760044, 0.13855856219703855, 0.18948045475110686, 0.12262180509183995, 0.12159202158663263, 0.16749793681448244, 0.17827699239452355, 0.154311834023094, 0.22221853865984165, 0.12496133382911245, 0.212804531746846, 0.18864534968242974, 0.21438147305734856, 0.15409155726307222, 0.16462446871507042, 0.13164492990004562, 0.12847905644717816, 0.01322654626345543, 0.06397603704764554, 0.028875106860125732, 0.030569405876631928, 0.03159296437517911, 0.026737192938114496, 0.060321276925884404, 0.025126676197182896, 0.04249964735128464, 0.12865633822979305, 0.09636707600128536, 0.149722475211703, 0.13540773403465867, 0.13846895096370315, 0.1186820793059109, 0.13735101882107925, 0.14756899918475974, 0.1338606966104402, 9.999999999998899e-05, 0.0035321447188063626, 0.007456553917736364, 0.011038712476612256, 9.999999999998899e-05, 0.00233458327167535, 0.0007959064472157218, 0.0258610655375352, 0.0001103006377516369, 0.1079850852843105, 0.1120040797723344, 0.13991753388015826, 0.10574370744969341, 0.09894996007354162, 0.11447896778773903, 0.09641935194031537, 0.11896313854926388, 0.1396768128371274, 0.4016370880782053, 0.40629887492902284, 0.39104056761254746, 0.38303149995573227, 0.37734957137392144, 0.417846292043092, 0.42390756253164097, 0.36548566501233504, 0.3953396704204707, 0.0983007330765413, 0.10980095759317665, 0.14061812434034893, 0.11134172401381892, 0.11725881319318321, 0.1471303782850738, 0.10278355460708499, 0.12625155963867052, 0.12366695481074352, 0.1490805443025809, 0.23600200825560136, 0.22208864349813562, 0.33297554793228035, 0.17197884759285298, 0.17300473677925288, 0.16387099658670068, 0.18567758126636247, 0.18364850081817496, 0.22279931498292893, 0.24179063816142832, 0.23840299166514223, 0.2744121951147368, 0.22197858930613357, 0.23195495710765257, 0.2332901972259721, 0.2485539752721858, 0.23688460188899585, 0.1947487284597692, 0.1706200786465355, 0.19313883127171094, 0.1772502838989234, 0.206623886094212, 0.15827430187038094, 0.17588423027771527, 0.20940763978508736, 0.18134971558601565, 0.20708095587254582, 0.17119502708868273, 0.1797549852321858, 0.18239095681796313, 0.19012857048062592, 0.20727085664013156, 0.20530462814036687, 0.18433827959254823, 0.19869506799894676, 0.19396444457402873, 0.18457539530762468, 0.19466906295307695, 0.20500109174692116, 0.17625195251636583, 0.18298647626678144, 0.19555495096807485, 0.20620750665718557, 0.17882174773220072, 0.6992679229550403, 0.2081089062641156, 0.4622401294339563, 0.6159912363398703, 0.19886536112657227, 0.4992037562378465, 0.17039445316306046, 0.24610529384635838, 0.4911964563233596, 0.404207145374439, 0.2012316776141706, 0.3412903686447033, 0.553635513548889, 0.1875699461891931, 0.21878571906978095, 0.1865665879582492, 0.360552778832649, 0.219798272653568, 0.17691817228978213, 0.20188183101454393, 0.19901412369287041, 0.1834779321440968, 0.18046692142682352, 0.19760312609706865, 0.18407593246175158, 0.17465610462328096, 0.18752340260800704, 0.08260058057927122, 0.09382255279377605, 0.0888925549510251, 0.08958824022019762, 0.07216623104078057, 0.07514853449642467, 0.08265043208190237, 0.07969064632097833, 0.08305143392216541]}, "mutation_prompt": null}
{"id": "e46110cb-ae99-4295-b32b-3acf573dc3ce", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control and stochastic perturbation for robust optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.46349311938485205, 0.45573029579144053, 0.44178594923404757, 0.45132867936012, 0.4666546876583595, 0.4463370385880451, 0.45550942877604084, 0.45398991414136025, 0.45183452276841585, 0.0850945946530497, 0.08018340325888784, 0.09470780997427797, 0.0813865628732503, 0.07519116165979955, 0.10103808670116199, 0.07112938033755667, 0.09603938787229616, 0.09672433200899178, 0.12492408218721773, 0.11960057650798628, 0.1125363577280648, 0.12121842558212026, 0.087835612158074, 0.09144423985368977, 0.10178449886943453, 0.12729899115833743, 0.1184131948821181, 0.10780779604257262, 0.10030918782611131, 0.09064439854365114, 0.09560232554025261, 0.08636911907783962, 0.09185817014302189, 0.11192253446688483, 0.11570896563778366, 0.10176251520208102, 0.7298838412743398, 0.7655591070005325, 0.783451140397938, 0.7437997241233434, 0.8081971311051066, 0.6689912075320137, 0.7636966694275198, 0.7686382322035197, 0.7702129398425329, 0.2846409045558387, 0.2773552701049584, 0.1959760987534369, 0.20302709581766898, 0.22480799296892606, 0.22141840616762243, 0.24169171725038574, 0.235598352071149, 0.22789492938170652, 0.5444082632033935, 0.265218668733607, 0.2812442156209385, 0.2574288028171662, 0.248242830796641, 0.26041522739944223, 0.5178665258542174, 0.38060516283001555, 0.6921147282783475, 0.19620061631653196, 0.1948390186760044, 0.13855856219703855, 0.18948045475110686, 0.12262180509183995, 0.12159202158663263, 0.16749793681448244, 0.17827699239452355, 0.154311834023094, 0.22221853865984165, 0.12496133382911245, 0.212804531746846, 0.18864534968242974, 0.21438147305734856, 0.15409155726307222, 0.16462446871507042, 0.13164492990004562, 0.12847905644717816, 0.01322654626345543, 0.06397603704764554, 0.028875106860125732, 0.030569405876631928, 0.03159296437517911, 0.026737192938114496, 0.060321276925884404, 0.025126676197182896, 0.04249964735128464, 0.12865633822979305, 0.09636707600128536, 0.149722475211703, 0.13540773403465867, 0.13846895096370315, 0.1186820793059109, 0.13735101882107925, 0.14756899918475974, 0.1338606966104402, 9.999999999998899e-05, 0.0035321447188063626, 0.007456553917736364, 0.011038712476612256, 9.999999999998899e-05, 0.00233458327167535, 0.0007959064472157218, 0.0258610655375352, 0.0001103006377516369, 0.1079850852843105, 0.1120040797723344, 0.13991753388015826, 0.10574370744969341, 0.09894996007354162, 0.11447896778773903, 0.09641935194031537, 0.11896313854926388, 0.1396768128371274, 0.4016370880782053, 0.40629887492902284, 0.39104056761254746, 0.38303149995573227, 0.37734957137392144, 0.417846292043092, 0.42390756253164097, 0.36548566501233504, 0.3953396704204707, 0.0983007330765413, 0.10980095759317665, 0.14061812434034893, 0.11134172401381892, 0.11725881319318321, 0.1471303782850738, 0.10278355460708499, 0.12625155963867052, 0.12366695481074352, 0.1490805443025809, 0.23600200825560136, 0.22208864349813562, 0.33297554793228035, 0.17197884759285298, 0.17300473677925288, 0.16387099658670068, 0.18567758126636247, 0.18364850081817496, 0.22279931498292893, 0.24179063816142832, 0.23840299166514223, 0.2744121951147368, 0.22197858930613357, 0.23195495710765257, 0.2332901972259721, 0.2485539752721858, 0.23688460188899585, 0.1947487284597692, 0.1706200786465355, 0.19313883127171094, 0.1772502838989234, 0.206623886094212, 0.15827430187038094, 0.17588423027771527, 0.20940763978508736, 0.18134971558601565, 0.20708095587254582, 0.17119502708868273, 0.1797549852321858, 0.18239095681796313, 0.19012857048062592, 0.20727085664013156, 0.20530462814036687, 0.18433827959254823, 0.19869506799894676, 0.19396444457402873, 0.18457539530762468, 0.19466906295307695, 0.20500109174692116, 0.17625195251636583, 0.18298647626678144, 0.19555495096807485, 0.20620750665718557, 0.17882174773220072, 0.6992679229550403, 0.2081089062641156, 0.4622401294339563, 0.6159912363398703, 0.19886536112657227, 0.4992037562378465, 0.17039445316306046, 0.24610529384635838, 0.4911964563233596, 0.404207145374439, 0.2012316776141706, 0.3412903686447033, 0.553635513548889, 0.1875699461891931, 0.21878571906978095, 0.1865665879582492, 0.360552778832649, 0.219798272653568, 0.17691817228978213, 0.20188183101454393, 0.19901412369287041, 0.1834779321440968, 0.18046692142682352, 0.19760312609706865, 0.18407593246175158, 0.17465610462328096, 0.18752340260800704, 0.08260058057927122, 0.09382255279377605, 0.0888925549510251, 0.08958824022019762, 0.07216623104078057, 0.07514853449642467, 0.08265043208190237, 0.07969064632097833, 0.08305143392216541]}, "mutation_prompt": null}
{"id": "306da20f-5376-4076-ad8f-b3474472a3a5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < 0.5:\n                    self.mutation_factor = self.adaptive_mutation_factor\n                \n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                else:\n                    new_population.append(population[i])\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def neighborhood_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(12):\n                perturbation = np.random.uniform(-step_size, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = neighborhood_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution with adaptive strategy control and stochastic perturbation for robust optimization.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.46349311938485205, 0.45573029579144053, 0.44178594923404757, 0.45132867936012, 0.4666546876583595, 0.4463370385880451, 0.45550942877604084, 0.45398991414136025, 0.45183452276841585, 0.0850945946530497, 0.08018340325888784, 0.09470780997427797, 0.0813865628732503, 0.07519116165979955, 0.10103808670116199, 0.07112938033755667, 0.09603938787229616, 0.09672433200899178, 0.12492408218721773, 0.11960057650798628, 0.1125363577280648, 0.12121842558212026, 0.087835612158074, 0.09144423985368977, 0.10178449886943453, 0.12729899115833743, 0.1184131948821181, 0.10780779604257262, 0.10030918782611131, 0.09064439854365114, 0.09560232554025261, 0.08636911907783962, 0.09185817014302189, 0.11192253446688483, 0.11570896563778366, 0.10176251520208102, 0.7298838412743398, 0.7655591070005325, 0.783451140397938, 0.7437997241233434, 0.8081971311051066, 0.6689912075320137, 0.7636966694275198, 0.7686382322035197, 0.7702129398425329, 0.2846409045558387, 0.2773552701049584, 0.1959760987534369, 0.20302709581766898, 0.22480799296892606, 0.22141840616762243, 0.24169171725038574, 0.235598352071149, 0.22789492938170652, 0.5444082632033935, 0.265218668733607, 0.2812442156209385, 0.2574288028171662, 0.248242830796641, 0.26041522739944223, 0.5178665258542174, 0.38060516283001555, 0.6921147282783475, 0.19620061631653196, 0.1948390186760044, 0.13855856219703855, 0.18948045475110686, 0.12262180509183995, 0.12159202158663263, 0.16749793681448244, 0.17827699239452355, 0.154311834023094, 0.22221853865984165, 0.12496133382911245, 0.212804531746846, 0.18864534968242974, 0.21438147305734856, 0.15409155726307222, 0.16462446871507042, 0.13164492990004562, 0.12847905644717816, 0.01322654626345543, 0.06397603704764554, 0.028875106860125732, 0.030569405876631928, 0.03159296437517911, 0.026737192938114496, 0.060321276925884404, 0.025126676197182896, 0.04249964735128464, 0.12865633822979305, 0.09636707600128536, 0.149722475211703, 0.13540773403465867, 0.13846895096370315, 0.1186820793059109, 0.13735101882107925, 0.14756899918475974, 0.1338606966104402, 9.999999999998899e-05, 0.0035321447188063626, 0.007456553917736364, 0.011038712476612256, 9.999999999998899e-05, 0.00233458327167535, 0.0007959064472157218, 0.0258610655375352, 0.0001103006377516369, 0.1079850852843105, 0.1120040797723344, 0.13991753388015826, 0.10574370744969341, 0.09894996007354162, 0.11447896778773903, 0.09641935194031537, 0.11896313854926388, 0.1396768128371274, 0.4016370880782053, 0.40629887492902284, 0.39104056761254746, 0.38303149995573227, 0.37734957137392144, 0.417846292043092, 0.42390756253164097, 0.36548566501233504, 0.3953396704204707, 0.0983007330765413, 0.10980095759317665, 0.14061812434034893, 0.11134172401381892, 0.11725881319318321, 0.1471303782850738, 0.10278355460708499, 0.12625155963867052, 0.12366695481074352, 0.1490805443025809, 0.23600200825560136, 0.22208864349813562, 0.33297554793228035, 0.17197884759285298, 0.17300473677925288, 0.16387099658670068, 0.18567758126636247, 0.18364850081817496, 0.22279931498292893, 0.24179063816142832, 0.23840299166514223, 0.2744121951147368, 0.22197858930613357, 0.23195495710765257, 0.2332901972259721, 0.2485539752721858, 0.23688460188899585, 0.1947487284597692, 0.1706200786465355, 0.19313883127171094, 0.1772502838989234, 0.206623886094212, 0.15827430187038094, 0.17588423027771527, 0.20940763978508736, 0.18134971558601565, 0.20708095587254582, 0.17119502708868273, 0.1797549852321858, 0.18239095681796313, 0.19012857048062592, 0.20727085664013156, 0.20530462814036687, 0.18433827959254823, 0.19869506799894676, 0.19396444457402873, 0.18457539530762468, 0.19466906295307695, 0.20500109174692116, 0.17625195251636583, 0.18298647626678144, 0.19555495096807485, 0.20620750665718557, 0.17882174773220072, 0.6992679229550403, 0.2081089062641156, 0.4622401294339563, 0.6159912363398703, 0.19886536112657227, 0.4992037562378465, 0.17039445316306046, 0.24610529384635838, 0.4911964563233596, 0.404207145374439, 0.2012316776141706, 0.3412903686447033, 0.553635513548889, 0.1875699461891931, 0.21878571906978095, 0.1865665879582492, 0.360552778832649, 0.219798272653568, 0.17691817228978213, 0.20188183101454393, 0.19901412369287041, 0.1834779321440968, 0.18046692142682352, 0.19760312609706865, 0.18407593246175158, 0.17465610462328096, 0.18752340260800704, 0.08260058057927122, 0.09382255279377605, 0.0888925549510251, 0.08958824022019762, 0.07216623104078057, 0.07514853449642467, 0.08265043208190237, 0.07969064632097833, 0.08305143392216541]}, "mutation_prompt": null}
{"id": "aa4e57ec-ea09-4330-9c54-07dcd496b547", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n        self.success_rate = 0.1\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                # Success-based learning of mutation factor\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = self.adaptive_mutation_factor\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.05)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 20)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridAdaptiveDE", "description": "A novel hybrid algorithm combining adaptive differential evolution with a dynamic local search and success-based learning mechanism.", "configspace": "", "generation": 44, "fitness": 0.22050901141165138, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "9ffaeb15-f9fe-4631-8480-02646c98de05", "metadata": {"aucs": [0.49989323639391425, 0.45152526374978996, 0.4615998097084182, 0.4577431035102828, 0.4691679556432792, 0.45873034530700374, 0.4338750308617515, 0.4852224361403088, 0.48594665965600503, 0.10012303088629337, 0.13120069762941566, 0.10399940762784154, 0.10401927587216886, 0.10914190955710801, 0.09763757882721114, 0.08654392375688535, 0.10878000359947504, 0.1002083848236065, 0.09870317576259491, 0.09122739369195221, 0.09854243926910877, 0.09439952973146815, 0.1021307027586259, 0.09303761292791402, 0.09897616905371376, 0.10862198658145539, 0.09867139161159999, 0.08808891426366372, 0.08889828120753884, 0.07858379363629342, 0.09172264879859793, 0.11151979553923719, 0.08104638677858367, 0.1044643343623275, 0.08680611894193258, 0.09013218648763999, 0.7528267775111057, 0.7634899685135124, 0.7320987096260754, 0.8421295426876052, 0.7075428041976044, 0.785115668357693, 0.7983038983126278, 0.8239197848936772, 0.8124032805967578, 0.23522593056291885, 0.22670400844292415, 0.21000130499024972, 0.21397636116064345, 0.25850161708448427, 0.22718340671523118, 0.2826143244430105, 0.2767961495630432, 0.27135873062511817, 0.30246578655401135, 0.31307746234930156, 0.3207957637572979, 0.30686071325435527, 0.449889412888969, 0.2891849088720799, 0.23816403629390903, 0.43647004826314273, 0.29487020096065997, 0.17587944451261006, 0.14367784196127664, 0.14728085391774148, 0.2224311242637489, 0.20719437241707983, 0.131339866905815, 0.23455939809280157, 0.15293203011076018, 0.14137249713800826, 0.19466234165695873, 0.11099623296300687, 0.131397889671104, 0.15337327367490816, 0.19358665096194705, 0.15395029588279774, 0.13626348732725746, 0.1845465445323442, 0.20315463094910757, 0.02571141566929891, 0.03452835942210497, 0.0321692625828045, 0.04010799268061016, 0.03476594964818813, 0.025774029946346477, 0.061398245973239285, 0.023693045246334754, 0.01932769817082336, 0.15281972387826515, 0.12073277429664664, 0.14351529343884617, 0.14678260302210877, 0.14934984712162513, 0.11519855506663113, 0.19307512398557347, 0.1580730050002398, 0.14661840800180903, 0.0001057747818884458, 0.000695487352177171, 9.999999999998899e-05, 0.005985928311511235, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019273966194436332, 0.012703195238168319, 9.999999999998899e-05, 0.1278429807061615, 0.10264714040029976, 0.12186507312454764, 0.09864406818909632, 0.10858893492725441, 0.1086507675510604, 0.10952180743552198, 0.10295722578060285, 0.10931693967855172, 0.4073781372248174, 0.40696356391478894, 0.4009677823904455, 0.37302189444065326, 0.39025541117597273, 0.400798321428955, 0.42186119484818374, 0.4109556361631812, 0.39199093686722797, 0.09745855417569982, 0.10853563842444514, 0.10821730607663249, 0.10024648461381636, 0.11542522339514472, 0.13973982092436488, 0.10732005317750848, 0.14085706758754368, 0.13184315090450327, 0.21611069762864432, 0.22921172454319183, 0.2139393136900044, 0.21448135286641012, 0.17021308479441555, 0.19968623860587642, 0.2983517512054483, 0.2610647953015821, 0.19575044380769313, 0.24692754411515794, 0.2323499240373249, 0.23683214168268274, 0.24737495191408065, 0.2755076581413002, 0.24900036256895397, 0.24493867441855788, 0.2508097694586956, 0.247581570861227, 0.19852903052191206, 0.1935914604936364, 0.19002381648808886, 0.19347526293981465, 0.1882529442791656, 0.18309081029551588, 0.1820704648225323, 0.197193264830004, 0.18287173932431722, 0.19833697141809303, 0.17942883156325007, 0.18232568255103454, 0.20479695689537025, 0.17198050721993696, 0.18547583881376717, 0.17220036086574797, 0.1797486388234213, 0.18338302718119814, 0.19230935231124435, 0.1841634331045634, 0.20444816037118296, 0.1869377820061, 0.17795896530958688, 0.17717545584904326, 0.2134441093075572, 0.18533764101861827, 0.2056330602162466, 0.5011773048968506, 0.6405456325417597, 0.5303066626775133, 0.29674722632810835, 0.534284890105817, 0.5246430093506211, 0.16495503288743463, 0.45773225552474417, 0.3828878434615034, 0.4137615675867927, 0.20352310648772332, 0.32989721777194003, 0.2833692506035558, 0.37116926376369785, 0.17766164590104505, 0.4511494011515438, 0.19274448376479858, 0.17276270347830136, 0.1892293009610433, 0.1805375075925869, 0.17607251703234905, 0.18405705601043842, 0.1662147813950101, 0.21005943879971978, 0.19372274996200445, 0.2038139146866571, 0.17351781015710965, 0.07172130962802425, 0.08210575262185282, 0.07528981210192853, 0.06722967124689017, 0.07762261410553362, 0.07508633191670155, 0.06943044345720284, 0.0697916798188375, 0.07997918232290269]}, "mutation_prompt": null}
{"id": "4e5bc66c-ce51-4b6d-a351-530f6d66a365", "solution": "import numpy as np\n\nclass HybridAdaptiveDERanked:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n        self.success_rate = 0.1\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = self.adaptive_mutation_factor\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + np.random.uniform(0.3, 0.7) * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.05)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(15):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        def stochastic_ranking(population):\n            ranked_population = sorted(population, key=func)\n            return ranked_population[:self.population_size]\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:\n                best_count = max(3, self.population_size // 20)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n                population = stochastic_ranking(population)\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridAdaptiveDERanked", "description": "A novel hybrid algorithm blending adaptive differential evolution with dynamic local search and stochastic ranking for improved exploration and exploitation balance.", "configspace": "", "generation": 45, "fitness": 0.21645988068273303, "feedback": "The algorithm HybridAdaptiveDERanked got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "aa4e57ec-ea09-4330-9c54-07dcd496b547", "metadata": {"aucs": [0.4592576525809432, 0.44620301963184594, 0.46555165227811357, 0.45623947772814355, 0.4576539907162922, 0.4881051389059331, 0.45194016409944227, 0.4536408784656264, 0.4773420729641584, 0.11031554432820012, 0.09612437255970452, 0.08833168631041077, 0.07061278899155243, 0.07210373999142561, 0.09810548309996281, 0.08380488272986808, 0.07379211703846045, 0.13892978651000343, 0.09810303447588709, 0.12155316252446302, 0.12021818994411715, 0.09678194840731613, 0.1236266893246375, 0.10959826243831161, 0.09117520620066477, 0.11623528216245016, 0.12179914132998837, 0.09833808508954445, 0.08327352055565485, 0.07629015921874183, 0.08589234821550451, 0.08084356315958463, 0.10209421738301261, 0.09268909567740213, 0.09270020765058595, 0.08291864698682239, 0.7810767142483842, 0.7505264222998524, 0.9018812012227635, 0.7004302946180871, 0.8855357584008134, 0.7876947847082771, 0.7580735694427507, 0.6195217215255631, 0.8493854640737549, 0.2709704579962795, 0.26632695623084324, 0.19604613035729312, 0.25294809724449663, 0.26289127063455686, 0.27621809093227423, 0.2813593799715002, 0.2673279254506483, 0.27616932847635, 0.33500167409182935, 0.26706697724984874, 0.49909369994279584, 0.3646467635363769, 0.49862508471601785, 0.3149329416141261, 0.2693713731847509, 0.2357940801409124, 0.5070170681852686, 0.19579082634019496, 0.17036642696908277, 0.1231136169017304, 0.13238028381325306, 0.1233318669709228, 0.1768320268672231, 0.14913432721244557, 0.21327691175330354, 0.14301436689118818, 0.2024907027707279, 0.15572034839035043, 0.11901540564565216, 0.15982160341529794, 0.1483615971302379, 0.12987954878549413, 0.23177805438093824, 0.17322663694159923, 0.11246858727222642, 0.018831149631407418, 0.0072135337128426125, 0.05332272031913721, 0.030843986521087885, 0.04901317116798287, 0.011314326747813852, 0.034710201466535695, 0.02210554505190543, 0.03439507543802611, 0.1339007802641743, 0.12311748777743248, 0.14783584026536623, 0.11509870186026006, 0.11810567398111504, 0.08710686658165268, 0.15194491194587167, 0.12895445360536872, 0.1448553358441652, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023718817170987894, 9.999999999998899e-05, 9.999999999998899e-05, 0.00888029854365524, 9.999999999998899e-05, 0.0042799865278013716, 9.999999999998899e-05, 0.1117154846668389, 0.07651277457525085, 0.11846526519218281, 0.09266696427003296, 0.08191042808372873, 0.12767785912320284, 0.10998088499822423, 0.10857020631932024, 0.09905659367319242, 0.40853051395242745, 0.418462603738191, 0.43314087453927863, 0.41452899442683433, 0.38573215807794703, 0.44065149569813666, 0.43800384176116147, 0.39470258414905646, 0.40881119387890363, 0.08405625461553223, 0.11990245613589012, 0.11502130595143245, 0.10895139192929204, 0.12297758306931461, 0.10920633636865662, 0.11476727411212995, 0.08831239562276838, 0.10365098845951581, 0.18833129686721173, 0.21188491278402444, 0.24259656009443942, 0.28845697258469827, 0.2689087756260098, 0.2530751938432676, 0.22781627880421818, 0.24755101175987193, 0.1810346847554406, 0.24674452454846718, 0.24275475357414034, 0.23563435413945932, 0.24643850166067305, 0.2579561190720371, 0.22905347179311408, 0.24284020102046655, 0.24948125224708295, 0.23963408882787784, 0.19527604563025625, 0.19024625479641366, 0.18214329812268615, 0.17622212914134505, 0.18800595295645528, 0.20503330599989245, 0.21060910700200597, 0.20402769011085642, 0.17930377931725638, 0.19278971079752028, 0.24628418927622464, 0.1933120862447052, 0.19896333245664355, 0.1858787400431524, 0.19237505428597745, 0.17121027562571745, 0.18642539309741946, 0.18790669387877734, 0.17419941092404645, 0.1751452636469063, 0.17461307523967828, 0.24060564062602763, 0.1880613059061752, 0.182844412652853, 0.19707045035536153, 0.1806968061431493, 0.16753264454815775, 0.16870093809874775, 0.17833913203924734, 0.6439293234449773, 0.46071421946417357, 0.1955606203815835, 0.1631852574406183, 0.1747041929721378, 0.17221276497406401, 0.24665724197762984, 0.3996921216176429, 0.20405113625851168, 0.529586266877504, 0.5003181625935167, 0.22101424295530514, 0.2603022521122662, 0.36838097945178694, 0.2938418876041916, 0.3988812310087546, 0.20279556931399778, 0.17913068172671465, 0.19058645579896327, 0.1695448317458187, 0.18991130057826, 0.1756551232547876, 0.16960097873117208, 0.17574880630651057, 0.1743521393431553, 0.08408840718733357, 0.06158964077853002, 0.07388407399748398, 0.08245713577786062, 0.07460400162697456, 0.07269993578864309, 0.09950610231593326, 0.0739481594694733, 0.07529369464569902]}, "mutation_prompt": null}
{"id": "05690784-e6ce-48c0-86cc-873e4624e502", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n        self.success_rate = 0.1\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                # Success-based learning of mutation factor\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = self.adaptive_mutation_factor\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.5 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.05)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(10):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 20)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridAdaptiveDE", "description": "A novel hybrid algorithm combining adaptive differential evolution with a dynamic local search and success-based learning mechanism.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "aa4e57ec-ea09-4330-9c54-07dcd496b547", "metadata": {"aucs": [0.49989323639391425, 0.45152526374978996, 0.4615998097084182, 0.4577431035102828, 0.4691679556432792, 0.45873034530700374, 0.4338750308617515, 0.4852224361403088, 0.48594665965600503, 0.10012303088629337, 0.13120069762941566, 0.10399940762784154, 0.10401927587216886, 0.10914190955710801, 0.09763757882721114, 0.08654392375688535, 0.10878000359947504, 0.1002083848236065, 0.09870317576259491, 0.09122739369195221, 0.09854243926910877, 0.09439952973146815, 0.1021307027586259, 0.09303761292791402, 0.09897616905371376, 0.10862198658145539, 0.09867139161159999, 0.08808891426366372, 0.08889828120753884, 0.07858379363629342, 0.09172264879859793, 0.11151979553923719, 0.08104638677858367, 0.1044643343623275, 0.08680611894193258, 0.09013218648763999, 0.7528267775111057, 0.7634899685135124, 0.7320987096260754, 0.8421295426876052, 0.7075428041976044, 0.785115668357693, 0.7983038983126278, 0.8239197848936772, 0.8124032805967578, 0.23522593056291885, 0.22670400844292415, 0.21000130499024972, 0.21397636116064345, 0.25850161708448427, 0.22718340671523118, 0.2826143244430105, 0.2767961495630432, 0.27135873062511817, 0.30246578655401135, 0.31307746234930156, 0.3207957637572979, 0.30686071325435527, 0.449889412888969, 0.2891849088720799, 0.23816403629390903, 0.43647004826314273, 0.29487020096065997, 0.17587944451261006, 0.14367784196127664, 0.14728085391774148, 0.2224311242637489, 0.20719437241707983, 0.131339866905815, 0.23455939809280157, 0.15293203011076018, 0.14137249713800826, 0.19466234165695873, 0.11099623296300687, 0.131397889671104, 0.15337327367490816, 0.19358665096194705, 0.15395029588279774, 0.13626348732725746, 0.1845465445323442, 0.20315463094910757, 0.02571141566929891, 0.03452835942210497, 0.0321692625828045, 0.04010799268061016, 0.03476594964818813, 0.025774029946346477, 0.061398245973239285, 0.023693045246334754, 0.01932769817082336, 0.15281972387826515, 0.12073277429664664, 0.14351529343884617, 0.14678260302210877, 0.14934984712162513, 0.11519855506663113, 0.19307512398557347, 0.1580730050002398, 0.14661840800180903, 0.0001057747818884458, 0.000695487352177171, 9.999999999998899e-05, 0.005985928311511235, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019273966194436332, 0.012703195238168319, 9.999999999998899e-05, 0.1278429807061615, 0.10264714040029976, 0.12186507312454764, 0.09864406818909632, 0.10858893492725441, 0.1086507675510604, 0.10952180743552198, 0.10295722578060285, 0.10931693967855172, 0.4073781372248174, 0.40696356391478894, 0.4009677823904455, 0.37302189444065326, 0.39025541117597273, 0.400798321428955, 0.42186119484818374, 0.4109556361631812, 0.39199093686722797, 0.09745855417569982, 0.10853563842444514, 0.10821730607663249, 0.10024648461381636, 0.11542522339514472, 0.13973982092436488, 0.10732005317750848, 0.14085706758754368, 0.13184315090450327, 0.21611069762864432, 0.22921172454319183, 0.2139393136900044, 0.21448135286641012, 0.17021308479441555, 0.19968623860587642, 0.2983517512054483, 0.2610647953015821, 0.19575044380769313, 0.24692754411515794, 0.2323499240373249, 0.23683214168268274, 0.24737495191408065, 0.2755076581413002, 0.24900036256895397, 0.24493867441855788, 0.2508097694586956, 0.247581570861227, 0.19852903052191206, 0.1935914604936364, 0.19002381648808886, 0.19347526293981465, 0.1882529442791656, 0.18309081029551588, 0.1820704648225323, 0.197193264830004, 0.18287173932431722, 0.19833697141809303, 0.17942883156325007, 0.18232568255103454, 0.20479695689537025, 0.17198050721993696, 0.18547583881376717, 0.17220036086574797, 0.1797486388234213, 0.18338302718119814, 0.19230935231124435, 0.1841634331045634, 0.20444816037118296, 0.1869377820061, 0.17795896530958688, 0.17717545584904326, 0.2134441093075572, 0.18533764101861827, 0.2056330602162466, 0.5011773048968506, 0.6405456325417597, 0.5303066626775133, 0.29674722632810835, 0.534284890105817, 0.5246430093506211, 0.16495503288743463, 0.45773225552474417, 0.3828878434615034, 0.4137615675867927, 0.20352310648772332, 0.32989721777194003, 0.2833692506035558, 0.37116926376369785, 0.17766164590104505, 0.4511494011515438, 0.19274448376479858, 0.17276270347830136, 0.1892293009610433, 0.1805375075925869, 0.17607251703234905, 0.18405705601043842, 0.1662147813950101, 0.21005943879971978, 0.19372274996200445, 0.2038139146866571, 0.17351781015710965, 0.07172130962802425, 0.08210575262185282, 0.07528981210192853, 0.06722967124689017, 0.07762261410553362, 0.07508633191670155, 0.06943044345720284, 0.0697916798188375, 0.07997918232290269]}, "mutation_prompt": null}
{"id": "3b882c8c-0cc0-4fb2-a92e-5ff28dd8fbf0", "solution": "import numpy as np\n\nclass EnhancedIslandDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n        self.success_rate = 0.2\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                # Stochastic parameter adaptation\n                current_mutation_factor = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1))\n                \n                mutant = np.clip(a + current_mutation_factor * (b - c) + 0.6 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.07)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.03)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_island_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(8):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.5:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_island_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedIslandDE", "description": "An enhanced adaptive differential evolution algorithm incorporating dynamic island models and stochastic parameter adaptation to improve convergence.", "configspace": "", "generation": 47, "fitness": 0.19795899867331943, "feedback": "The algorithm EnhancedIslandDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "aa4e57ec-ea09-4330-9c54-07dcd496b547", "metadata": {"aucs": [0.41147080609042397, 0.4170716339183753, 0.4465412741950716, 0.4048510748846813, 0.4297770417502452, 0.4277415468632355, 0.4276064610162349, 0.4081630284487907, 0.4391213149927047, 0.06460145969504516, 0.05169332499754198, 0.051987473603638534, 0.05499584372770405, 0.06420964310272481, 0.07562089362018454, 0.046238768437796174, 0.050299111489405135, 0.06456611627676356, 0.09580144782827815, 0.08567959119828394, 0.09761366605547228, 0.11801939765349778, 0.08990998726746968, 0.08328870692605195, 0.10768656359442852, 0.09363399655410554, 0.09413555598072254, 0.06550238092432015, 0.06844395865806596, 0.0655245732577101, 0.10564752425934965, 0.06905924442350242, 0.09527462990209246, 0.0912632220789712, 0.07489681902514134, 0.06745163598480663, 0.8319547258003133, 0.9176224696518912, 0.879880875546126, 0.8946804345911612, 0.8386145603380415, 0.8918436269547813, 0.8373583052179486, 0.8702114647822492, 0.905125724367075, 0.22295992409160703, 0.2335410189937338, 0.23943193888367464, 0.2791665913758319, 0.2251126635326688, 0.2511317623181113, 0.24525396429161173, 0.25436842891945854, 0.2535436355536199, 0.21446623241286356, 0.1985964388685144, 0.18089452735036615, 0.27393761544905015, 0.2971573976786789, 0.3951848629431721, 0.26471986473692755, 0.27330268487133935, 0.20770725337654383, 0.19481607684940583, 0.11832389816214839, 0.1284180034020843, 0.16287383082428297, 0.14495716566915673, 0.11989029840670173, 0.142263354643401, 0.13422745736693398, 0.12076655428854643, 0.17205967155272994, 0.19706421457064138, 0.18994878085555578, 0.16136591658298005, 0.11209159822699766, 0.1446193018642118, 0.15925884650724964, 0.1288372158320208, 0.16287323817479482, 0.02378371617870345, 9.999999999998899e-05, 9.999999999998899e-05, 0.008249123365535738, 0.0006100040776291227, 0.004779372899290535, 9.999999999998899e-05, 0.01092868604242192, 0.01480298246866929, 0.055270052306274575, 0.08523550406341707, 0.09577185382471876, 0.07721502865968455, 0.06941133018633538, 0.1185478103277694, 0.12187329674386349, 0.11343162002502782, 0.08580193640066913, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0759118368504591, 0.08543191070324663, 0.08766359358286846, 0.07813940770646166, 0.08513318116149349, 0.08342722240510281, 0.09100277165960757, 0.09330043707282931, 0.06539971878422035, 0.37306299310266267, 0.37236299887136015, 0.36655509048963364, 0.3758550680619521, 0.3687055013678455, 0.3822244515651587, 0.39658245073517495, 0.3560352378944144, 0.3560025194948254, 0.12416266553538224, 0.11039235431181404, 0.09739752423484793, 0.07758463458222264, 0.0948971296324378, 0.08370925907041804, 0.07102621254518982, 0.09267362150754721, 0.10850557361738267, 0.22701858941791686, 0.2038790163724149, 0.22463858905374767, 0.25434115551943526, 0.20749848695639062, 0.1944439323421191, 0.2525904771872729, 0.28065087481795714, 0.16862556706312648, 0.23855226129828966, 0.21599808619922012, 0.18812260388004165, 0.21663000367933782, 0.18919255944837787, 0.221487469903216, 0.2497170360617864, 0.25282788488701613, 0.23530182670133937, 0.15623125899495738, 0.20510946045044176, 0.1523669780950826, 0.15995559854950114, 0.15047815718906854, 0.15738931284286428, 0.20494621907100496, 0.1938372737607993, 0.16286249951070952, 0.20431826002384168, 0.1759423221231713, 0.18011845597698617, 0.17465210958555266, 0.18412241041456934, 0.19319655777680922, 0.1754297365519213, 0.17091775342385862, 0.18703737226168193, 0.19805641633369742, 0.18353585841375342, 0.19855114518190786, 0.19020938003920007, 0.17411200573044494, 0.17789748178763332, 0.186883260811316, 0.1776038279987644, 0.1826456295794473, 0.16258231072448837, 0.42349931928624607, 0.5718216438995609, 0.16932276720377626, 0.20032613119135323, 0.19631297479840382, 0.19148392180557372, 0.20615882590286916, 0.20133922344034583, 0.43298074556344346, 0.20715948081361923, 0.35275851212717135, 0.3003997302611038, 0.19536497251961604, 0.18715083784923192, 0.31818673623898686, 0.18733724881167646, 0.34729380803346144, 0.18430587199998394, 0.19947156945944744, 0.18804247572888733, 0.18112507388386956, 0.17823741686024985, 0.1941976295974609, 0.17015822292714888, 0.1721259508271309, 0.1728636286676215, 0.058580615337731845, 0.04917831064315126, 0.06107924614049787, 0.06602193717999294, 0.07233763320231779, 0.0674978827664292, 0.06849873016842334, 0.07146112303774066, 0.05468622179338456]}, "mutation_prompt": null}
{"id": "888cc699-824e-4826-a7e4-bee244c2b191", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                # Probabilistic learning of mutation factor\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.02)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.0025\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(15):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 15)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedHybridDE", "description": "A novel algorithm that enhances adaptive differential evolution with probabilistic learning of parameters and dynamic exploration-exploitation balance.", "configspace": "", "generation": 48, "fitness": 0.2209409877818074, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.16.", "error": "", "parent_id": "aa4e57ec-ea09-4330-9c54-07dcd496b547", "metadata": {"aucs": [0.47117805704052906, 0.47827075025239074, 0.4915343600102664, 0.45599671111539697, 0.4942445762900537, 0.4846355762050786, 0.5146429358261709, 0.45494426665234156, 0.485933706366093, 0.10462525771994291, 0.0922681392106951, 0.10108809863758739, 0.08559004117664348, 0.09925476700104008, 0.09868696385953557, 0.09505312258231391, 0.0951980817150685, 0.07889577480337884, 0.10177497192020069, 0.13623801088705167, 0.143171505299598, 0.10511301384515337, 0.12841428852212522, 0.12858137132922787, 0.12637296024587108, 0.14855524824640376, 0.10596806284580251, 0.10386883149781789, 0.08546218058604105, 0.08089475934844392, 0.09417067476113516, 0.09295754909068621, 0.13304823559915147, 0.08584388620386507, 0.0792256459657501, 0.07545959740983277, 0.7507046054039408, 0.7275327256266717, 0.7066294027932896, 0.5674175648417342, 0.7519631075977108, 0.6911150231621198, 0.7970127881255039, 0.7470205253098173, 0.6337682840207038, 0.2986765882325477, 0.23178071102115205, 0.2626348127216419, 0.22059727739529755, 0.22612523167478316, 0.23224961126942745, 0.2964936379358848, 0.28329098893560445, 0.23865637801644457, 0.5004847144764195, 0.29380010856701944, 0.21133889593852895, 0.2879641221010186, 0.3950694380937334, 0.2498805669868771, 0.2628053596236416, 0.3751987711450405, 0.24507987642341755, 0.16065709165230524, 0.175327359505542, 0.13899548479320833, 0.11162689699463846, 0.18527018416711183, 0.15235194901857596, 0.1762667869569554, 0.1727199815381698, 0.1247156229593851, 0.2023432223428152, 0.1554520932159006, 0.1206209180508322, 0.16568592259753712, 0.20331345568630133, 0.24530485160141557, 0.11955549810970534, 0.13728416833563317, 0.11644267991500723, 0.04081454144631225, 0.010122290301377457, 0.05383898634330486, 0.06605523211953601, 0.027687736698694065, 0.020164846530992153, 0.03815588064086861, 0.045816147934260365, 0.03677569426390459, 0.1418506487684692, 0.13673980436388988, 0.155421860807629, 0.11736832290332799, 0.14503841774799453, 0.15712250443341613, 0.16726892891675815, 0.15650853039872892, 0.17905514568402903, 0.015185922789755724, 0.0015757148631883044, 0.009204272017698023, 0.02732452787306483, 0.07346932979839493, 0.010545268139167674, 0.0028330109153739125, 0.03755751253308881, 0.02304422492923608, 0.11232699820589132, 0.14849805382546433, 0.1315852719757431, 0.12152859831933438, 0.14685232439382323, 0.10363130004612375, 0.12792645503950006, 0.103644005038668, 0.13274506144648734, 0.4187644996652852, 0.4070894338952117, 0.3990722348510315, 0.414453436622935, 0.3907526146553265, 0.40155246376622666, 0.41587139013861496, 0.3853995473183919, 0.4212423666477624, 0.09920856988904403, 0.12454918947474103, 0.1258658262764606, 0.12416645516495772, 0.11456924238364086, 0.11150474771917385, 0.0962658813840993, 0.10037593179502724, 0.09376262267263591, 0.13897412681228938, 0.16724029019779496, 0.2156898322768277, 0.1885227264241508, 0.16386816812338567, 0.2162800876605998, 0.1865061650431603, 0.18695213000038913, 0.20158688337669273, 0.23296135727479605, 0.23219570889700492, 0.24532280005907336, 0.25785681188122267, 0.23185821797121586, 0.2398776380203621, 0.2505599606070634, 0.2534473609329094, 0.24575772326990541, 0.17916578756646306, 0.17791277757058688, 0.19141767466014448, 0.16667066243418993, 0.164013398747756, 0.19772333374184936, 0.20814622300607455, 0.20645070408313249, 0.16962019901797953, 0.22953203416745416, 0.19625587619097817, 0.22652224933289, 0.2025183723490912, 0.20635883657804743, 0.17830259746583343, 0.20182300885639448, 0.20140208215396183, 0.18757394689517337, 0.21514915558682957, 0.20379160166475285, 0.18676960017855548, 0.19716767068187036, 0.1719745480670668, 0.19120912346567687, 0.2205338741854308, 0.21773079088201652, 0.18923447372301538, 0.1688018980454049, 0.5344486672572417, 0.22157167943213463, 0.5993862403862149, 0.21031598160152465, 0.5958836861457038, 0.42443664557974503, 0.5606205072667451, 0.6572872544181877, 0.3748845345989913, 0.3268032921334577, 0.3528699576105758, 0.45824227529942285, 0.3895921653411276, 0.3812584989149641, 0.2680415655876054, 0.259985157501083, 0.14551277625928416, 0.1926804407865308, 0.19873287770790704, 0.19002971208056485, 0.20373138304861627, 0.1878675517095879, 0.19302881924285897, 0.19597292675084432, 0.1928047511534241, 0.18788028717869, 0.09009024692677525, 0.08039457033642339, 0.08940961316915241, 0.08749135303798017, 0.081468512496786, 0.08161509736553485, 0.07774820599699417, 0.07977849322395048, 0.08602005147255154]}, "mutation_prompt": null}
{"id": "7e41d3d3-f4b8-462b-97a4-2cb6f14bba8c", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n        self.elite_fraction = 0.2  # New parameter for elite retention\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                # Probabilistic learning of mutation factor\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.02)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def adaptive_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.0025\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(15):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:\n                population = sorted(population, key=func)\n                elite_count = int(self.elite_fraction * self.population_size)\n                for i in range(min(elite_count, len(population))):\n                    population[i] = adaptive_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedHybridDE", "description": "An improved adaptive differential evolution algorithm incorporating elite retention and adaptive local search to better explore and exploit the solution space.", "configspace": "", "generation": 49, "fitness": 0.19420020138058264, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.14.", "error": "", "parent_id": "888cc699-824e-4826-a7e4-bee244c2b191", "metadata": {"aucs": [0.4138523284434279, 0.44138333666845975, 0.45162338303359006, 0.39081269095343996, 0.4367404662790477, 0.42303249450482816, 0.4823904626828144, 0.43227029992115196, 0.4294862625899888, 0.09259465800147226, 0.0696413264514607, 0.056941127474128383, 0.051627654484345475, 0.04473570933421578, 0.05365111682044721, 0.06078747679746388, 0.0434176125036696, 0.054424687202668465, 0.11947873692697408, 0.10136711767022166, 0.13284455960969066, 0.13430148462638536, 0.10154577851382451, 0.11977392859008018, 0.093875269775344, 0.11350363684083564, 0.11876929360192079, 0.08856179969305611, 0.07341690006484136, 0.08628550700247617, 0.09580159550422718, 0.08586245587514241, 0.0898448920386169, 0.07687372346159305, 0.08687426248022834, 0.09086827869150582, 0.663102923291029, 0.5518501021434228, 0.5275822097310363, 0.586620702368165, 0.5762118447186191, 0.5572407092037235, 0.5480714306810679, 0.6584986867682034, 0.6122018771031711, 0.18852109242372728, 0.23376898969236293, 0.16419577309156297, 0.13246060010414717, 0.1472594473796235, 0.17227898760646154, 0.17034554523306955, 0.19964451841227082, 0.16173410761773632, 0.245873432840912, 0.21767462886685185, 0.18398099208401164, 0.19410496055982163, 0.2094528979264736, 0.20083560684308455, 0.23550629254742583, 0.17320206586960196, 0.21989594353977004, 0.19122225329189313, 0.2021410092494419, 0.16117200335029136, 0.13459033802833276, 0.13795199502029898, 0.1871558437644001, 0.19938052021207542, 0.13748854852972603, 0.24022148249192243, 0.2071568169388377, 0.16226565296992446, 0.17345682096878645, 0.16873459466984964, 0.14107118490949067, 0.2168682668019969, 0.23134073300099112, 0.17974366086939986, 0.1395407271720136, 0.040186470908012084, 0.04187944952630418, 0.03182339176357962, 0.043207328448413684, 0.021199304248279094, 0.01828856973219095, 0.024406889763753492, 0.01194335906226296, 0.03763464030996799, 0.11124410479676894, 0.07437174463849971, 0.10001626432877142, 0.08146995802617496, 0.1155459040182314, 0.1270331542739248, 0.12359158881987764, 0.12667980267452672, 0.15470182232358565, 0.015952686039506947, 0.018866678981608098, 0.017058023804561118, 0.008217381236521937, 0.0147084583438164, 0.017273246131203845, 0.02785081993074001, 0.007992717350320477, 0.01588832617964364, 0.11096065790807008, 0.09225858833763034, 0.10941278235544849, 0.10719730033599628, 0.09425106136261752, 0.12120601007148635, 0.09973723513502031, 0.10026553075649369, 0.09114168748305762, 0.3867043709938899, 0.4189834019409465, 0.3793374041086639, 0.38738971650173915, 0.3757104481920329, 0.365323634806462, 0.3785367674198393, 0.33949073112340566, 0.42086693041400725, 0.1188838767589876, 0.16388120035291942, 0.11074194508585855, 0.10404250955134065, 0.10625102342840642, 0.11147850724768249, 0.10166899886821301, 0.09883792985043305, 0.1378484680884028, 0.18460257146486858, 0.16389607099686077, 0.33047317810569043, 0.23200161946773612, 0.15781255633858837, 0.15485598553118185, 0.22729648567162553, 0.18030410160697485, 0.18167088224039007, 0.22006096634969763, 0.2192773553387508, 0.24490238572058365, 0.20128697354731262, 0.18883839225132693, 0.20849256431309882, 0.20847024770406353, 0.21976935949270815, 0.20325282142511014, 0.13319030755908956, 0.15078869562656705, 0.15746314448156606, 0.15931004718185182, 0.13038327489888213, 0.1480301245240484, 0.15981194371837681, 0.15545887895812416, 0.15886124273520852, 0.18907622869663587, 0.19365045280798032, 0.1762063388060351, 0.1948039069313927, 0.20196228077384626, 0.1984802514837486, 0.21173200652276414, 0.19336728601413877, 0.18335016760137046, 0.18047647226163954, 0.17719892005030358, 0.20527976096253742, 0.17541363708878777, 0.1815067514006754, 0.17758105589426965, 0.1767273775451662, 0.1673257627802761, 0.2275666661553699, 0.16972724605756717, 0.2051822761998907, 0.5492300896204216, 0.5092364869922362, 0.19298112164776549, 0.6022823580691363, 0.5378585626379551, 0.33369243089359135, 0.207101238926226, 0.37955595577183954, 0.4428048395987264, 0.30036120847478, 0.26874760236367135, 0.27808702267212815, 0.2794633069179193, 0.16109888656947513, 0.18873861552895044, 0.23943141227113174, 0.20168890819471297, 0.2015183224318735, 0.20080910678512975, 0.19879549054435464, 0.20532547420886593, 0.19662372619565083, 0.20989850320446657, 0.1931794526585705, 0.197940455719833, 0.08757755357892216, 0.08198040141644147, 0.08427232427741238, 0.08724537324579418, 0.09124676518432095, 0.07854502878844072, 0.07389197211603116, 0.08572412155967724, 0.08881041571400894]}, "mutation_prompt": null}
{"id": "acc645c2-be74-4859-91e4-f376ea023684", "solution": "import numpy as np\n\nclass ImprovedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Slightly increased population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Adjusted adaptive mutation\n        self.success_rate = 0.2\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                # Probabilistic learning of mutation factor\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Increased step for success rate\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Decreased step for failure\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.0020  # Adjusted step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Increased number of local iterations\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:  # Adjusted budget threshold for local search\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 10)  # Adjusted number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "ImprovedHybridDE", "description": "An improved hybrid differential evolution that integrates probabilistic parameter tuning and enhanced local search for dynamic balance between global exploration and fine-tuning.", "configspace": "", "generation": 50, "fitness": 0.2016540841507258, "feedback": "The algorithm ImprovedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.15.", "error": "", "parent_id": "888cc699-824e-4826-a7e4-bee244c2b191", "metadata": {"aucs": [0.45666357180718375, 0.473604116203617, 0.47409603999834693, 0.4543423439567752, 0.4329076802108429, 0.44274331118677435, 0.5369824398491305, 0.43457814247249205, 0.41752357420087105, 0.03353366914611977, 0.07549557470400847, 0.047988664585431384, 0.061425058249164666, 0.057133601574257176, 0.042494644292357386, 0.04575064501466097, 0.033992105977420195, 0.057664599107303705, 0.08875320505285023, 0.09966432453674912, 0.1300723325185862, 0.12325520073829443, 0.10549898529292145, 0.10977481059555394, 0.13604475412549966, 0.11258838679051264, 0.11508661293004185, 0.09741251634346593, 0.09596288834203004, 0.08117988063642678, 0.09645367850993936, 0.10231475712467386, 0.07814154249147764, 0.09762122258467365, 0.12252474507369482, 0.07874632683444183, 0.7549949588971163, 0.5942998118865523, 0.7194347406717101, 0.5812789738834508, 0.5398873544000968, 0.7756506543594427, 0.7009978493260924, 0.8358446332879368, 0.6080299813234222, 0.19789970209773344, 0.19903900813068653, 0.19254361243223772, 0.19980602658843316, 0.15435743781499367, 0.18824129171634885, 0.15108827718877949, 0.16301616957541099, 0.23771981655186714, 0.2798606697712195, 0.24032346666097448, 0.21174020037315344, 0.24323205738706977, 0.24155327110649816, 0.19394306904911573, 0.16176811699950033, 0.21041001711574192, 0.18443133601078743, 0.18291568056720986, 0.1779292197324447, 0.09656833347366134, 0.16135342820669263, 0.12453022495771948, 0.1518544733594004, 0.14633243377030325, 0.12711643435404296, 0.18763807013971567, 0.12079048510056889, 0.13047411901874129, 0.22400012561852822, 0.1351640723158991, 0.20289529368820214, 0.10174119579804497, 0.1619795228741514, 0.1633594705721274, 0.12452923861874898, 0.03689085816645021, 0.023331458369359792, 0.025718290614831107, 0.07962723112725367, 0.008568066136188324, 0.005369842308380557, 0.11463780334874862, 0.0069655841093370086, 0.004425245068207739, 0.10779787387878514, 0.09353698944646915, 0.11288790864785714, 0.11563937536056579, 0.11218807126857588, 0.07317532232664525, 0.1431423322721761, 0.15587902869619885, 0.1475005449077742, 0.036847926303760103, 0.032043433105043206, 0.02821834509067389, 0.03086946975582472, 0.027053734340028335, 0.02025258639606109, 0.028461138091560145, 0.04589120091730181, 0.021037576252192047, 0.09723958458883775, 0.08289894959802802, 0.12125561393660378, 0.06728508885342743, 0.10051182721272944, 0.12460085470301852, 0.08939320219321067, 0.12920213503789224, 0.09831571825366303, 0.3961538171774106, 0.39655194067251387, 0.37077979436246544, 0.3868403938839675, 0.3850844477336022, 0.3879038007733001, 0.39610615058708676, 0.3649266306620873, 0.35316172324399275, 0.11169188665130514, 0.1266790574161043, 0.11350688476472492, 0.12835184336524563, 0.09769879024082051, 0.11205147872347021, 0.11861020065746453, 0.13325865265591308, 0.11119099230680662, 0.1786413265324811, 0.1704307879809832, 0.1708636500280365, 0.2637327883114705, 0.17841904464010472, 0.1556287842739713, 0.18406574768476502, 0.19371489545217724, 0.17377778023145352, 0.21277840553861338, 0.21826821998302526, 0.22456162511265199, 0.19477932891551386, 0.20410347002143114, 0.22939041030234186, 0.23193116349859932, 0.22900748584941333, 0.21600611039646234, 0.14666323301628037, 0.16015768389309104, 0.1807720593026101, 0.15074667964883304, 0.14439426137600586, 0.15355298569846798, 0.15268213607127867, 0.1715545205375384, 0.16931308474727502, 0.18776317188572156, 0.18428788382288042, 0.20210876143721512, 0.20348011868000515, 0.19768952176480914, 0.18692276795224116, 0.18234829032373345, 0.19929563136651418, 0.19459107320198998, 0.20237075833845375, 0.2935598724180649, 0.17909289690597252, 0.17942062108603662, 0.3513320548867107, 0.18002425094446406, 0.17263712050134217, 0.18858271136980642, 0.16498276667628797, 0.3906852749134424, 0.17980398322090807, 0.2638917643960411, 0.4247608112681621, 0.6165796872111856, 0.3724101273553948, 0.41220836776002734, 0.19696687713677807, 0.6541093396056945, 0.358641956887933, 0.31491011552545334, 0.4591753548221723, 0.3194302302694412, 0.20513365677662843, 0.20474420446656416, 0.27674066690002397, 0.2796664612609495, 0.25145800980762334, 0.2148630269594891, 0.21288505022763438, 0.20722485414490743, 0.20760330516519898, 0.20976800159214481, 0.19734335606311193, 0.2156757276153629, 0.21165014531996562, 0.2175839900106773, 0.1146205595865436, 0.0897217442054129, 0.09366664653406931, 0.08899290320156739, 0.0945937345560316, 0.08232733594544628, 0.07049320700004169, 0.08113789046533526, 0.08359688937917531]}, "mutation_prompt": null}
{"id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDE", "description": "A novel algorithm that refines adaptive differential evolution through probabilistic control of mutation, enhanced local search sensitivity, and strategic population management.", "configspace": "", "generation": 51, "fitness": 0.23234194796164692, "feedback": "The algorithm RefinedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "888cc699-824e-4826-a7e4-bee244c2b191", "metadata": {"aucs": [0.4810385500387777, 0.49122641721592986, 0.481417236803091, 0.4713072674896479, 0.47907942755758925, 0.4982162158862644, 0.4790185902784956, 0.47037772352158014, 0.45364683128225736, 0.059242853241332716, 0.08349984161870283, 0.05069640365585437, 0.07470962317203833, 0.10955241306254138, 0.08569029893423508, 0.0834131814923258, 0.08124115958281997, 0.08182012560979568, 0.09019305794601074, 0.118304716925275, 0.11515170958533616, 0.10335729835276519, 0.10181151482121009, 0.13136328118327, 0.10937423055909135, 0.12097880324397614, 0.12088439405808182, 0.10976421993031049, 0.10026277273979467, 0.07553557301202107, 0.09781579394321782, 0.16822779751300054, 0.07948852881821944, 0.10255991878217696, 0.12028367206556234, 0.09397778217691921, 0.7652399976661391, 0.687818816059065, 0.8340344265313764, 0.7460237406631894, 0.7781983792419996, 0.7403247913978884, 0.7175647662957516, 0.7632168764691745, 0.8107584713276046, 0.30264753556873836, 0.29706112693948983, 0.26275926667626126, 0.2811496200506002, 0.2688314747001579, 0.2952199381837055, 0.2825508076256026, 0.25317907522436267, 0.2948119240085687, 0.24870916040401614, 0.3471849257486429, 0.25229813732882644, 0.28508628202213127, 0.4055714665888992, 0.4393120783054123, 0.3518081973244751, 0.2677596281666348, 0.3207230749850358, 0.20300962358302066, 0.23246997145227, 0.20637503514276911, 0.24450753452070006, 0.18093906127802983, 0.18262307246424503, 0.16686262501810667, 0.2864951055162497, 0.19101488413646917, 0.17004441583465524, 0.1831817161756749, 0.14117459438234614, 0.23535914483927, 0.22704190044251127, 0.22252566475591562, 0.22246573449791351, 0.21621901769442697, 0.2580457623939423, 0.03168726808130484, 0.03601450134891315, 0.051323801129741, 0.03150628450294202, 0.05454677812829145, 0.007087926451563198, 0.04511175112412069, 0.03282561435239062, 0.04293962280107333, 0.13299521580642537, 0.1397535175169181, 0.18878868937349713, 0.07831415013460641, 0.04454532858390359, 0.12741137307972006, 0.16198870150338285, 0.12492013647034328, 0.11064330112841259, 9.999999999998899e-05, 9.999999999998899e-05, 0.011417578140188733, 0.00035648528881115915, 0.00016006721759154185, 0.005825304358538008, 0.0012088139100376871, 9.999999999998899e-05, 0.003221866895512404, 0.14796275452260166, 0.10851410441721676, 0.11046053296000813, 0.1130644091624563, 0.15391956093158465, 0.12345659561280042, 0.11913236292894558, 0.11230986791241482, 0.11267609544504908, 0.4263882878336763, 0.4274936851927539, 0.418762143062789, 0.42370737177660467, 0.42619508402193385, 0.40668591884692074, 0.4619947216257798, 0.4316305570193989, 0.4252281948643636, 0.09622242057730568, 0.10154562610426676, 0.12754323142276225, 0.1518650648580846, 0.08036922075285924, 0.1168512587899544, 0.10482315958869981, 0.10949151293033377, 0.11934665835519698, 0.19635879516990407, 0.2128549046075614, 0.21380405649254097, 0.2782400523968531, 0.1710769568130761, 0.156119964775273, 0.22559412547938895, 0.2149500867421792, 0.19655704984022315, 0.27507332513181315, 0.2168960854077231, 0.2569360247544873, 0.26333752860079385, 0.2351800920612267, 0.23504736910850388, 0.2339570384547287, 0.28596058855875395, 0.2173744245111474, 0.1435578754082626, 0.19528702526478658, 0.18191678169751424, 0.20067916682830866, 0.18865795194902535, 0.15567460674666578, 0.17009371323470257, 0.21067224088098602, 0.18092628803649757, 0.19805772623424855, 0.19892448987309164, 0.1933443750917374, 0.2040216248660739, 0.17843398614234707, 0.20862260246614395, 0.18148653617512822, 0.18701623948247803, 0.19788348156793067, 0.18966784926753288, 0.17118586710925976, 0.1887820114198624, 0.24093594106455674, 0.19425712406099094, 0.18894911277597948, 0.19657032605801783, 0.22288735898571999, 0.2039058052990178, 0.6591255943146832, 0.7155335327444009, 0.5784357772217903, 0.36997196449666847, 0.46496652988090514, 0.3996162317452482, 0.423088913200384, 0.644734246147201, 0.6444714055886749, 0.5040092044175888, 0.25160257483728377, 0.4896576355282628, 0.3439219703324584, 0.36219841688120347, 0.2985248741608768, 0.2715577850515687, 0.3358049361279589, 0.3441020010389485, 0.1900397993674927, 0.18220014764950432, 0.16713469755567711, 0.1892132933271088, 0.18565058372246113, 0.18008964636483327, 0.1898151496881223, 0.18938524514386057, 0.18780640202032484, 0.07777444697759017, 0.08749656149770968, 0.08372609412640264, 0.08032183465446341, 0.07640557991169772, 0.07369140474666214, 0.06672823677255035, 0.07715349704212315, 0.07492541396122465]}, "mutation_prompt": null}
{"id": "bea9764e-b097-4649-ac4d-3d98dc6890ab", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n        self.diversity_threshold = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                diversity = np.std(population, axis=0).mean()\n                if diversity < self.diversity_threshold:\n                    self.mutation_factor *= 1.2\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedDifferentialEvolution", "description": "An enhanced differential evolution algorithm incorporating adaptive mutation, dynamic local search, and population diversity strategies for efficient optimization.", "configspace": "", "generation": 52, "fitness": 0.2318634555521614, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.48219985413335176, 0.4919848381723275, 0.4718166657711289, 0.455789803636526, 0.47625184246876406, 0.49786892753984746, 0.4518381606347587, 0.4615198941069101, 0.44697203992420387, 0.059242853241332716, 0.08349984161870283, 0.05069640365585437, 0.07470962317203833, 0.10955241306254138, 0.08569029893423508, 0.0834131814923258, 0.08124115958281997, 0.08182012560979568, 0.09019305794601074, 0.118304716925275, 0.11515170958533616, 0.10335729835276519, 0.10181151482121009, 0.13136328118327, 0.10937423055909135, 0.12097880324397614, 0.12088439405808182, 0.10976421993031049, 0.10026277273979467, 0.07553557301202107, 0.09781579394321782, 0.16822779751300054, 0.07948852881821944, 0.10255991878217696, 0.12028367206556234, 0.09397778217691921, 0.7652399976661391, 0.687818816059065, 0.8340344265313764, 0.7460237406631894, 0.7781983792419996, 0.7403247913978884, 0.7175647662957516, 0.7632168764691745, 0.8107584713276046, 0.30264753556873836, 0.29706112693948983, 0.26275926667626126, 0.2811496200506002, 0.2688314747001579, 0.2952199381837055, 0.2825508076256026, 0.25317907522436267, 0.2948119240085687, 0.24870916040401614, 0.3471849257486429, 0.25229813732882644, 0.28508628202213127, 0.4055714665888992, 0.4393120783054123, 0.3518081973244751, 0.2677596281666348, 0.3207230749850358, 0.20300962358302066, 0.23246997145227, 0.20637503514276911, 0.24450753452070006, 0.18093906127802983, 0.18262307246424503, 0.16686262501810667, 0.2864951055162497, 0.19101488413646917, 0.17004441583465524, 0.1831817161756749, 0.14117459438234614, 0.23535914483927, 0.22704190044251127, 0.22252566475591562, 0.22246573449791351, 0.21621901769442697, 0.2580457623939423, 0.03168726808130484, 0.03601450134891315, 0.051323801129741, 0.03150628450294202, 0.05454677812829145, 0.007087926451563198, 0.04511175112412069, 0.03282561435239062, 0.04293962280107333, 0.13299521580642537, 0.1397535175169181, 0.18878868937349713, 0.07831415013460641, 0.04454532858390359, 0.12741137307972006, 0.16198870150338285, 0.12492013647034328, 0.11064330112841259, 9.999999999998899e-05, 9.999999999998899e-05, 0.011417578140188733, 0.00035648528881115915, 0.00016006721759154185, 0.005825304358538008, 0.0012088139100376871, 9.999999999998899e-05, 0.003221866895512404, 0.14796275452260166, 0.10851410441721676, 0.11046053296000813, 0.1130644091624563, 0.15381504304622562, 0.12345659561280042, 0.11913236292894558, 0.11230986791241482, 0.11267609544504908, 0.41750742210499003, 0.4262758225539036, 0.4178031145716372, 0.40968340868829833, 0.425677948950935, 0.40880308479543137, 0.46022753690646756, 0.4307155105583188, 0.4172285062365424, 0.09622242057730568, 0.10154562610426676, 0.12754323142276225, 0.1518650648580846, 0.08036922075285924, 0.1168512587899544, 0.10482315958869981, 0.10949151293033377, 0.11934665835519698, 0.19635879516990407, 0.2128549046075614, 0.21380405649254097, 0.2782400523968531, 0.1710769568130761, 0.156119964775273, 0.22559412547938895, 0.2149500867421792, 0.19655704984022315, 0.27507332513181315, 0.2168960854077231, 0.2569360247544873, 0.26333752860079385, 0.2351800920612267, 0.23504736910850388, 0.2339570384547287, 0.28596058855875395, 0.2173744245111474, 0.1435578754082626, 0.19528702526478658, 0.18191678169751424, 0.20067916682830866, 0.18865795194902535, 0.15567460674666578, 0.17009371323470257, 0.21067224088098602, 0.18092628803649757, 0.19805772623424855, 0.19892448987309164, 0.1933443750917374, 0.2040216248660739, 0.17843398614234707, 0.20862260246614395, 0.18148653617512822, 0.18701623948247803, 0.19788348156793067, 0.18966784926753288, 0.17118586710925976, 0.1887820114198624, 0.24093594106455674, 0.19425712406099094, 0.18894911277597948, 0.19657032605801783, 0.22288735898571999, 0.2039058052990178, 0.6591255943146832, 0.7155335327444009, 0.5784357772217903, 0.36997196449666847, 0.46496652988090514, 0.3996162317452482, 0.423088913200384, 0.644734246147201, 0.6444714055886749, 0.5040092044175888, 0.25160257483728377, 0.4896576355282628, 0.3439219703324584, 0.36219841688120347, 0.2985248741608768, 0.2715577850515687, 0.3358049361279589, 0.3441020010389485, 0.1900397993674927, 0.18220014764950432, 0.16713469755567711, 0.1892132933271088, 0.18565058372246113, 0.18008964636483327, 0.1898151496881223, 0.18938524514386057, 0.18780640202032484, 0.07777444697759017, 0.08749656149770968, 0.08372609412640264, 0.08032183465446341, 0.07640557991169772, 0.07369140474666214, 0.06672823677255035, 0.07715349704212315, 0.07492541396122465]}, "mutation_prompt": null}
{"id": "37318433-99f9-4c38-8feb-31d3262ae8ee", "solution": "import numpy as np\n\nclass RefinedAdaptiveDEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size for exploration\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # Slightly increased mutation factor for diversity\n        self.crossover_rate = 0.8  # Lowered crossover rate to maintain structural integrity\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Adjusted adaptive mutation factor\n        self.success_rate = 0.15  # Increased success rate to enhance feedback loop\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  # Adjusted mutation range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)  # Faster success rate adaptation\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)  # More penalizing rate decrease\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01  # Increased step size for broader search\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(15):  # Reduced number of local search iterations\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.75:  # Extended time for elitism before budget runs out\n                population = sorted(population, key=func)\n                best_count = max(5, self.population_size // 12)  # Increased elitism pool\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDEPlus", "description": "A novel refinement of adaptive differential evolution incorporating probabilistic mutation control, dynamic elitism, and enhanced search space exploration.", "configspace": "", "generation": 53, "fitness": 0.2140175240959714, "feedback": "The algorithm RefinedAdaptiveDEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.4475444528247168, 0.40436460904264804, 0.4317763933778783, 0.4552175745154452, 0.41285695238504216, 0.447068524689631, 0.46288408681416093, 0.4527229582730077, 0.43259073883700616, 0.06230794739441903, 0.08131497489250428, 0.05305905496917662, 0.0999565017414017, 0.06413115574717465, 0.06227078625610538, 0.07014022813661536, 0.039320090209439384, 0.057327126011032625, 0.10126031875580155, 0.10762067504341843, 0.10863104057427608, 0.0882936927852419, 0.0948265206201997, 0.11543330491502346, 0.1087965025358415, 0.12415018008932566, 0.09789424362672361, 0.10247158823401092, 0.08754736901181537, 0.0885588234085668, 0.0864151531535936, 0.06202874932707381, 0.08107182848136107, 0.09128729819224501, 0.08997488498890194, 0.09321873020297988, 0.7245473186132438, 0.7561433175343133, 0.7601853699316234, 0.6784714544242989, 0.7720159861677129, 0.6761108057461664, 0.8733875765173553, 0.906134785733402, 0.8353397919209051, 0.25660962550408417, 0.2513864645637486, 0.242411032573013, 0.22260371970170711, 0.2665243600609629, 0.2683503947537791, 0.24489121085650623, 0.22135999551516883, 0.2655204274127807, 0.2476815801741682, 0.2512280106967705, 0.20836482466219686, 0.2966790121930243, 0.23606669340479658, 0.2742741151584548, 0.25544754580307594, 0.29844022500475087, 0.3021218149444055, 0.16302581208697464, 0.17093966576655306, 0.15491011135412103, 0.1536653624013452, 0.13393187294066178, 0.14193958001239337, 0.13509773535937164, 0.19899046032404366, 0.13018103946551962, 0.15269352920901058, 0.1456176519075485, 0.15237003508168168, 0.1487424516390563, 0.16208617167936645, 0.1692103530062723, 0.17230205208466154, 0.15161279680727402, 0.12867135475127545, 0.04803095995682927, 0.02785647797374191, 9.999999999998899e-05, 0.02946444760009015, 0.0015537676398105216, 0.002079294654347308, 0.041171768240035767, 0.007871832006472124, 9.999999999998899e-05, 0.08122452852249407, 0.08349225665952376, 0.12766003017248007, 0.09794855083895704, 0.06483227325237328, 0.07716608335830755, 0.13986866425889655, 0.14249848936041676, 0.16153360973565667, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08058609737598055, 0.09396160854208813, 0.1013153821925904, 0.07696319175553257, 0.10834884454883997, 0.11145051977402165, 0.09840518060707015, 0.09924995553044769, 0.10152472540542234, 0.3956303266585127, 0.4037955625092954, 0.38086203674040275, 0.3861956701123621, 0.3811226864584851, 0.3871633006759485, 0.40512000388309977, 0.38951586862483967, 0.37820752359391996, 0.11849864584572567, 0.09981737043090566, 0.10669316646314797, 0.09836223921780163, 0.1014481187357189, 0.090838611622441, 0.09805267121256234, 0.10433445781735262, 0.11360289016047886, 0.24667640821262915, 0.17808411149856873, 0.22943135674007042, 0.2531753661935219, 0.2627392816416547, 0.17443868314935262, 0.24095874063609768, 0.18040551110562464, 0.18025390972111055, 0.2583580135707444, 0.21725172869300913, 0.2274883822925231, 0.23957974403003446, 0.23397146254859258, 0.2618787991158107, 0.2521996757223586, 0.26304080262210916, 0.2864240538460485, 0.17800630731355505, 0.17398392749714242, 0.1874814096798323, 0.16306501250120875, 0.20069018651447534, 0.2007185346232263, 0.20010691650658063, 0.17679454389239968, 0.21112317658584023, 0.19771874604549744, 0.19722415961543172, 0.1713885100674888, 0.22042258563078898, 0.17679839330785763, 0.20488007733106217, 0.18376500644355376, 0.18165087437172234, 0.17811097945436283, 0.19312797633749434, 0.17933046132897745, 0.19891426625721065, 0.2265070713118975, 0.19834982795379785, 0.21124818254177014, 0.19277291288206222, 0.18097296698039522, 0.2107409679596569, 0.5954052551259983, 0.24297854550368303, 0.6452417308442536, 0.5598055516773897, 0.3503569742131999, 0.5244821878873915, 0.5116519645077806, 0.43200983616205557, 0.5621933337263806, 0.42627849199046286, 0.3271803314731644, 0.36728256562164785, 0.4394634935942139, 0.27732347756280773, 0.29801996461446445, 0.18888897715299235, 0.4314234787844823, 0.34678109630181886, 0.1894416319809915, 0.17682654490076688, 0.17148292723501568, 0.17106114793116833, 0.1820857556494514, 0.17057932090550698, 0.18419673698509564, 0.17098679536532546, 0.17627423490781935, 0.07700112082565536, 0.06513502521796477, 0.07043301738685515, 0.0870553396321131, 0.07666717750479435, 0.07047266202991687, 0.06978073081487113, 0.06774904714653063, 0.07049847305187174]}, "mutation_prompt": null}
{"id": "53092084-146a-4a78-b6c2-dea8752fc262", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # [Change]: Increase in population size for better exploration\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # [Change]: Adjusted mutation factor for broader search space exploration\n        self.crossover_rate = 0.85  # [Change]: Modified crossover rate for varied exploration-exploitation balance\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # [Change]: Lowered adaptive factor to fine-tune convergence\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  # [Change]: Adjust mutation factor range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (d - a), *self.bounds)  # [Change]: Different combination strategy\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.02)  # [Change]: Adjust success rate adaptation\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01  # [Change]: Increased step size for local search\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(25):  # [Change]: More iterations for a more thorough local search\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.9:  # [Change]: Longer phase for exploitation\n                population = sorted(population, key=func)\n                best_count = max(5, self.population_size // 8)  # [Change]: More individuals in local search\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution algorithm utilizing adaptive mutation rates and local search strategies to dynamically balance exploration and exploitation.", "configspace": "", "generation": 54, "fitness": 0.20154650747220396, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.5101011101167859, 0.4333257273074893, 0.41310848519407806, 0.46437180305230785, 0.452273851168531, 0.3965618606285889, 0.4458622626536365, 0.4281400129908899, 0.4183420654186102, 0.032438852061858925, 0.009001456622549586, 0.019734757041094397, 0.010715063589549545, 0.04400948254678172, 0.010736485828715003, 0.013935263500662987, 0.023004971136541652, 0.011187963623748853, 0.11175780528454105, 0.0999450666828463, 0.12294803291569967, 0.09536434076754763, 0.0935553684985484, 0.1068189144289945, 0.12348346917550357, 0.09573719414787718, 0.08915248291637745, 0.09408934170168437, 0.08611073515040168, 0.07496001801658658, 0.09310756874056458, 0.07129854649378653, 0.0713772005562967, 0.09976487060577166, 0.06874268169485609, 0.08663458183193617, 0.4302527364728569, 0.6424794749125107, 0.8097182203706456, 0.6530533779235451, 0.5891698058401971, 0.6652198866417728, 0.7116487373408444, 0.6799478549618163, 0.7094466853063769, 0.2534360541037176, 0.23922688740925557, 0.26778858108549297, 0.26837571750140143, 0.25337707368073037, 0.22739261256503995, 0.21782124895715238, 0.23984306684690737, 0.24890315398290042, 0.28049831050471197, 0.22207648310074912, 0.21944329679752905, 0.3122020768848516, 0.24054746758526435, 0.24034699839018991, 0.21022964542765243, 0.34394878143342755, 0.29061170312258233, 0.17655156490185253, 0.16887118420937608, 0.15393417568431, 0.2245402994445218, 0.12961839921266105, 0.17175986748635097, 0.15426414683686762, 0.17716939043303614, 0.200935088991107, 0.17870946551347966, 0.14773118928744533, 0.1683226641471387, 0.15287210538941542, 0.1634387764020555, 0.13972051693638055, 0.16937114804344078, 0.1889813651477107, 0.14174004199922274, 0.007176699105681084, 0.02787771136574213, 9.999999999998899e-05, 0.00012601978139792358, 0.03140620967011987, 0.0012874968862017777, 0.0016129668927060692, 0.05708861657576747, 0.0013958176137471856, 0.10244088584318956, 0.0933674775187121, 0.09824276195268011, 0.08122875427246123, 0.06276581603912879, 0.07189394531008042, 0.12429857681167034, 0.12129487550637819, 0.08154252587281641, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011933217050849265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10312042443451697, 0.09698564965935563, 0.08762474092785544, 0.1081355032111313, 0.08632166613063963, 0.1051634864970381, 0.07965042635485475, 0.10307599650267785, 0.09763697681421668, 0.37949011128315646, 0.38980152184524686, 0.39631282609970353, 0.39486799845647025, 0.3943804475370978, 0.37894112533267166, 0.40619768005838286, 0.39063215343320823, 0.3834519204415021, 0.08858006229534043, 0.09168940204366594, 0.09836205479491822, 0.08029095582505574, 0.09798399116993572, 0.10284484330619803, 0.09553880603154719, 0.07888543092030353, 0.08176825613274719, 0.20858238700037035, 0.1709686173406213, 0.18133381118054404, 0.24533469846981693, 0.21686396105566597, 0.25335575022003165, 0.22895880525294243, 0.1700185719155023, 0.23595856289550698, 0.20857229606060124, 0.21385591419294858, 0.23526032349607018, 0.2218417432120101, 0.1997682287933309, 0.22655236330966344, 0.2221489265811517, 0.2646773614923833, 0.19724800435983614, 0.13979644320143614, 0.17165986926057397, 0.18755299619996946, 0.20469223076409437, 0.16720269630650586, 0.16612856133683307, 0.15204471812199882, 0.1925673605893573, 0.15205924321775766, 0.1876261681895277, 0.21284921537311718, 0.18562537453091466, 0.22100362726653133, 0.18709333667734884, 0.21121352379253477, 0.18341552205451972, 0.1747271346705418, 0.19770625035939904, 0.18841438035423297, 0.21072546860110097, 0.19295490259954062, 0.18740794983063014, 0.18622092004765067, 0.20350181541914658, 0.1881238305518288, 0.20450756983208673, 0.1777436167983426, 0.46112807455367777, 0.4977122568992123, 0.5898324166512595, 0.5244343463718432, 0.19966609790921142, 0.4617491599835776, 0.5614022572787444, 0.6098019754035129, 0.20219027083641816, 0.4161059430191486, 0.233710518072075, 0.305998663079904, 0.4367458113078947, 0.19840397923403785, 0.20107889072895535, 0.2617609371808316, 0.30368899972797403, 0.3355541684499165, 0.1952087743202101, 0.1748460661995359, 0.18260796509663535, 0.1888285537382629, 0.20108121093904552, 0.17248689068310508, 0.18104350064832808, 0.1724699851860676, 0.18148174820685703, 0.07757063615457371, 0.07240156686279609, 0.08050805724531673, 0.06905723518728335, 0.08578085062637475, 0.06397344151139805, 0.06566931896560912, 0.08158071779881759, 0.07776742024361905]}, "mutation_prompt": null}
{"id": "677db4b6-e336-4645-90e6-35558f0f21bf", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDE", "description": "A novel algorithm that refines adaptive differential evolution through probabilistic control of mutation, enhanced local search sensitivity, and strategic population management.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.4810385500387777, 0.49122641721592986, 0.481417236803091, 0.4713072674896479, 0.47907942755758925, 0.4982162158862644, 0.4790185902784956, 0.47037772352158014, 0.45364683128225736, 0.059242853241332716, 0.08349984161870283, 0.05069640365585437, 0.07470962317203833, 0.10955241306254138, 0.08569029893423508, 0.0834131814923258, 0.08124115958281997, 0.08182012560979568, 0.09019305794601074, 0.118304716925275, 0.11515170958533616, 0.10335729835276519, 0.10181151482121009, 0.13136328118327, 0.10937423055909135, 0.12097880324397614, 0.12088439405808182, 0.10976421993031049, 0.10026277273979467, 0.07553557301202107, 0.09781579394321782, 0.16822779751300054, 0.07948852881821944, 0.10255991878217696, 0.12028367206556234, 0.09397778217691921, 0.7652399976661391, 0.687818816059065, 0.8340344265313764, 0.7460237406631894, 0.7781983792419996, 0.7403247913978884, 0.7175647662957516, 0.7632168764691745, 0.8107584713276046, 0.30264753556873836, 0.29706112693948983, 0.26275926667626126, 0.2811496200506002, 0.2688314747001579, 0.2952199381837055, 0.2825508076256026, 0.25317907522436267, 0.2948119240085687, 0.24870916040401614, 0.3471849257486429, 0.25229813732882644, 0.28508628202213127, 0.4055714665888992, 0.4393120783054123, 0.3518081973244751, 0.2677596281666348, 0.3207230749850358, 0.20300962358302066, 0.23246997145227, 0.20637503514276911, 0.24450753452070006, 0.18093906127802983, 0.18262307246424503, 0.16686262501810667, 0.2864951055162497, 0.19101488413646917, 0.17004441583465524, 0.1831817161756749, 0.14117459438234614, 0.23535914483927, 0.22704190044251127, 0.22252566475591562, 0.22246573449791351, 0.21621901769442697, 0.2580457623939423, 0.03168726808130484, 0.03601450134891315, 0.051323801129741, 0.03150628450294202, 0.05454677812829145, 0.007087926451563198, 0.04511175112412069, 0.03282561435239062, 0.04293962280107333, 0.13299521580642537, 0.1397535175169181, 0.18878868937349713, 0.07831415013460641, 0.04454532858390359, 0.12741137307972006, 0.16198870150338285, 0.12492013647034328, 0.11064330112841259, 9.999999999998899e-05, 9.999999999998899e-05, 0.011417578140188733, 0.00035648528881115915, 0.00016006721759154185, 0.005825304358538008, 0.0012088139100376871, 9.999999999998899e-05, 0.003221866895512404, 0.14796275452260166, 0.10851410441721676, 0.11046053296000813, 0.1130644091624563, 0.15391956093158465, 0.12345659561280042, 0.11913236292894558, 0.11230986791241482, 0.11267609544504908, 0.4263882878336763, 0.4274936851927539, 0.418762143062789, 0.42370737177660467, 0.42619508402193385, 0.40668591884692074, 0.4619947216257798, 0.4316305570193989, 0.4252281948643636, 0.09622242057730568, 0.10154562610426676, 0.12754323142276225, 0.1518650648580846, 0.08036922075285924, 0.1168512587899544, 0.10482315958869981, 0.10949151293033377, 0.11934665835519698, 0.19635879516990407, 0.2128549046075614, 0.21380405649254097, 0.2782400523968531, 0.1710769568130761, 0.156119964775273, 0.22559412547938895, 0.2149500867421792, 0.19655704984022315, 0.27507332513181315, 0.2168960854077231, 0.2569360247544873, 0.26333752860079385, 0.2351800920612267, 0.23504736910850388, 0.2339570384547287, 0.28596058855875395, 0.2173744245111474, 0.1435578754082626, 0.19528702526478658, 0.18191678169751424, 0.20067916682830866, 0.18865795194902535, 0.15567460674666578, 0.17009371323470257, 0.21067224088098602, 0.18092628803649757, 0.19805772623424855, 0.19892448987309164, 0.1933443750917374, 0.2040216248660739, 0.17843398614234707, 0.20862260246614395, 0.18148653617512822, 0.18701623948247803, 0.19788348156793067, 0.18966784926753288, 0.17118586710925976, 0.1887820114198624, 0.24093594106455674, 0.19425712406099094, 0.18894911277597948, 0.19657032605801783, 0.22288735898571999, 0.2039058052990178, 0.6591255943146832, 0.7155335327444009, 0.5784357772217903, 0.36997196449666847, 0.46496652988090514, 0.3996162317452482, 0.423088913200384, 0.644734246147201, 0.6444714055886749, 0.5040092044175888, 0.25160257483728377, 0.4896576355282628, 0.3439219703324584, 0.36219841688120347, 0.2985248741608768, 0.2715577850515687, 0.3358049361279589, 0.3441020010389485, 0.1900397993674927, 0.18220014764950432, 0.16713469755567711, 0.1892132933271088, 0.18565058372246113, 0.18008964636483327, 0.1898151496881223, 0.18938524514386057, 0.18780640202032484, 0.07777444697759017, 0.08749656149770968, 0.08372609412640264, 0.08032183465446341, 0.07640557991169772, 0.07369140474666214, 0.06672823677255035, 0.07715349704212315, 0.07492541396122465]}, "mutation_prompt": null}
{"id": "90dd41ac-a583-4c97-999f-b077b47e7016", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDE", "description": "A novel algorithm that refines adaptive differential evolution through probabilistic control of mutation, enhanced local search sensitivity, and strategic population management.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.4810385500387777, 0.49122641721592986, 0.481417236803091, 0.4713072674896479, 0.47907942755758925, 0.4982162158862644, 0.4790185902784956, 0.47037772352158014, 0.45364683128225736, 0.059242853241332716, 0.08349984161870283, 0.05069640365585437, 0.07470962317203833, 0.10955241306254138, 0.08569029893423508, 0.0834131814923258, 0.08124115958281997, 0.08182012560979568, 0.09019305794601074, 0.118304716925275, 0.11515170958533616, 0.10335729835276519, 0.10181151482121009, 0.13136328118327, 0.10937423055909135, 0.12097880324397614, 0.12088439405808182, 0.10976421993031049, 0.10026277273979467, 0.07553557301202107, 0.09781579394321782, 0.16822779751300054, 0.07948852881821944, 0.10255991878217696, 0.12028367206556234, 0.09397778217691921, 0.7652399976661391, 0.687818816059065, 0.8340344265313764, 0.7460237406631894, 0.7781983792419996, 0.7403247913978884, 0.7175647662957516, 0.7632168764691745, 0.8107584713276046, 0.30264753556873836, 0.29706112693948983, 0.26275926667626126, 0.2811496200506002, 0.2688314747001579, 0.2952199381837055, 0.2825508076256026, 0.25317907522436267, 0.2948119240085687, 0.24870916040401614, 0.3471849257486429, 0.25229813732882644, 0.28508628202213127, 0.4055714665888992, 0.4393120783054123, 0.3518081973244751, 0.2677596281666348, 0.3207230749850358, 0.20300962358302066, 0.23246997145227, 0.20637503514276911, 0.24450753452070006, 0.18093906127802983, 0.18262307246424503, 0.16686262501810667, 0.2864951055162497, 0.19101488413646917, 0.17004441583465524, 0.1831817161756749, 0.14117459438234614, 0.23535914483927, 0.22704190044251127, 0.22252566475591562, 0.22246573449791351, 0.21621901769442697, 0.2580457623939423, 0.03168726808130484, 0.03601450134891315, 0.051323801129741, 0.03150628450294202, 0.05454677812829145, 0.007087926451563198, 0.04511175112412069, 0.03282561435239062, 0.04293962280107333, 0.13299521580642537, 0.1397535175169181, 0.18878868937349713, 0.07831415013460641, 0.04454532858390359, 0.12741137307972006, 0.16198870150338285, 0.12492013647034328, 0.11064330112841259, 9.999999999998899e-05, 9.999999999998899e-05, 0.011417578140188733, 0.00035648528881115915, 0.00016006721759154185, 0.005825304358538008, 0.0012088139100376871, 9.999999999998899e-05, 0.003221866895512404, 0.14796275452260166, 0.10851410441721676, 0.11046053296000813, 0.1130644091624563, 0.15391956093158465, 0.12345659561280042, 0.11913236292894558, 0.11230986791241482, 0.11267609544504908, 0.4263882878336763, 0.4274936851927539, 0.418762143062789, 0.42370737177660467, 0.42619508402193385, 0.40668591884692074, 0.4619947216257798, 0.4316305570193989, 0.4252281948643636, 0.09622242057730568, 0.10154562610426676, 0.12754323142276225, 0.1518650648580846, 0.08036922075285924, 0.1168512587899544, 0.10482315958869981, 0.10949151293033377, 0.11934665835519698, 0.19635879516990407, 0.2128549046075614, 0.21380405649254097, 0.2782400523968531, 0.1710769568130761, 0.156119964775273, 0.22559412547938895, 0.2149500867421792, 0.19655704984022315, 0.27507332513181315, 0.2168960854077231, 0.2569360247544873, 0.26333752860079385, 0.2351800920612267, 0.23504736910850388, 0.2339570384547287, 0.28596058855875395, 0.2173744245111474, 0.1435578754082626, 0.19528702526478658, 0.18191678169751424, 0.20067916682830866, 0.18865795194902535, 0.15567460674666578, 0.17009371323470257, 0.21067224088098602, 0.18092628803649757, 0.19805772623424855, 0.19892448987309164, 0.1933443750917374, 0.2040216248660739, 0.17843398614234707, 0.20862260246614395, 0.18148653617512822, 0.18701623948247803, 0.19788348156793067, 0.18966784926753288, 0.17118586710925976, 0.1887820114198624, 0.24093594106455674, 0.19425712406099094, 0.18894911277597948, 0.19657032605801783, 0.22288735898571999, 0.2039058052990178, 0.6591255943146832, 0.7155335327444009, 0.5784357772217903, 0.36997196449666847, 0.46496652988090514, 0.3996162317452482, 0.423088913200384, 0.644734246147201, 0.6444714055886749, 0.5040092044175888, 0.25160257483728377, 0.4896576355282628, 0.3439219703324584, 0.36219841688120347, 0.2985248741608768, 0.2715577850515687, 0.3358049361279589, 0.3441020010389485, 0.1900397993674927, 0.18220014764950432, 0.16713469755567711, 0.1892132933271088, 0.18565058372246113, 0.18008964636483327, 0.1898151496881223, 0.18938524514386057, 0.18780640202032484, 0.07777444697759017, 0.08749656149770968, 0.08372609412640264, 0.08032183465446341, 0.07640557991169772, 0.07369140474666214, 0.06672823677255035, 0.07715349704212315, 0.07492541396122465]}, "mutation_prompt": null}
{"id": "8a0ba537-3331-4861-a942-91ff5fbffcae", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.75\n        self.success_rate = 0.15\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.25 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.04)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.007\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(25):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.85:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 8)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "AdvancedAdaptiveDE", "description": "An advanced differential evolution algorithm with reinforced adaptive mutation and dynamic local search adjustments for improved convergence.", "configspace": "", "generation": 57, "fitness": 0.22057788077166868, "feedback": "The algorithm AdvancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.4686126441671995, 0.4845787623343323, 0.4693396787239803, 0.47959435277998086, 0.4625720478099934, 0.4608238107330884, 0.4637327506691188, 0.4681758704604948, 0.4379155433298121, 0.053605842551637584, 0.05049936870864802, 0.03175131400850606, 0.034819080359009824, 0.054398361831627495, 0.06010445591522351, 0.0465478494745577, 0.041659072912407114, 0.0697049754563892, 0.09837745322914748, 0.12450010521407129, 0.11552150660537153, 0.12604269464921658, 0.10527259786556464, 0.12303231669142789, 0.10495344922414751, 0.12216421586001813, 0.08697356488438168, 0.09053321853928464, 0.10011922841867071, 0.09781114822020864, 0.08580674497870078, 0.09789218057738891, 0.07881257224989136, 0.08295512524896931, 0.10145952849193618, 0.08323957826195727, 0.8177474935766007, 0.7528888409044263, 0.7459535360781657, 0.7571223025086633, 0.7611863251800717, 0.6530755835314768, 0.7963525469939557, 0.8507965110671735, 0.7779638594839642, 0.30187088733386747, 0.2590502173434014, 0.25722835328649796, 0.288909033271443, 0.2967593230571218, 0.29456106637245405, 0.30758019829139016, 0.26908650012001323, 0.31653015187113887, 0.3711099562308421, 0.3831105724593781, 0.16887147510125555, 0.2654559048908509, 0.20467434948172025, 0.48469858838960855, 0.26137995014531556, 0.22635089692131238, 0.29007734865167667, 0.24230643670517782, 0.13307820015774685, 0.179581046655637, 0.2043196949015974, 0.142406435815847, 0.1965119769088114, 0.21083613475402585, 0.1969784195347173, 0.2104396201295542, 0.1625848777876907, 0.14204077265686177, 0.19109381324398456, 0.15167702563805285, 0.18391623588818706, 0.2133118625639635, 0.17281210791873747, 0.18739677181081438, 0.1612673165394235, 0.013889097217388735, 0.04190668201961201, 9.999999999998899e-05, 0.007523003853137755, 0.05158255616265428, 0.0315557126978907, 0.013920734037263016, 0.011322999382257004, 0.009435815621705146, 0.09729576488584712, 0.07792492154872621, 0.18087561378124173, 0.079623402530418, 0.10527489812213209, 0.08408304003895373, 0.15702792747894978, 0.07841852970108742, 0.09464162056006442, 0.021787900808875604, 9.999999999998899e-05, 0.0039589008376932355, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012428473667865925, 9.999999999998899e-05, 9.999999999998899e-05, 0.13081702663993167, 0.08658285927216891, 0.11943777510555809, 0.10510181212785807, 0.13012213958964203, 0.1136222173927457, 0.109671433751386, 0.13346646060572998, 0.11447049994686098, 0.4148461515386769, 0.4152735394750542, 0.41015897284397906, 0.43498888019312276, 0.3979409299150143, 0.4007018767218016, 0.43963032482283326, 0.40354942544106853, 0.4213744246122958, 0.09024019088477508, 0.11680427165337204, 0.11129933389585389, 0.11656661581411065, 0.1001003100973401, 0.09261977188328308, 0.08519186971044712, 0.12499317212477712, 0.12398527856790076, 0.19776181676172766, 0.19302427861781746, 0.17922112356799025, 0.29925415164405444, 0.24697463788631235, 0.23602181494727903, 0.25130105393973945, 0.19252042475723674, 0.20580771734807202, 0.21498071984000922, 0.23526127939905261, 0.21909759203920676, 0.2046821008539843, 0.21877123647970187, 0.21547445415604827, 0.2369848608832532, 0.25003591042203355, 0.2221095825660101, 0.1909349080457159, 0.18611531593987873, 0.1907984827800253, 0.1703698351822861, 0.17783232450721131, 0.17377472245298176, 0.21248578282208652, 0.17528799947860207, 0.16379546779942233, 0.2142878803117403, 0.19805723054689028, 0.19491160397717866, 0.20248890825695887, 0.214730451385456, 0.19210152131257696, 0.19183409738978308, 0.18700234238984592, 0.20064687623538957, 0.2056325346708483, 0.1796129690522945, 0.2008096773178012, 0.21601457729047657, 0.18867082813155944, 0.1819149928917707, 0.18397391238234584, 0.18986575042731013, 0.18759565276704415, 0.6021424525148547, 0.6120379237941486, 0.6135616993959806, 0.19504761412570304, 0.20015936377156518, 0.19440689103786812, 0.5612377726335236, 0.5319469033518673, 0.7457399315844155, 0.4721987507134592, 0.2112092163446223, 0.5010514963575494, 0.26262917511093775, 0.20487527976270614, 0.3805057672471568, 0.20540939868344787, 0.34376151590481263, 0.3833086829719148, 0.1930175315470638, 0.22065679222832668, 0.18485281815273957, 0.1915970262445723, 0.177187376876495, 0.19807829833797042, 0.18533028865765622, 0.18268900791361398, 0.1897091558206555, 0.07387241164666725, 0.09024365566902304, 0.08522535654396546, 0.06865743688589732, 0.07044428951222947, 0.06785234196688672, 0.08377690724207665, 0.0807232183857397, 0.0744440290160594]}, "mutation_prompt": null}
{"id": "d82bc679-63b7-46a7-80c1-0853c0f01d0e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.8\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.75\n        self.success_rate = 0.15\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.25 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.adaptive_crossover_rate()\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n\n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.006\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(25):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        def adaptive_crossover_rate():\n            return np.random.uniform(0.6, 0.95)\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:\n                population = sorted(population, key=func)\n                best_count = max(5, self.population_size // 8)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced adaptive differential evolution using stochastic selection and adaptive crossover with localized exploration.", "configspace": "", "generation": 58, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedAdaptiveDE' object has no attribute 'adaptive_crossover_rate'\").", "error": "AttributeError(\"'EnhancedAdaptiveDE' object has no attribute 'adaptive_crossover_rate'\")", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {}, "mutation_prompt": null}
{"id": "442d353b-ef47-42f0-aab9-06e2a4b8a1f0", "solution": "import numpy as np\n\nclass RefinedStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def stochastic_differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                # Using a stochastic approach for the mutation factor\n                self.mutation_factor = np.random.uniform(0.5, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - b), *self.bounds)\n\n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n\n        def adaptive_local_search(individual):\n            dynamic_radius = (self.bounds[1] - self.bounds[0]) * 0.01 * (1 - self.success_rate)\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(20):\n                perturbation = np.random.normal(0, dynamic_radius, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n\n        while self.evaluations < self.budget:\n            population = stochastic_differential_evolution(population)\n\n            # Apply local search dynamically on selected top individuals\n            if self.evaluations < self.budget * 0.8:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)\n                for i in range(min(best_count, len(population))):\n                    population[i] = adaptive_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedStochasticDE", "description": "A novel algorithm that refines adaptive differential evolution by incorporating stochastic mutation strategy and adaptive local search radius for improved exploration and exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.17272261507011877, "feedback": "The algorithm RefinedStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.12.", "error": "", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.2900051803635243, 0.28143076402538747, 0.3007644380770135, 0.3395503401617226, 0.2947961440304355, 0.3996864563841579, 0.2979816507019153, 0.2945195097451987, 0.29240214979380863, 0.03417381462495339, 0.028655147124833635, 0.02882502116727681, 0.031035603091294273, 0.054901329638898266, 0.05300359466173665, 0.06342636727909834, 0.05174403650139303, 0.04710765492326541, 0.09469407458711498, 0.12303716771608475, 0.11213022664971395, 0.11091245307828068, 0.08298031928495442, 0.11172611018836831, 0.09541215277616444, 0.11292776992849463, 0.11318117871849576, 0.08998656283274487, 0.08808101043824468, 0.07917291913622193, 0.08178637336962524, 0.08607617709011772, 0.06521216546407982, 0.06988233061185078, 0.07723370408269237, 0.0629467589525673, 0.20797459788712924, 0.40382821570855154, 0.18789051927222322, 0.20442206001212504, 0.3500956052851254, 0.272855204425418, 0.2086231086906014, 0.20109410216567492, 0.7793861726124178, 0.24291190079840597, 0.1677936133096677, 0.14493867118371695, 0.15663647399702463, 0.12840404450033072, 0.11156099231941441, 0.19019881592699583, 0.08611075508346333, 0.10444985183893074, 0.2423945700941258, 0.2743729412371557, 0.2065098805701181, 0.2731225331674768, 0.44020531642668603, 0.23157008156389425, 0.40833061436563767, 0.19388735176311733, 0.2386715485351405, 0.16610329067480412, 0.14925509067480958, 0.14751213604151814, 0.14917860795599303, 0.10105132406145345, 0.14160657839470348, 0.16357873757305275, 0.11381994729242073, 0.13404261196199607, 0.17594678629660576, 0.09291056220817462, 0.14772898515524446, 0.136948704873741, 0.08786965623826415, 0.1206018478606411, 0.11145406726527451, 0.1428096398876041, 0.10769564424054823, 0.004686673768264149, 0.015818524374818455, 0.0061651980638885995, 0.0194275807364771, 0.023627528926472574, 0.00742787978633952, 0.03218227159881737, 0.03326706023322512, 0.02204004958801875, 0.1750187607586755, 0.10436328065917455, 0.17572954437919086, 0.09647353140826909, 0.12071060758011354, 0.08544698991679633, 0.15273425665108675, 0.10008527583912818, 0.10792420129661073, 9.999999999998899e-05, 0.015752084370690866, 0.05366585719121597, 0.009388437907618785, 0.025986048547680163, 0.0488642248185992, 0.01524119878764163, 0.028183873307750962, 0.0061895559813576195, 0.11910876277008398, 0.04820682393434139, 0.09233793747121055, 0.07119579121663278, 0.05136745659982267, 0.09859760864570544, 0.05392806010098594, 0.06681842568378815, 0.07955248500056111, 0.30368449493207983, 0.2875284580001173, 0.3260962098620831, 0.30142714129621195, 0.2662460223546561, 0.33520250021753994, 0.3027115117901996, 0.2911766670665825, 0.3002462397989839, 0.08632228884371074, 0.12213028869963205, 0.09888448535922068, 0.10819653266191709, 0.10593570371416716, 0.1231852909662906, 0.10075124704378358, 0.06524141908069192, 0.10563202175544939, 0.2062938423828199, 0.19114945666296657, 0.26030142209561224, 0.23397918959535657, 0.2602794645712002, 0.17314683345072135, 0.2404301537408997, 0.1804720776008768, 0.23130179913428406, 0.2346088567950575, 0.22862476938976373, 0.23633343883132352, 0.2313465545265807, 0.24335435813453854, 0.24177251072361516, 0.23774671464726183, 0.24570508770016863, 0.21951154010221097, 0.1661125543677212, 0.1604694478630161, 0.18456180632414398, 0.18184814165185714, 0.17331722313161224, 0.1627890519960985, 0.17514384781198533, 0.17967602385127324, 0.16893781447346323, 0.1993645586035392, 0.18115643129869596, 0.1966842317983314, 0.21831210729820127, 0.1932767710424531, 0.19636310504836252, 0.2071486263097514, 0.19697664197056342, 0.18460484957119516, 0.16855969262488524, 0.16953177041696688, 0.18694712540820457, 0.195246013601721, 0.16646619209497493, 0.17692993407987745, 0.1510496979604462, 0.20153597809720636, 0.1844446653243892, 0.4695056144187929, 0.19749104948443763, 0.5667851604444502, 0.5970330722132429, 0.20827965529553671, 0.6500264500587981, 0.1988796980240931, 0.5194170912122331, 0.16610590006030057, 0.41825018817608095, 0.20635500835562814, 0.1771331641559757, 0.31754563573892614, 0.3780087603898047, 0.3385400220910816, 0.16062458960904025, 0.18858838859429028, 0.4237735174402688, 0.19238870375795036, 0.19153442653211894, 0.19327150383353342, 0.19433890102786489, 0.18179861455135804, 0.17657450711562706, 0.1916042795982157, 0.17972653781706738, 0.17881484856926344, 0.08650142624174895, 0.06511372580271235, 0.08642239370139271, 0.08707518090714694, 0.09462504838956776, 0.06709143424176578, 0.08248153201526598, 0.09258141269411424, 0.07203024853624396]}, "mutation_prompt": null}
{"id": "6ff846d3-3288-46a5-865d-d23657b78d58", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Changed from 10 to 8\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # Changed from 0.8 to 0.85\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.75  # Changed from 0.7 to 0.75\n        self.success_rate = 0.15  # Changed from 0.1 to 0.15\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.35, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)  # Changed increment from 0.03 to 0.05\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.02, self.success_rate - 0.02)  # Changed decrement from 0.01 to 0.02\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.006  # Changed step size from 0.005 to 0.006\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(25):  # Changed iteration count from 20 to 25\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Changed from 0.8 to 0.7\n                population = sorted(population, key=func)\n                best_count = max(5, self.population_size // 9)  # Changed from 4 to 5 and divisor from 10 to 9\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "A novel strategy enhancing adaptive differential evolution with probabilistic mutation control, dynamic local search, and strategic elitism for robust optimization.", "configspace": "", "generation": 60, "fitness": 0.22630187957813142, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.5048533309740493, 0.48979419852523376, 0.4649987362479481, 0.5008798092687952, 0.49438097739589626, 0.4694141694841941, 0.46613774093777205, 0.5136660996782507, 0.4779730331858729, 0.05823611286684227, 0.08007727514754204, 0.07418110351426077, 0.10154452514594214, 0.135801566992361, 0.07061205405168691, 0.06788109833103861, 0.09582669460540039, 0.04449955204640388, 0.14512976490285878, 0.11810474781768532, 0.10310826068727708, 0.09440123102198272, 0.0964918316605674, 0.10167205663310819, 0.11288749311529411, 0.1126530767530618, 0.10027114290056693, 0.08292452465118516, 0.10630099982674268, 0.09063394818336634, 0.09439675472053155, 0.07751706969930328, 0.08508719102043016, 0.09022895620945892, 0.09139558919975566, 0.06653407608603024, 0.7189796239900506, 0.7957919132315009, 0.7754847046642203, 0.8064700031154413, 0.7338878827198198, 0.8031004431348274, 0.7930661074077018, 0.6935680132981538, 0.8314069930708821, 0.3236878074620254, 0.27220434440956565, 0.27795431873692433, 0.28853655377646936, 0.28497902583546264, 0.3077799784887537, 0.33034327089617865, 0.26861310239463065, 0.33734690530987976, 0.39558713896584863, 0.5507729796316337, 0.3028247597249688, 0.3114038353912362, 0.2758491247601188, 0.39555731557059826, 0.20021379938986383, 0.3770582777600031, 0.5200219246781057, 0.24118664650289734, 0.1857796603913331, 0.21811201340904895, 0.1775800109074709, 0.16967826960275634, 0.22410017630808443, 0.16634146813619444, 0.2023470674301726, 0.19730847526246875, 0.20159278338361064, 0.21000207106950952, 0.22563238841557054, 0.14574146837832525, 0.16093148945968605, 0.14765270030632605, 0.1770446012344279, 0.20755389014282477, 0.16231047491512984, 0.04199859770536296, 0.02888516572159716, 0.03776643057294227, 0.03196556495876979, 0.0664592859446026, 0.01959414802311965, 0.04586996171365332, 0.0296847142533625, 0.058158678658726926, 0.13184528147451402, 0.10854981509458794, 0.08741684535697769, 0.13922461635737704, 0.09268220334086796, 0.05153498273361601, 0.17866060488094482, 0.14556448878091977, 0.1187776675082225, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007659650305006371, 0.0011240551755558048, 9.999999999998899e-05, 0.0007202767274524513, 9.999999999998899e-05, 0.038442035072221326, 0.005189120136585679, 0.1281849552206541, 0.12212493149801118, 0.1495070949551941, 0.10550812814040733, 0.10988042317977065, 0.12629393963219804, 0.12425777423145923, 0.11606937879186785, 0.1308964044147204, 0.4446388051344684, 0.430112842584646, 0.4311856790225703, 0.4273346238238195, 0.40936090964532645, 0.4268387047539922, 0.43803855674641146, 0.4324713518534944, 0.419740877957986, 0.14975453565953234, 0.11362346579629834, 0.09966786215948253, 0.09637496108803101, 0.09666627520268689, 0.10050623493585409, 0.11602739990575517, 0.11129939627260044, 0.10590104455752858, 0.18227659836085153, 0.22170138188080357, 0.33019890503650584, 0.24782804260079672, 0.20187231682323115, 0.17131647053481536, 0.1656676963451832, 0.15650091375759423, 0.18358077262570227, 0.18928660980815248, 0.23495108995130898, 0.2236795322690095, 0.21917254285819743, 0.23905110298102705, 0.20418850298822067, 0.24314240460676007, 0.26187514640192, 0.2473600530737997, 0.16000993017823517, 0.1967510662633647, 0.17487566195182458, 0.18290254721498345, 0.2058161154219933, 0.17434579418853502, 0.20648164197744323, 0.18924036078864515, 0.1891713892437079, 0.20573071724327352, 0.18408009400565928, 0.19851324411970261, 0.19072659010787507, 0.1943490045859395, 0.19531558455210052, 0.20364274791382153, 0.19997151435815497, 0.18205264820522093, 0.22171227540575833, 0.21018411523467317, 0.18179017941168918, 0.21406630153751827, 0.18882302675529494, 0.1952549631165985, 0.1828128976285499, 0.20606692057642773, 0.19602302589981813, 0.4078659216551975, 0.24277661776298487, 0.7678632038224169, 0.6079131259767281, 0.2006003630856671, 0.19667836468350575, 0.6182303496802067, 0.6883387331916433, 0.20719739703388573, 0.4458057979566452, 0.20777708126154626, 0.3587762077886435, 0.37628371988759834, 0.20002385358837926, 0.20088886141571383, 0.23057520353111793, 0.3387438768243236, 0.3965209140734902, 0.17385485266160106, 0.1760824343689985, 0.18253086566422894, 0.18892338702710887, 0.17849068548193658, 0.19111442378447896, 0.19155908681669298, 0.19816329472277816, 0.1890217727115302, 0.085730289928718, 0.06412247377753155, 0.07864593900043326, 0.07608473898744084, 0.07877204937165794, 0.06820211269238718, 0.06569933815016415, 0.07561915759889803, 0.07393939317277254]}, "mutation_prompt": null}
{"id": "cd5976cc-88a1-4b06-a227-1f5e95a2736c", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDE", "description": "A novel algorithm that refines adaptive differential evolution through probabilistic control of mutation, enhanced local search sensitivity, and strategic population management.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.4810385500387777, 0.49122641721592986, 0.481417236803091, 0.4713072674896479, 0.47907942755758925, 0.4982162158862644, 0.4790185902784956, 0.47037772352158014, 0.45364683128225736, 0.059242853241332716, 0.08349984161870283, 0.05069640365585437, 0.07470962317203833, 0.10955241306254138, 0.08569029893423508, 0.0834131814923258, 0.08124115958281997, 0.08182012560979568, 0.09019305794601074, 0.118304716925275, 0.11515170958533616, 0.10335729835276519, 0.10181151482121009, 0.13136328118327, 0.10937423055909135, 0.12097880324397614, 0.12088439405808182, 0.10976421993031049, 0.10026277273979467, 0.07553557301202107, 0.09781579394321782, 0.16822779751300054, 0.07948852881821944, 0.10255991878217696, 0.12028367206556234, 0.09397778217691921, 0.7652399976661391, 0.687818816059065, 0.8340344265313764, 0.7460237406631894, 0.7781983792419996, 0.7403247913978884, 0.7175647662957516, 0.7632168764691745, 0.8107584713276046, 0.30264753556873836, 0.29706112693948983, 0.26275926667626126, 0.2811496200506002, 0.2688314747001579, 0.2952199381837055, 0.2825508076256026, 0.25317907522436267, 0.2948119240085687, 0.24870916040401614, 0.3471849257486429, 0.25229813732882644, 0.28508628202213127, 0.4055714665888992, 0.4393120783054123, 0.3518081973244751, 0.2677596281666348, 0.3207230749850358, 0.20300962358302066, 0.23246997145227, 0.20637503514276911, 0.24450753452070006, 0.18093906127802983, 0.18262307246424503, 0.16686262501810667, 0.2864951055162497, 0.19101488413646917, 0.17004441583465524, 0.1831817161756749, 0.14117459438234614, 0.23535914483927, 0.22704190044251127, 0.22252566475591562, 0.22246573449791351, 0.21621901769442697, 0.2580457623939423, 0.03168726808130484, 0.03601450134891315, 0.051323801129741, 0.03150628450294202, 0.05454677812829145, 0.007087926451563198, 0.04511175112412069, 0.03282561435239062, 0.04293962280107333, 0.13299521580642537, 0.1397535175169181, 0.18878868937349713, 0.07831415013460641, 0.04454532858390359, 0.12741137307972006, 0.16198870150338285, 0.12492013647034328, 0.11064330112841259, 9.999999999998899e-05, 9.999999999998899e-05, 0.011417578140188733, 0.00035648528881115915, 0.00016006721759154185, 0.005825304358538008, 0.0012088139100376871, 9.999999999998899e-05, 0.003221866895512404, 0.14796275452260166, 0.10851410441721676, 0.11046053296000813, 0.1130644091624563, 0.15391956093158465, 0.12345659561280042, 0.11913236292894558, 0.11230986791241482, 0.11267609544504908, 0.4263882878336763, 0.4274936851927539, 0.418762143062789, 0.42370737177660467, 0.42619508402193385, 0.40668591884692074, 0.4619947216257798, 0.4316305570193989, 0.4252281948643636, 0.09622242057730568, 0.10154562610426676, 0.12754323142276225, 0.1518650648580846, 0.08036922075285924, 0.1168512587899544, 0.10482315958869981, 0.10949151293033377, 0.11934665835519698, 0.19635879516990407, 0.2128549046075614, 0.21380405649254097, 0.2782400523968531, 0.1710769568130761, 0.156119964775273, 0.22559412547938895, 0.2149500867421792, 0.19655704984022315, 0.27507332513181315, 0.2168960854077231, 0.2569360247544873, 0.26333752860079385, 0.2351800920612267, 0.23504736910850388, 0.2339570384547287, 0.28596058855875395, 0.2173744245111474, 0.1435578754082626, 0.19528702526478658, 0.18191678169751424, 0.20067916682830866, 0.18865795194902535, 0.15567460674666578, 0.17009371323470257, 0.21067224088098602, 0.18092628803649757, 0.19805772623424855, 0.19892448987309164, 0.1933443750917374, 0.2040216248660739, 0.17843398614234707, 0.20862260246614395, 0.18148653617512822, 0.18701623948247803, 0.19788348156793067, 0.18966784926753288, 0.17118586710925976, 0.1887820114198624, 0.24093594106455674, 0.19425712406099094, 0.18894911277597948, 0.19657032605801783, 0.22288735898571999, 0.2039058052990178, 0.6591255943146832, 0.7155335327444009, 0.5784357772217903, 0.36997196449666847, 0.46496652988090514, 0.3996162317452482, 0.423088913200384, 0.644734246147201, 0.6444714055886749, 0.5040092044175888, 0.25160257483728377, 0.4896576355282628, 0.3439219703324584, 0.36219841688120347, 0.2985248741608768, 0.2715577850515687, 0.3358049361279589, 0.3441020010389485, 0.1900397993674927, 0.18220014764950432, 0.16713469755567711, 0.1892132933271088, 0.18565058372246113, 0.18008964636483327, 0.1898151496881223, 0.18938524514386057, 0.18780640202032484, 0.07777444697759017, 0.08749656149770968, 0.08372609412640264, 0.08032183465446341, 0.07640557991169772, 0.07369140474666214, 0.06672823677255035, 0.07715349704212315, 0.07492541396122465]}, "mutation_prompt": null}
{"id": "fb025733-18d9-4f44-ae4e-0c4de81741f8", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - b), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDE", "description": "A novel algorithm that refines adaptive differential evolution through probabilistic control of mutation, enhanced local search sensitivity, and strategic population management.", "configspace": "", "generation": 52, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.4810385500387777, 0.49122641721592986, 0.481417236803091, 0.4713072674896479, 0.47907942755758925, 0.4982162158862644, 0.4790185902784956, 0.47037772352158014, 0.45364683128225736, 0.059242853241332716, 0.08349984161870283, 0.05069640365585437, 0.07470962317203833, 0.10955241306254138, 0.08569029893423508, 0.0834131814923258, 0.08124115958281997, 0.08182012560979568, 0.09019305794601074, 0.118304716925275, 0.11515170958533616, 0.10335729835276519, 0.10181151482121009, 0.13136328118327, 0.10937423055909135, 0.12097880324397614, 0.12088439405808182, 0.10976421993031049, 0.10026277273979467, 0.07553557301202107, 0.09781579394321782, 0.16822779751300054, 0.07948852881821944, 0.10255991878217696, 0.12028367206556234, 0.09397778217691921, 0.7652399976661391, 0.687818816059065, 0.8340344265313764, 0.7460237406631894, 0.7781983792419996, 0.7403247913978884, 0.7175647662957516, 0.7632168764691745, 0.8107584713276046, 0.30264753556873836, 0.29706112693948983, 0.26275926667626126, 0.2811496200506002, 0.2688314747001579, 0.2952199381837055, 0.2825508076256026, 0.25317907522436267, 0.2948119240085687, 0.24870916040401614, 0.3471849257486429, 0.25229813732882644, 0.28508628202213127, 0.4055714665888992, 0.4393120783054123, 0.3518081973244751, 0.2677596281666348, 0.3207230749850358, 0.20300962358302066, 0.23246997145227, 0.20637503514276911, 0.24450753452070006, 0.18093906127802983, 0.18262307246424503, 0.16686262501810667, 0.2864951055162497, 0.19101488413646917, 0.17004441583465524, 0.1831817161756749, 0.14117459438234614, 0.23535914483927, 0.22704190044251127, 0.22252566475591562, 0.22246573449791351, 0.21621901769442697, 0.2580457623939423, 0.03168726808130484, 0.03601450134891315, 0.051323801129741, 0.03150628450294202, 0.05454677812829145, 0.007087926451563198, 0.04511175112412069, 0.03282561435239062, 0.04293962280107333, 0.13299521580642537, 0.1397535175169181, 0.18878868937349713, 0.07831415013460641, 0.04454532858390359, 0.12741137307972006, 0.16198870150338285, 0.12492013647034328, 0.11064330112841259, 9.999999999998899e-05, 9.999999999998899e-05, 0.011417578140188733, 0.00035648528881115915, 0.00016006721759154185, 0.005825304358538008, 0.0012088139100376871, 9.999999999998899e-05, 0.003221866895512404, 0.14796275452260166, 0.10851410441721676, 0.11046053296000813, 0.1130644091624563, 0.15391956093158465, 0.12345659561280042, 0.11913236292894558, 0.11230986791241482, 0.11267609544504908, 0.4263882878336763, 0.4274936851927539, 0.418762143062789, 0.42370737177660467, 0.42619508402193385, 0.40668591884692074, 0.4619947216257798, 0.4316305570193989, 0.4252281948643636, 0.09622242057730568, 0.10154562610426676, 0.12754323142276225, 0.1518650648580846, 0.08036922075285924, 0.1168512587899544, 0.10482315958869981, 0.10949151293033377, 0.11934665835519698, 0.19635879516990407, 0.2128549046075614, 0.21380405649254097, 0.2782400523968531, 0.1710769568130761, 0.156119964775273, 0.22559412547938895, 0.2149500867421792, 0.19655704984022315, 0.27507332513181315, 0.2168960854077231, 0.2569360247544873, 0.26333752860079385, 0.2351800920612267, 0.23504736910850388, 0.2339570384547287, 0.28596058855875395, 0.2173744245111474, 0.1435578754082626, 0.19528702526478658, 0.18191678169751424, 0.20067916682830866, 0.18865795194902535, 0.15567460674666578, 0.17009371323470257, 0.21067224088098602, 0.18092628803649757, 0.19805772623424855, 0.19892448987309164, 0.1933443750917374, 0.2040216248660739, 0.17843398614234707, 0.20862260246614395, 0.18148653617512822, 0.18701623948247803, 0.19788348156793067, 0.18966784926753288, 0.17118586710925976, 0.1887820114198624, 0.24093594106455674, 0.19425712406099094, 0.18894911277597948, 0.19657032605801783, 0.22288735898571999, 0.2039058052990178, 0.6591255943146832, 0.7155335327444009, 0.5784357772217903, 0.36997196449666847, 0.46496652988090514, 0.3996162317452482, 0.423088913200384, 0.644734246147201, 0.6444714055886749, 0.5040092044175888, 0.25160257483728377, 0.4896576355282628, 0.3439219703324584, 0.36219841688120347, 0.2985248741608768, 0.2715577850515687, 0.3358049361279589, 0.3441020010389485, 0.1900397993674927, 0.18220014764950432, 0.16713469755567711, 0.1892132933271088, 0.18565058372246113, 0.18008964636483327, 0.1898151496881223, 0.18938524514386057, 0.18780640202032484, 0.07777444697759017, 0.08749656149770968, 0.08372609412640264, 0.08032183465446341, 0.07640557991169772, 0.07369140474666214, 0.06672823677255035, 0.07715349704212315, 0.07492541396122465]}, "mutation_prompt": null}
{"id": "3e3da4c2-faa4-4026-9c56-2133ab265e6d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7\n        self.success_rate = 0.1\n        self.diversity_threshold = 0.15\n    \n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < np.random.uniform(0.5, self.crossover_rate)\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.02)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.01\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(15):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.85:\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 8)\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced adaptive differential evolution algorithm using stochastic mutation adjustments, improved local search dynamics, and adaptive crossover for robust optimization.", "configspace": "", "generation": 63, "fitness": 0.20730445242706338, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.4507816459064393, 0.42593757872583393, 0.4192102226998702, 0.4391858602484652, 0.4500147566947841, 0.42785468614200506, 0.4374301349852404, 0.43403405999589273, 0.4393354636144017, 0.04992949038771444, 0.0434885719200061, 0.04255938106277468, 0.03580432605823047, 0.04227165906305286, 0.057886993911692164, 0.04610663676713811, 0.04232783405111351, 0.04650230989150028, 0.10782951047138034, 0.10120384737493826, 0.10573210634359909, 0.11189418109265137, 0.10652631507341703, 0.10740236936164971, 0.10274056000995735, 0.10597260424513388, 0.10283198949516414, 0.10129167280580298, 0.09082354665330294, 0.06996098470382783, 0.08406294726425945, 0.08857593041817058, 0.07719645677722076, 0.08900887171416527, 0.09335291659761247, 0.08304065162770424, 0.8655168099947748, 0.8288823155490616, 0.8290304425781757, 0.790645245482826, 0.9020913429240237, 0.7958633952208884, 0.8197964304596388, 0.8447939231750178, 0.8124656648063902, 0.26699771761522506, 0.23206590668727933, 0.21250426790810217, 0.25848564047366296, 0.2626750516411952, 0.25510327936964405, 0.22122522387290722, 0.25689013668126637, 0.24930012953518144, 0.22013054101640983, 0.19116117168049218, 0.17638182096488164, 0.3220685533585209, 0.2390061062788713, 0.2730771755973893, 0.28816640246333813, 0.1959442758226383, 0.31700958201939633, 0.18988731462099062, 0.170000740066921, 0.1651738029216835, 0.19279801240128125, 0.13839013028071456, 0.14705022457044215, 0.14034754883573097, 0.16807697146741352, 0.1521167211956701, 0.16313399803655426, 0.18668585000714688, 0.1637682167197292, 0.17021442556493382, 0.15937528205598572, 0.158241561560296, 0.16951398688214725, 0.2106527278047895, 0.145226921922196, 0.004032969326092872, 9.999999999998899e-05, 0.014891278192303625, 0.020758675331466803, 0.0015781403256230897, 0.0025840568535803188, 0.016652818872524455, 9.999999999998899e-05, 0.03837829568268769, 0.06626890851792544, 0.06619219266109977, 0.07388401612268847, 0.06435354651428138, 0.06080487188770933, 0.0845059261594655, 0.0978133857172806, 0.0858772532686054, 0.07326330703480799, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08477502299136797, 0.07563475524397689, 0.11269227594235376, 0.10216471337922939, 0.1003720570658404, 0.10444007328900295, 0.0925001847202378, 0.10443907014862619, 0.08786760157844453, 0.39692258324832286, 0.3908329418191411, 0.4162577892430277, 0.390564453648671, 0.3826389028830125, 0.4032062763846964, 0.4072017218371692, 0.4098997992409855, 0.3961142953194219, 0.10452703033546129, 0.10493294541156772, 0.08808151871664827, 0.08400921657271831, 0.09644996057469812, 0.11129473642735155, 0.0972951912220511, 0.08219932599118474, 0.09064325753184477, 0.2550694955822471, 0.23371343090891306, 0.2021017600930589, 0.23904788806120358, 0.2073606950594361, 0.20682007540143355, 0.2277839568185236, 0.1582449004106682, 0.21582987846671498, 0.21724471383955513, 0.19827694550563357, 0.25745053137438556, 0.2277079243640222, 0.21670671848597456, 0.22678342381843197, 0.25858029243113567, 0.2548938808628448, 0.23621526216711342, 0.2097141299382499, 0.17476990758953503, 0.1846161633819916, 0.1766667663770911, 0.1562047651276376, 0.17578457648159496, 0.1861130641882941, 0.1810776667490721, 0.17664179974559668, 0.19709659479452812, 0.18616788513841698, 0.18315962129733687, 0.2186352314673543, 0.19375692674576706, 0.1855953087946125, 0.19361691288813843, 0.18734782665899463, 0.1801739139697247, 0.20134384382142945, 0.1843307954500829, 0.18956905540817548, 0.19764056952712838, 0.1925237457233202, 0.1939332735829613, 0.17533793392036734, 0.19987237295560212, 0.1923945332499074, 0.18355966688042447, 0.17211238138437768, 0.5830177196408155, 0.5205599088190009, 0.20042525775582354, 0.4294049065919645, 0.4966052189539445, 0.43347387064390885, 0.49308087137929724, 0.3643520606260663, 0.23277566826490947, 0.37809582289245414, 0.39235706640061063, 0.3759061013252851, 0.2612658331985225, 0.31664495570608786, 0.21409492443258182, 0.2533802312096851, 0.18338972635423945, 0.17494863229590596, 0.1915214939324157, 0.1873347992824692, 0.18807956277971738, 0.16909615708784564, 0.17895112367986588, 0.17904243323881508, 0.17230943775597263, 0.07252351555589254, 0.07443376541301228, 0.07138867694349083, 0.06403735524813092, 0.06777751269859367, 0.07389672232237154, 0.07528095670182133, 0.09422833778117767, 0.07555268296086015]}, "mutation_prompt": null}
{"id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "solution": "import numpy as np\n\nclass EnhancedProbabilisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Adjusted adaptive mutation factor\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.2, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (d - b), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.02)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.004  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(25):  # Adjust iterations\n                perturbation = np.random.laplace(0, step_size, self.dim)  # Use Laplace distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.75:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 12)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedProbabilisticDE", "description": "An enhanced differential evolution algorithm integrating probabilistic mutation control, dynamic local search, and adaptive population strategies.", "configspace": "", "generation": 64, "fitness": 0.23704774263630965, "feedback": "The algorithm EnhancedProbabilisticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "e7a392d7-591c-4dad-96b8-b18231510c0a", "metadata": {"aucs": [0.5393123899668028, 0.5373972954254295, 0.5079782013055729, 0.4968929102876505, 0.5259901318766611, 0.521767150418901, 0.5214155825364594, 0.5296740436920113, 0.4949076177288344, 0.07366767395156093, 0.09214755069016678, 0.05288033145251325, 0.09097596369166117, 0.09466263592521718, 0.07479449687834772, 0.0757833173684399, 0.10927571775134204, 0.08344453158314313, 0.1382540154909837, 0.11491385970389256, 0.11883163280363807, 0.11365309472264085, 0.12844696667187605, 0.0965336070000592, 0.10958050676347553, 0.1174227517380676, 0.11429105541652351, 0.1195266305642112, 0.08483608289837707, 0.09931952397392652, 0.12368962102324732, 0.0934459367277033, 0.11342835078354674, 0.09687398011004755, 0.07511613370986436, 0.09958272903179677, 0.680631405306914, 0.7255111936109335, 0.8182972046751945, 0.8192975748315621, 0.7751893182143845, 0.7457393134812773, 0.7297768433603746, 0.7563818226191532, 0.812536785553954, 0.29886077666134914, 0.3103542392009424, 0.2835702771090227, 0.3360274178551189, 0.3043314705036071, 0.32514516832795504, 0.34585827875310593, 0.30794977699545656, 0.2732272025088319, 0.6291684172824116, 0.8020816467556198, 0.39279766079214673, 0.3240235649257236, 0.31062400792708544, 0.2639260038193084, 0.2272138282291698, 0.326492362036108, 0.26481610159747637, 0.21475843554620522, 0.25189340594273646, 0.14043577685892217, 0.11699996431486048, 0.13776153904479438, 0.19611502559522032, 0.1636583718067235, 0.25051713294569655, 0.2311026357271091, 0.18875427660841648, 0.17702308208034578, 0.22906378833359742, 0.2524204383298789, 0.2324917922330374, 0.15390773893014464, 0.18410391187800768, 0.2539139880624611, 0.27347957329775585, 0.04339946974859299, 0.01759915969930914, 0.006007871708253343, 0.012073253954930752, 0.063824010832493, 0.015758264474096673, 0.0017648621844533752, 0.025569230325591552, 0.04738454078870491, 0.11280943104815144, 0.07279985792184585, 0.10814321880573297, 0.12418841502977995, 0.08867922756325664, 0.12453762081665176, 0.16111857775697214, 0.10007410939112793, 0.09233317788680706, 0.06780205743565015, 0.001445889838076253, 9.999999999998899e-05, 0.019204365065578877, 0.021481075609119382, 0.005206169071318434, 0.01962047045475468, 0.0009554413169570175, 0.02633447606645245, 0.13798560743110155, 0.12869912651563642, 0.12523503797858115, 0.12971180420729211, 0.14269575458468642, 0.1433193860735399, 0.14468139117355971, 0.13322381207901313, 0.0967217457749473, 0.4284357688660174, 0.4493172275452927, 0.44342063008677046, 0.45668972253241713, 0.4334007101334275, 0.44644143738333486, 0.4581253802059365, 0.4579978557967559, 0.426499091865304, 0.11531356963002526, 0.09581122636399797, 0.10011660846031334, 0.12179121676273974, 0.14247486589019487, 0.1043105164220377, 0.112411187165109, 0.11636637927553783, 0.1039195457803358, 0.16954868524955202, 0.18137299349475478, 0.18169310776861103, 0.31463461433489215, 0.2582438867701111, 0.15506934344792445, 0.31257521981618264, 0.20321716958269342, 0.14919835244996105, 0.2533281036250242, 0.2648362940385718, 0.2575445860341099, 0.24676639782381748, 0.2603470810315308, 0.22536733351678773, 0.28742620731465585, 0.28490213306577983, 0.2455479647078318, 0.17552371428624047, 0.1825100047979683, 0.21697381305352492, 0.21229089565868842, 0.19652217045489195, 0.17611054571996787, 0.1948438291209562, 0.22029874699581564, 0.17566885177652203, 0.19760146210226215, 0.20119337303812468, 0.2001564181942025, 0.1981487440303933, 0.17723549361504298, 0.18337147474618198, 0.18802240202239484, 0.18295349223879898, 0.19274747437693873, 0.1946099767469669, 0.18650050692307973, 0.20205586348643823, 0.20432224669717958, 0.19934491616787042, 0.19385530223441516, 0.19623160401607753, 0.1965354613328315, 0.2130192954860679, 0.18324990787061224, 0.18666411133641536, 0.7039818165848036, 0.7962273880806561, 0.19975344172626175, 0.19589873004218417, 0.6065419079574869, 0.6952244277691323, 0.7936762260212924, 0.4232485056942079, 0.30084814070198307, 0.33841529462875564, 0.19597473974392787, 0.20556622017251092, 0.5905707441935798, 0.4771372768037905, 0.3636072373958583, 0.23459687725256295, 0.1837292423064424, 0.1791451415247799, 0.1759201228321361, 0.19515149080590044, 0.1715152474941768, 0.1937348349943948, 0.1950346594978002, 0.18423251536221352, 0.1995018916754393, 0.09255892510374375, 0.09214624883020239, 0.07764709787169777, 0.07624411609844306, 0.07564043657424024, 0.07271235052283775, 0.07643157623472507, 0.08003054387377673, 0.08521000755801922]}, "mutation_prompt": null}
{"id": "bb4a3e89-011d-4ec0-90e7-ebdc2dff93dc", "solution": "import numpy as np\n\nclass HybridStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.15  # Adjusted success rate\n        self.gradient_step_size = 0.005  # New parameter for gradient-based updates\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.15 * (d - b), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.02, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def stochastic_gradient_update(individual):\n            gradient = np.random.normal(0, self.gradient_step_size, self.dim)  # Gradient-based update\n            candidate = np.clip(individual - gradient, *self.bounds)\n            candidate_val = func(candidate)\n            self.evaluations += 1\n            if candidate_val < func(individual):\n                return candidate\n            return individual\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:  # Adjust exploration-exploitation balance\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = stochastic_gradient_update(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridStochasticDE", "description": "A hybrid metaheuristic blending enhanced differential evolution with stochastic gradient-based updates and dynamic exploration-exploitation balancing.", "configspace": "", "generation": 65, "fitness": 0.17841556082176668, "feedback": "The algorithm HybridStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.11.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.3867632605592397, 0.3889835006318322, 0.4245377981448164, 0.4065865199651656, 0.395569855624313, 0.36081079257394433, 0.37551472642731165, 0.4143318020834964, 0.39328141760072866, 0.10650790510653618, 0.11896367971313426, 0.11254294010698218, 0.10216676741325281, 0.11985769919116207, 0.12439057068014503, 0.10515542082365958, 0.13239044215816287, 0.11151861550593256, 0.07907157159533529, 0.0984511638221024, 0.08733407242991575, 0.09327456717216842, 0.0965353730695262, 0.09672591661202079, 0.08876392849690706, 0.08938605753929862, 0.09945680413245028, 0.06898310755888615, 0.07669405527072981, 0.07893625066013432, 0.08504943488187033, 0.07333570532197664, 0.06543994502212502, 0.07984960041122724, 0.07226205084466253, 0.08935205482251696, 0.3434256017557096, 0.2294748981390239, 0.519131248972291, 0.4098654098066994, 0.4131904618737221, 0.4277373399594019, 0.49912305624980613, 0.7244470953291887, 0.38258452517702535, 0.16100268870845924, 0.15550479144670348, 0.1292160592279552, 0.14223432049864115, 0.1383928509143576, 0.16211933277301027, 0.1309518339178679, 0.11529708159738783, 0.15717569651291763, 0.29213940485858747, 0.35242558168406846, 0.2281116871177583, 0.3323748026061002, 0.3396694923936734, 0.38950782589840194, 0.4379117825729326, 0.3798525797492991, 0.26353915681169093, 0.11400605263706343, 0.11638416745064828, 0.10116096995736301, 0.09779216482978204, 0.13611553901638473, 0.11147120006609823, 0.10606304950537082, 0.1711698243081481, 0.10854133364248086, 0.10009642268269059, 0.11075252658166901, 0.15879593782086, 0.09684670122659411, 0.10856285313572389, 0.12180404143674184, 0.09219166182540317, 0.08481201971908836, 0.13364284165843943, 0.06012311346714394, 0.06605673985921401, 0.0640144470433488, 0.09252077289957283, 0.11896786098212175, 0.050006669134177395, 0.052865361518872445, 0.08221824531141286, 0.04943603926496254, 0.1712343523469475, 0.1867444215372729, 0.19864702745191476, 0.1419548102541094, 0.1448619740396052, 0.18801451364693944, 0.2000258571063418, 0.1628454051900109, 0.16865994620334335, 0.02261886780544997, 0.021256978510448943, 0.01189322663447423, 0.01498479573166367, 0.014048096596226967, 0.0082226797417847, 0.018622976476574182, 0.0036630827419470435, 0.0332493482668762, 0.08577698486658558, 0.06676627006681535, 0.09238458123497162, 0.08253121022027932, 0.10307406643360806, 0.08941174830674203, 0.08285044352812476, 0.08329138286475313, 0.06460912011604325, 0.3792800389419009, 0.3879173855358302, 0.3717868421946551, 0.3546504509211277, 0.3594988450019265, 0.3832027521036828, 0.3619725686841403, 0.3681246117284068, 0.3822446391167972, 0.08312322793448002, 0.07358645341333325, 0.07610432860666694, 0.07156815609108858, 0.09415584746150962, 0.10327193884977026, 0.08697817844108391, 0.09459178223111553, 0.0845180269790502, 0.13301436666520727, 0.16303597750596233, 0.14123936036454454, 0.16107627458964213, 0.15304602879518292, 0.1824926550887428, 0.13358885948518728, 0.13649176371467986, 0.11892045615656444, 0.2497432035494086, 0.2533084985156262, 0.2505692410174505, 0.2419836020870968, 0.26630197753388885, 0.2314356659833411, 0.2635163654424034, 0.2580596618295251, 0.23862000714947618, 0.1738053717358069, 0.18209233250617096, 0.18872554490551807, 0.180691494489313, 0.1915409559393172, 0.1988978766197943, 0.18010495659486592, 0.21102952557964227, 0.17472132860802592, 0.2203586985567355, 0.186123556235957, 0.22553179659391465, 0.1981189302893711, 0.19921055567205292, 0.2259947358340283, 0.21367338200827235, 0.1953314224067697, 0.206160494008233, 0.16648496045961092, 0.1609380676435761, 0.16612856727383896, 0.16977436095207143, 0.17634008135908474, 0.1722506670567966, 0.17461609766440178, 0.17639917514957615, 0.16821720742458435, 0.14807559114633262, 0.16934052444343306, 0.31328882819269654, 0.1741684127421741, 0.16449675998409496, 0.18514760586549972, 0.27525100549118864, 0.1427342369950868, 0.21969173071214987, 0.2022888216287535, 0.1897161179097746, 0.22598798050330082, 0.36120645556446696, 0.2287107137891088, 0.15431613978284664, 0.18535121527263598, 0.18495653398904055, 0.16426212197462642, 0.19916993059688548, 0.19451489885771112, 0.220551821802902, 0.19052223680524116, 0.19591323937975114, 0.19215632258900173, 0.20460973168281293, 0.1908289596853685, 0.21711501889768048, 0.0947552721825643, 0.07958515616972395, 0.06916994253166087, 0.08622013965411335, 0.08691410424451462, 0.0855425553335375, 0.08643492171143696, 0.07190296149988173, 0.08273623918419415]}, "mutation_prompt": null}
{"id": "7d9af51c-b39a-4c1a-a69b-1e2bdb548145", "solution": "import numpy as np\n\nclass EnhancedProbabilisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Adjusted adaptive mutation factor\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.2, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (d - b), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.02)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.004  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(25):  # Adjust iterations\n                perturbation = np.random.laplace(0, step_size, self.dim)  # Use Laplace distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.75:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 12)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedProbabilisticDE", "description": "An enhanced differential evolution algorithm integrating probabilistic mutation control, dynamic local search, and adaptive population strategies.", "configspace": "", "generation": 65, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.5393123899668028, 0.5373972954254295, 0.5079782013055729, 0.4968929102876505, 0.5259901318766611, 0.521767150418901, 0.5214155825364594, 0.5296740436920113, 0.4949076177288344, 0.07366767395156093, 0.09214755069016678, 0.05288033145251325, 0.09097596369166117, 0.09466263592521718, 0.07479449687834772, 0.0757833173684399, 0.10927571775134204, 0.08344453158314313, 0.1382540154909837, 0.11491385970389256, 0.11883163280363807, 0.11365309472264085, 0.12844696667187605, 0.0965336070000592, 0.10958050676347553, 0.1174227517380676, 0.11429105541652351, 0.1195266305642112, 0.08483608289837707, 0.09931952397392652, 0.12368962102324732, 0.0934459367277033, 0.11342835078354674, 0.09687398011004755, 0.07511613370986436, 0.09958272903179677, 0.680631405306914, 0.7255111936109335, 0.8182972046751945, 0.8192975748315621, 0.7751893182143845, 0.7457393134812773, 0.7297768433603746, 0.7563818226191532, 0.812536785553954, 0.29886077666134914, 0.3103542392009424, 0.2835702771090227, 0.3360274178551189, 0.3043314705036071, 0.32514516832795504, 0.34585827875310593, 0.30794977699545656, 0.2732272025088319, 0.6291684172824116, 0.8020816467556198, 0.39279766079214673, 0.3240235649257236, 0.31062400792708544, 0.2639260038193084, 0.2272138282291698, 0.326492362036108, 0.26481610159747637, 0.21475843554620522, 0.25189340594273646, 0.14043577685892217, 0.11699996431486048, 0.13776153904479438, 0.19611502559522032, 0.1636583718067235, 0.25051713294569655, 0.2311026357271091, 0.18875427660841648, 0.17702308208034578, 0.22906378833359742, 0.2524204383298789, 0.2324917922330374, 0.15390773893014464, 0.18410391187800768, 0.2539139880624611, 0.27347957329775585, 0.04339946974859299, 0.01759915969930914, 0.006007871708253343, 0.012073253954930752, 0.063824010832493, 0.015758264474096673, 0.0017648621844533752, 0.025569230325591552, 0.04738454078870491, 0.11280943104815144, 0.07279985792184585, 0.10814321880573297, 0.12418841502977995, 0.08867922756325664, 0.12453762081665176, 0.16111857775697214, 0.10007410939112793, 0.09233317788680706, 0.06780205743565015, 0.001445889838076253, 9.999999999998899e-05, 0.019204365065578877, 0.021481075609119382, 0.005206169071318434, 0.01962047045475468, 0.0009554413169570175, 0.02633447606645245, 0.13798560743110155, 0.12869912651563642, 0.12523503797858115, 0.12971180420729211, 0.14269575458468642, 0.1433193860735399, 0.14468139117355971, 0.13322381207901313, 0.0967217457749473, 0.4284357688660174, 0.4493172275452927, 0.44342063008677046, 0.45668972253241713, 0.4334007101334275, 0.44644143738333486, 0.4581253802059365, 0.4579978557967559, 0.426499091865304, 0.11531356963002526, 0.09581122636399797, 0.10011660846031334, 0.12179121676273974, 0.14247486589019487, 0.1043105164220377, 0.112411187165109, 0.11636637927553783, 0.1039195457803358, 0.16954868524955202, 0.18137299349475478, 0.18169310776861103, 0.31463461433489215, 0.2582438867701111, 0.15506934344792445, 0.31257521981618264, 0.20321716958269342, 0.14919835244996105, 0.2533281036250242, 0.2648362940385718, 0.2575445860341099, 0.24676639782381748, 0.2603470810315308, 0.22536733351678773, 0.28742620731465585, 0.28490213306577983, 0.2455479647078318, 0.17552371428624047, 0.1825100047979683, 0.21697381305352492, 0.21229089565868842, 0.19652217045489195, 0.17611054571996787, 0.1948438291209562, 0.22029874699581564, 0.17566885177652203, 0.19760146210226215, 0.20119337303812468, 0.2001564181942025, 0.1981487440303933, 0.17723549361504298, 0.18337147474618198, 0.18802240202239484, 0.18295349223879898, 0.19274747437693873, 0.1946099767469669, 0.18650050692307973, 0.20205586348643823, 0.20432224669717958, 0.19934491616787042, 0.19385530223441516, 0.19623160401607753, 0.1965354613328315, 0.2130192954860679, 0.18324990787061224, 0.18666411133641536, 0.7039818165848036, 0.7962273880806561, 0.19975344172626175, 0.19589873004218417, 0.6065419079574869, 0.6952244277691323, 0.7936762260212924, 0.4232485056942079, 0.30084814070198307, 0.33841529462875564, 0.19597473974392787, 0.20556622017251092, 0.5905707441935798, 0.4771372768037905, 0.3636072373958583, 0.23459687725256295, 0.1837292423064424, 0.1791451415247799, 0.1759201228321361, 0.19515149080590044, 0.1715152474941768, 0.1937348349943948, 0.1950346594978002, 0.18423251536221352, 0.1995018916754393, 0.09255892510374375, 0.09214624883020239, 0.07764709787169777, 0.07624411609844306, 0.07564043657424024, 0.07271235052283775, 0.07643157623472507, 0.08003054387377673, 0.08521000755801922]}, "mutation_prompt": null}
{"id": "f51f4774-7e2e-4f45-94b8-7c6c7ca3902f", "solution": "import numpy as np\n\nclass HybridMetaheuristicOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.9\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.8\n        self.success_rate = 0.15\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.05, self.success_rate - 0.03)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def strategic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use Gaussian distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 10)\n                for i in range(min(best_count, len(population))):\n                    population[i] = strategic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridMetaheuristicOptimizer", "description": "A robust hybrid metaheuristic leveraging dynamic crossover, adaptive mutation, and a strategic local search to balance exploration and exploitation.", "configspace": "", "generation": 67, "fitness": 0.23202357592523928, "feedback": "The algorithm HybridMetaheuristicOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.5067914732083434, 0.46549746528994373, 0.4752734132080214, 0.49987532044540517, 0.5046684194319557, 0.4903002991663228, 0.5135710170343539, 0.45916264868909784, 0.462503473077028, 0.12028322049512918, 0.0768348469801573, 0.09126546221906662, 0.1076313546645914, 0.08290459148453722, 0.072646247291834, 0.08981402058055465, 0.09240166652179282, 0.0733521892302118, 0.09272252217535093, 0.11118894479623853, 0.1034427932089893, 0.11655964168792265, 0.1308487727082256, 0.11365686714016154, 0.11519977405248205, 0.11349729212944892, 0.09531820791948808, 0.08227632762715076, 0.09014740675832822, 0.12375021515669127, 0.1125460218514982, 0.09786624637104357, 0.07861681307664226, 0.11644478206103837, 0.0834098625251043, 0.09138811906046818, 0.8595566832597363, 0.8587033136519537, 0.8272742977068175, 0.7991779829427985, 0.8025225070619095, 0.8290136091455116, 0.8452211806475438, 0.8384573473905557, 0.8203114065163678, 0.2957263844330015, 0.2812143694422574, 0.2677035053377743, 0.2812309694219579, 0.28587443357434683, 0.3179389246607872, 0.31211099671397646, 0.2864143576388819, 0.2706652734973227, 0.45675768799188654, 0.3445429243091178, 0.5038678848688959, 0.6083556277506721, 0.2518094419890746, 0.2671350364239987, 0.24131362421021996, 0.2662068475925131, 0.48201928696049334, 0.23088590278334986, 0.1538191935752724, 0.1793246746545223, 0.1401407181680705, 0.14172836293492086, 0.14907041632681461, 0.1442644708064339, 0.20532607417015747, 0.17456684655018706, 0.19107331723759713, 0.15464043940490246, 0.14741830608579554, 0.16122757181366865, 0.20158953304808558, 0.16067264908924683, 0.1865377297906149, 0.2113439843104774, 0.13589273428451165, 0.0724074545529918, 0.03243437976488184, 0.018436916193399155, 0.05355492973635789, 0.06334402588092147, 0.05241151342757677, 0.04035743461744534, 0.036463509077133804, 0.03194325151868416, 0.14093546558532521, 0.13016820120134398, 0.1585797820152529, 0.11229841209304792, 0.13587910067585507, 0.07819424424267019, 0.15165838733294446, 0.1484724053630151, 0.13555530964677331, 9.999999999998899e-05, 0.0017408157161600268, 0.006521030642656633, 0.006676499889054166, 0.00813723604890182, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005834420409123187, 0.1250599078044241, 0.12352832868959995, 0.1223559098958582, 0.11189071964718589, 0.13201673300331973, 0.12594890597794817, 0.12354419566229713, 0.0998510722958792, 0.14342895491170293, 0.43683692848454925, 0.412884168560009, 0.45962111021572905, 0.4599195485354841, 0.4240188281398447, 0.39021979306970245, 0.5091576510149664, 0.4151522306809198, 0.4008325900750378, 0.11591226648787156, 0.09054626930324228, 0.11020933410330436, 0.10162546055443689, 0.1374212219126244, 0.10118362148963789, 0.11726344183947346, 0.1185809326708488, 0.09186524081846148, 0.16215547577671663, 0.1818553943788319, 0.1842226461474603, 0.3014915608926333, 0.27127412937396955, 0.17622785757091264, 0.21259186520369833, 0.23589044186174613, 0.17158512196928644, 0.23859201892460136, 0.22756660774541204, 0.23947202361374065, 0.23929373375145058, 0.23088476030035798, 0.232373683847659, 0.22684575385171524, 0.25806024412970097, 0.22114683747745345, 0.17052479270982934, 0.16476887663862838, 0.16765256709340215, 0.17025828953527378, 0.17695613866288118, 0.18498369962072359, 0.1807946545486977, 0.1792933530826043, 0.17777657350989917, 0.1878611861493381, 0.17406622997788668, 0.16712912035379135, 0.2258680016473683, 0.23220326741931963, 0.17580257128407706, 0.19398637248424255, 0.1922025525366171, 0.17016503123272086, 0.21292058383854218, 0.19233469785185253, 0.1741796782059466, 0.20460368336406998, 0.20559994159535477, 0.17979836338973942, 0.20257600184631197, 0.17221259422074797, 0.17573754058002722, 0.6415040520087876, 0.1726734920024544, 0.5737512169460004, 0.7223296283433419, 0.199603170886402, 0.5884374969858859, 0.7024841643341684, 0.718123779266775, 0.20335927127888365, 0.47772198280893574, 0.20883383259735433, 0.4434103206153368, 0.38984660239451974, 0.27314751129462833, 0.35737292282491084, 0.2417632615469978, 0.3202874974280797, 0.2205666468319415, 0.1886248782379436, 0.17741865332971118, 0.1718274836671766, 0.19693634348874745, 0.1881227755762418, 0.1806150157860953, 0.20489063984906009, 0.17823630850571448, 0.17276768871915105, 0.09090753854879785, 0.11353777960676525, 0.09509594101542407, 0.07546459192839317, 0.07621772835909746, 0.0728977564240153, 0.07097692921688414, 0.06831709061570723, 0.06764722540862078]}, "mutation_prompt": null}
{"id": "68521ea6-3032-4a9e-b250-843ef3d5eb26", "solution": "import numpy as np\n\nclass DynamicHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.65  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.15  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)  # Adjust vector combination\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def stochastic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(30):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use Gaussian distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 10)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = stochastic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "DynamicHybridDE", "description": "A dynamic hybrid algorithm fusing adaptive differential evolution with stochastic local search incorporating Gaussian jumps.", "configspace": "", "generation": 68, "fitness": 0.23679799894611106, "feedback": "The algorithm DynamicHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.524275349675418, 0.5146357324101007, 0.501400087169614, 0.5224193262476268, 0.525984164683738, 0.49851996565201384, 0.493887727988924, 0.5280032699100843, 0.5075783245089244, 0.10579389811524453, 0.10197857336265936, 0.14061849436617613, 0.10377807787740223, 0.11774080254037944, 0.10045822011041383, 0.09219949760559776, 0.09725877351331624, 0.11254376202743899, 0.11549665168909451, 0.10170652140139269, 0.11470221363268229, 0.11439543281985265, 0.09667326898179562, 0.09595548035953139, 0.09680519792704001, 0.12295291618746995, 0.12784439589123964, 0.08195256820194496, 0.0887458664811176, 0.11727421640623592, 0.0975547267676089, 0.06948534437203657, 0.07112491470871851, 0.07596853959113237, 0.07425610359174739, 0.09604407689040872, 0.7921323690977412, 0.8573509738618545, 0.814895270198626, 0.7693447986658997, 0.8064983565563008, 0.7787366152075784, 0.7182125031665574, 0.6476450890046779, 0.7930931691450701, 0.331330773803049, 0.3052827405028594, 0.2858717720219386, 0.30722239903000637, 0.29283170411904913, 0.3277440057802883, 0.29471917603715825, 0.32838415248226915, 0.3507084812200706, 0.6636532256749337, 0.35276689518021354, 0.4310770966745354, 0.24497834659953444, 0.38201887853163274, 0.38176020049724535, 0.48982769272494375, 0.5248713037722541, 0.3412826505481533, 0.23066799701431495, 0.16274241783685794, 0.18991068773094033, 0.17892469655172172, 0.16788234012094694, 0.18773924925642393, 0.17332542469557033, 0.19065557621972684, 0.21303636596798292, 0.23662524078212888, 0.17739200224146445, 0.18575764903306535, 0.2319476620634583, 0.1826639091415877, 0.2018646749690468, 0.2018462065780674, 0.22795817467130786, 0.15490793795797086, 0.04657716787299537, 0.06683272641490257, 0.02874613116426461, 0.050232146550300616, 0.03724016491551341, 0.005614406347244971, 0.031063208306510215, 0.03939809493907487, 0.047016473565655525, 0.11299001263959785, 0.08782610116516443, 0.17678321393399388, 0.1235156390419575, 0.16636196128827108, 0.13771437511864548, 0.20285451250296815, 0.1872528934362716, 0.153606675481055, 0.0012451587789633622, 0.003029343458228362, 0.016673238902921717, 9.999999999998899e-05, 0.013239957128128976, 0.0033625693676986312, 0.010117166692751756, 0.0021250983537144386, 0.015505745705040708, 0.13051746196039749, 0.10311457038381955, 0.1258562135982716, 0.11566676601393833, 0.12839466017805934, 0.13872419964107263, 0.14029496366418248, 0.1674739662076934, 0.12095560091037438, 0.46116726964698473, 0.4522400266402039, 0.4595960052490723, 0.45675980193461285, 0.43458310075338424, 0.45271142886854554, 0.46792799140689034, 0.43786804789795364, 0.42837548661027924, 0.11514472398093734, 0.1539472219319663, 0.12849563688083288, 0.13979263024550015, 0.0797319628558032, 0.1047937306833634, 0.09399150194261241, 0.12412294821483827, 0.08095131323951232, 0.22093541598090072, 0.29177719848636174, 0.18419339277317737, 0.3070520818629975, 0.25647433785233376, 0.1850763487846261, 0.23144497444469347, 0.14762350898778298, 0.23684767816900698, 0.23971282080608003, 0.24614593218675107, 0.2416508130680214, 0.23659251458153463, 0.2677731194597158, 0.26318923595745947, 0.2457560148808846, 0.28364397823976606, 0.24552133336169202, 0.1816272960542299, 0.21781380628943792, 0.17558797311955732, 0.19144939753062573, 0.21936188608629303, 0.19818641550186777, 0.16066912027147717, 0.2109142282521721, 0.19076705822998918, 0.20263710807638458, 0.19775049461352356, 0.1765139776812763, 0.17383176317522375, 0.18062303323870565, 0.1872899112953883, 0.18731736426890644, 0.20519397586935506, 0.2078159571975967, 0.2073623473464038, 0.21905030014961047, 0.20303142616229974, 0.24531009547549942, 0.17986477093440623, 0.193628877051658, 0.20104492680177288, 0.21038674173315652, 0.17982763596343598, 0.18638648265340974, 0.7290088630173204, 0.16692497734090794, 0.7679974264923393, 0.199978499342523, 0.19819644123862878, 0.18305962359643002, 0.16911622945687488, 0.7140895747653615, 0.5200222918896367, 0.21009367908326038, 0.4232756450563372, 0.42346827848260904, 0.20551135346952232, 0.20358472268731598, 0.636881737114041, 0.4182799757983615, 0.2774353305303846, 0.19956147873806973, 0.1993976723513884, 0.17976495355858935, 0.19370525777240977, 0.1775638185931281, 0.19028625920173192, 0.17165228574415214, 0.19718399951164622, 0.21553038565343818, 0.08066028582916629, 0.07503030721198889, 0.08302156577502151, 0.0744558380055782, 0.07253618505631398, 0.0879910944917397, 0.06530644961780563, 0.05892869120257582, 0.08788677255985367]}, "mutation_prompt": null}
{"id": "7b666028-455d-4544-bbd4-7c7a5689e2fc", "solution": "import numpy as np\n\nclass DynamicAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.15  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.1, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def enhanced_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.006  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(30):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.65:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = enhanced_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "DynamicAdaptiveDE", "description": "A dynamic and adaptive differential evolution algorithm with probabilistic mutation, enhanced local search, and fitness-based elitism.", "configspace": "", "generation": 69, "fitness": 0.2218389744225349, "feedback": "The algorithm DynamicAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.4698596264346432, 0.4413480176150476, 0.45648839683465015, 0.5374050164924424, 0.4804236107038068, 0.5039284696754041, 0.46783335931276193, 0.4596894416902586, 0.4504401211514063, 0.08178434108174537, 0.05799901147239783, 0.06009441713437502, 0.09456240449200182, 0.08299172604983562, 0.057037005270635155, 0.04591779664241891, 0.06316450424732356, 0.05998041797485143, 0.1252155313577339, 0.11986986566892888, 0.12829496117300443, 0.09072990048721663, 0.13177922790195884, 0.09680084004558243, 0.11650097181252039, 0.11931962492009318, 0.1235516260973023, 0.07394742191843329, 0.07969741542878239, 0.09783691194662425, 0.1087724074282651, 0.09851475608797988, 0.08261880618317596, 0.10540947860090233, 0.07653873593577643, 0.07610633837218173, 0.7084583114540259, 0.5771999560788138, 0.6969938443027475, 0.7226753544761209, 0.6727148114215002, 0.6018455768645736, 0.6239473416790667, 0.8570930246771898, 0.7070069767303864, 0.30585728545397195, 0.29537164503952995, 0.2857833849047573, 0.25795665012899227, 0.2855434148191929, 0.27615660692563393, 0.28841954190838115, 0.28059891840395723, 0.2740584042752675, 0.26073622057767165, 0.4281458581755939, 0.45293122117254914, 0.257950234815971, 0.3562243889203609, 0.20746793828500998, 0.2852783374380127, 0.4600698543478392, 0.17776827472221035, 0.20030913268910566, 0.1454467273914708, 0.1726635301315993, 0.16489610393571308, 0.14469844514546548, 0.1455224490017717, 0.1685853162394223, 0.2725073200536656, 0.1588185949307186, 0.21333763099037772, 0.15467096828292637, 0.1353739921811129, 0.1538029024741685, 0.15625501838161293, 0.16971642672697673, 0.2120203516238084, 0.1629138392281526, 0.16179399801313188, 0.0209045134721082, 0.013877671381399836, 0.03797768574823279, 0.030681882719290843, 0.03745302312385701, 0.037272207252376344, 0.01495393524892119, 0.006633832132063255, 0.009993745235142737, 0.14180373457538387, 0.07134418701746459, 0.11682278131406987, 0.09561022661092866, 0.1019682572712527, 0.06553724443750197, 0.16448006301139373, 0.1571468324465064, 0.09920558422139203, 0.0005313879786305042, 0.006552313395438936, 0.009164524033053012, 9.999999999998899e-05, 0.0005344037495730314, 0.002473349046309692, 0.010125141295368456, 0.0012052483249459511, 0.007890465970507798, 0.11178505185209764, 0.11442866412468211, 0.11088541421370357, 0.12334188042188143, 0.12583087217135414, 0.1340245644007051, 0.12010428492870073, 0.11488983795863583, 0.09104818705644191, 0.421633058641794, 0.44149911605180137, 0.4357377668919301, 0.4147314722716411, 0.3920968420631723, 0.41133541435408894, 0.4418779612668772, 0.42451195268443476, 0.4307415278345861, 0.12308278079702284, 0.12520489429386872, 0.09883393449120981, 0.09643233783898741, 0.1189847365262573, 0.11592794250402971, 0.10858091143867621, 0.08173090466070976, 0.10684248306412614, 0.21202725858770033, 0.25235531775411457, 0.19706444913413124, 0.29844951930094044, 0.26142966129688094, 0.15922572480443797, 0.206538292261365, 0.21513562628294924, 0.19025486120586643, 0.22104361987413768, 0.22780058641678147, 0.2541319543805274, 0.24768743439759278, 0.2557351089161253, 0.21946273740355116, 0.23455874726527837, 0.2568523132390943, 0.2573532735973554, 0.18138123028704245, 0.20281771994409759, 0.1797916775646099, 0.1809057699188149, 0.2060520831320929, 0.18440371578014314, 0.19740519523000244, 0.2017186725486455, 0.17697077734432565, 0.20630166070993317, 0.2033493156696462, 0.17700839374802124, 0.1986843172605105, 0.20709652163792847, 0.1985806026056307, 0.21664400654069782, 0.17991816107926129, 0.1973002479151813, 0.2193339294895157, 0.2081011329035658, 0.19323677256923577, 0.19969043181720691, 0.24322367177980841, 0.212061790335061, 0.1941902761141494, 0.2157518601747367, 0.2047665016251452, 0.1675235906019742, 0.20608367371863234, 0.17100200906930474, 0.6062735513928914, 0.3388260367581415, 0.5405902026320041, 0.6392606673955772, 0.5466560623561321, 0.6435126812536142, 0.5570301032481499, 0.20648680109839113, 0.6193454069696664, 0.27809542591068837, 0.46557121142066205, 0.20474529324617963, 0.3688363617696171, 0.4236433695361166, 0.4604561692738173, 0.18414767492815554, 0.18178236839672668, 0.1719040977922618, 0.18212405454765557, 0.1919284956509132, 0.17802339988283877, 0.1898545108428269, 0.19352605633997355, 0.18705777357049325, 0.06698635617531146, 0.10170731046145798, 0.07679266868485013, 0.08218761648254369, 0.07965537565807623, 0.09167715205906402, 0.08912844638950579, 0.0694705328462234, 0.08312537818373456]}, "mutation_prompt": null}
{"id": "523dcbf5-ff54-4672-a7fd-f8821e1ee9d1", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.15\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.2, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.01)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def strategic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 10)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = strategic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm featuring dynamic mutation, crossover rates, and strategic local refinement based on fitness feedback.", "configspace": "", "generation": 70, "fitness": 0.23338675082784502, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.5232559206053378, 0.45349060912322836, 0.4906338465702219, 0.4866553549687349, 0.4815937119876389, 0.47567339387654284, 0.563313074539548, 0.510256346407921, 0.48054219744014237, 0.11182446716712091, 0.07931654729117432, 0.08631653363811498, 0.106904920142184, 0.0867805446319393, 0.08256918283510262, 0.10434952221832572, 0.09711144959199336, 0.09540043812262522, 0.10780973229458846, 0.14036367090537172, 0.11999954479454467, 0.12988408326670686, 0.12827745825339476, 0.12343264814131927, 0.12035750117841604, 0.11243721608590385, 0.10073023291055527, 0.13567335553813287, 0.09826157834135829, 0.09958031657923605, 0.09164507908723385, 0.10142626696203516, 0.10738014689231712, 0.11139370267321025, 0.11254740382896089, 0.07466438472097381, 0.7652248774226963, 0.8125319257265831, 0.7632733820058826, 0.6229760842862504, 0.7709823310528916, 0.8228619269559527, 0.7794433466832196, 0.8135707159229286, 0.7828535660142165, 0.2816443438948426, 0.25799887190941573, 0.2996550003198829, 0.34113784025201677, 0.3080114692431889, 0.32281999971229824, 0.3116383081800105, 0.2962144583499431, 0.2784020979786316, 0.5347731792701005, 0.2884262908124149, 0.29024083343488294, 0.5114536205737316, 0.41472153424511593, 0.47063037479282877, 0.3041421334478309, 0.4837081384960398, 0.4131838881263479, 0.259407523166565, 0.15055984470388717, 0.16006691873378476, 0.1606678832608628, 0.14067072030893524, 0.15292982824260926, 0.16244963809601254, 0.22627208471550408, 0.15680861686306402, 0.15376073766284304, 0.13616886731368305, 0.17401332016424276, 0.21688996925711523, 0.20652634523883584, 0.20321030565089204, 0.21529172993938606, 0.21612780961017375, 0.17868040156951626, 0.05835666410135032, 0.039622836166184006, 0.020433647357718798, 0.06514847382940714, 0.02802603670874637, 0.02949814232326642, 0.01966319573675701, 0.020568439046633635, 0.024567339882665018, 0.17157026045560086, 0.0970340137270681, 0.1288587160451352, 0.08457630342424582, 0.0725428361216629, 0.12715882813713908, 0.18325146115422075, 0.1139109930971165, 0.11576308851813633, 9.999999999998899e-05, 0.05226698630977922, 0.0031396549116933237, 0.008518739621592775, 0.008835157750028522, 9.999999999998899e-05, 0.014640214926336936, 0.017797835415407803, 0.0018124704860380536, 0.11367688973023793, 0.13688588586049377, 0.13137204238778655, 0.10087351300203895, 0.12449733815415542, 0.1300820105372401, 0.12497845653056905, 0.12290351691363999, 0.08107452963148554, 0.4202645508304679, 0.42080097339626354, 0.42623810937264894, 0.4418676646862397, 0.44213429367361834, 0.41518129775113544, 0.4508237304855075, 0.4002620745574569, 0.45904652118214173, 0.13354662916046978, 0.10356209619200563, 0.10804769272645498, 0.10732369871991887, 0.09417883290956885, 0.12241850943370425, 0.12769105294278904, 0.10638204589466294, 0.1011026602197036, 0.20050088108175645, 0.1746019507290334, 0.17696835565032776, 0.24621307272358162, 0.2737950335881113, 0.18153709517636296, 0.19609798826145908, 0.16626642931756774, 0.23937499633949655, 0.24118343019333166, 0.2418229498248885, 0.25411353364169287, 0.24151728695111452, 0.27121650376490747, 0.237826215415179, 0.24581352645804144, 0.25876034971230777, 0.24542597133939215, 0.19684095470105, 0.17240213848443908, 0.21829269175579336, 0.1919505456913182, 0.20993313939790081, 0.17380301895907868, 0.19066112248134914, 0.20725636406341996, 0.1731792468159823, 0.2139293633707342, 0.19256868123168924, 0.19367265488918994, 0.2160718597527832, 0.22197344060251745, 0.22928910489916532, 0.1939142780201223, 0.18400035273024373, 0.19278563063636345, 0.20022594597696874, 0.18245715064489254, 0.19448628953729152, 0.20375926552900914, 0.17700779448059234, 0.1829688513382356, 0.19798043235704332, 0.21166170033507992, 0.20531661645155452, 0.6105892226884061, 0.16482474824984406, 0.6259366182896728, 0.17389328822176708, 0.20066823727593486, 0.17147861737373638, 0.6688756784420682, 0.6531168591178123, 0.7870396243662523, 0.4335179498027042, 0.2073178857146093, 0.4321801497285721, 0.45368365687611745, 0.1974184091411868, 0.3746543180809191, 0.2629675115113227, 0.42535944016400695, 0.34168128178308577, 0.19065864238139296, 0.1737249981300827, 0.1682204907391942, 0.18981748845658586, 0.17173017888638364, 0.17588180519760666, 0.19869955134358064, 0.21656323684368273, 0.1798275404985199, 0.07513238544128775, 0.08137670988244994, 0.0766124539765135, 0.08387087685070782, 0.08718888006614745, 0.0818752303590562, 0.0902836149515922, 0.07857388801530141, 0.08501808530751609]}, "mutation_prompt": null}
{"id": "2d8531ba-c67c-4506-8f8f-a92ca65b29b9", "solution": "import numpy as np\n\nclass FeedbackDrivenDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7  # Adjusted adaptive mutation factor\n        self.success_rate = 0.2\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - b), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.02, self.success_rate - 0.03)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def enhanced_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.003  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(30):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.85:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = enhanced_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "FeedbackDrivenDE", "description": "A novel differential evolution algorithm with feedback-driven mutation control, enhanced local search, and dynamic population adjustment.", "configspace": "", "generation": 71, "fitness": 0.22212371955248, "feedback": "The algorithm FeedbackDrivenDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.4770186103018216, 0.49017611233187375, 0.5046754132655706, 0.48872475696800965, 0.4966376339640515, 0.4855291588653322, 0.5435747848995797, 0.47989240321226856, 0.4849477819772511, 0.08273288916194377, 0.0469979930045612, 0.07203531623727832, 0.044194681824801574, 0.058078869851988735, 0.05094390282758887, 0.06599591534540361, 0.04507793733964627, 0.06154727865483567, 0.10149697195676888, 0.10856552380866902, 0.11371650184376902, 0.14825045664220182, 0.12861016580154794, 0.11069431512991779, 0.10632187147583427, 0.12755196251858558, 0.12052488369618275, 0.08204787860895191, 0.13904824869927102, 0.08556019352712396, 0.08352344505529619, 0.096383914016402, 0.08113523350724539, 0.09183120542510592, 0.10443649277726963, 0.07601921091151564, 0.689290053052616, 0.7048921641044068, 0.6440168958447695, 0.692006300660444, 0.6077227183038687, 0.582433832371086, 0.6985396854521982, 0.820007093723557, 0.6587911553924515, 0.31723180478022295, 0.28328177010897904, 0.20399024229843876, 0.25786586517875887, 0.25452051289261524, 0.282370180805403, 0.29982070765261537, 0.3055459599673128, 0.3209564558712005, 0.2782644601546611, 0.27274796325106077, 0.26838763915095176, 0.25788007720597794, 0.2349244784866361, 0.2720112759616159, 0.28220565462828995, 0.2284410285901488, 0.2725572928701133, 0.2208209943472893, 0.20287434883184985, 0.13594050657219248, 0.13684841727961572, 0.15022973505190984, 0.13507544029167662, 0.23663127250942362, 0.19892138396464176, 0.15953155314292322, 0.20142787802681172, 0.33392739034849006, 0.16645664685205086, 0.22987580000683272, 0.2298362511232146, 0.1440425362048251, 0.17309481933782211, 0.18784907484953828, 0.1398150221894655, 0.04281013613564777, 0.03531514189844365, 0.009648683084641174, 0.03244526908620171, 0.07648972475652793, 0.0136802429379963, 0.014335941400246188, 0.017844370006221855, 0.02237960452748977, 0.1611556677152821, 0.08078567378480461, 0.12405591031064067, 0.11307810502541582, 0.09953082059654894, 0.10564565511230517, 0.1080903220882743, 0.10679439154937187, 0.11034314213585894, 0.029705818320008848, 0.014596235982743733, 0.03168547664619059, 0.022961732818986058, 0.014103494204351641, 0.048037398417926314, 0.020699805421171003, 0.03701427815325109, 0.009872077539405333, 0.12967845837839798, 0.10561607810081786, 0.13589569619079067, 0.1084048877049123, 0.13630320462086676, 0.14371979461337014, 0.14014228087945269, 0.1337735351701549, 0.12873087519969817, 0.43510807146567654, 0.4419597818297357, 0.4320337364431761, 0.43373484389739037, 0.3916948286858445, 0.4016135506979849, 0.4485924258490823, 0.40417262868566517, 0.46040575271807826, 0.09927304704875184, 0.09728150589217055, 0.13654106102129904, 0.11647336395591179, 0.0899300953060308, 0.1005903338485914, 0.1379857389772957, 0.10080389738174911, 0.1068986230581771, 0.2371327075223545, 0.38852072234836343, 0.20252510886562947, 0.2622969885867472, 0.21569614747573373, 0.17662646020216544, 0.2383328922846928, 0.1875522589563935, 0.15061045882976154, 0.22551179649062758, 0.2206717125219554, 0.2269805836784794, 0.21478808011654915, 0.2385815634554358, 0.24369557750844828, 0.21714152808718445, 0.23957835824788476, 0.2100472412935297, 0.1614051452623797, 0.1686269452635808, 0.19505810190006478, 0.17532945669403466, 0.18775011207651837, 0.17266673994182324, 0.17029196896661447, 0.20519980947238503, 0.1501992365784548, 0.19356271947676207, 0.19155328634245583, 0.19124084684521836, 0.20711879972698966, 0.2051444548288569, 0.18797579401826758, 0.20556606633199204, 0.18128524317172967, 0.18591653449716383, 0.18332275548617138, 0.17305921246043565, 0.2006378787098021, 0.22098270052514157, 0.20419427845928873, 0.18738495813576217, 0.1897015370167524, 0.1851969202359347, 0.21019035130671126, 0.4166147899887901, 0.3835790431100463, 0.6423870565197496, 0.1699786888664696, 0.6624820187307632, 0.7243261389396043, 0.18213348401813823, 0.5387590839168052, 0.7387847488938835, 0.47746752018745175, 0.20788190453477984, 0.5103361220542055, 0.42444471584395793, 0.3203220501239674, 0.2834874910981092, 0.23816115737233845, 0.33142209320398863, 0.22902646816049832, 0.1945543108570864, 0.19024121261019522, 0.2044820545699073, 0.2049263816680844, 0.19962714381099078, 0.22934649579767408, 0.2090794466928636, 0.22067081574935832, 0.19363166902864448, 0.07748488913426466, 0.08505315734922847, 0.08339178818633375, 0.07995680702915708, 0.06897265994006996, 0.07586491653128269, 0.08624829452429605, 0.0740259483796244, 0.07385334330638071]}, "mutation_prompt": null}
{"id": "5cc474eb-082e-405a-a2e2-8bf085410c20", "solution": "import numpy as np\n\nclass AdaptiveProbabilisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Slightly increased population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.75  # Slightly increased mutation factor\n        self.crossover_rate = 0.9  # Slightly increased crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.65  # Adjusted adaptive mutation factor\n        self.success_rate = 0.15  # Increased initial success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.12 * (d - b), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.05, self.success_rate - 0.02)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.003  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(30):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use Gaussian distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "AdaptiveProbabilisticDE", "description": "An adaptive differential evolution algorithm with probabilistic mutation, adaptive local search, and enhanced crossover strategies for robust optimization.", "configspace": "", "generation": 72, "fitness": 0.20549842468108018, "feedback": "The algorithm AdaptiveProbabilisticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.16.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.4748897489449144, 0.4886510210552659, 0.4658149859022376, 0.5020516742505587, 0.4958693332082966, 0.46777830561197276, 0.46973923450971955, 0.48247351944391925, 0.4726783898394822, 0.03979561811974286, 0.04088785595985589, 0.03710658822410462, 0.061695091369671884, 0.04533151010997716, 0.03928384460753964, 0.036165480943326056, 0.03879286416029559, 0.03773931719139234, 0.13219359681358633, 0.10682256885244801, 0.1312607470673116, 0.11535904960010723, 0.08794794481048063, 0.1092857580151736, 0.12190435285208545, 0.11387008937361132, 0.10473680273193053, 0.07839020266622976, 0.09386479783577473, 0.07960757458204393, 0.085990512613073, 0.10896608499607774, 0.106345981868045, 0.0851609222930465, 0.08670673051532518, 0.09643894042119516, 0.6667579348799852, 0.6195543406047817, 0.6726490146370592, 0.47359448015458583, 0.735396833035149, 0.6832266078148659, 0.5090103733511759, 0.6425267757996476, 0.7053764067677603, 0.23955034704926792, 0.24382865388481467, 0.22109668917268988, 0.2096712279361188, 0.2786844985429803, 0.2522824212484631, 0.2158658276275187, 0.16257941590078395, 0.2498114956864903, 0.2090769578575058, 0.214668413834452, 0.1703983101561264, 0.2125895677312416, 0.23329585934408614, 0.6149184933818936, 0.25038170371276436, 0.16576993433617393, 0.18609612272688714, 0.23261003782509926, 0.24092921301529846, 0.1145697749688156, 0.11889215170922085, 0.1146030448012223, 0.12758429130130966, 0.14852423033942375, 0.22849857084360636, 0.15170006535790703, 0.17265860437943414, 0.18160927240307911, 0.14481278819028243, 0.14283541689191714, 0.19723945015874633, 0.2251506079068778, 0.1689570005503439, 0.14866645269028467, 0.13062969260025492, 0.0028864215099770885, 0.0026649211634494074, 0.013893759691428254, 0.0234269877020139, 0.01421843181260718, 0.01878985981611836, 0.016533066781584616, 0.032882543163244016, 0.05109878372442178, 0.08768674287939227, 0.12839104048534833, 0.09678579245565455, 0.08177278080234429, 0.11414842633103872, 0.07828563509218567, 0.10164414203989514, 0.1583027493808058, 0.09701385452250177, 0.030508569370101934, 0.05735796702739737, 0.0325765559830814, 0.01445696193895818, 0.03950068705827636, 0.033842823066682626, 0.011816888439557305, 0.03629048852210093, 0.03632985879057249, 0.11767071721270272, 0.11530372648298837, 0.12039253979069275, 0.11459192641727078, 0.10087566439383722, 0.1330278248058634, 0.10634174796478879, 0.13370036995425705, 0.10958163614627814, 0.3892550896909218, 0.4182611410219951, 0.40400091255835013, 0.36025816716921844, 0.4004046454557981, 0.39239169997502454, 0.42200448922748524, 0.3747551625266963, 0.4416378673313047, 0.0967260799967875, 0.10022649115756399, 0.10849543904187342, 0.10817758084909002, 0.0979834169911794, 0.16088198625157968, 0.12032506986156988, 0.11326450320531711, 0.10710060024138857, 0.16155064741902192, 0.15521197681089904, 0.22285269934707663, 0.343776694570314, 0.1910394292989549, 0.1942633247688833, 0.1921332568965749, 0.18830008814210186, 0.20711769707288363, 0.20411411789986345, 0.19504588041960658, 0.2117283860131507, 0.20809151324371966, 0.19843149959309792, 0.21004708314169496, 0.22727658550744456, 0.23171241080312732, 0.21021057127553966, 0.14753980174665338, 0.14814238476303687, 0.16412424589536623, 0.16973999296870368, 0.13957899299984833, 0.16591762301829382, 0.1477789016106763, 0.20121348158740304, 0.15262216282902608, 0.19490825600996609, 0.1683358009511754, 0.18585217656703568, 0.22024963931917063, 0.18869874252345065, 0.23238301389788452, 0.19714252147595757, 0.19741013277694897, 0.17800058423234533, 0.18734961594212396, 0.1970457849685998, 0.2012942812720404, 0.19759071078507362, 0.19941868781283179, 0.20842759773627995, 0.1654335791889161, 0.2027713180476156, 0.21551191193207064, 0.1729745624080108, 0.6986507925423604, 0.5335760573270929, 0.4338900288741848, 0.19790679791652988, 0.48782604227655857, 0.15767229611708067, 0.47758844433004743, 0.19469137621740107, 0.5084407943203926, 0.4639341047590211, 0.27871886868975393, 0.1893823625868557, 0.45652893076870915, 0.2593515388780546, 0.19479927179115597, 0.40427082529261904, 0.3734306899328198, 0.19605898258632204, 0.22221456818890795, 0.20065541448842372, 0.19166493883709712, 0.19610795737484388, 0.1978615989372472, 0.1912247510171643, 0.20766584825281775, 0.20720226284503018, 0.08289791894613063, 0.08149585775719537, 0.08336940179335284, 0.08618539161755834, 0.06998715638562969, 0.08229044829056853, 0.08144529091969177, 0.07450729940443435, 0.07233540361903268]}, "mutation_prompt": null}
{"id": "85ca14b6-4033-4d6a-8861-44fe54328446", "solution": "import numpy as np\n\nclass EnhancedHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Slightly larger population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Increased mutation factor for more exploration\n        self.crossover_rate = 0.9  # Increased crossover rate for better gene mixing\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Decreased adaptive mutation factor range\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.1, self.adaptive_mutation_factor)  # Narrower range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.15 * (d - b), *self.bounds)  # Increased contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.025)  # Slightly larger increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.015)  # Smaller decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def stochastic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005  # Increased step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Fewer iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Switched to normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Longer exploration phase\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)  # More best individuals for local search\n                for i in range(min(best_count, len(population))):\n                    population[i] = stochastic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedHybridDE", "description": "A novel Differential Evolution hybrid with enhanced adaptive strategies and stochastic local search integration.", "configspace": "", "generation": 73, "fitness": 0.22354549418231484, "feedback": "The algorithm EnhancedHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.4857847843254697, 0.5033219605091885, 0.44999393977082514, 0.528193841270393, 0.5171603319160536, 0.47040688118987406, 0.4771430959397711, 0.5145243209206126, 0.4604459801199505, 0.07035117897992005, 0.09943034136043238, 0.07524493242621233, 0.04938646765050103, 0.1002811417000028, 0.03692110781458491, 0.09252556433352366, 0.08575138577249686, 0.06416747863302352, 0.1468471041021605, 0.08858358122871435, 0.10864860482843541, 0.1235320783422329, 0.09739444385449547, 0.10990578289577912, 0.10284237043131284, 0.12096429996525127, 0.09874498991258318, 0.10590054493499956, 0.10321067323815747, 0.08899903933977527, 0.08321352235066404, 0.09326943167501756, 0.0882977090358047, 0.0983059030926372, 0.08981579096387937, 0.08046069619699303, 0.6789138218110911, 0.5208529191624276, 0.7436775815349779, 0.6945721853480333, 0.7357646498758139, 0.6078453610798874, 0.7001168970204371, 0.6858403743149188, 0.7130835824267143, 0.26638112584955886, 0.25014940080247583, 0.25547282185577647, 0.22922937765522544, 0.25787567943341005, 0.2365588836696756, 0.20422419581146434, 0.23672362127689184, 0.28235515556091073, 0.3270556127405332, 0.5293189576430939, 0.25014389120096125, 0.4118083935853861, 0.6494441870878755, 0.5382675560158139, 0.22947133035861667, 0.27243402188909394, 0.39109338022808837, 0.20726140754491096, 0.1539892296097911, 0.13330795514441762, 0.16808598872211955, 0.15136018321391453, 0.12985947687958865, 0.24194762792380597, 0.14137456532881365, 0.14723230091141215, 0.2224876429527196, 0.1374625949789946, 0.14148278475531073, 0.17672975825792037, 0.11524302462781799, 0.14373961300578653, 0.18353689991649902, 0.17724891390479258, 0.12305773009663701, 0.038874925947718464, 9.999999999998899e-05, 0.025447968963025258, 0.049985449160630746, 0.04895277269942311, 0.025379241621034998, 0.06868271657799918, 0.024414874508622786, 0.06672849794504343, 0.15624930845507334, 0.16301360388097041, 0.16153135907368377, 0.11109304047850421, 0.10833268615118108, 0.10608584081569483, 0.17974186384186164, 0.137965023626049, 0.09745355053368965, 0.008699832238363903, 0.016128818469725914, 0.009994781766009542, 0.01739722352602935, 0.01472922106154606, 0.004809349165012078, 0.0027442986153347615, 0.024049126119963682, 0.028436489064846304, 0.11722533142674507, 0.09745385670362028, 0.12206818720158374, 0.11255369392463654, 0.12007732708630481, 0.1415427762287409, 0.11169581483511448, 0.1405739504718595, 0.11417178922060578, 0.4146228311124628, 0.41393185022844536, 0.4214528658872554, 0.42261426473788977, 0.42313367751883557, 0.40755091125425313, 0.4563986397479721, 0.4061957628090236, 0.4155960635540865, 0.10394375153724955, 0.10344741073629338, 0.09063701777937405, 0.12583323129735458, 0.08794736151135585, 0.11684576273101299, 0.09464747970900189, 0.0926784952777654, 0.130399972828789, 0.23939633938169413, 0.26864076478007026, 0.19575853565481904, 0.2741730655252961, 0.22292659047404362, 0.17807085083078233, 0.23270635547035023, 0.15440116135598492, 0.2562172047237604, 0.232545177459215, 0.24332282796899618, 0.26392841937539335, 0.2425889670244331, 0.24754862168507163, 0.23868248053468744, 0.2548127226950624, 0.2673215000293744, 0.19970025906896938, 0.2011703733761665, 0.18123495931648304, 0.17873757865596784, 0.1933858005711142, 0.18064248583927056, 0.17482128547151532, 0.18557009170454153, 0.21177053516198563, 0.17694935466893602, 0.18378787806419772, 0.17286440326605257, 0.21399100745505006, 0.20034271694565564, 0.1821583653630625, 0.21067234502301913, 0.18833613025270202, 0.1831195261085422, 0.2093699825061912, 0.18649709649982205, 0.17869647014757062, 0.19467487055648858, 0.21963440402205137, 0.2081812562869897, 0.19106983556746926, 0.19067708038970121, 0.19404074773519608, 0.18624020271248165, 0.6229972087441547, 0.18425943798619504, 0.6732349203230521, 0.6418052396045681, 0.23934394719925456, 0.6520703165493408, 0.5027320955815191, 0.17030773883826733, 0.2575007620481963, 0.5095588021334296, 0.47686828510062484, 0.3550092319947261, 0.2003468588293873, 0.2575703078726277, 0.43465657726400064, 0.16406061096970403, 0.47474347744067347, 0.4360763554319146, 0.1840771846618442, 0.181883658551657, 0.19154278708509886, 0.17641336149769127, 0.22074267386728175, 0.1887431542157305, 0.18112149910435393, 0.1961810557429724, 0.1928318529854619, 0.06656041764318577, 0.09447491602995084, 0.06950089387125813, 0.08413289200873075, 0.08033067640868252, 0.071098548997923, 0.09230101168356963, 0.08437741503110119, 0.07867603667484002]}, "mutation_prompt": null}
{"id": "4e07933e-0f95-4dac-a64b-3c0b328407ed", "solution": "import numpy as np\n\nclass EnhancedProbabilisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 15 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.2  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.1, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.15 * (d - b), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Adjust iterations\n                perturbation = np.random.laplace(0, step_size, self.dim)  # Use Laplace distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 10)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedProbabilisticDE", "description": "A probabilistic mutation-driven differential evolution with dynamic local search and adaptive control.", "configspace": "", "generation": 74, "fitness": 0.21577371754550753, "feedback": "The algorithm EnhancedProbabilisticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.16.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.47371786402189775, 0.4672011130450462, 0.4601421011553509, 0.461307569154644, 0.4602094088874197, 0.45034165677512816, 0.462434722024584, 0.43389684698889786, 0.438691003130701, 0.0414309149417077, 0.057520077382044454, 0.06148686217649724, 0.02537101277219389, 0.0689325142252406, 0.07603965211311858, 0.058797238612950276, 0.07470428713099353, 0.02346760864619113, 0.09941904466723495, 0.08625373475454778, 0.11448882877948985, 0.08883773694096708, 0.08095459215777046, 0.10051145781826121, 0.1421219513262496, 0.11750505794903399, 0.10129241947684442, 0.08289416062778021, 0.09554730505657116, 0.06941305727198688, 0.09173722465367462, 0.08837897219781843, 0.0956604279350598, 0.10132324622244682, 0.1071574519801215, 0.07441632320135882, 0.543071691032055, 0.7964651519388399, 0.6825422009134785, 0.6853304653639436, 0.7952386184553608, 0.6701468935957148, 0.7124345703684216, 0.6499873149014139, 0.6185199837613049, 0.2522846107507639, 0.2506373509484824, 0.21874882356724068, 0.26353330816992826, 0.25733765956426147, 0.2653150351467465, 0.2522918384849222, 0.23292093991547813, 0.28178427095096426, 0.28587084695246956, 0.28513604468730436, 0.3792039928151669, 0.2755679257235645, 0.2742258578633736, 0.2253790894034401, 0.25866000769110087, 0.3103176975710794, 0.21346774432804105, 0.19738255501755642, 0.14928876260832236, 0.1390632363588069, 0.18086557160577, 0.18364864814550663, 0.22750087665544572, 0.21690812697128947, 0.20887127180395015, 0.1585072226108285, 0.1628893532955148, 0.13313512742920086, 0.2019193521484448, 0.22167064257620472, 0.16680815261653037, 0.26658539799473824, 0.15682103687291327, 0.14533990836928712, 0.1492186612244253, 0.032719687912074136, 0.030811555575869898, 0.006052608896458644, 0.0658904884873267, 0.028207200456403014, 0.014864807327589213, 0.027236295396521726, 0.012130098603670758, 0.036738758861803555, 0.12372004987694996, 0.11174701945395904, 0.12409779705112434, 0.09001706957246536, 0.10882348457371804, 0.09055013978906923, 0.16799487477329145, 0.14595458836026864, 0.09099260573200718, 0.0004007376247389116, 0.004037543169359559, 0.0008187023562818974, 0.00024339550001295507, 0.0058181821001924705, 0.006316366127390616, 0.004426993371184129, 9.999999999998899e-05, 0.01196763987810845, 0.1245648907650555, 0.08209512199965574, 0.11057964344469073, 0.12704666644841323, 0.1225385186530511, 0.13867421240239508, 0.11539601348522355, 0.12567088369862633, 0.11029153936416547, 0.4387279971034508, 0.3873770586358891, 0.43567664895733815, 0.3962109686755202, 0.3864536550919644, 0.4120486399040587, 0.4167085000802354, 0.3977745430690387, 0.37793492884089297, 0.15191214091318994, 0.1009320859645435, 0.09449534712652441, 0.10246377863075873, 0.08917545361277712, 0.11744087709947149, 0.10072338217865218, 0.0808247983391489, 0.12130810917862367, 0.20514082838989567, 0.21109109961693373, 0.20748154446924294, 0.20664472987222027, 0.22553536566325982, 0.21022819490217437, 0.24804523641519427, 0.1614607498606303, 0.26471581107260267, 0.19478496647148957, 0.21537800205335422, 0.24002404624772378, 0.2795360957772932, 0.21550589619044447, 0.24190917301928672, 0.24142142519998389, 0.22996605124843905, 0.21959572501886904, 0.1581840311259397, 0.17449966382947402, 0.19939419436928962, 0.18257853216390962, 0.17758007490857963, 0.17469754632583845, 0.16401499324005542, 0.19503759280840405, 0.20271568505647752, 0.18411731741824022, 0.1850494827307595, 0.19623624630000724, 0.22071677484293517, 0.1966092472010732, 0.19840017495089923, 0.2282462403859753, 0.1800106710313083, 0.20457542066307588, 0.21311653049943768, 0.19736992648299378, 0.1983670494457761, 0.191545133606572, 0.19840659037246466, 0.1788427043690033, 0.1909348618720399, 0.18557116933037765, 0.19416275138331884, 0.44093842472631406, 0.18376189848285696, 0.61942616894747, 0.19443541717604995, 0.46822561822183584, 0.6382733301879316, 0.39179448875497647, 0.6445044473919156, 0.5918538079682907, 0.4122943890064147, 0.43136340848820554, 0.45248257661110713, 0.3719331475492682, 0.4016562703411659, 0.1914276865035851, 0.31585049050719105, 0.39027356173594674, 0.3806656268885821, 0.18477376033408432, 0.16495225319704254, 0.17821446775780736, 0.17228369499378315, 0.18717556020200354, 0.18389941481400252, 0.1917071958710358, 0.19264367867887577, 0.17811306841214314, 0.08060476926235915, 0.07051682257337866, 0.06824388370383727, 0.08135980803091747, 0.07257261944706084, 0.07158668708961746, 0.09207340475878811, 0.08804425921300296, 0.0935769539348974]}, "mutation_prompt": null}
{"id": "2f9fede6-a464-401e-92b7-3ed77a820245", "solution": "import numpy as np\n\nclass EnhancedProbabilisticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.2, 0.5)  # Adjusted range for exploration\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) - 0.1 * (d - a), *self.bounds)  # Hybrid mutation strategy\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Slightly increased success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Slightly decreased success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005  # Small increased step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(30):  # Increased iterations for local search\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use Normal distribution instead of Laplace\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjusted exploration phase to emphasize exploration\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 10)  # Increased number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedProbabilisticDE", "description": "An adaptive differential evolution algorithm with hybrid mutation strategy and dynamic local search control for robust optimization.", "configspace": "", "generation": 75, "fitness": 0.21506559391287883, "feedback": "The algorithm EnhancedProbabilisticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.48554846412789054, 0.4725713320569983, 0.4909446796100524, 0.4756228305948129, 0.48767419588300764, 0.4872391070854626, 0.49104806580734917, 0.5152683264787898, 0.5042689916941823, 0.07969625249002876, 0.03755349107440853, 0.036214824048431016, 0.09186615397290099, 0.05345925520887018, 0.05314667830883646, 0.05745479860187319, 0.054809758134583886, 0.11105244692017735, 0.08409238571709288, 0.09480694493934227, 0.08681321398472974, 0.1238528484401561, 0.10669843033183446, 0.11219408622132432, 0.09168450750889079, 0.12341337553056364, 0.11094455304704187, 0.0881898944615066, 0.10744551887638898, 0.10086350725138216, 0.08729669440197052, 0.0813874896826654, 0.07925362483717313, 0.08693608015815935, 0.07238638193287739, 0.06252215243954362, 0.7575267567125714, 0.9162426602702156, 0.7761289720268103, 0.7842276463594028, 0.9182688857298602, 0.7635703058360137, 0.7848067384491806, 0.8247414892752607, 0.8102020511911643, 0.3097068938265446, 0.31502393130587125, 0.3014034259529905, 0.2812399765798539, 0.2924422490021672, 0.25864278497665505, 0.321869720810403, 0.29398445076369983, 0.30331503805915394, 0.1758644266918633, 0.5977690306454821, 0.33508708277328647, 0.2985668910743001, 0.2844680086594228, 0.2912580057773605, 0.3502710378094248, 0.17676060931287152, 0.31132025395426777, 0.24310334968252723, 0.14257346756655298, 0.2381708942808629, 0.13608475422550326, 0.13707858285609942, 0.14526116213966267, 0.17313059481448623, 0.24764611913260826, 0.1921954662804496, 0.1456472749525909, 0.1514327614578529, 0.19483694968359366, 0.2114887379717607, 0.15138804682718143, 0.19050231698759912, 0.17934372831059697, 0.14728403389441336, 0.2882051580684698, 0.03978017893073971, 0.007133651900838589, 0.07986772648001406, 0.054051100302210164, 0.017242214449013082, 0.014695550996054796, 0.08674537840127705, 0.0055839543446760675, 0.010311606531827944, 0.11249686240452028, 0.08085370799049019, 0.11124765924456992, 0.07318993515624583, 0.0707792147923848, 0.06716488702562762, 0.1424246567449221, 0.07778801726394735, 0.1047425924937746, 9.999999999998899e-05, 0.00020478943097335112, 9.999999999998899e-05, 0.005147420238588496, 9.999999999998899e-05, 9.999999999998899e-05, 0.008127288689809942, 0.0017781396644351855, 0.027926386711450868, 0.13364233770853373, 0.13021691812402258, 0.13027481080634407, 0.14981315663186867, 0.11116674711426877, 0.13547890734781542, 0.13432834237506575, 0.12747839463062205, 0.13184213874878425, 0.4218258618845574, 0.4515906256950427, 0.45261748166440496, 0.4151587598314337, 0.43426427990565974, 0.4124463505982111, 0.44742665644921253, 0.43760318267133047, 0.4291102589103162, 0.09989736283886219, 0.11270934806819655, 0.09251280588134958, 0.09189322005800493, 0.10113486177076214, 0.12645685817913654, 0.09179962297075706, 0.0934503625143065, 0.08922010828760374, 0.18607493671400044, 0.21364162122936348, 0.2373419642916037, 0.29952470984199153, 0.20268751848662392, 0.13968154920146858, 0.17709228578766412, 0.1484831273555559, 0.2966136179135126, 0.22949809335204496, 0.21457556372540298, 0.22461532058050548, 0.21816351249509314, 0.21254340501981317, 0.2012290375600907, 0.2180940204696442, 0.22530043757078877, 0.21460155062017838, 0.17497227337986188, 0.14583801383926132, 0.17371602361426142, 0.16489385272127988, 0.15887229912005352, 0.15600139787880218, 0.17556947696875846, 0.19909776416851277, 0.1552021586691802, 0.19887947205586298, 0.16688728573854206, 0.18506313667630814, 0.19602650854974102, 0.1778909300154623, 0.21104233052355237, 0.19132079530658608, 0.18430578747258253, 0.21189456626230607, 0.21662702005350631, 0.1796932417888223, 0.20999763796692794, 0.190857367625752, 0.18632714873224565, 0.19033208863013906, 0.1769978822374786, 0.1953012912681823, 0.16938807597229077, 0.18706439675499364, 0.18686043862134394, 0.6819978240970481, 0.17002072570091264, 0.2005416498612671, 0.1959888081703538, 0.16587878151948932, 0.17541365918273222, 0.7662092657928647, 0.43298017503041275, 0.208678805914715, 0.3423096243388192, 0.24830721290412316, 0.2061015616744497, 0.20115515357541813, 0.25513942813953416, 0.3951139398272576, 0.23785148680061285, 0.1970443660739214, 0.1783584256806383, 0.19972147052431877, 0.17712453698485076, 0.17817801808103162, 0.19993314883641367, 0.17263871881334603, 0.18099611149942463, 0.17502336059180612, 0.07334711085829493, 0.06877004923987984, 0.0806546714866736, 0.09554838262192389, 0.079299807970726, 0.08750601653137857, 0.08306079238536201, 0.06766216895917476, 0.07758334400963451]}, "mutation_prompt": null}
{"id": "391dbd09-53f9-4ec8-b74d-64993d97afd9", "solution": "import numpy as np\n\nclass RobustMultiStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.15  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.15 * (d - b), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def stochastic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(30):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use Normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 10)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = stochastic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RobustMultiStrategyDE", "description": "A robust multi-strategy optimization algorithm blending adaptive differential evolution with stochastic local search and selection pressure adjustments.", "configspace": "", "generation": 76, "fitness": 0.21465780960195596, "feedback": "The algorithm RobustMultiStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.46722991477921694, 0.4721335338752123, 0.44333111752949217, 0.49402295949891506, 0.4738232111691406, 0.45233292452167273, 0.4708450982356279, 0.46642815061353415, 0.4595812852041006, 0.039715812871213396, 0.044801309262394895, 0.049667752791204056, 0.05523271920956008, 0.046965701112062, 0.06852406040938219, 0.05056135195563494, 0.03712823395446918, 0.04990246827921441, 0.0929151665719048, 0.1181059660210656, 0.11752866562420983, 0.09479937094047364, 0.11432462584413283, 0.09542022467116273, 0.10356359850248553, 0.10917957326409344, 0.10006798624951152, 0.09598493258029062, 0.07647480607722024, 0.07476425615832527, 0.08824869706668181, 0.08117126769311656, 0.07949533171678702, 0.08899601230011578, 0.08739186936319399, 0.07030217205604716, 0.6071613125748437, 0.6506642591946912, 0.6460922123292057, 0.3291137044876049, 0.7221133324509261, 0.6775486965899451, 0.6515065555600388, 0.749848911436794, 0.5803909124061524, 0.276646678315138, 0.27607014352273496, 0.3124106340713855, 0.2744708129390929, 0.2768159456263647, 0.2977140337284131, 0.2859328317008888, 0.24949122779141775, 0.3230972763249611, 0.3594205979220787, 0.4467239440983113, 0.24135719397681565, 0.807781097511435, 0.4143797840608807, 0.26004146810662665, 0.20574800000762372, 0.26552224909229794, 0.27046867623226534, 0.20691859592806094, 0.23226315023102606, 0.13667577838182843, 0.14169094750963596, 0.2032504932159802, 0.15799355150858685, 0.16535732327318364, 0.20439047861818693, 0.16125306109558002, 0.1955895799685553, 0.16631323928564257, 0.16294137235455453, 0.1386496203392984, 0.15357581506152385, 0.21196751346276632, 0.16698359385687378, 0.14556012280150643, 0.1426239003508023, 0.030914515766008677, 0.039340953572375326, 0.016945789026250768, 0.05041193942675781, 0.015584836368007782, 0.010892867346402602, 0.00989352540297328, 0.030283370983055335, 0.0345912667331808, 0.10605587347272727, 0.1133217923115899, 0.11581889661273859, 0.09023165967885083, 0.1024263965851856, 0.11863380958622327, 0.13474194968481024, 0.14081136824815732, 0.11172252173698671, 0.006855784472662663, 9.999999999998899e-05, 9.999999999998899e-05, 0.016665030829024152, 0.007961096094630138, 0.0019509112697322362, 9.999999999998899e-05, 0.007807362202011392, 9.999999999998899e-05, 0.12240448624691158, 0.1034567448111311, 0.13063267972398263, 0.11011505408289235, 0.10309175238328117, 0.11599910019620618, 0.11413872047001838, 0.12911095723569632, 0.1103227059457007, 0.4301493934308138, 0.4180073402968395, 0.4374785825304369, 0.3969170837876229, 0.3921351313458251, 0.4237855231312234, 0.45245163398802635, 0.4066435753430655, 0.4402323688337968, 0.10171709466905665, 0.09019226143119974, 0.10896716661557926, 0.11423054818930178, 0.1009716073044381, 0.1547884641435685, 0.13049930485264616, 0.10476414729460759, 0.10049556729401898, 0.1790150444366878, 0.19124765988388048, 0.20128417418342792, 0.3156772826351214, 0.21935332402328545, 0.20883261020965127, 0.2410538414027732, 0.18677834476458544, 0.19033793635846774, 0.22964343338536908, 0.26592885466298866, 0.24989828908065137, 0.23442635586000338, 0.21837421317952732, 0.25898181243080465, 0.24045978807897117, 0.25339826118209596, 0.23747198788498514, 0.1864677740401609, 0.1577758141900234, 0.20292075083668637, 0.18762418715582718, 0.18192618513017356, 0.18902056781038679, 0.16996221793767907, 0.17510753768664966, 0.18884200545376795, 0.17586717375858685, 0.18513626487066437, 0.18678108469080112, 0.18551564676087628, 0.2124337965719698, 0.20597636462206315, 0.2368382418478332, 0.1914180792397817, 0.1827612281096429, 0.2187908977928974, 0.21386739145732991, 0.2032428360339038, 0.1891978194430306, 0.19406278582199532, 0.18895473262269913, 0.18566305529969584, 0.17675494139676973, 0.21294677447225707, 0.16291000250119414, 0.6672009631191655, 0.20982580349624502, 0.7245669185845617, 0.6913320397094611, 0.19319554262739969, 0.6376109263712525, 0.17440476157809404, 0.2076186805894552, 0.45034653499009003, 0.4241290812223206, 0.20250977240777956, 0.20033210447248317, 0.2685512770565667, 0.3002056320734816, 0.25554220456566457, 0.46919343861154983, 0.4371859323480194, 0.17710162545359032, 0.17981327973242112, 0.17696219293605697, 0.20543674944046586, 0.16405822779544688, 0.18537296362730782, 0.18630926539355264, 0.1885662068195999, 0.19294292022919002, 0.09156240775884639, 0.06959015692440629, 0.07475079603033574, 0.07196641193755327, 0.07169832655915775, 0.07244922670636367, 0.06635274313428585, 0.0864219475318263, 0.07859517072624023]}, "mutation_prompt": null}
{"id": "d74f69cc-92e5-4d8b-8947-56542a543b77", "solution": "import numpy as np\n\nclass ChaoticHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Adjusted mutation factor\n        self.crossover_rate = 0.9   # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7  # Adjusted adaptive mutation factor\n        self.success_rate = 0.1\n\n    def __call__(self, func):\n        def chaotic_map():\n            return 0.7 * np.random.rand() - 0.5  # Simple chaotic map\n\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = chaotic_map()  # Chaotic mutation factor\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.05 * (d - b), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.02)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def adaptive_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.006  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(30):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use Gaussian distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 10)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = adaptive_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "ChaoticHybridDE", "description": "A hybrid evolutionary algorithm combining differential evolution with chaotic map-based exploration and adaptive local search to enhance convergence and diversity.", "configspace": "", "generation": 77, "fitness": 0.225619971957889, "feedback": "The algorithm ChaoticHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.17.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.5106906640606423, 0.5827962352238043, 0.5155830222655728, 0.5051721613763593, 0.5544516461775189, 0.5113694127969766, 0.5305550521341811, 0.571170828988459, 0.5082080961483386, 0.09357103532466449, 0.10655328824970434, 0.060040777897332864, 0.07257893938414894, 0.1098556353869592, 0.10265711704374303, 0.07669539762548316, 0.07109443335275223, 0.10326395537360966, 0.1155327140959378, 0.08967696412865966, 0.09310726684377768, 0.10383030035114948, 0.10261129366989863, 0.12054618027872654, 0.11551452117448247, 0.12385126909002242, 0.11610870793194428, 0.10541150460838522, 0.07769647366992105, 0.08738795576773772, 0.10692199980729677, 0.080662945779441, 0.08806808721546389, 0.0827454431880944, 0.09177509855312305, 0.09226724876772241, 0.6671057294084679, 0.6500619908172292, 0.674261652002375, 0.6103673730325322, 0.5725214598152788, 0.6727094911062379, 0.6997272015784148, 0.7792938170733825, 0.8562284564895639, 0.32490952439606535, 0.2815822791157132, 0.24448925867461768, 0.2655053806300869, 0.29090767643744975, 0.31731590601699733, 0.3547815854020865, 0.2832914917163978, 0.30907427394949105, 0.33060350185012033, 0.5729682818970607, 0.37825823328677066, 0.40270110995894726, 0.6551096713470734, 0.2053580569168877, 0.22251184108968902, 0.19522415147905514, 0.20935369497061485, 0.2288101473698667, 0.16690722826705073, 0.13827910194434911, 0.150135603648773, 0.16537237721589348, 0.17481017813329291, 0.1832678367892191, 0.2390379647654095, 0.17144113550472995, 0.1734365560952954, 0.12040067215006889, 0.17336031335520696, 0.15872865297173688, 0.19839321296339352, 0.2020624803955241, 0.1812309752979142, 0.24456454536404504, 0.22660652242772772, 0.058896972742418674, 0.05525721760230884, 0.0201582694203577, 0.03712750754549832, 9.999999999998899e-05, 0.028801535558215408, 0.019311467125137094, 0.032215202305502455, 0.09605846367486026, 0.07771881959737315, 0.10894214949073378, 0.11661423308678098, 0.11063764051651304, 0.10991954501324741, 0.04690292243886174, 0.15708799538995333, 0.129879981203588, 0.1186118842688163, 0.01597223341419396, 0.044135055922314814, 0.030888973783406604, 0.012408308794560119, 0.008569630921879234, 0.0032655119090592155, 0.00505651891855563, 0.011395644042137443, 0.04104191844305083, 0.13767604687063872, 0.10927909580151318, 0.16664485417513675, 0.1268501755046606, 0.125141396507653, 0.1606420424412951, 0.1475599815203522, 0.15185788557117907, 0.09528340009231673, 0.4388453701807058, 0.4687627963690222, 0.44553987137010376, 0.43598034372255656, 0.42890289977787976, 0.43041845895636666, 0.47310872519364777, 0.38933607278303817, 0.43748024047591216, 0.11178794912515355, 0.09723998635314979, 0.0829165513963318, 0.11404701654855709, 0.10719637580440922, 0.12735174099751279, 0.08743812548384489, 0.09237035901235846, 0.11696729370790959, 0.19403481144124812, 0.19766257932288978, 0.3024291854143146, 0.26837204550239135, 0.29812672798015516, 0.27596730235734523, 0.20676236999143383, 0.17961014441366863, 0.1840563398928986, 0.25669933489276253, 0.237012002814191, 0.22791257980851498, 0.24927409141829582, 0.20528907819244202, 0.23281568942818998, 0.21130095776585534, 0.2530686686942627, 0.253639156484732, 0.19501050966910272, 0.19031231962899087, 0.19299418224825526, 0.21248384499054118, 0.18175474292955707, 0.1774201888890391, 0.1659906560966785, 0.25362001170311876, 0.23355709173985428, 0.19038494447633736, 0.17786743643054015, 0.20749314203359615, 0.21207914434469544, 0.18794361289011863, 0.1899789348108719, 0.18599388324370358, 0.18423596480853188, 0.21643878819612794, 0.2002511095996894, 0.18230597968389273, 0.20083501107474822, 0.23137737838578476, 0.16837417478704286, 0.21459352767164253, 0.21630155019160224, 0.1913315397622639, 0.19878801852805272, 0.20603271625297204, 0.18141795068195266, 0.7139875382587093, 0.5481330484057448, 0.5662825000977648, 0.43599852158473673, 0.16594284396491998, 0.19808851318566245, 0.21172659303724906, 0.4558608095056331, 0.5073119213985213, 0.31934381745993445, 0.20279615171970344, 0.49865805215539527, 0.32869337060329673, 0.2037051299019309, 0.3798333228021421, 0.37552390909169475, 0.17940721865069387, 0.17546901398398518, 0.20003026884953656, 0.1816702926520244, 0.1834489395967548, 0.18706556350232972, 0.18325306896006344, 0.19014000731407044, 0.17224153207944914, 0.07960644057996491, 0.07558227954440022, 0.07319647120997108, 0.07277423670088212, 0.0759771820511691, 0.07290823622229947, 0.07239637492758633, 0.07414073650761888, 0.08482568711061611]}, "mutation_prompt": null}
{"id": "3b7ab37e-7ffb-4818-9469-add188a4af06", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 12 * dim  # Increased population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.8  # Adjusted adaptive mutation factor\n        self.success_rate = 0.15\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 4, replace=False)\n                a, b, c = population[indices[0]], population[indices[1]], population[indices[2]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.05, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def stochastic_hill_climbing(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use Gaussian distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                top_count = max(4, self.population_size // 10)  # Adjust number of top individuals\n                for i in range(min(top_count, len(population))):\n                    population[i] = stochastic_hill_climbing(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridAdaptiveDE", "description": "A hybrid differential evolution algorithm with adaptive mutation, stochastic hill climbing, and dynamic multi-phase search.", "configspace": "", "generation": 78, "fitness": 0.21150055986530103, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.45568600870317555, 0.42750931705529904, 0.4555385136179204, 0.46307905362329715, 0.42382255945134195, 0.436017199242, 0.4417384651621633, 0.47625447553811695, 0.4480711434329745, 0.04237492639667284, 0.050387265425645644, 0.05242620835285583, 0.03496923884350234, 0.03381560304317155, 0.052410851517817214, 0.03486862074506081, 0.030786051982024776, 0.03238883023918315, 0.09835869041262946, 0.08160552530873955, 0.12442371346739856, 0.09457199566945562, 0.09744636498271664, 0.0941182214593893, 0.10516839217087304, 0.12177130574752304, 0.11521255942558806, 0.11446545821375165, 0.07550293514690765, 0.0977436035144208, 0.07778456000437306, 0.07411404861023496, 0.08623212467312691, 0.10345598555002666, 0.11102490437311463, 0.07503917101779134, 0.7761202854190017, 0.6237482872181078, 0.7493830123920786, 0.7478224061990739, 0.7057893118741441, 0.7277004782246572, 0.7275086933511082, 0.7877619771966325, 0.7182825192734837, 0.25784426266799587, 0.21657514804908062, 0.25622141072634064, 0.2272403428939046, 0.2450912546559071, 0.23825906693467747, 0.22186706219517416, 0.23652623709177156, 0.29128774960384496, 0.24530719714141347, 0.19189466228460983, 0.2282053742314557, 0.4465336132650244, 0.2595572895936701, 0.24216637938000263, 0.17497057508194302, 0.3344636832044824, 0.18808522530085015, 0.2319698766283239, 0.13355259859422786, 0.16799133436638736, 0.1793128188091534, 0.16025830317376677, 0.1742857905284485, 0.14131224564829337, 0.18332396300610976, 0.15421095710873378, 0.20756111818324685, 0.19310224518428054, 0.16676502500203572, 0.1884449701022327, 0.17276782780122701, 0.2222230357055316, 0.19507941679416596, 0.14837076854843123, 0.1481308285971149, 0.018934436206926697, 0.0483397793365995, 0.008927221859370338, 0.04014322213770283, 0.012298341621981512, 0.016762520770224776, 0.007559062202359357, 0.01646817176435833, 0.0032433673880813974, 0.10588813073949932, 0.07934691199172572, 0.08452390245758157, 0.09447281299124333, 0.0922937250279956, 0.08627459092793632, 0.13051100019574602, 0.1566125506267404, 0.16398750430933773, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001519146894039869, 9.999999999998899e-05, 0.010941503835733224, 0.006641359437335237, 9.999999999998899e-05, 9.999999999998899e-05, 0.10916530302171468, 0.10880602893001523, 0.1409746807193918, 0.10699603843936223, 0.07274657088806347, 0.11556488043008906, 0.1098463241179426, 0.10895465517290681, 0.12184266947803768, 0.39047626422674864, 0.41577132760341284, 0.41565100221594586, 0.41311183485163505, 0.3800818972046127, 0.37627264165955554, 0.4120477623890998, 0.4050340034625992, 0.40418584521244216, 0.08661263077452008, 0.10114024133647781, 0.10402606445682328, 0.0882001764292285, 0.11010437677099982, 0.10283906263317422, 0.09519876971513674, 0.12887060305560516, 0.09881668000106325, 0.21888440957870292, 0.19495262767428512, 0.23398014490101227, 0.2951117551339748, 0.2661607682635242, 0.1768453527913718, 0.20214149320111208, 0.20664493944043538, 0.22772502456391053, 0.20742887416563593, 0.21883886394428975, 0.2037005325007003, 0.19270460823814572, 0.20337041313269144, 0.20817031980168255, 0.19472528245926302, 0.2399766466000126, 0.2038540136914293, 0.18966729577222474, 0.16027778898755318, 0.15048006874442887, 0.15294357367705325, 0.14742115603522743, 0.16825348686397645, 0.161999830321523, 0.20346281451795722, 0.1682073289409649, 0.17360129506366961, 0.17185821929096146, 0.17994447647181, 0.19558404088296788, 0.17965913764796881, 0.1845567364039732, 0.19423162423387597, 0.20078395588598563, 0.19385766942727356, 0.1996510786261545, 0.197236263953658, 0.23948490694033475, 0.19267042536458878, 0.1755225683675199, 0.20664420076118217, 0.1784591076582479, 0.1977667489897903, 0.1812902323656851, 0.19238697251802672, 0.5114167175887605, 0.5726509294858023, 0.18769561694262227, 0.48362480242835026, 0.5902889007815313, 0.6505296943825064, 0.7138597082241769, 0.2012603970970388, 0.4033051621027933, 0.3989316010733033, 0.41866993420616405, 0.33286091722978195, 0.3766190750648929, 0.2599513070683541, 0.44836543276981333, 0.35594094922433717, 0.32064638410093416, 0.19883218669763425, 0.1743738183959993, 0.18017213014135103, 0.1864450413486517, 0.17516979855847425, 0.1858840157592454, 0.1865637598831904, 0.1831882922478062, 0.18304898374497358, 0.07947442729016385, 0.08484454909168015, 0.07747942579257427, 0.07282110908165085, 0.0706174484667339, 0.06964507750852222, 0.07098492869541584, 0.08063483450244824, 0.0795163798590296]}, "mutation_prompt": null}
{"id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "solution": "import numpy as np\n\nclass DiversifiedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.08  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - a), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  # Use uniform distribution\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 14)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "DiversifiedAdaptiveDE", "description": "A diversified differential evolution algorithm with adaptive ops for mutation, crossover, and local search.", "configspace": "", "generation": 79, "fitness": 0.2551001782100308, "feedback": "The algorithm DiversifiedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.18.", "error": "", "parent_id": "572e4683-48d1-418f-b93d-730b2d7d10ca", "metadata": {"aucs": [0.6521986992973346, 0.6392947390842681, 0.6508972343979942, 0.6211680250670794, 0.5881429054332373, 0.6228583359444704, 0.6555465234034965, 0.5955161851861538, 0.6186758777850432, 0.23208557604052582, 0.2658436580576329, 0.2011362594259717, 0.24497414685351315, 0.3247775283353379, 0.15320201673410028, 0.045011164449223706, 0.1347297067283607, 0.22855295760645256, 0.13813347402659892, 0.14141154716354631, 0.12470820482770195, 0.13931097764458933, 0.11985049164447881, 0.1717696441525206, 0.15539091167426433, 0.14261849375774105, 0.12413136038560135, 0.10702679681475924, 0.11110943883817526, 0.09159448759424538, 0.10698456405981682, 0.11352321575025015, 0.10208911000724807, 0.10843032719375678, 0.08926475221214392, 0.09254093454914547, 0.7138274826689499, 0.7562998922556634, 0.4049085646103203, 0.5598949885931972, 0.7010471090584384, 0.5754298454722817, 0.6985639336651704, 0.6178557338998006, 0.7888443500536809, 0.29272005313415994, 0.2215019988888821, 0.3296302315638471, 0.3458976973289758, 0.24207865377649074, 0.3175142084354011, 0.3191407373890306, 0.3198315851530661, 0.3241139554360579, 0.45629306852056783, 0.5306930902055766, 0.47955060069636346, 0.5490604034898932, 0.43118157839178806, 0.5482688806882834, 0.39104181305161356, 0.3006774215645087, 0.5676604182726172, 0.15808436246561597, 0.21627601227285786, 0.19712345930986774, 0.30633828814088915, 0.30745687306199565, 0.219754489728208, 0.23424693668522178, 0.218356341463254, 0.22573401328900244, 0.15954283758005172, 0.17458508517145144, 0.21393108971943986, 0.2317469640895049, 0.1475172523944377, 0.15070124543791952, 0.16123223625176064, 0.19688857035027296, 0.14840488599174972, 0.09228183567065429, 0.028092408307855643, 0.06041307273818397, 0.10675779443096467, 0.023547740796202032, 0.0608790484435946, 0.06376646783973539, 0.07495367189805924, 0.1215566909437864, 0.15631279033152934, 0.12069278734650957, 0.2122532345222765, 0.08986632751465207, 0.1433972532095108, 0.1360490205423044, 0.24032116581518226, 0.1733181164646045, 0.20243884668627599, 0.01124965712178383, 0.06577776723715745, 0.046797352969587536, 0.05113070755243898, 0.050195439815043374, 0.04963376852819423, 0.04851854010597778, 0.048545444412373406, 0.06588821107062415, 0.14525089861996443, 0.1437174672786763, 0.14721274124040096, 0.11138101994314198, 0.17270723766816976, 0.14850004056385346, 0.11702594866954674, 0.1433313256180363, 0.13816564819945776, 0.48974489559132106, 0.5016786388423404, 0.4904666951218062, 0.4780070874351613, 0.47082404644743137, 0.47095976419068597, 0.5117865806827204, 0.5074794768556726, 0.5017700143709332, 0.09816908686142611, 0.12247190500827054, 0.08645039954959788, 0.22455265738881058, 0.1159472595424833, 0.12039219904888454, 0.10237073398671159, 0.1446713011166506, 0.1404351999174669, 0.20230567136778144, 0.13506521390254078, 0.17278908701808182, 0.18841516422691917, 0.1782700678112069, 0.1883226618268612, 0.1684370520090659, 0.18187169286034044, 0.16223634284712185, 0.2680788020046738, 0.2983603260867854, 0.29760909752880316, 0.3061827029057602, 0.30159767855934116, 0.3142638805455388, 0.30308486943662993, 0.32273541220862223, 0.29325064628766984, 0.18614363992169913, 0.23712806305522693, 0.2166386133060414, 0.2059384669821327, 0.20839654889851267, 0.22505375590233057, 0.2092707413022894, 0.25768419770343365, 0.24598118734347163, 0.2113410266358634, 0.21242355421182102, 0.20945435694418524, 0.2231913042180319, 0.19993910503035484, 0.19031736642422992, 0.19393374751789483, 0.20670596783798645, 0.23246631892888725, 0.19897346675985883, 0.19482304550411889, 0.18569927569352862, 0.1982208994982919, 0.23731174001447364, 0.1853064408470817, 0.20138309382182795, 0.21088972017186491, 0.1788457161506769, 0.18197136464104535, 0.18269628311009078, 0.18304350223700383, 0.16945301470253238, 0.20851066934417561, 0.7255058510388596, 0.5584750035048769, 0.7049902325090331, 0.7201283448733368, 0.5848293521187384, 0.2036906368064455, 0.4906166510062486, 0.40313190742938654, 0.1618974128344458, 0.6396736693256484, 0.4289582995402248, 0.280364876752786, 0.1994911847177433, 0.1845660202444943, 0.19976449641408867, 0.19248056670334857, 0.2061005270476377, 0.21087089555944494, 0.2159102238796563, 0.20082704270056984, 0.187904709895367, 0.21219710682630988, 0.09627269404529304, 0.09243668607697997, 0.08476060639045058, 0.09100552261363792, 0.09213318840534213, 0.09372289201494599, 0.09609516193229373, 0.08584023882414327, 0.08892898337057653]}, "mutation_prompt": null}
{"id": "66c8080b-dd0f-4d2b-994a-9a88f43411fe", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Adjusted population size to enhance diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Adjusted mutation factor for better exploration\n        self.crossover_rate = 0.9  # Increased crossover rate for higher trial diversity\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Improved adaptive mutation factor\n        self.success_rate = 0.1  # Improved success rate for initial adaptation\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  # Adjusted range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (d - a), *self.bounds)  # Reduced contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.rand(self.dim) < self.crossover_rate  # Random crossover\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)  # Improved success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.05, self.success_rate - 0.02)  # Improved success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.0015  # Refined step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(30):  # Increased iterations for finer search\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:  # Adjusted exploration phase\n                population = sorted(population, key=func)\n                best_count = max(4, self.population_size // 12)  # Adjusted number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced adaptive differential evolution with dynamic exploration-exploitation balance and improved local search.", "configspace": "", "generation": 80, "fitness": 0.22636480750238447, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.16.", "error": "", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.49787374090057224, 0.5178033155735771, 0.46999988002877857, 0.4596547154529922, 0.4768885272333375, 0.4684009943808761, 0.4797715746733455, 0.5541040614259718, 0.4653554357045254, 0.08523640658316656, 0.08522521882797063, 0.06276929734004244, 0.06552854972245437, 0.06053157962869715, 0.11495498399062487, 0.0808997253027528, 0.05028518841833007, 0.06376299754247083, 0.13373308503302161, 0.13016805607000947, 0.12675738852310237, 0.11885345917188006, 0.11221370835650091, 0.13549573731306797, 0.14973930905904986, 0.12104839052945282, 0.11108413768767655, 0.11416248424784003, 0.08572452769795202, 0.10178347075032124, 0.1090493441201621, 0.09139499654323913, 0.13333567380157496, 0.0919652872990131, 0.07794416562928819, 0.10882163213886376, 0.6553280128684531, 0.5136935619606846, 0.6919250418375336, 0.6194816792429712, 0.7284390039770902, 0.5214239292070408, 0.6357101320035035, 0.6853181439456542, 0.6136686581761509, 0.3552418397928836, 0.12334320372661456, 0.24971559773773633, 0.24815329362590588, 0.25966999347697983, 0.27821309786962656, 0.3787457088749694, 0.2671733966216756, 0.266051972924244, 0.20067441271404596, 0.21645525048641112, 0.2380750911159425, 0.24899428377834343, 0.5593393688657731, 0.32310930351618794, 0.38720870441616306, 0.24472690149575171, 0.2680837757348439, 0.25616930515984915, 0.18118854096086656, 0.12544267835940792, 0.24941835607698648, 0.16276911344780398, 0.226925772818112, 0.14576575066027742, 0.18423171711733255, 0.19150772174868425, 0.13638797066038388, 0.2683558143452168, 0.16624910447647523, 0.1823975519886578, 0.1335347427140634, 0.20846066399137064, 0.14923242664342362, 0.13387101954691938, 0.22221393956547097, 0.0061249963163905186, 0.013623922012782397, 0.06836789589953829, 0.055507004511849534, 0.02595963989222072, 0.00829360546848712, 0.05169043417504893, 0.03974314853048477, 0.03065987031234363, 0.13641046488851605, 0.10595372342871778, 0.11145472612657026, 0.08301937285468597, 0.0892404403535797, 0.11208309254814552, 0.17060070940121208, 0.13122187638548277, 0.1403075389247066, 0.05097090092234102, 0.059880827571407114, 0.04599832606911736, 0.03927519785877398, 0.06246982356070663, 0.04682568550835586, 0.05744406443120387, 0.05686175167773544, 0.06118534386598928, 0.13931912820903236, 0.11045245846111762, 0.1403916739212011, 0.1134591475057527, 0.1387339086963313, 0.13521247578232887, 0.1442089837477064, 0.13414384441381222, 0.1297306637189215, 0.4050865270007946, 0.45456963180999943, 0.42936857231865433, 0.4240886201389461, 0.40356551491390336, 0.41324924066541713, 0.4612756788475394, 0.39530608566948333, 0.4119627401967396, 0.08569766991192229, 0.12841649737917782, 0.12039538733427957, 0.11720787542060973, 0.10195299475327879, 0.1061029798158708, 0.11285507790200722, 0.12721671007298718, 0.10614164370726542, 0.16857937596584383, 0.1819323643805787, 0.15098838564107175, 0.20374093185871867, 0.138056560846464, 0.21148556406239583, 0.16397393817779704, 0.16270849137012955, 0.1917145694276451, 0.21752989796633238, 0.22305085359181287, 0.22768894199309775, 0.2426443046055239, 0.24682642212079042, 0.2418065984898945, 0.2692406134777964, 0.24998283878789085, 0.249422191792237, 0.1660700897232722, 0.15048947453520545, 0.1558871759470256, 0.1685950634643847, 0.14906383351921848, 0.1688710905491131, 0.18670904875486638, 0.19414275700549966, 0.1810557112808796, 0.18274287007390144, 0.17853698529206463, 0.1895187800221615, 0.2654361176836898, 0.21313804355704935, 0.20413530077040143, 0.19738074460560062, 0.19391211519115503, 0.21963666657204262, 0.18344022825145967, 0.4197309483383014, 0.17327840370964043, 0.19438411293528668, 0.23190134678141183, 0.1780161176517615, 0.19478555135766495, 0.17755109123799306, 0.19375650066213257, 0.47798004165264174, 0.6628824080931974, 0.4920029357494824, 0.6891814431492209, 0.5841022018692978, 0.6771176466565736, 0.5225729414699067, 0.53490401947788, 0.6262477625263903, 0.445890929902783, 0.22543175792585957, 0.29921035187392664, 0.35523610626708957, 0.3206988178048248, 0.4288117010830249, 0.2788616283239008, 0.22712628107695143, 0.19143401011250183, 0.21993911020952617, 0.20404859250749952, 0.19902786142391538, 0.24489773076255839, 0.2197758392345479, 0.2055073344026931, 0.21551849998959227, 0.22609176111882712, 0.20925219723154065, 0.0921118880477847, 0.08953607719177803, 0.07479972295271253, 0.10241559390804522, 0.08490113971963198, 0.08116192108328601, 0.0841464040674349, 0.09772554177491344, 0.08501649305564729]}, "mutation_prompt": null}
{"id": "4c0a8e07-73da-4796-8fd6-d774c0621e6a", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Increase population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.5 + np.random.rand() * 0.3  # Stochastic mutation factor\n        self.crossover_rate = 0.9  # Increase crossover rate for better exploration\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Slightly adjusted adaptive mutation factor\n        self.success_rate = 0.1  # Increased success rate threshold\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.25 * (d - a), *self.bounds)  # Adjust contribution\n\n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.02)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.02, self.success_rate - 0.02)  # Adjust success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n\n        def multilevel_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.003  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(25):  # Increased iterations for more thorough search\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n\n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.6:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 12)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = multilevel_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedDifferentialEvolution", "description": "Enhanced differential evolution with stochastic adaptive parameters and multilevel local search.", "configspace": "", "generation": 81, "fitness": 0.224949011756389, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.15.", "error": "", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.514928052971846, 0.5084391455515358, 0.5349275709800598, 0.52209340317966, 0.5452942834430772, 0.48131739093604553, 0.5201201452672499, 0.529786884507008, 0.5145106920245576, 0.103689631717227, 0.12838423476651406, 0.1111036541973337, 0.07428278090099882, 0.11647434853066896, 0.13668424992016448, 0.0632029215170754, 0.11045838144044207, 0.11827958440196129, 0.1269990892094386, 0.10584284629259233, 0.13553919575371987, 0.17250001111096647, 0.1488174422301176, 0.10217751025899613, 0.132340196977069, 0.11888296913517693, 0.19120276486148058, 0.09850583504969457, 0.09404676797516609, 0.09414945945184172, 0.08718619647083015, 0.08644240223817123, 0.10265711417897072, 0.09410841866061981, 0.07522247956111494, 0.09311963596956196, 0.4695694414956061, 0.6597005340774941, 0.47979717725632476, 0.3952513547689904, 0.5958198550113802, 0.562576544543636, 0.5574826391577359, 0.726525570721896, 0.48418819765544985, 0.26014457365104937, 0.30971698503201817, 0.2866431152699863, 0.295680380459454, 0.30510092769710795, 0.30714073290208266, 0.27995030974550517, 0.2938433639904513, 0.27629290161145137, 0.3687052706067516, 0.4172936914278609, 0.33909520373679425, 0.5040225122920247, 0.39469856773251977, 0.5526291131481396, 0.3129465588947259, 0.23333432166916745, 0.3132330247916155, 0.213082474945268, 0.1619809338282292, 0.1846264991262222, 0.24632522054965034, 0.24212815576485625, 0.19235811657467738, 0.25028024485703326, 0.16090134723697413, 0.14453264110691866, 0.18562507152843477, 0.16370470842565044, 0.17714661766972817, 0.17901827364978695, 0.21144516725861096, 0.16447260740298641, 0.1424521968439405, 0.18747401459361024, 0.14346452910240315, 0.03507551921502583, 0.03634242596833759, 0.042924211492549325, 0.07223079284874234, 0.006616529310965236, 0.058423135967054396, 0.07432038806466701, 0.0439777781389501, 0.07313035412187818, 0.1786639661418663, 0.1953707967855265, 0.16226896490667064, 0.16074622116682624, 0.10766845431574434, 0.16258682200606, 0.17067959478890082, 0.1593629757535171, 0.17124569877919582, 0.01135808332170185, 0.004536706207428742, 0.018289615082277666, 0.01822500580086417, 0.007129467763981823, 0.008273817738390643, 0.07084764490160977, 0.009872255973487176, 0.018377456830062866, 0.13234560114771576, 0.12626093948564798, 0.144343207485636, 0.13898142012392833, 0.1348732398061907, 0.14820764185018376, 0.1333531631770356, 0.15741019639436205, 0.11597514129805209, 0.4261117513574424, 0.44370577570169345, 0.43059604298528953, 0.4486940481070898, 0.4262648352470042, 0.43557347945648006, 0.4605092351161939, 0.4698608290382301, 0.449624694874756, 0.14270007449933586, 0.1328774147616918, 0.13664881218487623, 0.10309980606976843, 0.12930676701584543, 0.13895824529919498, 0.12531549445978485, 0.12859568559440815, 0.14324190061949826, 0.2667449676666188, 0.1808043510728642, 0.18086176473213522, 0.1910781730716038, 0.19254816485474224, 0.1710554391553991, 0.20984533529190308, 0.19027770811673317, 0.1615304705077376, 0.2516726476091089, 0.2579485430989915, 0.2335994494333471, 0.2631623221977304, 0.2470267543772725, 0.2605436075351182, 0.26148006137445257, 0.23632397938359762, 0.2858317826840926, 0.20795907689995063, 0.20643424346057493, 0.21292417519325124, 0.2004219434942328, 0.18390533249582774, 0.2014025545917053, 0.20816646039806475, 0.18596733720395853, 0.18371074529083375, 0.19016660483956582, 0.19292657702658167, 0.18454903012794555, 0.22121790552096166, 0.19346995456974414, 0.19651908883186542, 0.1782608266921718, 0.2049603245688182, 0.2008706758898493, 0.1923787211931235, 0.20475017637810378, 0.2184485807095805, 0.19306686714169086, 0.19174715761732009, 0.1815690858398138, 0.18226547668047033, 0.18758399115932356, 0.20846625429277177, 0.16575300722563768, 0.6173523909773047, 0.6443986608596707, 0.19298014822342913, 0.6899308606041943, 0.6009967584995615, 0.18905666607492044, 0.22211101890718166, 0.18969289366581943, 0.4460176468801482, 0.26749452544630237, 0.3851354029078371, 0.2714876174683778, 0.16688272235322343, 0.21036469425640103, 0.2308925843752807, 0.3436096990958074, 0.35924691091542427, 0.1915406845525376, 0.17175548165957266, 0.18901055870454198, 0.19521039022133957, 0.19882161640950835, 0.18678306089017138, 0.19792204441394645, 0.19045985528491471, 0.19678927839644855, 0.08429193122490675, 0.08431290588246088, 0.08486536232326014, 0.10513843206013718, 0.09080532937307184, 0.08541864879690475, 0.10101302477942375, 0.08382156649913919, 0.09307796089889286]}, "mutation_prompt": null}
{"id": "5fc8523b-9024-417e-a7cc-1e809cc5e7a4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.7  # Adjusted adaptive mutation factor\n        self.success_rate = 0.1  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.5, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.25 * (d - a), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  # Use uniform distribution\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.05, self.success_rate - 0.02)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.003  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(25):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.8:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 12)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "An enhanced differential evolution algorithm with dynamic adaptive mutation and local search for robust optimization.", "configspace": "", "generation": 82, "fitness": 0.22215726390158094, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.16.", "error": "", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.5528156526392044, 0.46617878825610004, 0.49725082743813487, 0.49646852528856367, 0.4742182880321768, 0.5295396505012233, 0.494855428732794, 0.5417810268694614, 0.5005561109753331, 0.05035501535060216, 0.06757260616606586, 0.08022603621493385, 0.07848611343950684, 0.06739042524574856, 0.07101661462379838, 0.055261245090319266, 0.08797941814825971, 0.06315356890693424, 0.11316866271120851, 0.11967370340412431, 0.09235155417158714, 0.09692320304705715, 0.1025322138964293, 0.12188522128522417, 0.15110050308535206, 0.12987585806903812, 0.10964301814255972, 0.09881644676502366, 0.08941780255645204, 0.09377028176568858, 0.09155862453416264, 0.10540057428066707, 0.08889542118351768, 0.06536603949776598, 0.11281282871685583, 0.11476514807434246, 0.655458443269741, 0.7069650178680316, 0.6185242821601736, 0.7251335167686064, 0.6930277097424695, 0.6210911983362837, 0.6081066730660877, 0.66380630338623, 0.7273402817185746, 0.2999474007863747, 0.32033689263541454, 0.2556592207389039, 0.26394162606574634, 0.3191484568429528, 0.29216278303871024, 0.28237435210622563, 0.2345233288023405, 0.23525991787380995, 0.24389135574243626, 0.2388684126775351, 0.2243669749821553, 0.2849163995382077, 0.28580413819852424, 0.27043927655436395, 0.27394677634412823, 0.2092811742389561, 0.4034606062137074, 0.22894655884445958, 0.25035872755256794, 0.17841550061978706, 0.21689013293545334, 0.27917568746391885, 0.15129653986396585, 0.18302209686023652, 0.2624895803623517, 0.270972264259294, 0.16064087526977544, 0.15087552353721312, 0.16799636064083712, 0.1300077415183667, 0.1475112194758551, 0.1459207651907991, 0.2158501509628541, 0.14918134464959454, 0.18000284156005875, 0.03654656550637703, 0.01118051069552839, 0.009150770278646636, 0.042207181664229765, 0.04266447152923114, 0.0321675834964853, 0.027159173812381754, 0.030006550614574024, 0.01792975358530491, 0.11255921889454601, 0.1068731975018763, 0.11163592891777951, 0.10138428506293218, 0.10680157339081087, 0.12467271638549393, 0.15854364755572536, 0.12946880221752688, 0.12835039646707513, 0.03627200744785186, 0.023117824125603703, 0.012651551127572547, 0.028983614097749744, 0.004445280746399272, 0.04934844204045241, 0.02517187809077226, 0.02549868417460388, 0.002959802612425344, 0.13871981242521925, 0.1229198442593753, 0.14631540946772748, 0.14426572194447018, 0.0996868048922821, 0.12006818772774241, 0.1148765850675123, 0.15079423766681088, 0.10022390702345929, 0.414013519118296, 0.44130257237970716, 0.41681454596027867, 0.40656202570649813, 0.4190952536138831, 0.44422281208553727, 0.44396057381443166, 0.414062349798623, 0.41927945498513663, 0.11689450425760173, 0.11826890741809093, 0.10801184391788521, 0.12202098278218076, 0.11130389886202652, 0.14530441077733025, 0.11734560202163213, 0.12006916211918983, 0.11645578976842952, 0.1972488523674254, 0.18210134562493363, 0.23040225857830587, 0.2788749187458899, 0.1603969287516105, 0.15929144753960778, 0.22381552929143156, 0.17259444560069181, 0.20844350434242753, 0.2311911359151898, 0.22004746203870895, 0.24225731729141675, 0.24240565629923427, 0.23489605313715622, 0.22265191351012703, 0.22651559514177777, 0.24010725482483253, 0.22748182117168703, 0.2002197485891657, 0.17064926304620598, 0.18026507395863411, 0.18408136754523008, 0.1432806255865211, 0.16623020093547547, 0.16927219133834093, 0.1979906182007638, 0.21452444101258583, 0.23339633261789727, 0.19186345824021733, 0.19466669294606065, 0.20317661749999938, 0.2196923999344529, 0.20943685615696372, 0.16736301915946228, 0.21006862324054776, 0.19724991379474155, 0.18145568973104986, 0.18355181258699893, 0.19894673550091801, 0.18942101085613927, 0.1906688956748327, 0.17571854460822756, 0.21106486570076055, 0.20019908359513605, 0.18066729402826964, 0.6380633019978481, 0.5444929701508608, 0.6195229635413741, 0.19290759865800322, 0.45774466863094043, 0.7089433362192359, 0.5836716805439226, 0.32845446509313814, 0.16950952385305118, 0.46237916699188786, 0.40492658553464145, 0.4069561117364222, 0.1808175861084489, 0.33066833572698584, 0.25725632591605385, 0.37659236817153807, 0.41281642347547565, 0.23194698847948125, 0.1957468391195447, 0.20893937749306002, 0.17207372287658385, 0.2219011248797953, 0.18084037002307685, 0.19856236986755482, 0.19095377014351944, 0.1939670555396985, 0.19171667078508692, 0.07598378069337774, 0.10043933115180403, 0.09456604639623167, 0.08416289072840355, 0.08475264460658072, 0.10451953838826866, 0.07674410389224484, 0.08248035289737032, 0.08309478590030595]}, "mutation_prompt": null}
{"id": "e16dbb9c-f862-48d2-951f-f97df484b243", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Slightly increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.5  # Adjusted mutation factor for balance\n        self.crossover_rate = 0.9  # Increased crossover rate for more exploration\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Adjusted adaptive mutation factor\n        self.success_rate = 0.1  # Adjusted success rate for adaptation\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  # Adjusted range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.15 * (d - a), *self.bounds)  # Adjusted contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  # Use uniform distribution\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.02)  # Adjusted success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.02, self.success_rate - 0.01)  # Adjusted success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.001  # Adjusted step size for fine-tuning\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(25):  # Increased iterations for more intensive search\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.75:  # Adjustment in exploration phase\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 12)  # Adjusted number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "A novel adaptive differential evolution algorithm with enhanced dynamic search strategies and refined parameter adjustments for improved convergence.", "configspace": "", "generation": 83, "fitness": 0.20646926029635176, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.14.", "error": "", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.49938575475834823, 0.4916642080027108, 0.5108626158496541, 0.4718130674399298, 0.5087341783830556, 0.47457736718403654, 0.5126899208220934, 0.516441025027633, 0.4838694777195184, 0.09109210072696716, 0.11365661445701658, 0.10825975577897384, 0.11168633856107013, 0.10764475111629945, 0.10884241581138177, 0.09692846243653408, 0.10792373264489996, 0.08013340057373808, 0.1274794313602915, 0.13873774763527913, 0.10648943119094534, 0.10748918173012367, 0.10776293872130549, 0.11300274992233228, 0.11567962819228106, 0.13509319643391848, 0.10892904646261048, 0.08935055769641054, 0.09331554989556412, 0.09748458819852113, 0.08093709985709607, 0.09137256032488172, 0.09534194365141102, 0.09254960676225765, 0.08285228298533098, 0.10383236793715911, 0.5909147063644453, 0.6128893014948068, 0.42847957411343507, 0.5384227231971029, 0.6811553902170736, 0.541024255583944, 0.532520000496463, 0.5562177397505367, 0.6422829774683902, 0.20089557841123573, 0.25080451265548687, 0.17095634707249008, 0.21438411925786205, 0.2213939817923264, 0.28300125952180055, 0.23087511702609242, 0.21673918418843618, 0.24992391709028838, 0.25060461308890647, 0.23531323521064396, 0.22665605845583736, 0.30951485147984326, 0.250756688024394, 0.22646793827737066, 0.21800877701636068, 0.2540161695332208, 0.23527845814572823, 0.2261445140356828, 0.13392434586542457, 0.2538529369625102, 0.12089025077372606, 0.13810415151030297, 0.11138659419054842, 0.1592822290352326, 0.18348641607542981, 0.2654915990475786, 0.17530413826141467, 0.16756096288711064, 0.16897647982978892, 0.14686072629911373, 0.15899376131653065, 0.14844546890808474, 0.14457874235058665, 0.13326539974868734, 0.14366477602217897, 0.050873342712808856, 0.003828455229388017, 0.010682072267915843, 0.025567520942080812, 0.03199342337020372, 0.054539511535479646, 0.024389801540946943, 0.035576249949534566, 0.040869706467461575, 0.1667162676411741, 0.15961494127058373, 0.16695781536819654, 0.11889148050764198, 0.1339581188813458, 0.15631918870221329, 0.143861704666162, 0.13812829110259117, 0.12527373283580368, 0.05698692932538141, 0.07212938502874078, 0.0728631302321765, 0.053582169538591407, 0.05534204174329571, 0.0660547061274872, 0.06697383480901187, 0.046246368276237404, 0.07125116930367947, 0.1386190794553529, 0.12091970723405598, 0.11746537163303672, 0.11843708345766213, 0.12174716523400986, 0.1266094219775068, 0.11781654364547578, 0.11412110491768868, 0.109276523472707, 0.4112475150357485, 0.4087851131392908, 0.42348792657971945, 0.3738709321428878, 0.3706131603776468, 0.3983981889436292, 0.437538392693142, 0.3770046397330068, 0.40178866645110944, 0.1216477941864248, 0.12620020440972313, 0.11612666275351125, 0.13404993187657432, 0.11842940433034133, 0.0977364948311098, 0.13226383492613136, 0.1219088012133479, 0.13753677524078645, 0.14445914193477516, 0.1791391397120098, 0.17557468812413413, 0.19640747052966223, 0.1833073637365784, 0.1773048798707183, 0.1934768218422238, 0.12961634364602648, 0.14785953045209987, 0.24337579758081607, 0.23521037193568184, 0.24668029674386238, 0.22302764560969612, 0.23608084097649984, 0.22968776826678738, 0.2156388195388358, 0.24615830678035078, 0.23843832278457322, 0.1858424360462929, 0.18172537014396695, 0.18609243942718512, 0.18627194932855717, 0.17545226276130166, 0.18158088080606227, 0.18021123053906307, 0.19503781892388372, 0.17657447602827636, 0.2205802632284677, 0.19141090104727354, 0.19690111526816922, 0.223998438604187, 0.19035227155535572, 0.21580493056837102, 0.21102106198102422, 0.1890959983433116, 0.197586744255139, 0.1837104445729435, 0.17907888052723608, 0.18584428450417323, 0.19054080674129215, 0.17837130103394738, 0.19165769828188783, 0.1670013279951167, 0.17589379484240586, 0.1866764902582071, 0.1808441430110289, 0.17745878386344016, 0.18694312143572023, 0.41584240201401845, 0.19118685452698458, 0.5753470794865221, 0.5141159178929987, 0.21572279222166713, 0.3302905869802235, 0.43136262854140717, 0.279293341751228, 0.25533826836000184, 0.2547767470080431, 0.369185842099797, 0.40793822827674453, 0.23467610862952792, 0.31717190921279426, 0.1550059646009011, 0.20471084752827728, 0.20735268351587033, 0.1950594737866379, 0.21309956715130507, 0.22264880372362228, 0.22791391042530373, 0.2211102509191719, 0.21417768791991865, 0.22786292299103972, 0.08258972342402049, 0.12279986041979629, 0.08820956280398118, 0.09683329862755308, 0.08535062118452674, 0.09105216755101997, 0.0782777529683768, 0.09149815583305898, 0.09181918207322326]}, "mutation_prompt": null}
{"id": "8be2f423-75e3-49d0-bc6e-0be1fc487eba", "solution": "import numpy as np\n\nclass DiversifiedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.08  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                # Modify with probability\n                if np.random.rand() < 0.25:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - a), *self.bounds)\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            # Modify with probability\n            if self.evaluations < self.budget * (0.7 if np.random.rand() < 0.25 else 0.8):\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 14)\n                for i in range(min(best_count, len(population))):\n                    # Modify with probability\n                    if np.random.rand() < 0.25:\n                        population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "DiversifiedAdaptiveDE", "description": "A diversified differential evolution algorithm with probabilistically adaptive mutation and local search strategies.", "configspace": "", "generation": 84, "fitness": 0.2528290996549175, "feedback": "The algorithm DiversifiedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.18.", "error": "", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.6819444092970477, 0.6660443223683423, 0.6811961560830815, 0.6737657385533433, 0.650898285421701, 0.6643383118287005, 0.6199659686333117, 0.6904539075731408, 0.6364487988306593, 0.24741460593434017, 0.3532170999742916, 0.35175388894981197, 0.34291527892393314, 0.3061984240708193, 0.37452589772290634, 0.31024092222642086, 0.357634202818632, 0.09407929059873787, 0.1256592451264914, 0.18087023512945188, 0.11397564705902263, 0.12831832113659658, 0.1301381466451894, 0.14190042469945763, 0.1374661941047145, 0.1314232238373153, 0.16332093255585534, 0.09251199679487287, 0.10915602302292338, 0.10448477091092467, 0.1082128822670958, 0.1041558722158985, 0.1117989932876381, 0.12724722978791236, 0.10837125372697065, 0.09769857020513573, 0.6171858868467343, 0.15095317339035297, 0.5608421292627701, 0.5911143193310664, 0.1716903883119698, 0.5383356979197982, 0.4702631454452104, 0.5833710229775606, 0.5810156146945811, 0.2931986525504938, 0.2645988675170844, 0.10920304883317711, 0.30240265360281715, 0.26971335019871834, 0.21107275859813246, 0.3034545255179786, 0.2234409355595005, 0.2678889768488677, 0.5425610089131072, 0.5704372012938954, 0.6053449613275277, 0.5233048828024609, 0.7178238599687956, 0.605517932690454, 0.20739271366480638, 0.5283834417845861, 0.6177634340946168, 0.14726349231450042, 0.19090314987638435, 0.14812026878776707, 0.1646830404475964, 0.1411167414903497, 0.19041905544180926, 0.13197242266118625, 0.1655451727465681, 0.18896448942965605, 0.1561501677263668, 0.16022185741893646, 0.13314930797402447, 0.13578597493041977, 0.15096667855723722, 0.14025691379977723, 0.1477451141571824, 0.13492869496312054, 0.15463699910230522, 0.0939145872989704, 9.999999999998899e-05, 9.999999999998899e-05, 0.08713439197305783, 0.06493356397012306, 0.07373584245012077, 0.039472659643726704, 0.03442892503555939, 0.020822586011424393, 0.1693790378969383, 0.12197696353147969, 0.20846482995933435, 0.11152958999375606, 0.09744681727624138, 0.10391708159994706, 0.14791001244342283, 0.271678490312637, 0.17735315190734913, 0.0767542944541123, 0.04493264829195287, 0.059791382365468215, 0.060177369165756445, 0.07946503901489177, 0.06219264040018424, 0.06794558921031235, 0.031339715215066066, 0.05483384404228675, 0.1549956745139751, 0.12356348915127224, 0.13699099068207976, 0.17507485949554524, 0.17599083048613484, 0.16506864216350714, 0.15662916486696266, 0.15884418829068558, 0.09287586084409016, 0.4809708119131132, 0.5242691563609578, 0.5046676499442495, 0.49856166834145577, 0.4673797946342536, 0.48281364509873215, 0.517816390166878, 0.5028799003639942, 0.4918885448648934, 0.11964086744851543, 0.13920544142071356, 0.07865297300674834, 0.10479076585918956, 0.11242053532248197, 0.13717667140369427, 0.10860144530721028, 0.134354873216757, 0.13919087343339065, 0.14602196400401013, 0.2603477556167859, 0.18058557847054346, 0.18306731097122597, 0.13691185636863978, 0.19535851317570718, 0.1673145693226319, 0.14287904422581488, 0.18571913296478504, 0.3020661287469667, 0.29583124427294294, 0.30132230537763693, 0.3196626774113962, 0.294167982257435, 0.3267360402121794, 0.3115400800661736, 0.3430983487662542, 0.3232639103294941, 0.21993956352552346, 0.2400080194935208, 0.23110767475243843, 0.23238810638269392, 0.2406768332181739, 0.23424547675529794, 0.23102103258039197, 0.24873585960236955, 0.2607951886041351, 0.1980682626483684, 0.2114787596697878, 0.19863063336236808, 0.22135917073038103, 0.19062920513057247, 0.20101180873755042, 0.21066529934944567, 0.21915675773239462, 0.1939399422393484, 0.19082860120493939, 0.1937317115830277, 0.26711809388712937, 0.19218641253044888, 0.2048871368827666, 0.17990441686724934, 0.1913394436017487, 0.19168802885464886, 0.17819012612093443, 0.44363648246073395, 0.688379930458165, 0.17998284802151177, 0.7660489416801588, 0.4382535500650748, 0.5004977377389437, 0.5320095291279907, 0.37240247036142204, 0.5330552659133864, 0.5536621156769489, 0.19639416449353675, 0.48095267807004816, 0.643264312545395, 0.24106603354810563, 0.2582911779549325, 0.1818758890694172, 0.2196224007021257, 0.1870295067282921, 0.1906389233134087, 0.20681755668630142, 0.19640118521291983, 0.19452776293581842, 0.19142924703545605, 0.19752845775872951, 0.18715605883713315, 0.2023607719228384, 0.18901843691684495, 0.09792203909845998, 0.08666640604639264, 0.07996397898848229, 0.09574012195173887, 0.09239484941036624, 0.12137088130382323, 0.08744266980763182, 0.11754263469598025, 0.0922161401548558]}, "mutation_prompt": null}
{"id": "f9cc28a7-7f39-4ffa-926d-726f3845820f", "solution": "import numpy as np\n\nclass DiversifiedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.08  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - a), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  # Use uniform distribution\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 14)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "DiversifiedAdaptiveDE", "description": "A diversified differential evolution algorithm with adaptive ops for mutation, crossover, and local search.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.6521986992973346, 0.6392947390842681, 0.6508972343979942, 0.6211680250670794, 0.5881429054332373, 0.6228583359444704, 0.6555465234034965, 0.5955161851861538, 0.6186758777850432, 0.23208557604052582, 0.2658436580576329, 0.2011362594259717, 0.24497414685351315, 0.3247775283353379, 0.15320201673410028, 0.045011164449223706, 0.1347297067283607, 0.22855295760645256, 0.13813347402659892, 0.14141154716354631, 0.12470820482770195, 0.13931097764458933, 0.11985049164447881, 0.1717696441525206, 0.15539091167426433, 0.14261849375774105, 0.12413136038560135, 0.10702679681475924, 0.11110943883817526, 0.09159448759424538, 0.10698456405981682, 0.11352321575025015, 0.10208911000724807, 0.10843032719375678, 0.08926475221214392, 0.09254093454914547, 0.7138274826689499, 0.7562998922556634, 0.4049085646103203, 0.5598949885931972, 0.7010471090584384, 0.5754298454722817, 0.6985639336651704, 0.6178557338998006, 0.7888443500536809, 0.29272005313415994, 0.2215019988888821, 0.3296302315638471, 0.3458976973289758, 0.24207865377649074, 0.3175142084354011, 0.3191407373890306, 0.3198315851530661, 0.3241139554360579, 0.45629306852056783, 0.5306930902055766, 0.47955060069636346, 0.5490604034898932, 0.43118157839178806, 0.5482688806882834, 0.39104181305161356, 0.3006774215645087, 0.5676604182726172, 0.15808436246561597, 0.21627601227285786, 0.19712345930986774, 0.30633828814088915, 0.30745687306199565, 0.219754489728208, 0.23424693668522178, 0.218356341463254, 0.22573401328900244, 0.15954283758005172, 0.17458508517145144, 0.21393108971943986, 0.2317469640895049, 0.1475172523944377, 0.15070124543791952, 0.16123223625176064, 0.19688857035027296, 0.14840488599174972, 0.09228183567065429, 0.028092408307855643, 0.06041307273818397, 0.10675779443096467, 0.023547740796202032, 0.0608790484435946, 0.06376646783973539, 0.07495367189805924, 0.1215566909437864, 0.15631279033152934, 0.12069278734650957, 0.2122532345222765, 0.08986632751465207, 0.1433972532095108, 0.1360490205423044, 0.24032116581518226, 0.1733181164646045, 0.20243884668627599, 0.01124965712178383, 0.06577776723715745, 0.046797352969587536, 0.05113070755243898, 0.050195439815043374, 0.04963376852819423, 0.04851854010597778, 0.048545444412373406, 0.06588821107062415, 0.14525089861996443, 0.1437174672786763, 0.14721274124040096, 0.11138101994314198, 0.17270723766816976, 0.14850004056385346, 0.11702594866954674, 0.1433313256180363, 0.13816564819945776, 0.48974489559132106, 0.5016786388423404, 0.4904666951218062, 0.4780070874351613, 0.47082404644743137, 0.47095976419068597, 0.5117865806827204, 0.5074794768556726, 0.5017700143709332, 0.09816908686142611, 0.12247190500827054, 0.08645039954959788, 0.22455265738881058, 0.1159472595424833, 0.12039219904888454, 0.10237073398671159, 0.1446713011166506, 0.1404351999174669, 0.20230567136778144, 0.13506521390254078, 0.17278908701808182, 0.18841516422691917, 0.1782700678112069, 0.1883226618268612, 0.1684370520090659, 0.18187169286034044, 0.16223634284712185, 0.2680788020046738, 0.2983603260867854, 0.29760909752880316, 0.3061827029057602, 0.30159767855934116, 0.3142638805455388, 0.30308486943662993, 0.32273541220862223, 0.29325064628766984, 0.18614363992169913, 0.23712806305522693, 0.2166386133060414, 0.2059384669821327, 0.20839654889851267, 0.22505375590233057, 0.2092707413022894, 0.25768419770343365, 0.24598118734347163, 0.2113410266358634, 0.21242355421182102, 0.20945435694418524, 0.2231913042180319, 0.19993910503035484, 0.19031736642422992, 0.19393374751789483, 0.20670596783798645, 0.23246631892888725, 0.19897346675985883, 0.19482304550411889, 0.18569927569352862, 0.1982208994982919, 0.23731174001447364, 0.1853064408470817, 0.20138309382182795, 0.21088972017186491, 0.1788457161506769, 0.18197136464104535, 0.18269628311009078, 0.18304350223700383, 0.16945301470253238, 0.20851066934417561, 0.7255058510388596, 0.5584750035048769, 0.7049902325090331, 0.7201283448733368, 0.5848293521187384, 0.2036906368064455, 0.4906166510062486, 0.40313190742938654, 0.1618974128344458, 0.6396736693256484, 0.4289582995402248, 0.280364876752786, 0.1994911847177433, 0.1845660202444943, 0.19976449641408867, 0.19248056670334857, 0.2061005270476377, 0.21087089555944494, 0.2159102238796563, 0.20082704270056984, 0.187904709895367, 0.21219710682630988, 0.09627269404529304, 0.09243668607697997, 0.08476060639045058, 0.09100552261363792, 0.09213318840534213, 0.09372289201494599, 0.09609516193229373, 0.08584023882414327, 0.08892898337057653]}, "mutation_prompt": null}
{"id": "32c4ddd0-fa59-4b62-bc92-0df9b393781a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Increased population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Slightly increased mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6  # Increased adaptive mutation factor\n        self.success_rate = 0.1  # Increased success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  # Adjusted range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - a), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.04)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.02, self.success_rate - 0.02)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.003  # Increased step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(25):  # Increased iterations\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.75:  # Adjusted exploration phase\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 12)  # Adjusted number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "A diversified differential evolution with adaptive ops and enhanced exploration via dynamic strategy adjustment.", "configspace": "", "generation": 86, "fitness": 0.2425272592869149, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.17.", "error": "", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.5185371065027, 0.5192575685761771, 0.5015983451225581, 0.5016871966155682, 0.49448104422805994, 0.4925083143272442, 0.5241142027454571, 0.49926557467892485, 0.5013814073505991, 0.12725869536986445, 0.11042839095784474, 0.10632140891901531, 0.07370218431708431, 0.11332720190275247, 0.12514786113575682, 0.08700777492690681, 0.13392470405098245, 0.06851626933334387, 0.1297542873451143, 0.12486537141258736, 0.1519389182830153, 0.14206195387986043, 0.1526233243751629, 0.12490938207223912, 0.13580205139513524, 0.13185494761727223, 0.11868734423673, 0.1153603780864052, 0.08737793610925071, 0.11158859060401027, 0.08872034342493096, 0.10518041516126286, 0.08263349875245185, 0.08086153758826697, 0.0894067034192314, 0.10131852555063359, 0.6214075951447515, 0.742774924656636, 0.6675255066313129, 0.681257158289194, 0.24255977173126042, 0.5258006700827499, 0.4746494358936312, 0.5467409789195948, 0.5954991471627566, 0.2970885397901134, 0.2396043436210813, 0.3205508192414157, 0.2972361104244591, 0.3133882573701532, 0.32611188143579917, 0.30174809613709874, 0.2733271633549622, 0.3064402091929189, 0.31692027062553507, 0.5276075195525844, 0.4542896306871882, 0.47256481496333214, 0.5062984053556223, 0.42612531187517066, 0.43789910604365556, 0.36997520673830464, 0.5779057677156001, 0.22628988784366721, 0.15976972814303048, 0.21542841499734033, 0.20375385703814552, 0.17617713259383394, 0.1948484856135062, 0.2977723946489679, 0.26342910040789713, 0.2058803755172961, 0.14545782222637393, 0.15048783610575778, 0.2420939185553811, 0.12343408947500356, 0.1636310720834705, 0.1532079410949112, 0.26527415535034704, 0.16221524381344976, 0.24431847620810931, 0.04368215569725453, 0.07980876163021045, 0.035222046316539135, 0.04864306810864638, 0.08418425178250877, 0.03422284193027936, 0.044095499232436164, 0.04128249047683552, 0.05445865832355867, 0.15411703344352157, 0.13870472085149865, 0.18918073062996155, 0.12795312032093475, 0.1370575938708709, 0.1395095459524882, 0.22762757700090397, 0.13013569984435147, 0.1093684186885584, 0.02710793034292658, 0.029081796399044846, 0.02280057073576136, 0.010406435429129113, 0.0148626633659662, 0.020540011577073525, 0.036461440749626095, 0.024427159817467015, 0.006836715537850924, 0.1328779121210848, 0.1421440456113996, 0.13457145450711028, 0.1055058575841189, 0.11530975321662207, 0.14585075032334094, 0.120509493778296, 0.1321039297606772, 0.11615744207380119, 0.4359288274004113, 0.4439236851614816, 0.45842650354850834, 0.42628612526386334, 0.4375954183485531, 0.43803578155590717, 0.4576081545072831, 0.4442556662781595, 0.4485774098188319, 0.10126859118989828, 0.11868517429898129, 0.08798174478882315, 0.15829913795523187, 0.09322836032476556, 0.1129452805780351, 0.14001772052089778, 0.12662292105773287, 0.1353791890821141, 0.2863008785163954, 0.20405543604686682, 0.21985881430169918, 0.2679924516747656, 0.18299230015822465, 0.25851467446641485, 0.197802625740102, 0.16309449183764102, 0.2038048928245193, 0.24420865259424362, 0.23377309650625955, 0.25693579379295006, 0.2684528177933404, 0.25485314651605107, 0.29198317914045924, 0.24698411406748355, 0.2724609916379709, 0.24704871442945042, 0.21669130188099317, 0.21260452225839, 0.19684784953163248, 0.2054745838496428, 0.2117393862182846, 0.19655924443850958, 0.1846202596069243, 0.2038733047686252, 0.19289979990192707, 0.22323140725417556, 0.2146841871127353, 0.2040552163574253, 0.19398663907135216, 0.19620928756824707, 0.2043862961005447, 0.2240612850717233, 0.21924860885420905, 0.23555864746835709, 0.21481506793247984, 0.1737639641534564, 0.19974140682010744, 0.19929509213089658, 0.18463940870048556, 0.17360016428536473, 0.18692410717788532, 0.20944405314120418, 0.2488131168783384, 0.4843002789298927, 0.5496194592978347, 0.5853926496493442, 0.8049880456774308, 0.1989678840887621, 0.6627690428535349, 0.628298815011549, 0.6314056061268816, 0.7178391372319621, 0.4794295427472067, 0.3808776148551606, 0.37431609576514635, 0.7276037639681427, 0.20137238719545247, 0.4316092174899471, 0.3023060340824778, 0.2998147131813015, 0.2585959973100914, 0.20355338379149046, 0.19986406356861686, 0.18946762110988058, 0.1966898907408008, 0.19662090599190374, 0.20828446885125274, 0.19416260566136734, 0.19171597866862733, 0.1878128002730266, 0.09158602589929155, 0.09342805827488043, 0.08950102017132577, 0.09143189753568026, 0.08535608063813283, 0.09518911233811156, 0.08586570742429489, 0.08866118122491484, 0.09625303432923715]}, "mutation_prompt": null}
{"id": "d5159683-ee10-4500-ac4c-2227298562f4", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Adjusted mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.4  # Adjusted adaptive mutation factor\n        self.success_rate = 0.1  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.2, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.25 * (d - a), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  # Use uniform distribution\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.02, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.001  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(30):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.6:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 12)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "A dynamically adaptive differential evolution algorithm with enhanced mutation and local refinement strategies.", "configspace": "", "generation": 87, "fitness": 0.21053785295670416, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.15.", "error": "", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.6318963017274823, 0.5575290481186101, 0.573170411381385, 0.5398343354570969, 0.5129263818335659, 0.5183623748987221, 0.5600364329978784, 0.5614319126741097, 0.4948336587054337, 0.16988870214207963, 0.17318463524614436, 9.999999999998899e-05, 0.17087424116055772, 0.14221530173088137, 0.08810478242763897, 9.999999999998899e-05, 0.14736226968134525, 0.08305173374562524, 0.15758090410051806, 0.2092139988363061, 0.12181013961093123, 0.12887965200950224, 0.1347589439552156, 0.15350543059032173, 0.09495868261651563, 0.13697329419758042, 0.1198814332223892, 0.09679258933063206, 0.09324494957023266, 0.10043659204240407, 0.11964838013993562, 0.09722195923455568, 0.07805084768417914, 0.12610837613006498, 0.10795605053501711, 0.0847459202375569, 0.10488651088270695, 0.10756063636177693, 0.07664018193162869, 0.11361205701732213, 0.1860672542285572, 0.11699978224218266, 0.11359355913265701, 0.1196369493741668, 0.102296553288036, 0.16299333208939237, 0.28333783266574564, 0.12594373372487622, 0.16195120484616143, 0.0689755363039507, 0.13041212245317346, 0.29402287936487626, 0.24176365541474076, 0.25932928766162033, 0.4556816482704542, 0.47914260096343164, 0.20306428858430536, 0.3123702115471134, 0.5378114808463914, 0.28894400633846984, 0.19364100627372105, 0.17925402187076345, 0.20162670735769384, 0.13660076872848081, 0.19596397333780802, 0.13335827762994124, 0.17854639726620825, 0.30689229652540073, 0.13372947145648484, 0.2292914428427234, 0.20510945240646228, 0.1857608778448795, 0.18998935679793705, 0.14774377801298377, 0.12376219134902644, 0.13551611377147854, 0.14299469834405332, 0.14958769713115128, 0.25729665160741855, 0.19102229642466728, 0.16130015271743847, 0.05604422508846052, 0.05885505886541409, 0.10284932778244582, 0.11871101530258843, 0.10949122581618231, 9.999999999998899e-05, 0.002284997120122201, 0.03657829223824649, 0.1736977739647635, 0.1933800293960677, 0.10740557040615972, 0.14970721809061838, 0.07087024033231115, 0.09371957208574899, 0.04553712960058287, 0.13238076706055812, 0.12465259404747409, 0.24501220593154205, 0.06043983857880908, 0.06302696274150654, 0.06791253633348693, 0.06752987129669241, 0.05346781949460511, 0.053024034058778535, 0.1013898658096587, 0.05012866158673712, 0.09493226511231856, 0.07219117304156875, 0.16687717628337229, 0.08218113735448407, 0.0361708238054147, 0.13555278906369062, 0.12804643096205914, 0.1198210249644237, 0.14052279261827005, 0.07400531256648468, 0.47192986188483255, 0.47147902968271105, 0.4308143072075902, 0.4194418762709301, 0.35439008733984534, 0.4098444651078642, 0.4517136270810095, 0.45290306056456575, 0.479736039253542, 0.08499960154055775, 0.09058613360589862, 0.09078727870273617, 0.20350609297871047, 0.11451014020053785, 0.09885518873878085, 0.11069487994137528, 0.1381158501729085, 0.11066789703844038, 0.1880514786225097, 0.16743763598857297, 0.17409317175452288, 0.16457813843929925, 0.17537671763662732, 0.19715190955247897, 0.1755602121832497, 0.15660691424335105, 0.16366296496603117, 0.27248898734547444, 0.23302023806364713, 0.2629011599727774, 0.29962391641463515, 0.25422802650876997, 0.2634736781411521, 0.26115656442301827, 0.30978861579357486, 0.2357678319030445, 0.21032851493113358, 0.19782122832261473, 0.2259701640936045, 0.246141685920094, 0.24140123744241748, 0.25351700807493605, 0.18786647021016178, 0.23550366134382505, 0.1895605040489825, 0.22209424479906337, 0.23359426568074182, 0.22622529925684454, 0.2083514872687584, 0.2137733244718497, 0.2279332322488995, 0.20647157370756697, 0.22949430186776776, 0.24492292805424554, 0.18950120680753957, 0.19416024952180766, 0.18747408191389336, 0.2091140382549852, 0.19754171428652278, 0.1867309587787077, 0.1821122543950754, 0.1784056558919217, 0.1807184009073135, 0.2694935964719326, 0.17698504923912273, 0.4950403750124519, 0.6780606136286845, 0.659434733973081, 0.18545292099734145, 0.8248678194186091, 0.1613148985622198, 0.7123559920214677, 0.5468767577832563, 0.3306547054544787, 0.6139937268152734, 0.5551602464649026, 0.2947374478116158, 0.3459344138462076, 0.15442811143627622, 0.26401956081490885, 0.328114783691675, 0.2347303563320432, 0.24774757708546447, 0.18895616133929982, 0.2158477490105225, 0.24012090240709527, 0.2131794837742934, 0.22944192675064723, 0.23986563566152908, 0.23067302737754236, 0.10625898809501, 0.09454112478810406, 0.09176003161734736, 0.11301005569306466, 0.09745201585221763, 0.1025012680559817, 0.09554442660556106, 0.09225365919555173, 0.09749946179195101]}, "mutation_prompt": null}
{"id": "9e20ebfb-c235-4a85-a3ac-8a83cc11ed5f", "solution": "import numpy as np\n\nclass DiversifiedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.08  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - a), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  # Use uniform distribution\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 14)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "DiversifiedAdaptiveDE", "description": "A diversified differential evolution algorithm with adaptive ops for mutation, crossover, and local search.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.6521986992973346, 0.6392947390842681, 0.6508972343979942, 0.6211680250670794, 0.5881429054332373, 0.6228583359444704, 0.6555465234034965, 0.5955161851861538, 0.6186758777850432, 0.23208557604052582, 0.2658436580576329, 0.2011362594259717, 0.24497414685351315, 0.3247775283353379, 0.15320201673410028, 0.045011164449223706, 0.1347297067283607, 0.22855295760645256, 0.13813347402659892, 0.14141154716354631, 0.12470820482770195, 0.13931097764458933, 0.11985049164447881, 0.1717696441525206, 0.15539091167426433, 0.14261849375774105, 0.12413136038560135, 0.10702679681475924, 0.11110943883817526, 0.09159448759424538, 0.10698456405981682, 0.11352321575025015, 0.10208911000724807, 0.10843032719375678, 0.08926475221214392, 0.09254093454914547, 0.7138274826689499, 0.7562998922556634, 0.4049085646103203, 0.5598949885931972, 0.7010471090584384, 0.5754298454722817, 0.6985639336651704, 0.6178557338998006, 0.7888443500536809, 0.29272005313415994, 0.2215019988888821, 0.3296302315638471, 0.3458976973289758, 0.24207865377649074, 0.3175142084354011, 0.3191407373890306, 0.3198315851530661, 0.3241139554360579, 0.45629306852056783, 0.5306930902055766, 0.47955060069636346, 0.5490604034898932, 0.43118157839178806, 0.5482688806882834, 0.39104181305161356, 0.3006774215645087, 0.5676604182726172, 0.15808436246561597, 0.21627601227285786, 0.19712345930986774, 0.30633828814088915, 0.30745687306199565, 0.219754489728208, 0.23424693668522178, 0.218356341463254, 0.22573401328900244, 0.15954283758005172, 0.17458508517145144, 0.21393108971943986, 0.2317469640895049, 0.1475172523944377, 0.15070124543791952, 0.16123223625176064, 0.19688857035027296, 0.14840488599174972, 0.09228183567065429, 0.028092408307855643, 0.06041307273818397, 0.10675779443096467, 0.023547740796202032, 0.0608790484435946, 0.06376646783973539, 0.07495367189805924, 0.1215566909437864, 0.15631279033152934, 0.12069278734650957, 0.2122532345222765, 0.08986632751465207, 0.1433972532095108, 0.1360490205423044, 0.24032116581518226, 0.1733181164646045, 0.20243884668627599, 0.01124965712178383, 0.06577776723715745, 0.046797352969587536, 0.05113070755243898, 0.050195439815043374, 0.04963376852819423, 0.04851854010597778, 0.048545444412373406, 0.06588821107062415, 0.14525089861996443, 0.1437174672786763, 0.14721274124040096, 0.11138101994314198, 0.17270723766816976, 0.14850004056385346, 0.11702594866954674, 0.1433313256180363, 0.13816564819945776, 0.48974489559132106, 0.5016786388423404, 0.4904666951218062, 0.4780070874351613, 0.47082404644743137, 0.47095976419068597, 0.5117865806827204, 0.5074794768556726, 0.5017700143709332, 0.09816908686142611, 0.12247190500827054, 0.08645039954959788, 0.22455265738881058, 0.1159472595424833, 0.12039219904888454, 0.10237073398671159, 0.1446713011166506, 0.1404351999174669, 0.20230567136778144, 0.13506521390254078, 0.17278908701808182, 0.18841516422691917, 0.1782700678112069, 0.1883226618268612, 0.1684370520090659, 0.18187169286034044, 0.16223634284712185, 0.2680788020046738, 0.2983603260867854, 0.29760909752880316, 0.3061827029057602, 0.30159767855934116, 0.3142638805455388, 0.30308486943662993, 0.32273541220862223, 0.29325064628766984, 0.18614363992169913, 0.23712806305522693, 0.2166386133060414, 0.2059384669821327, 0.20839654889851267, 0.22505375590233057, 0.2092707413022894, 0.25768419770343365, 0.24598118734347163, 0.2113410266358634, 0.21242355421182102, 0.20945435694418524, 0.2231913042180319, 0.19993910503035484, 0.19031736642422992, 0.19393374751789483, 0.20670596783798645, 0.23246631892888725, 0.19897346675985883, 0.19482304550411889, 0.18569927569352862, 0.1982208994982919, 0.23731174001447364, 0.1853064408470817, 0.20138309382182795, 0.21088972017186491, 0.1788457161506769, 0.18197136464104535, 0.18269628311009078, 0.18304350223700383, 0.16945301470253238, 0.20851066934417561, 0.7255058510388596, 0.5584750035048769, 0.7049902325090331, 0.7201283448733368, 0.5848293521187384, 0.2036906368064455, 0.4906166510062486, 0.40313190742938654, 0.1618974128344458, 0.6396736693256484, 0.4289582995402248, 0.280364876752786, 0.1994911847177433, 0.1845660202444943, 0.19976449641408867, 0.19248056670334857, 0.2061005270476377, 0.21087089555944494, 0.2159102238796563, 0.20082704270056984, 0.187904709895367, 0.21219710682630988, 0.09627269404529304, 0.09243668607697997, 0.08476060639045058, 0.09100552261363792, 0.09213318840534213, 0.09372289201494599, 0.09609516193229373, 0.08584023882414327, 0.08892898337057653]}, "mutation_prompt": null}
{"id": "39ac701a-fa36-4e9e-8d18-8c9843331536", "solution": "import numpy as np\n\nclass DiversifiedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.08  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - a), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  # Use uniform distribution\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 14)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "DiversifiedAdaptiveDE", "description": "A diversified differential evolution algorithm with adaptive ops for mutation, crossover, and local search.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.6521986992973346, 0.6392947390842681, 0.6508972343979942, 0.6211680250670794, 0.5881429054332373, 0.6228583359444704, 0.6555465234034965, 0.5955161851861538, 0.6186758777850432, 0.23208557604052582, 0.2658436580576329, 0.2011362594259717, 0.24497414685351315, 0.3247775283353379, 0.15320201673410028, 0.045011164449223706, 0.1347297067283607, 0.22855295760645256, 0.13813347402659892, 0.14141154716354631, 0.12470820482770195, 0.13931097764458933, 0.11985049164447881, 0.1717696441525206, 0.15539091167426433, 0.14261849375774105, 0.12413136038560135, 0.10702679681475924, 0.11110943883817526, 0.09159448759424538, 0.10698456405981682, 0.11352321575025015, 0.10208911000724807, 0.10843032719375678, 0.08926475221214392, 0.09254093454914547, 0.7138274826689499, 0.7562998922556634, 0.4049085646103203, 0.5598949885931972, 0.7010471090584384, 0.5754298454722817, 0.6985639336651704, 0.6178557338998006, 0.7888443500536809, 0.29272005313415994, 0.2215019988888821, 0.3296302315638471, 0.3458976973289758, 0.24207865377649074, 0.3175142084354011, 0.3191407373890306, 0.3198315851530661, 0.3241139554360579, 0.45629306852056783, 0.5306930902055766, 0.47955060069636346, 0.5490604034898932, 0.43118157839178806, 0.5482688806882834, 0.39104181305161356, 0.3006774215645087, 0.5676604182726172, 0.15808436246561597, 0.21627601227285786, 0.19712345930986774, 0.30633828814088915, 0.30745687306199565, 0.219754489728208, 0.23424693668522178, 0.218356341463254, 0.22573401328900244, 0.15954283758005172, 0.17458508517145144, 0.21393108971943986, 0.2317469640895049, 0.1475172523944377, 0.15070124543791952, 0.16123223625176064, 0.19688857035027296, 0.14840488599174972, 0.09228183567065429, 0.028092408307855643, 0.06041307273818397, 0.10675779443096467, 0.023547740796202032, 0.0608790484435946, 0.06376646783973539, 0.07495367189805924, 0.1215566909437864, 0.15631279033152934, 0.12069278734650957, 0.2122532345222765, 0.08986632751465207, 0.1433972532095108, 0.1360490205423044, 0.24032116581518226, 0.1733181164646045, 0.20243884668627599, 0.01124965712178383, 0.06577776723715745, 0.046797352969587536, 0.05113070755243898, 0.050195439815043374, 0.04963376852819423, 0.04851854010597778, 0.048545444412373406, 0.06588821107062415, 0.14525089861996443, 0.1437174672786763, 0.14721274124040096, 0.11138101994314198, 0.17270723766816976, 0.14850004056385346, 0.11702594866954674, 0.1433313256180363, 0.13816564819945776, 0.48974489559132106, 0.5016786388423404, 0.4904666951218062, 0.4780070874351613, 0.47082404644743137, 0.47095976419068597, 0.5117865806827204, 0.5074794768556726, 0.5017700143709332, 0.09816908686142611, 0.12247190500827054, 0.08645039954959788, 0.22455265738881058, 0.1159472595424833, 0.12039219904888454, 0.10237073398671159, 0.1446713011166506, 0.1404351999174669, 0.20230567136778144, 0.13506521390254078, 0.17278908701808182, 0.18841516422691917, 0.1782700678112069, 0.1883226618268612, 0.1684370520090659, 0.18187169286034044, 0.16223634284712185, 0.2680788020046738, 0.2983603260867854, 0.29760909752880316, 0.3061827029057602, 0.30159767855934116, 0.3142638805455388, 0.30308486943662993, 0.32273541220862223, 0.29325064628766984, 0.18614363992169913, 0.23712806305522693, 0.2166386133060414, 0.2059384669821327, 0.20839654889851267, 0.22505375590233057, 0.2092707413022894, 0.25768419770343365, 0.24598118734347163, 0.2113410266358634, 0.21242355421182102, 0.20945435694418524, 0.2231913042180319, 0.19993910503035484, 0.19031736642422992, 0.19393374751789483, 0.20670596783798645, 0.23246631892888725, 0.19897346675985883, 0.19482304550411889, 0.18569927569352862, 0.1982208994982919, 0.23731174001447364, 0.1853064408470817, 0.20138309382182795, 0.21088972017186491, 0.1788457161506769, 0.18197136464104535, 0.18269628311009078, 0.18304350223700383, 0.16945301470253238, 0.20851066934417561, 0.7255058510388596, 0.5584750035048769, 0.7049902325090331, 0.7201283448733368, 0.5848293521187384, 0.2036906368064455, 0.4906166510062486, 0.40313190742938654, 0.1618974128344458, 0.6396736693256484, 0.4289582995402248, 0.280364876752786, 0.1994911847177433, 0.1845660202444943, 0.19976449641408867, 0.19248056670334857, 0.2061005270476377, 0.21087089555944494, 0.2159102238796563, 0.20082704270056984, 0.187904709895367, 0.21219710682630988, 0.09627269404529304, 0.09243668607697997, 0.08476060639045058, 0.09100552261363792, 0.09213318840534213, 0.09372289201494599, 0.09609516193229373, 0.08584023882414327, 0.08892898337057653]}, "mutation_prompt": null}
{"id": "495a7a2e-f930-435a-9655-67227d57ef54", "solution": "import numpy as np\n\nclass DiversifiedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5  # Adjusted adaptive mutation factor\n        self.success_rate = 0.08  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n                \n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  # Adjust range\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - a), *self.bounds)  # Adjust contribution\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  # Use uniform distribution\n                trial[crossover] = mutant[crossover]\n                \n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjust success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjust success rate decrement\n                \n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Adjust step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n            \n            for _ in range(20):  # Adjust iterations\n                perturbation = np.random.normal(0, step_size, self.dim)  # Use normal distribution\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n                \n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                \n                if self.evaluations >= self.budget:\n                    break\n            \n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n            \n            if self.evaluations < self.budget * 0.7:  # Adjust exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 14)  # Adjust number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "DiversifiedAdaptiveDE", "description": "A diversified differential evolution algorithm with adaptive ops for mutation, crossover, and local search.", "configspace": "", "generation": 80, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.6521986992973346, 0.6392947390842681, 0.6508972343979942, 0.6211680250670794, 0.5881429054332373, 0.6228583359444704, 0.6555465234034965, 0.5955161851861538, 0.6186758777850432, 0.23208557604052582, 0.2658436580576329, 0.2011362594259717, 0.24497414685351315, 0.3247775283353379, 0.15320201673410028, 0.045011164449223706, 0.1347297067283607, 0.22855295760645256, 0.13813347402659892, 0.14141154716354631, 0.12470820482770195, 0.13931097764458933, 0.11985049164447881, 0.1717696441525206, 0.15539091167426433, 0.14261849375774105, 0.12413136038560135, 0.10702679681475924, 0.11110943883817526, 0.09159448759424538, 0.10698456405981682, 0.11352321575025015, 0.10208911000724807, 0.10843032719375678, 0.08926475221214392, 0.09254093454914547, 0.7138274826689499, 0.7562998922556634, 0.4049085646103203, 0.5598949885931972, 0.7010471090584384, 0.5754298454722817, 0.6985639336651704, 0.6178557338998006, 0.7888443500536809, 0.29272005313415994, 0.2215019988888821, 0.3296302315638471, 0.3458976973289758, 0.24207865377649074, 0.3175142084354011, 0.3191407373890306, 0.3198315851530661, 0.3241139554360579, 0.45629306852056783, 0.5306930902055766, 0.47955060069636346, 0.5490604034898932, 0.43118157839178806, 0.5482688806882834, 0.39104181305161356, 0.3006774215645087, 0.5676604182726172, 0.15808436246561597, 0.21627601227285786, 0.19712345930986774, 0.30633828814088915, 0.30745687306199565, 0.219754489728208, 0.23424693668522178, 0.218356341463254, 0.22573401328900244, 0.15954283758005172, 0.17458508517145144, 0.21393108971943986, 0.2317469640895049, 0.1475172523944377, 0.15070124543791952, 0.16123223625176064, 0.19688857035027296, 0.14840488599174972, 0.09228183567065429, 0.028092408307855643, 0.06041307273818397, 0.10675779443096467, 0.023547740796202032, 0.0608790484435946, 0.06376646783973539, 0.07495367189805924, 0.1215566909437864, 0.15631279033152934, 0.12069278734650957, 0.2122532345222765, 0.08986632751465207, 0.1433972532095108, 0.1360490205423044, 0.24032116581518226, 0.1733181164646045, 0.20243884668627599, 0.01124965712178383, 0.06577776723715745, 0.046797352969587536, 0.05113070755243898, 0.050195439815043374, 0.04963376852819423, 0.04851854010597778, 0.048545444412373406, 0.06588821107062415, 0.14525089861996443, 0.1437174672786763, 0.14721274124040096, 0.11138101994314198, 0.17270723766816976, 0.14850004056385346, 0.11702594866954674, 0.1433313256180363, 0.13816564819945776, 0.48974489559132106, 0.5016786388423404, 0.4904666951218062, 0.4780070874351613, 0.47082404644743137, 0.47095976419068597, 0.5117865806827204, 0.5074794768556726, 0.5017700143709332, 0.09816908686142611, 0.12247190500827054, 0.08645039954959788, 0.22455265738881058, 0.1159472595424833, 0.12039219904888454, 0.10237073398671159, 0.1446713011166506, 0.1404351999174669, 0.20230567136778144, 0.13506521390254078, 0.17278908701808182, 0.18841516422691917, 0.1782700678112069, 0.1883226618268612, 0.1684370520090659, 0.18187169286034044, 0.16223634284712185, 0.2680788020046738, 0.2983603260867854, 0.29760909752880316, 0.3061827029057602, 0.30159767855934116, 0.3142638805455388, 0.30308486943662993, 0.32273541220862223, 0.29325064628766984, 0.18614363992169913, 0.23712806305522693, 0.2166386133060414, 0.2059384669821327, 0.20839654889851267, 0.22505375590233057, 0.2092707413022894, 0.25768419770343365, 0.24598118734347163, 0.2113410266358634, 0.21242355421182102, 0.20945435694418524, 0.2231913042180319, 0.19993910503035484, 0.19031736642422992, 0.19393374751789483, 0.20670596783798645, 0.23246631892888725, 0.19897346675985883, 0.19482304550411889, 0.18569927569352862, 0.1982208994982919, 0.23731174001447364, 0.1853064408470817, 0.20138309382182795, 0.21088972017186491, 0.1788457161506769, 0.18197136464104535, 0.18269628311009078, 0.18304350223700383, 0.16945301470253238, 0.20851066934417561, 0.7255058510388596, 0.5584750035048769, 0.7049902325090331, 0.7201283448733368, 0.5848293521187384, 0.2036906368064455, 0.4906166510062486, 0.40313190742938654, 0.1618974128344458, 0.6396736693256484, 0.4289582995402248, 0.280364876752786, 0.1994911847177433, 0.1845660202444943, 0.19976449641408867, 0.19248056670334857, 0.2061005270476377, 0.21087089555944494, 0.2159102238796563, 0.20082704270056984, 0.187904709895367, 0.21219710682630988, 0.09627269404529304, 0.09243668607697997, 0.08476060639045058, 0.09100552261363792, 0.09213318840534213, 0.09372289201494599, 0.09609516193229373, 0.08584023882414327, 0.08892898337057653]}, "mutation_prompt": null}
{"id": "8a16845b-09d1-4480-9c0b-510a7e0d80b0", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Slightly increased mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate for diversity\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n        self.success_rate = 0.1  # Adjusted higher initial success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  \n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.25 * (d - a), *self.bounds)  # Increased contribution factor\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  \n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.04)  # Slightly increased success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)  # Decreased success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def enhanced_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.003  # Increased step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(15):  # Reduced iterations for quick exploitation\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.6:  # Reduced exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 10)  # Adjusted number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = enhanced_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "AdvancedAdaptiveDE", "description": "An advanced differential evolution algorithm with adaptive mechanisms for balancing exploration and exploitation.", "configspace": "", "generation": 91, "fitness": 0.26383256740239247, "feedback": "The algorithm AdvancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "8a251c2e-1a08-4d82-b7b8-6ad7ca40d38c", "metadata": {"aucs": [0.7171544631186488, 0.7283319420527326, 0.7353370813798383, 0.6743631433807067, 0.6844985796985275, 0.7164156112366187, 0.7283414869674292, 0.7268943815790402, 0.7230030533846581, 0.3224800824605867, 0.3304338347792476, 0.14939203647112587, 0.05402162580735659, 0.3625413403318455, 9.999999999998899e-05, 9.999999999998899e-05, 0.10047844621183344, 0.015927946036407903, 0.12919916660537822, 0.12519488933251688, 0.1268944519743631, 0.2003757584411482, 0.13118515635700534, 0.12662767011764442, 0.12103000290573185, 0.10845737571615044, 0.13723891354959106, 0.10281718927735695, 0.08680150328488379, 0.10645286528796283, 0.10898217037085212, 0.08577429277669402, 0.05394548806506905, 0.0904879370187538, 0.09296077357462307, 0.09618305408554284, 0.6108853504528045, 0.6843453685335098, 0.46025266763047534, 0.15473703370145464, 0.1692686092695601, 0.4965177645918416, 0.22003502109594753, 0.5382127011324646, 0.13208778510942443, 0.3199043164027472, 0.3391876094627605, 0.3116474011853013, 0.3186738535174868, 0.3303177648446828, 0.3185607250549387, 0.36201195219597804, 0.299347940416992, 0.3058435413805157, 0.6632273761593555, 0.19318160894951675, 0.1635473825637982, 0.2693074740276833, 0.7168887327282238, 0.7491948860142237, 0.22141706632393388, 0.6788995400457909, 0.5692450470419776, 0.18048243519755147, 0.12292980724981517, 0.18116357478573686, 0.17254158749844262, 0.18381676534408453, 0.15678617492154556, 0.2228001151869925, 0.27745949672345327, 0.17867417844840816, 0.24324615462544708, 0.16317692928152283, 0.18368485904668574, 0.23731486611873265, 0.2640906475878759, 0.30081349883863473, 0.16142119745585548, 0.17081888554444036, 0.26376955209192554, 0.034794225931567, 0.11462536234284726, 0.1107324298361777, 0.1653204376805486, 0.08374277316713363, 0.009827545546078897, 0.05843066734492042, 0.08212115974534295, 0.16337021213721603, 0.34087969890557124, 0.14046661008972583, 0.32008163929952693, 0.10096757134362255, 0.0681642787601422, 0.16615314834700168, 0.15689095555511834, 0.15906396733213823, 0.15827335134087794, 0.09008790701062486, 0.09485408281892216, 0.1455738089144728, 0.06829178668456826, 0.10300775860112044, 0.06431158664285519, 0.08783994087057256, 0.04234830273731294, 0.0608808853075794, 0.19429120353162488, 0.20691775512450228, 0.23504610608229304, 0.17798427057477417, 0.19719113168309232, 0.2331651826647091, 0.13923113582888091, 0.19337455380013413, 0.08463914284300278, 0.5233437119189773, 0.5140002440478674, 0.5226475092798424, 0.5230587203500019, 0.48641556152368626, 0.4336048469789644, 0.5301905752411833, 0.48886855954922204, 0.5726123150295184, 0.10337473908425543, 0.12068862225615651, 0.12629373253290466, 0.12650990348728064, 0.14217911090848334, 0.121849082516716, 0.14108693276803208, 0.13834501263224375, 0.1441341660887474, 0.24754562127624868, 0.18438428495425985, 0.1870424866351319, 0.33812723658953836, 0.2165694682857534, 0.34376943589644093, 0.2747969467491024, 0.15404029792418583, 0.20054562030312595, 0.31152031210008657, 0.32724905455736564, 0.2687283147867392, 0.31683903836674776, 0.29434946345557744, 0.36490529020221874, 0.3072080016555051, 0.3946544295723242, 0.3193299670395281, 0.21554125656755663, 0.24515734287716018, 0.17110674828336736, 0.25740327779170735, 0.24335780157107256, 0.24938174422784587, 0.18599658740013625, 0.28024076155016364, 0.22766143762967017, 0.197547501949485, 0.22586226596457137, 0.21253501361671534, 0.19950844090758302, 0.20491172303965266, 0.20319893680490297, 0.2229714777377798, 0.2197114229628513, 0.2237334643327311, 0.17767744009751063, 0.2260496617495351, 0.1804949743282923, 0.23966411017886768, 0.24683647083337878, 0.23749421491267808, 0.1875067973504655, 0.34921175597525966, 0.17046659108078255, 0.7009351848836809, 0.7238067286279656, 0.18067966556995074, 0.7675115135567829, 0.19812697638894639, 0.8160123040432697, 0.7247499986811357, 0.1921315311256786, 0.7197593682666084, 0.7534095343952784, 0.48264912226153334, 0.6504918743714574, 0.4524073991287455, 0.1994242871336933, 0.18968762601428824, 0.3274849133742359, 0.3706916729462427, 0.20538083554634623, 0.2135192940880012, 0.18762046867345783, 0.20471933919808016, 0.19583771487143464, 0.18344705608395362, 0.18837451330330268, 0.1892820402138271, 0.18581047854662225, 0.227138635764632, 0.09535969792520593, 0.08500967880802668, 0.08897783129480319, 0.08267754345158229, 0.09295794438334848, 0.11610843563054407, 0.08423935260679283, 0.08944723435060187, 0.09482538929601558]}, "mutation_prompt": null}
{"id": "af183d60-62fd-4068-ac8d-3b5d83dce677", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Modified population size for better exploration\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6  # Adjusted mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate for balance\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n        self.success_rate = 0.2  # Modified initial success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - a), *self.bounds)  # Adjusted contribution factor\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  \n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjusted success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjusted success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def enhanced_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.0025  # Modified step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(20):  # Adjusted iterations for local search\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.7:  # Adjusted exploration phase threshold\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 8)  # Adjusted number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = enhanced_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDE", "description": "A refined differential evolution algorithm incorporating enhanced adaptive mechanisms for improved exploration-exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.23425236287332088, "feedback": "The algorithm RefinedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.16.", "error": "", "parent_id": "8a16845b-09d1-4480-9c0b-510a7e0d80b0", "metadata": {"aucs": [0.54004634905842, 0.5325711083425868, 0.5262655699666696, 0.50097828879946, 0.5286605766479786, 0.5054460544831492, 0.5399195868256876, 0.5877262327336665, 0.526724909723344, 0.14220619160410353, 0.12675913199998945, 0.13695395987534342, 0.1533703851447159, 0.15767424890422677, 0.15491176389571626, 0.15742649085037486, 0.1288154253581404, 0.12913678436401865, 0.11764648798923916, 0.1201220227677553, 0.13452288637638776, 0.15920608268170022, 0.11684919061846866, 0.13780078819711328, 0.14532436615630473, 0.1196896804993125, 0.1455138650787936, 0.10301884279138307, 0.09457891693030229, 0.1225678642674839, 0.0966322096827753, 0.09126646469257904, 0.0897188014754362, 0.08887653281042718, 0.10413044389301518, 0.10176777798981473, 0.5586049616036458, 0.6150957656260887, 0.6150341614553594, 0.5862399067964321, 0.6951006792688914, 0.5086005332990942, 0.5517448737889314, 0.741224743200519, 0.7519189211188635, 0.2963825638770595, 0.2893448594828828, 0.20545780133599167, 0.2756180971410619, 0.259388352138348, 0.3100693320603751, 0.3245640921149173, 0.2957826563946748, 0.2627229629060124, 0.2563457700241045, 0.24614785903760217, 0.23965197348745992, 0.29618922196452635, 0.2968348421333492, 0.3454675714089258, 0.27377421704645, 0.41314463714814276, 0.29823203343781535, 0.27653440189529044, 0.2823185712529145, 0.15274235977564277, 0.29112972693711914, 0.30123279768049693, 0.18450671679181063, 0.1865322102466045, 0.2173914977993623, 0.2517076591232912, 0.17282815488388736, 0.2508257949066136, 0.25727797910797623, 0.14403320051990542, 0.2952678046609304, 0.1707888914588579, 0.15994745204102945, 0.18734301336872394, 0.18875570449494183, 0.020707107517417334, 0.012682204255913376, 0.028650131153403757, 0.08835137051212494, 0.05534712540578801, 0.0336832907550173, 0.09993643969035815, 0.029558222752510077, 0.07401264693900611, 0.1573018540989306, 0.1249785172559239, 0.12337857929427776, 0.08748675231737468, 0.11883346975921527, 0.06695210547199437, 0.12277598283533897, 0.11150086415213556, 0.16660226034169467, 0.009660092673109855, 0.031389796143279636, 0.025510817888760307, 0.040759911574551166, 0.020478997953448763, 0.0035245122833766906, 0.024133141555879756, 0.017555526439119284, 0.06659599575254382, 0.13801799793846115, 0.129473757456953, 0.12333358761132973, 0.12552440008727572, 0.143191354139925, 0.12218602622350594, 0.12800878342487754, 0.14080103075336958, 0.09088433958885, 0.4174942021905147, 0.4376875457997377, 0.43461530712878094, 0.4347243883214921, 0.4285230206469872, 0.4209180473289048, 0.45176734531777496, 0.4155688474382737, 0.4404177694481761, 0.13149461487987624, 0.13110435187433, 0.09611774170913356, 0.12269515121434182, 0.1307616481958992, 0.13885256218310682, 0.13425779632938706, 0.14348449780568495, 0.10751762508118523, 0.17245828083453285, 0.15429338513108581, 0.20312607586350007, 0.23193303504223095, 0.19800187419187498, 0.293122006627209, 0.20726178984842147, 0.17881204329349787, 0.13293849211007092, 0.24960000941383653, 0.25000938133858175, 0.24063697815941965, 0.2558881313536632, 0.2450980367991179, 0.27703056946506677, 0.24640739370168407, 0.2513485925148399, 0.25704635468622694, 0.16501006643300808, 0.23356666839125206, 0.18871699250674856, 0.2005540829121243, 0.1994000042476215, 0.22154879220224843, 0.19034603905158043, 0.1937076673272934, 0.2159538998174112, 0.1915928119964353, 0.20818235785716332, 0.18955151097943668, 0.22366402594297852, 0.21968573747370068, 0.2186278708267505, 0.23915680932259709, 0.19143780373839003, 0.19966176198312746, 0.1825874818150761, 0.19607409416637644, 0.2133528520591006, 0.18613093510474876, 0.21886563066097386, 0.21716310319863164, 0.1974666771459198, 0.2033326242104052, 0.19543565765048887, 0.7006237331009726, 0.18329965567796758, 0.19240353534275156, 0.6208703466338625, 0.19804657601653664, 0.5704524351640172, 0.6017536219006727, 0.20385141645923055, 0.7015859145243661, 0.5065977026988562, 0.356216105508535, 0.5431094142583578, 0.4920794284989882, 0.4580674945771236, 0.4595383269830621, 0.18619559117361073, 0.34964465671594236, 0.21796374785955042, 0.19467293220586068, 0.21541330577622841, 0.19866197032369792, 0.19973090877394195, 0.19687975577827288, 0.20051997389483545, 0.2238242379474764, 0.20301783150837205, 0.19820923905032983, 0.08759774404155307, 0.08776762617344902, 0.0970740608955557, 0.08755065909773818, 0.10057861825466985, 0.09444013227426606, 0.08615670298001554, 0.08242461280915836, 0.08945890975159365]}, "mutation_prompt": null}
{"id": "0d7c4b5a-83de-480e-98ce-485a4d993064", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size for better exploration\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Modified mutation factor for enhanced search\n        self.crossover_rate = 0.85  # Balanced crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n        self.success_rate = 0.15  # Modified higher initial success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)\n\n                mutant = np.clip(a + self.mutation_factor * (b - c), *self.bounds)  # Standard DE strategy\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate\n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjusted success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.05, self.success_rate - 0.01)  # Adjusted success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def adaptive_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Adjusted step size for fine-tuning\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(20):  # Increased iterations for thorough local search\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.5:  # Adjusted exploration phase\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 8)  # Adjusted number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = adaptive_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridAdaptiveDE", "description": "A hybrid differential evolution with adaptive local search and elite preservation for enhanced convergence.", "configspace": "", "generation": 93, "fitness": 0.2198441043219837, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.17.", "error": "", "parent_id": "8a16845b-09d1-4480-9c0b-510a7e0d80b0", "metadata": {"aucs": [0.5144649942383401, 0.48632474236062373, 0.484312802183293, 0.4907683513432929, 0.5355628362305203, 0.5045541329094734, 0.5125609169096232, 0.49714253577772416, 0.4795486096539735, 0.11855304458222637, 0.10344387685843626, 0.09124293203804701, 0.09079340900634547, 0.10071286738374874, 0.12569121549541729, 0.09983841766823276, 0.09456533290986957, 0.11720919958826381, 0.14953996344936693, 0.1118319687559739, 0.10353255265706518, 0.11342876294419568, 0.12906411460628753, 0.10150717848326496, 0.12633117586111298, 0.11773965695104549, 0.10142137674935225, 0.11000687717892854, 0.07228342021167933, 0.09613387290074749, 0.11724239578375728, 0.09494623323517803, 0.08677936639165817, 0.08236584378711431, 0.09446793170221679, 0.10080450659934836, 0.8078330137011311, 0.7422740351306083, 0.7896364356013447, 0.7099973382067477, 0.7378826284916224, 0.7717772237670155, 0.8639747398024571, 0.8030826786938013, 0.7114396966769516, 0.23410564616027751, 0.2707165327682174, 0.15049456246306303, 0.2418716098252759, 0.1958451923676796, 0.29357805601203724, 0.27979509741769226, 0.2646090258515237, 0.2619798701516105, 0.2211144214038665, 0.23679783207740834, 0.3107442718165928, 0.23997404318177762, 0.2678802330061807, 0.29901037237615347, 0.21703639040644562, 0.20305516749388242, 0.18627615832883215, 0.1458518673596223, 0.14956350264882434, 0.20716585432815404, 0.24003092430852535, 0.16481035236346475, 0.277076522935373, 0.16031959181534583, 0.1334820446201378, 0.1378379848136161, 0.17153706017871195, 0.14060325859110656, 0.12045851511590122, 0.17880287431379294, 0.13831131345880998, 0.18210895507067748, 0.24840607178086738, 0.13547391929335295, 0.14463266238121864, 0.038719841625224016, 0.0220689754991803, 0.02685931004058606, 0.042335676465399374, 0.04873474914899356, 0.05656413311392772, 0.01707985453613492, 0.029443022074369773, 0.04550646763692823, 0.12792717866185643, 0.11531249868663584, 0.1345386833505725, 0.10302845547760808, 0.12533848560338523, 0.0675703590234491, 0.13318071231889028, 0.1292364256778472, 0.1081149619031132, 0.05325910053661609, 0.06061590938500705, 0.02217786492559204, 0.013956278563239333, 0.041826830990760344, 0.034232063250733025, 0.031793743141914854, 0.049124484499413645, 0.04279050872659196, 0.1318406711219201, 0.1228274555347092, 0.12858262596760794, 0.09150995241530158, 0.14282415790997616, 0.1248342388042214, 0.1309006076101723, 0.12394022513610148, 0.1414339139241041, 0.3834554494433565, 0.41411347797060405, 0.43010508184125484, 0.41609965150005623, 0.3765253160264269, 0.40071513300689987, 0.437321118974924, 0.38317054689572927, 0.45478397762909606, 0.1221885874857851, 0.11528019241259813, 0.16254313374045926, 0.0927539168070678, 0.12313354977009816, 0.1639533173687281, 0.11465835051484596, 0.10189184799926321, 0.12833997399997843, 0.24119520643422498, 0.15992503463872942, 0.20593446199679477, 0.2269113818578582, 0.15664380366972963, 0.15365330879465944, 0.19710522423553245, 0.19398032639334273, 0.21805848955814522, 0.21249132627699552, 0.21256117793850293, 0.21321230616502107, 0.22132877890678804, 0.21034912761008795, 0.23397013238994013, 0.21116081048678847, 0.2820097168895104, 0.23267050377258525, 0.1686028633080252, 0.15808292803492419, 0.1361862385426319, 0.16909120710643932, 0.15972592817475761, 0.15924721331563707, 0.17671627967721948, 0.16606415258370089, 0.177207044758379, 0.19356817407505433, 0.17133576040939225, 0.18160145266895356, 0.20229312071037486, 0.20463735814231, 0.19577899687418954, 0.1850971534246023, 0.18504105001997706, 0.21383922995785987, 0.1783075824375563, 0.173581095304993, 0.18414302167153074, 0.18587214154771237, 0.20324966293764213, 0.19501342614734551, 0.188511983034779, 0.17011757199847544, 0.20265789959445535, 0.5568293938547444, 0.6298527320144074, 0.1917956475938588, 0.6323906473610024, 0.3738170456349408, 0.6124966906484035, 0.5646850526846263, 0.18544893353073344, 0.19804685950951695, 0.40598844123064703, 0.1984033169072481, 0.276677996455704, 0.41612079997435625, 0.18260230099501962, 0.26820230850249127, 0.34369128893516376, 0.5593291876471829, 0.19819299951104064, 0.20778627970774943, 0.20016266697240048, 0.18992807925763078, 0.19853324305653175, 0.20719136752267697, 0.20653565022502496, 0.2092042638996935, 0.20126841152519515, 0.2190093865609246, 0.11445734153904819, 0.08482434868631517, 0.07704015011377507, 0.08235825885938197, 0.0877196131428678, 0.07123125151643872, 0.08461393234007342, 0.07685590561477074, 0.07726707492403784]}, "mutation_prompt": null}
{"id": "6155861c-ce01-450a-83ef-b7e6fd476dc1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 10 * dim  # Increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Further increased mutation factor\n        self.crossover_rate = 0.85  # Slightly decreased crossover rate for reduced premature convergence\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.4\n        self.success_rate = 0.15  # Increased initial success rate for faster adaptation\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.2, self.adaptive_mutation_factor)  \n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.3 * (d - a), *self.bounds)  # Further increased contribution factor\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  \n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)  # Further increased success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.03)  # Further decreased success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def enhanced_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Reduced step size for nuanced local search\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(20):  # Increased iterations for thorough exploitation\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.5:  # Adjusted exploration phase ratio\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 8)  # Slightly increased number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = enhanced_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "A balanced enhanced adaptive differential evolution with strategic parameter modulation for improved optimization performance.", "configspace": "", "generation": 94, "fitness": 0.21760260566600348, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.15.", "error": "", "parent_id": "8a16845b-09d1-4480-9c0b-510a7e0d80b0", "metadata": {"aucs": [0.5909643003918186, 0.5646735786362183, 0.5855582192300937, 0.5044818565626394, 0.5024851716278949, 0.5365625606370912, 0.5662579115084632, 0.5689838352131358, 0.5071404837711104, 0.1093295544103392, 0.20281151609878678, 0.05221991355514488, 9.999999999998899e-05, 0.11776039600758648, 0.05457735183463808, 0.10468880082987286, 9.999999999998899e-05, 0.15365506173108934, 0.09285032539139648, 0.1498508305553865, 0.16791149974579223, 0.12929189290136145, 0.1193753000859975, 0.13473730730305122, 0.11360953433177634, 0.14433709045365672, 0.15000351841833925, 0.09699625908722898, 0.11369865495622267, 0.11990392917675852, 0.09288321639717101, 0.11025636051726195, 0.09136163995302027, 0.11022759136240434, 0.10298158792927459, 0.11086616212397726, 0.10671575361270247, 0.12377070964456671, 0.1138302499832129, 0.1528835843325138, 0.13363813428728277, 0.11310242377838697, 0.10858369502395815, 0.15267937678934762, 0.3816986246807327, 0.22833527330536485, 0.1588837466264209, 0.26014370965118605, 0.17033971177403218, 0.2786181037289388, 0.20269852167350444, 0.28222100014313456, 0.2696606211011766, 0.2335720413868304, 0.19379948601992947, 0.3289735063357132, 0.4996312817566346, 0.6508929924446809, 0.5571762679838066, 0.13676997354095644, 0.15309457131731108, 0.16540878876929332, 0.2053870121782424, 0.23903175018388423, 0.3021842742270663, 0.14377079593039577, 0.27123986875739936, 0.24765540481538728, 0.24493744975681297, 0.17109469151065804, 0.3008300106296925, 0.22498889540117362, 0.24709313092355978, 0.16590981166749352, 0.18367321612100163, 0.14685139818186, 0.23091561778870828, 0.14016223119245874, 0.16667165263826678, 0.23179968506406712, 0.1622452249155797, 0.08994731273488799, 0.010495625628243244, 0.013842445515165669, 0.11342831180267365, 0.08719070001581752, 0.04619283242749317, 0.029373231277144307, 0.050017716798877676, 0.09243676587744953, 0.1445643929363658, 0.11482175126622751, 0.225072459250368, 0.07801732502322334, 0.11255439965711211, 0.11887678142199698, 0.12253611396202302, 0.13098007496821462, 0.12309703424306029, 0.04427225976444893, 0.0659098570416401, 0.05018424611374339, 0.04096387797679912, 0.02630062568805147, 0.052226292175168276, 0.05291860734241727, 0.03271086389252509, 0.03696770958490447, 0.16595651579435666, 0.06885791331867619, 0.11420701485660556, 0.1107879660848684, 0.13822222000965634, 0.16669338508914366, 0.14224234809315894, 0.14097495055394993, 0.062237070992480215, 0.4853894572963977, 0.48725260917949986, 0.46284018826215934, 0.4226721095372259, 0.39587071006658636, 0.34050557554576477, 0.4755689534962456, 0.4323690331236697, 0.4892823033546996, 0.10775788294788058, 0.09532838406600497, 0.08659925074915154, 0.1397246000465433, 0.10589259173105003, 0.14132506859278104, 0.14393905623381176, 0.15934166893852564, 0.1421032482938379, 0.13113257044510795, 0.13956970562198368, 0.19906551901640657, 0.21532432310362215, 0.20648040314754723, 0.21127081619087318, 0.18456862123408635, 0.22537426286250506, 0.17950112067691293, 0.21852042624042045, 0.27807531908036065, 0.2835437343324947, 0.29221195258833854, 0.30549967903759656, 0.29022767589734555, 0.20495841305672524, 0.30493548724849284, 0.21428512797973387, 0.21063683527353372, 0.21940488106000555, 0.24938171238033202, 0.19193753012494685, 0.23670444560452486, 0.22898560134315038, 0.17196557585406858, 0.23511327091996304, 0.19067319189982723, 0.22386119038329166, 0.20261729674753093, 0.20553994717798663, 0.23336306217234393, 0.22840994539264547, 0.24792570304362804, 0.20767257527966032, 0.22254145878107479, 0.2315431529315336, 0.18945617460882136, 0.18440023647395964, 0.19411050408280361, 0.20453146809561185, 0.1813814795795925, 0.18184073058472205, 0.1918900230775733, 0.19159887381017893, 0.1928205737285832, 0.17500442491000323, 0.6114016079818786, 0.43939614111353376, 0.7075322420788636, 0.7121147469461426, 0.5526791380347618, 0.5514090830495326, 0.2792165280206619, 0.6526377487855166, 0.41844382435437133, 0.3842456737673794, 0.47267775683131874, 0.5089358781961126, 0.38161967786189666, 0.37985244228952386, 0.21452807641526317, 0.3283500653842948, 0.3228198270004289, 0.22780014716605024, 0.21087979116619604, 0.2092910966537842, 0.2153973811764559, 0.23963700433460877, 0.20810083838662174, 0.20322602319904237, 0.19947656057151353, 0.20485708007553216, 0.0894675246591552, 0.0899770066135287, 0.10682349988221918, 0.09797525422980402, 0.09945104744571176, 0.10028515365290391, 0.09233104676454063, 0.08908225666520897, 0.10348745506784018]}, "mutation_prompt": null}
{"id": "e9c75347-169d-4ced-bf10-50f53496d927", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 8 * dim  # Adjusted population size for balance\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.6  # Tweaked mutation factor\n        self.crossover_rate = 0.85  # Slightly modified crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n        self.success_rate = 0.15  # Adjusted success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  \n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.15 * (d - a), *self.bounds)  # Adjusted contribution factor\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  \n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)  # Adjusted success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.03)  # Adjusted success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def enhanced_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Adjusted step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(20):  # Tweaked iterations for thorough exploitation\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.55:  # Adjusted exploration phase\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 9)  # Adjusted number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = enhanced_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive algorithm integrating differential evolution and local search for improved exploration-exploitation balance.", "configspace": "", "generation": 95, "fitness": 0.2440279520901073, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.17.", "error": "", "parent_id": "8a16845b-09d1-4480-9c0b-510a7e0d80b0", "metadata": {"aucs": [0.5899282377232875, 0.5649787208849715, 0.5521777961944279, 0.5424755749178519, 0.512220484358646, 0.53528508285361, 0.5524212866442522, 0.5298388180585574, 0.5515158136204484, 0.17362611433155184, 0.1865465145044669, 0.14423294952559806, 0.15948165221818067, 0.21344611588797735, 0.1598264584478306, 0.1092192147820078, 0.16011477572341204, 0.11417667082415717, 0.1198439306991097, 0.127844312763579, 0.11118253207922912, 0.14319251435639746, 0.14548826225213785, 0.13169059157851692, 0.13106539605743583, 0.14167838180694303, 0.11147293996690644, 0.09828585934319012, 0.10690161492053596, 0.12304907055436687, 0.09066866825958642, 0.10531827496678547, 0.10398460785204788, 0.11010375498041158, 0.07814278821605403, 0.11879527724262895, 0.6540515348518009, 0.6315095121031971, 0.7420474565084341, 0.6828291984759862, 0.5315884158449125, 0.7955876824839632, 0.6331595534572381, 0.5827341545606306, 0.6577394123735782, 0.3175205113570644, 0.24915093784799147, 0.2530118318640272, 0.30588848032809446, 0.24787774194667012, 0.326828826122592, 0.27589290778356557, 0.24439642421819618, 0.25769601210206705, 0.46636263810246537, 0.45845212965279103, 0.3699424457370183, 0.499022047676844, 0.3402624912308576, 0.438353438852642, 0.49408277888437313, 0.5338550177726411, 0.3854765395440596, 0.2182121573336281, 0.11362548406197437, 0.19858926577785507, 0.14884636682038543, 0.1720119947202704, 0.18116869714243922, 0.13204369791468218, 0.2424408000753604, 0.1917270196480374, 0.1599028249342711, 0.1169121477359173, 0.2344281297706976, 0.24662646796536336, 0.19669278071585916, 0.1804427511657104, 0.17472637984990413, 0.14147605428196508, 0.18523374163257533, 0.10044096035631478, 0.06162164952139615, 0.06039410807311818, 0.047281505318529926, 0.0417694063553985, 0.04454389454169827, 0.05336758531381802, 0.04138049197273719, 0.08850154680977285, 0.1654003523734665, 0.1280065466581054, 0.19085075042792965, 0.08767896847457957, 0.1428942891552173, 0.14609712148981868, 0.17463883025535654, 0.22973520113461277, 0.16869182363952295, 0.024199711244656696, 0.08315031462528788, 0.032718492998023985, 0.034224653333552846, 0.04767825251626423, 0.038527203600764226, 0.030623093690857806, 0.021982078861020105, 0.07510339645739661, 0.1454387853044089, 0.11900386305374322, 0.1388459121405351, 0.1351698385905754, 0.15868274116078518, 0.13003057434163423, 0.13077292889040948, 0.11055037646808974, 0.09939200545413374, 0.4610153743922639, 0.46223955527386484, 0.46535129948625054, 0.4393662662180913, 0.4209514330710168, 0.42390198653787736, 0.4690287564233018, 0.4469247101839712, 0.4374286615110583, 0.10128048832362324, 0.12921549796150178, 0.11439800358060637, 0.12998971330743003, 0.11560106454116847, 0.133206495510945, 0.13791658113982852, 0.14233821120806023, 0.13995558931736507, 0.1269997821955534, 0.17525711021069235, 0.2241328994017454, 0.23281529857416172, 0.15932407080707967, 0.254453981880829, 0.22889868804826596, 0.14228082088323257, 0.21281025616715143, 0.2535721438402131, 0.2530767982613724, 0.2482533031291667, 0.284832874135614, 0.2575979875660811, 0.2431987654219785, 0.2551737204920279, 0.28078503467772087, 0.26870059162591997, 0.20638460856328367, 0.21574388801919508, 0.20009186417276026, 0.21905163901101643, 0.22963524286588122, 0.20351862965552414, 0.21614062953133528, 0.24264354963693557, 0.20491895393066284, 0.19971738862487654, 0.24066186646638565, 0.2065307719496986, 0.2232675248627335, 0.20140565745591665, 0.2114491688906882, 0.19240357545100706, 0.2049392221608185, 0.20075517475784888, 0.18327582677705023, 0.18140557998167717, 0.19286465058506896, 0.19153498473089614, 0.18863863372919132, 0.1835270448210523, 0.2001150382550564, 0.1663736364737186, 0.18239381075741534, 0.7421942903477706, 0.6421420314090517, 0.19044005645748752, 0.7205477183890242, 0.19849051253294525, 0.19334832165463467, 0.7631061889654598, 0.16540090043474553, 0.597431056086132, 0.42064629763220374, 0.5038612082678219, 0.5450103950136963, 0.40617220109026486, 0.3518123202806176, 0.19801739682941277, 0.38784106634408266, 0.3473491609853109, 0.29175641323719903, 0.2221900351218865, 0.19783337897368314, 0.21583656725636746, 0.22116052961168453, 0.20525284783747777, 0.21898827834321222, 0.21351977982324966, 0.19240969759805704, 0.20926690960612937, 0.08568036666170575, 0.09105943267807393, 0.09247568978169218, 0.09336393346802163, 0.0858384341793349, 0.07764508412991966, 0.0927514761915732, 0.08347225786225243, 0.09402584172504413]}, "mutation_prompt": null}
{"id": "12541250-62e5-4955-9a6e-a23fd240e806", "solution": "import numpy as np\n\nclass AdvancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Slightly increased mutation factor\n        self.crossover_rate = 0.9  # Increased crossover rate for diversity\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.5\n        self.success_rate = 0.1  # Adjusted higher initial success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.3, self.adaptive_mutation_factor)  \n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.25 * (d - a), *self.bounds)  # Increased contribution factor\n                \n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  \n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.04)  # Slightly increased success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)  # Decreased success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def enhanced_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.003  # Increased step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(15):  # Reduced iterations for quick exploitation\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.6:  # Reduced exploration phase\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 10)  # Adjusted number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = enhanced_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "AdvancedAdaptiveDE", "description": "An advanced differential evolution algorithm with adaptive mechanisms for balancing exploration and exploitation.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a16845b-09d1-4480-9c0b-510a7e0d80b0", "metadata": {"aucs": [0.7171544631186488, 0.7283319420527326, 0.7353370813798383, 0.6743631433807067, 0.6844985796985275, 0.7164156112366187, 0.7283414869674292, 0.7268943815790402, 0.7230030533846581, 0.3224800824605867, 0.3304338347792476, 0.14939203647112587, 0.05402162580735659, 0.3625413403318455, 9.999999999998899e-05, 9.999999999998899e-05, 0.10047844621183344, 0.015927946036407903, 0.12919916660537822, 0.12519488933251688, 0.1268944519743631, 0.2003757584411482, 0.13118515635700534, 0.12662767011764442, 0.12103000290573185, 0.10845737571615044, 0.13723891354959106, 0.10281718927735695, 0.08680150328488379, 0.10645286528796283, 0.10898217037085212, 0.08577429277669402, 0.05394548806506905, 0.0904879370187538, 0.09296077357462307, 0.09618305408554284, 0.6108853504528045, 0.6843453685335098, 0.46025266763047534, 0.15473703370145464, 0.1692686092695601, 0.4965177645918416, 0.22003502109594753, 0.5382127011324646, 0.13208778510942443, 0.3199043164027472, 0.3391876094627605, 0.3116474011853013, 0.3186738535174868, 0.3303177648446828, 0.3185607250549387, 0.36201195219597804, 0.299347940416992, 0.3058435413805157, 0.6632273761593555, 0.19318160894951675, 0.1635473825637982, 0.2693074740276833, 0.7168887327282238, 0.7491948860142237, 0.22141706632393388, 0.6788995400457909, 0.5692450470419776, 0.18048243519755147, 0.12292980724981517, 0.18116357478573686, 0.17254158749844262, 0.18381676534408453, 0.15678617492154556, 0.2228001151869925, 0.27745949672345327, 0.17867417844840816, 0.24324615462544708, 0.16317692928152283, 0.18368485904668574, 0.23731486611873265, 0.2640906475878759, 0.30081349883863473, 0.16142119745585548, 0.17081888554444036, 0.26376955209192554, 0.034794225931567, 0.11462536234284726, 0.1107324298361777, 0.1653204376805486, 0.08374277316713363, 0.009827545546078897, 0.05843066734492042, 0.08212115974534295, 0.16337021213721603, 0.34087969890557124, 0.14046661008972583, 0.32008163929952693, 0.10096757134362255, 0.0681642787601422, 0.16615314834700168, 0.15689095555511834, 0.15906396733213823, 0.15827335134087794, 0.09008790701062486, 0.09485408281892216, 0.1455738089144728, 0.06829178668456826, 0.10300775860112044, 0.06431158664285519, 0.08783994087057256, 0.04234830273731294, 0.0608808853075794, 0.19429120353162488, 0.20691775512450228, 0.23504610608229304, 0.17798427057477417, 0.19719113168309232, 0.2331651826647091, 0.13923113582888091, 0.19337455380013413, 0.08463914284300278, 0.5233437119189773, 0.5140002440478674, 0.5226475092798424, 0.5230587203500019, 0.48641556152368626, 0.4336048469789644, 0.5301905752411833, 0.48886855954922204, 0.5726123150295184, 0.10337473908425543, 0.12068862225615651, 0.12629373253290466, 0.12650990348728064, 0.14217911090848334, 0.121849082516716, 0.14108693276803208, 0.13834501263224375, 0.1441341660887474, 0.24754562127624868, 0.18438428495425985, 0.1870424866351319, 0.33812723658953836, 0.2165694682857534, 0.34376943589644093, 0.2747969467491024, 0.15404029792418583, 0.20054562030312595, 0.31152031210008657, 0.32724905455736564, 0.2687283147867392, 0.31683903836674776, 0.29434946345557744, 0.36490529020221874, 0.3072080016555051, 0.3946544295723242, 0.3193299670395281, 0.21554125656755663, 0.24515734287716018, 0.17110674828336736, 0.25740327779170735, 0.24335780157107256, 0.24938174422784587, 0.18599658740013625, 0.28024076155016364, 0.22766143762967017, 0.197547501949485, 0.22586226596457137, 0.21253501361671534, 0.19950844090758302, 0.20491172303965266, 0.20319893680490297, 0.2229714777377798, 0.2197114229628513, 0.2237334643327311, 0.17767744009751063, 0.2260496617495351, 0.1804949743282923, 0.23966411017886768, 0.24683647083337878, 0.23749421491267808, 0.1875067973504655, 0.34921175597525966, 0.17046659108078255, 0.7009351848836809, 0.7238067286279656, 0.18067966556995074, 0.7675115135567829, 0.19812697638894639, 0.8160123040432697, 0.7247499986811357, 0.1921315311256786, 0.7197593682666084, 0.7534095343952784, 0.48264912226153334, 0.6504918743714574, 0.4524073991287455, 0.1994242871336933, 0.18968762601428824, 0.3274849133742359, 0.3706916729462427, 0.20538083554634623, 0.2135192940880012, 0.18762046867345783, 0.20471933919808016, 0.19583771487143464, 0.18344705608395362, 0.18837451330330268, 0.1892820402138271, 0.18581047854662225, 0.227138635764632, 0.09535969792520593, 0.08500967880802668, 0.08897783129480319, 0.08267754345158229, 0.09295794438334848, 0.11610843563054407, 0.08423935260679283, 0.08944723435060187, 0.09482538929601558]}, "mutation_prompt": null}
{"id": "17f31197-2173-4f1e-bef6-aa5c45b74389", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Adjusted population size for balance\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.65  # Fine-tuned mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n        self.success_rate = 0.08  # Recalibrated initial success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  \n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - a), *self.bounds)  # Adjusted contribution factor\n\n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  \n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjusted success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjusted success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def enhanced_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Fine-tuned step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(20):  # Adjusted iterations for thorough exploitation\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.5:  # Adjusted exploration to exploitation ratio\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 8)  # Modified number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = enhanced_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDE", "description": "A refined Adaptive Differential Evolution with enhanced local search and strategic budget allocation for improved convergence.", "configspace": "", "generation": 97, "fitness": 0.27900061808634713, "feedback": "The algorithm RefinedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.20.", "error": "", "parent_id": "8a16845b-09d1-4480-9c0b-510a7e0d80b0", "metadata": {"aucs": [0.6717232270746841, 0.6690746887678944, 0.6598611590261947, 0.6647555712128408, 0.6468094816069534, 0.6245911368171925, 0.6594992228618854, 0.6555608256748849, 0.6268686121236359, 0.2932936756856178, 0.34832573316028936, 0.3113750354573742, 0.09654424835294506, 0.26537403319442776, 0.31292652399984544, 0.29463017323827045, 0.2940754358159112, 0.2314140117167549, 0.10912109527675962, 0.15087419094659693, 0.11858378927241175, 0.13738489274481203, 0.13255861688643855, 0.1450879401110058, 0.3332897719244816, 0.1291758064781774, 0.12648698840782924, 0.11177645277716952, 0.11441055226573604, 0.0968277420963275, 0.0976864418997615, 0.09614749794493527, 0.13234199252760992, 0.1533871252600928, 0.12253088972799087, 0.10710775637123893, 0.7647767616515769, 0.7467856404666104, 0.6510804681995188, 0.6912431278123705, 0.7101703278541329, 0.7991791949044778, 0.7525689675840336, 0.8121329621742598, 0.18638502087032427, 0.3543306394076019, 0.34113341106921735, 0.33086521538062674, 0.34587314292648097, 0.35831694484593446, 0.3649038153836949, 0.3341690489065666, 0.31582345363670317, 0.3123750908873354, 0.7026755033724965, 0.5651718177291806, 0.51357364875252, 0.7080998126651391, 0.655214024401792, 0.2479336636141971, 0.1605454829863615, 0.6617421068699245, 0.5461427887188429, 0.16966074655155172, 0.1763272716795694, 0.15596120659508272, 0.22106628384969984, 0.2604150559093037, 0.16702142194665448, 0.18230637304020536, 0.22233589443363466, 0.18574373854460424, 0.2339162124223868, 0.16863957816074981, 0.18158437962996565, 0.17207854394363276, 0.15902796526559382, 0.2603692878717646, 0.1774013014433794, 0.20233383254416737, 0.17638818142164658, 0.11329702383869411, 0.11724533729705744, 0.12843667366873812, 0.10685158603339495, 0.09586204272505983, 0.025958128262083324, 0.06146188531706631, 0.14065381882809747, 0.1360662742902634, 0.2309836949394517, 0.1403599098507362, 0.16470306053204697, 0.17898259429042207, 0.05790981699389264, 0.210400443963091, 0.2114117069574062, 0.1161194895059594, 0.11600920188810138, 0.0820516630038346, 0.05963460963984457, 0.04152049802132829, 0.053129120526786755, 0.06686151234941995, 0.06669052338547976, 0.05419532530363502, 0.04330207221780202, 0.04199538529251001, 0.1705691807469315, 0.16815463779432072, 0.16072903733938781, 0.1479031302487287, 0.194093652554035, 0.18794492075634062, 0.17596520178807185, 0.18219205801220695, 0.15706876253381374, 0.5221803014575084, 0.525693625362312, 0.5021273629596705, 0.5330063040048988, 0.48615617424408475, 0.5029070830518247, 0.5108974528569084, 0.49899278822764714, 0.49066255904741507, 0.15424958709802727, 0.12471558589704668, 0.11441113031888983, 0.1366858933704238, 0.12930639110512454, 0.12566197072958185, 0.13277789520820116, 0.13496832180389662, 0.10319329998890303, 0.15942743973542384, 0.1955771184410593, 0.220297356952319, 0.19183539205873812, 0.14687987569460415, 0.22429479171124678, 0.17717290980595535, 0.22149770796850976, 0.2124081600084824, 0.2837989730110765, 0.2579532835249412, 0.2988480481679361, 0.2783783985374746, 0.29203259224922595, 0.2984482406731902, 0.33331620589224764, 0.3156219264990735, 0.30298245847786154, 0.217312176346677, 0.2077144677042997, 0.19745772879354173, 0.1997286887261157, 0.24260323645651138, 0.2491994595489183, 0.23942804339997503, 0.23828288845684742, 0.22713255311891212, 0.21725164945072462, 0.19378117639199588, 0.21752966100764126, 0.2101291495712141, 0.19337951412747623, 0.19040676115362298, 0.27108262439863307, 0.19072913575696204, 0.20143528655203935, 0.22086602890496465, 0.21507269354183878, 0.19974899249883016, 0.18635392597242462, 0.1899371477805355, 0.2021443995475849, 0.2080852250412628, 0.18802414034232695, 0.19618389122910307, 0.7727904613808506, 0.1774400330648317, 0.8328686702699424, 0.6875307937991855, 0.1980802239773466, 0.8219477347356935, 0.5959687994574003, 0.1911027314207594, 0.716955037104057, 0.7060061033816762, 0.5923121314946364, 0.5055043324572788, 0.5179786562220488, 0.5164597183310988, 0.37883865313753995, 0.15893652387438229, 0.4665095862048161, 0.30696922929490145, 0.20315252180218235, 0.21048454480791123, 0.22834543970033494, 0.21543685608006147, 0.21556581155211196, 0.20859848529146308, 0.21946401124075432, 0.21428998523704812, 0.21845135124375004, 0.09440751106627354, 0.07805869797391352, 0.10336702914264773, 0.07739543565304152, 0.07790642985771357, 0.08553624237888957, 0.0879613633204368, 0.08337737930165512, 0.09378406170110187]}, "mutation_prompt": null}
{"id": "5aab7c9d-b6dd-446c-ae75-4767ca804978", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Adjusted population size for balance\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # Fine-tuned mutation factor\n        self.crossover_rate = 0.9  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.8\n        self.success_rate = 0.1  # Recalibrated initial success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  \n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.1 * (d - a), *self.bounds)  # Adjusted contribution factor\n\n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  \n                trial[crossover] = mutant[crossover]\n\n                trial_val, current_val = func(trial), func(population[i])\n\n                if trial_val < current_val:\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.05)  # Adjusted success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.02)  # Adjusted success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def dynamic_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.005  # Fine-tuned step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(25):  # Adjusted iterations for thorough exploitation\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n                    step_size *= 1.05  # Increase step size upon improvement\n                else:\n                    step_size *= 0.95  # Decrease step size if no improvement\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.6:  # Adjusted exploration to exploitation ratio\n                population = sorted(population, key=func)\n                best_count = max(3, self.population_size // 6)  # Modified number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = dynamic_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "EnhancedAdaptiveDE", "description": "Enhanced Adaptive Differential Evolution with dynamic step size adaptation and strategic mutation factor tuning for improved convergence.", "configspace": "", "generation": 98, "fitness": 0.25071112771623444, "feedback": "The algorithm EnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "17f31197-2173-4f1e-bef6-aa5c45b74389", "metadata": {"aucs": [0.5860283754920077, 0.5782319185302364, 0.5758797755745009, 0.5998066038476446, 0.5762092066906418, 0.6011025799512568, 0.5801045940680352, 0.5984002444554832, 0.5905876042863198, 0.15912038658647942, 0.1475346520985984, 0.157325021221301, 0.14745028936452453, 0.12101456808915645, 0.17078592162319473, 0.16938967769047486, 0.17098503560822265, 0.1431453115916569, 0.13060340331583198, 0.10067070425298097, 0.10847094202220886, 0.1385744920699994, 0.10804992708573169, 0.09911985414852587, 0.1029627734732319, 0.11126912590668958, 0.11341413200423489, 0.10098798695290856, 0.09962882628374647, 0.08363381539913284, 0.11014756883352306, 0.08894303588676888, 0.08633756438452733, 0.06924832450554819, 0.09883948686686217, 0.07862684778092122, 0.8354478852570191, 0.8104329278906464, 0.7688832993371486, 0.7667260312065307, 0.8488915924374818, 0.6694421278472196, 0.8833405418792966, 0.6819064103454588, 0.8520681580571421, 0.43209204932106393, 0.3248989638644464, 0.36419597510943724, 0.4025365368877861, 0.3149831807473422, 0.3903979750673996, 0.3445013234582398, 0.3582167661736527, 0.3804804277428223, 0.33965894750608827, 0.38625546218525264, 0.34414785425321703, 0.5114332178045142, 0.33947211398867905, 0.4422637290974346, 0.5647689792647776, 0.45140395378419884, 0.5819042638873592, 0.1605360416849564, 0.17838116792218572, 0.1687822632199193, 0.1514342576567902, 0.16415292645772228, 0.18474836942457973, 0.18253126140975162, 0.22121290554891615, 0.2753618862599203, 0.21129485345798094, 0.1596323868798103, 0.25371779085939417, 0.3165065588032122, 0.17677566332620465, 0.3105743169299223, 0.21702498106935364, 0.1544336147087041, 0.3053677212448932, 0.03845765280057878, 0.062089580377399534, 0.08254358715575161, 0.06453322368230252, 0.06798449167410658, 0.040705905885792926, 0.07415180804753163, 0.03851156714210047, 0.08307910445496614, 0.13016713263789514, 0.15963236256889846, 0.12280021568964838, 0.13093522126112056, 0.12556734979126527, 0.154651782927975, 0.1869433626777678, 0.15196965714875965, 0.1838618730618825, 0.03516334181304415, 0.03587762931606853, 0.07645885644502959, 0.04301519309495527, 0.06258532020958774, 0.05706954387585084, 0.04043058268707678, 0.03255569770579636, 0.03467534987268428, 0.16578486938238435, 0.13626684423518565, 0.1757972703367202, 0.15633240957308392, 0.17098471833854656, 0.14494600143674774, 0.16979875977169778, 0.16312471294490427, 0.1729320023146672, 0.468579187734641, 0.4722683638728905, 0.5267941068571131, 0.44538540351231704, 0.5104277964393374, 0.48026351134651435, 0.4649501239888809, 0.47463693163141896, 0.4911484343653897, 0.09080279849593376, 0.12487993014214649, 0.10483287012102194, 0.11044867538996661, 0.10774428414485393, 0.10041348623501711, 0.07938500266299875, 0.1060369012528738, 0.09250881181052772, 0.17424006782440016, 0.15924346436950365, 0.1621850950165219, 0.22494538497078653, 0.18694098010041194, 0.20955049905232148, 0.2728325298821638, 0.18034047766861583, 0.1725143086509373, 0.23395858871378217, 0.2309915246771258, 0.23001692306360055, 0.23471367293470724, 0.22019547921430216, 0.20423928435389294, 0.24474053021021414, 0.2401047032961735, 0.22201752204088876, 0.17244539177933693, 0.16480255983859915, 0.20582586187085072, 0.1695738877768277, 0.1742477386010598, 0.15864776390996327, 0.22131909290980378, 0.23342396090657236, 0.17604957920551767, 0.210853788386124, 0.2231245429720463, 0.19094839699351251, 0.19358355377735137, 0.1997193653682573, 0.2300579843613153, 0.19247175663239036, 0.2007697618952906, 0.23124174291512545, 0.20415307804558747, 0.1914015945057519, 0.4279516598425618, 0.19529076706564386, 0.2385932193336241, 0.2069467060991027, 0.1785679805793583, 0.25087170142828097, 0.18104312473634177, 0.6189754383728796, 0.19726771026490897, 0.21080201430073087, 0.17214365214749228, 0.2008628492327562, 0.1966336766669916, 0.8304873481725592, 0.1861673685244557, 0.2017234680628207, 0.5493872196426528, 0.20844137796143336, 0.44012943661262993, 0.42084661680083324, 0.33666368637121824, 0.4885337802468662, 0.20823624588547363, 0.47396103784023713, 0.4651727469035627, 0.20957837217254527, 0.20075465009894078, 0.1981624882368077, 0.19731912283394892, 0.19901381759117853, 0.2016229439484909, 0.21367184633925984, 0.21454643440705423, 0.2098596306729209, 0.07270873019421564, 0.0974571429345018, 0.07173135883061399, 0.08810522879238636, 0.09474494162496616, 0.08958680663856344, 0.08622588478416204, 0.08657707632861888, 0.07806199693781057]}, "mutation_prompt": null}
{"id": "cb76b2b1-9656-44c5-9ca7-41e66875a734", "solution": "import numpy as np\n\nclass RefinedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = 5 * dim  # Adjusted population size for balance\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.65  # Fine-tuned mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.evaluations = 0\n        self.adaptive_mutation_factor = 0.6\n        self.success_rate = 0.08  # Recalibrated initial success rate\n\n    def __call__(self, func):\n        def differential_evolution(population):\n            new_population = []\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d = population[indices[0]], population[indices[1]], population[indices[2]], population[indices[3]]\n\n                if np.random.rand() < self.success_rate:\n                    self.mutation_factor = np.random.uniform(0.4, self.adaptive_mutation_factor)  \n\n                mutant = np.clip(a + self.mutation_factor * (b - c) + 0.2 * (d - a), *self.bounds)  # Adjusted contribution factor\n\n                trial = np.copy(population[i])\n                crossover = np.random.uniform(size=self.dim) < self.crossover_rate  \n                trial[crossover] = mutant[crossover]\n\n                if func(trial) < func(population[i]):\n                    new_population.append(trial)\n                    self.success_rate = min(1.0, self.success_rate + 0.03)  # Adjusted success rate increment\n                else:\n                    new_population.append(population[i])\n                    self.success_rate = max(0.01, self.success_rate - 0.01)  # Adjusted success rate decrement\n\n                self.evaluations += 1\n                if self.evaluations >= self.budget:\n                    return new_population\n            return new_population\n        \n        def enhanced_local_search(individual):\n            step_size = (self.bounds[1] - self.bounds[0]) * 0.002  # Fine-tuned step size\n            best_local = np.copy(individual)\n            best_val = func(best_local)\n\n            for _ in range(20):  # Adjusted iterations for thorough exploitation\n                perturbation = np.random.normal(0, step_size, self.dim)\n                candidate = np.clip(best_local + perturbation, *self.bounds)\n\n                candidate_val = func(candidate)\n                self.evaluations += 1\n                if candidate_val < best_val:\n                    best_local, best_val = candidate, candidate_val\n\n                if self.evaluations >= self.budget:\n                    break\n\n            return best_local\n\n        population = np.random.uniform(*self.bounds, (self.population_size, self.dim))\n        \n        while self.evaluations < self.budget:\n            population = differential_evolution(population)\n\n            if self.evaluations < self.budget * 0.5:  # Adjusted exploration to exploitation ratio\n                population = sorted(population, key=func)\n                best_count = max(2, self.population_size // 8)  # Modified number of best individuals\n                for i in range(min(best_count, len(population))):\n                    population[i] = enhanced_local_search(population[i])\n                    if self.evaluations >= self.budget:\n                        break\n\n        best_individual = min(population, key=func)\n        return best_individual", "name": "RefinedAdaptiveDE", "description": "A refined Adaptive Differential Evolution with enhanced local search and strategic budget allocation for improved convergence.", "configspace": "", "generation": 98, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "17f31197-2173-4f1e-bef6-aa5c45b74389", "metadata": {"aucs": [0.6717232270746841, 0.6690746887678944, 0.6598611590261947, 0.6647555712128408, 0.6468094816069534, 0.6245911368171925, 0.6594992228618854, 0.6555608256748849, 0.6268686121236359, 0.2932936756856178, 0.34832573316028936, 0.3113750354573742, 0.09654424835294506, 0.26537403319442776, 0.31292652399984544, 0.29463017323827045, 0.2940754358159112, 0.2314140117167549, 0.10912109527675962, 0.15087419094659693, 0.11858378927241175, 0.13738489274481203, 0.13255861688643855, 0.1450879401110058, 0.3332897719244816, 0.1291758064781774, 0.12648698840782924, 0.11177645277716952, 0.11441055226573604, 0.0968277420963275, 0.0976864418997615, 0.09614749794493527, 0.13234199252760992, 0.1533871252600928, 0.12253088972799087, 0.10710775637123893, 0.7647767616515769, 0.7467856404666104, 0.6510804681995188, 0.6912431278123705, 0.7101703278541329, 0.7991791949044778, 0.7525689675840336, 0.8121329621742598, 0.18638502087032427, 0.3543306394076019, 0.34113341106921735, 0.33086521538062674, 0.34587314292648097, 0.35831694484593446, 0.3649038153836949, 0.3341690489065666, 0.31582345363670317, 0.3123750908873354, 0.7026755033724965, 0.5651718177291806, 0.51357364875252, 0.7080998126651391, 0.655214024401792, 0.2479336636141971, 0.1605454829863615, 0.6617421068699245, 0.5461427887188429, 0.16966074655155172, 0.1763272716795694, 0.15596120659508272, 0.22106628384969984, 0.2604150559093037, 0.16702142194665448, 0.18230637304020536, 0.22233589443363466, 0.18574373854460424, 0.2339162124223868, 0.16863957816074981, 0.18158437962996565, 0.17207854394363276, 0.15902796526559382, 0.2603692878717646, 0.1774013014433794, 0.20233383254416737, 0.17638818142164658, 0.11329702383869411, 0.11724533729705744, 0.12843667366873812, 0.10685158603339495, 0.09586204272505983, 0.025958128262083324, 0.06146188531706631, 0.14065381882809747, 0.1360662742902634, 0.2309836949394517, 0.1403599098507362, 0.16470306053204697, 0.17898259429042207, 0.05790981699389264, 0.210400443963091, 0.2114117069574062, 0.1161194895059594, 0.11600920188810138, 0.0820516630038346, 0.05963460963984457, 0.04152049802132829, 0.053129120526786755, 0.06686151234941995, 0.06669052338547976, 0.05419532530363502, 0.04330207221780202, 0.04199538529251001, 0.1705691807469315, 0.16815463779432072, 0.16072903733938781, 0.1479031302487287, 0.194093652554035, 0.18794492075634062, 0.17596520178807185, 0.18219205801220695, 0.15706876253381374, 0.5221803014575084, 0.525693625362312, 0.5021273629596705, 0.5330063040048988, 0.48615617424408475, 0.5029070830518247, 0.5108974528569084, 0.49899278822764714, 0.49066255904741507, 0.15424958709802727, 0.12471558589704668, 0.11441113031888983, 0.1366858933704238, 0.12930639110512454, 0.12566197072958185, 0.13277789520820116, 0.13496832180389662, 0.10319329998890303, 0.15942743973542384, 0.1955771184410593, 0.220297356952319, 0.19183539205873812, 0.14687987569460415, 0.22429479171124678, 0.17717290980595535, 0.22149770796850976, 0.2124081600084824, 0.2837989730110765, 0.2579532835249412, 0.2988480481679361, 0.2783783985374746, 0.29203259224922595, 0.2984482406731902, 0.33331620589224764, 0.3156219264990735, 0.30298245847786154, 0.217312176346677, 0.2077144677042997, 0.19745772879354173, 0.1997286887261157, 0.24260323645651138, 0.2491994595489183, 0.23942804339997503, 0.23828288845684742, 0.22713255311891212, 0.21725164945072462, 0.19378117639199588, 0.21752966100764126, 0.2101291495712141, 0.19337951412747623, 0.19040676115362298, 0.27108262439863307, 0.19072913575696204, 0.20143528655203935, 0.22086602890496465, 0.21507269354183878, 0.19974899249883016, 0.18635392597242462, 0.1899371477805355, 0.2021443995475849, 0.2080852250412628, 0.18802414034232695, 0.19618389122910307, 0.7727904613808506, 0.1774400330648317, 0.8328686702699424, 0.6875307937991855, 0.1980802239773466, 0.8219477347356935, 0.5959687994574003, 0.1911027314207594, 0.716955037104057, 0.7060061033816762, 0.5923121314946364, 0.5055043324572788, 0.5179786562220488, 0.5164597183310988, 0.37883865313753995, 0.15893652387438229, 0.4665095862048161, 0.30696922929490145, 0.20315252180218235, 0.21048454480791123, 0.22834543970033494, 0.21543685608006147, 0.21556581155211196, 0.20859848529146308, 0.21946401124075432, 0.21428998523704812, 0.21845135124375004, 0.09440751106627354, 0.07805869797391352, 0.10336702914264773, 0.07739543565304152, 0.07790642985771357, 0.08553624237888957, 0.0879613633204368, 0.08337737930165512, 0.09378406170110187]}, "mutation_prompt": null}
