{"id": "d3775667-9c06-4b44-b938-4764831f96f0", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Gaussian perturbation\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                else:\n                    new_population[i] = self.population[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Gaussian Perturbation to balance exploration and exploitation for efficient optimization.", "configspace": "", "generation": 0, "fitness": 0.15676162975803298, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.16.", "error": "", "parent_id": null, "metadata": {"aucs": [0.32428640920739915, 0.3154824181049416, 0.3297692794688508, 0.34842750306188697, 0.34396123878181095, 0.3541487768318953, 0.3358338266340126, 0.32211919614021156, 0.3096524952684442, 0.0037658854197805125, 0.024250618451999273, 0.012055535679174278, 0.016608787723488394, 0.007241019967701656, 0.0009356047693493963, 0.03923131918693312, 0.007555013943997824, 0.0211548937996906, 0.06844669800381364, 0.08051545007007022, 0.0734883260129563, 0.08118426111277877, 0.08986057858827678, 0.06942159872307851, 0.06688566260992124, 0.05875868139571483, 0.0817739061428252, 0.05879077059780069, 0.06281739687613175, 0.06510533593180212, 0.059533279202877765, 0.06053295066670161, 0.056846540703520465, 0.06541279090050633, 0.0674236440702769, 0.06429603054400979, 0.8121092905629803, 0.7648625814164364, 0.8275063957656146, 0.792021651237925, 0.7311044343241428, 0.7835159075216597, 0.8087460737870011, 0.8075687266746354, 0.8531425156938175, 0.13954302952582132, 0.12686256852055122, 0.13692618843883753, 0.16698679201900668, 0.14468187262519072, 0.15191260409975238, 0.1512601632702899, 0.17019126321047462, 0.1478947636040997, 0.21219370518350944, 0.21942012913599718, 0.21255693644295826, 0.22711166672100047, 0.2237938880261855, 0.22680649392848096, 0.22998137046525768, 0.22887777349623362, 0.195405701142072, 0.09212970700653988, 0.09138789194236652, 0.09176297748941942, 0.08762874524701036, 0.1027350828099789, 0.07583054009651113, 0.08172376511424484, 0.1055089420786981, 0.07677515449466554, 0.07538081367070393, 0.08499770902105974, 0.11587208039453922, 0.07356567966758865, 0.07991883463516947, 0.09972364729552685, 0.09132318300036968, 0.06298308027550281, 0.07860940610817246, 0.0012725160879776265, 0.0037898944914129817, 0.0014868243948767956, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08954051013003572, 0.0770640386549648, 0.06479041977486943, 0.055261031279867034, 0.056715963856586504, 0.09470267579520719, 0.05927187599976569, 0.07531840599986606, 0.058423176602118265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04340683946384083, 0.051616297750799456, 0.05623149064097799, 0.04842840917739866, 0.06031287726405521, 0.054473584919193074, 0.058699446644910336, 0.04411315851971176, 0.048819994945669354, 0.29372509801594493, 0.3041350800648249, 0.3108544704012868, 0.31702412129463753, 0.3043916968388525, 0.3095817525757004, 0.314375814527855, 0.31539152889234034, 0.2911746646357236, 0.07415205113834822, 0.0716424796482592, 0.07493864736569267, 0.07193433702075325, 0.06896259604468102, 0.07232072021416769, 0.07292219118459198, 0.061653148617817566, 0.07212910654040061, 0.12734842000040314, 0.1560599216292332, 0.15770894313640116, 0.13763336593021214, 0.12753845132356778, 0.13675568696150386, 0.1566046103715697, 0.12351333946679732, 0.13695857858099514, 0.21868948315128067, 0.21253137681234124, 0.208241717735537, 0.21894471394646076, 0.19877896543902907, 0.20052128763113297, 0.2305628765792509, 0.2175263005791832, 0.21286706302291702, 0.15234272945103022, 0.13997149498563122, 0.15370435892590517, 0.13951482101072454, 0.14205939321229488, 0.13848020038730136, 0.16091313070567193, 0.1574508437007358, 0.1395066905557818, 0.1623226022907731, 0.17871037786875643, 0.16196568603052963, 0.1594763701533326, 0.1675285411516757, 0.18841873814340637, 0.1659575860375726, 0.15920014280829964, 0.1572463918521826, 0.16011163726662925, 0.15781672560889415, 0.15491120461670593, 0.15771698823777291, 0.1553134881300653, 0.16138969464365238, 0.1544335193359877, 0.1566644408039285, 0.16574394358492883, 0.14346769226802503, 0.2329587479500913, 0.34504430393115215, 0.1601122790240861, 0.20472044081769514, 0.14786540657354186, 0.1658811514730658, 0.1796169992164416, 0.14602190822062544, 0.20131031760045892, 0.16862571396987913, 0.15564420242687937, 0.158858776641304, 0.15841283397749006, 0.13570312744838176, 0.2549735474000474, 0.2663609141514186, 0.1789323576128239, 0.17864435104140974, 0.1713574773368779, 0.17194432012175298, 0.17614676308974153, 0.176969520246538, 0.17328879843160738, 0.17507273241991284, 0.18676486571134732, 0.17221943524555994, 0.05321401396159531, 0.058801054006922815, 0.04716498205541808, 0.06158122050325843, 0.06551577207663506, 0.05646990411043584, 0.05773115292455255, 0.06504356217941909, 0.06545014857213138]}, "mutation_prompt": null}
{"id": "4c83805a-b3e5-41e0-9b52-392f24214dd9", "solution": "import numpy as np\nfrom sklearn.ensemble import RandomForestRegressor\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.evaluated_solutions = []\n        self.fitness_values = []\n\n    def __call__(self, func):\n        evaluations = 0\n        rf_model = RandomForestRegressor()\n        \n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                if len(self.evaluated_solutions) >= 5:\n                    rf_model.fit(self.evaluated_solutions, self.fitness_values)\n                    predicted_fitness = rf_model.predict([trial])[0]\n                    if predicted_fitness < self.best_fitness:\n                        trial_fitness = func(trial)\n                    else:\n                        trial_fitness = func(self.population[i])\n                else:\n                    trial_fitness = func(trial)\n                \n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial\n                else:\n                    new_population[i] = self.population[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial\n\n                self.evaluated_solutions.append(trial)\n                self.fitness_values.append(trial_fitness)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with Random Forest-assisted mutation to improve convergence efficiency through adaptive learning.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "d3775667-9c06-4b44-b938-4764831f96f0", "metadata": {}, "mutation_prompt": null}
{"id": "f18ee2fa-4a1a-48c5-bf81-00356753d8a9", "solution": "import numpy as np\n\nclass MemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def local_search(self, individual):\n        perturbation = np.random.normal(0, 0.05, self.dim)\n        perturbed = individual + perturbation\n        return np.clip(perturbed, *self.bounds)\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Gaussian perturbation\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                else:\n                    new_population[i] = self.population[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            # Local search on the best found solution\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                local_candidate = self.local_search(new_population[i])\n                local_fitness = func(local_candidate)\n                evaluations += 1\n                if local_fitness < func(new_population[i]):\n                    new_population[i] = local_candidate\n                    if local_fitness < self.best_fitness:\n                        self.best_fitness = local_fitness\n                        self.best_solution = local_candidate\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "MemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with Gaussian Perturbation and Local Search to enhance convergence speed and accuracy.", "configspace": "", "generation": 2, "fitness": 0.14161567094303237, "feedback": "The algorithm MemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.13.", "error": "", "parent_id": "d3775667-9c06-4b44-b938-4764831f96f0", "metadata": {"aucs": [0.27585558096801355, 0.29075168503641247, 0.29685124155974996, 0.26384395341558475, 0.2858418440724757, 0.30552592864985917, 0.2960170165528837, 0.2721719290103637, 0.2754986820892483, 0.003099163823017115, 0.00286900695805814, 0.0019243418793241096, 0.002903674859259575, 0.002584626036650106, 0.007010412696562662, 0.00010525465424437996, 0.0029492176972522044, 0.013377962830570689, 0.06149815574962325, 0.07148650193459039, 0.08079333927659138, 0.07371872622266074, 0.08392145889549663, 0.07308973711588296, 0.08345798769002011, 0.07766843694229897, 0.09686365235406191, 0.05032902091697311, 0.045550214268054834, 0.05680787663770048, 0.06440763513034709, 0.07029674028635968, 0.06869432586934177, 0.06936796326374639, 0.054312527457953674, 0.06385588755500615, 0.4756785487585091, 0.6148619699094423, 0.6842234752987608, 0.763623309138487, 0.6872566323770433, 0.5443462366891647, 0.6931003595663916, 0.6342548738086808, 0.681732465263023, 0.10711673712848657, 0.10634985105464945, 0.0962384715143737, 0.09137151352943551, 0.07994925191154345, 0.0983943053488332, 0.11871144855333482, 0.09040919204325715, 0.10184911477325209, 0.16934084098537183, 0.19094343806762826, 0.16666965118291588, 0.17167450441209653, 0.22333717079608983, 0.27857997324422556, 0.1836855284925144, 0.19442585158652392, 0.1560444432334247, 0.07754592005610561, 0.057475877976229106, 0.06349047999156987, 0.09539603373668959, 0.09626615197624089, 0.042887514008355554, 0.12804546603512157, 0.08052160934614472, 0.0579300812443162, 0.07333984019968198, 0.08085446814730535, 0.048465665064508556, 0.04461523644679788, 0.06053884914691976, 0.07997955910584609, 0.03239317799184538, 0.05337122127585514, 0.04483937816978045, 0.001347584968268034, 0.007463041852473373, 9.999999999998899e-05, 0.006685738931715424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.102204174318976, 0.06785547064944386, 0.08813528901173906, 0.0909216941626364, 0.0670489383641305, 0.07117022550545171, 0.10291887921857978, 0.06677749651187481, 0.07395302403119663, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05062875354276419, 0.034314008294383025, 0.04840218738431723, 0.025055997747397307, 0.043817455600478894, 0.041200302338356254, 0.049005890979640365, 0.04557987879380343, 0.05444924609383106, 0.2697173016126241, 0.25196852300424233, 0.2867726012599522, 0.2870918703281713, 0.2589163552646362, 0.30557790447620714, 0.3113866135378859, 0.24684848686604666, 0.2421163273820588, 0.07782056394132453, 0.08275904268006617, 0.08914883440288268, 0.08221942436521401, 0.06563921953833274, 0.08513836114583517, 0.07525014225089421, 0.06993645401437498, 0.07219840246690368, 0.17009886138645158, 0.1682510085613188, 0.1507179516057887, 0.17152322215871463, 0.1739548682112485, 0.15379531669663615, 0.18286283627852695, 0.22750053033370332, 0.15926715441517558, 0.19484088298280045, 0.18520127001775655, 0.1714676785126802, 0.1823460505064861, 0.1744067748508784, 0.1654067977592918, 0.18478029868011592, 0.19803061693783652, 0.17947043075551283, 0.12595190106633758, 0.13755212637453806, 0.12173536956800113, 0.11980680242997965, 0.10561106100346096, 0.12978897134485445, 0.1447827449552317, 0.14261295301085897, 0.1451736217646601, 0.17858647022227647, 0.16486018185060325, 0.1873711978770921, 0.18254833939379655, 0.18201385345675547, 0.16548929068178697, 0.16968210247087812, 0.17524829924521712, 0.1788263152491527, 0.15918077214173076, 0.15531567171080407, 0.16635541549211263, 0.15576981706650406, 0.15187323441425216, 0.14771082827229254, 0.14785833740654875, 0.15842506334191808, 0.18080025414713052, 0.14545930258280237, 0.1503578845091741, 0.18902666439446214, 0.15931769439374688, 0.1627488640337802, 0.1422486655503168, 0.1866326409105843, 0.1422954355000231, 0.1651688337699304, 0.17803565931800136, 0.18576281899428015, 0.22785081419453102, 0.14393522369641965, 0.223370435002317, 0.14910737232408722, 0.1835410890740231, 0.27244914014238086, 0.19565818249610323, 0.19254439982389437, 0.20445623511163835, 0.190050043996853, 0.19194523329834023, 0.20349902284866206, 0.18549350791375752, 0.1818158159040245, 0.1707685910768938, 0.16592108893504753, 0.06668670051588921, 0.07000799009130165, 0.054125603752609774, 0.06856385637565288, 0.05602141262723104, 0.060915268304699066, 0.0580749940321319, 0.06164470053170645, 0.06026108527586871]}, "mutation_prompt": null}
{"id": "a5d2d6f4-b0d0-4fd4-9a3c-5d062e9ba4a0", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 10 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Gaussian perturbation\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                else:\n                    new_population[i] = self.population[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Gaussian Perturbation to balance exploration and exploitation for efficient optimization.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d3775667-9c06-4b44-b938-4764831f96f0", "metadata": {"aucs": [0.32428640920739915, 0.3154824181049416, 0.3297692794688508, 0.34842750306188697, 0.34396123878181095, 0.3541487768318953, 0.3358338266340126, 0.32211919614021156, 0.3096524952684442, 0.0037658854197805125, 0.024250618451999273, 0.012055535679174278, 0.016608787723488394, 0.007241019967701656, 0.0009356047693493963, 0.03923131918693312, 0.007555013943997824, 0.0211548937996906, 0.06844669800381364, 0.08051545007007022, 0.0734883260129563, 0.08118426111277877, 0.08986057858827678, 0.06942159872307851, 0.06688566260992124, 0.05875868139571483, 0.0817739061428252, 0.05879077059780069, 0.06281739687613175, 0.06510533593180212, 0.059533279202877765, 0.06053295066670161, 0.056846540703520465, 0.06541279090050633, 0.0674236440702769, 0.06429603054400979, 0.8121092905629803, 0.7648625814164364, 0.8275063957656146, 0.792021651237925, 0.7311044343241428, 0.7835159075216597, 0.8087460737870011, 0.8075687266746354, 0.8531425156938175, 0.13954302952582132, 0.12686256852055122, 0.13692618843883753, 0.16698679201900668, 0.14468187262519072, 0.15191260409975238, 0.1512601632702899, 0.17019126321047462, 0.1478947636040997, 0.21219370518350944, 0.21942012913599718, 0.21255693644295826, 0.22711166672100047, 0.2237938880261855, 0.22680649392848096, 0.22998137046525768, 0.22887777349623362, 0.195405701142072, 0.09212970700653988, 0.09138789194236652, 0.09176297748941942, 0.08762874524701036, 0.1027350828099789, 0.07583054009651113, 0.08172376511424484, 0.1055089420786981, 0.07677515449466554, 0.07538081367070393, 0.08499770902105974, 0.11587208039453922, 0.07356567966758865, 0.07991883463516947, 0.09972364729552685, 0.09132318300036968, 0.06298308027550281, 0.07860940610817246, 0.0012725160879776265, 0.0037898944914129817, 0.0014868243948767956, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08954051013003572, 0.0770640386549648, 0.06479041977486943, 0.055261031279867034, 0.056715963856586504, 0.09470267579520719, 0.05927187599976569, 0.07531840599986606, 0.058423176602118265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04340683946384083, 0.051616297750799456, 0.05623149064097799, 0.04842840917739866, 0.06031287726405521, 0.054473584919193074, 0.058699446644910336, 0.04411315851971176, 0.048819994945669354, 0.29372509801594493, 0.3041350800648249, 0.3108544704012868, 0.31702412129463753, 0.3043916968388525, 0.3095817525757004, 0.314375814527855, 0.31539152889234034, 0.2911746646357236, 0.07415205113834822, 0.0716424796482592, 0.07493864736569267, 0.07193433702075325, 0.06896259604468102, 0.07232072021416769, 0.07292219118459198, 0.061653148617817566, 0.07212910654040061, 0.12734842000040314, 0.1560599216292332, 0.15770894313640116, 0.13763336593021214, 0.12753845132356778, 0.13675568696150386, 0.1566046103715697, 0.12351333946679732, 0.13695857858099514, 0.21868948315128067, 0.21253137681234124, 0.208241717735537, 0.21894471394646076, 0.19877896543902907, 0.20052128763113297, 0.2305628765792509, 0.2175263005791832, 0.21286706302291702, 0.15234272945103022, 0.13997149498563122, 0.15370435892590517, 0.13951482101072454, 0.14205939321229488, 0.13848020038730136, 0.16091313070567193, 0.1574508437007358, 0.1395066905557818, 0.1623226022907731, 0.17871037786875643, 0.16196568603052963, 0.1594763701533326, 0.1675285411516757, 0.18841873814340637, 0.1659575860375726, 0.15920014280829964, 0.1572463918521826, 0.16011163726662925, 0.15781672560889415, 0.15491120461670593, 0.15771698823777291, 0.1553134881300653, 0.16138969464365238, 0.1544335193359877, 0.1566644408039285, 0.16574394358492883, 0.14346769226802503, 0.2329587479500913, 0.34504430393115215, 0.1601122790240861, 0.20472044081769514, 0.14786540657354186, 0.1658811514730658, 0.1796169992164416, 0.14602190822062544, 0.20131031760045892, 0.16862571396987913, 0.15564420242687937, 0.158858776641304, 0.15841283397749006, 0.13570312744838176, 0.2549735474000474, 0.2663609141514186, 0.1789323576128239, 0.17864435104140974, 0.1713574773368779, 0.17194432012175298, 0.17614676308974153, 0.176969520246538, 0.17328879843160738, 0.17507273241991284, 0.18676486571134732, 0.17221943524555994, 0.05321401396159531, 0.058801054006922815, 0.04716498205541808, 0.06158122050325843, 0.06551577207663506, 0.05646990411043584, 0.05773115292455255, 0.06504356217941909, 0.06545014857213138]}, "mutation_prompt": null}
{"id": "e8860c08-1177-48e3-88b1-1b200e80c48d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = 12 * dim\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adapt_rate = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Stochastic Gaussian perturbation\n                perturbation = np.random.normal(0, 0.1 * (1 - evaluations / self.budget), self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    self.crossover_rate = min(1.0, self.crossover_rate + self.adapt_rate)\n                else:\n                    new_population[i] = self.population[i]\n                    self.crossover_rate = max(0.5, self.crossover_rate - self.adapt_rate)\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Stochastic Gaussian Perturbation tuned to dynamically adjust mutation and crossover rates for robust optimization.", "configspace": "", "generation": 4, "fitness": 0.1471046875377684, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.16.", "error": "", "parent_id": "d3775667-9c06-4b44-b938-4764831f96f0", "metadata": {"aucs": [0.3180781002142151, 0.3548413319485275, 0.34725769551749275, 0.3571335427554554, 0.33137513185606005, 0.34979130520203516, 0.34865182809576123, 0.3238871148705368, 0.33196862087544055, 0.0070921166380306655, 0.00980375595620675, 0.014833243787073846, 0.0066215078207753075, 0.00423253069973728, 0.005782339332322972, 0.01175251563181412, 0.006661646261117871, 0.008763650062396433, 0.07850756146307991, 0.09386339442916958, 0.08773796779744969, 0.07827976016128668, 0.08026643053150095, 0.08158361504908096, 0.08140890903465736, 0.07941731885337033, 0.08594994798043576, 0.0690960337033284, 0.06068897099846127, 0.07641998754278634, 0.07255344625832572, 0.06897729963904364, 0.07022821973123827, 0.06855981145418077, 0.06369884821294214, 0.06971191540699839, 0.8705697832926662, 0.9520200298959702, 0.7643090567905939, 0.8044873959050042, 0.710925176789418, 0.6600346109281341, 0.8316380136176955, 0.7628340843138871, 0.7328828892710517, 0.1206041084399807, 0.10977026678855129, 0.11341231290660092, 0.12563223674697999, 0.10467305963364537, 0.08735087914303019, 0.14834804356897735, 0.11880094166234645, 0.14304106689100227, 0.13490149771656035, 0.1394630482805269, 0.1371197834557366, 0.17145530121220076, 0.18726663367084917, 0.17097514363523747, 0.14252088359534587, 0.1645494361812947, 0.17865044671728136, 0.08528246403942175, 0.05992843659931091, 0.07254936297228054, 0.07287699377530499, 0.10224873141390867, 0.08657924340715706, 0.08192192240360041, 0.07298657918269658, 0.07266148660763083, 0.03888407400058025, 0.03242647027217316, 0.04534546437975673, 0.08366884722198487, 0.08409176043849509, 0.07935471112278925, 0.052702832407272804, 0.04643845722594597, 0.05594240384982874, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04807642460771511, 0.03610564407028993, 0.06956676908269888, 0.036288916860674036, 0.0268390318056283, 0.029018827953660398, 0.06576454572953261, 0.06779445383901672, 0.03709785443036995, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03343617663810661, 0.024470939287414284, 0.03065734903675188, 0.0334973700301876, 0.02741530453985619, 0.03717638032980197, 0.03804098397576561, 0.038383780370403464, 0.038856713046102276, 0.29449998943463374, 0.29641204279287214, 0.3252172427132506, 0.30266459397701884, 0.299184195030466, 0.3054323544120203, 0.30346000052262434, 0.285139931033905, 0.303629680109923, 0.08223865322331747, 0.0665597387014093, 0.06818780277304581, 0.0675937492672094, 0.0670080196467403, 0.06323908600009454, 0.06506324129836316, 0.06602579720850876, 0.06965290593016671, 0.18246790290318116, 0.13431251345412076, 0.1401945342335521, 0.1730597684976305, 0.1511008825022505, 0.1336527128643793, 0.14841520923609353, 0.15024149691323818, 0.13216620148214497, 0.17954616025136017, 0.18993202471506543, 0.18943761543774706, 0.1789995932777969, 0.1776580384795301, 0.1813419332634929, 0.20936455744804516, 0.20344958475168273, 0.20116528663562516, 0.13284798959994026, 0.13412396991502973, 0.12750522081381166, 0.14599762443409015, 0.1262042924184763, 0.1343997599913226, 0.13343208965342002, 0.12711272119226702, 0.13155299767656803, 0.1790618385182885, 0.17057624713707376, 0.1822276744011847, 0.1724848391773387, 0.1631386834211731, 0.16169367572449644, 0.16905900147652098, 0.179426861000465, 0.17191313631972593, 0.15539852393361375, 0.15310967916193308, 0.15942165450953583, 0.16952838998631936, 0.16798362093566377, 0.16658415738373367, 0.17763466598879163, 0.15758698506766522, 0.1763151485884158, 0.17926024339814628, 0.15658534301729088, 0.15602247437710537, 0.16587260950730964, 0.1546146779891625, 0.14436951463058145, 0.15281229756428583, 0.15961411456488728, 0.1618846007169017, 0.1872769889746846, 0.15341775488464116, 0.17700214938748215, 0.1429101933005038, 0.15539387730414622, 0.13839821698757004, 0.18912316248343441, 0.1700654192320633, 0.18256936856986572, 0.17685508432833907, 0.18866101016104153, 0.16545705205722516, 0.20879428688993107, 0.191212188329834, 0.18071212487876942, 0.17236319947793577, 0.1773793415936381, 0.17226467351387031, 0.06828499358009266, 0.051928187509639456, 0.055918829582327634, 0.06645242848530053, 0.05662538516706794, 0.06387429203011341, 0.07078577345629489, 0.06447504766217294, 0.06144785993792379]}, "mutation_prompt": null}
{"id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)  # Dynamic adjustment\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1  # Start with a fixed sigma for Gaussian perturbation\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0  # To track stagnation and adjust perturbation\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Adaptive Gaussian perturbation\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0  # Reset stagnation counter\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            # Adjust perturbation based on stagnation\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.1, 1.0)  # Increase sigma\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.9, 0.01)  # Decrease sigma\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Dynamic Population and Adaptive Gaussian Perturbation for improved convergence.", "configspace": "", "generation": 5, "fitness": 0.22179648072277264, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "d3775667-9c06-4b44-b938-4764831f96f0", "metadata": {"aucs": [0.49101213563674717, 0.5051551192722341, 0.47280035964871603, 0.49859402668657216, 0.49317691687670384, 0.4967669246272859, 0.4927259721893884, 0.47749831186692704, 0.4921073246970149, 0.0938719811089539, 0.10907935433072813, 0.09697380529599342, 0.13609951413353172, 0.10887496190830548, 0.11710966654658128, 0.11704634571698347, 0.13910631479123803, 0.11971114567029328, 0.07908065638406936, 0.08166896212566532, 0.08879543451922767, 0.07002425948515734, 0.08872142683469553, 0.08006245303978443, 0.0859485742506726, 0.07537765191085566, 0.08225176587354166, 0.08713967000247325, 0.08157793223191656, 0.08228261549616378, 0.0817306301559072, 0.07667699242441017, 0.07623728743962566, 0.06996043005336561, 0.08147978933948197, 0.07241573337693918, 0.7775017604704693, 0.935024026661861, 0.871654711867239, 0.7924144275328534, 0.8676342002216488, 0.8458950490617765, 0.8383059278829418, 0.8339183374650982, 0.8169227681778637, 0.2600459671525971, 0.2781048591149192, 0.26487631714511983, 0.2688785606509315, 0.24405580725461806, 0.2567198511966492, 0.22339535759952966, 0.27524120224216186, 0.2830245561177842, 0.47348419562834243, 0.5432546469745765, 0.36546189318308653, 0.4369038975498555, 0.32335964763568537, 0.5654992080277638, 0.5859226821356966, 0.4690498136648559, 0.5089680066884752, 0.15034313288752488, 0.16948699525559408, 0.1672058098816509, 0.1726988201926808, 0.10844532014736719, 0.1376866251394302, 0.1764436414516498, 0.1847953117100165, 0.20572327968922954, 0.16246979599977163, 0.14861935381221758, 0.10735357907172671, 0.14457420599177873, 0.1797215698399366, 0.11406622418278656, 0.15652679759901234, 0.15092319418225575, 0.1823437209923333, 0.061203286588981665, 0.06816007236469157, 0.06833198078628089, 0.04558582153968238, 0.09752861526948398, 0.06753065572739725, 0.06214170322997503, 0.05046862576119715, 0.06511841559256282, 0.11963756487906319, 0.10749815540943541, 0.09521611785873552, 0.11691825228336472, 0.09243357555539355, 0.08011793562961811, 0.1429538869693011, 0.14383373460430082, 0.15593711071608396, 0.03117536287292677, 0.01919343043717958, 0.01058979991238107, 0.007018774949137718, 0.00975141318047612, 0.0016906116567854124, 9.999999999998899e-05, 0.005716100072934216, 0.011969748907572964, 0.10948255272141127, 0.10555057126472289, 0.12486051780033303, 0.12537987375515547, 0.12956195175691088, 0.11959360167628497, 0.10933306840634538, 0.11240062709042775, 0.11955094493594387, 0.4140699987873028, 0.41708582893541724, 0.4224064456382063, 0.44196206060919074, 0.41704725101487206, 0.4273754664636572, 0.43390133088586214, 0.4084128483476682, 0.40523624010148473, 0.08230983305669248, 0.0792717921125311, 0.0819535035403487, 0.07581137567523077, 0.07934023170870896, 0.06888036019688171, 0.07184419978327483, 0.06884266554621177, 0.07256853043713085, 0.14715253880677592, 0.1776185440040179, 0.13102243421019033, 0.11786623403685625, 0.15820647861557013, 0.12585816407000838, 0.1522524441008407, 0.17019410562926018, 0.2044382536250755, 0.25091919548303854, 0.2419230032421258, 0.2545361954081863, 0.2689718294671989, 0.266582317319234, 0.2554204453985658, 0.2611284156665282, 0.27243420325093215, 0.27608630106654797, 0.21677410642472328, 0.21969668296044775, 0.19071148913772407, 0.18118481485006632, 0.1661153720199774, 0.19441426210861057, 0.19630595657523975, 0.2136560981565191, 0.2115731139607564, 0.16059346706267297, 0.20669635625370952, 0.16591705845635663, 0.16504173308647074, 0.238830657921017, 0.16639657610053504, 0.16552939536718403, 0.1889545587914826, 0.19299497599104665, 0.17408265023097824, 0.16273102268465078, 0.17572473959631074, 0.1764556973355884, 0.17122188382460357, 0.1674513272523167, 0.16758782934043626, 0.1748539619598498, 0.1762040039409669, 0.702804440483497, 0.49705422649245257, 0.1617974145650274, 0.621389474827991, 0.1810002961965832, 0.553986759293738, 0.18690356301396205, 0.15164720226032447, 0.18204799463363508, 0.47889791354666844, 0.16395567275074152, 0.15860875746381642, 0.4817787912560715, 0.17504154471849065, 0.5071512214730343, 0.20739674871529612, 0.19767525866512337, 0.2044743776639114, 0.17958725813895382, 0.18062076770672775, 0.1650036412896908, 0.18148332004573198, 0.17723636163857048, 0.18165082131476673, 0.1887399056043476, 0.1710053894992627, 0.1797046488847569, 0.0591672733451829, 0.0625785417076955, 0.06680696745565251, 0.06314914071005573, 0.06361862201241297, 0.06771839451338468, 0.07317812903441823, 0.05855843709195363, 0.0683677350310945]}, "mutation_prompt": null}
{"id": "5fa1f448-8240-4ebd-b664-6506b6e4a15d", "solution": "import numpy as np\n\nclass AdaptiveCompetitiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(20, 10 * dim // 2)  # More extensive population for diversity\n        self.mutation_factor = 0.5 + np.random.rand() * 0.3  # Randomized mutation factor for diversity\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1  # Start with a fixed sigma for Gaussian perturbation\n        self.competition_frequency = 5  # Frequency of conducting competitive learning\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0  # To track stagnation and adjust perturbation\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Adaptive Gaussian perturbation\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0  # Reset stagnation counter\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            # Adjust perturbation based on stagnation\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.1, 1.0)  # Increase sigma\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.9, 0.01)  # Decrease sigma\n\n            # Apply competitive learning to adjust mutation factor\n            if evaluations % self.competition_frequency == 0:\n                fitness_scores = np.array([func(ind) for ind in self.population])\n                best_indices = fitness_scores.argsort()[:self.population_size // 3]\n                # Increase mutation factor for less fit individuals\n                for idx in range(self.population_size):\n                    if idx not in best_indices:\n                        self.mutation_factor = min(0.9, self.mutation_factor + 0.05)\n                    else:\n                        self.mutation_factor = max(0.4, self.mutation_factor - 0.05)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveCompetitiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Competitive Learning and Enhanced Mutation Dynamics for improved exploration and exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.17260247625280709, "feedback": "The algorithm AdaptiveCompetitiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.16.", "error": "", "parent_id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "metadata": {"aucs": [0.3732304319653238, 0.38160717652814446, 0.37325706637455536, 0.3695640051747259, 0.4171320036392985, 0.39820857822786393, 0.429495668229133, 0.40246030814996403, 0.3930897136676669, 0.08778282815572525, 0.05881962110075767, 0.07013022235590671, 0.09233912034895397, 0.07240107021091169, 0.06835606172668085, 0.09554317539648016, 0.07260654881268225, 0.08416607075678295, 0.07687563413683907, 0.0819071181791946, 0.06693896655857556, 0.07409380515835906, 0.09518812227349593, 0.07848321593511287, 0.05673667046718078, 0.08812596107303783, 0.07639007692155719, 0.09210542182535775, 0.06634285023172393, 0.06889348320752364, 0.057075194812701735, 0.06838354036246452, 0.06923265858088923, 0.05738345281758517, 0.06356624417092427, 0.0706864218922465, 0.8280348487571849, 0.7557823040423238, 0.741285178489759, 0.657205048751375, 0.717033006601184, 0.7952686688087632, 0.7438623691635323, 0.7273412056244215, 0.791574197092886, 0.1703822487574156, 0.1793372831968989, 0.1632067607793971, 0.14369789827930457, 0.20859654551665752, 0.15796510452883872, 0.18247104175575446, 0.1458741164152878, 0.2145761617713985, 0.22259194766307833, 0.20145861610030313, 0.2289289454142548, 0.2913430371027974, 0.261082218631692, 0.2447841511380422, 0.2492442936114988, 0.22550973560651988, 0.22391260671384916, 0.1048560339104202, 0.11586677902768971, 0.084151711949912, 0.10704716741520659, 0.0798138370419631, 0.08302865531364256, 0.08833679844902198, 0.10248618361929962, 0.11909369782000234, 0.10496425547043198, 0.12026044582833306, 0.1287771212553418, 0.11618209919468714, 0.10216542951626728, 0.09351219531048938, 0.08838019633611971, 0.0892819764426338, 0.1038841749040279, 0.01763673714608649, 0.011178344185424405, 0.027725159064810767, 0.010811602052187674, 0.025601373784380654, 0.022236057636449313, 0.02101630692799572, 0.028455269656487148, 0.04523565482747416, 0.09806170715659301, 0.09044164098154783, 0.08161811957180576, 0.07525204738639335, 0.05867607383263007, 0.09175762692774347, 0.0871833217220328, 0.10433649907320086, 0.1243077736570447, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06960940636313317, 0.07228316366494858, 0.07816338567864933, 0.07378607166464968, 0.06956507703798676, 0.06759946219575719, 0.07796032404948983, 0.0731501541723596, 0.0673353498890128, 0.3280637248741147, 0.32759455101567936, 0.330813061699474, 0.33613712298715737, 0.3415008432155442, 0.3593165456125845, 0.3153405755303885, 0.30804825863189567, 0.35004554565731283, 0.07109923168879306, 0.05779682005534359, 0.07627801025051872, 0.06462638292821044, 0.06833107062279886, 0.07019687827242382, 0.05868789308397937, 0.0707560868099717, 0.05851971158511515, 0.13558351744458375, 0.15433193451572913, 0.150656513626645, 0.1132943714686866, 0.16759085541933672, 0.1333552575066893, 0.14326151942783216, 0.15386629955893494, 0.1141167526037794, 0.2096168616077847, 0.21135454228733874, 0.19915539362981705, 0.2370485682172785, 0.2323114269275871, 0.22106969650104158, 0.23573412176156927, 0.2164219120515949, 0.20493570850374743, 0.15714789070621482, 0.15296033682362464, 0.16397248674939857, 0.16965088055535238, 0.14900038438805607, 0.16492997752355187, 0.14704619742903102, 0.15691677550866456, 0.15093099801791054, 0.15771466712078985, 0.1525375747851957, 0.16940568305682824, 0.16277455101976135, 0.1505422745076921, 0.15078485747849335, 0.16076017644412455, 0.20739408853638464, 0.1574051453638542, 0.16659078835161423, 0.166472228162443, 0.1678140014264452, 0.15100056438543052, 0.16374430949198793, 0.22344774683318758, 0.18993066949186566, 0.16802899959922013, 0.16394451751698746, 0.37375724170900426, 0.46614167613392987, 0.1536880906337137, 0.15461490267390765, 0.15339795272404644, 0.23833379862856985, 0.13325839740804168, 0.18819167805589565, 0.3258782765995335, 0.2659510782711183, 0.15537991685217278, 0.3379441464305394, 0.3095501846383536, 0.1434543562835211, 0.1530903108930206, 0.19440747281997361, 0.4127491070374315, 0.18380962744451868, 0.1728351743155372, 0.17637583448506178, 0.18509712457976535, 0.20410709176924458, 0.17222916465557958, 0.16204672751394156, 0.18081412124687202, 0.17187231888385035, 0.18825334783947578, 0.048202595893239386, 0.05752658584143133, 0.06433332074945941, 0.05330899164995628, 0.054968473735452994, 0.06432261781324689, 0.06119424838606102, 0.06510596832154003, 0.06131608998141236]}, "mutation_prompt": null}
{"id": "fea609fb-f246-4eee-a817-c2d9f7dbf954", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)  # Dynamic adjustment\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1  # Start with a fixed sigma for Gaussian perturbation\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0  # To track stagnation and adjust perturbation\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Adaptive Gaussian perturbation\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0  # Reset stagnation counter\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            # Adjust perturbation based on stagnation\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.1, 1.0)  # Increase sigma\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.9, 0.01)  # Decrease sigma\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Dynamic Population and Adaptive Gaussian Perturbation for improved convergence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "metadata": {"aucs": [0.49101213563674717, 0.5051551192722341, 0.47280035964871603, 0.49859402668657216, 0.49317691687670384, 0.4967669246272859, 0.4927259721893884, 0.47749831186692704, 0.4921073246970149, 0.0938719811089539, 0.10907935433072813, 0.09697380529599342, 0.13609951413353172, 0.10887496190830548, 0.11710966654658128, 0.11704634571698347, 0.13910631479123803, 0.11971114567029328, 0.07908065638406936, 0.08166896212566532, 0.08879543451922767, 0.07002425948515734, 0.08872142683469553, 0.08006245303978443, 0.0859485742506726, 0.07537765191085566, 0.08225176587354166, 0.08713967000247325, 0.08157793223191656, 0.08228261549616378, 0.0817306301559072, 0.07667699242441017, 0.07623728743962566, 0.06996043005336561, 0.08147978933948197, 0.07241573337693918, 0.7775017604704693, 0.935024026661861, 0.871654711867239, 0.7924144275328534, 0.8676342002216488, 0.8458950490617765, 0.8383059278829418, 0.8339183374650982, 0.8169227681778637, 0.2600459671525971, 0.2781048591149192, 0.26487631714511983, 0.2688785606509315, 0.24405580725461806, 0.2567198511966492, 0.22339535759952966, 0.27524120224216186, 0.2830245561177842, 0.47348419562834243, 0.5432546469745765, 0.36546189318308653, 0.4369038975498555, 0.32335964763568537, 0.5654992080277638, 0.5859226821356966, 0.4690498136648559, 0.5089680066884752, 0.15034313288752488, 0.16948699525559408, 0.1672058098816509, 0.1726988201926808, 0.10844532014736719, 0.1376866251394302, 0.1764436414516498, 0.1847953117100165, 0.20572327968922954, 0.16246979599977163, 0.14861935381221758, 0.10735357907172671, 0.14457420599177873, 0.1797215698399366, 0.11406622418278656, 0.15652679759901234, 0.15092319418225575, 0.1823437209923333, 0.061203286588981665, 0.06816007236469157, 0.06833198078628089, 0.04558582153968238, 0.09752861526948398, 0.06753065572739725, 0.06214170322997503, 0.05046862576119715, 0.06511841559256282, 0.11963756487906319, 0.10749815540943541, 0.09521611785873552, 0.11691825228336472, 0.09243357555539355, 0.08011793562961811, 0.1429538869693011, 0.14383373460430082, 0.15593711071608396, 0.03117536287292677, 0.01919343043717958, 0.01058979991238107, 0.007018774949137718, 0.00975141318047612, 0.0016906116567854124, 9.999999999998899e-05, 0.005716100072934216, 0.011969748907572964, 0.10948255272141127, 0.10555057126472289, 0.12486051780033303, 0.12537987375515547, 0.12956195175691088, 0.11959360167628497, 0.10933306840634538, 0.11240062709042775, 0.11955094493594387, 0.4140699987873028, 0.41708582893541724, 0.4224064456382063, 0.44196206060919074, 0.41704725101487206, 0.4273754664636572, 0.43390133088586214, 0.4084128483476682, 0.40523624010148473, 0.08230983305669248, 0.0792717921125311, 0.0819535035403487, 0.07581137567523077, 0.07934023170870896, 0.06888036019688171, 0.07184419978327483, 0.06884266554621177, 0.07256853043713085, 0.14715253880677592, 0.1776185440040179, 0.13102243421019033, 0.11786623403685625, 0.15820647861557013, 0.12585816407000838, 0.1522524441008407, 0.17019410562926018, 0.2044382536250755, 0.25091919548303854, 0.2419230032421258, 0.2545361954081863, 0.2689718294671989, 0.266582317319234, 0.2554204453985658, 0.2611284156665282, 0.27243420325093215, 0.27608630106654797, 0.21677410642472328, 0.21969668296044775, 0.19071148913772407, 0.18118481485006632, 0.1661153720199774, 0.19441426210861057, 0.19630595657523975, 0.2136560981565191, 0.2115731139607564, 0.16059346706267297, 0.20669635625370952, 0.16591705845635663, 0.16504173308647074, 0.238830657921017, 0.16639657610053504, 0.16552939536718403, 0.1889545587914826, 0.19299497599104665, 0.17408265023097824, 0.16273102268465078, 0.17572473959631074, 0.1764556973355884, 0.17122188382460357, 0.1674513272523167, 0.16758782934043626, 0.1748539619598498, 0.1762040039409669, 0.702804440483497, 0.49705422649245257, 0.1617974145650274, 0.621389474827991, 0.1810002961965832, 0.553986759293738, 0.18690356301396205, 0.15164720226032447, 0.18204799463363508, 0.47889791354666844, 0.16395567275074152, 0.15860875746381642, 0.4817787912560715, 0.17504154471849065, 0.5071512214730343, 0.20739674871529612, 0.19767525866512337, 0.2044743776639114, 0.17958725813895382, 0.18062076770672775, 0.1650036412896908, 0.18148332004573198, 0.17723636163857048, 0.18165082131476673, 0.1887399056043476, 0.1710053894992627, 0.1797046488847569, 0.0591672733451829, 0.0625785417076955, 0.06680696745565251, 0.06314914071005573, 0.06361862201241297, 0.06771839451338468, 0.07317812903441823, 0.05855843709195363, 0.0683677350310945]}, "mutation_prompt": null}
{"id": "a8d54334-686c-45fd-af1b-c1f6a25c63b3", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)  # Dynamic adjustment\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1  # Start with a fixed sigma for Gaussian perturbation\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0  # To track stagnation and adjust perturbation\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                # Introduce variability in mutation factor\n                mutation_factor = self.mutation_factor * (0.8 + 0.4 * np.random.rand())\n                mutant = self.population[a] + mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Adaptive Gaussian perturbation\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0  # Reset stagnation counter\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            # Adjust perturbation based on stagnation\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.1, 1.0)  # Increase sigma\n                # Decrease population size to increase pressure\n                self.population_size = max(10, int(self.population_size * 0.9))\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.9, 0.01)  # Decrease sigma\n                # Slightly increase population size for exploration\n                self.population_size = min(max(10, 10 * self.dim // 2), int(self.population_size * 1.05))\n\n            self.population = new_population[:self.population_size]\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Dynamic Population and Adaptive Gaussian Perturbation improved by Stagnation-based Adaptive Population Resizing and Differential Mutation Factor Variability.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 22 is out of bounds for axis 0 with size 22').", "error": "IndexError('index 22 is out of bounds for axis 0 with size 22')", "parent_id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "metadata": {}, "mutation_prompt": null}
{"id": "7dd6fee0-6d29-40e7-bb65-e85ec5cce508", "solution": "import numpy as np\n\nclass AdvancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 12 * dim // 2)  # Slightly different dynamic adjustment\n        self.mutation_factor = 0.9  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # Adjusted crossover rate to maintain diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_factor_adaptive = 0.8  # Start with a different adaptive factor\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n                \n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.mutation_factor = min(self.mutation_factor_adaptive * 1.05, 0.95)  # Alter mutation factor adaptively\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.mutation_factor = max(self.mutation_factor_adaptive * 0.95, 0.5)  # Adjust mutation factor back\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdvancedDifferentialEvolution", "description": "Advanced Differential Evolution with Dynamic Strategies and Adaptive Mutation Techniques for robust optimization.", "configspace": "", "generation": 9, "fitness": 0.2011145883452411, "feedback": "The algorithm AdvancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "metadata": {"aucs": [0.4836921274457887, 0.46443772637630687, 0.4555589112320384, 0.46945841185772574, 0.503768083431507, 0.48424827561430805, 0.4825709088839957, 0.4926639295038795, 0.4927241566664916, 0.12470761577287592, 0.11197007666553904, 0.09857619297327946, 0.09199827716211462, 0.10625671590661534, 0.10392411611720254, 0.1236463739869117, 0.09674789278951645, 0.10308187572233907, 0.09063930331817394, 0.08784891444523579, 0.08085651050434173, 0.09682670510487001, 0.07651698344310043, 0.07358628685564583, 0.08543560514471882, 0.08532885837922144, 0.09468468437261923, 0.08112652013273203, 0.07904339914044067, 0.08999807205879296, 0.08550691957369183, 0.0789213757759688, 0.08023060537222881, 0.07234481558460215, 0.08731022922111187, 0.06801084883896313, 0.8452689723071631, 0.881577189119142, 0.8284478770811858, 0.8378592728653997, 0.901931391065699, 0.8234733315492635, 0.8127872053293039, 0.8803195626923042, 0.8781429629345894, 0.22592823533954276, 0.20114337101179613, 0.253134174074819, 0.23682540902728255, 0.22394573742876522, 0.24570686544307196, 0.24367779242881893, 0.24508655859205797, 0.23559805619574203, 0.3445338654304082, 0.3557795865344112, 0.4400921907859009, 0.29277908673851083, 0.2903039989842138, 0.2971098031493101, 0.28312581271927906, 0.45664668055894986, 0.3231720603923527, 0.15515894466895663, 0.14269470009818164, 0.1339586436435084, 0.16048869589901338, 0.12286253182020013, 0.12309354783378657, 0.11576755911046133, 0.13902275260553654, 0.1368070669481658, 0.16362413257949793, 0.09696414949203702, 0.1411423507995898, 0.20322707696907516, 0.1459733418453032, 0.13664779731721788, 0.11271139291894083, 0.11622567174721266, 0.16939103956302093, 0.021958158940631245, 0.039946057937829904, 0.021464734895651594, 0.016823165302821352, 0.020202689448714728, 0.02332807647436841, 0.025506875416103303, 0.005712937266343254, 0.03214508335995181, 0.07376857079679777, 0.08312106713249434, 0.10752244554543922, 0.06458838662776001, 0.06504610953559553, 0.0899749284356014, 0.10863469981461404, 0.08115895453504474, 0.10447399408908165, 9.999999999998899e-05, 0.01044221743574636, 0.001514050407758094, 9.999999999998899e-05, 0.027018894159085316, 9.999999999998899e-05, 0.0011329758773533927, 9.999999999998899e-05, 0.0012649883909565673, 0.10145725811315165, 0.10436303042898276, 0.09575947589692935, 0.12002694477636211, 0.11908268810446121, 0.09987778921486912, 0.10023155052601085, 0.10214256343273431, 0.11126918132095343, 0.3873672067164331, 0.40034841645525276, 0.4183942607977692, 0.3998376737712275, 0.3908416517622679, 0.40884073923350384, 0.389543753880505, 0.390956859460285, 0.38851443757070725, 0.086060471415641, 0.06495208038084288, 0.07950099042891146, 0.0757270236904507, 0.08661307473724988, 0.06935822813772974, 0.06651154925146752, 0.08001890311596904, 0.0870311852096598, 0.15038754381246655, 0.13404175288743136, 0.12707385614126765, 0.16923231169556585, 0.1403512420958265, 0.1667516708093132, 0.1307956312842471, 0.14664271028325293, 0.1159094251654349, 0.24334532161011369, 0.2586458712010701, 0.23001550081921174, 0.2499966755198585, 0.22649355608466748, 0.2320210867183392, 0.2556149486707281, 0.2683914358625542, 0.23810503112488335, 0.17886478193313537, 0.1820694699141997, 0.18788741514263485, 0.17387246247119947, 0.17614741140181234, 0.18691042664563395, 0.18618891980785923, 0.17628427420782045, 0.17745553444261153, 0.16378363843018218, 0.15557984954306991, 0.1763126684140316, 0.1771536460638521, 0.16082731311543663, 0.1796859156234405, 0.16846392414959077, 0.17347906337051988, 0.16950213636827394, 0.18058644779842215, 0.17019164770529893, 0.17021304817498317, 0.1607869911262425, 0.16330265225667828, 0.17587161153012987, 0.16413268505616874, 0.19107160478063845, 0.1684061614398097, 0.44675155728717386, 0.4361454236556691, 0.1733186646471906, 0.5850831669919285, 0.18496691631998563, 0.16727806376529986, 0.15274096821802252, 0.20014015763156623, 0.16167815880180425, 0.36516563622169473, 0.17786838681246186, 0.18302093099628325, 0.23143124457753528, 0.15907448863514073, 0.27477942829322954, 0.19768277111015053, 0.28698318136493195, 0.20147890192251994, 0.20813629428033154, 0.21200266802287548, 0.1731713384961442, 0.17198671165035628, 0.17642006251711295, 0.17455323278605395, 0.16603084593304174, 0.197230818684069, 0.17399269647387394, 0.06893478659314156, 0.0596515090321551, 0.0666300014306227, 0.06704271641362225, 0.05947211951698683, 0.07005339500391494, 0.07059442365492852, 0.0594859301953502, 0.0647404112650376]}, "mutation_prompt": null}
{"id": "597ddd6f-6187-444a-be9a-7d77e1008f76", "solution": "import numpy as np\n\nclass AdaptiveTurbulentDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)  # Dynamic adjustment\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_rate = 0.75  # Reduced crossover rate for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.turbulence_factor = 0.5  # Control turbulence intensity\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Turbulent Cosine Perturbation\n                turbulence = self.turbulence_factor * np.cos(np.random.rand(self.dim) * 2 * np.pi)\n                trial_perturbed = trial + turbulence\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                else:\n                    new_population[i] = self.population[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveTurbulentDifferentialEvolution", "description": "Adaptive Differential Evolution with Turbulent Cosine Perturbation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 10, "fitness": 0.16196742276517798, "feedback": "The algorithm AdaptiveTurbulentDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.18.", "error": "", "parent_id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "metadata": {"aucs": [0.3007025294929946, 0.30171796140609064, 0.3288413337247321, 0.303691226369992, 0.299183205290504, 0.3200244868181006, 0.29247823911917215, 0.30367723593657525, 0.3058473127315, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00010226993186501776, 9.999999999998899e-05, 0.09986248320230096, 0.06491471922333736, 0.059089607822597645, 0.0718003457906028, 0.07607531662383704, 0.09778626611546748, 0.0749697083762263, 0.07691345671841587, 0.08455299660106175, 0.07752875766696721, 0.09324512505492588, 0.0706067936940652, 0.06266784981246076, 0.06856669236722734, 0.06936527870413667, 0.06298722776705201, 0.06396025444538644, 0.06731962405053549, 0.9028620000441798, 0.9130903714727342, 0.8713785699135674, 0.8778066054924379, 0.9374431248698779, 0.88938750841164, 0.896478723788489, 0.8751017578402258, 0.918291053016272, 0.19231744518836635, 0.1658058029963948, 0.16636497538187467, 0.16443259907251395, 0.14605425961329943, 0.1496021999672179, 0.16672937339429406, 0.16470250667197395, 0.17025070075892867, 0.2060008076127382, 0.18323354327651298, 0.21612094248733482, 0.18873833053192868, 0.21833475404018532, 0.2068015257931174, 0.199353883144063, 0.2033867465253757, 0.19313294756814414, 0.1001530160536277, 0.09521224137618878, 0.14096234015331954, 0.10179283657183036, 0.09180138731167664, 0.09585979189473581, 0.07848287075733273, 0.11406531041764101, 0.10176000062045987, 0.0953463793952476, 0.07533283370930732, 0.07169936889031137, 0.10902223906884334, 0.09756857163006571, 0.09558434411625982, 0.08057688617817071, 0.06736118045462425, 0.08634524908261387, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006382572737640979, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04281138694059372, 0.08914063125526372, 0.07260392980225339, 0.07207975099165831, 0.01717073593048768, 0.04586492910970685, 0.039847451095161524, 0.04464777922201424, 0.0725279986470736, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030134969347798912, 0.061292938020225285, 0.03781496900140646, 0.03361234103332367, 0.04589967304829856, 0.0437208335007806, 0.04111446077078085, 0.05023276988581615, 0.05083921239261657, 0.3200023961669586, 0.2973805179564548, 0.30569189277415454, 0.3015112839573312, 0.30608790432274935, 0.29721976758833357, 0.30453126863856583, 0.32158284878287435, 0.3054364429859494, 0.08450590312820405, 0.08182435743772709, 0.07700140951346623, 0.06156346398898327, 0.0709881575806186, 0.09671114369318168, 0.0799505172946412, 0.05953363790610633, 0.08888464878878599, 0.14664834450215825, 0.1407145316257571, 0.12699900423801613, 0.11907521759641693, 0.13188007547253222, 0.14846570070111642, 0.11391357011612613, 0.1665675871369181, 0.12385222859202372, 0.20382504777281962, 0.21351330529532297, 0.217391775969749, 0.21337925460565332, 0.22019431897999653, 0.21287951871126443, 0.22447567951467728, 0.21461918424005044, 0.20851741292554493, 0.1491016271066592, 0.13827111383357382, 0.16879340756409544, 0.13756300913917496, 0.1393945986684605, 0.1523568163745629, 0.16410062468863051, 0.17432558418919453, 0.1796824843238104, 0.15969700840973233, 0.15325614945741783, 0.17980602884571506, 0.17883145504464049, 0.1571149197132976, 0.17089427676825797, 0.17133999190723503, 0.16835456731811105, 0.18894662598562117, 0.16549462001695758, 0.16759540319981903, 0.15254117944668866, 0.1703884365164775, 0.1612772767549897, 0.1841240085539474, 0.16405731448072713, 0.17130861139845677, 0.15692787646601514, 0.16380841770359822, 0.14625928238138364, 0.15183858098695435, 0.1581353755105347, 0.24780928959552784, 0.24512199479345465, 0.22111870942139045, 0.17482598520669768, 0.28051451836075014, 0.177547072488783, 0.24463174281567635, 0.14581051633686326, 0.17274630087756027, 0.19676409176458087, 0.173985861093518, 0.18698123969871772, 0.19868428796192694, 0.38208593149249714, 0.17713969444979338, 0.20965988741730068, 0.19169467191086564, 0.1690071785565056, 0.18050523049415956, 0.16858672629348226, 0.1766902923496515, 0.1909168052130248, 0.1901893685624002, 0.05971136083184725, 0.06345686559119745, 0.058060930125001464, 0.060620574942329974, 0.06173354777647655, 0.061268217542546854, 0.06720807516184868, 0.06160813038155988, 0.060268995831431305]}, "mutation_prompt": null}
{"id": "79180269-fbc7-4912-a37e-1bf55e42c437", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_step = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                # Dual mutation strategy\n                if np.random.rand() > 0.5:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                else:\n                    mutant = self.population[a] + self.mutation_factor * (self.population[a] - self.population[c])\n\n                mutant = np.clip(mutant, *self.bounds)\n\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n\n                # Adaptive step size\n                step_size = np.random.normal(0, self.adaptive_step, self.dim)\n                trial_perturbed = trial + step_size\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n\n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_step = min(self.adaptive_step * 1.1, 1.0)\n            else:\n                self.adaptive_step = max(self.adaptive_step * 0.9, 0.01)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Dual Mutation Strategy and Adaptive Step Size for Robust Optimization.", "configspace": "", "generation": 11, "fitness": 0.19090796485486447, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "metadata": {"aucs": [0.36778717604409517, 0.427338992918197, 0.4228418828108288, 0.4584403040623962, 0.41221052536808866, 0.44798098477552517, 0.47209311845935986, 0.4311356465658551, 0.4196928831980996, 0.06939673892238729, 0.09630404269988446, 0.08520893205323732, 0.08459838491519278, 0.08983776390403164, 0.09544350749053843, 0.06512479447895025, 0.06681240642034936, 0.08161563711154851, 0.07661022926152927, 0.06944238971197703, 0.09257291426786163, 0.08866868263908656, 0.06843568013100776, 0.08233295825709452, 0.07241043609811382, 0.07491775408263823, 0.09504657358701663, 0.05803114016070665, 0.06491691722910187, 0.06376802045479513, 0.073342965804013, 0.06016302400094242, 0.06017239142016917, 0.07993995731124137, 0.06206558221938563, 0.06719823515638712, 0.9409956063483415, 0.8592998753750878, 0.8717409045967226, 0.9026817758219858, 0.9253222685537519, 0.9292817895508392, 0.8979434054666104, 0.8771855409254782, 0.9047218335386595, 0.19914160341860432, 0.19739656537782924, 0.21467046064410478, 0.23725854227416598, 0.19063616271843142, 0.1938244693077621, 0.22115494677169323, 0.1974660150939751, 0.23399482524696458, 0.2543142614534206, 0.23948937273784132, 0.3409841158890554, 0.28202556988878213, 0.4619223434561345, 0.38936775432902015, 0.2510137539066857, 0.5330208714212185, 0.2448510550993631, 0.11420343891010709, 0.13355471956556197, 0.11625827591769067, 0.1229832790762665, 0.11759934696628116, 0.18048776374081898, 0.12562581608737056, 0.11773110384047847, 0.11592135250924052, 0.11401971381693543, 0.1463166065301571, 0.10396170623132017, 0.1311505255254235, 0.11438198051714732, 0.13739545574030487, 0.09824183485860272, 0.11105546629796359, 0.1154284621588515, 0.010639439862013433, 0.02255607138886606, 0.0448771342703469, 0.026169067636494403, 0.021575381642324087, 0.004873872610793084, 0.04072615927884504, 0.04654735110656438, 0.03338343918013309, 0.12150266352341166, 0.13466125472175627, 0.07120325766228308, 0.11036858399118121, 0.04301045848966589, 0.07789594930845067, 0.0776583454083658, 0.05826100854342853, 0.11254878385255374, 0.0007613889733907309, 0.00949015221547711, 0.008732706998092699, 0.01296670649686038, 0.0011012743601248598, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08733074889043324, 0.0947795599359893, 0.10458427408319981, 0.09609738657286016, 0.08495086867563917, 0.08176580944743383, 0.08938085695453901, 0.12226113554445406, 0.10308635813275668, 0.3766226251403533, 0.34190494580705255, 0.3899356521272642, 0.3487527692330875, 0.38263802647415546, 0.3904937674899014, 0.3489390292224487, 0.3682872202832008, 0.36644728443626895, 0.07448094285443674, 0.07813069432718367, 0.07218809464363418, 0.0631886103217355, 0.07304025838889627, 0.07923645961407288, 0.05877126596720805, 0.07782843365696024, 0.07976688261140064, 0.14372662269771663, 0.1477124175893445, 0.1544110375761375, 0.19459298003655134, 0.18190435336576793, 0.11965892187831106, 0.12083072447396048, 0.1332691707322543, 0.16806505639613556, 0.21440302779543907, 0.23285689866568082, 0.22349346885739574, 0.21287838416054206, 0.19071175695341458, 0.21201372121771023, 0.26253813521301994, 0.2620232466286998, 0.22991722685820637, 0.1738108810968101, 0.15642422313457371, 0.1783732460832007, 0.15012826060814422, 0.1781693783408389, 0.16471243764067844, 0.17615585313084248, 0.18248586165162028, 0.18212687621560497, 0.1589218378155085, 0.16976948797903912, 0.16122413292359505, 0.17524214287651196, 0.15790547652014864, 0.16974886315227122, 0.17654393882175623, 0.18745176292010235, 0.17331424815918073, 0.15956386711310766, 0.16634204825158116, 0.16133671330948418, 0.16736791592574973, 0.17166193749601244, 0.15287897697156883, 0.15373088489446074, 0.1605785570227063, 0.1821876386589255, 0.3886514359631612, 0.543683345188703, 0.1493771476235357, 0.1566567413011326, 0.1769639477673539, 0.1766933267493025, 0.16809010146191083, 0.16526059084046485, 0.18397251708094553, 0.3705100273823143, 0.1783001578637321, 0.1601953630259908, 0.18609945927262794, 0.16402933585300894, 0.3213808395872154, 0.20914583328664682, 0.12025467540540213, 0.20656126289882737, 0.18904938103580837, 0.18348454001140257, 0.19385194376223325, 0.17338327388924568, 0.16938664001812742, 0.19072675448804088, 0.16769995085296252, 0.18929694876602077, 0.22577280083293083, 0.06481299089746972, 0.055499659771795495, 0.06160170649867325, 0.05783009521716753, 0.06289805061418952, 0.05404137319234015, 0.054076925629535255, 0.06120173431533471, 0.06379240664218455]}, "mutation_prompt": null}
{"id": "d4be9527-9af1-4750-94a5-f3f1dc5a81d7", "solution": "import numpy as np\n\nclass AdvancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 10 * dim // 2)  # Slightly larger dynamic adjustment\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_rate = 0.85  # Slightly decreased crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.05  # Reduced initial sigma for Gaussian perturbation\n        self.fitness_values = np.full(self.population_size, np.inf)  # Track fitness values for diversity\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            new_fitness_values = np.empty(self.population_size)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Adaptive Gaussian perturbation\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < self.fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    new_fitness_values[i] = trial_fitness\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    new_fitness_values[i] = self.fitness_values[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.population = new_population\n            self.fitness_values = new_fitness_values\n\n            # Adjust perturbation based on stagnation\n            if stagnation_counter > self.population_size // 3:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.15, 1.0)  # Increase sigma\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.9, 0.01)  # Decrease sigma\n\n        return self.best_solution, self.best_fitness", "name": "AdvancedDifferentialEvolution", "description": "Advanced Differential Evolution with Dynamic Population, Adaptive Gaussian Perturbation, and Fitness-Based Diversity Mechanism.", "configspace": "", "generation": 12, "fitness": 0.21012888115414438, "feedback": "The algorithm AdvancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "metadata": {"aucs": [0.536244709098143, 0.512399264362062, 0.49983882013055003, 0.5298760393890927, 0.5121718513253366, 0.5295532364997007, 0.5099020700122653, 0.5345075931598284, 0.543606952433703, 0.1980026155951431, 0.08652638266051105, 0.10539981708345092, 0.10291550715679987, 0.0786828596141882, 0.065638796818969, 0.11310148812626197, 0.1136488169601706, 0.09247215011352383, 0.08771416426676715, 0.08614791193047566, 0.08596589593509829, 0.09544586461431603, 0.09786019905195387, 0.08741993314378649, 0.08861316634991911, 0.07441440384803522, 0.09572195275346107, 0.07433924633381561, 0.08238164234307255, 0.0715564251133397, 0.09135446976411188, 0.11506101863372875, 0.08070219217422869, 0.07981589334411254, 0.08484340638947796, 0.07219909105579336, 0.9054539431739683, 0.9379654727053206, 0.9573381309246329, 0.9480538842809206, 0.922678319751297, 0.940280303097653, 0.9073382046103954, 0.9242285293319942, 0.9292659512291492, 0.3001644090806934, 0.2616469525002567, 0.3386470304936603, 0.29490973978271207, 0.31242942134576024, 0.2971310687717087, 0.34431905865393253, 0.31834001463039696, 0.33976788844977857, 0.22057509472673986, 0.3253733745168502, 0.25684176948872084, 0.25127330531664616, 0.275670195865129, 0.3366645533348719, 0.2612447956237567, 0.24908998796849946, 0.2092135694387114, 0.17654449143329143, 0.15746791368481283, 0.19282752106624435, 0.19041386339310595, 0.1894070917913676, 0.2014118925585764, 0.18964015923060684, 0.17632878467016377, 0.16425634932025057, 0.19340956833106593, 0.18492118415317527, 0.20083889793777443, 0.19266494902308617, 0.1747830337514954, 0.1338727328528152, 0.17765865873061526, 0.19126134179415377, 0.18639892545789138, 0.0027753898970895863, 9.999999999998899e-05, 9.999999999998899e-05, 0.02165453142809015, 0.008277686925952321, 0.02033017879724508, 9.999999999998899e-05, 0.019433663347685814, 9.999999999998899e-05, 0.04541042597236278, 0.050363011891879084, 0.08257667812308467, 0.06928779791526452, 0.07182807477131825, 0.06506532873810233, 0.07686696088504341, 0.07466210176148691, 0.08695461506161994, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1296593185724354, 0.09317089914235654, 0.07904189673572515, 0.11788639083418817, 0.090298510843554, 0.11966494272001871, 0.11774860778998641, 0.09961832719148411, 0.1088972300086356, 0.4191514178525402, 0.439011609542587, 0.42205447136705654, 0.45134668277761736, 0.4535746575709736, 0.42576539135611446, 0.4865626024421035, 0.43729024253432347, 0.4486518045550548, 0.07261872516136259, 0.07366462284867137, 0.07086375969044545, 0.07751735259625092, 0.08380336176676151, 0.09598164617381788, 0.08190857414373254, 0.08350738598874707, 0.09252383681394827, 0.13772279382101826, 0.1434942513971864, 0.15122427445005848, 0.14292809707271603, 0.14586755816617547, 0.1339170051837666, 0.15316803856910388, 0.14083319963643737, 0.14546745137249784, 0.267403093320406, 0.27057599726517645, 0.26062084413443387, 0.2399937674167102, 0.2649489245757337, 0.29903861445021473, 0.26338673955401826, 0.29157839344503167, 0.27866158810166164, 0.16634610782276282, 0.1786933012773363, 0.18716336545678236, 0.1551984854310533, 0.18893305579378816, 0.17418888034267943, 0.19302784878943047, 0.21521354196884845, 0.20292135124341226, 0.18877650389264233, 0.17303768612307757, 0.19178275088886343, 0.1627084651804358, 0.17730379118559703, 0.1662542931751272, 0.16181115634500542, 0.17962374387178803, 0.18037776358119773, 0.1822277640600687, 0.17207098065683146, 0.17730403789145766, 0.17437890884159823, 0.16624047628386507, 0.16844703580020637, 0.16801250298951254, 0.17084524582221472, 0.17569133135602755, 0.18137425449941624, 0.3408253076274331, 0.2951818666649476, 0.16906274137366362, 0.20567620286609156, 0.24554225264690444, 0.16675768894986454, 0.15989734917155618, 0.23525612775377258, 0.20299598123475882, 0.2021619556569655, 0.16479183177827017, 0.4874534435498662, 0.21391728068024385, 0.2765282836533953, 0.21009982422774942, 0.152222968932046, 0.21037632705985965, 0.1879736171075288, 0.1868758977601629, 0.2000698417574438, 0.18551293958065418, 0.17786484136709113, 0.1904642730335151, 0.18194912403414765, 0.19365199575956882, 0.19205145794168255, 0.06687533453780958, 0.06546484654897833, 0.061042487697371195, 0.07037268552014886, 0.07404931913357249, 0.06814357873713561, 0.06688414607452797, 0.0713640806822925, 0.07306627529423326]}, "mutation_prompt": null}
{"id": "e0e23553-8548-43da-aae1-7bbe7bcaaa63", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)  # Dynamic adjustment\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1  # Start with a fixed sigma for Gaussian perturbation\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0  # To track stagnation and adjust perturbation\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                # Adaptive Gaussian perturbation\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0  # Reset stagnation counter\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            # Adjust perturbation based on stagnation\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.1, 1.0)  # Increase sigma\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.9, 0.01)  # Decrease sigma\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Dynamic Population and Adaptive Gaussian Perturbation for improved convergence.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "metadata": {"aucs": [0.49101213563674717, 0.5051551192722341, 0.47280035964871603, 0.49859402668657216, 0.49317691687670384, 0.4967669246272859, 0.4927259721893884, 0.47749831186692704, 0.4921073246970149, 0.0938719811089539, 0.10907935433072813, 0.09697380529599342, 0.13609951413353172, 0.10887496190830548, 0.11710966654658128, 0.11704634571698347, 0.13910631479123803, 0.11971114567029328, 0.07908065638406936, 0.08166896212566532, 0.08879543451922767, 0.07002425948515734, 0.08872142683469553, 0.08006245303978443, 0.0859485742506726, 0.07537765191085566, 0.08225176587354166, 0.08713967000247325, 0.08157793223191656, 0.08228261549616378, 0.0817306301559072, 0.07667699242441017, 0.07623728743962566, 0.06996043005336561, 0.08147978933948197, 0.07241573337693918, 0.7775017604704693, 0.935024026661861, 0.871654711867239, 0.7924144275328534, 0.8676342002216488, 0.8458950490617765, 0.8383059278829418, 0.8339183374650982, 0.8169227681778637, 0.2600459671525971, 0.2781048591149192, 0.26487631714511983, 0.2688785606509315, 0.24405580725461806, 0.2567198511966492, 0.22339535759952966, 0.27524120224216186, 0.2830245561177842, 0.47348419562834243, 0.5432546469745765, 0.36546189318308653, 0.4369038975498555, 0.32335964763568537, 0.5654992080277638, 0.5859226821356966, 0.4690498136648559, 0.5089680066884752, 0.15034313288752488, 0.16948699525559408, 0.1672058098816509, 0.1726988201926808, 0.10844532014736719, 0.1376866251394302, 0.1764436414516498, 0.1847953117100165, 0.20572327968922954, 0.16246979599977163, 0.14861935381221758, 0.10735357907172671, 0.14457420599177873, 0.1797215698399366, 0.11406622418278656, 0.15652679759901234, 0.15092319418225575, 0.1823437209923333, 0.061203286588981665, 0.06816007236469157, 0.06833198078628089, 0.04558582153968238, 0.09752861526948398, 0.06753065572739725, 0.06214170322997503, 0.05046862576119715, 0.06511841559256282, 0.11963756487906319, 0.10749815540943541, 0.09521611785873552, 0.11691825228336472, 0.09243357555539355, 0.08011793562961811, 0.1429538869693011, 0.14383373460430082, 0.15593711071608396, 0.03117536287292677, 0.01919343043717958, 0.01058979991238107, 0.007018774949137718, 0.00975141318047612, 0.0016906116567854124, 9.999999999998899e-05, 0.005716100072934216, 0.011969748907572964, 0.10948255272141127, 0.10555057126472289, 0.12486051780033303, 0.12537987375515547, 0.12956195175691088, 0.11959360167628497, 0.10933306840634538, 0.11240062709042775, 0.11955094493594387, 0.4140699987873028, 0.41708582893541724, 0.4224064456382063, 0.44196206060919074, 0.41704725101487206, 0.4273754664636572, 0.43390133088586214, 0.4084128483476682, 0.40523624010148473, 0.08230983305669248, 0.0792717921125311, 0.0819535035403487, 0.07581137567523077, 0.07934023170870896, 0.06888036019688171, 0.07184419978327483, 0.06884266554621177, 0.07256853043713085, 0.14715253880677592, 0.1776185440040179, 0.13102243421019033, 0.11786623403685625, 0.15820647861557013, 0.12585816407000838, 0.1522524441008407, 0.17019410562926018, 0.2044382536250755, 0.25091919548303854, 0.2419230032421258, 0.2545361954081863, 0.2689718294671989, 0.266582317319234, 0.2554204453985658, 0.2611284156665282, 0.27243420325093215, 0.27608630106654797, 0.21677410642472328, 0.21969668296044775, 0.19071148913772407, 0.18118481485006632, 0.1661153720199774, 0.19441426210861057, 0.19630595657523975, 0.2136560981565191, 0.2115731139607564, 0.16059346706267297, 0.20669635625370952, 0.16591705845635663, 0.16504173308647074, 0.238830657921017, 0.16639657610053504, 0.16552939536718403, 0.1889545587914826, 0.19299497599104665, 0.17408265023097824, 0.16273102268465078, 0.17572473959631074, 0.1764556973355884, 0.17122188382460357, 0.1674513272523167, 0.16758782934043626, 0.1748539619598498, 0.1762040039409669, 0.702804440483497, 0.49705422649245257, 0.1617974145650274, 0.621389474827991, 0.1810002961965832, 0.553986759293738, 0.18690356301396205, 0.15164720226032447, 0.18204799463363508, 0.47889791354666844, 0.16395567275074152, 0.15860875746381642, 0.4817787912560715, 0.17504154471849065, 0.5071512214730343, 0.20739674871529612, 0.19767525866512337, 0.2044743776639114, 0.17958725813895382, 0.18062076770672775, 0.1650036412896908, 0.18148332004573198, 0.17723636163857048, 0.18165082131476673, 0.1887399056043476, 0.1710053894992627, 0.1797046488847569, 0.0591672733451829, 0.0625785417076955, 0.06680696745565251, 0.06314914071005573, 0.06361862201241297, 0.06771839451338468, 0.07317812903441823, 0.05855843709195363, 0.0683677350310945]}, "mutation_prompt": null}
{"id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)  # Adjust population size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]  # Adding self-adaptive mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Self-Adaptive Mutation Strategy for Robust Performance.", "configspace": "", "generation": 14, "fitness": 0.24833209469140785, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "f846d807-37fc-48ea-b8fc-4c4b8a8e4658", "metadata": {"aucs": [0.49568991282865293, 0.5609129062753054, 0.5454570631785307, 0.5276329961814406, 0.5667415584074479, 0.5526681965948148, 0.5459613828097101, 0.5337191292944101, 0.5155386640537143, 0.13287487503997653, 0.10670014952838303, 0.06692825888454512, 0.09326676709106174, 0.09784647386179535, 0.09708708490966733, 0.11099193821568698, 0.09949630353266259, 0.06915461992829008, 0.08971123158298655, 0.14405936532935593, 0.09260991947424768, 0.07471031775506631, 0.09409545846535439, 0.09983536314110841, 0.08567607046964332, 0.07197741912934286, 0.0897234681060769, 0.07065085092214796, 0.07357275369590022, 0.08106881431286528, 0.10062343460007672, 0.07617884866295954, 0.11362680971595784, 0.11807803331985411, 0.08823229839862634, 0.10882050817120892, 0.9059483889935853, 0.8716605395728954, 0.9364530668212362, 0.8287047744400401, 0.8472653465869171, 0.8619433229725021, 0.8565564805128323, 0.8844506150044527, 0.9221222509475404, 0.35312211828952755, 0.31713525340079873, 0.3662809490752148, 0.3501803203656244, 0.31101759677443863, 0.3319878098525323, 0.30883920959291766, 0.3260090506047837, 0.30173438506575834, 0.2149924128498214, 0.7171873437144838, 0.7293543178052186, 0.7393370277275653, 0.7570336820239753, 0.7804347176779627, 0.8083234468541868, 0.20136250713043502, 0.8002137572139699, 0.1175667679955621, 0.2563533095786996, 0.2730757202392581, 0.20806631674861453, 0.20914402037568014, 0.19705529408180877, 0.20265202226432555, 0.17542122307541141, 0.18671335340987338, 0.1115599026642321, 0.11253380196200413, 0.1691938496796873, 0.25860659037947265, 0.17249259946646156, 0.2088886466094052, 0.20176491539219077, 0.2005607885363634, 0.19328246406209693, 0.09738093086336608, 0.10176279226277418, 0.0332301848469273, 0.05620227433669023, 0.065083886348825, 0.032944120834552115, 0.03423020869025328, 0.054214113565149824, 0.11509418614107803, 0.1350188634594579, 0.14622899821208046, 0.11278431896139374, 0.13329395073231243, 0.08531324866244283, 0.11594647933317226, 0.09718151749201664, 0.17725403975154064, 0.04578750672037024, 0.004449044109719247, 9.999999999998899e-05, 9.999999999998899e-05, 0.00456794763305568, 0.02717763738359591, 0.04683397934048239, 0.023807585389137076, 0.0022510045112663635, 0.02877676899350412, 0.11140166195704582, 0.15099695693480697, 0.16231609648630652, 0.16269651000348895, 0.12702193450623822, 0.1304857541230251, 0.1332320394056533, 0.17713729415661017, 0.15761335135741006, 0.45329945447929876, 0.43725350067312563, 0.4521238496007858, 0.4711520199486746, 0.441207893243179, 0.4429774055517499, 0.4589829284397131, 0.4597276632098406, 0.46756505425729544, 0.09154615751776507, 0.08715700532390058, 0.0949611980087709, 0.09676365544456689, 0.07811488586854398, 0.06867174168665091, 0.0721922736033046, 0.10181704471656616, 0.0881417696640523, 0.1344967295445475, 0.1285138064172262, 0.13185131717034493, 0.1294338175476909, 0.19169182224475056, 0.12764047603227924, 0.1223606161412617, 0.22107313565519804, 0.14297599734345112, 0.3271426143659629, 0.31378086729150445, 0.29544715034361413, 0.2929434921867917, 0.3113682884608323, 0.2972472846624984, 0.31783997489530635, 0.3186054771852046, 0.3393223081331165, 0.24647840328015747, 0.23010809916584052, 0.23931848263486233, 0.2277788984476682, 0.23955864858974496, 0.2268957747805218, 0.2589048681087096, 0.267486515982889, 0.2443592813278045, 0.16220871448631902, 0.18252246624615887, 0.1736885270554258, 0.18091186888003663, 0.17248168954471987, 0.16761779063984572, 0.17056843436142222, 0.18142235951705643, 0.17160144694064527, 0.18112786082445764, 0.19990115425450872, 0.1869185738223612, 0.17231424105942827, 0.18251222022428137, 0.16602594516626834, 0.17715068016182756, 0.17405354565846132, 0.17644220889253304, 0.675267344783971, 0.7799228104694149, 0.18248892403426253, 0.7774252737242051, 0.1838459271533749, 0.7429494613645686, 0.7464662956637469, 0.16653745445781565, 0.164778399249759, 0.16532993443355992, 0.20368236442652732, 0.20706693087060846, 0.19295287120945392, 0.7391474631324462, 0.15218725668583755, 0.12527155175218374, 0.15103509117123848, 0.1514391471843206, 0.17484954481431847, 0.17242467675974582, 0.169989733961721, 0.17640623155635915, 0.17168665441512498, 0.18579966183658192, 0.17958341786294618, 0.17121219406500499, 0.16944965721321348, 0.08458269807162344, 0.06154460218686386, 0.06896426320660265, 0.06413534419834754, 0.07086803876802972, 0.0742706992642106, 0.06496016827121909, 0.0688949473394721, 0.06814732910511234]}, "mutation_prompt": null}
{"id": "bafc7167-4636-4cba-bbee-7b21dfdef907", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(12, 12 * dim // 3)  # Adjusted population size\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.4, 0.9]  # Tweaked self-adaptive mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        improvement_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = mutant if np.random.rand() < self.crossover_rate else self.population[i]\n                \n                # Quantum-inspired perturbation\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim) * np.random.choice([-1, 1], self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    improvement_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    improvement_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if improvement_counter > self.population_size // 3:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.15, 1.0)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.85, 0.01)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-Inspired Differential Evolution with Niche Creation and Mutation Diversity for Enhanced Exploration.", "configspace": "", "generation": 15, "fitness": 0.24281349511454073, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.5208924292546826, 0.5576654274518101, 0.5361570906309503, 0.5178266251353956, 0.4807960793482532, 0.5177545812010196, 0.5282620101001714, 0.5084861018031654, 0.5266144650850746, 0.12688751156372458, 0.08067249278065813, 0.14663427935344786, 0.10481514782578283, 0.08001862436494545, 0.09102232672642152, 0.09455341124996264, 0.11380698271847522, 0.09738683816569338, 0.08201162149054508, 0.11940671386622947, 0.08701566918995085, 0.11189990700093588, 0.08971001184586314, 0.12442108177732314, 0.117820065646012, 0.12693502669796342, 0.15292657161983148, 0.07324683234203733, 0.09605798079420746, 0.11829348532310613, 0.09425508555107776, 0.0689406522326077, 0.0883510643541684, 0.08542169466131122, 0.07292002891654514, 0.06486559254656565, 0.5617466837627074, 0.8356874951446704, 0.9002719458743543, 0.7261186995728692, 0.7821349506574543, 0.6784685480412037, 0.6990480534485388, 0.6234436112631094, 0.776032038815745, 0.33433988490125344, 0.355102579151085, 0.2358834595118029, 0.3134666953308539, 0.25265660099278286, 0.20330215956433673, 0.2676925149817112, 0.26017868402295796, 0.22054021414094194, 0.624653998601943, 0.7507808689856929, 0.34386212474008704, 0.7816164527680907, 0.762060534378335, 0.7655034772075937, 0.725554071076318, 0.8398887412226155, 0.7534439384092463, 0.32496832930895336, 0.2064299144886249, 0.19880421907411028, 0.22633529810954256, 0.18470092548939943, 0.09014909271199756, 0.25180913451090925, 0.15682567208288545, 0.20275891931239232, 0.16297328103289876, 0.18423156279576736, 0.18703224425597076, 0.253450415784118, 0.16673399011792012, 0.15963358882001522, 0.24493561574882527, 0.233243896444971, 0.24355980207330563, 0.08018327256405677, 0.07524491885319107, 0.10064981604012113, 0.19033898547009742, 0.08988642039610129, 0.10060046068789286, 0.07346608094040441, 0.08344836090570551, 0.08343777444268885, 0.12265171559001975, 0.10363889104248591, 0.1553235248188254, 0.1209620042106353, 0.15665441523262746, 0.10326102819170957, 0.11141875842328486, 0.15347566001564572, 0.07879032080122539, 0.02688472618339821, 0.038917785313007935, 0.026867641890638283, 0.014144134891222904, 0.024672674027527264, 0.03498844642181809, 0.03912475303803964, 0.022197732277077775, 0.04157864946886891, 0.154197820743742, 0.13479455745128666, 0.14403417198246826, 0.16352617512260226, 0.1556290826841903, 0.1491848329842469, 0.1776529812075387, 0.17826685847526258, 0.14045457885669566, 0.4539697854058077, 0.4542479195392225, 0.4654626354510776, 0.45996875832834705, 0.4457915098083738, 0.47478344012978135, 0.46550462021256667, 0.4324870821986768, 0.4507705773902576, 0.06851377253025659, 0.07199362662319786, 0.0989954627228542, 0.12966838035423311, 0.12586721952337443, 0.10215828478413735, 0.12064432269855385, 0.12656139147240597, 0.11265962666843643, 0.17003342935751264, 0.15100588813151494, 0.14851233360829952, 0.18850377240584448, 0.13866356964103577, 0.14105451563381521, 0.29970687278220076, 0.1028773677761694, 0.1324026663716824, 0.33429975445067595, 0.31105857248409885, 0.24860875410021555, 0.24906094379202948, 0.30717120202589643, 0.31825760411618687, 0.30559036561082065, 0.30246973021382606, 0.204586638005277, 0.24973364597088044, 0.23176179689992737, 0.22551156076037593, 0.2150094238715471, 0.2642329981873507, 0.2520342777718222, 0.25316761940600885, 0.2520384542562173, 0.24659903717891862, 0.18242952864216833, 0.1761887540389695, 0.17288591864162284, 0.18561460681398456, 0.19358503059276266, 0.20047315196778526, 0.18039681210481773, 0.20356346604704534, 0.17108572219724405, 0.1957531610553076, 0.3640182674116431, 0.17825943579638082, 0.20438884489573517, 0.200414501000298, 0.1954461405610769, 0.20649265506555015, 0.22745973393364816, 0.1681059579577333, 0.1799192884434182, 0.5654730935160222, 0.7707933505852982, 0.17327717105447848, 0.1866832707945587, 0.18023386405987507, 0.18437701800408146, 0.16116052975495765, 0.5644952423318172, 0.16218624302772333, 0.16785116972726188, 0.19951132136271377, 0.19794430855890954, 0.1970687418820909, 0.7560349111315916, 0.20371217435551536, 0.14882193411535283, 0.1226703864963149, 0.19285759674848046, 0.1891129194935416, 0.1846582148328595, 0.18333589608803813, 0.174298393683191, 0.19395387610369874, 0.18216899107690998, 0.17513643124891154, 0.1901994428538809, 0.06495079771751266, 0.06706121618567773, 0.07154523816596425, 0.07417780015871578, 0.0653646481362985, 0.0791643971331929, 0.07860383785969238, 0.0668311639918675, 0.07416071369172061]}, "mutation_prompt": null}
{"id": "a3728185-1050-4f4c-a034-be7ddb700844", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 15 * dim // 3)  # Slightly increased population size\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.2  # Adjusted adaptive sigma\n        self.mutation_strategy = [0.4, 0.8, 1.2]  # Expanded self-adaptive mutation factor\n        self.alpha = 0.02  # New parameter for quantum-inspired perturbation\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim) + self.alpha * np.random.uniform(-1, 1, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.1, 0.5)  # Adjusted scaling\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.9, 0.05)  # Adjusted scaling\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Strategy Transition for Enhanced Exploitation and Exploration.", "configspace": "", "generation": 16, "fitness": 0.1920892809610063, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.43262075485948914, 0.42902048023331996, 0.4784651264417378, 0.4307437568749115, 0.4303767343076438, 0.4387990659156137, 0.43002887354951713, 0.42435665261559774, 0.4252471736485912, 0.044090749021176046, 0.07697933179309546, 0.009301342318783878, 0.0364341730805825, 0.021191726493168028, 0.0068227126039762664, 0.027889197840905267, 0.042033968379394215, 0.02397208112130378, 0.08499926301085126, 0.08902982927629166, 0.08150524327614972, 0.08083306548167113, 0.07973849091545837, 0.07109730244634627, 0.08696686427758538, 0.08589267635655173, 0.09013592283066285, 0.06952292164463181, 0.07105311055621444, 0.07514651116086535, 0.08560358228986698, 0.08015053625140878, 0.07738545907583216, 0.10283302650141346, 0.08578985215192791, 0.08582358559107484, 0.8745813999288831, 0.8765303828355767, 0.7969868636872715, 0.8442330174506217, 0.8973805105698315, 0.881867905778829, 0.8834941095836734, 0.873952599963754, 0.8920969927227337, 0.2435832692496659, 0.2422375730918609, 0.23949384784295058, 0.23537325810059606, 0.24522258632569538, 0.24072824062546871, 0.23496617815834098, 0.25926499280311965, 0.25810221862910454, 0.31005032504159513, 0.2910444032064895, 0.2866041623927206, 0.31752572212419083, 0.4811221451733614, 0.30157833574309123, 0.29796315927376193, 0.3083565985143991, 0.320892309682959, 0.13848052900962282, 0.14143486592668453, 0.14477849181698987, 0.14630462591378235, 0.13906948864908986, 0.13246985786161114, 0.14434913174942465, 0.16493778189646002, 0.1614646032975523, 0.1310814506294823, 0.13656236703014168, 0.08653203927033737, 0.13524859012186774, 0.13296696705506983, 0.1409115096043011, 0.1431224600418367, 0.10072130041745908, 0.1521115654649351, 9.999999999998899e-05, 0.02787759155415004, 9.999999999998899e-05, 0.01532348404457684, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027098116069508293, 9.999999999998899e-05, 9.999999999998899e-05, 0.042821739464519504, 0.06466910528373204, 0.05753865032670691, 0.06642024701588156, 0.0622615876033793, 0.05053377589003649, 0.08330433730492626, 0.052224023388000584, 0.05227511618000813, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08400420177198886, 0.07832781351719675, 0.11736707763277521, 0.09861824915113393, 0.08765959809770285, 0.08855007747247312, 0.09268245692539845, 0.08620094841238424, 0.09156661452951886, 0.37776325559643564, 0.3963976905837886, 0.36987116284587085, 0.3827678980757794, 0.373307024200184, 0.38156048947650456, 0.3761911022185406, 0.37251162893200696, 0.38306931829521795, 0.07429771750795866, 0.07859205360152921, 0.07664705954625806, 0.08571491424118216, 0.07933477058299887, 0.06938917564259972, 0.0936667132421164, 0.08509598307230282, 0.07449279842996226, 0.1190020318195415, 0.15975470080649212, 0.23456449463480944, 0.1495412461764266, 0.12754835405946519, 0.11960627322649053, 0.16057370640388913, 0.13901108037363397, 0.16627565820370493, 0.256835878379033, 0.2571781763300294, 0.25626232321651965, 0.2825869167771532, 0.26833376619261673, 0.2600243248142037, 0.2645377228085639, 0.27508171233723366, 0.26228934769279577, 0.19115633874761429, 0.17084222489500822, 0.1752089429109357, 0.19312867277213697, 0.18531624428737736, 0.19921507463273236, 0.20811035511089926, 0.22413679125692887, 0.18365078568627602, 0.17047174369463314, 0.17190719026547596, 0.1732939135834578, 0.16687098362168362, 0.16968241564489128, 0.1717274827633537, 0.16981909246198323, 0.19227503420253478, 0.19051160937273792, 0.17732025238046678, 0.16621774601890194, 0.17219204796498633, 0.16611464083785232, 0.1802618203350418, 0.1766468412247043, 0.17314718123675177, 0.1671817800251585, 0.16509001054013428, 0.44597200037991935, 0.160056584813151, 0.149376042939813, 0.3556134652695111, 0.16564568937292046, 0.15897714504817717, 0.1582793191787346, 0.42528281614961394, 0.16112614017345828, 0.18422362468827447, 0.31276297677936715, 0.19582919773109686, 0.24370630921467196, 0.15348848709576246, 0.17096485995860344, 0.10166953835458481, 0.20620740485221756, 0.20846550487471216, 0.1822175877892459, 0.1726241001752733, 0.1750331575929427, 0.20875437389177565, 0.1872716237239508, 0.17934915489949144, 0.18542774009820306, 0.1979366111055184, 0.16543397543225058, 0.0700853546491147, 0.08375518522961356, 0.06275129575579597, 0.07514583980265321, 0.06402565856110143, 0.07255701090745592, 0.06562592744507567, 0.06872906464389184, 0.07163984655668032]}, "mutation_prompt": null}
{"id": "c03e54a9-b430-45ec-a2b1-343b6c7896c6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)  # Adjust population size dynamically\n        self.mutation_factor = 0.85  # Slight change in mutation factor\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]  # Self-adaptive mutation factor remains\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)  # Increase the growth rate for sigma\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)  # Decrease shrink rate for sigma\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Perturbation and Self-Tuning Strategies for Enhanced Global Exploration.", "configspace": "", "generation": 17, "fitness": 0.24336210276481182, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.23.", "error": "", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.5237437337891607, 0.5213488099247192, 0.5568285568494674, 0.5252282832656503, 0.5721229307136808, 0.5192272926312375, 0.5498690536589894, 0.5921288574470482, 0.5055351137633127, 0.12002922270524163, 0.07100115220934988, 0.05885950613256885, 0.0785281597876698, 0.08379052390912078, 0.09509074551226893, 0.0833202194933167, 0.11723398108724015, 0.09447858582387092, 0.08921362550280554, 0.079535506294942, 0.07276265165646367, 0.08748592950161893, 0.10660529873597402, 0.07376209354022412, 0.06728541070219984, 0.08716802086053954, 0.08845137284305293, 0.0897946889928527, 0.09308412750967376, 0.081297071245506, 0.07382650789851619, 0.06851476017339775, 0.0871827660440706, 0.07323151870484768, 0.07292710306058403, 0.07998596747399112, 0.8641921192798743, 0.8794262355936275, 0.9254824958865105, 0.8922624020899343, 0.8536879582460661, 0.8750256720583222, 0.8801362295253812, 0.8678328461374953, 0.8688075071697794, 0.32574788148750666, 0.36813658632108937, 0.31998816248548645, 0.29681331208896833, 0.34657952904405354, 0.2904212798125, 0.33130249896041497, 0.322798107356261, 0.33401844892914756, 0.8082105340095604, 0.3559468738294318, 0.8157723751335225, 0.7834177095310493, 0.7622654748602318, 0.7907047633867667, 0.8208910096363025, 0.14591387048701088, 0.7587623495936348, 0.1720797509776243, 0.18396269835117107, 0.2503329464987183, 0.1289890798058082, 0.13114621840609275, 0.21264639277803088, 0.2355394490875813, 0.1943598474307725, 0.12628121168701234, 0.11400226339363762, 0.20280828723947475, 0.22130695958643165, 0.11640315458517148, 0.20422880735039484, 0.2012330555990577, 0.20493991580261406, 0.26840177021117506, 0.1649661028505398, 0.06145765869717945, 0.054760584594789496, 9.999999999998899e-05, 0.06382839813991437, 0.08665871441172601, 0.094772674689095, 0.047638059067560024, 0.06023382631324625, 0.0726582868755199, 0.07373524311577861, 0.09481241447560496, 0.0801203650291673, 0.11034125842344256, 0.09417100079781027, 0.0856141818115348, 0.12248476472038039, 0.085640697621021, 0.11615787231099817, 0.012652326591051088, 0.011440404854175856, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021138666892830726, 9.999999999998899e-05, 0.00652953726398553, 9.999999999998899e-05, 0.1512932634173887, 0.12624859617457151, 0.12481527028052097, 0.1296173980958627, 0.11672809651057181, 0.14417093008030502, 0.14564925587753408, 0.1692018503151741, 0.13000069657953572, 0.43032611626280803, 0.4410312305011048, 0.44148237563261206, 0.4252489660567419, 0.42463907172150417, 0.4622825043519425, 0.4583096590802722, 0.41033513889420237, 0.4252497737047596, 0.07376987439348903, 0.08247175201411738, 0.08376856608147631, 0.0654048990824233, 0.07310466536180116, 0.09093143087078948, 0.08568473335661042, 0.07960427584474894, 0.08159982045436698, 0.13260640039934302, 0.13717376934810888, 0.1340689867346686, 0.12223774101484142, 0.147169522748119, 0.12684290766705086, 0.15873508758462318, 0.24327730859452346, 0.13622057877380955, 0.21153742683404653, 0.3036853505532916, 0.31117382424035245, 0.2886348508719768, 0.2959724035944782, 0.3060135358842242, 0.3160491019238537, 0.32452362338314955, 0.28540159984383073, 0.22558710354778255, 0.22909577330972597, 0.23164312534893194, 0.22300883376727076, 0.21792340046970515, 0.239139164006119, 0.256669851306884, 0.24942072638265766, 0.22976197814514965, 0.17432607705056435, 0.1803235089172589, 0.18710555416723107, 0.16665248594822746, 0.1711084433131035, 0.17581245768667209, 0.18786754742862677, 0.17492062887276294, 0.17138555075774242, 0.1676951015462138, 0.17916828722551292, 0.16730327637839715, 0.16912226803420072, 0.16756814989354663, 0.17304323019133494, 0.16228704117804593, 0.1659845179131053, 0.16351973192524238, 0.7066966067754932, 0.7566735368653422, 0.1836148057009327, 0.678585416489928, 0.19502092024028028, 0.7714490808536523, 0.7995355144779258, 0.1664302725114487, 0.16492873175210332, 0.16503933815574834, 0.19992204407840541, 0.2067541416789599, 0.1927673686511463, 0.6965450228655599, 0.15227969776456207, 0.12389823215974904, 0.15142175857510376, 0.15183218723370173, 0.18015965457395489, 0.1703954083199598, 0.1761336758811407, 0.1751567731085093, 0.18191578185778157, 0.17820094499665484, 0.18095748412267876, 0.18605283459842115, 0.17213400501999154, 0.09911302011432421, 0.06479801513972638, 0.0682296760919584, 0.07347156445678116, 0.06906070431697209, 0.05653853072940129, 0.06627386497836563, 0.06283313558985826, 0.06355817004606035]}, "mutation_prompt": null}
{"id": "63ac0e02-99a7-4753-8f64-3096ffa4a2d7", "solution": "import numpy as np\n\nclass HybridSelfAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(8, 8 * dim // 3)  # Reduced population size for faster convergence\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0, 1.5]  # Broadened self-adaptive mutation factor options\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.1, 1.0)  # Smaller increment for stability\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.85, 0.01)  # Larger decrement to encourage diversity\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridSelfAdaptiveDifferentialEvolution", "description": "Hybrid Self-Adaptive Differential Evolution with Dynamic Strategy Adjustment and Adaptive Mutation for Improved Convergence.", "configspace": "", "generation": 18, "fitness": 0.2362832510978596, "feedback": "The algorithm HybridSelfAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.5007574094552896, 0.5322070089991515, 0.6028880224163697, 0.5291344709850807, 0.5677935502992658, 0.5001095219540593, 0.48387538959234666, 0.5229272552833764, 0.531246186524954, 0.12858514292618606, 0.12049097361505023, 0.09403714228864024, 0.10087241841739236, 0.057583838079107386, 0.09496676529817705, 0.11921182083487836, 0.1162102501335105, 0.10874729870358513, 0.11789382195469511, 0.11159638952390216, 0.07087104795925114, 0.1543316243906151, 0.08180542004034619, 0.08803048516124856, 0.08790777239395353, 0.08973855099586547, 0.08908362803579162, 0.07270673740489797, 0.10476190233888083, 0.06653220516229053, 0.08796675208348714, 0.08189899915628918, 0.0815225962863455, 0.09136258533157993, 0.09029677562203164, 0.11065050166209, 0.8805136875137836, 0.9077099729441246, 0.8884851149566941, 0.945948922658225, 0.9166048673982146, 0.9078433436681878, 0.8908905629515519, 0.9038584581528887, 0.8790898089721724, 0.3306144295892164, 0.31859011175515095, 0.33844590173755396, 0.3146974391644811, 0.3511605745166081, 0.29477598895919455, 0.3593772951755827, 0.32399927801866857, 0.3139466366323662, 0.7392846764613055, 0.7707291770592474, 0.745166809116689, 0.79798580166983, 0.38509180106807595, 0.7902741727073215, 0.7178891733184092, 0.5662613288971414, 0.22905272204581995, 0.18517753604959053, 0.2049257291383103, 0.18331217097243302, 0.1891634620920415, 0.22020042168119947, 0.12298072079496247, 0.18642187832816137, 0.2072130227336988, 0.24600576724842227, 0.11415985824393315, 0.10898265009113473, 0.11660990068632926, 0.20432600313252147, 0.22541076561836504, 0.23836180474938862, 0.19899091431589644, 0.18091220072781955, 0.2197539545800078, 0.054824161060177956, 0.07233969014110075, 0.04844411379829494, 0.011875775794834231, 0.05579459408888088, 0.0888520514497515, 0.04750644852403296, 0.049682013658633895, 0.0655578770431654, 0.1281020879970043, 0.12740472811920323, 0.10445001360766659, 0.06886616762452036, 0.044973945485765054, 0.055180490087696654, 0.15592292968194543, 0.031484647398308474, 0.11016610793791337, 0.01949907585364219, 9.999999999998899e-05, 9.999999999998899e-05, 0.05348947630008116, 0.02068515438208729, 0.08190319047006978, 9.999999999998899e-05, 0.016022100517142146, 0.03837825797264138, 0.13487409063787892, 0.1576848257232939, 0.12100367663433897, 0.16420434713491106, 0.1403244484504872, 0.15541192122952074, 0.15667151790539702, 0.1542055573438771, 0.12852115424960497, 0.41896963285760025, 0.41841113707630884, 0.43202310373539143, 0.4080984955659265, 0.43874982365404847, 0.4425897033209961, 0.43528775288171795, 0.43631513025892676, 0.4542681751109495, 0.07916488923923315, 0.09131678872797766, 0.07370379755140033, 0.0802241513454206, 0.07907880486982743, 0.09276333400583558, 0.07692288895466803, 0.0701327394818847, 0.10312104737748473, 0.12959354016946, 0.1460116356851946, 0.1478320777410458, 0.12746342070375072, 0.13898833091842877, 0.1399396005408451, 0.21120559874254552, 0.3209448289883361, 0.1396076279192161, 0.3012413887801145, 0.27260649280637894, 0.305751687425568, 0.3121078917512853, 0.2904564480351248, 0.2756825026494161, 0.30737444899402633, 0.30357975627223155, 0.2875473013060166, 0.20116698718900416, 0.18588523003130708, 0.22951257888663223, 0.21948783259324134, 0.18742486878206366, 0.25789194922504544, 0.24356735681009156, 0.2378274161144689, 0.2404458596292407, 0.17474551223129786, 0.17027121560781378, 0.1785738076893052, 0.17065502248909392, 0.1692321842353678, 0.1853744924551446, 0.1966579809948411, 0.17483141332317842, 0.18422249512257893, 0.18057026305353174, 0.18085187951355042, 0.18669848173476844, 0.18230498665414452, 0.18580337992506224, 0.17947657561076247, 0.1839303590419119, 0.17955156491964863, 0.17149195648269577, 0.6905675257563553, 0.7725920267714468, 0.15309037647329637, 0.12172883436912618, 0.19321640865490763, 0.1847227760045952, 0.20144681752963067, 0.16753038054865133, 0.19304696006658295, 0.16488493639273716, 0.2067629687733732, 0.1436376210989443, 0.20762113777745705, 0.2023275496070811, 0.1554674244705031, 0.20714614185304947, 0.2075480953074107, 0.2075788208027609, 0.18298745412982453, 0.19371998372345656, 0.17706972825407863, 0.1923076488749168, 0.1791334049556197, 0.17228014073049158, 0.17275191050722039, 0.18233788906539505, 0.17132339994221568, 0.06767375602627779, 0.06158740274814212, 0.06581142928531503, 0.07777592203052808, 0.056311188054382955, 0.06891738824012372, 0.06458874876068099, 0.06252868405320755, 0.06322401180094295]}, "mutation_prompt": null}
{"id": "b8e56c20-b45a-4f57-af9b-ac1a827d6e16", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)  # Adjust population size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]  # Adding self-adaptive mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with Adaptive Population Size and Self-Adaptive Mutation Strategy for Robust Performance.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.49568991282865293, 0.5609129062753054, 0.5454570631785307, 0.5276329961814406, 0.5667415584074479, 0.5526681965948148, 0.5459613828097101, 0.5337191292944101, 0.5155386640537143, 0.13287487503997653, 0.10670014952838303, 0.06692825888454512, 0.09326676709106174, 0.09784647386179535, 0.09708708490966733, 0.11099193821568698, 0.09949630353266259, 0.06915461992829008, 0.08971123158298655, 0.14405936532935593, 0.09260991947424768, 0.07471031775506631, 0.09409545846535439, 0.09983536314110841, 0.08567607046964332, 0.07197741912934286, 0.0897234681060769, 0.07065085092214796, 0.07357275369590022, 0.08106881431286528, 0.10062343460007672, 0.07617884866295954, 0.11362680971595784, 0.11807803331985411, 0.08823229839862634, 0.10882050817120892, 0.9059483889935853, 0.8716605395728954, 0.9364530668212362, 0.8287047744400401, 0.8472653465869171, 0.8619433229725021, 0.8565564805128323, 0.8844506150044527, 0.9221222509475404, 0.35312211828952755, 0.31713525340079873, 0.3662809490752148, 0.3501803203656244, 0.31101759677443863, 0.3319878098525323, 0.30883920959291766, 0.3260090506047837, 0.30173438506575834, 0.2149924128498214, 0.7171873437144838, 0.7293543178052186, 0.7393370277275653, 0.7570336820239753, 0.7804347176779627, 0.8083234468541868, 0.20136250713043502, 0.8002137572139699, 0.1175667679955621, 0.2563533095786996, 0.2730757202392581, 0.20806631674861453, 0.20914402037568014, 0.19705529408180877, 0.20265202226432555, 0.17542122307541141, 0.18671335340987338, 0.1115599026642321, 0.11253380196200413, 0.1691938496796873, 0.25860659037947265, 0.17249259946646156, 0.2088886466094052, 0.20176491539219077, 0.2005607885363634, 0.19328246406209693, 0.09738093086336608, 0.10176279226277418, 0.0332301848469273, 0.05620227433669023, 0.065083886348825, 0.032944120834552115, 0.03423020869025328, 0.054214113565149824, 0.11509418614107803, 0.1350188634594579, 0.14622899821208046, 0.11278431896139374, 0.13329395073231243, 0.08531324866244283, 0.11594647933317226, 0.09718151749201664, 0.17725403975154064, 0.04578750672037024, 0.004449044109719247, 9.999999999998899e-05, 9.999999999998899e-05, 0.00456794763305568, 0.02717763738359591, 0.04683397934048239, 0.023807585389137076, 0.0022510045112663635, 0.02877676899350412, 0.11140166195704582, 0.15099695693480697, 0.16231609648630652, 0.16269651000348895, 0.12702193450623822, 0.1304857541230251, 0.1332320394056533, 0.17713729415661017, 0.15761335135741006, 0.45329945447929876, 0.43725350067312563, 0.4521238496007858, 0.4711520199486746, 0.441207893243179, 0.4429774055517499, 0.4589829284397131, 0.4597276632098406, 0.46756505425729544, 0.09154615751776507, 0.08715700532390058, 0.0949611980087709, 0.09676365544456689, 0.07811488586854398, 0.06867174168665091, 0.0721922736033046, 0.10181704471656616, 0.0881417696640523, 0.1344967295445475, 0.1285138064172262, 0.13185131717034493, 0.1294338175476909, 0.19169182224475056, 0.12764047603227924, 0.1223606161412617, 0.22107313565519804, 0.14297599734345112, 0.3271426143659629, 0.31378086729150445, 0.29544715034361413, 0.2929434921867917, 0.3113682884608323, 0.2972472846624984, 0.31783997489530635, 0.3186054771852046, 0.3393223081331165, 0.24647840328015747, 0.23010809916584052, 0.23931848263486233, 0.2277788984476682, 0.23955864858974496, 0.2268957747805218, 0.2589048681087096, 0.267486515982889, 0.2443592813278045, 0.16220871448631902, 0.18252246624615887, 0.1736885270554258, 0.18091186888003663, 0.17248168954471987, 0.16761779063984572, 0.17056843436142222, 0.18142235951705643, 0.17160144694064527, 0.18112786082445764, 0.19990115425450872, 0.1869185738223612, 0.17231424105942827, 0.18251222022428137, 0.16602594516626834, 0.17715068016182756, 0.17405354565846132, 0.17644220889253304, 0.675267344783971, 0.7799228104694149, 0.18248892403426253, 0.7774252737242051, 0.1838459271533749, 0.7429494613645686, 0.7464662956637469, 0.16653745445781565, 0.164778399249759, 0.16532993443355992, 0.20368236442652732, 0.20706693087060846, 0.19295287120945392, 0.7391474631324462, 0.15218725668583755, 0.12527155175218374, 0.15103509117123848, 0.1514391471843206, 0.17484954481431847, 0.17242467675974582, 0.169989733961721, 0.17640623155635915, 0.17168665441512498, 0.18579966183658192, 0.17958341786294618, 0.17121219406500499, 0.16944965721321348, 0.08458269807162344, 0.06154460218686386, 0.06896426320660265, 0.06413534419834754, 0.07086803876802972, 0.0742706992642106, 0.06496016827121909, 0.0688949473394721, 0.06814732910511234]}, "mutation_prompt": null}
{"id": "87441559-a766-4816-b6ec-44eae3fca0ae", "solution": "import numpy as np\n\nclass AdaptiveSwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 10 * dim // 2)  # Adjusted population size for diversity\n        self.initial_mutation_factor = 0.8\n        self.initial_crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.5]  # Expanded range for self-adaptive mutation factor\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = self.population.copy()\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                crossover_rate = self.initial_crossover_rate * (1 - evaluations / self.budget) \n                trial = np.where(np.random.rand(self.dim) < crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                    if trial_fitness < self.personal_best_fitness[i]:\n                        self.personal_best_fitness[i] = trial_fitness\n                        self.personal_best_positions[i] = trial_perturbed\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n\n            # Update velocities and move particles\n            inertia = 0.5 + np.random.random() / 2\n            cognitive = 1.5\n            social = 1.5\n            for i in range(self.population_size):\n                self.velocities[i] = (\n                    inertia * self.velocities[i] +\n                    cognitive * np.random.random(self.dim) * (self.personal_best_positions[i] - self.population[i]) +\n                    social * np.random.random(self.dim) * (self.best_solution - self.population[i])\n                )\n                new_population[i] = self.population[i] + self.velocities[i]\n                new_population[i] = np.clip(new_population[i], *self.bounds)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveSwarmDifferentialEvolution", "description": "Adaptive Particle Swarm-Enhanced Differential Evolution with Dynamic Mutation and Crossover Rates for Improved Convergence.", "configspace": "", "generation": 20, "fitness": 0.19302714291897355, "feedback": "The algorithm AdaptiveSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.3936202077180637, 0.3869469181027331, 0.40671646453255983, 0.43319209805901626, 0.4683741188802588, 0.4026429528636768, 0.4269663399276675, 0.4245248053124506, 0.4217990314864163, 0.0999904369515332, 0.10234020272127842, 0.05624370616860919, 0.08807981860803482, 0.027653789977941212, 0.06079991311535704, 0.08915037999940101, 0.09566855535534047, 0.06056146178352251, 0.08576254496218005, 0.091781725194088, 0.09229454042345475, 0.09360408569593548, 0.12523123428494487, 0.09063418777348575, 0.11191588386001494, 0.09045264711268208, 0.09340584012475706, 0.08787234863491844, 0.07889114792531404, 0.08383313904909317, 0.0914977322567363, 0.07337997660767015, 0.08451230696692547, 0.0872982605391589, 0.08274471306975462, 0.08769256325812291, 0.9847510265037868, 0.9907595378544559, 0.9779398772219472, 0.9789164693398675, 0.9900837487842966, 0.9803953363688924, 0.990334743206049, 0.9846861046766489, 0.9819766000876305, 0.22222626632031783, 0.19647259570243436, 0.20909615009924787, 0.18819447159388225, 0.21676411865249068, 0.19418083002035313, 0.1968123673934309, 0.1548528372349096, 0.20852153527851658, 0.21759723728054958, 0.18805761502175244, 0.22563581721029147, 0.19057629705081858, 0.44806301270106774, 0.18865937044310221, 0.2100765377748819, 0.2403249349336991, 0.22539051379938135, 0.13926186829490272, 0.11780656414799484, 0.1516794438560226, 0.1295259511563105, 0.07909006692605713, 0.10934957509352317, 0.10757309999601294, 0.12558521386635912, 0.13144146317682315, 0.10108546029248189, 0.10326288227944991, 0.1028381728671125, 0.1379197789047878, 0.11143819417975176, 0.12030809615453852, 0.14467293222077715, 0.11752880294476731, 0.08167453114346557, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015123420505109841, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.024994922694150046, 0.08049785432664269, 0.08325564703590049, 0.031126843056529463, 0.015792584573864787, 0.00512062489097187, 0.03594738616754478, 0.05963652174343681, 0.012180085865164392, 0.0006256398659665319, 0.004519664476575036, 0.0061822802453221914, 0.007721268981719875, 0.004808252067290186, 0.0016658319484711415, 0.032580573658761436, 0.020863301236750176, 0.00969200746025456, 0.06618299720846588, 0.08295179470876013, 0.06332983923941449, 0.03106286893078536, 0.07798557414312601, 0.06767729764182606, 0.06731346369809321, 0.0646281812873265, 0.08979615516778072, 0.3712390829986558, 0.38826521590292595, 0.35589338627649947, 0.355322282300664, 0.3783553340699225, 0.3478138719920736, 0.3370242612362926, 0.3589187505661001, 0.3697937718376757, 0.07943603779395958, 0.08040421535278164, 0.08108490581945293, 0.09229385990287386, 0.08608692438466514, 0.09152414641869366, 0.0970458128686863, 0.08682244551985863, 0.08471981441232512, 0.18736625648619176, 0.18958295304927986, 0.14548216063571184, 0.35017622505006885, 0.17910071945653017, 0.15610700730863314, 0.1677343266307869, 0.15761861539262068, 0.17961777443282023, 0.2498942262284456, 0.2669650209332002, 0.2557458592571754, 0.2630837243499001, 0.22788030207524457, 0.25288358727002214, 0.2525997564215079, 0.2758922649225437, 0.25764325853065273, 0.18560740977655854, 0.18533481457506717, 0.14310975951563176, 0.16568349991362885, 0.16793525954956934, 0.1682343020377759, 0.20205410620911812, 0.18253448725387678, 0.17465665859410906, 0.21478346266960857, 0.18870135977864055, 0.1801548013119273, 0.2104148253026148, 0.19734122434691403, 0.1874851382244772, 0.2049432940103617, 0.19270501649886107, 0.19169543250379206, 0.1877065020212383, 0.19839275831441583, 0.17463516717154726, 0.17879795180164948, 0.1871099446891895, 0.1752182782188112, 0.1648073236241191, 0.17912749590009314, 0.17695150216473376, 0.1483529639668132, 0.4448131610184196, 0.19993979195388234, 0.18488879631937638, 0.18194597252870282, 0.19200524008712538, 0.5195474027964027, 0.19916137938071077, 0.4475142220486862, 0.3730353978291887, 0.200478482790151, 0.14693460276304393, 0.1807711831591139, 0.12487347553948347, 0.1732671509510807, 0.20796866060582253, 0.12545477634880986, 0.20401677417083597, 0.20128805821470708, 0.18285337161266702, 0.19027971436665148, 0.18157878313760967, 0.18628092373890315, 0.19651331150275242, 0.18727047000961017, 0.19774636673199097, 0.18133612702564572, 0.08518143295382141, 0.07340240481677651, 0.07334663345394687, 0.06602791777565564, 0.07458046951081743, 0.09940076641782003, 0.069165681180416, 0.0705132471189911, 0.07667188887773968]}, "mutation_prompt": null}
{"id": "fc2de002-380b-44fe-ae7f-a4f49d66b1fa", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 12 * dim // 3)  # Adjusted population size\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.08\n        self.mutation_strategy = [0.5, 0.9, 1.2]  # Expanded self-adaptive mutation factors\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.1, 0.5)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.9, 0.01)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMultiStrategyDifferentialEvolution", "description": "Adaptive Multi-Strategy Differential Evolution with Dynamic Parameter Tuning for Enhanced Convergence and Robustness.", "configspace": "", "generation": 21, "fitness": 0.21032915869319466, "feedback": "The algorithm AdaptiveMultiStrategyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.5172025763147856, 0.5118953935433719, 0.5330626468210249, 0.5351339590460383, 0.5289033723636158, 0.5437987418396882, 0.5209465036733014, 0.5248383787046577, 0.5033072513122145, 0.10338562933904827, 0.11668183017187805, 0.1046570862181565, 0.1032901465477527, 0.11015053440428202, 0.07242378486888279, 0.10600514216555657, 0.10478227208091706, 0.10315944273429922, 0.08755474533287921, 0.09247036804753883, 0.11515245614664527, 0.08935415958531234, 0.09834448942653762, 0.1028921647104204, 0.09299617113493319, 0.1037457267520604, 0.0978761344960738, 0.08873967566631713, 0.09113094261879706, 0.09143018476345077, 0.0675461306044699, 0.07876764980861684, 0.0827566449210746, 0.0995320993152583, 0.10472532159664583, 0.0750901436265643, 0.880659751410253, 0.9178551725344496, 0.8380671792591863, 0.8656644874444334, 0.9102970126963719, 0.8704944420546263, 0.9022325805539443, 0.8759343810115292, 0.8419855827795264, 0.2876761244261177, 0.258780305285336, 0.30001130744709137, 0.2706076288882885, 0.3185712290153866, 0.2778488490366857, 0.3208850692011762, 0.2804707600580454, 0.29637836662683514, 0.30526399789218683, 0.511531039580103, 0.2472274896061465, 0.34510989099762623, 0.31155009919106413, 0.5962001774039908, 0.4963248531310903, 0.4990627062731988, 0.6272105655089608, 0.20845382816485603, 0.18704972199916658, 0.1738078653757178, 0.1143252926689724, 0.18130403187893174, 0.15079825630712274, 0.17208539731466121, 0.15845427259491573, 0.17967671513466543, 0.1658974452242552, 0.11079226732402148, 0.16849964476037804, 0.1551270098868126, 0.1567540091976103, 0.167725157767589, 0.17017637309218792, 0.1536880900196329, 0.17511876576147334, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00894038106319206, 9.999999999998899e-05, 9.999999999998899e-05, 0.012611620377845467, 9.999999999998899e-05, 0.08261439749333477, 0.08657720170297512, 0.07724038636973929, 0.04116324016828243, 0.045361324400036374, 0.0760393549808126, 0.05313719485307844, 0.0834356617706371, 0.086791968886623, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020261424932003336, 9.999999999998899e-05, 0.10525861808341486, 0.10020940715260962, 0.10787266183186761, 0.12009781145055964, 0.10011316042913254, 0.11263157865068862, 0.12078457149230815, 0.1097046803668622, 0.11398012193276297, 0.41081788739573144, 0.39543252709648846, 0.40027147603880453, 0.40471373473441263, 0.4112151587527213, 0.4098450460785583, 0.4059520103502633, 0.37483929432373997, 0.40995927373024876, 0.07474844603620134, 0.08595984772240595, 0.07234330574277814, 0.09898815348339451, 0.08763147082539868, 0.0820667234811786, 0.08249103081947329, 0.08706784390494138, 0.06765825669603531, 0.140090239444573, 0.11835757892307996, 0.1383789217629272, 0.1253321239953048, 0.15016652249115015, 0.15215839885690297, 0.16780451216385395, 0.15217046453799288, 0.1443641010445501, 0.2701641113549037, 0.27294312715083446, 0.2476022177138668, 0.2769567680426607, 0.2570548355821537, 0.2631987211506235, 0.2949653096670207, 0.2789541288469005, 0.2609571383197711, 0.21242128208564326, 0.18571321214499648, 0.163495100908844, 0.15361068100302366, 0.1764014214004359, 0.17278629694193537, 0.20549590770752024, 0.19546476307526273, 0.19524520440025994, 0.17768589966926085, 0.19771389060347844, 0.1869275083438806, 0.18335582609752799, 0.1590159644058169, 0.17971322482588092, 0.20437595610702197, 0.17777402385201635, 0.18551567932508883, 0.18024935424493183, 0.16843992359588578, 0.16791053564891467, 0.1833515962244524, 0.17358996489542156, 0.1657375617469079, 0.1839837161423602, 0.17700695801404087, 0.1711771182515317, 0.1863504204271772, 0.16070197882334358, 0.19325902955909213, 0.17158789355926984, 0.25049598476484447, 0.2428965088741576, 0.18680475335410052, 0.14243344451190154, 0.1424987914384621, 0.3498430433461204, 0.164436242556961, 0.16298333936222176, 0.14795181412700553, 0.2897569735307892, 0.2034428264239304, 0.15874738690636991, 0.44001660919758023, 0.20473107435854077, 0.19818840861860076, 0.18494868386442465, 0.17902487138113887, 0.172631976366052, 0.1947394529255928, 0.1899964392193657, 0.18563925930320802, 0.16942351882621787, 0.18488313863764538, 0.06459811889335454, 0.0804582581257024, 0.06856490089557943, 0.06338984379666235, 0.07100737332322482, 0.0766777759493954, 0.06092155365665908, 0.09269254219914169, 0.06290290382356856]}, "mutation_prompt": null}
{"id": "12e42878-e1f4-48ca-9687-7e6bc74da50d", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.rotation_angle = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                quantum_prob = np.random.rand(self.dim)\n                quantum_rotation = np.sin(quantum_prob * self.rotation_angle)\n                trial = np.where(quantum_prob < self.crossover_rate, mutant * quantum_rotation + self.population[i] * (1 - quantum_rotation), self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                else:\n                    new_population[i] = self.population[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.population = new_population\n\n            mean_position = np.mean(self.population, axis=0)\n            dist_to_mean = np.linalg.norm(self.population - mean_position, axis=1)\n            self.adaptive_sigma = np.clip(np.mean(dist_to_mean) / np.sqrt(self.dim), 0.01, 0.5)\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-Inspired Hybrid Differential Evolution with Self-Tuning Quantum Rotation Gates and Crossover for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 22, "fitness": 0.17611836249143867, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.5162437832464795, 0.5034970469881288, 0.5404180026459449, 0.49888511156060644, 0.49497979618148136, 0.5127188657406416, 0.5221523532819234, 0.5073083641442675, 0.4953824526724553, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07926669898867345, 0.07585602577464923, 0.05314192877887858, 0.07326592922368469, 0.0882205465981104, 0.08100538294017512, 0.0802026781813574, 0.08389411033715588, 0.07192956452554866, 0.06931134493163305, 0.06017601277940898, 0.06850957039943328, 0.0835134729473388, 0.06983764366092948, 0.06618374126905968, 0.05965167463216825, 0.07075396451995852, 0.06984062262102819, 0.6233377229523077, 0.7808083688368603, 0.5798299277471004, 0.4756719367264237, 0.6804500851947457, 0.6332101370332265, 0.6345081082135381, 0.6763315394477283, 0.6988501643331981, 0.19163821170503104, 0.20265131800638914, 0.20782898023571728, 0.1988276830633544, 0.21081680905011602, 0.21161613756625686, 0.1751745131112502, 0.189943006695118, 0.2293732482871036, 0.2196489777027536, 0.21890977603607797, 0.18497435453639177, 0.2481503030786255, 0.23676384307161502, 0.25061510330952974, 0.19155385305526085, 0.2258784268972741, 0.20350821697348387, 0.09997653047052102, 0.10182137599826258, 0.09909511400082971, 0.11634119927078368, 0.12421421259609511, 0.11131930547085866, 0.11249661345913808, 0.0978479293499368, 0.09971286188528516, 0.11220610588104496, 0.11193758894545502, 0.098847589893994, 0.1186787234147334, 0.10556372583114826, 0.10046748327517885, 0.12257784082249623, 0.10671619620813344, 0.11176301101529584, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000293853759278373, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13099893344230007, 0.0875583692393691, 0.09263576117959293, 0.05676255489368287, 0.07630622806799237, 0.10707550740798866, 0.2007870962396534, 0.05601483623342551, 0.09486841557950343, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04097567010249059, 0.037720817319791045, 0.044605910788874326, 0.0384029760393132, 0.05126583131073226, 0.04806171315510588, 0.04266542168389964, 0.05504046697506004, 0.048590962656797076, 0.3869142365500192, 0.37855390705298153, 0.3873650802362427, 0.367593359172696, 0.37284025017034406, 0.3719397343447203, 0.3745908907030564, 0.3909360073426247, 0.3685737120876388, 0.06406358408480006, 0.07913465129407193, 0.06246939090954251, 0.07954243590903876, 0.06924632091095428, 0.07056529382437549, 0.07958573965896287, 0.07830167945331101, 0.07377832918464888, 0.1767655711463123, 0.17463569694933334, 0.17918276838805292, 0.18615178641759, 0.1624389238329722, 0.14457531350222685, 0.12325515645894736, 0.17073369616252498, 0.14407676667815195, 0.18890330311195513, 0.20380171558227034, 0.17170868967988595, 0.21159824514145675, 0.21121423483109947, 0.19954380824727858, 0.1773707044148638, 0.23055961886561105, 0.16180045399559773, 0.08186093857731225, 0.15484648223570008, 0.13960753179960284, 0.15805447640066927, 0.15816486782885641, 0.16041001986350312, 0.14056005166071994, 0.16528584999289797, 0.10258966925672752, 0.17973273769746922, 0.18436100042583425, 0.21315061126973278, 0.15959757555514476, 0.18182306176335106, 0.1718425012953252, 0.1876575557070641, 0.17330704805143982, 0.19096837813114376, 0.17763163616707933, 0.17063745573534728, 0.16924677189846005, 0.18384153499793887, 0.18380524800817766, 0.16893528887976594, 0.17598135279645089, 0.16664140604762379, 0.16992283251475349, 0.33906749386902235, 0.3391030227554016, 0.3362621907441976, 0.35531539183472627, 0.29664280316920055, 0.37148130787781597, 0.17053809466528658, 0.33826167814428887, 0.35753046133902844, 0.2846723737314596, 0.24084457043552365, 0.48172898517308316, 0.28960463415988835, 0.2226561687324281, 0.24253373129545497, 0.2509563308577424, 0.1928856877251831, 0.18112926420789577, 0.17622606860867673, 0.17093108577166605, 0.1944879329428667, 0.1680976470512664, 0.18689369326345806, 0.20525839749072539, 0.18165737912420732, 0.17897043017237757, 0.17007562398241605, 0.07653391484299232, 0.06832504370306591, 0.06871327934460292, 0.07124618205917799, 0.05939465194035021, 0.0705802573262787, 0.08224066418290898, 0.07205058079173521, 0.06206215767846501]}, "mutation_prompt": null}
{"id": "436767db-d3f8-40dc-a053-561c7152613c", "solution": "import numpy as np\n\nclass AdaptiveEnsembleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 8 * dim // 3)  # Adjust population size\n        self.mutation_factor = 0.9  # Changed mutation factor\n        self.crossover_rate = 0.85  # Changed crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 0.9, 1.5]  # Added additional mutation strategy\n        self.strategy_probabilities = np.array([0.4, 0.4, 0.2])  # Probabilities for strategy selection\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                strategy_choice = np.random.choice(len(self.mutation_strategy), p=self.strategy_probabilities)\n                mutant = self.population[a] + self.mutation_strategy[strategy_choice] * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n                \n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:  # Adjusted stagnation condition\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)  # Adjusted sigma increase rate\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)  # Adjusted sigma decrease rate\n\n            # Update strategy probabilities based on performance\n            successful_strategies = [i for i in range(len(self.mutation_strategy)) \n                                     if func(new_population[i]) < func(self.population[i])]\n            if successful_strategies:\n                for idx in successful_strategies:\n                    self.strategy_probabilities[idx] += 0.05\n                self.strategy_probabilities /= self.strategy_probabilities.sum()\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveEnsembleDifferentialEvolution", "description": "Adaptive Ensemble Differential Evolution using Dynamic Strategy Selection and Noise Handling.", "configspace": "", "generation": 23, "fitness": 0.19456280642875526, "feedback": "The algorithm AdaptiveEnsembleDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.515067817219437, 0.4488363575178095, 0.47383802302658073, 0.4629978218087901, 0.5152269787553401, 0.4944088788309142, 0.47998446633387193, 0.5613583182547112, 0.44843623673497834, 0.06415494091383211, 0.07946256002710783, 0.06767723999521036, 0.08742358843084586, 0.09553993772629343, 0.035971128187153645, 0.044038422934221444, 0.05054434311009004, 0.05572958880829648, 0.08278111605327321, 0.07384947069446424, 0.07265983771926476, 0.09401486687996963, 0.10762135951370233, 0.06931161669486197, 0.09062627706779713, 0.07929867919084954, 0.09302862737829687, 0.061617955755796316, 0.0638453908140888, 0.06820945493390373, 0.1015597551102434, 0.07140903702024881, 0.06754506972543728, 0.060717305062338855, 0.07376611098435149, 0.06232002940809689, 0.8419666697897197, 0.8875016268917564, 0.9296216753728124, 0.8543674748189973, 0.9043613317182961, 0.8968141705280945, 0.8890036639947746, 0.8817940495123305, 0.9222472577469669, 0.29867452144259854, 0.2596472085020337, 0.26552550271969, 0.24997479136681866, 0.2771321590092819, 0.2618280889074084, 0.26541692674876605, 0.2806078298989436, 0.26284206027162305, 0.2184866361531349, 0.2117413994602999, 0.2830960262059199, 0.23756987099976745, 0.2538016713554846, 0.30044806264371915, 0.3026255765109416, 0.21768181553008392, 0.7539905564862969, 0.1363044335870578, 0.18313911765479662, 0.14022065556992858, 0.15993202008633867, 0.16255279238489928, 0.114102356039679, 0.18298192772524047, 0.14098818130531854, 0.13838151945538135, 0.13959814565451967, 0.1775856060216684, 0.11321930240754519, 0.12853910848963368, 0.13867934711679808, 0.18058481276536964, 0.1798873849332604, 0.1335608827481779, 0.12736020755549726, 9.999999999998899e-05, 0.009961635164936866, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0019769549545534115, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0435657219127259, 0.03341051478826318, 0.09544392670704072, 0.044195439953333304, 0.03774121407693187, 0.030972648969182615, 0.06524752161727387, 0.09634144686443324, 0.06406094044990118, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06380224047293892, 0.08495237542901701, 0.06281536889422479, 0.1176432491494559, 0.08394790585940737, 0.09693414195975658, 0.06312459296255257, 0.07870033775550966, 0.09044490350315315, 0.4140277040601694, 0.390097940799247, 0.4262212727588911, 0.39471286558240837, 0.4374338499133109, 0.39707262906933793, 0.40658927658589417, 0.4338704930226751, 0.46877252798287006, 0.06876560450584124, 0.06803926326875631, 0.07240656534709378, 0.08439164031324287, 0.06374408184242242, 0.08152542982484279, 0.08201455637656396, 0.06823893626140087, 0.06827163402905789, 0.14413437468919388, 0.16921283507447404, 0.14297072087257456, 0.11849862642423648, 0.13818689027926978, 0.14700784453074778, 0.12680359107391437, 0.13222599637819332, 0.1471213305252832, 0.22647593036110814, 0.20158522403339796, 0.25972546420426246, 0.2746081907979515, 0.2452370668096392, 0.27423089458993977, 0.21018418659317695, 0.2470300753616358, 0.26913912614433066, 0.1338392242537071, 0.18216506824409617, 0.19347248606863154, 0.14358254804007953, 0.18308247536598488, 0.1660539848069138, 0.17471875295019146, 0.15036048684432712, 0.14176885315936238, 0.17021449586902304, 0.16683737244631225, 0.16595030740693129, 0.16669868716513558, 0.19832011694382146, 0.17458955591714254, 0.18445127376271897, 0.18287348275429938, 0.17108943319674397, 0.15926159272485108, 0.16478791742393317, 0.16609262536289426, 0.16902935328088575, 0.16893072844676915, 0.1634121468808475, 0.17646972718136222, 0.17277837337863988, 0.16732369059338836, 0.16393571192488765, 0.7259438372254553, 0.15103169698260188, 0.19029859108132363, 0.16109802932162343, 0.16398517828516856, 0.1715357386964892, 0.1504319054310117, 0.15862587644846426, 0.15781853464917972, 0.3085959102817315, 0.17927628367381143, 0.14687072698300396, 0.2219953958376233, 0.1205463675968853, 0.20569438014118435, 0.12427082113420329, 0.3839881830114802, 0.1790137905831356, 0.1810301202706771, 0.1758793769040351, 0.16420514524194163, 0.1718416996384703, 0.17662779193683076, 0.1811685119075569, 0.17276202520236728, 0.1604773675039609, 0.0491077816830342, 0.07066150867507281, 0.07179064306647176, 0.06714005679324475, 0.06374516112746553, 0.07223602125932072, 0.05759608042613695, 0.07255913557994464, 0.06490328519425492]}, "mutation_prompt": null}
{"id": "ad3e8047-d0f7-4dee-870e-64314846beb5", "solution": "import numpy as np\n\nclass DynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05  # Adaptive learning rate for perturbations\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, 1.0)  # Increase learning rate\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, 0.01)  # Decrease learning rate\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "DynamicAdaptiveDifferentialEvolution", "description": "Dynamic Adaptive Differential Evolution with Improved Perturbation and Adaptive Learning Rate for Enhanced Exploration and Convergence.", "configspace": "", "generation": 24, "fitness": 0.32145428957860916, "feedback": "The algorithm DynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "685e1519-3623-4bd0-8b64-7fb2e9673c9a", "metadata": {"aucs": [0.7935956524861002, 0.7753102169528892, 0.7868806175555162, 0.7960537766506737, 0.8100793177822811, 0.8292946813520324, 0.7875605713640874, 0.8136473925698191, 0.8068305491828122, 0.4277857565661882, 0.4095368523234353, 0.44616092250182116, 0.40537012697107844, 0.3975641974285823, 0.36078601794157017, 0.3837923820489494, 0.40764313378284966, 0.39227394133827564, 0.3066459990480308, 0.25093036121721246, 0.11774848023923312, 0.14841705576920672, 0.09661528750812809, 0.10170451630765143, 0.07983993756108121, 0.09894906461894515, 0.12613369239871608, 0.14152737499998114, 0.11251260915766947, 0.0830265000987418, 0.1040519828927039, 0.10159297875654116, 0.10516210265687043, 0.07406610519543333, 0.1356471730331763, 0.13079680636349222, 0.8941450041456407, 0.8502342513843499, 0.8598696757424108, 0.9061381527489316, 0.9018008789065997, 0.9080731918989, 0.8989307251867469, 0.8945605860830946, 0.905802996571821, 0.4734773132472072, 0.48569754465361026, 0.4523598513413307, 0.4671530429779328, 0.4220913931986975, 0.48677624458093693, 0.43537358917757496, 0.47693144026640844, 0.44021003425278427, 0.2089494071796626, 0.7462251869169639, 0.8137237080598234, 0.7547399533020216, 0.6522048430921388, 0.7969969081708221, 0.7712011897940833, 0.7062289930624093, 0.357545764978614, 0.12427253753074752, 0.2199302667712596, 0.23063998499541272, 0.1771760864661741, 0.3942992077498313, 0.18066454637070306, 0.18152269326436088, 0.238939218794198, 0.23878430124719408, 0.2039151483488847, 0.07982484546135471, 0.19023823358943392, 0.20897805556755777, 0.2610369404020879, 0.2428241962708665, 0.1795635496303868, 0.23544067066636742, 0.23822152276138253, 0.1457830046194022, 0.28446098595547586, 0.2731407691730101, 0.06606318679167666, 0.13652845587501505, 0.2508285312519867, 0.34167002611204, 0.21689291862941518, 0.33741232884605876, 0.34383157948980647, 0.3183120652349877, 0.4075205249878714, 0.15746133706347887, 0.33732516000819557, 0.30586517472799823, 0.38571848304322254, 0.37718493360505123, 0.3852156517790417, 0.1469374349390551, 0.15504831213504, 0.19063698595501266, 0.16769959481158603, 0.12357331762857249, 0.13165271982665616, 0.21560425598935673, 0.14655330364093666, 0.21939074079612042, 0.2674658429720941, 0.252241706924046, 0.26306688049999105, 0.2725192249885412, 0.2864720215587363, 0.27695733444613146, 0.26474294778738006, 0.24083607086298686, 0.27671236003794475, 0.5833082765532641, 0.5488232677500284, 0.5629691897802638, 0.5775538605095436, 0.5723936622586241, 0.5532765593148469, 0.5575443351294085, 0.5984567894890352, 0.5452162454494627, 0.08079972131188551, 0.08381191472836103, 0.0787039189139137, 0.08708776389642803, 0.08919976674247321, 0.09767068450759542, 0.08271032655961574, 0.07975033449304414, 0.07419263397214748, 0.17824868226517643, 0.16334306705008872, 0.12831862897002888, 0.18560501468567536, 0.12794348981720083, 0.18076735746426598, 0.12670090216284957, 0.1438197529548464, 0.13755884559585374, 0.389921630054043, 0.3836750213269069, 0.400001922618316, 0.41287654372105387, 0.3929663471923921, 0.38982421245944987, 0.39646628005636897, 0.4192576344669876, 0.42400964130918206, 0.21047865369600205, 0.29750297105005996, 0.27011555737555704, 0.33493009100294224, 0.2910205930003773, 0.3292205499120523, 0.35045484849853237, 0.31161103409012636, 0.3357785700485463, 0.1715877751856154, 0.17155143164134934, 0.19187923873702661, 0.19618741859669886, 0.16165710503511432, 0.17038296883420212, 0.16253212918331628, 0.1935069564538764, 0.20376011084029122, 0.18056726672513324, 0.2239440860040004, 0.22182845336291734, 0.19929298012713093, 0.4916120570824134, 0.1851376583470048, 0.19157254669393464, 0.16996296032136138, 0.1667724461959067, 0.7690059386058763, 0.36222166998504635, 0.18022307478026978, 0.8424205065475986, 0.18586848740669581, 0.8304949533497236, 0.8057474468313648, 0.1518066179733385, 0.16567901784901207, 0.16579153534599733, 0.20131393745406445, 0.20550861924234964, 0.163287510264702, 0.20339695178093076, 0.15106375404336325, 0.20735623270386194, 0.16641175318359525, 0.19709867942914494, 0.20503059301352478, 0.1750294532301021, 0.21489760719052964, 0.18893456190309754, 0.18302157233032068, 0.18110072692272594, 0.18923871288236527, 0.17890623803018335, 0.17342241575366735, 0.07314470030699738, 0.06926431811401434, 0.07225282017060564, 0.07501268955349549, 0.08427569233842391, 0.06866287604086951, 0.06788410428758329, 0.06947059746194117, 0.08168331467465795]}, "mutation_prompt": null}
{"id": "55fb3f88-38fc-44f7-b6d7-f692669428e3", "solution": "import numpy as np\n\nclass ImprovedDynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(12, 12 * dim // 3)  # Increased initial population size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 0.6, 1.0, 1.2]  # Expanded mutation strategies\n        self.learning_rate = 0.07  # Slightly increased initial learning rate\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:  # Reduced threshold for stagnation\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, 1.0)  # Increase learning rate\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, 0.01)  # Decrease learning rate\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedDynamicAdaptiveDifferentialEvolution", "description": "Improved Dynamic Adaptive Differential Evolution with Randomized Mutation Strategies and Reduced Stagnation.", "configspace": "", "generation": 25, "fitness": 0.2784574517034538, "feedback": "The algorithm ImprovedDynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "ad3e8047-d0f7-4dee-870e-64314846beb5", "metadata": {"aucs": [0.6956178017063352, 0.7037849561654572, 0.7444918527158514, 0.6910177676873759, 0.6873800483458234, 0.6869927375677696, 0.6936088865285692, 0.7415445573631702, 0.6996017453692893, 0.34608756929098017, 0.3252271225146709, 0.3317431297740332, 0.3125303620519736, 0.33746080493839303, 0.3028650754675639, 0.34159209757013764, 0.3782500176696467, 0.35126540621434055, 0.07923949705415467, 0.09877324274868038, 0.0969029680631498, 0.09029711989718947, 0.09568926669921707, 0.06375185198835698, 0.08618567864567228, 0.09527472946602755, 0.07958317966293016, 0.08392752059448827, 0.08862542873745882, 0.07514784883624848, 0.0688926167100894, 0.09215244748723272, 0.086848676792882, 0.0630041051909418, 0.07194636453550052, 0.08044057876879196, 0.9030970795323805, 0.8534607718035212, 0.8886069447337117, 0.8364839340490915, 0.8976094003497788, 0.8754114262406764, 0.8969576275915977, 0.8790737555092416, 0.8903342082578489, 0.38351681002236326, 0.3259226244495339, 0.3618089571109573, 0.38956004054147597, 0.3044684559359462, 0.37951553524078363, 0.3288849605921661, 0.36669572548575935, 0.3691271691128455, 0.7090489981225631, 0.6362391287537508, 0.6431518089281467, 0.708738440619167, 0.7123449707285434, 0.6748413463149574, 0.6527256374859627, 0.7080619845525047, 0.6151365482363875, 0.18089756191688988, 0.22042693046749418, 0.24242169033315963, 0.15933904447761837, 0.22021917309673267, 0.31228165198215163, 0.2731210373621975, 0.29681367903765643, 0.22814496050436162, 0.08975945080608816, 0.29957127745185586, 0.29016891896735575, 0.2362773320056153, 0.29925379889133263, 0.25787050323047056, 0.21421635747481893, 0.1933802120250625, 0.2668192665092336, 0.18292335802614268, 0.2044546216352393, 0.23764801659458157, 0.011536669045868031, 0.18886242765405037, 0.25678369856356065, 0.2115532784683548, 0.16863046722905906, 0.1710470207062733, 0.2495662873321467, 0.2708549812728861, 0.2593867800152685, 0.30843742505054417, 0.17647071559961802, 0.283694300549193, 0.30243373273577323, 0.27161028047591307, 0.2828968402196037, 0.17054789645787094, 0.09269620887693086, 0.06652879348451102, 0.09630293296220205, 0.0865967000440131, 0.018780519305834242, 0.08219303059983973, 0.05676229347443318, 0.0574681400223106, 0.2162476325096131, 0.20614351770029293, 0.20518960896029248, 0.20464140129084019, 0.2054713164897669, 0.22085702993502498, 0.20856894225787093, 0.22391090640595535, 0.19565319128120584, 0.4971144247125334, 0.4916269264016999, 0.4858633556419284, 0.5150439776817248, 0.5348738516033762, 0.5167997427956039, 0.502936017450281, 0.5158877054734887, 0.4993725704361195, 0.08371015571397056, 0.0852228368184067, 0.07320206699207465, 0.07229907429405702, 0.0816540256280015, 0.06557650867914888, 0.0769863654636822, 0.08149124420577336, 0.0969851614344105, 0.14853939448132847, 0.11846078525357284, 0.1548367278860442, 0.1408935006065296, 0.16839787459059807, 0.14395815538879542, 0.19103551488301784, 0.15182653678497082, 0.13345182100020903, 0.30351334210179826, 0.3042697860569258, 0.28630187340488933, 0.31969162867871703, 0.3019289815401295, 0.30955232729462046, 0.3230056877238492, 0.36720631548093563, 0.34562239366075287, 0.209075783609596, 0.2025261810623218, 0.23762845939119925, 0.1933559402754077, 0.17925044472511653, 0.21364727426110752, 0.18748689014023334, 0.25014086736874164, 0.25112158130296625, 0.18229127097261588, 0.1958957802148953, 0.17301254234024932, 0.1674516917432557, 0.16106105272596527, 0.16612943702643024, 0.17490462271968787, 0.16789469720081163, 0.18690623895119174, 0.1739322898015131, 0.18523621115070887, 0.1780168967860185, 0.1745727901567563, 0.1744055135294208, 0.17482343662848976, 0.17464749424496162, 0.17195617751760073, 0.16387578993086394, 0.1668221095435769, 0.7257610076460111, 0.1487843771629237, 0.17001665720700898, 0.18462189244898408, 0.18275692972302127, 0.21347021189160553, 0.16993957309676244, 0.16525790562269194, 0.1469146290740284, 0.16127777273122645, 0.7264590345933792, 0.19212794516616305, 0.20022206872702086, 0.18715194691573356, 0.2076636119221833, 0.20240702416517886, 0.20185564142602608, 0.18180836987728966, 0.1703036720306622, 0.1801147348599268, 0.17694015584734113, 0.18550206744065467, 0.18540083003948826, 0.18158272058742508, 0.18447739082689119, 0.17494620264961835, 0.07732071468368662, 0.059747689996257236, 0.0690176849655092, 0.07759880720600099, 0.06888914262863033, 0.062046076334594025, 0.06541652435895617, 0.07074442531417302, 0.06815284431827073]}, "mutation_prompt": null}
{"id": "2c0f0a8c-a1ff-4c63-8ad0-c21b9bbc8ff6", "solution": "import numpy as np\n\nclass EnhancedDynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05  # Adaptive learning rate for perturbations\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < func(self.population[i]):\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)  # Stochastic adjustment\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)  # Stochastic adjustment\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDynamicAdaptiveDifferentialEvolution", "description": "Enhanced Dynamic Adaptive Differential Evolution with Stochastic Learning Rate Adjustment for Improved Convergence and Exploration.", "configspace": "", "generation": 26, "fitness": 0.3241795353949279, "feedback": "The algorithm EnhancedDynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "ad3e8047-d0f7-4dee-870e-64314846beb5", "metadata": {"aucs": [0.7935956524861002, 0.7753102169528892, 0.7868806175555162, 0.7960537766506737, 0.8100793177822811, 0.8292946813520324, 0.7875605713640874, 0.8136473925698191, 0.8068305491828122, 0.4277857565661882, 0.4095368523234353, 0.44616092250182116, 0.40537012697107844, 0.3975641974285823, 0.36078601794157017, 0.3837923820489494, 0.40764313378284966, 0.39227394133827564, 0.3066459990480308, 0.25093036121721246, 0.11774848023923312, 0.14841705576920672, 0.09855671615077533, 0.11194172166165284, 0.09419042286694856, 0.09962947211380613, 0.12613369239871608, 0.14152737499998114, 0.11251260915766947, 0.09151618864388, 0.1040519828927039, 0.10159297875654116, 0.10516210265687043, 0.08249963997009258, 0.1356471730331763, 0.13079680636349222, 0.8941450041456407, 0.8502342513843499, 0.8598696757424108, 0.9061381527489316, 0.9018008789065997, 0.9080731918989, 0.8989307251867469, 0.8945605860830946, 0.905802996571821, 0.4734773132472072, 0.48569754465361026, 0.4523598513413307, 0.4671530429779328, 0.4220913931986975, 0.48677624458093693, 0.43537358917757496, 0.47693144026640844, 0.44021003425278427, 0.2155383637818442, 0.7462251869169639, 0.8137237080598234, 0.7547399533020216, 0.6522048430921388, 0.7969969081708221, 0.7712011897940833, 0.7062289930624093, 0.357545764978614, 0.12427253753074752, 0.2199302667712596, 0.23063998499541272, 0.1771760864661741, 0.3942992077498313, 0.18066454637070306, 0.18152269326436088, 0.238939218794198, 0.23878430124719408, 0.2039151483488847, 0.07982484546135471, 0.19023823358943392, 0.20897805556755777, 0.2610369404020879, 0.2428241962708665, 0.1795635496303868, 0.23544067066636742, 0.23822152276138253, 0.1457830046194022, 0.28446098595547586, 0.2731407691730101, 0.06606318679167666, 0.13652845587501505, 0.2508285312519867, 0.34167002611204, 0.21689291862941518, 0.33741232884605876, 0.34383157948980647, 0.3183120652349877, 0.4075205249878714, 0.15746133706347887, 0.33732516000819557, 0.30586517472799823, 0.38571848304322254, 0.37718493360505123, 0.3852156517790417, 0.1469374349390551, 0.15504831213504, 0.19063698595501266, 0.16769959481158603, 0.12357331762857249, 0.13165271982665616, 0.21560425598935673, 0.14655330364093666, 0.21939074079612042, 0.2674658429720941, 0.252241706924046, 0.26306688049999105, 0.2725192249885412, 0.2864720215587363, 0.27695733444613146, 0.26474294778738006, 0.24083607086298686, 0.27671236003794475, 0.5833082765532641, 0.5488232677500284, 0.5629691897802638, 0.5775538605095436, 0.5723936622586241, 0.5532765593148469, 0.5575443351294085, 0.5984567894890352, 0.5452162454494627, 0.0844320525857023, 0.09443005637045754, 0.08105664845097649, 0.09642023775996844, 0.08921937935205226, 0.08605124951342036, 0.09011251800403719, 0.08048979577082105, 0.08126410083318447, 0.17824868226517643, 0.16572400867354975, 0.17655819888499846, 0.18728151686299632, 0.1584430445767252, 0.207926270058571, 0.1667909809136685, 0.44303947501750185, 0.14536157181327614, 0.389921630054043, 0.3836750213269069, 0.400001922618316, 0.41287654372105387, 0.3929663471923921, 0.38982421245944987, 0.39646628005636897, 0.4192576344669876, 0.42400964130918206, 0.21047865369600205, 0.29750297105005996, 0.27011555737555704, 0.33493009100294224, 0.2910205930003773, 0.3292205499120523, 0.35045484849853237, 0.31161103409012636, 0.3357785700485463, 0.18668436265138633, 0.17968311111629387, 0.19187923873702661, 0.19618741859669886, 0.18336965638451197, 0.16977492954528628, 0.16798599469205078, 0.18511423236926183, 0.20376011084029122, 0.18056726672513324, 0.2239440860040004, 0.22182845336291734, 0.19929298012713093, 0.4916120570824134, 0.18700264498821517, 0.19427098933758602, 0.17469306546752816, 0.17501111743330855, 0.7690059386058763, 0.36222166998504635, 0.18022307478026978, 0.8424205065475986, 0.18586848740669581, 0.8304949533497236, 0.8057474468313648, 0.1518066179733385, 0.16567901784901207, 0.16579153534599733, 0.20131393745406445, 0.20550861924234964, 0.163287510264702, 0.20339695178093076, 0.15106375404336325, 0.20735623270386194, 0.16641175318359525, 0.19709867942914494, 0.20503059301352478, 0.18451341334622462, 0.21489760719052964, 0.17211083333653077, 0.18281732173773613, 0.18110072692272594, 0.18923871288236527, 0.18084398303372573, 0.17402534465415942, 0.07472192591440852, 0.06926431811401434, 0.07422839250921953, 0.0626369839064409, 0.08427569233842391, 0.06983004343079957, 0.0719543318149366, 0.06760914866769785, 0.08452190328775344]}, "mutation_prompt": null}
{"id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution incorporating dynamic mutation and crossover rates with population diversity maintenance for enhanced convergence.", "configspace": "", "generation": 27, "fitness": 0.34032606929623044, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "2c0f0a8c-a1ff-4c63-8ad0-c21b9bbc8ff6", "metadata": {"aucs": [0.7942027628536306, 0.8003890841900754, 0.794766104780833, 0.7964771471737537, 0.7737519426070871, 0.8185543347056987, 0.774038965735971, 0.78287101307618, 0.7517979098901955, 0.403080295546858, 0.38977480228176475, 0.40532081959813226, 0.4191500099794563, 0.3334354940259827, 0.43821926427063185, 0.3801180191820802, 0.4094325167520958, 0.3472554825861447, 0.1131134368026202, 0.12726708784383134, 0.11648544278487039, 0.09933098298307397, 0.14799398895887939, 0.1468729469223612, 0.12099207156636405, 0.1305890942194874, 0.3696228498214579, 0.10685002589243009, 0.09713004539165071, 0.10056156656301796, 0.11227307287509669, 0.09228376760220713, 0.1064967270856203, 0.09083898750234753, 0.09642165997758345, 0.11535276430442032, 0.8928185313424353, 0.890130984826779, 0.9389909688320673, 0.9052410654122369, 0.8771172395239936, 0.919246535828723, 0.9116541580730064, 0.8623360592621786, 0.9250746899046827, 0.5000195014731567, 0.40718412504937473, 0.4020115652183164, 0.4085326075695366, 0.4819581801246008, 0.42278223033674445, 0.48427706637459167, 0.44070084534264453, 0.24099756886717727, 0.7809079124682039, 0.7786493962797002, 0.7659526401926805, 0.8011546448552254, 0.7669583919978132, 0.7930928936216576, 0.7976031799655016, 0.6630995731309124, 0.38000442584112215, 0.23171895736436943, 0.1985536648928834, 0.23581198878968157, 0.2033984412225044, 0.2692515214116259, 0.21442644079665374, 0.1785347506080609, 0.23128312165764842, 0.182842062593344, 0.1760559409632828, 0.4131367521723155, 0.08350819808814636, 0.12318240120262713, 0.2914020741330404, 0.21742663225127, 0.197486158628411, 0.16032111536512317, 0.3698264511889271, 0.23098182558125813, 0.190710692342267, 0.24115951444036376, 0.32159860633688575, 0.2655600950151453, 0.1315559036924837, 0.29059368598355073, 0.28524591534488697, 0.22269575830544153, 0.1838863148196741, 0.38200973289102014, 0.2964454217766481, 0.4144998689624315, 0.34494426154734714, 0.34413203027620254, 0.3738638607993383, 0.29536301685344124, 0.38260710971935064, 0.06819552960204678, 0.145480287716792, 0.08038975261861758, 0.16139415838724414, 0.17436681904259077, 0.14070007503839732, 0.17859662342813243, 0.10482265002191649, 0.17533705539836864, 0.24298860387963184, 0.22119692704225635, 0.26003497030336353, 0.27145906911707196, 0.25547583310225175, 0.24842269589812538, 0.2767785844253402, 0.2643538456018507, 0.24730112150394923, 0.5793684946399158, 0.5410604092323203, 0.557389763648086, 0.5341644084112532, 0.5828804887920412, 0.5828951902910291, 0.5719518209671327, 0.5830274933261974, 0.570379516774062, 0.11204800393155634, 0.09311914818796208, 0.08465603721573445, 0.09769732599930225, 0.15066099844186343, 0.08698208313238898, 0.09073788619890655, 0.1102502402937886, 0.11425319208859597, 0.17266319175328348, 0.41715123444518765, 0.34447911601719206, 0.21211033758500053, 0.39919342301701044, 0.14927429307501838, 0.24464350092353382, 0.23008545193217456, 0.2251607339649413, 0.3591948594475458, 0.4010178765546756, 0.44596870603003813, 0.39076596793536966, 0.3616438558794648, 0.3627736411344431, 0.39862553449942684, 0.4265516805179095, 0.4145380510580484, 0.3068488947407345, 0.323579158275333, 0.31833266400644056, 0.29448694128048336, 0.28435589732113076, 0.3162521649580472, 0.3369710269590389, 0.31067331907632156, 0.2528172085757412, 0.182845839771268, 0.2233857224005128, 0.18516907487347767, 0.18792797504159775, 0.18242920969893428, 0.18527107193919556, 0.18245051104970955, 0.19974239675771532, 0.179749489002894, 0.18055828022174136, 0.18922858101914064, 0.21930953571416745, 0.22366191601868846, 0.22606942856499268, 0.21306379414044008, 0.1755318628187007, 0.22513738130988292, 0.16559279130845228, 0.8573812261782274, 0.18332985250746603, 0.15091407153817493, 0.8293462851162157, 0.18838118125459302, 0.15957266136029846, 0.7746422125349463, 0.6972016941411441, 0.7361866201728344, 0.8172625803512157, 0.20362480619733103, 0.7950284576391707, 0.16440345429318803, 0.6120687745260749, 0.6572994276575476, 0.20348502495231668, 0.206307605129189, 0.6844646533156196, 0.17589677658384062, 0.16900078777611582, 0.19602674148997223, 0.17603984193770772, 0.17458800702637123, 0.18954725681341633, 0.17105237329572143, 0.18234230607977808, 0.17911766801438733, 0.07605395564517525, 0.0747851322762011, 0.07678992347978131, 0.08220798390885231, 0.06980342994761668, 0.07524126680706267, 0.06504378922048948, 0.07195764215478817, 0.07830504228119939]}, "mutation_prompt": null}
{"id": "91cba000-8b72-438a-bddd-c1e93b6411a7", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution incorporating dynamic mutation and crossover rates with population diversity maintenance for enhanced convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.7942027628536306, 0.8003890841900754, 0.794766104780833, 0.7964771471737537, 0.7737519426070871, 0.8185543347056987, 0.774038965735971, 0.78287101307618, 0.7517979098901955, 0.403080295546858, 0.38977480228176475, 0.40532081959813226, 0.4191500099794563, 0.3334354940259827, 0.43821926427063185, 0.3801180191820802, 0.4094325167520958, 0.3472554825861447, 0.1131134368026202, 0.12726708784383134, 0.11648544278487039, 0.09933098298307397, 0.14799398895887939, 0.1468729469223612, 0.12099207156636405, 0.1305890942194874, 0.3696228498214579, 0.10685002589243009, 0.09713004539165071, 0.10056156656301796, 0.11227307287509669, 0.09228376760220713, 0.1064967270856203, 0.09083898750234753, 0.09642165997758345, 0.11535276430442032, 0.8928185313424353, 0.890130984826779, 0.9389909688320673, 0.9052410654122369, 0.8771172395239936, 0.919246535828723, 0.9116541580730064, 0.8623360592621786, 0.9250746899046827, 0.5000195014731567, 0.40718412504937473, 0.4020115652183164, 0.4085326075695366, 0.4819581801246008, 0.42278223033674445, 0.48427706637459167, 0.44070084534264453, 0.24099756886717727, 0.7809079124682039, 0.7786493962797002, 0.7659526401926805, 0.8011546448552254, 0.7669583919978132, 0.7930928936216576, 0.7976031799655016, 0.6630995731309124, 0.38000442584112215, 0.23171895736436943, 0.1985536648928834, 0.23581198878968157, 0.2033984412225044, 0.2692515214116259, 0.21442644079665374, 0.1785347506080609, 0.23128312165764842, 0.182842062593344, 0.1760559409632828, 0.4131367521723155, 0.08350819808814636, 0.12318240120262713, 0.2914020741330404, 0.21742663225127, 0.197486158628411, 0.16032111536512317, 0.3698264511889271, 0.23098182558125813, 0.190710692342267, 0.24115951444036376, 0.32159860633688575, 0.2655600950151453, 0.1315559036924837, 0.29059368598355073, 0.28524591534488697, 0.22269575830544153, 0.1838863148196741, 0.38200973289102014, 0.2964454217766481, 0.4144998689624315, 0.34494426154734714, 0.34413203027620254, 0.3738638607993383, 0.29536301685344124, 0.38260710971935064, 0.06819552960204678, 0.145480287716792, 0.08038975261861758, 0.16139415838724414, 0.17436681904259077, 0.14070007503839732, 0.17859662342813243, 0.10482265002191649, 0.17533705539836864, 0.24298860387963184, 0.22119692704225635, 0.26003497030336353, 0.27145906911707196, 0.25547583310225175, 0.24842269589812538, 0.2767785844253402, 0.2643538456018507, 0.24730112150394923, 0.5793684946399158, 0.5410604092323203, 0.557389763648086, 0.5341644084112532, 0.5828804887920412, 0.5828951902910291, 0.5719518209671327, 0.5830274933261974, 0.570379516774062, 0.11204800393155634, 0.09311914818796208, 0.08465603721573445, 0.09769732599930225, 0.15066099844186343, 0.08698208313238898, 0.09073788619890655, 0.1102502402937886, 0.11425319208859597, 0.17266319175328348, 0.41715123444518765, 0.34447911601719206, 0.21211033758500053, 0.39919342301701044, 0.14927429307501838, 0.24464350092353382, 0.23008545193217456, 0.2251607339649413, 0.3591948594475458, 0.4010178765546756, 0.44596870603003813, 0.39076596793536966, 0.3616438558794648, 0.3627736411344431, 0.39862553449942684, 0.4265516805179095, 0.4145380510580484, 0.3068488947407345, 0.323579158275333, 0.31833266400644056, 0.29448694128048336, 0.28435589732113076, 0.3162521649580472, 0.3369710269590389, 0.31067331907632156, 0.2528172085757412, 0.182845839771268, 0.2233857224005128, 0.18516907487347767, 0.18792797504159775, 0.18242920969893428, 0.18527107193919556, 0.18245051104970955, 0.19974239675771532, 0.179749489002894, 0.18055828022174136, 0.18922858101914064, 0.21930953571416745, 0.22366191601868846, 0.22606942856499268, 0.21306379414044008, 0.1755318628187007, 0.22513738130988292, 0.16559279130845228, 0.8573812261782274, 0.18332985250746603, 0.15091407153817493, 0.8293462851162157, 0.18838118125459302, 0.15957266136029846, 0.7746422125349463, 0.6972016941411441, 0.7361866201728344, 0.8172625803512157, 0.20362480619733103, 0.7950284576391707, 0.16440345429318803, 0.6120687745260749, 0.6572994276575476, 0.20348502495231668, 0.206307605129189, 0.6844646533156196, 0.17589677658384062, 0.16900078777611582, 0.19602674148997223, 0.17603984193770772, 0.17458800702637123, 0.18954725681341633, 0.17105237329572143, 0.18234230607977808, 0.17911766801438733, 0.07605395564517525, 0.0747851322762011, 0.07678992347978131, 0.08220798390885231, 0.06980342994761668, 0.07524126680706267, 0.06504378922048948, 0.07195764215478817, 0.07830504228119939]}, "mutation_prompt": null}
{"id": "c12d5ddd-ed9c-4481-baed-8f3545439b1e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 15 * dim // 4)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.5, 1.5]\n        self.learning_rate = 0.1\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n\n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.85, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.95, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with diversity-driven mutation strategies and learning rate modulation for robust convergence across diverse landscapes.", "configspace": "", "generation": 29, "fitness": 0.2383332071367122, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.21.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.6800918026178949, 0.6618963024404063, 0.6744622418032613, 0.7029805793603386, 0.7144873185423681, 0.6645844788737671, 0.6716261285635596, 0.6840579690852664, 0.6880302627979022, 0.3283208230449983, 0.35895679946047243, 0.3243592393663953, 0.3036499394468073, 0.3167467317251743, 0.32349448965278893, 0.26891527885393174, 0.24339019908085968, 0.2760852231311334, 0.09101028497473473, 0.10012170971585455, 0.08241975983826921, 0.09670361498274649, 0.08805580254307821, 0.0876225025078542, 0.08873617375668585, 0.08477342660495013, 0.09267010949834698, 0.07365399080858392, 0.08543785211498411, 0.07444524877214476, 0.08432765365365102, 0.0821187802061768, 0.07236622112242552, 0.07007062981664458, 0.07907860592500182, 0.07563459776269532, 0.9165177711176965, 0.9283936144472142, 0.8777883019193584, 0.8979216338595575, 0.8900588442479715, 0.9283892089218315, 0.8750635726010183, 0.8677802396262183, 0.8982158555842407, 0.3367502374434317, 0.3487042612099466, 0.2805293585866607, 0.2981756137270489, 0.37902825483232516, 0.38356858713230046, 0.3887127723162378, 0.3591121010203012, 0.2832134660910278, 0.28080961980663954, 0.24787921873703844, 0.280781618031297, 0.311005546875297, 0.2553929371554936, 0.7227792232515382, 0.2668173328375275, 0.6760942200815325, 0.3079764791719002, 0.12847486365213956, 0.16634404071191877, 0.19185873753691352, 0.08083809020139687, 0.18524707182910205, 0.2017464060979628, 0.13896903311658348, 0.16967462813362777, 0.22257437014356463, 0.1534405867670755, 0.11664965297032215, 0.10426741179118637, 0.14779256839227306, 0.1674869119085406, 0.15975880249522711, 0.17553974630161406, 0.2444310195639503, 0.16349429731287746, 0.03563897014830797, 9.999999999998899e-05, 0.002001368343284793, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009230901724872287, 9.999999999998899e-05, 0.07957546493268541, 0.060573195495422394, 0.06164231771731743, 0.17323597346646435, 0.08832360523210414, 0.10992238018412659, 0.13864623797756503, 0.062381700568849396, 0.08127658399639426, 0.0772268048500857, 0.03531858777047636, 9.999999999998899e-05, 0.0371928483489804, 0.009462905619930462, 0.0066455017025484064, 0.01606282981603635, 0.007694834246723237, 0.01637718567777957, 9.999999999998899e-05, 0.14726706178647053, 0.1211075160765358, 0.15878613928095653, 0.12223076944387012, 0.12408383617826968, 0.15715089151594042, 0.10816472656266574, 0.13024173861815658, 0.12943553738074076, 0.4676357258407783, 0.4673439106511734, 0.43709687425974775, 0.5066994249983694, 0.4892162626899921, 0.42068041655296506, 0.49862790196819295, 0.47555526548214144, 0.4609698529141535, 0.09112904465743465, 0.07463417698032027, 0.09532275781879285, 0.08835064387688452, 0.07914274645913988, 0.09797442323081873, 0.08822084585649081, 0.08647217933522533, 0.08971217904872031, 0.16033035403938578, 0.160676570334657, 0.13772408255069235, 0.1269832112379341, 0.13179661849983149, 0.19680673015534977, 0.18940856599554978, 0.16525025973414864, 0.1464876444672093, 0.27230427743638064, 0.23306756660505623, 0.23849067150855807, 0.24037743205117434, 0.21520036210569282, 0.252487830137614, 0.30018778549089387, 0.24672663299020914, 0.24708696772614858, 0.17737797673584532, 0.1893019740531391, 0.22072811908068557, 0.20170165821540442, 0.16664454668546336, 0.18234203563155504, 0.18238499411915932, 0.28668828320485207, 0.1679250053952983, 0.20838003259246318, 0.19266598673675328, 0.18170566538812272, 0.1779613223838391, 0.1888735031408605, 0.1853236976842748, 0.17728879188121904, 0.17491971688147445, 0.18854854947231103, 0.17076213923893424, 0.17291572329357807, 0.1696134522146756, 0.17999021584383357, 0.169976315047062, 0.18794083474690093, 0.17546610353396863, 0.1633072561788531, 0.17352747028100457, 0.16125438909166445, 0.15981615144253725, 0.14973722472954398, 0.4845851188439432, 0.4665518535934625, 0.1729862838571442, 0.769633197673284, 0.22819674204542595, 0.38925168670169197, 0.12071037272442553, 0.1640086547156554, 0.19386898202250558, 0.1918579907852911, 0.15290008693552193, 0.30653997685172285, 0.20648229771395432, 0.7397020815686537, 0.3294381873531883, 0.18054296529328206, 0.18447691230537588, 0.183898529312301, 0.2050155256856102, 0.17230589186780965, 0.17282345446985892, 0.1776007440045716, 0.18006373042876966, 0.18149836460250157, 0.07034562177983295, 0.06599831207760232, 0.07236270446745419, 0.07504527538207217, 0.07168637016630286, 0.07394662581416911, 0.07737359086977524, 0.07882603454471226, 0.06917192778421632]}, "mutation_prompt": null}
{"id": "f089f474-074a-4cb3-80bb-0ba1b44b5b0c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 12 * dim // 3)  # Adjusted population size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.2]  # Adjusted mutation strategy\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.15  # Adjusted max learning rate\n        self.dynamic_mutation_factor = 0.1  # Adjusted dynamic mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        feedback_loop_factor = 0.1  # Introduced feedback loop factor\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor * (1 + np.random.normal(0, self.dynamic_mutation_factor))\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:  # Adjusted stagnation check\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n            \n            self.mutation_factor *= (1 + feedback_loop_factor)\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using non-linear dynamic crossover and mutation adjustment with feedback loop for accelerated convergence.", "configspace": "", "generation": 30, "fitness": 0.2914079234244789, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.6804642210408185, 0.6723631389790382, 0.7113384409779617, 0.7206734810154006, 0.6875205705690767, 0.7450755285001958, 0.7160775709700128, 0.6400071295901808, 0.7174324784342148, 0.3283784688940835, 0.31921091558121717, 0.34938486284113457, 0.3459201677686494, 0.32190275572837146, 0.31539140143226774, 0.32038284117096116, 0.3503978771756431, 0.33573317633353694, 0.09174161430531969, 0.08867270024564333, 0.07839686155165726, 0.09769773085777289, 0.08512983159718568, 0.10016536459222047, 0.10340239720929767, 0.10004699139358253, 0.08310661078444903, 0.07175132678451923, 0.08474087749940862, 0.072869873763308, 0.08218167859636127, 0.09102849696084792, 0.08037177132736029, 0.0831725431013971, 0.07160787193123341, 0.0905532772547003, 0.9275936374913459, 0.8329540860471831, 0.8714042532872117, 0.8850588614702961, 0.9299980322723574, 0.8624350503228637, 0.8979440204660438, 0.8904385039823117, 0.8490187599496449, 0.35328562014143905, 0.37748812765059103, 0.33771181421781316, 0.3629445310967696, 0.3875893654271547, 0.3124939559426151, 0.3441294552414843, 0.3769433084413384, 0.34572742244088805, 0.6654375226750289, 0.7223526115400928, 0.5949283857744865, 0.6712321566060129, 0.5876480095607715, 0.6833744935200863, 0.6739287655914108, 0.712322318515342, 0.6570738204769194, 0.20817993001189128, 0.2786131705800786, 0.2884982944115264, 0.12149902142787816, 0.16302541183224473, 0.12285410391365492, 0.22318196109935484, 0.16623962123774694, 0.3369548298902819, 0.11953755338313421, 0.11912734410457526, 0.08963406145662589, 0.1434411399138278, 0.2358494586643517, 0.23623210750409296, 0.1669339550833, 0.20001791305431282, 0.2050704551955591, 0.24294979635348501, 0.20860381170763453, 0.20817959817257703, 0.01610249053544721, 0.20441858684789715, 0.1703472720583381, 0.17364211323044199, 0.22552377507033694, 0.21528848612270424, 0.3093194336897974, 0.28483132599456007, 0.18657559545330882, 0.21532598119178137, 0.2774915418454922, 0.3300046939360868, 0.3169017719734324, 0.33183819631600986, 0.30268635998674276, 0.08508719542026533, 0.08685443674021154, 0.0442009767013023, 0.12335402804801376, 0.026850618915362112, 0.1265365212747156, 0.11606607766060184, 0.08186637288703025, 0.13412132304650515, 0.21050780528247803, 0.2169552476449943, 0.1997426370826374, 0.18736348830811322, 0.22884367307639064, 0.19225208123598214, 0.21820001327733896, 0.20595171602340867, 0.19391368639702056, 0.5233127708450891, 0.5161666321034226, 0.5169724984498687, 0.5608527735791891, 0.502455190019782, 0.5332465781113394, 0.5163102423818655, 0.5213083672119864, 0.5447975592377848, 0.07527172588592002, 0.07659034877955251, 0.08784692090852264, 0.09888906003226205, 0.08594754990731801, 0.08456081540064975, 0.08247330642811246, 0.07443277854022745, 0.09421388635845052, 0.36490067690924466, 0.1518537878937033, 0.15138005063891102, 0.1387616288747422, 0.15043265007587325, 0.13405446959718414, 0.167604280217152, 0.17188787536135974, 0.23937163523089322, 0.3268993508486919, 0.32081995165031596, 0.32342132782739286, 0.27186371950477506, 0.33089179729313756, 0.3077522158974413, 0.35260155172907504, 0.35888646576851657, 0.32729694541395415, 0.2089226319678974, 0.2396915884055868, 0.21703299007550791, 0.26574609813548666, 0.2387686998700287, 0.21691349469899035, 0.24923254257650185, 0.29367737123323656, 0.2451697196335293, 0.20393772735545967, 0.17429944138278786, 0.16145637469879548, 0.17799947681755346, 0.17536686937959844, 0.1885637648581161, 0.1824439297358318, 0.17692896441810113, 0.18988757738342088, 0.16813616194435055, 0.174761318721408, 0.18344405823882948, 0.183393846077896, 0.1669451136738398, 0.16874918581550735, 0.17023018045311689, 0.17357753441272217, 0.1705864433723132, 0.7256279328741857, 0.15845911320029804, 0.14871951462540423, 0.18242069324154497, 0.19879010620371174, 0.7859082490056075, 0.6943370331231848, 0.6760158558111404, 0.5927261619466871, 0.7002611428436728, 0.16703537722228812, 0.49980111171820985, 0.15899726632256894, 0.19117575427042444, 0.1804523834711148, 0.21005927346042452, 0.5087500472524438, 0.15030486701308, 0.19398099465207452, 0.1715823448425473, 0.17537726358434702, 0.1866204379976958, 0.1920603062383036, 0.1836039803413212, 0.1790336832764471, 0.19207800968169197, 0.17293451363242418, 0.0739980259011711, 0.06822627744625775, 0.06962509959128238, 0.07004158016803519, 0.07847105139034449, 0.07747697135234233, 0.07129979656840002, 0.06848535614752183, 0.06584259383771807]}, "mutation_prompt": null}
{"id": "ba8bd327-265d-4d21-b458-aeae1e51aaaa", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.initial_population_size = max(10, 10 * dim // 3)\n        self.population_size = self.initial_population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n        self.convergence_speed = []\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.convergence_speed.append(self.best_fitness)\n            if len(self.convergence_speed) > 50:\n                self.convergence_speed.pop(0)\n            \n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n                if len(self.convergence_speed) > 1 and self.convergence_speed[-1] == self.convergence_speed[-50]:\n                    self.population_size = max(self.population_size // 2, 10)\n                    self.population = self.population[:self.population_size]\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n                if evaluations < self.budget // 2 and self.population_size < self.initial_population_size:\n                    self.population_size = min(self.population_size * 2, self.initial_population_size)\n                    additional_population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size - len(self.population), self.dim))\n                    self.population = np.vstack((self.population, additional_population))\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic population resizing and mutation factor scaling based on convergence speed for improved robustness and efficiency.", "configspace": "", "generation": 31, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('list index out of range').", "error": "IndexError('list index out of range')", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {}, "mutation_prompt": null}
{"id": "eb7a2fa0-30a0-47ed-a41b-d8f8edd0b8f9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(12, 12 * dim // 3)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.6, 1.2]\n        self.learning_rate = 0.02\n        self.min_learning_rate = 0.005\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        chaotic_sequence = self._generate_chaotic_sequence(self.population_size)\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + chaotic_sequence[i] * self.dynamic_mutation_factor\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = chaotic_sequence[i] * np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.85, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness\n\n    def _generate_chaotic_sequence(self, length, seed=0.5):\n        # Logistic map for generating chaotic sequences\n        sequence = np.empty(length)\n        sequence[0] = seed\n        for i in range(1, length):\n            sequence[i] = 4.0 * sequence[i-1] * (1.0 - sequence[i-1])\n        return sequence", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution using chaotic maps for improved exploration and exploitation balance.", "configspace": "", "generation": 32, "fitness": 0.2765791796070977, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.6821053201131613, 0.6583347706594447, 0.7043587911225677, 0.6828815453548065, 0.6908870497248842, 0.6533300337033479, 0.6462011085554864, 0.6757271285645656, 0.6903280144186525, 0.44557724814467214, 0.42539657732664293, 0.4951314160570036, 0.4503641617826245, 0.4702564298780737, 0.4995226495381807, 0.44130874799964825, 0.4418166728234564, 0.4524670984425343, 0.09943698729924944, 0.14624254275971305, 0.09584754643378424, 0.11767332051894608, 0.11295703846865668, 0.09840969898813856, 0.09982676802723234, 0.12320266473141361, 0.08922828051231901, 0.08419553500411492, 0.09276010846506666, 0.11447361614724083, 0.10275301984903695, 0.08419934772981508, 0.08763712150881309, 0.09769510490343747, 0.0939531364566294, 0.09576811430987131, 0.9856745946906553, 0.9727271843246519, 0.9203566040307621, 0.9380043440897915, 0.9413689624195996, 0.9716070836223273, 0.9471206991300084, 0.9456560680347929, 0.9326418075332572, 0.3827363909817968, 0.28725544500196487, 0.29644816489937753, 0.32585124149468625, 0.2673395245648922, 0.30800954057062757, 0.09634104857545411, 0.3538877882721372, 0.2774931293469052, 0.4022370850047652, 0.4192427674649273, 0.5156061680558649, 0.640294996100658, 0.5045123923937317, 0.6607250132146005, 0.5054846536075346, 0.5837036305113892, 0.4820071258495314, 0.24667853442705412, 0.1806229725891817, 0.1852422076525212, 0.23686912348642064, 0.21228562812873675, 0.2514289516422954, 0.1685977505580577, 0.18351055726166998, 0.1995533811997654, 0.1668232659614456, 0.17800561682656757, 0.20890466897453086, 0.20653959577337633, 0.1753726693339076, 0.19795558539939562, 0.17919015331925525, 0.20826697545342376, 0.22785413218849826, 0.17372718747772253, 0.118660721694548, 0.04291049889702536, 0.12272404719941843, 0.12677411283824824, 0.11685897178502547, 0.13934398978881835, 0.11407805158652662, 0.1859884234899235, 0.24467582357024853, 0.23271577946268618, 0.2749546164845871, 0.26151885033450184, 0.21514141492154282, 0.23728808981156158, 0.2884020054491503, 0.30767379914480775, 0.3218301165344828, 0.023350435961399074, 0.05609363153114533, 0.0653372002317052, 0.09961972382044426, 0.14494490318593567, 0.0808733758090644, 0.046483541505758286, 0.04817977508312654, 0.05546042037507182, 0.047356052952051475, 0.1914140024735308, 0.16039379176948565, 0.17409449616420147, 0.1652286146896993, 0.1647437728758112, 0.18395880461417835, 0.16029206984048505, 0.16470884073216352, 0.5031150447921497, 0.4988024524489728, 0.509628501450718, 0.5005126968820711, 0.4580304371870927, 0.5063645948466571, 0.4935797967137726, 0.4922297763256003, 0.5060315544046352, 0.08663172539842812, 0.08919705822042756, 0.07034940093256059, 0.08520194810236392, 0.09533383163652565, 0.08034172183890531, 0.08290280771584224, 0.09372490157235913, 0.0741096479590484, 0.14612046756214425, 0.17487059613927447, 0.25096900328255733, 0.27070000466431665, 0.15683754716771414, 0.1265847926549819, 0.16001990529372856, 0.16847028738750525, 0.1615223458087599, 0.2871098165516536, 0.2618337047772419, 0.3240545315475144, 0.28415492919248353, 0.2883263096444145, 0.27583085902733473, 0.29337405281224005, 0.35841084003468116, 0.30815917788178926, 0.20878436954759616, 0.2208001849057114, 0.2103115493159351, 0.1865200746017216, 0.24479794782159714, 0.16927796068102652, 0.21241346976212439, 0.24443484358256218, 0.21670542876948762, 0.1784026595206185, 0.17233148694282296, 0.1621087286015771, 0.15620581333754802, 0.17093926684477723, 0.20022791984688804, 0.18380404365373815, 0.1786201772796956, 0.17404516315743646, 0.17125535272934433, 0.1700089780208387, 0.18810342481665043, 0.2180733763267233, 0.20161478209791572, 0.17834225585121533, 0.20792389373642395, 0.1655671479307388, 0.18382390012967254, 0.527905277717598, 0.1589901335174687, 0.1678586911436898, 0.7178401732926034, 0.1720204775826687, 0.49318922253576003, 0.18791750515818018, 0.5465079449255061, 0.14854108670744737, 0.16291888606645166, 0.18967995467696885, 0.15789008845060326, 0.18344815053951558, 0.18355524923747635, 0.18796995827026375, 0.5746934473681944, 0.6398185874188469, 0.18628251415263775, 0.17634870625917431, 0.17423394167432893, 0.175324181818165, 0.19427966454820778, 0.1709885173448602, 0.22803115661984363, 0.20968832559093387, 0.17601404241902696, 0.21849784481399592, 0.06711226802883508, 0.07624124388540554, 0.06363167377339174, 0.06895140091682972, 0.07016139881271755, 0.09569474927123633, 0.06324606492393492, 0.07950071312158835, 0.06915838850579292]}, "mutation_prompt": null}
{"id": "dba2c876-1fab-47c9-bbca-c6bceec83918", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "Improved Adaptive Differential Evolution incorporating dynamic mutation and crossover rates with population diversity maintenance for enhanced convergence.", "configspace": "", "generation": 28, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.7942027628536306, 0.8003890841900754, 0.794766104780833, 0.7964771471737537, 0.7737519426070871, 0.8185543347056987, 0.774038965735971, 0.78287101307618, 0.7517979098901955, 0.403080295546858, 0.38977480228176475, 0.40532081959813226, 0.4191500099794563, 0.3334354940259827, 0.43821926427063185, 0.3801180191820802, 0.4094325167520958, 0.3472554825861447, 0.1131134368026202, 0.12726708784383134, 0.11648544278487039, 0.09933098298307397, 0.14799398895887939, 0.1468729469223612, 0.12099207156636405, 0.1305890942194874, 0.3696228498214579, 0.10685002589243009, 0.09713004539165071, 0.10056156656301796, 0.11227307287509669, 0.09228376760220713, 0.1064967270856203, 0.09083898750234753, 0.09642165997758345, 0.11535276430442032, 0.8928185313424353, 0.890130984826779, 0.9389909688320673, 0.9052410654122369, 0.8771172395239936, 0.919246535828723, 0.9116541580730064, 0.8623360592621786, 0.9250746899046827, 0.5000195014731567, 0.40718412504937473, 0.4020115652183164, 0.4085326075695366, 0.4819581801246008, 0.42278223033674445, 0.48427706637459167, 0.44070084534264453, 0.24099756886717727, 0.7809079124682039, 0.7786493962797002, 0.7659526401926805, 0.8011546448552254, 0.7669583919978132, 0.7930928936216576, 0.7976031799655016, 0.6630995731309124, 0.38000442584112215, 0.23171895736436943, 0.1985536648928834, 0.23581198878968157, 0.2033984412225044, 0.2692515214116259, 0.21442644079665374, 0.1785347506080609, 0.23128312165764842, 0.182842062593344, 0.1760559409632828, 0.4131367521723155, 0.08350819808814636, 0.12318240120262713, 0.2914020741330404, 0.21742663225127, 0.197486158628411, 0.16032111536512317, 0.3698264511889271, 0.23098182558125813, 0.190710692342267, 0.24115951444036376, 0.32159860633688575, 0.2655600950151453, 0.1315559036924837, 0.29059368598355073, 0.28524591534488697, 0.22269575830544153, 0.1838863148196741, 0.38200973289102014, 0.2964454217766481, 0.4144998689624315, 0.34494426154734714, 0.34413203027620254, 0.3738638607993383, 0.29536301685344124, 0.38260710971935064, 0.06819552960204678, 0.145480287716792, 0.08038975261861758, 0.16139415838724414, 0.17436681904259077, 0.14070007503839732, 0.17859662342813243, 0.10482265002191649, 0.17533705539836864, 0.24298860387963184, 0.22119692704225635, 0.26003497030336353, 0.27145906911707196, 0.25547583310225175, 0.24842269589812538, 0.2767785844253402, 0.2643538456018507, 0.24730112150394923, 0.5793684946399158, 0.5410604092323203, 0.557389763648086, 0.5341644084112532, 0.5828804887920412, 0.5828951902910291, 0.5719518209671327, 0.5830274933261974, 0.570379516774062, 0.11204800393155634, 0.09311914818796208, 0.08465603721573445, 0.09769732599930225, 0.15066099844186343, 0.08698208313238898, 0.09073788619890655, 0.1102502402937886, 0.11425319208859597, 0.17266319175328348, 0.41715123444518765, 0.34447911601719206, 0.21211033758500053, 0.39919342301701044, 0.14927429307501838, 0.24464350092353382, 0.23008545193217456, 0.2251607339649413, 0.3591948594475458, 0.4010178765546756, 0.44596870603003813, 0.39076596793536966, 0.3616438558794648, 0.3627736411344431, 0.39862553449942684, 0.4265516805179095, 0.4145380510580484, 0.3068488947407345, 0.323579158275333, 0.31833266400644056, 0.29448694128048336, 0.28435589732113076, 0.3162521649580472, 0.3369710269590389, 0.31067331907632156, 0.2528172085757412, 0.182845839771268, 0.2233857224005128, 0.18516907487347767, 0.18792797504159775, 0.18242920969893428, 0.18527107193919556, 0.18245051104970955, 0.19974239675771532, 0.179749489002894, 0.18055828022174136, 0.18922858101914064, 0.21930953571416745, 0.22366191601868846, 0.22606942856499268, 0.21306379414044008, 0.1755318628187007, 0.22513738130988292, 0.16559279130845228, 0.8573812261782274, 0.18332985250746603, 0.15091407153817493, 0.8293462851162157, 0.18838118125459302, 0.15957266136029846, 0.7746422125349463, 0.6972016941411441, 0.7361866201728344, 0.8172625803512157, 0.20362480619733103, 0.7950284576391707, 0.16440345429318803, 0.6120687745260749, 0.6572994276575476, 0.20348502495231668, 0.206307605129189, 0.6844646533156196, 0.17589677658384062, 0.16900078777611582, 0.19602674148997223, 0.17603984193770772, 0.17458800702637123, 0.18954725681341633, 0.17105237329572143, 0.18234230607977808, 0.17911766801438733, 0.07605395564517525, 0.0747851322762011, 0.07678992347978131, 0.08220798390885231, 0.06980342994761668, 0.07524126680706267, 0.06504378922048948, 0.07195764215478817, 0.07830504228119939]}, "mutation_prompt": null}
{"id": "4e96780c-bf96-46a0-8bb7-e0c7ccc9876e", "solution": "import numpy as np\n\nclass EnhancedPheromoneDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 10 * dim // 2)  # Increased population size for diversity\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.05\n        self.mutation_strategy = [0.6, 1.2]  # Adjusted mutation strategy\n        self.learning_rate = 0.1\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.1  # Increased dynamic mutation factor\n        self.pheromone_influence = np.zeros(self.dim)  # Pheromone component initialization\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            pheromone_decay = 0.9\n            self.pheromone_influence *= pheromone_decay\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                trial += self.pheromone_influence  # Pheromone influence on trial vector\n                trial = np.clip(trial, *self.bounds)\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                    self.pheromone_influence += 0.1 * (trial_perturbed - self.population[i])  # Update pheromone for success\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedPheromoneDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive strategies incorporating pheromone-based influence and diversity management for robust optimization.", "configspace": "", "generation": 34, "fitness": 0.13922157097499938, "feedback": "The algorithm EnhancedPheromoneDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.19.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.14331242169173097, 0.15916591802444835, 0.31487359326453646, 0.16266563097712783, 0.15851268596196477, 0.20950761305488774, 0.16943211571447192, 0.18650489132938952, 0.13547021221434918, 0.00028153762060678655, 0.0017055975331778939, 9.999999999998899e-05, 9.999999999998899e-05, 0.02274223114697671, 0.02309903394320012, 0.007008949139779341, 0.022997828162091394, 0.011437993826819537, 0.06699110653874263, 0.070649815181266, 0.061681737656943736, 0.051839836967087605, 0.06403229235660113, 0.06350727167526149, 0.05820121352802998, 0.06218141849007952, 0.045823208332256615, 0.061830539840199705, 0.01831062187636434, 0.05707928177338595, 0.06704384868693125, 0.05608568103863509, 0.03703700888464412, 0.051186600447868824, 0.0638363844972002, 0.057020445336933734, 0.9904390177352863, 0.9675559870724983, 0.9878548041525628, 0.9586975708437512, 0.952192243207019, 0.9706170372965592, 0.940875550777288, 0.980571420823408, 0.9426739325401867, 0.07605231352412234, 0.14537439803012098, 0.06197530090898706, 0.14249487482725431, 0.10468778794368061, 0.10228323346829715, 0.11057204837904355, 0.08222976364597656, 0.05162014571324358, 0.23353949374028193, 0.20809691210905934, 0.22579214626772315, 0.17695028903591536, 0.160083042838984, 0.24925206699820723, 0.21226102507873013, 0.11702232267070745, 0.09348163487837813, 0.05054178798355591, 0.10669991507549514, 0.06363035152878405, 0.0019031516547823868, 0.019984719991823163, 0.06848870645427163, 0.062091276127952955, 9.999999999998899e-05, 0.09133601935475655, 0.023314576106464813, 0.01904021598244876, 0.02082527231206044, 0.06811385064158515, 0.07212243153779041, 0.06575292664223775, 0.06136094530673786, 0.08655284748938707, 0.08684038666138094, 0.01940671313697151, 9.999999999998899e-05, 0.0010381097294656083, 0.027476963233625806, 9.999999999998899e-05, 9.999999999998899e-05, 0.02026730151333267, 0.0001302550230102284, 0.03457938098400282, 0.03227936463569292, 0.10870180491376791, 0.015656137056326958, 0.09160397470043302, 9.999999999998899e-05, 0.02027451364502153, 0.16004278251571302, 0.10630667129126992, 0.11127634906629313, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005735688319706056, 0.013475061825484413, 0.007073310520379739, 0.00950150658524107, 0.0063175819381838805, 0.001553135455926724, 0.006143024285765186, 0.0057673973561808145, 0.0023426030631369388, 0.010318424969213646, 0.06176092687424495, 0.1874852943370402, 0.13550301749733884, 0.29450773033865063, 0.1446965084044114, 0.14477231144709968, 0.31207120917642983, 0.31200415735409626, 0.26619845429194366, 0.30610541321827345, 0.051966695432268395, 0.05202030372414901, 0.03250167929013226, 0.06995596580568786, 0.06402121604554845, 0.0818012041836158, 0.066290732223249, 0.06153254117839768, 0.06909190312689184, 0.12840802352041414, 0.13245465049810612, 0.11849880644559929, 0.11979739833467051, 0.12960001108619112, 0.1748415120181469, 0.11373687172177105, 0.15904049932838515, 0.20757774127688589, 0.18841108848130816, 0.16434991263494558, 0.21651512902060832, 0.19601736906587863, 0.13773276565615766, 0.2249256684434361, 0.17380088844406272, 0.22462995170674172, 0.12849977348948904, 0.1182791847935456, 0.15128709857451939, 0.16170551960191515, 0.09380849048400708, 0.14530505398504245, 0.14217198175206325, 0.12302868583626425, 0.15342514882681135, 0.14653779251534993, 0.168304916968659, 0.18810828694660153, 0.18293179218417044, 0.1645461942420403, 0.12962768491787535, 0.1626366558178839, 0.18234110073207488, 0.15534010203613802, 0.1625250404626637, 0.12420780384274654, 0.14744784756457285, 0.1342584766823849, 0.14771027533723813, 0.14560221280145946, 0.1383904236123028, 0.1487006336244613, 0.13414839976141646, 0.14684464298017608, 0.14362251898789835, 0.14484945139695427, 0.14045189022675353, 0.14226644249887044, 0.15289106251732387, 0.1505905085048702, 0.15594134047250097, 0.16167309469777869, 0.16206301212635532, 0.07469203210691411, 0.15137597326046548, 0.1127588930559934, 0.09921304905123507, 0.1426245245398382, 0.14899717321452732, 0.18718110232209206, 0.10991213919247111, 0.1365129371389041, 0.18425993715635391, 0.18511261944562563, 0.16844875450411945, 0.1728970124362852, 0.17457162038534302, 0.16889699675638437, 0.18714521769275594, 0.1833384963218011, 0.17056719301465306, 0.04495875844540442, 0.06209784161292098, 0.06480600671748438, 0.0635569218316796, 0.05926054720885965, 0.05726427100574638, 0.06573305041326438, 0.05701406571428236, 0.056395734781576]}, "mutation_prompt": null}
{"id": "766a476c-aa4d-47a8-8f00-916bb46b8509", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.9  # Altered mutation factor for diversity\n        self.crossover_rate = 0.8  # Adjusted crossover rate for exploration\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15  # Adjusted for increased local search when needed\n        self.mutation_strategy = [0.6, 1.2]  # Diverse choice of mutation strategies\n        self.learning_rate = 0.06  # Enhanced learning rate\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.07  # Increased for better exploration\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim) * np.random.choice([-1, 1], size=self.dim)  # Added stochastic sign for perturbation\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.25, 1.0)  # Enhanced adaptive increase\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)  # Enhanced learning rate adaptability\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)  # Enhanced adaptive decrease\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)  # Enhanced learning rate adaptability\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution leveraging dynamic adaptive strategies and stochastic perturbations to maintain diversity and improve convergence rate.", "configspace": "", "generation": 35, "fitness": 0.26069644256945484, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.7180167691093129, 0.6980095144817771, 0.6694383044827421, 0.7463369338674162, 0.7617593370321611, 0.7460076332666623, 0.7185484484145547, 0.7201343237182984, 0.683368073164004, 0.2825840766314701, 0.32187142743269004, 0.3149000114118188, 0.3201996323355767, 0.29696282505177884, 0.33301174048306803, 0.32294332709886575, 0.3029713307762544, 0.31111264932526583, 0.10526600289223442, 0.0943980180948345, 0.08401551559406484, 0.09672678814958158, 0.08715197895207605, 0.09856713531986572, 0.09257007816977436, 0.1040649136641294, 0.08682069183315233, 0.07510131138971099, 0.08888349399916173, 0.10374148567872976, 0.07183238154042793, 0.07949693957857129, 0.07869834602990267, 0.07682931270090065, 0.07800892965299355, 0.0780655629217134, 0.9224022761594164, 0.9187295398530407, 0.9331827249863764, 0.9032706965333461, 0.8983165392275065, 0.9151385858343893, 0.9280699777452953, 0.9151954144947362, 0.9325671274697214, 0.35327107595929885, 0.3830712826229894, 0.37311238373130373, 0.3956129197610858, 0.38906758048942125, 0.3817690242168035, 0.4057859064384848, 0.35115745699952117, 0.3546603940390266, 0.24432631979580677, 0.5620162600565154, 0.6079402004896635, 0.24803456670473334, 0.6595732481585387, 0.6629437259325595, 0.5708193950954843, 0.3043932372394874, 0.5819713525099944, 0.2644798116738222, 0.1735620257540873, 0.23004962532034778, 0.2716897308077054, 0.231849558651945, 0.10668616753189619, 0.22067242971152012, 0.18380169627177667, 0.21735432328182192, 0.174863201693098, 0.15287579313365407, 0.08885672834250291, 0.24407954849832292, 0.16964636880550643, 0.1804002125426869, 0.22942656643437165, 0.21662372902100402, 0.21553102358070408, 0.07467305769169164, 0.09522652696240763, 9.999999999998899e-05, 0.03279044547647392, 0.10875231967106846, 0.02167722922615345, 0.1692357163442586, 0.0009733844484551835, 9.999999999998899e-05, 0.06426847373201194, 0.076282370584701, 0.061194207958512936, 0.11640269390438429, 0.06668235303592973, 0.09774274081359491, 0.1476978854535369, 0.18944599731439793, 0.2073208799413565, 0.003072068070146039, 0.05077091353325236, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06545028227436, 0.04802152512583291, 0.057721315662311645, 0.015186765756858178, 0.17503030210764048, 0.10872460608664314, 0.1261485466209904, 0.18833015799433805, 0.18598186926642635, 0.1724463840570739, 0.18466837221617172, 0.17937266261076257, 0.18626227926263117, 0.49843885523912124, 0.4829371061543809, 0.49819010108755835, 0.5022162863144013, 0.48544966300493264, 0.49044676434673207, 0.46456848183129373, 0.47846128545380306, 0.5028013188030822, 0.08038457429831614, 0.07557473982673168, 0.0833119879678208, 0.08579945447591486, 0.09281779959766046, 0.08616612503914822, 0.09620895623353354, 0.07656602147977187, 0.10099318608218122, 0.13838460296962563, 0.2077723509707018, 0.14363804631984967, 0.16163864180793786, 0.1345837582306849, 0.11796926449117018, 0.1413605565448517, 0.1317043314909202, 0.12813205446619214, 0.3084088782976928, 0.29634541554027616, 0.2820652789501702, 0.3338780335801774, 0.3151210137962447, 0.3164683138713662, 0.36959372043017535, 0.304570552354655, 0.32780177513202546, 0.19357782223321252, 0.17602116564427273, 0.21313350569947342, 0.20379810894664419, 0.21503591623707297, 0.19686961573668926, 0.18478017382187428, 0.21391927746022443, 0.20558632987112846, 0.18913642522374086, 0.1927397501417245, 0.17421299054426675, 0.1976466646948204, 0.16852112343202075, 0.19797396575127668, 0.18163997927494857, 0.16385274848079956, 0.18625003852003041, 0.1839446768551326, 0.16904200583723983, 0.16909007599316772, 0.1933670673161929, 0.17331651198260412, 0.17161111352975478, 0.17171533129625483, 0.16940926999325678, 0.17059107561398212, 0.7138675209106735, 0.16987491623497264, 0.1510896231109351, 0.721805154303448, 0.7276118845973529, 0.6472840598219907, 0.17013372577290442, 0.17280721174609093, 0.16151199056252785, 0.1465865279310934, 0.1988239838980297, 0.582961598174053, 0.17045576110373384, 0.32317390416065295, 0.19452076932827767, 0.21007869558854275, 0.17242723337975807, 0.20595795577818932, 0.18440423991950583, 0.18682785821172243, 0.22746495570780068, 0.17595266895313233, 0.18321716464967874, 0.17181339375129046, 0.1802047110747651, 0.1916987287650842, 0.18952808889593853, 0.06567197940802838, 0.06934942023967816, 0.06258611014780069, 0.06607416955475032, 0.06877706146095153, 0.07355697534621086, 0.07333722794622222, 0.07900837204941913, 0.05711659485289655]}, "mutation_prompt": null}
{"id": "c897968e-842f-4076-a54e-1cf046dedbc5", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n        self.ranking_probability = 0.25\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            sorted_idx = np.argsort(fitness_values)\n            ranked_population = self.population[sorted_idx]\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = (ranked_population[a] + np.random.choice(self.mutation_strategy) * \n                          (ranked_population[b] - ranked_population[c]))\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with stochastic ranking and gradient-based mutation for improved exploration-exploitation balance.", "configspace": "", "generation": 36, "fitness": 0.333016101707561, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.7783770954631837, 0.779508054903325, 0.7854141798241223, 0.7842265803266509, 0.8010230677164519, 0.8068034999863716, 0.801071144515169, 0.7677443940791624, 0.7864105521483966, 0.4000985840131155, 0.3468966004538947, 0.40198534104372097, 0.3719212288326109, 0.39781980982242926, 0.3868482375122262, 0.3842470189700482, 0.4303360118129731, 0.4140887622764743, 0.12033850082216435, 0.10803996618242706, 0.08384659353424084, 0.15100563504866493, 0.11711320505624756, 0.34718811428815066, 0.1087897953676662, 0.12628723488138371, 0.14459785171605344, 0.09758099116991892, 0.09516074221937487, 0.09154158230608622, 0.09688363419180201, 0.08039960488619746, 0.11202070899406535, 0.09395966469995742, 0.12312389367045529, 0.11174946239746564, 0.8947044309175415, 0.8872291158161045, 0.8939547640603205, 0.897624622838159, 0.9104238077184023, 0.8931139468801863, 0.8932978855568512, 0.8597785547354982, 0.9098203719421712, 0.43919505087610766, 0.4875332459011372, 0.4577622615335908, 0.42547736180011486, 0.44474252367808154, 0.4092478729519008, 0.42014540956265933, 0.4601813991007794, 0.4933236917305521, 0.22376535726858693, 0.7162863448153867, 0.766274933766889, 0.7859204073034293, 0.7477774829024542, 0.7543401885179872, 0.6373148929103192, 0.823252466968551, 0.7368009939556222, 0.45381993870282866, 0.2745638597460299, 0.2011222757161344, 0.27117057812356726, 0.28290179534222604, 0.4909662806774896, 0.24192723698806107, 0.2714434200290924, 0.19779733718099313, 0.1506977924098124, 0.08875536657442773, 0.26013586439428205, 0.16002483519107102, 0.3081753483601031, 0.24627139614285343, 0.21761022212343517, 0.310873752157488, 0.2126104785094861, 0.2328106855427452, 0.27239204289265173, 0.20210593160805335, 0.23509727576243067, 0.11081748567573235, 0.30228229672686724, 0.11752946466706582, 0.23401884122791872, 0.3181618786608701, 0.31285762108027604, 0.3498512708572098, 0.380447598882633, 0.36172730958090804, 0.3007395338512341, 0.37188947690582386, 0.35205582296053783, 0.2570728640311397, 0.3127592629435073, 0.12124027024479289, 0.10947637036451796, 0.21857361688619492, 0.235723598758798, 0.14456282244521468, 0.1453250263116177, 0.14407796131111994, 0.12314158040539347, 0.1595782197915987, 0.24002034145727258, 0.24575976726213966, 0.23348315520276974, 0.2706017586068037, 0.2534153027556112, 0.2430799203985211, 0.22526073224419563, 0.25524257350281354, 0.22806323366481684, 0.5846004118880883, 0.5611650938063046, 0.5597974352705621, 0.5661347670303556, 0.5758635454159845, 0.5739099970529746, 0.5183114111304709, 0.5426125875196459, 0.5655147657301776, 0.08810174498928358, 0.11509976570587255, 0.10284071154202379, 0.08290058988902382, 0.09517066127532292, 0.11009427168988473, 0.08397566156702596, 0.08370871633783739, 0.08282136938613127, 0.16176037731303383, 0.13302478079238667, 0.2766827040333002, 0.16614438115932972, 0.2058871831738166, 0.25016043905829854, 0.37415417418583397, 0.1433995584726988, 0.20541788604580657, 0.34513135487030144, 0.42026340114197824, 0.3736417219524113, 0.3663400548894379, 0.3436381970530181, 0.3774927479530108, 0.38536646955041065, 0.39821447376616936, 0.3792447100450699, 0.325525863511824, 0.30317629755986886, 0.27053968576040066, 0.3035639783590577, 0.274347442372014, 0.2880518867776244, 0.3029111713654582, 0.2924816282773194, 0.26111782050214527, 0.18849788981708404, 0.17404239389825993, 0.18486067963145925, 0.17940718076250883, 0.16735136527034844, 0.17416920489257626, 0.20234048586332443, 0.17763668945264033, 0.1890757903904301, 0.207967900676005, 0.500888894868886, 0.2198031751908709, 0.1775875557329748, 0.1861372818514072, 0.18061551713257507, 0.20159687655830472, 0.17563935705750122, 0.18922779904086662, 0.8149804470100926, 0.16910991303887546, 0.15718323144291912, 0.7941560783092246, 0.7273239609708221, 0.19300932868747156, 0.1775715960806341, 0.193289873635903, 0.18140405591837572, 0.546289434050586, 0.20662305118749225, 0.7722067694470148, 0.681323563246873, 0.16515684078721427, 0.7463472912421985, 0.7890202980552824, 0.2043183795367134, 0.20524912262870854, 0.16773956493802578, 0.1866943059486561, 0.1913819078079364, 0.19145855677439538, 0.17683839208048246, 0.17916195677974633, 0.196758352934022, 0.19533160568262908, 0.17948810279792393, 0.06474403208697055, 0.08223486754309484, 0.07358147585541974, 0.08030551161494892, 0.06570852373633296, 0.0734780877112402, 0.07806591428418619, 0.07408278142543545, 0.0868634333151096]}, "mutation_prompt": null}
{"id": "5f49e837-56b9-441c-b2c8-6dbbd1919935", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 10 * dim // 3)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.5, 1.5, 0.8]\n        self.learning_rate = 0.03\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDynamicDifferentialEvolution", "description": "Enhanced Dynamic Differential Evolution using adaptive multi-directional mutation strategies and stochastic control of exploration-exploitation balance for improved convergence.", "configspace": "", "generation": 37, "fitness": 0.26873013810552626, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.7503080838378889, 0.7291226156119432, 0.7631855549582991, 0.7361676446697643, 0.7511708118253171, 0.7717058917835559, 0.7656306559655327, 0.7734710983485948, 0.7346383586738612, 0.376333909509904, 0.28574321891349763, 0.36426923117068044, 0.35760828166302394, 0.35844119132938546, 0.37871846659808617, 0.31573769646493977, 0.3088101661557413, 0.354332576030882, 0.08720905541324098, 0.07628969459795154, 0.07960545829082366, 0.09909988773222633, 0.10659123970124895, 0.0940898444229088, 0.10208256241538272, 0.09158659475987463, 0.1279352962692204, 0.10034186708701431, 0.09559963531466542, 0.08999972589382776, 0.08359259726400048, 0.07875947945120298, 0.08596277689066922, 0.09523452895931861, 0.11220542932784916, 0.07730123956515977, 0.9093487911244988, 0.939724114835038, 0.9443135856358039, 0.9036691976277206, 0.9515860313282135, 0.9196659431761793, 0.9229553808348423, 0.9239007218134312, 0.9230045517158507, 0.41453852830077353, 0.4185749101603299, 0.40376639340003484, 0.3700321271244783, 0.3492727382160079, 0.4255972946780091, 0.4109209337939991, 0.4093540495730401, 0.3680469388871048, 0.6820146211421783, 0.7308542351728549, 0.2578278699382105, 0.4011415809556125, 0.677218383476959, 0.6702331655458604, 0.5636950935590129, 0.5923187627302291, 0.5253558020160609, 0.18136740012906616, 0.24396243615839908, 0.21787264203977275, 0.22062942360332705, 0.21730716940205752, 0.17627544532431183, 0.23743388522648312, 0.187297396596648, 0.22946915180687089, 0.2422827123473571, 0.08541517010438948, 0.1421707264354929, 0.18664595778414128, 0.212793574242092, 0.23976995003932866, 0.26663702714282367, 0.21303669383870294, 0.26834312239462266, 0.10982180528199392, 0.01724397800987021, 0.05019286494811348, 0.05508066084719243, 0.10953686339345514, 0.025158210966298666, 0.0458987256797605, 0.06801441273380837, 0.10364492907581047, 0.13922408268411057, 0.055304099501760184, 0.09857310051199752, 0.2009724192637874, 0.06205444047643527, 0.03691857284646083, 0.1051802743330652, 0.09056286226606225, 0.20885682136040096, 0.09553077823734979, 0.028050054388748635, 9.999999999998899e-05, 9.999999999998899e-05, 0.024476412988036045, 0.07221296325869475, 9.999999999998899e-05, 0.01765470160821625, 0.09166544761036244, 0.14296564911340048, 0.13995371424333303, 0.1734190532160339, 0.18123132402262143, 0.18493705232460456, 0.20283938321783412, 0.15300691822619006, 0.18084248488983967, 0.1774954062053512, 0.5404067520628368, 0.5077517004805452, 0.5120798227667642, 0.49544961747748684, 0.4958662426252829, 0.47302293238356896, 0.49574722024728224, 0.4790022898877564, 0.4635282074284893, 0.09253122552638415, 0.09245132329404682, 0.09238236338059269, 0.07473521269605177, 0.08412125896265155, 0.08279749955449389, 0.08127898026447111, 0.07569029220405643, 0.07756205694880536, 0.131859251663356, 0.13939467021921137, 0.15257749419747446, 0.12264267653275307, 0.13051582165493514, 0.12785522253473014, 0.14833914638542978, 0.14366914615100812, 0.1457538728817448, 0.3214653612123879, 0.341653664852254, 0.2902437831933594, 0.3310016002257242, 0.3342150362557096, 0.2787536958231457, 0.3648474829988827, 0.33370735003555396, 0.3680541444640777, 0.18959986200833134, 0.21610133720924585, 0.20001137738387864, 0.238432774715317, 0.17150107579251583, 0.22035440704241493, 0.26177497518127113, 0.26672022193567724, 0.238820014204286, 0.1762395942118905, 0.17055240640856717, 0.16938676928987484, 0.17647310116069725, 0.1773310112743487, 0.1869584692255173, 0.19243414002074644, 0.1852728594267602, 0.19137715101834396, 0.1660810588196302, 0.1794856721415916, 0.20768305393306052, 0.17580701596000492, 0.17592929511301614, 0.1738562066058188, 0.17564374001322924, 0.17548016079787176, 0.16963916963701553, 0.706562770456619, 0.15980387838537313, 0.15398498328059673, 0.6769407805214456, 0.18335576497349315, 0.6606113494979076, 0.17624707904608583, 0.1948097672467627, 0.3593325016032245, 0.1649970846577724, 0.20301129973520682, 0.16154776215721978, 0.6176161742060144, 0.15814249080242626, 0.20218424642269384, 0.20993921098938106, 0.1989642643517936, 0.2008926288595705, 0.1789408748717447, 0.18486665869132646, 0.18602455352505953, 0.16464933770475587, 0.17695456825261735, 0.16197130184022024, 0.17240935351232856, 0.1798668480769824, 0.173897294926327, 0.07771790076888885, 0.06529810489807442, 0.07481447313238365, 0.06944964486229943, 0.07201918802532692, 0.06259640098684849, 0.06845223617662144, 0.07218230871748399, 0.07740893864985687]}, "mutation_prompt": null}
{"id": "fb9df746-d511-4c37-adfd-a1088b23cf3f", "solution": "import numpy as np\n\nclass AdaptiveDynamicQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(12, 12 * dim // 3)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.entanglement_factor = 0.05\n        self.dynamic_mutation_factor = 0.07\n        self.stochastic_tunneling_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice([0.5, 1.0]) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                entanglement = np.random.normal(0, self.entanglement_factor, self.dim)\n                trial_entangled = trial + entanglement\n                trial_entangled = np.clip(trial_entangled, *self.bounds)\n                \n                trial_fitness = func(trial_entangled)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_entangled\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_entangled\n\n            if stagnation_counter > self.population_size // 2:\n                self.entanglement_factor = min(self.entanglement_factor * 1.1, 0.2)\n                self.stochastic_tunneling_factor = max(self.stochastic_tunneling_factor * 0.9, 0.01)\n            else:\n                self.entanglement_factor = max(self.entanglement_factor * 0.9, 0.01)\n                self.stochastic_tunneling_factor = min(self.stochastic_tunneling_factor * 1.1, 0.2)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDynamicQuantumDifferentialEvolution", "description": "Adaptive Dynamic Quantum-Inspired Differential Evolution utilizing quantum-inspired entanglement strategies and stochastic tunneling for enhanced global search and convergence.", "configspace": "", "generation": 38, "fitness": 0.24543620569368638, "feedback": "The algorithm AdaptiveDynamicQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.5121640841977698, 0.5524267621719705, 0.5708464061542465, 0.5299607858780386, 0.5162344212717833, 0.5572050430755806, 0.5359107564623757, 0.49226108501368415, 0.518011223827821, 0.11731596072771366, 0.12600889478069133, 0.13300887404566508, 0.11877446316907259, 0.1478506830449252, 0.11521840466785216, 0.16295989808205413, 0.15802092154245362, 0.12624938703139632, 0.10288870882630674, 0.09780448872931646, 0.09407279201293917, 0.10588279982825588, 0.1354032227674814, 0.11971959513330732, 0.10470518173613708, 0.1360166575375752, 0.10734560712875296, 0.09058363797128421, 0.08796214618766118, 0.08434679621444197, 0.11237927835800765, 0.07619946829409963, 0.09389475096415445, 0.10283376982250225, 0.10350524210999756, 0.08051488713127275, 0.8770151473268855, 0.8230438536869548, 0.8811305565432563, 0.848109731961632, 0.8958335211477652, 0.8734629804509558, 0.9085843215528951, 0.8922063273135378, 0.8612655780255718, 0.3352627926542062, 0.31875450525894433, 0.32811181884662755, 0.32804036361015443, 0.3370057016914615, 0.2974834070176189, 0.3406169394939771, 0.32547981904218903, 0.3214215130050667, 0.674110394004333, 0.6041847181806608, 0.5201587160847638, 0.672139719115567, 0.6565336107070356, 0.6732680570088564, 0.6215735569094671, 0.6593587617601613, 0.6983655744401287, 0.20025092281998813, 0.22200000041743106, 0.2347356815214543, 0.2023758526653494, 0.175138032067218, 0.16985702851921558, 0.21748757589166667, 0.19106648164016748, 0.18163771059667688, 0.17173779781431953, 0.10626982754838787, 0.1847106162544605, 0.200294613452343, 0.14575156781048937, 0.20706337078844828, 0.17080508624976043, 0.09039089945893197, 0.2117304335021094, 0.08354818244689322, 0.07295559627193104, 0.0538493774986013, 0.06085241440763389, 0.07776306195794169, 0.07668627915433679, 0.05091705242711264, 0.06068720820776363, 0.07284758061320717, 0.10254578724531016, 0.1068296133873693, 0.07663091234057229, 0.11193937437322987, 0.06585990105106954, 0.0640042170575762, 0.12567793840567643, 0.12327238477705416, 0.10970821216159388, 0.037079326142991365, 0.007150416956535621, 9.999999999998899e-05, 0.02025898579972185, 0.02511190491425075, 0.013796205478186274, 0.062098176151395235, 0.03245976268143802, 0.005234861488830234, 0.1478596802386264, 0.129184568529792, 0.14066523936649156, 0.1561455340963276, 0.1417020816709641, 0.15303181604752913, 0.13153556347004358, 0.12879734618088878, 0.13799616753984667, 0.4412975979953466, 0.4431181132011851, 0.445429286741144, 0.47485165869883306, 0.4486614868539165, 0.4350222221732931, 0.44675418636056863, 0.450285874353351, 0.4386210773190903, 0.0889426071232523, 0.09428572121515366, 0.08531019133362694, 0.0802108829121928, 0.10360943170658465, 0.0898466846071535, 0.08137815669354809, 0.08358198672048534, 0.08932893248246687, 0.1444543541734945, 0.13763422617641408, 0.1534450297934269, 0.16199829985193515, 0.15550484782171858, 0.16006677602620034, 0.18639631649012134, 0.12620403462519447, 0.149645552999792, 0.3056025445098126, 0.2980673916077493, 0.324783591873286, 0.3145877576051387, 0.29704849468246475, 0.30721246415059333, 0.3032947921118725, 0.3266909342196833, 0.3073091574651555, 0.22695552339469494, 0.23604498524874107, 0.23769513082257543, 0.21598900044702019, 0.24026739045270462, 0.2328239186355725, 0.2262007162106081, 0.2427287417610643, 0.24831577808611482, 0.17692095687721687, 0.18517337980291715, 0.19062204193043775, 0.20023730362580394, 0.197008089997615, 0.16581632314352124, 0.2014747296890993, 0.17755671827382868, 0.18181242575467638, 0.17848033160274646, 0.1978365098228393, 0.17175139844836818, 0.17802994524514182, 0.18056346205532026, 0.178379698038172, 0.17545597805190172, 0.20350186720748065, 0.2912305938023022, 0.18029529668818356, 0.6332161585940997, 0.18241138610411167, 0.17080648196946036, 0.18326982024307237, 0.17915630528910675, 0.45611781924566497, 0.5626164796898074, 0.17427552231726418, 0.5660130439092604, 0.20102054013472503, 0.5658237594416253, 0.48717151362090927, 0.19504908316397718, 0.1963587164982986, 0.20917833771031602, 0.20038049111590783, 0.20553433053850834, 0.17378434819996602, 0.19110553677503173, 0.17701196275476327, 0.21263370103166612, 0.17748593656759637, 0.1706098217724772, 0.16833544112465848, 0.1851145055570571, 0.1841939733111415, 0.06982221602009575, 0.07916951002545924, 0.0644919558261774, 0.06853194112650929, 0.08824991458193909, 0.07773363088148166, 0.06917041240467736, 0.06606531032963137, 0.07356431987148204]}, "mutation_prompt": null}
{"id": "21abb605-4a9f-4696-a2ce-eb052a9dbb9f", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 8 * dim // 3)  # Adjusted population size\n        self.mutation_factor = 0.7  # Slightly reduced mutation factor\n        self.crossover_rate = 0.95  # Increased crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15  # Increased initial adaptive sigma\n        self.mutation_strategy = [0.4, 1.2]  # Altered mutation strategies\n        self.learning_rate = 0.06  # Adjusted learning rate\n        self.min_learning_rate = 0.02  # Adjusted minimum learning rate\n        self.max_learning_rate = 0.25  # Adjusted maximum learning rate\n        self.dynamic_mutation_factor = 0.06  # Increased dynamic mutation factor\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            quantum_wave_function = np.random.normal(0, 1, (self.population_size, self.dim))\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = quantum_wave_function[i] * self.adaptive_sigma\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)  # Increased scaling factor\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)  # Decreased scaling factor\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution utilizing quantum behaviors for population diversity and adaptive control parameters for robust optimization.", "configspace": "", "generation": 39, "fitness": 0.28250331209994833, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.7967749039469192, 0.7392659601911172, 0.7842900668660306, 0.7672990398786758, 0.8070313197813274, 0.7801418565555789, 0.7576942732356868, 0.7595430819399162, 0.8057391384633252, 0.3556723684281402, 0.09718900468624359, 0.27541714720011257, 0.27554019304650923, 0.35172211992322566, 0.28879079945443964, 0.2705792292803956, 0.28167611912561197, 0.24631277315128486, 0.13755914753700693, 0.10088041332757436, 0.09011912618593565, 0.10563304186832867, 0.4821974805591521, 0.10649872479422962, 0.09627160717962957, 0.09315146268599162, 0.08293156403971802, 0.0969641114971318, 0.08581267805114223, 0.13446607667926058, 0.09967014264685825, 0.07349559432475672, 0.08255350959337904, 0.12524543608522343, 0.08860703453597252, 0.0889123697622135, 0.8059653870948911, 0.8940767010764549, 0.8510747042394624, 0.9329440869436517, 0.915832333387478, 0.9345266080962313, 0.6321244264530408, 0.8909629432611933, 0.9213699184205545, 0.44638675580114884, 0.3435626761341867, 0.424615763020633, 0.23283045757823917, 0.38570775477823827, 0.37916498629239137, 0.2570919248648361, 0.38665183094076894, 0.46011579138797176, 0.22716712708406817, 0.3600328542077087, 0.3736257559631794, 0.2636476703976578, 0.8550375465945632, 0.2551626399648892, 0.2069115690858263, 0.8369126779013242, 0.2355191723592338, 0.1768502747010905, 0.20708234247331636, 0.194258895820683, 0.19460103938119044, 0.174880448742173, 0.24058229862474867, 0.2127734645471283, 0.12694042914849124, 0.18542503030687263, 0.12609664068659843, 0.19282856787696, 0.2354151940113609, 0.13032581362404239, 0.3634607603622225, 0.26928465239513455, 0.12805767743622398, 0.12683086490701134, 0.14669748413049966, 0.06547750078088377, 0.13504562535039966, 0.2332674727736389, 0.09251990495051399, 0.14788843735176982, 0.11618351720106179, 0.22343374251968284, 0.09058977814338942, 0.18143078654913503, 0.11116546362816992, 0.27171189655765615, 0.1807471062100593, 0.13162746279409454, 0.0924412754670082, 0.1647574760894751, 0.19782192727553116, 0.22548545457319213, 0.32611074216173663, 0.22268772813013693, 0.06464399922257502, 0.1829918852974165, 0.19036004270241302, 0.10384487066541437, 0.13780603907036204, 0.1762295712258075, 0.09857462047671939, 0.21833603420729308, 0.2586033456210719, 0.23833130950721126, 0.20812849115686305, 0.20207121061260014, 0.25043643208188704, 0.2588955545645628, 0.23200522432493087, 0.2480135294763518, 0.23573762443620516, 0.5654600061158832, 0.5571104447425468, 0.5765844316369462, 0.5410965795285001, 0.5755482977257274, 0.49446433318197947, 0.6030389184235624, 0.5118239549541532, 0.5506550546310971, 0.08516603355753394, 0.06916236866008274, 0.08760733919396613, 0.10824881015865195, 0.08804112952740817, 0.098119058044007, 0.11063446330424198, 0.1311331292168123, 0.10072324430777047, 0.18481175621651869, 0.1508439258630626, 0.14330376563861646, 0.24480184648530623, 0.14100612291872006, 0.14602217006557605, 0.1578208901063437, 0.2785425606818158, 0.21472548171923844, 0.3803978178977835, 0.3003684027753698, 0.33187327957141965, 0.2856549544953626, 0.32665724494950066, 0.3068458534085814, 0.4269548312376723, 0.341903032611658, 0.29406750546282423, 0.21539944142152756, 0.21200740465753298, 0.32476657197481995, 0.18363789971251865, 0.18729086879046186, 0.27683037145539835, 0.34580075446554315, 0.19663103696010698, 0.23275342966595935, 0.1867790164829798, 0.20196713077084305, 0.24964384451470467, 0.17331615826894542, 0.23180966158410643, 0.18447530483895402, 0.20174479340002194, 0.17429350084429407, 0.1870043337468994, 0.1927761858303213, 0.16821910687900943, 0.21340059104925346, 0.24387784069999685, 0.18379640193909386, 0.21635333033357795, 0.1944884741301769, 0.20515833362140656, 0.1901897464703034, 0.1721025789906302, 0.16874407758972498, 0.15753862618349213, 0.66565298211657, 0.1839348683955001, 0.19884879336823502, 0.1853246443648906, 0.8855540950109618, 0.5013640335667914, 0.16642211437859644, 0.2049957873227558, 0.8500326223748105, 0.2061808058449558, 0.2057720754514426, 0.2076283584911469, 0.5925915421519694, 0.20475512239436788, 0.3350450327112465, 0.1744049883836376, 0.17541884840656252, 0.16380157129044293, 0.19520876010149868, 0.19625114668426202, 0.1912940747534343, 0.1755618635641797, 0.2001418038515902, 0.18425499507715382, 0.07493738481896839, 0.08624548832197454, 0.07142290229193005, 0.07222035224585632, 0.08210512152238114, 0.09302180043656938, 0.07379653357208549, 0.08569895585715026, 0.07834414600524431]}, "mutation_prompt": null}
{"id": "2e5ef5fa-4f97-46fa-8883-e36b410e4924", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.dynamic_mutation_factor = 0.1\n        self.history_factor = 0.3\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            sorted_indices = np.argsort(fitness_values)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + self.history_factor * (fitness_values[sorted_indices[0]] - fitness_values[i]) / (np.std(fitness_values) + 1e-6)\n                mutant = self.population[a] + dynamic_mutation * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate *= 1.1\n            else:\n                self.adaptive_sigma *= 0.8\n                self.learning_rate *= 0.9\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with dynamic selection pressure and adaptive learning rates for improved robustness and convergence.", "configspace": "", "generation": 40, "fitness": 0.24216418306846332, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.40026768667411716, 0.44966341537801946, 0.7196963469317299, 0.5263401182508687, 0.551431376740839, 0.587231298673603, 0.8118759039382137, 0.7903697635281021, 0.7438611590671889, 0.03451784365308108, 0.1187696495764965, 0.29391703082300136, 0.2908036283330694, 0.25352917714529744, 0.09846379654686899, 9.999999999998899e-05, 0.6617661520708421, 0.6273860987370461, 0.14786964661780255, 0.11952525644768808, 0.16887319013680935, 0.5135846081985433, 0.14245918565541238, 0.15071371435120617, 0.1541837630460512, 0.12021129622517945, 0.13468425977400622, 0.10371521690127139, 0.1096697551814696, 0.10686228343273318, 0.1107588222336422, 0.13394154104303546, 0.14189119413852747, 0.08270169816717332, 0.0865251094900632, 0.10976676025077325, 0.7827887994330054, 0.7636449758650509, 0.46138357019853793, 0.3369257679447649, 0.3553008733924161, 0.22968542938380487, 0.8648060304369081, 0.16831941138060325, 0.25575038746599965, 0.08942277520835273, 0.1517782033405901, 0.1355665562272128, 0.13688731254044573, 0.18583083294887293, 0.03496587691461994, 0.1660093402187276, 0.17022567385244514, 0.18764035974451687, 0.37008924652421116, 0.36185100019118144, 0.34252736777302817, 0.2757084368832303, 0.8030702933636362, 0.26104599278388263, 0.22517081073116285, 0.3468290539056881, 0.22583806592740086, 0.18109191151019222, 0.16856909480850824, 0.1231120624307227, 0.22773174016491415, 0.0888906933083441, 0.1821560236274551, 0.13376874944177075, 0.12712518745321666, 0.1405384874172525, 0.1264121728468166, 0.14462171450708172, 0.18269568362720956, 0.12145229280408076, 0.20021215187375985, 0.12906890356633505, 0.17976009779580382, 0.1252034096452047, 0.12451346195174084, 0.0951025423933648, 9.999999999998899e-05, 0.08810561835797381, 0.08520073768730907, 0.14391407263054767, 0.022807991945326456, 0.014635329642378236, 0.05200231136642708, 0.32447096274509424, 0.22517423142394766, 0.18924888306652288, 0.24603821028517137, 0.32104948264558775, 0.14858416808331765, 0.19356847178288483, 0.24573011455771643, 0.21324999932968858, 0.4324931254455592, 0.11473394116593094, 0.05831867722079209, 0.10227207890011758, 0.062168682705755596, 0.22059664691875336, 0.07854981058564936, 0.19484069345214594, 0.1254809043684718, 0.24727889485072396, 0.11243565763688934, 0.08293784476907873, 0.1345065847610435, 0.07896207971595592, 0.07107648941302724, 0.05125695890335935, 0.14316322221698752, 0.10011885457094172, 0.07614750346844579, 0.3889826172009794, 0.44376738722653886, 0.5142666558918496, 0.442973349968649, 0.4738888233486931, 0.4596285784407712, 0.25899279948283227, 0.32186383059742707, 0.5425328747417191, 0.063494403216944, 0.11985165696598177, 0.11783506815909439, 0.13419633809549392, 0.10897880439437291, 0.12341616511870634, 0.13477600421860592, 0.12524027101748414, 0.1109356267312458, 0.3381238537847082, 0.18279304043604105, 0.226016853950729, 0.2578846210952095, 0.3752342604314126, 0.290808621652175, 0.28883426758206565, 0.29611830271653117, 0.24718866129437267, 0.323271131619576, 0.3263591461353994, 0.3231709961908654, 0.37964062229993334, 0.22974188918951965, 0.4160538872511833, 0.4255119398752947, 0.29686771039002646, 0.4236257082470746, 0.2532101421283196, 0.29525832976060706, 0.2905768185514621, 0.20297373721914402, 0.2996603481255049, 0.26510538012121565, 0.27017259473749133, 0.20404703060063023, 0.25719403068561797, 0.1933381178495991, 0.20636254686085453, 0.17452756486678422, 0.23529357323969147, 0.22306914454976112, 0.25018750656408506, 0.19609059883180435, 0.19696958440235834, 0.18944817734432362, 0.19192624975868888, 0.32061779617889974, 0.2345720321042094, 0.21594344904218732, 0.18424509189472937, 0.20313017828523638, 0.2445780154762468, 0.23112699046204044, 0.19019117875336744, 0.18969462649647162, 0.16834453722729104, 0.18112379416638258, 0.32864125076276784, 0.18648645252649731, 0.3714905043690504, 0.7539126849514745, 0.7945161946522267, 0.18237269395531297, 0.8425463210100386, 0.1447820390376543, 0.2017642602558768, 0.16779318060679138, 0.20779355624178875, 0.16666633646777995, 0.20602345263133381, 0.8110903830641482, 0.18198394149815011, 0.17583256187115182, 0.16393888651963462, 0.1714648525574326, 0.18034652167700382, 0.18577735870857337, 0.1871328622098044, 0.1874177217571259, 0.1775298535007419, 0.17704566754708628, 0.08266877350977286, 0.09259863521809908, 0.06275864541265563, 0.086110449601011, 0.09882203724632366, 0.08474825429974664, 0.07667907780612093, 0.09633320561430625, 0.0903131807227191]}, "mutation_prompt": null}
{"id": "69437d04-7b38-496e-9e3a-a6db47bc5bd8", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.initial_population_size = self.population_size\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n        self.resize_frequency = 50\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        resize_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            resize_counter += 1\n            if resize_counter >= self.resize_frequency:\n                resize_counter = 0\n                if self.best_fitness < np.median(fitness_values):\n                    self.population_size = max(self.initial_population_size // 2, 5)\n                else:\n                    self.population_size = min(self.initial_population_size * 2, 100)\n                self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, self.dim))\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution integrating self-adaptive mutation rates and adaptive population resizing for improved exploration-exploitation balance.", "configspace": "", "generation": 41, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 31 is out of bounds for axis 0 with size 16').", "error": "IndexError('index 31 is out of bounds for axis 0 with size 16')", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {}, "mutation_prompt": null}
{"id": "fbd19aae-197e-4379-af67-6baa9b709c11", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 42, "fitness": 0.34140736310572783, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "9f8fa481-57e7-431c-8ff6-9618c7897241", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "1b088cdb-6070-4a01-8eac-695afdf75dc2", "solution": "import numpy as np\n\nclass AdaptiveQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.005\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                q = np.random.rand(self.dim)\n                quantum_mutation = (np.log(q/(1-q))) * (self.population[b] - self.population[c])\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * quantum_mutation\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.005)\n                self.crossover_rate = min(self.crossover_rate * 1.05, 1.0)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumDifferentialEvolution", "description": "Adaptive Quantum Differential Evolution with dynamic quantum-inspired mutation and adaptive crossover for enhanced global search capabilities.", "configspace": "", "generation": 43, "fitness": 0.22259905839569083, "feedback": "The algorithm AdaptiveQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.5391417297915819, 0.5831879068938782, 0.5377135430610783, 0.5980081419551581, 0.6296473925531259, 0.5899923403622147, 0.5180464151695172, 0.6190991474803581, 0.522536335380788, 0.19499891245691459, 0.19104346777989045, 0.2283660099470357, 0.203010958802875, 0.18982370859356856, 0.20550797432207124, 0.16082982813991276, 0.17101757973555742, 0.018078153051144685, 0.09942136024677162, 0.11887753348196217, 0.06938974042204082, 0.0740781677099751, 0.07462102888472377, 0.11497294617243936, 0.08356576817389538, 0.08251589399412018, 0.09919615558275419, 0.08220865392681698, 0.08812697007583592, 0.09958025941257742, 0.0951425280622692, 0.09588580208524144, 0.07336104096169782, 0.07219038606532491, 0.07632489116992403, 0.08523293660995679, 0.9382737414912546, 0.9022525567912564, 0.9249561983712702, 0.9292052426110229, 0.9352333004236819, 0.9149862534291636, 0.9394226969586066, 0.9502566325612003, 0.9073098511416526, 0.28975498999025673, 0.3148314943879126, 0.26719461745582584, 0.30962114677430863, 0.3415113881245395, 0.36831126681391524, 0.33536720429409994, 0.3041341040051987, 0.28717768038759994, 0.19551073670604702, 0.20871271358991395, 0.20547890096733634, 0.2834960449885703, 0.24591154975836227, 0.2020496272543365, 0.16505298959926928, 0.2013850740397849, 0.20814578222097846, 0.13745292717929025, 0.15695665577380602, 0.1627640994692383, 0.16149612230573474, 0.1420197776090919, 0.17290456140291954, 0.15531768001995294, 0.14479691049497745, 0.13324202073539615, 0.16678863208254058, 0.15772077926911954, 0.1699192105633046, 0.10469032240696341, 0.17174963839956237, 0.13570715238351427, 0.1569248478276366, 0.1104671194819713, 0.14519963072931896, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03250890041092225, 0.045588008540038416, 0.05664317140681563, 0.038923814414631, 0.020867234410295588, 0.02316384424186657, 0.002821427981699154, 0.06739656200806621, 0.07270559731603587, 0.009077296949878466, 0.00877510065494791, 0.012558388334444892, 0.04195720468358177, 0.05382844427437672, 0.04532837531883216, 0.04712129594792258, 0.007107817707614261, 0.06707267072561829, 0.04946963498473611, 0.1132305253190451, 0.07356258815446526, 0.04580131112716335, 0.030916861083421288, 0.14278586336712162, 0.050008772630873555, 0.09664486317624543, 0.07240097735538698, 0.05951740311845022, 0.4161441429782471, 0.4087086402041781, 0.43763330901726727, 0.4011623494364335, 0.43276928480987664, 0.4031366302163276, 0.43228161916139596, 0.40057277069449093, 0.4352078630946684, 0.07974838704008635, 0.10223408141247015, 0.07841065713059181, 0.08679386824048285, 0.08742534133863022, 0.09017178094897227, 0.0803154873718166, 0.08431090126029317, 0.06423855127687839, 0.1441996577799235, 0.18954140102241068, 0.15355981053681844, 0.16410984464569445, 0.15473419484415885, 0.19380573589356054, 0.14875393347725208, 0.20534469567541935, 0.16135562430571737, 0.21565189210115832, 0.28469818205663755, 0.22611043023665878, 0.21335538131813025, 0.2538699503419193, 0.20998997056430135, 0.2638122501189958, 0.27538719477393014, 0.2792790177208613, 0.212505692163935, 0.23243972033085625, 0.19630566089555246, 0.16592980299542037, 0.17740352042634477, 0.18342830916167374, 0.2185744383316165, 0.2257684860594743, 0.2085681153563329, 0.16846332078917825, 0.19373915868673952, 0.1565153841029998, 0.15513054793029513, 0.16408174742976478, 0.16553999811267173, 0.19679362028536662, 0.16431899228189417, 0.18439299330012637, 0.21608348008504785, 0.18269915031665274, 0.20842079553925585, 0.17434888801560788, 0.23202317036188758, 0.16339656468058783, 0.20483490143324834, 0.1812993076244156, 0.16930151471288424, 0.7069175448146816, 0.7120898824847204, 0.5452972216269989, 0.7278590591202976, 0.17761185203315655, 0.6094323773617114, 0.17986768499972605, 0.6065547360161685, 0.19695641782436601, 0.16476899804430833, 0.1464660000843755, 0.1654438872162195, 0.329231047184262, 0.16078909906680405, 0.2034468232213228, 0.2015382172064476, 0.6147478918245411, 0.541974194032695, 0.17887678982587019, 0.17557997667930592, 0.17171085677155784, 0.1706425639014737, 0.1761164299131378, 0.18763750570219873, 0.24787302989384763, 0.18109444004468156, 0.1930343175383591, 0.0656268949071438, 0.07653542059720309, 0.06919343916638832, 0.05857909135426875, 0.06699711404011433, 0.07257343094817714, 0.06699231605723877, 0.0705535850606126, 0.06466692501715421]}, "mutation_prompt": null}
{"id": "93b6f2a8-e058-45a8-9c5c-56d48071450b", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "8194f06d-70ce-4d10-8eaa-1129934d0721", "solution": "import numpy as np\n\nclass AdaptiveBiasedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.rebalance_factor = 0.1\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.scaling_factor = 0.1\n        self.mutation_strategy = [0.4, 1.2]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                biased_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + biased_mutation * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.scaling_factor, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.scaling_factor = min(self.scaling_factor * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.scaling_factor = max(self.scaling_factor * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.8, self.min_learning_rate)\n\n            if evaluations < self.budget * 0.5:\n                self.population += np.random.normal(0, self.rebalance_factor, self.population.shape)\n                self.population = np.clip(self.population, *self.bounds)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveBiasedDifferentialEvolution", "description": "Adaptive Biased Differential Evolution using stochastic ranking with adaptive scaling and rebalance strategy for enhanced convergence.", "configspace": "", "generation": 45, "fitness": 0.3003244779082653, "feedback": "The algorithm AdaptiveBiasedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7006594260570618, 0.7203513915539596, 0.7831165543524417, 0.7503468521304427, 0.7739084023050746, 0.7592410035931575, 0.7240181621988253, 0.7319870621581651, 0.7429794941664145, 0.32739143852055064, 0.35650838209675983, 0.36010519181840484, 0.33649079546949845, 0.34858458041127327, 0.34328274611601595, 0.35596551664148923, 0.3415467740478805, 0.3637087562587602, 0.0843671637736475, 0.08535508069489695, 0.0910877609106967, 0.10906527163548252, 0.08728855125705026, 0.09619210905273179, 0.09471173017909662, 0.09088392310236793, 0.11262633413353074, 0.08386821538108868, 0.08389980801945007, 0.08934366058417342, 0.08977642160188481, 0.130916956729917, 0.06517906911484128, 0.0982828211314325, 0.07843398200983442, 0.0795823451418406, 0.9147328045219795, 0.9187001340124055, 0.93738991923882, 0.8803672300723718, 0.9119203950540719, 0.8915640384235496, 0.8907500620651092, 0.9172963004367215, 0.882099465357802, 0.41127136833131195, 0.3408669572317842, 0.3725288076168537, 0.36699181335770736, 0.40195695787535823, 0.4244109194617557, 0.39693319142962535, 0.3334429558132801, 0.3728573622122632, 0.7109719495149258, 0.6273529717688064, 0.7387835471356403, 0.6785048245435744, 0.7099952739043385, 0.7071565727101998, 0.7210227219344721, 0.7492679740527053, 0.6420490882698109, 0.19783478709209523, 0.3104410023813501, 0.22604064466190354, 0.21307016516281752, 0.2673822208844737, 0.3274663303424209, 0.29521128911968886, 0.25964175189275573, 0.28723555410995083, 0.08243718042025316, 0.40789009277198984, 0.10597409074307163, 0.2661142380376086, 0.26430183302707666, 0.3045929758418635, 0.11208020597993562, 0.19084619359639932, 0.22778102764790875, 0.28309903412093973, 0.21146354376340715, 0.296293119268929, 0.1872614872792313, 0.23526208450165964, 0.24531736045609365, 0.21283553210951678, 0.29136121046444563, 0.24314788278599442, 0.29738414041164396, 0.2614469926030417, 0.24128944351492998, 0.30981620494228024, 0.2966601282866945, 0.2927138864445008, 0.34836086615607664, 0.2771876578031638, 0.35018756066259127, 0.09274129485874072, 0.16837300858363125, 0.08326518986820497, 9.999999999998899e-05, 0.17491115515983402, 0.12321446767741695, 0.09595919920360796, 0.09238884511264711, 0.12434482409300796, 0.23667477225321154, 0.21786237634345307, 0.20351108080934333, 0.2201706137209417, 0.22328239447824494, 0.23463732173315144, 0.24561864692279123, 0.22634547020598617, 0.2250524653357261, 0.5334266085089658, 0.5363954670164053, 0.5358420884645458, 0.5050220136554545, 0.5018221791029052, 0.5388800836761405, 0.5445461893120799, 0.5356387771654393, 0.5556543376275818, 0.08568647228614723, 0.08741945408645002, 0.08680621498287056, 0.08625043293445067, 0.07816395857601033, 0.10493364946974126, 0.09193070534505243, 0.09036110964755628, 0.09495502558777458, 0.18330448659262433, 0.1203570026931986, 0.15421076733245587, 0.14604688030727098, 0.18345035364098505, 0.1410083394106627, 0.18279259209504561, 0.12429270211655863, 0.14605159095184994, 0.27319872448906846, 0.32156445350678986, 0.325499157933691, 0.34539946141796596, 0.32595715153887406, 0.27546825344778214, 0.383122956329771, 0.35644472856334086, 0.3616172013539325, 0.24985250217927468, 0.23427965186392719, 0.2318135817289685, 0.26526632185501864, 0.2363101651070717, 0.25640706872143526, 0.25005638699767263, 0.2767949523009273, 0.2926224714733552, 0.19005658106465984, 0.16492423452560634, 0.18158863487534604, 0.16811941410681375, 0.17794023309522833, 0.18026512654046511, 0.19395205227752677, 0.17530809518829815, 0.20992501495153737, 0.1756509423958752, 0.1822653399162557, 0.17744023688646482, 0.18550927762712432, 0.17726376797892807, 0.18482478775546385, 0.1914442687808089, 0.1857676176191021, 0.17895462288166641, 0.7750632591509884, 0.19484859053569337, 0.15205944231688973, 0.18716113340704443, 0.6530187236430134, 0.17362719492905399, 0.1401390945733283, 0.7604664396245674, 0.1794293920624701, 0.20472623839339, 0.2085569262310374, 0.19357704284096322, 0.1986225714619726, 0.1991141869373687, 0.6776721793525758, 0.21118186150550844, 0.20466979302160593, 0.20522638484590183, 0.1729200726349962, 0.16921725085249473, 0.19448164271112178, 0.16678612141749416, 0.18951178255805712, 0.18121377008616657, 0.2300808280882427, 0.1855924759721569, 0.1748211122956922, 0.0632860794615332, 0.06847941260678692, 0.06823003026280183, 0.06982319239368895, 0.07965771920932507, 0.06508394753198188, 0.06814270025501323, 0.0819885670837519, 0.06536295972234618]}, "mutation_prompt": null}
{"id": "e838133e-6149-40d4-b304-881c2c5bd27c", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "c1ed374e-8e5c-4a5e-aaa5-bb2cdb8c18d2", "solution": "import numpy as np\n\nclass ImprovedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(20, 10 * dim // 2)\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.6, 1.2]\n        self.learning_rate = 0.04\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.08\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.25, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.8, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedDifferentialEvolution", "description": "Improved Differential Evolution utilizing adaptive learning rates and Gaussian mutations for enhanced convergence and robustness.", "configspace": "", "generation": 47, "fitness": 0.23407602545009476, "feedback": "The algorithm ImprovedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.5722661237330504, 0.5143091436635103, 0.5844666072028666, 0.6031039181133598, 0.5988260425614984, 0.5732997471764297, 0.5739140447787152, 0.5852608186286898, 0.6120724512017406, 0.25113951314073246, 0.2606276102954914, 0.2741537829217795, 0.27454682095722693, 0.2917080955013024, 0.2535841244186404, 0.28388044797364587, 0.27208961508762664, 0.25992901197646257, 0.08269339704789602, 0.08440201548296211, 0.07640032408202913, 0.08588992940105977, 0.095878956892269, 0.10650053028780804, 0.08397528252732755, 0.0861307908373421, 0.0869921339496097, 0.08176219160698861, 0.07565183564858491, 0.09563950199349036, 0.09960234068039275, 0.09026217714791596, 0.08424414797550706, 0.07505964343519755, 0.08922459112679593, 0.0851668802893355, 0.9164582098770845, 0.8867132415514029, 0.8881749082336471, 0.8850987850740977, 0.9017554326503197, 0.9007782630407501, 0.8740549222223185, 0.8949189410196988, 0.9370132316543786, 0.27252069161366466, 0.25176665442357604, 0.23464131757296303, 0.2562419043610996, 0.21646670387197087, 0.28007536660893706, 0.2418718617348392, 0.2478760800312616, 0.26493201111086784, 0.4356483717850167, 0.6021784072363785, 0.5200556218910153, 0.43581894586473036, 0.3190067349898865, 0.48084496946879873, 0.425883164019081, 0.37191174307281294, 0.361218012653458, 0.14695373295665282, 0.13590929276533203, 0.16423608605439843, 0.13655096338330242, 0.1062020432913292, 0.1776893755914114, 0.11657578014172554, 0.18586296361859944, 0.16282466358151637, 0.08454434558023782, 0.14669843222236323, 0.16967857168021216, 0.19440096471287038, 0.13537748802265304, 0.14268878880907343, 0.13999766203548258, 0.14208917497880957, 0.14107464185720653, 0.08865171839804675, 0.07014490696427422, 0.07786859876959928, 0.09919028690465581, 0.09935526212673307, 0.09045469177455068, 0.08760038272045945, 0.07740979384835156, 0.059728266048954204, 0.21816464246659006, 0.13314896384473052, 0.2079904582415324, 0.1623045099165038, 0.1753430340445289, 0.165859493123231, 0.22838816580821109, 0.2039357103298577, 0.21988579467865188, 0.033823215439842014, 0.01518792361352661, 0.010545448558143877, 0.03319543034699857, 0.0022631595097729607, 0.02578272498899059, 0.003870194396677462, 0.029777364675000362, 0.005108718435860138, 0.1366010127813988, 0.12850914519001166, 0.14024933782011428, 0.12246470590371195, 0.13926841074113128, 0.14428887660377565, 0.13156894531519814, 0.13132021467261545, 0.1512575021719631, 0.4154648555415349, 0.43060086225503325, 0.4304298213478226, 0.4517010839128992, 0.4307012056479358, 0.4480091564111208, 0.41746994887391864, 0.42298108910890797, 0.4410384291055782, 0.0750669634630049, 0.08510342471746424, 0.08951055652958806, 0.08044170053673916, 0.09566370015293346, 0.08968217767676956, 0.07093494601520522, 0.0735422643633925, 0.08155836301602615, 0.13105079285543053, 0.158976989064462, 0.12299977908303694, 0.11321033350821563, 0.13244241640189625, 0.12375233915956596, 0.1313255961459856, 0.18098355724284243, 0.14319860428425568, 0.2462669206620799, 0.26112255912343896, 0.2658608430011975, 0.2643865944600615, 0.24845321193503256, 0.2908093703957606, 0.2631362727415614, 0.29820209687073906, 0.27969055817676935, 0.17925495533969316, 0.17858920524510946, 0.1882365442155236, 0.16849012605468383, 0.19041906884355064, 0.18721695792970483, 0.21908057896304545, 0.19195844236230342, 0.19435615299938014, 0.16194340790573736, 0.17665328648504186, 0.19751677200073225, 0.17218916390576555, 0.15652861469785007, 0.19104628337928242, 0.1846302528979632, 0.16998497674586488, 0.17354792162586619, 0.16720161984874415, 0.1739419060316808, 0.16939058568377696, 0.17164875204460206, 0.16498125472975167, 0.17805013693462368, 0.1653085989951869, 0.18169224878576273, 0.16739000688400707, 0.6283695280386987, 0.15408626974021467, 0.15716419225841982, 0.17668391550065154, 0.1792906155028906, 0.6331220460986227, 0.1609224889756753, 0.12944730001032856, 0.5587716945966013, 0.16021964694210877, 0.19891041539731336, 0.19345598293939026, 0.18161595775742967, 0.16608032040193554, 0.2823112880978653, 0.4810102516064576, 0.5094467353209624, 0.20576695050666172, 0.17158214088964308, 0.16560443162553562, 0.1850636532304647, 0.213376152729151, 0.1645829262646059, 0.22283653230628886, 0.18044264169885227, 0.1994725209117203, 0.18334182928774145, 0.060996589967122206, 0.06523877391654076, 0.08056852203160692, 0.058564077305503615, 0.06671765074099967, 0.07770968494757713, 0.06583481014910375, 0.06975421773632129, 0.07660046662930686]}, "mutation_prompt": null}
{"id": "76b5f696-1099-4c3b-a32a-272995277994", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.w = 0.5  # initial inertia weight\n        self.c1 = 1.5  # cognitive component\n        self.c2 = 1.5  # social component\n        self.positions = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best_positions = np.copy(self.positions)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best_position = None\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            fitness_values = np.apply_along_axis(func, 1, self.positions)\n            evaluations += self.population_size\n            \n            for i in range(self.population_size):\n                if fitness_values[i] < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness_values[i]\n                    self.personal_best_positions[i] = self.positions[i]\n                    \n                if fitness_values[i] < self.global_best_fitness:\n                    self.global_best_fitness = fitness_values[i]\n                    self.global_best_position = self.positions[i]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.w * self.velocities[i]\n                                      + self.c1 * r1 * (self.personal_best_positions[i] - self.positions[i])\n                                      + self.c2 * r2 * (self.global_best_position - self.positions[i]))\n                # Dynamic velocity clamping\n                self.velocities[i] = np.clip(self.velocities[i], -1, 1)\n                self.positions[i] += self.velocities[i]\n                self.positions[i] = np.clip(self.positions[i], *self.bounds)\n            \n            # Update inertia weight for exploration-exploitation balance\n            self.w = max(0.4, self.w * 0.99)\n        \n        return self.global_best_position, self.global_best_fitness", "name": "AdaptiveParticleSwarmOptimization", "description": "Adaptive Particle Swarm Optimization (APSO) with dynamic velocity adjustments and fitness-based neighborhood influence for robust global search capabilities.", "configspace": "", "generation": 48, "fitness": 0.1979908079917269, "feedback": "The algorithm AdaptiveParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.21.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.48755509926078444, 0.709518818147685, 0.3589661863098933, 0.3265190886704461, 0.2653806742804896, 0.43448187225467194, 0.6040576063899422, 0.7989442651960386, 0.2627116727524067, 0.10769051646893035, 0.05811632763694796, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.056341436954942425, 0.08423170114501422, 0.04715562402728979, 0.07760553223845201, 0.12600527450329568, 0.09879004498015964, 0.0875985567890577, 0.07057408966335277, 0.049053995499652614, 0.0758802091761418, 0.04513441037058952, 0.0661143490189261, 0.11326283233622325, 0.05666787099811277, 0.04890594605871357, 0.031346404782539694, 0.08048325893554376, 0.03557761808591875, 0.9722759190365713, 0.9750905984887025, 0.9646721943279546, 0.9554332638010997, 0.9778670387691386, 0.9705804239952462, 0.9515182002762886, 0.9722244924198394, 0.9728277738236195, 0.1835373524231414, 0.04302640287850312, 0.07772470021000721, 0.19964677662618024, 0.1830674288502172, 0.17826768142564509, 0.2117831098445988, 0.07091071042230868, 0.11106578380937204, 0.25583473782944244, 0.14172859922005576, 0.17265360960328668, 0.2733778585533363, 0.14579631619187272, 0.24136563893393592, 0.1558060255020186, 0.05403508955981473, 0.13971812243164172, 0.18920058208092805, 0.13366988294332727, 0.1557651428529505, 0.2692172703514576, 0.14474167921445424, 0.013191281879808003, 0.30477969400430427, 0.1434798717414173, 0.12139169523417748, 0.15590878893637383, 9.999999999998899e-05, 0.18377450804637363, 0.14175608510937, 0.13902485758956662, 0.14120157616380402, 0.1243905467524219, 9.999999999998899e-05, 0.14663468991863138, 9.999999999998899e-05, 9.999999999998899e-05, 0.11350566578362653, 9.999999999998899e-05, 0.006330503823998024, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01115168424547719, 0.10360296200760055, 0.0881331324509611, 0.17366799698550606, 0.07169051226270551, 0.03402176569508153, 0.05715451468153876, 0.16649550837827776, 0.07486233907230999, 0.0516964937426998, 0.1315772483174491, 0.03246143085846509, 0.20672741498925518, 0.16858855602374134, 9.999999999998899e-05, 0.4057806382133372, 0.131011538970356, 9.999999999998899e-05, 0.03125045779622326, 0.01820914681186825, 0.15346371141790838, 0.0651799083359692, 0.09017768558464323, 0.07056470941163129, 9.999999999998899e-05, 0.03492284282184277, 0.08788420248619955, 0.08580411164759394, 0.37548840804373007, 0.5015360735273031, 0.2091307969879277, 0.31047936076482296, 0.41330536977059384, 0.28618897682703315, 0.261820337251051, 0.4268658009030074, 0.5732341145231139, 0.042882330062583573, 0.0817641786072687, 0.028433894241671975, 0.0840117384568515, 0.058049238358285016, 0.0782202515348761, 0.12794564515352524, 0.08835030003783706, 0.08371985837794327, 0.23383460416654767, 0.20754167031078097, 0.18430500781525927, 0.16941197468886227, 0.29142068921641007, 0.12998907013787753, 0.3351094239267193, 0.2343104386978715, 0.2524747603869487, 0.14449612464740802, 0.2236279869811768, 0.14895274967594374, 0.1922207978089283, 0.18419269209658928, 0.26718375064615996, 0.15040349619839855, 0.308372152221557, 0.12562605994193476, 0.10243934853338377, 0.12892189887605687, 0.16514056058749416, 0.13709561813771665, 0.19026850778114268, 0.17890128084224488, 0.08587751628497131, 0.2610403271252689, 0.09881985436421203, 0.21844703605375948, 0.20909889025254902, 0.218445822228309, 0.2562632147326779, 0.23230935345107262, 0.17273329237091584, 0.210394873961819, 0.1745757957006423, 0.19937559791727788, 0.16562797991409917, 0.18339074655595722, 0.17904585796576433, 0.19116356338348195, 0.21219410183087384, 0.19337318351536192, 0.1911210960964752, 0.18829115155690102, 0.18224395867448273, 0.12333532160569138, 0.1871940198111236, 0.15324728260557274, 0.3718532581909648, 0.20213300741746132, 0.45860751093038277, 0.16645300379419858, 0.9599811119423073, 0.160395824517636, 0.4000917791897759, 0.2117015727480832, 0.27485945430053227, 0.41516821192186526, 0.16958359924447286, 0.15256624852704914, 0.16561700435908222, 0.12864923304367026, 0.200192861758135, 0.18788255624843597, 0.21187089326585518, 0.21014950530100573, 0.25880314574590924, 0.21419448552536624, 0.23799270347475765, 0.26621208295712684, 0.21044361173184234, 0.23059246778240716, 0.08559136758956587, 0.0852181179316398, 0.07019055807750696, 0.06705926036992915, 0.07919193886527742, 0.08203120749851167, 0.08949226858603487, 0.0757990321216293, 0.06781649772086662]}, "mutation_prompt": null}
{"id": "022bd7c7-113a-4905-8196-94e4861d079f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 12 * dim // 3)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.6, 1.2]\n        self.learning_rate = 0.1\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.06\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.4, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic learning rate and mutation strategies for optimal convergence in varied landscapes.", "configspace": "", "generation": 49, "fitness": 0.25113110913734404, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6276864527711379, 0.6344728410972755, 0.6564258478888392, 0.6434129978313532, 0.6702206115294072, 0.6555827122397535, 0.6745935285569045, 0.6681797026490465, 0.6550460996291503, 0.27510713186060154, 0.28540575018554415, 0.2702772983367506, 0.29331113573952394, 0.2342034051887213, 0.25313914973922425, 0.2995184386741565, 0.28275699954271327, 0.28503410481963776, 0.10553710177285414, 0.0834245989991732, 0.08821219318549722, 0.09823747442947783, 0.08538769302134464, 0.09553507345806955, 0.08731040493629882, 0.08444584981564107, 0.10170244530548334, 0.08407187115064718, 0.08236412664514647, 0.08317341013837742, 0.07730905458411852, 0.0713014054347827, 0.07642911437674427, 0.06727197606797819, 0.07685959846136592, 0.0801975391897859, 0.8819322566356318, 0.8471996298843747, 0.8691015111316418, 0.9211169817425605, 0.8970591360365081, 0.8588688670256331, 0.8954681762380614, 0.8995879980403302, 0.8625817772134736, 0.2837415445622854, 0.32573695692430615, 0.2839657905479961, 0.34584330418046094, 0.34571365839363866, 0.3036033286689188, 0.3362470003544933, 0.30539816820230226, 0.32579890098582776, 0.6246131558433241, 0.5868405925355993, 0.2181654862131106, 0.6128476952986613, 0.4894880666762723, 0.19144840153413567, 0.5291337366260729, 0.5162119164766843, 0.5501260103170365, 0.23179619206120816, 0.19505783487781714, 0.18919810307435636, 0.1979397223212389, 0.1535227303621428, 0.21344034914501642, 0.1755489683849628, 0.18733221991289073, 0.21329388097858404, 0.17002200086552877, 0.13631481514535448, 0.21754481762929123, 0.1826677893058034, 0.15864269181374036, 0.2075909813313036, 0.2016593211235751, 0.17552838632337442, 0.19173840378486828, 0.15187053471029466, 0.07601221726567187, 0.12989396399044906, 0.11687785855535326, 0.08088277042312475, 0.10422629101942116, 0.15276081125506957, 0.14326202553789447, 0.15534909905474326, 0.21850130340340967, 0.09619885187581023, 0.1664212405034714, 0.186287620371272, 0.07899334611107411, 0.2218982230298563, 0.16190353055318374, 0.2450656934324934, 0.12847786423165253, 0.035254186578169366, 0.013455975530750064, 0.00687894504264952, 0.05939943072400855, 0.034702106966265966, 0.028428298170793953, 0.033214648265160185, 0.021429339732103703, 0.036362543530634506, 0.14548385986958912, 0.16701483324028865, 0.14551681297555463, 0.16095794532145846, 0.1836011698808565, 0.16628417198814716, 0.18382429575685533, 0.1668933946383373, 0.17780315253105472, 0.45960291477617354, 0.4831564028416925, 0.4633817995331543, 0.4882889787538004, 0.47054896532001467, 0.48351168688185675, 0.4824446233899272, 0.4850708909752348, 0.4668506523465471, 0.07668171473902452, 0.08648063269994122, 0.08259647985380403, 0.07043694406192569, 0.07337923922016709, 0.07463867131893698, 0.07631141684112952, 0.07177806248845409, 0.08529537484305527, 0.1289439049334543, 0.12786038299779556, 0.14210807314153118, 0.1471154099116233, 0.1400632017884862, 0.16265163429694063, 0.16455108191364565, 0.12710470757720393, 0.29219786806052783, 0.2771008313614389, 0.29509383185674276, 0.265656813783687, 0.28031056022974354, 0.24589732025536237, 0.27115774272260773, 0.2901476717425353, 0.3587088273804864, 0.29842971216689673, 0.1760865214788555, 0.19049260635446885, 0.1805218853036955, 0.19863466968552246, 0.2231250267025945, 0.1679933344169392, 0.2252861420649056, 0.2099939010207973, 0.2253342589245373, 0.1878437303641486, 0.19612131757068485, 0.16978443167387358, 0.1809853950841953, 0.16409278349095036, 0.19518045334134226, 0.18676202146550847, 0.18900277370126684, 0.1766170660401154, 0.1739832930813907, 0.17956912789569301, 0.19795502909552576, 0.17511276541538223, 0.18447831851416985, 0.17794045587122187, 0.1669046146613946, 0.16771869359466018, 0.18581491983931908, 0.14421636355431855, 0.1753273624890881, 0.15002512226092857, 0.18044695470126504, 0.1750794181952433, 0.16381502814549165, 0.158107821175137, 0.5654152431808972, 0.6359540179212613, 0.5174563750465859, 0.20278445479339158, 0.14876476861340193, 0.16591132721116142, 0.6831679033004023, 0.5184039334641577, 0.20967229115030905, 0.20808336072808176, 0.148509912813375, 0.17512979940159223, 0.19383657949841993, 0.18778600620996544, 0.17467630049235594, 0.1979431734790572, 0.176832306186119, 0.18047088312109627, 0.17285598038925676, 0.18244831148773533, 0.06752732044491094, 0.06246023971493109, 0.07187325388755506, 0.061103936979495344, 0.07971979249803351, 0.06952941621686315, 0.06356812925442956, 0.0677463453963657, 0.07756682455508235]}, "mutation_prompt": null}
{"id": "a02bb39b-b344-489a-8e3e-85b1caf0b54f", "solution": "import numpy as np\n\nclass DynamicMemeticEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 12 * dim // 3)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.05\n        self.mutation_strategy = [0.5, 1.2]\n        self.learning_rate = 0.04\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.06\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.05, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "DynamicMemeticEvolutionaryAlgorithm", "description": "Dynamic Memetic Evolutionary Algorithm with Self-Adaptive Memetic Mutation and Hybrid Selection for Enhanced Diversity and Convergence.", "configspace": "", "generation": 50, "fitness": 0.26060413171048186, "feedback": "The algorithm DynamicMemeticEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7215151205519988, 0.6989993075414016, 0.7078860742118317, 0.6797085016283037, 0.7312104142854305, 0.7249964806059561, 0.7249109738202013, 0.7349806495857445, 0.7097131552211, 0.3603531385219686, 0.3623747431790276, 0.34495518130281955, 0.35523498281418975, 0.383550406635198, 0.3298241984333833, 0.3110899102963114, 0.35400617391269085, 0.3294504050150593, 0.09700569222837097, 0.1098447540765417, 0.11613835140224416, 0.09524879379596385, 0.11112328274457872, 0.0957997172870031, 0.09710221212326542, 0.1075250844481408, 0.11843887122110186, 0.10031218833187827, 0.0931965231691334, 0.10330563920442981, 0.09060463132734298, 0.09505317006949976, 0.10208194731890108, 0.12000545436120558, 0.08341531921034506, 0.10453486102546283, 0.9361227861761173, 0.9029492787512478, 0.9215780057136949, 0.9075815614943756, 0.9247162495061972, 0.8727204799279336, 0.8743387265390913, 0.8883065365382402, 0.8776082122379006, 0.3885589362020473, 0.35843013081003106, 0.35130076482605954, 0.3115425896237015, 0.3618716280258102, 0.35659760553122133, 0.37863923638913555, 0.34127006193908793, 0.36142890662269633, 0.5031641009773338, 0.5842723564095818, 0.6073780749244071, 0.6446514844689614, 0.6570251962123544, 0.5677198271729349, 0.5103154114988859, 0.5575176076686494, 0.5618045870501872, 0.18853169361346855, 0.18228727918455467, 0.15097566877535318, 0.21403285209020473, 0.15384956194303667, 0.10031790931102913, 0.17708994267693234, 0.2408018612488293, 0.1865713707756803, 0.09129991187657394, 0.11501581524976279, 0.17881723110398984, 0.19959864111656267, 0.1871284854416011, 0.16033516898479738, 0.1695989364892594, 0.08954506836996201, 0.18722419014497094, 0.09469117714988173, 0.10173908052318714, 0.12353008942066968, 0.11466416391192946, 0.12177208347899737, 0.08083436045165049, 0.13694586406337805, 0.09482299233653535, 0.03789081496982982, 0.16984713077247982, 0.05910519478095644, 0.12490158060138934, 0.14587919046431197, 0.1392716311921437, 0.09624460334755136, 0.24392492360511442, 0.12636968048574804, 0.15615162336634425, 0.027223478886571284, 0.003415324485430804, 0.020009333380976435, 0.04941325431305066, 0.058912298786580886, 0.017660960629391598, 0.09286257748482463, 0.0983577591218916, 0.00627469043420481, 0.1634391294536286, 0.16472419705721308, 0.1340381873340446, 0.17719102821328758, 0.1892650212295225, 0.14963233994521452, 0.1378682819011119, 0.1791137502300948, 0.1472743884993637, 0.48328972294243955, 0.5191169472454746, 0.4799838931977025, 0.4839007187419232, 0.46538469486273637, 0.4987279962467027, 0.49306425055107206, 0.5064902336979351, 0.48032828139615713, 0.08514089205177311, 0.0791139569132332, 0.07757974243205623, 0.09637384968682383, 0.07892751366390693, 0.08094429750866661, 0.07860329642801067, 0.08138971743360435, 0.07295876074113017, 0.1451767686832207, 0.13693716642727194, 0.14054754243954903, 0.1394060902256271, 0.1274392885335961, 0.15523686821557026, 0.18456278202069543, 0.12937088312327938, 0.1604634891813841, 0.29037608294697115, 0.31351149402088463, 0.2989823324828622, 0.29093075969389814, 0.305347664978007, 0.3092614286357538, 0.35607937054533334, 0.3383483472795835, 0.3270249107829474, 0.24759107860215512, 0.23401784326392483, 0.196725618164451, 0.24346701500260137, 0.2057594058981238, 0.20510660158192717, 0.24971610723864124, 0.22051204299549632, 0.23753359485245273, 0.21813949093838936, 0.17021028326313825, 0.16989504812056944, 0.19983993799180877, 0.18254758242730373, 0.17419492791762403, 0.20027250735306723, 0.17260187358589063, 0.17449352048805689, 0.1669158312522433, 0.17530679717506337, 0.17183809080915913, 0.17843917731698788, 0.17180322473052967, 0.17277112643269776, 0.17190482490000958, 0.18128865456115795, 0.18382452370850388, 0.18432612585598862, 0.18530676818027114, 0.14925509571929962, 0.6207547731786394, 0.1818932167390579, 0.17552236566914248, 0.16987704497473932, 0.17962021608469625, 0.1720263214120541, 0.1562932661303421, 0.20025308911433326, 0.47577393200641305, 0.5054664672235432, 0.12174720885116752, 0.2786146048841286, 0.20321402645456565, 0.1975423178869885, 0.496822835902495, 0.16924383210271787, 0.17301394169202178, 0.18722806800013225, 0.1676750434017531, 0.16784917698207358, 0.16450296746175286, 0.17445562187841568, 0.18891283962125194, 0.17025749888876196, 0.07640434221714854, 0.06475792786739931, 0.08450759735560442, 0.07204284059601362, 0.06085626459176108, 0.0659218369377077, 0.0765196989619562, 0.0637236254556317, 0.0680804538033768]}, "mutation_prompt": null}
{"id": "f56f315d-efcf-469e-add7-bb7d0da43da3", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "310100f5-44d5-4158-bcc5-853f17426de0", "solution": "import numpy as np\n\nclass SynergisticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 8 * dim // 3)\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.5, 0.7, 1.5]\n        self.learning_rate = 0.04\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.18\n        self.dynamic_mutation_factor = 0.06\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.25, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.02)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "SynergisticDifferentialEvolution", "description": "Synergistic Differential Evolution with adaptive crossover, mutation tuning, and dynamic population strategies for robust optimization.", "configspace": "", "generation": 52, "fitness": 0.23961691272159277, "feedback": "The algorithm SynergisticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.756192831329544, 0.680637580743494, 0.7050751933898305, 0.6229980256642451, 0.6848624075440468, 0.7178906214383116, 0.6873812861691828, 0.6590345566441242, 0.6690246249458116, 0.2701161487624685, 0.21383921042106635, 0.2650886557340252, 0.2539884390842937, 0.2701679582968777, 0.2798888009713991, 0.2495655394899985, 0.22878896001728977, 0.24190399827333509, 0.10848458398917193, 0.1350907640611596, 0.09973564973871163, 0.08869471477719237, 0.08960081913340179, 0.1044391533323964, 0.09438274160407745, 0.08488900403022304, 0.09762561390803515, 0.08866778273597431, 0.10079073958836704, 0.09039767958286515, 0.08401614775882094, 0.09793861494731848, 0.08760810507308348, 0.08138380903542897, 0.09048760412746926, 0.08896467328518953, 0.8797613352094584, 0.9244375697733468, 0.9433230470614863, 0.939299860502375, 0.9191251890678966, 0.9478047749408022, 0.9206542505754622, 0.9405336083694483, 0.9381498812456527, 0.3892698952188234, 0.34397714963516457, 0.45134903871827625, 0.43289244531095794, 0.42048900356048324, 0.35759289043185816, 0.2668406525566346, 0.42024001806076483, 0.2901766558562584, 0.3319291879948907, 0.31328105202664747, 0.23992693334684123, 0.38733370759096775, 0.307339235817104, 0.8422913263636271, 0.3096016078067855, 0.28895689144365955, 0.2813375491159831, 0.16935570360249474, 0.19151949467478402, 0.22043874099792715, 0.18189255715501573, 0.17345397373334348, 0.12032742783979045, 0.16762258718944467, 0.18615255083338256, 0.2177142781129513, 0.138531647109971, 0.102536410489531, 0.19053597168942094, 0.23212190750848138, 0.2240858223897202, 0.2306073324935186, 0.12669094415298332, 0.17594079515031202, 0.18892630808576216, 0.054111572318675805, 0.008519900334969854, 0.014218924889056184, 0.007411391549059232, 0.03763237208471315, 9.999999999998899e-05, 0.03172753945716211, 0.011161903251483474, 9.999999999998899e-05, 0.04702748860797934, 0.07540238783691533, 0.11526080739553912, 0.0359019146580114, 0.07319192155148335, 0.08082657328582721, 0.10186154502840095, 0.1546979651916729, 0.06965360808390375, 9.999999999998899e-05, 0.01307929746609826, 0.04922780992000264, 9.999999999998899e-05, 0.007851594885127766, 9.999999999998899e-05, 0.04739798435179232, 0.031959430758804364, 0.0031237639629360103, 0.12261046965776745, 0.13309279537695784, 0.1375897898713272, 0.14940163152792063, 0.14953493033009435, 0.1250518080757007, 0.1336081826036012, 0.14587508135044824, 0.13163476934673612, 0.41044666928523676, 0.41674528609396333, 0.5037419246904052, 0.5164264919173749, 0.4633671186068793, 0.4478754154897997, 0.4057556379978069, 0.47700932389478756, 0.4469589712377414, 0.08006376798511483, 0.0895173431820171, 0.07841353853384103, 0.08710288250018472, 0.0862391929985159, 0.07478367752784598, 0.0804744280751053, 0.089655821090175, 0.08300038500225615, 0.19592343968689374, 0.14153538685589118, 0.20718148991353547, 0.18654909651951668, 0.17404005514333054, 0.15013720526326124, 0.19931471017377467, 0.16207757561956537, 0.17234423506961505, 0.33697965840972666, 0.2621426856601863, 0.29171337027709787, 0.2790607383361633, 0.26173908526468337, 0.24764708812860292, 0.26461752054957355, 0.3786332810378532, 0.32623816662817773, 0.19683334383451434, 0.1838364351246774, 0.19713867446304612, 0.21225879835492878, 0.23206165926148847, 0.1844485816435688, 0.1945414911357689, 0.197496366256938, 0.21957475435309448, 0.1720401598756185, 0.16399295538701386, 0.18713366300003376, 0.1813366852287871, 0.19252612166367766, 0.17551727382217197, 0.21409451279317415, 0.20262559308595074, 0.16901224419846728, 0.18482731361384808, 0.17773882537924512, 0.17928943391522478, 0.16968966725002488, 0.17461987316816885, 0.19055671789792272, 0.17991508773133902, 0.20032063324681926, 0.17364962786667804, 0.145189791731683, 0.16313202199793686, 0.1483730763536405, 0.1422248971899942, 0.7056082314631689, 0.1887949839940346, 0.18369951348124702, 0.1708945845642451, 0.15947107657544535, 0.45453077224508265, 0.1661681251240692, 0.1607987915674337, 0.1571276608446659, 0.5142524760678219, 0.2002618669933136, 0.5631417372533718, 0.20769273554903922, 0.1543242391445261, 0.17550296657940723, 0.1617310654728057, 0.1688372342756993, 0.18037135383069547, 0.1885357311187842, 0.17117605102818212, 0.18693629757038543, 0.1889675084236584, 0.16418444635124307, 0.07188045013327193, 0.07088846637661139, 0.07648133766029841, 0.07758257002791269, 0.07154516623425822, 0.08797639026639137, 0.06618599391300706, 0.07576614292403006, 0.06832882988909295]}, "mutation_prompt": null}
{"id": "01d82712-8f49-4aee-9ea0-5970726b7172", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.2\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + dynamic_mutation * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic parameter adjustment for enhanced convergence and diversity exploration.", "configspace": "", "generation": 53, "fitness": 0.2603696936705824, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6982581233519916, 0.7118299778122794, 0.7005474063082543, 0.6968195259840034, 0.7107164358196881, 0.6943321099401906, 0.680145147781885, 0.7267735259138048, 0.6780905324660939, 0.30860279301155247, 0.34494900295813435, 0.330329640096946, 0.3438135427908048, 0.3350719330749853, 0.3278168164443447, 0.327846696389937, 0.362630795539032, 0.32653888017139465, 0.09667614286868176, 0.1021591531374697, 0.10792913242107205, 0.08577192570882142, 0.09295576217605905, 0.10230813313212206, 0.09072647705977055, 0.09296926517894732, 0.08840477158522153, 0.0985271590484561, 0.09323893795015681, 0.07138534106525507, 0.0836373010313115, 0.09011929111525974, 0.08220969059821959, 0.08864010798528577, 0.09862564936824658, 0.08470318443953728, 0.8390183374798065, 0.8730105265493666, 0.8981006470319693, 0.8590385443822557, 0.8902277327543571, 0.8932957011145308, 0.866691451985417, 0.871518773738068, 0.8903038945393695, 0.29436962036383096, 0.31183534620050424, 0.2935179888222026, 0.3081350661746721, 0.3227169323204806, 0.32298187015992186, 0.28641488813018456, 0.2943393719673665, 0.30270624253272627, 0.5122598537569433, 0.5618903169545122, 0.43784063422924635, 0.5872163478928691, 0.5743048297474729, 0.5736880289761737, 0.6197784543456698, 0.49480947241371476, 0.38049554799510144, 0.21602941900132022, 0.17709209582181706, 0.16572078701107584, 0.17032145730401194, 0.15383940357621229, 0.1570515628171807, 0.15499809483758653, 0.18470226069713758, 0.17594641083314322, 0.16554291697768053, 0.08130826400384028, 0.17055189609286903, 0.19850952665267807, 0.1954699542372006, 0.14328537784196438, 0.16999347468071224, 0.20400884895591542, 0.16935878968268936, 0.09467631363325946, 0.06821120035293082, 0.06428860303388684, 0.07947900011704445, 0.1125126249667111, 0.08617520910667387, 0.09068695822798578, 0.07975550553096078, 0.09604909080930324, 0.19209247530598905, 0.18662962889587376, 0.21208035757820176, 0.2175471978080673, 0.18794634097620233, 0.18332885626828, 0.23030667481517286, 0.21869530257388692, 0.21678590842552425, 0.014883269249919562, 0.05971634567957296, 0.028904083163307392, 0.0507535897856064, 0.02150505539983738, 0.06231361019495818, 0.010923583773690959, 0.026902860081938873, 0.06419421428937055, 0.15840538971054452, 0.1468493062030941, 0.14601387244331254, 0.16545684696631813, 0.15752027510177946, 0.1413426982556052, 0.13925123111227877, 0.1299112008307728, 0.16512162766072103, 0.4674187930203192, 0.472816687158539, 0.48848592629955456, 0.4707110707383406, 0.48119425784786185, 0.47906563333901797, 0.48472299198022606, 0.4817103972964132, 0.4798194712401429, 0.09683030306117013, 0.08227293242981681, 0.08972835556217618, 0.08687393635224794, 0.08531858560544059, 0.09523730986784396, 0.07543976549764397, 0.08572910883310558, 0.07534799641828616, 0.1184968396085897, 0.14068136203926584, 0.1374670891501093, 0.17465232819789345, 0.125436082866061, 0.14273509225401215, 0.16199357674113513, 0.1359349885878408, 0.14260660415421478, 0.29004562326030414, 0.27843059815318016, 0.24835251613218157, 0.30037894541011634, 0.2602398791957726, 0.2862751705114963, 0.3337710970777753, 0.29630079576330237, 0.3021049407357568, 0.21222656036165533, 0.1770504187853661, 0.20901668868073764, 0.19709490262933949, 0.19290490969116714, 0.1855646319995431, 0.24420729072373748, 0.2191357759753333, 0.20502159452735869, 0.18290581897109282, 0.18989838216625454, 0.18098021392600327, 0.18881844719317875, 0.17124436291211675, 0.18267295171014386, 0.19253606109728705, 0.17358736787031903, 0.18493704307590852, 0.17471088042125593, 0.18763724250153502, 0.17811499860039748, 0.1831759084415815, 0.16651737024905355, 0.17165881500657465, 0.18047016062522925, 0.17199260204721212, 0.18878363369455875, 0.5386427859369964, 0.5819823699564238, 0.15984561926272178, 0.5867515653135967, 0.16977670554563595, 0.26525916877375744, 0.628210997043265, 0.4475072665566361, 0.15717544139228867, 0.6263395817267254, 0.1959586169241957, 0.19368923386788006, 0.4597266423747156, 0.32871656233413415, 0.24494427480188874, 0.20441171756105458, 0.14969620280707951, 0.20525291811054336, 0.17456467753024862, 0.17079170321716042, 0.1914637531369362, 0.20884968190892095, 0.21386843078059004, 0.19950699490897073, 0.1851736204089719, 0.19441658827015174, 0.17275599003977893, 0.06506855837252623, 0.08489676884547703, 0.08109459263778374, 0.06845492429299194, 0.08375687978208757, 0.07094741132340188, 0.0676242235663278, 0.06841098848929084, 0.069274705135968]}, "mutation_prompt": null}
{"id": "342b11ef-d917-415f-8e57-0921fc8464b5", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "31da4f94-afac-48a3-8229-33e1258f794c", "solution": "import numpy as np\n\nclass LayeredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0, 1.5]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.3\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "LayeredDifferentialEvolution", "description": "Layered Differential Evolution with multi-tier adaptive mechanisms for enhanced diversity and convergence speed.", "configspace": "", "generation": 55, "fitness": 0.2949552587740092, "feedback": "The algorithm LayeredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7144085640555478, 0.7025749480155249, 0.7317054626638997, 0.6942346223390768, 0.7388243907896772, 0.7228672356922287, 0.7135039529314067, 0.7170871534487782, 0.7201557922736769, 0.3719855720753923, 0.32822453299282683, 0.4075569579745093, 0.35567401355392514, 0.3321174624674662, 0.3372248538417628, 0.33931921790854536, 0.31507139391367955, 0.3423099017787592, 0.09392474613085633, 0.09401363859241973, 0.08692281227043552, 0.09274460657181849, 0.08670543167923239, 0.09346955865459039, 0.07435586903927593, 0.09545827694781839, 0.09026396776747969, 0.07483894611259312, 0.07688548824468922, 0.0789077395300416, 0.08799072861010482, 0.07888500192849701, 0.06713947198414338, 0.09433832302065581, 0.086657081990826, 0.08249131074967264, 0.9136075552195909, 0.8857942491155767, 0.9247768404184965, 0.9112946196264591, 0.9500020853035489, 0.9175270213433488, 0.9118857310137434, 0.938763330258674, 0.9003015888967774, 0.3737569842463814, 0.39015957991320827, 0.32521968933208856, 0.3627681006358938, 0.3363241590518806, 0.33958818090800846, 0.16879807092265786, 0.3537181782983435, 0.392685266678786, 0.7576138716925509, 0.6668407058530312, 0.6823859504220315, 0.7178073137352197, 0.7115966140260146, 0.678237634848392, 0.7134414079609797, 0.6874421426207442, 0.5915529867125675, 0.2357444141546593, 0.18388915734256328, 0.18900456661541742, 0.22721439890619, 0.2313833541881558, 0.3833424017662044, 0.2603396542304054, 0.3187477095821599, 0.25660440947803587, 0.11102188045348971, 0.28612132280271374, 0.1654819307750286, 0.2849327765753592, 0.2615370171910164, 0.28936220459876805, 0.23140038181047784, 0.1106876320417981, 0.18851576977683637, 0.23069752727709159, 0.2743256885859585, 0.26368562381081107, 0.15198669464244663, 0.16408905557403508, 0.28756709650183765, 0.21435298713019313, 0.1604676214675701, 0.21619635767247825, 0.31233139678886623, 0.27695004589813965, 0.3351938327859053, 0.25701212609006807, 0.2323022121310624, 0.28880312437175404, 0.3384681496227364, 0.33211093703160954, 0.30479059625669824, 0.07077796964479055, 0.11818487400609479, 0.14848357315088978, 0.13412770276722807, 0.10775952517916898, 0.17819663705165856, 0.10834868138275378, 0.08800251388643698, 0.06042095019616389, 0.22175563065777393, 0.2153130888449455, 0.2205964586634458, 0.22049609761320266, 0.20017745210434712, 0.23996922939477605, 0.1880708236791072, 0.20103418858641475, 0.2290315443591754, 0.5278567326773418, 0.5363168848006794, 0.5170074757095678, 0.5080683540556209, 0.546113579544397, 0.5040792513073244, 0.5255617808947542, 0.5466124884276977, 0.5028055807266401, 0.0911197882210214, 0.08956639344989181, 0.07695209223583355, 0.07266594676854998, 0.09906314310899356, 0.07669732198736234, 0.09205492602018328, 0.07190492401987214, 0.1271665191194743, 0.1426391276299579, 0.14680139842207696, 0.16724985149284988, 0.14991479303942268, 0.14802842985458609, 0.14818982674083103, 0.13103898818545645, 0.18422810329859918, 0.12233939654618242, 0.320032530147346, 0.36254154121062476, 0.3094546858302165, 0.31495874717214234, 0.31852295853559986, 0.3631864711997982, 0.3351761390802318, 0.37466228303810134, 0.32742467219393623, 0.255304081542053, 0.2800570446762163, 0.25447852603442045, 0.25149608577949356, 0.22743353418870704, 0.24766652305190073, 0.2912096470165235, 0.2546683291969014, 0.2590368367247793, 0.16996396959285853, 0.17650692791573186, 0.19667180011900876, 0.1882689604876927, 0.17222274176459484, 0.17358935491557226, 0.18400999344766178, 0.18989388731801182, 0.1788712691072556, 0.18034578049380157, 0.16398173520600035, 0.17449786476636875, 0.16856229586937332, 0.1730966998965754, 0.16661472181757542, 0.16924104015902486, 0.1888113920279939, 0.17383251167669023, 0.18701027545697402, 0.4907364665025581, 0.7847819067413709, 0.18046675165813886, 0.7490431080489162, 0.14113893296317293, 0.17768335320831774, 0.16837682941274856, 0.19211948748493457, 0.15807173264402463, 0.16666425716923472, 0.1617065663566002, 0.6249474911947688, 0.1609612764666707, 0.16314421644826183, 0.2075641616197268, 0.15160560120236133, 0.6209818468682049, 0.17389700082448656, 0.1900567765303096, 0.20847841844145265, 0.2291117052283883, 0.17092707017326758, 0.2070491427938831, 0.16068678243151102, 0.23101567704631087, 0.20814810082977642, 0.07724149882549192, 0.07219833577387091, 0.06843985806770525, 0.07124271287730066, 0.0682366166496371, 0.06375102135701649, 0.06937072672400901, 0.06521319776157686, 0.0677924252233073]}, "mutation_prompt": null}
{"id": "29f50284-e465-4e10-8acc-f9a6a548442e", "solution": "import numpy as np\n\nclass DynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.6, 1.2]\n        self.learning_rate = 0.07\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.3\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "DynamicAdaptiveDifferentialEvolution", "description": "Dynamic Adaptive Differential Evolution with Environmentally-Inspired Local Search.", "configspace": "", "generation": 56, "fitness": 0.22165647493294763, "feedback": "The algorithm DynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.19.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6106090439391043, 0.6164542637894104, 0.6230574211889219, 0.6131204344857031, 0.582786730306061, 0.6223626254961578, 0.614152216006137, 0.621050699294012, 0.6070933507925862, 0.2886051920524203, 0.27466814909405857, 0.30116835375251494, 0.2794798402729698, 0.2780544247201169, 0.26952750820507687, 0.2622903293782278, 0.305693130161927, 0.29475694115249207, 0.07147220218584338, 0.10716223046949236, 0.09929224870127096, 0.11055136141208766, 0.0986788179375453, 0.10185044472168137, 0.0903478439477503, 0.08844601171566158, 0.09525018348688796, 0.08867558076909832, 0.08064849679007347, 0.06260407241122734, 0.08132335934414059, 0.07745007775476864, 0.08419629765570757, 0.0875273397247407, 0.10329595821189264, 0.09868340822140709, 0.9240183551775742, 0.8654646153112748, 0.8785773316487535, 0.8719277359087384, 0.8895299603599369, 0.8910517101771235, 0.8625660542651608, 0.9374131292638934, 0.8063717818623163, 0.23839635483911348, 0.22098535972254285, 0.25000116681389606, 0.22392717701463416, 0.25458753911036824, 0.244852507518599, 0.2308428268489916, 0.26532349948778733, 0.23867267257182423, 0.3699015030927588, 0.37061143288746456, 0.2643229593786378, 0.47725623910193726, 0.31150839548794607, 0.4445268724046286, 0.34770862045667017, 0.37329259263331516, 0.391348903417429, 0.1400833631583719, 0.12383332888247733, 0.15995932805918078, 0.13840217627057738, 0.14013502443797565, 0.14946110946180602, 0.1551709324128573, 0.17069869678609972, 0.16483800002303728, 0.11681610509067919, 0.13729057094969288, 0.1918436549279079, 0.134990158375918, 0.14418333323672194, 0.14831103173153481, 0.13820461772439052, 0.12322595593722596, 0.1495545039380095, 0.07780835790989382, 0.03437661833489891, 0.07335819763711626, 0.020219247580267052, 0.03167305465713366, 0.030453537259026997, 0.026399031154755725, 0.04653201797672113, 0.04605637648382033, 0.16491844836594405, 0.08867144779639458, 0.07441312227362318, 0.01467858078949813, 0.13512046368303032, 0.11588432823061035, 0.1484182742273077, 0.16404149015427194, 0.1586294799378002, 0.009599569599326063, 0.016483989687184786, 0.003267703011569756, 9.999999999998899e-05, 0.0036430215185824233, 0.005588712805213114, 0.028336408875712538, 0.02901261946121525, 9.999999999998899e-05, 0.11330107390697941, 0.09543326315767864, 0.11136340532097944, 0.11242096485741782, 0.11324278196100657, 0.12243158985363878, 0.0995129684519459, 0.12313275411441682, 0.10423190997200804, 0.4331308066100269, 0.4330793270727108, 0.4701394288477396, 0.44813284127846487, 0.4362232880196806, 0.448332490901317, 0.4138968341551589, 0.4115035286587623, 0.44064641041229446, 0.08505740126413674, 0.07440824770960974, 0.07961625606776346, 0.08632232775791648, 0.0804892487706298, 0.07412760102482063, 0.0662084208710072, 0.07622780948116548, 0.07091455933772706, 0.12385842345408093, 0.13891316668511222, 0.11867905538931789, 0.1335363683166475, 0.16684939625290185, 0.1424789948030084, 0.13432341253067537, 0.13449226235134115, 0.12085360744971585, 0.2662597185930383, 0.26304881923467005, 0.24577069889698844, 0.2528382644360089, 0.22923555037249566, 0.26400769258112444, 0.27740174539747864, 0.2658670025490757, 0.2852316607696239, 0.17223868886875093, 0.18704542181774764, 0.16845408814442164, 0.16397653987104166, 0.15066848486408557, 0.1737988607436326, 0.19096659475865585, 0.20918264091541505, 0.181966428325824, 0.16330156054318323, 0.18258385738630667, 0.20198072927180455, 0.18163016787344388, 0.1829007539321854, 0.1622930169654241, 0.18352287975265924, 0.16622978173294978, 0.17924905560784554, 0.1628891259818538, 0.1780170559787777, 0.16284899393493124, 0.1944328638597418, 0.1726818433575823, 0.16336690735759296, 0.16533368884302013, 0.15929178790222465, 0.17269871488698485, 0.19070486525353503, 0.2508391555757167, 0.267827411520433, 0.23670755597859383, 0.3474271781137088, 0.2816383287981492, 0.17353738712236577, 0.1432770705017642, 0.21891317757723583, 0.19080681850921677, 0.2628885613918407, 0.3139058025822544, 0.21043098134238314, 0.24239528497715213, 0.18422400212773682, 0.20179460477747202, 0.4953338659771295, 0.19904187975003407, 0.17798094690222677, 0.18862666568719422, 0.2031859047448904, 0.18291649492508355, 0.17719006117122482, 0.17050144859109828, 0.18690459406898474, 0.17687016472568373, 0.17559625328516382, 0.07063250867316584, 0.057673541001660666, 0.07207293621588828, 0.06816044284351575, 0.0674065785234339, 0.062427054647760105, 0.06234713793645985, 0.06769854931555597, 0.06502957987470637]}, "mutation_prompt": null}
{"id": "b64fc1d9-c29c-4978-a893-a71b56ae1305", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Learning and Mutation Control improves optimization by adjusting strategies based on population progress.", "configspace": "", "generation": 57, "fitness": 0.34140736310572783, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "f741e2c0-79ca-4bd0-8c76-d9605562824f", "solution": "import numpy as np\n\nclass AdaptiveDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.6, 1.2]\n        self.learning_rate = 0.07\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.4, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.8, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDynamicDifferentialEvolution", "description": "Adaptive Dynamic Differential Evolution utilizing dual mutation strategies and learning rate modulation for enhanced convergence.", "configspace": "", "generation": 58, "fitness": 0.25949991083583523, "feedback": "The algorithm AdaptiveDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6823134569789578, 0.7096507523873058, 0.7019479312445154, 0.7268469632901009, 0.7368091329517563, 0.6911379923655376, 0.7214115237992325, 0.7056336916668803, 0.7043261248771484, 0.2818414693010908, 0.33155259282741867, 0.38324147747699533, 0.30002073868839985, 0.2997587793978119, 0.29541600471022544, 0.3357901306350477, 0.28663034577127633, 0.31569628512685244, 0.08141680326906642, 0.0906635893389548, 0.08329091505836805, 0.0925661368548446, 0.09351870365771375, 0.0846704203702573, 0.09976853517408069, 0.11414902128795934, 0.08866151082497942, 0.0932614663039969, 0.09306802300844286, 0.0712988436037133, 0.08708052059814486, 0.09259133235070915, 0.0742477455449787, 0.08394193391892235, 0.0844540524836841, 0.10732065953934522, 0.9055759886457306, 0.9073773089730186, 0.9199595950357555, 0.9348898198826133, 0.9455945230854562, 0.9268373024828472, 0.9364334710085767, 0.9133171617373445, 0.9022558721023172, 0.3777528362308622, 0.3929640649328632, 0.3575710008843376, 0.38214720465210084, 0.4591112559260929, 0.42297917672951224, 0.36304644670523556, 0.3752019958841416, 0.4118247855413911, 0.4619813804954449, 0.24070983997240536, 0.6494895982434037, 0.5597097154895059, 0.6665272480707722, 0.6440786484448671, 0.6775924756595438, 0.5070991886828438, 0.69145079209865, 0.2521788048328112, 0.1921048446632423, 0.26475129737480074, 0.1556525016879292, 0.13007373686783252, 0.15652235876330634, 0.2317278896583974, 0.18631575409803636, 0.1890135616185179, 0.1803092919246918, 0.10164221211824698, 0.17985652003720565, 0.22153223076580408, 0.18785821031552596, 0.21618127526749797, 0.21822740700787968, 0.24046631464752266, 0.21652902005101127, 0.05333881367879856, 0.08802897488193517, 0.06156428178808093, 0.03529169593325454, 0.07838743952432903, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10084570545845528, 0.09083804778918836, 0.13454309026225164, 0.08256788807501525, 0.09526928670876389, 0.06228720724381309, 0.09342561161524698, 0.16316232961407473, 0.1019578548434853, 0.18821836305431783, 0.007324239602379379, 9.999999999998899e-05, 0.03878623099686096, 0.02557485617143007, 9.999999999998899e-05, 9.999999999998899e-05, 0.030606955243922096, 0.0038507201026579674, 0.07424808398261118, 0.15623765015303615, 0.1486286470461664, 0.1484618310795709, 0.16283219521838588, 0.1666906416590478, 0.16145117193707137, 0.18057466227393182, 0.16176650891943534, 0.1518301246117284, 0.4716125686950957, 0.5406269886756083, 0.41774799381453853, 0.4667470730922736, 0.45769536112517795, 0.47483776628819285, 0.450405227471373, 0.4786253151176819, 0.487940095836649, 0.08995989692322115, 0.09525951872100735, 0.06147819378662023, 0.07536078099606625, 0.07877364451011215, 0.08648929248436832, 0.07626437490771354, 0.08514056422289085, 0.07249361110165176, 0.12142760078586179, 0.14109014340842618, 0.1707158993735629, 0.1223763109639514, 0.13476549556767203, 0.13335483577759333, 0.1582650010142792, 0.11326827327917277, 0.14363006594547645, 0.31333012339610167, 0.30442108268270074, 0.2923770668476664, 0.23766347977258762, 0.3231045242999848, 0.3121754636783044, 0.2804785189272312, 0.34771827778994846, 0.3503036744218291, 0.19190610987537482, 0.1789601330941507, 0.18967145663966944, 0.16663637047101998, 0.20793030236707222, 0.1734934558982575, 0.2026613383210658, 0.2793008584319493, 0.21377863747582437, 0.1848174160495949, 0.2117243747905616, 0.18414472751461086, 0.17618582779094705, 0.17164908599846662, 0.18341621026991883, 0.169008685650181, 0.1714834148254244, 0.16052752614158106, 0.1703552474263741, 0.16818497848472092, 0.21951230388363097, 0.17143930216804815, 0.1687503010889928, 0.1776398293189121, 0.17336763125730925, 0.17705958719399584, 0.15988711603955708, 0.6715328103723248, 0.5176959877107328, 0.15662392972763295, 0.17058003951551293, 0.305980646924635, 0.16411222598060815, 0.18393340027069816, 0.17262068355254723, 0.15251667690014803, 0.19165955331041296, 0.20077409259766377, 0.5713608307031806, 0.5826738311595375, 0.4839728729777282, 0.4040109948204591, 0.20097440566003033, 0.199879908007905, 0.1938958675495701, 0.182619755812246, 0.1680019635747414, 0.1908624085846714, 0.17107778277474495, 0.16671833395612956, 0.17383936511813514, 0.1955209844929071, 0.1635144944999165, 0.18975007704398927, 0.06443610112160636, 0.06632848214163312, 0.06708553050356114, 0.0707953410320199, 0.07288305421650954, 0.06377375144807573, 0.08096159587697949, 0.07299277776259527, 0.06499520321696295]}, "mutation_prompt": null}
{"id": "c1418fda-75f8-48bc-b473-1dad919d5ba7", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 12 * dim // 3)\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.4, 1.2]\n        self.learning_rate = 0.04\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.3\n        self.dynamic_mutation_factor = 0.06\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Gaussian Perturbation and Dynamic Adjustment for Enhanced Convergence.", "configspace": "", "generation": 59, "fitness": 0.2792408520417879, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7264092538448116, 0.6964794589314871, 0.7299815585419429, 0.722684647064179, 0.7613517688525924, 0.7253828879961646, 0.7126279770631129, 0.7341209364244037, 0.685631859466005, 0.3604071565224898, 0.31712011164776155, 0.32248115693369206, 0.3406128452729206, 0.3428812640891792, 0.3412862860477819, 0.34981712281242694, 0.33498668486145877, 0.3297192113788109, 0.09575281038451611, 0.10413319501986329, 0.1029175590941801, 0.0933555022924929, 0.1047799799516046, 0.11551525355735992, 0.09813253101036845, 0.10738080886869483, 0.09780548098869735, 0.11444328951618643, 0.07295480258087739, 0.08403987155831205, 0.09785052411355466, 0.1122267708369098, 0.08554381426340041, 0.10592739621574687, 0.1271283598486077, 0.09556557393921083, 0.876357552911056, 0.9177073799878327, 0.9097978933461239, 0.8833696712087473, 0.9212738591490158, 0.8954616625710554, 0.843943792900655, 0.9193617741491109, 0.8838823910168984, 0.3286742653927428, 0.3659719724428384, 0.3823532790166069, 0.2918968773377204, 0.30554619891589974, 0.37252789050837565, 0.3609643750313738, 0.39726948551934904, 0.27444403825310215, 0.5983494283393036, 0.6482360102225746, 0.6948457531690768, 0.7346213353188775, 0.6890161624777675, 0.5488756204270809, 0.7194020323382243, 0.6387589008159684, 0.6237998295905314, 0.22156629278020978, 0.1606413926701834, 0.2822662454309157, 0.1163863275082323, 0.21073083357239653, 0.10921356927058112, 0.1627209733386923, 0.16651786662751733, 0.189098364300187, 0.07346187536541005, 0.09785794256433678, 0.12634810350528647, 0.20505537763246606, 0.18766381538028853, 0.19218732312371023, 0.11777788873198825, 0.22287679882373168, 0.16998520050204347, 0.12443011282488803, 0.10372979251426673, 0.11398951876516039, 0.18210509098853744, 0.08243677359019674, 0.06844950592245092, 0.12127507834617735, 0.14402185879087337, 0.10102214151872357, 0.24768352563775486, 0.13914444888394284, 0.11637243951966647, 0.1871754103926766, 0.13170159913893187, 0.14583681767552226, 0.2561514919142863, 0.22444188419982247, 0.2686658663162317, 0.049321427972636056, 0.0914734671701346, 0.05391331005910416, 0.08297264013268191, 0.07128366482578352, 0.05886370024059884, 0.113486089940804, 0.059163306798408866, 0.09535624427535627, 0.15835666541537807, 0.1784906158560169, 0.17128797037841303, 0.19796451967115503, 0.1977819650294116, 0.17763158093317855, 0.1798493457293483, 0.18532204805683428, 0.1501025828256577, 0.4789029908669148, 0.4896770011872229, 0.5300992389678059, 0.49599904007405626, 0.5091091502225373, 0.4954692053201595, 0.5255873716286694, 0.5048656607004678, 0.5275739619423623, 0.09034964258240075, 0.09875980525063188, 0.08227473056674206, 0.09292827353367816, 0.08021208166331817, 0.09430166606249146, 0.07863333966862052, 0.0813388006940926, 0.07549284000289114, 0.12505806316606793, 0.14327031590115025, 0.15826917069253255, 0.1332675422622025, 0.1393658082657081, 0.1485174068711873, 0.15738575843076452, 0.2149999380227544, 0.14913614218570892, 0.3188111256045182, 0.3465370596447671, 0.35455856016935905, 0.298290354479425, 0.3608944108034461, 0.3593437632833084, 0.3490827803010915, 0.37998303313859216, 0.36451610403537726, 0.26533775656850367, 0.24838558838052827, 0.18458793678900332, 0.2572700747836194, 0.28279275381647184, 0.24149344903326897, 0.2767294099332882, 0.2828051283659492, 0.26383727482768815, 0.1834063975646547, 0.20935011567435524, 0.201354213763134, 0.2151129304360766, 0.21503904661053375, 0.20238949236393367, 0.17626194810525797, 0.18827784973385797, 0.19045134280139708, 0.181078807951919, 0.17505810946292644, 0.16886456534986827, 0.18140914867688906, 0.1899120707146501, 0.17259284142529907, 0.1684513342986449, 0.18922100147686371, 0.17055160250581125, 0.1478285241576044, 0.5313917917865283, 0.16695101002507895, 0.7482505688779606, 0.17675066945732065, 0.1782538340289015, 0.6907526772515596, 0.7218313268245591, 0.1923525793532318, 0.11154624677810077, 0.20210438034654676, 0.6175958464016478, 0.641894948047526, 0.19440229699048306, 0.18236223067531743, 0.2083617424078088, 0.20242814967307066, 0.20578989436211315, 0.2063539382215862, 0.16629054846985358, 0.18159831088346623, 0.17173572584382746, 0.18358433671211527, 0.18335256670934852, 0.19527360626229406, 0.1824213210637068, 0.16901088103294915, 0.07049118316062308, 0.06483305415202745, 0.067693416363106, 0.0712143675576814, 0.07955621020362436, 0.07015021646122932, 0.06935215488372082, 0.06390695932961499, 0.06371635913373286]}, "mutation_prompt": null}
{"id": "a62ede9f-5556-43d5-bfe1-4d43930acdfe", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 12 * dim // 3)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.2\n        self.mutation_strategy = [0.6, 1.2]\n        self.learning_rate = 0.08\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.15\n        self.dynamic_mutation_factor = 0.03\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.05, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.02)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic learning and selection pressure adjustment for enhanced performance.", "configspace": "", "generation": 60, "fitness": 0.25465708377200563, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.629408101265248, 0.6390507400679997, 0.6401680034381338, 0.652758466025172, 0.6726641135733908, 0.6243637430961434, 0.6332690143864821, 0.6341629706272813, 0.63214672415391, 0.2819324742783482, 0.2741768055075787, 0.2633964953107448, 0.23366451617480966, 0.27276550976472513, 0.25096890918607595, 0.2692584852654156, 0.2985705223349243, 0.27308272631083985, 0.09543478546758488, 0.11238623311180707, 0.09919344865338608, 0.08451696966174516, 0.11826741591049483, 0.09449038487861794, 0.13803770595821718, 0.10651697877833122, 0.11486746199140085, 0.09101452162112766, 0.08028737023210475, 0.07626561373761287, 0.07919599013633705, 0.08862258536477874, 0.08037440775935834, 0.08250267344115714, 0.07988393968355667, 0.07473903218612954, 0.8905455141055649, 0.8256465811816236, 0.863202016711518, 0.8681252982935354, 0.8910934291114287, 0.8699194093787566, 0.8938252648623678, 0.9151673630633673, 0.8675922731394476, 0.31137887198883607, 0.3369697973934458, 0.2889646244301832, 0.3409703810810465, 0.29620167590997515, 0.33956835970236665, 0.24298276445442202, 0.3133561943800417, 0.3128193694971121, 0.6841994443224338, 0.5527433722161734, 0.6096773868198371, 0.5634966627406668, 0.5177809606159489, 0.5020194308467676, 0.547018361341759, 0.5282897120362837, 0.5388997875113144, 0.17603927864708235, 0.17942814680945374, 0.15984323696700575, 0.16974082362989829, 0.14989265128266327, 0.2573065094621062, 0.18632687077989107, 0.17741821313782968, 0.2357485723509949, 0.1076863010243303, 0.12485717728013968, 0.1685158444121071, 0.13038819430395177, 0.21464052870192862, 0.2024811819321839, 0.16533732376157173, 0.16336230722704126, 0.26008719306828976, 0.11578704066548884, 0.12039110879971215, 0.12937680806238094, 0.14106164873746851, 0.1420811516595193, 0.1342484200486591, 0.14303576783470984, 0.14420053084597106, 0.16526958413847426, 0.19440819864979308, 0.23841468917318132, 0.19554029080446544, 0.1804281537673207, 0.15405923425090673, 0.16495037175583926, 0.2354077457349255, 0.24428089884042115, 0.23095276975969736, 0.041116800640556006, 0.03802923007841841, 0.04025348298222853, 0.08696373805361013, 0.09310758060955704, 0.03925292230498656, 0.08133778751454579, 0.02515492390160512, 0.009916645784339928, 0.1491038878528128, 0.14627999111803236, 0.18409676584067636, 0.14482516132619117, 0.18432149267754483, 0.16960929938163916, 0.1711567818362708, 0.15132828369463203, 0.16270369305200316, 0.44722990918610617, 0.4755740414963986, 0.47435737996019245, 0.49389215197008796, 0.458407930608995, 0.4474303273144927, 0.44949452979201576, 0.48033979295292106, 0.4713087759220521, 0.10081812115805389, 0.08149808069165443, 0.08754392350197504, 0.07414148750808491, 0.07350020222306941, 0.0970247725956358, 0.07820237617683257, 0.07774729562662741, 0.07047135894842127, 0.1551336664675207, 0.2587416269614218, 0.21460555688336036, 0.14820756219764375, 0.13645287839846298, 0.1902235079911484, 0.15374970025450052, 0.15667868320279976, 0.1584859532082994, 0.3048859754312868, 0.2823663970861672, 0.28150481976644937, 0.3036840713373914, 0.27519694396474614, 0.28707785709637546, 0.2956573305370406, 0.33198020727148536, 0.3058244906255816, 0.2241052789873368, 0.19699535290493408, 0.21310336793969875, 0.19972019636210614, 0.21255180647662864, 0.2249575012691789, 0.2320722302346825, 0.21951302265425432, 0.2388004874573888, 0.17480100313846691, 0.17527263557290096, 0.16335869901073818, 0.17895967235160848, 0.18410131741559854, 0.19887909541260995, 0.17058762090234636, 0.1793486083606527, 0.1910490832573457, 0.17733923739535962, 0.16857154117516326, 0.1855969378494713, 0.1707648316148509, 0.16707089347879378, 0.1712160251349536, 0.17007805205932236, 0.16863528044526188, 0.1732521858391266, 0.1441928394490789, 0.17419867677925482, 0.1566358005774502, 0.18047496176653843, 0.17986025438065534, 0.17079107661756876, 0.1581081892596976, 0.29283649660817734, 0.29431238103858726, 0.5922113824869444, 0.20345391388108103, 0.14923538044108942, 0.18165637815292357, 0.7011790837873895, 0.49633115689862384, 0.20966837150365647, 0.20810578789177403, 0.14849989555892573, 0.16969216434249446, 0.17839383550114218, 0.18902474049942886, 0.1760952757274563, 0.17743696085589478, 0.17615948653462077, 0.2094305066936345, 0.17472466450501156, 0.16894217108829868, 0.08440054524258356, 0.0642910624171118, 0.07257323795421033, 0.06832513137430885, 0.06836792028639771, 0.06008263066868513, 0.06285592494726422, 0.07260908600680027, 0.07421768857812949]}, "mutation_prompt": null}
{"id": "0a10ae73-1fe3-4b04-a41b-8c1e6abc955f", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 12 * dim // 2)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.niche_radius = 0.5\n        self.success_rate = 0.1\n        self.dynamic_sigma_factor = 0.03\n\n    def __call__(self, func):\n        evaluations = 0\n        success_count = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_sigma_factor)\n                mutant = self.population[a] + dynamic_mutation * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + np.random.normal(0, self.niche_radius) * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    success_count += 1\n                else:\n                    new_population[i] = self.population[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if success_count / self.population_size > self.success_rate:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.niche_radius = min(self.niche_radius * 1.05, 1.0)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.niche_radius = max(self.niche_radius * 0.95, 0.1)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Dynamic Niche Radius and Success-Based Strategy Adjustment for Efficient Search in High-Dimensional Spaces.", "configspace": "", "generation": 61, "fitness": 0.1508965466826779, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.18.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.26650269199625776, 0.2688540091255719, 0.28738078718066096, 0.302218312006193, 0.3086450686095965, 0.29813514497679283, 0.285708927310954, 0.2688118789436297, 0.295001695457079, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008503796181926759, 9.999999999998899e-05, 9.999999999998899e-05, 0.009014642290905095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06897668912979293, 0.05414822433421518, 0.07145653381593586, 0.06677843476173462, 0.0666360403728331, 0.07276144218142888, 0.0573430515773955, 0.05432632383906022, 0.0681514810652668, 0.04992472504253509, 0.06422403855901015, 0.06878861151033344, 0.06610807920624606, 0.05510257080499359, 0.047557315972838854, 0.07378760850149524, 0.05011708862938047, 0.05853095466400393, 0.88043051596038, 0.9137018283167541, 0.8930295647076464, 0.9306726256895582, 0.825873380963678, 0.8799145191656327, 0.9387075092244277, 0.9514470636886293, 0.8983131107777518, 0.13567302027431072, 0.14020052353390133, 0.14341167834877266, 0.11768657416830208, 0.144522191657952, 0.12962980792796586, 0.16661578003370014, 0.14775762544530113, 0.14298005930085056, 0.19027914242288235, 0.18867773624420814, 0.2037822177598807, 0.1933606605965814, 0.2005175425093425, 0.17586578020571741, 0.19032953305166034, 0.1800393185271436, 0.18868097919169635, 0.06849010259892474, 0.07225689695903292, 0.06437398967059194, 0.09391314405262896, 0.07692120364713084, 0.06610706854950477, 0.060950375075557006, 0.06351662283282744, 0.06264203387677136, 0.0663962978003434, 0.05961717489531004, 0.06397724892142087, 0.0931366739014815, 0.07138231044464372, 0.028561608128895077, 0.05247754888455036, 0.05682788644732939, 0.06198381675043929, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053077241587289214, 0.03316528270817454, 0.02487937622567804, 0.031084331249363495, 0.07342908484177346, 0.042266675751232996, 0.06397146484796545, 0.06547468114612098, 0.05734273422832026, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.030827711865287766, 0.032524882457780624, 0.032899269816444976, 0.02565495488518077, 0.029418104376630838, 0.026629035765794118, 0.03543068290057616, 0.02497780983373854, 0.0362709310482493, 0.27241935176254417, 0.2812340501005649, 0.26532688424555184, 0.29038804644921545, 0.2706719675100381, 0.2733615482254277, 0.2804319216641561, 0.2671652386259147, 0.30113149233402337, 0.09905632991293001, 0.06939283504680538, 0.06890001103713927, 0.06342764375034982, 0.07643448439631795, 0.06033541587983726, 0.06641082375511398, 0.06427053834670371, 0.06612140680221656, 0.13357272863959457, 0.1463635159741674, 0.11453438177938424, 0.147003602407076, 0.1565184340063186, 0.1479296095569953, 0.1486076113845507, 0.12286534727660148, 0.14370058120648443, 0.20753415079303628, 0.19566943036881312, 0.22626882860370978, 0.18787054059545616, 0.18478419034322258, 0.1884183611960618, 0.19491351306646698, 0.21037006938827774, 0.2023042122460491, 0.1417220412250887, 0.1396990956330808, 0.13203608035092163, 0.13173904293634475, 0.13247657405957092, 0.12334189546974161, 0.13550284532678813, 0.1543935494380927, 0.12971131422448356, 0.17598717913472506, 0.15299911267797195, 0.1551040133737822, 0.154717956834464, 0.1756224012947578, 0.16276413847377447, 0.15773796064892653, 0.16559021301530197, 0.18206318880365813, 0.14911240344800203, 0.15414731296737572, 0.15785076842248214, 0.16287569180049521, 0.1647223260642029, 0.17047372506366354, 0.15998337846348876, 0.15851615288661391, 0.172777949613943, 0.24867245693714624, 0.2471287125540763, 0.19301361132704342, 0.22492010679128538, 0.16795750126306486, 0.17007141887220456, 0.19506386954942612, 0.17547188865625596, 0.15948664491858378, 0.228558579775074, 0.15476596519668784, 0.16063097184434005, 0.17237605058887584, 0.14007111573983988, 0.12231883798488374, 0.19244252482991187, 0.197570877946864, 0.20131430794767013, 0.18978395394531622, 0.17716358383039466, 0.17485815517137526, 0.19617575759641837, 0.17257204124118142, 0.17159024133303102, 0.18463906307711053, 0.18182231958266115, 0.18792535835027158, 0.05884057772565754, 0.05587864976980239, 0.06903944401070716, 0.06344668932103903, 0.06438345061099682, 0.05532471538477435, 0.060668435728041925, 0.06053247541632789, 0.06449701815928188]}, "mutation_prompt": null}
{"id": "983df188-02f3-4918-9908-7426a015665d", "solution": "import numpy as np\n\nclass AdaptiveHybridEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 12 * dim // 3)\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.3, 0.7]\n        self.learning_rate = 0.04\n        self.min_learning_rate = 0.005\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.07\n        self.temperature = 1.0\n        self.cooling_rate = 0.99\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    if np.random.rand() < np.exp(-(trial_fitness - fitness_values[i]) / self.temperature):\n                        new_population[i] = trial_perturbed\n                    else:\n                        new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.temperature *= self.cooling_rate\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.4, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.8, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveHybridEvolution", "description": "Adaptive Hybrid Evolution Algorithm integrating Differential Evolution with simulated annealing and self-adaptive mutation for robust optimization.", "configspace": "", "generation": 62, "fitness": 0.23483363290984874, "feedback": "The algorithm AdaptiveHybridEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.13.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.3613889506726802, 0.3675219257574216, 0.41093371273569246, 0.37939638372987106, 0.3869040215284172, 0.3753050364310785, 0.388838644450091, 0.3678068776430524, 0.3807803277429672, 0.330928046744587, 0.31674837873166195, 0.3305300104891399, 0.307545369526521, 0.3385321192533052, 0.3094745993393765, 0.3067031906479243, 0.3227778776970023, 0.3319849685163906, 0.24182970610359467, 0.14464246796024416, 0.18836904556784695, 0.1492241757687689, 0.11910137900035023, 0.20330267295765747, 0.10254699246691923, 0.15094333912496405, 0.10835238882091913, 0.11045015159890703, 0.11096852198572138, 0.12967014958778877, 0.1188649361474956, 0.10484991268744248, 0.10420303800915132, 0.10647328307367165, 0.12595600168711063, 0.13357114682913596, 0.4246089169715509, 0.4158830371363127, 0.5784339528898932, 0.440931593400569, 0.49324185285972555, 0.5468225697723204, 0.5657642767673785, 0.43932941809248693, 0.561252245815992, 0.2845369397872858, 0.2682515536051927, 0.24983983438337354, 0.2683879319120924, 0.28135646905377787, 0.27271755389913055, 0.24309325703359908, 0.24208146375054562, 0.2424827133512819, 0.5037761116864303, 0.5905989782944236, 0.21300006532564664, 0.4911071539594267, 0.5732657436046866, 0.6002754598796298, 0.49418962180416826, 0.3034075986776136, 0.5580775214666807, 0.20541965068092716, 0.12368192710633552, 0.155612973173062, 0.27936202683098754, 0.12381709535456975, 0.18404703364999564, 0.17785293640545774, 0.1253856943438455, 0.16491834830745156, 0.205413788164174, 0.30088033384525925, 0.17785375630027433, 0.1767842304382824, 0.1807947606967062, 0.18661209564608472, 0.17183122563640607, 0.19162390105423532, 0.1433696254545248, 0.129576252392972, 0.08528540276636232, 0.06646211240111954, 0.2000875585059524, 0.155237262942181, 0.1217473268019188, 0.10276555097294526, 0.06360048740258695, 0.16465616010549733, 0.17905558162111468, 0.14678359228791282, 0.22515911468800387, 0.1482234698253455, 0.22966179513545681, 0.12298229852850096, 0.2388353845357888, 0.17369939078727525, 0.17635898729332333, 0.07455314120718393, 0.05579260984213119, 0.06159641552293438, 0.07305364340650777, 0.1586927194795551, 0.11924731085156004, 0.09504732345234002, 0.13194947909546917, 0.08766980289674953, 0.22355488865754947, 0.20572223467951667, 0.192884321144129, 0.1808469257917964, 0.21578031565357791, 0.16687413427090236, 0.1217733161275073, 0.2002133795465154, 0.16154259681666938, 0.3586953888100649, 0.3606329685436097, 0.3624919775996187, 0.3530603151293853, 0.3615427418120002, 0.3473701499968125, 0.3427750865446645, 0.3472307515559967, 0.356031423991782, 0.11405303120952726, 0.09531385930865366, 0.09013993248036001, 0.0899864989063528, 0.09240201833391659, 0.09203900783331187, 0.09585067036579498, 0.11997356482182309, 0.08688880697730816, 0.12329158512803096, 0.12861178231742565, 0.15146881622715735, 0.15310196069763182, 0.13460936780378818, 0.1587298079267483, 0.13038841980704496, 0.1306475672151437, 0.1578343145660247, 0.2836168577677417, 0.29399981183601487, 0.2775698844326313, 0.2866907459951872, 0.2893535092253311, 0.2970163683909508, 0.2986969667793785, 0.2979624900180211, 0.29512967149970004, 0.24649786148934882, 0.26200068834015944, 0.25941895107154345, 0.25509675106095187, 0.25450787054793866, 0.24356928115725673, 0.2453081775927971, 0.26215353010066955, 0.25719031370077083, 0.1931151977587472, 0.1894589543857188, 0.1816317076515176, 0.19452135381223534, 0.20775721494460586, 0.20546061732292464, 0.21215356356089787, 0.19583223723627763, 0.1957796356499255, 0.25032360948688315, 0.28377196915997316, 0.22911582290483368, 0.3018669824986979, 0.211188789054082, 0.22810373769624814, 0.260140633517297, 0.19831164927621592, 0.3179901771976895, 0.16943816359292108, 0.48778843010192785, 0.1818138768922598, 0.4210985926209573, 0.5235026235327661, 0.5127028354840879, 0.17049389251834746, 0.45174894428148915, 0.3945309992635413, 0.14211508651285754, 0.20590216068334422, 0.5083522716932604, 0.16258551412817468, 0.36454306752828447, 0.3103150285489872, 0.20914327348624417, 0.16262503756594904, 0.1978141624204378, 0.17900893497283554, 0.18568766493794797, 0.22104672038826212, 0.18100244987228675, 0.17089778398289235, 0.18158944091231277, 0.1843099581942722, 0.20852723991001043, 0.17151648139461995, 0.09130264707068037, 0.0754234389366607, 0.0686258382153968, 0.07404298625731864, 0.08034031868719071, 0.07634866683199981, 0.07723761499019055, 0.09293439292557282, 0.08387549243837789]}, "mutation_prompt": null}
{"id": "79805c89-79d0-40e6-a697-e8461e1fd632", "solution": "import numpy as np\n\nclass AdaptiveDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0, 1.5]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n        self.adaptive_crossover_rate = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.adaptive_crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.adaptive_crossover_rate = max(0.7, min(0.95, self.adaptive_crossover_rate + (np.random.rand() - 0.5) * 0.1))\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDynamicDifferentialEvolution", "description": "Adaptive Dynamic Differential Evolution incorporating multi-phase mutation and crossover strategies for enhanced convergence and diversity.", "configspace": "", "generation": 63, "fitness": 0.27525779599806866, "feedback": "The algorithm AdaptiveDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7076400545537903, 0.6648197792393493, 0.7190910702220747, 0.7151218838523321, 0.7485144130112563, 0.7212316341823146, 0.7512181687038547, 0.759279529956297, 0.7319220408912359, 0.3742440518129321, 0.30541103999433095, 0.25696361167427595, 0.36861243764966733, 0.35055875685481086, 0.30818099186649284, 0.3453930030464427, 0.4035173815356188, 0.3733174839277007, 0.08013082134925131, 0.13172219684851183, 0.09501140521957618, 0.08268822212235993, 0.09602333255178841, 0.10271603966597909, 0.10622098089601639, 0.08581140026843082, 0.11256928444264269, 0.08064220800108346, 0.10995050758236646, 0.0943495867551063, 0.09159514831002125, 0.08347259323937417, 0.1013507245955394, 0.08771125966231541, 0.09123249148899304, 0.07938077230208851, 0.8821275059928608, 0.9008791317075157, 0.9265999310253876, 0.9023942916301715, 0.9386157143051828, 0.9334039634586548, 0.949548950497373, 0.9380236610061106, 0.9284656571213168, 0.3383335043680161, 0.38274230715359303, 0.16575192481539447, 0.4179696488149045, 0.4084773956652181, 0.403302401084343, 0.2442773022352246, 0.34770242535270246, 0.4175876273540865, 0.24834813241713338, 0.7093465037752287, 0.606887010041981, 0.46638803587592215, 0.7638324827592724, 0.5919931654234472, 0.62488168258795, 0.6681911783724277, 0.48613232635073766, 0.17463279047763025, 0.18533728914725578, 0.19874774904205061, 0.2621763007476686, 0.2764550522064847, 0.3105424051893412, 0.20711550118534805, 0.20480940622685484, 0.19458678470144553, 0.10931246704057684, 0.10847858980049407, 0.16561155145477402, 0.20418898907691174, 0.2886786733639667, 0.22410505828940763, 0.2584621107131009, 0.17334662403187595, 0.2469265124105905, 0.019653127513622914, 0.06180939980457456, 9.999999999998899e-05, 0.03652247059494762, 0.12221954036406446, 0.11954709670143637, 0.03493646998476174, 0.1786855244204456, 0.1516530871501891, 0.1922243617472985, 0.19131099085868086, 0.06453700447307731, 0.06105745752376257, 0.2616700443048472, 0.06612164874710924, 0.2092868931935491, 0.260715541741507, 0.07885318971179334, 9.999999999998899e-05, 0.1211456128498809, 0.12275067870114886, 0.006270884786917619, 0.12760472975145531, 0.10611868768764632, 9.999999999998899e-05, 0.10368270320730699, 0.14045592405457297, 0.13175546266379, 0.19056919267675387, 0.1991176305222343, 0.17998035192248063, 0.19696041682596077, 0.19460605667744535, 0.15021631002907776, 0.10547806937726256, 0.16871132431386282, 0.467329489816684, 0.5020902483344412, 0.4920818557199407, 0.49849567423330887, 0.5463532552029156, 0.5129432472027265, 0.43481389905100354, 0.4754008546050653, 0.5192186689461831, 0.08007128868111213, 0.08406529885151448, 0.08451653798916647, 0.06630462754690403, 0.08810137923583683, 0.09085838712241534, 0.080502293004732, 0.08102323237276121, 0.09440850871459794, 0.16755099944579177, 0.15371974129600807, 0.15348789371008675, 0.15014812121016052, 0.18532737978405678, 0.18451186326383873, 0.1498169423730733, 0.1481124324652222, 0.15403020562824876, 0.27791703673056833, 0.3477630758038752, 0.31199805861170693, 0.29393310366899306, 0.29833723846224824, 0.2901080439251189, 0.301692975560791, 0.36027168337655935, 0.3234512882479458, 0.1702039158873384, 0.21872819668098908, 0.26260988060223356, 0.17254166650725455, 0.2235480419686191, 0.19698866331129983, 0.19626823801595483, 0.24106300315438944, 0.23310023300508265, 0.17557597449059903, 0.1772089168440223, 0.19800749002777462, 0.17773156387789546, 0.17867965663398577, 0.18137382585674777, 0.19305911006313403, 0.1844212609949245, 0.18478704369979682, 0.16990959990876708, 0.1745385375256434, 0.17531545200110776, 0.1774797323960312, 0.17341137052840894, 0.16760328252747692, 0.18230747568005923, 0.1818644725490942, 0.1679440642450556, 0.45321886550271506, 0.1679396592598993, 0.7029524354303058, 0.17761716520204518, 0.16140704006714346, 0.17406640402001217, 0.5855488610226698, 0.17539462447707554, 0.174678597822429, 0.6637940573543444, 0.16118262698106522, 0.44220776905209536, 0.40946084957149365, 0.6350077981781579, 0.427507883997559, 0.20712206053378224, 0.14854998451806223, 0.6496738817867929, 0.17543905135336046, 0.18397532872969524, 0.18736177298917034, 0.17774111060967568, 0.21195683933548892, 0.1694296007463103, 0.1838972277483235, 0.17879355337545544, 0.18024825412066747, 0.06919150553757647, 0.0528230404574892, 0.08253321199151087, 0.07072252073314866, 0.0745649032709782, 0.06441546507315266, 0.07212875859079848, 0.08163371230011873, 0.07460810520534955]}, "mutation_prompt": null}
{"id": "9d9ab8da-604a-4c54-91a7-34416693d4d9", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.c1 = 2.0  # cognitive coefficient\n        self.c2 = 2.0  # social coefficient\n        self.inertia = 0.7\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.personal_best = np.copy(self.population)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        self.global_best = None\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if fitness_values[i] < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness_values[i]\n                    self.personal_best[i] = self.population[i]\n\n                if fitness_values[i] < self.global_best_fitness:\n                    self.global_best_fitness = fitness_values[i]\n                    self.global_best = self.population[i]\n\n            inertia_weight = np.linspace(0.9, 0.4, self.budget // self.population_size)\n            self.inertia = inertia_weight[min(evaluations // self.population_size, len(inertia_weight) - 1)]\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                cognitive_component = self.c1 * r1 * (self.personal_best[i] - self.population[i])\n                social_component = self.c2 * r2 * (self.global_best - self.population[i])\n                self.velocities[i] = self.inertia * self.velocities[i] + cognitive_component + social_component\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], *self.bounds)\n\n        return self.global_best, self.global_best_fitness", "name": "AdaptiveParticleSwarmOptimization", "description": "Adaptive Particle Swarm Optimization with dynamic inertia and self-adaptive learning coefficients for enhanced convergence balance.", "configspace": "", "generation": 64, "fitness": 0.20566834048201496, "feedback": "The algorithm AdaptiveParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.5108497326942534, 0.5825011107905942, 0.4649873646206345, 0.12339262269571405, 0.15670748426116532, 0.5570698465500212, 0.501383546120643, 0.5986551987449289, 0.17903332947626072, 0.04280629357241483, 9.999999999998899e-05, 9.999999999998899e-05, 0.16435865077983414, 0.15490240977844172, 0.3620193913566444, 0.03389969232257395, 0.09248524688302973, 0.04335467499709755, 0.12703632605559867, 0.10174716849534338, 0.12059402043233114, 0.06471385179541034, 0.1386926754330372, 0.12683524575394844, 0.11330044227798097, 0.10265199449410889, 0.10710723485027462, 0.09624168179132231, 0.07551887912119104, 0.06885672535438903, 0.08491096904393491, 0.06492264035568374, 0.10278091807401246, 0.0640769570270362, 0.06633013969695545, 0.08120731146826032, 0.9914444174191414, 0.9782634936559722, 0.9968688951438426, 0.9938615035007446, 0.9837753828724387, 0.9963779851104145, 0.07498715604643913, 0.9939662736659498, 0.9871264883500507, 0.13187483125594368, 0.05816477953445043, 0.11335293323673434, 0.14078782616510943, 0.13779044917871397, 0.14219879237886124, 0.08046967509144376, 0.08498242034352532, 0.25573822672876767, 0.1715508884688789, 0.19965957107956278, 0.20696427575147747, 0.621602593017113, 0.064176487990804, 0.6587941743146062, 0.12484588287894438, 0.127556122070152, 0.16563219900491566, 0.11721211770202478, 0.0822311451714377, 0.11635571548020529, 0.17928399379610238, 0.08839011829128907, 0.1282884049753491, 0.10242718599160339, 0.12142584854174365, 0.20305122371449358, 0.10551586707548555, 0.1520562411323867, 0.1186786609085968, 0.14117391965954318, 0.10346163322360935, 0.31615211670412735, 0.14655898873357887, 0.1085875142886622, 0.11588122378795429, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04921596762533842, 9.999999999998899e-05, 0.010127853845416923, 0.049867029573641974, 9.999999999998899e-05, 0.05463772255530586, 0.06549260658683775, 0.04497893313156309, 0.05359855346110565, 0.1692747123538606, 0.008512788954573969, 9.999999999998899e-05, 0.134133586174915, 0.2005119322807455, 0.012400815252529118, 0.02219127103878049, 9.999999999998899e-05, 9.999999999998899e-05, 0.05255011874770443, 0.033955429007675786, 0.03985445994313663, 0.05999550049457936, 0.04867446278521781, 0.03785661644774774, 0.07129393138006812, 0.03572697841400818, 0.2324541609641848, 9.999999999998899e-05, 0.09297740196115756, 0.08135217875897183, 0.11198728404120306, 0.04596620997828704, 0.060125467760102635, 0.3745842207611836, 0.3713703174809295, 0.5058345875501735, 0.17992293630652, 0.47177918564999544, 0.5404015888643522, 0.43332985592196793, 0.5332193843241095, 0.44859229339251916, 0.07950735769757744, 0.05936952866072476, 0.035884190634715596, 0.11638915789240323, 0.07753820123866284, 0.1172601176221929, 0.11674135048645551, 0.07760646846926378, 0.12518322105016855, 0.2338788536834413, 0.22292399659307127, 0.2868746127578645, 0.33085612072505466, 0.17839641804094408, 0.2453352427221197, 0.2737364898893344, 0.27408156061517974, 0.20073063319125484, 0.3025213353476467, 0.28884287164514855, 0.18097718258185136, 0.23569397993057162, 0.28612741381310847, 0.2685291755905055, 0.24550376542873642, 0.2973981450478884, 0.24976174270953022, 0.18665813899520167, 0.22715212467222634, 0.15904180019273284, 0.18767860312597318, 0.20774221784608193, 0.22303889604440041, 0.19717884337236669, 0.19714079133516393, 0.13533992475522882, 0.18465761888993726, 0.16036545692194182, 0.20416083122851536, 0.1893386285700296, 0.17893854774228002, 0.23663598976604394, 0.24059966128956978, 0.21000986569477453, 0.24227739502720902, 0.19149169840465663, 0.20540282123448383, 0.20885201014234567, 0.2387268082281736, 0.2037713276511911, 0.18202268745540173, 0.19054039297074, 0.18975337172844997, 0.18686450682414102, 0.17106965848211697, 0.7019887862633418, 0.1246518720005928, 0.1796810018615943, 0.18875082825237, 0.19280199757750704, 0.621817655846397, 0.16697823674592105, 0.1735848751767618, 0.08113265468311748, 0.16393264234790417, 0.1623067444885844, 0.5051752778513849, 0.16848195112472097, 0.6013707240366869, 0.6877352525574244, 0.16243219744451365, 0.14389444577705068, 0.18703560963362176, 0.1831238268250499, 0.209516134679132, 0.20104080140919067, 0.1501056346908285, 0.20799419457956947, 0.20407019076857003, 0.18633842716047166, 0.196086324241728, 0.07898200482590945, 0.08615064951331985, 0.09068909231577926, 0.11235702172258155, 0.09591571916719766, 0.07934002203556156, 0.07810897872760836, 0.07038357029007969, 0.09098068046769625]}, "mutation_prompt": null}
{"id": "26c76199-062e-4687-a5d3-4dcf24bf7389", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.9  # Slightly higher to encourage diversity\n        self.crossover_rate = 0.85  # Adjusted for balance\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))  # Initial velocities for PSO\n        self.individual_best_positions = np.copy(self.population)\n        self.individual_best_fitness = np.inf * np.ones(self.population_size)\n        self.global_best_position = None\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.3  # Increased for potentially faster adaptation\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, 0.02)\n                mutant = self.population[a] + dynamic_mutation * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, 0.1, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.individual_best_fitness[i]:\n                    self.individual_best_fitness[i] = trial_fitness\n                    self.individual_best_positions[i] = trial_perturbed\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n                    self.global_best_position = trial_perturbed\n\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(2)\n                self.velocities[i] = (self.inertia_weight * self.velocities[i] +\n                                      self.cognitive_coefficient * r1 * (self.individual_best_positions[i] - self.population[i]) +\n                                      self.social_coefficient * r2 * (self.global_best_position - self.population[i]))\n                new_population[i] = self.population[i] + self.velocities[i]\n                new_population[i] = np.clip(new_population[i], *self.bounds)\n\n            if stagnation_counter > self.population_size // 2:\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridDEPSO", "description": "Hybrid Differential Evolution and Particle Swarm Optimization using adaptive strategies for enhanced global and local search capabilities.", "configspace": "", "generation": 65, "fitness": 0.2546755730354831, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6103481297637545, 0.61105428623606, 0.5982777616298625, 0.6149617044360549, 0.5147929840616384, 0.5625390689319477, 0.6161181027465834, 0.6300806125484103, 0.5967071173847431, 0.22070393014382184, 0.2002498554852009, 0.22507965107410532, 0.2757479513650616, 0.23941638220537165, 0.23502087764214263, 0.2412745316442022, 0.2267353488361007, 0.1318228971057115, 0.10787390685556042, 0.10919533632010403, 0.10403394281645939, 0.12456383848963015, 0.061961536970329134, 0.13427532550861399, 0.11697465075042779, 0.1283204850280949, 0.11475858713428533, 0.12107420504084698, 0.11564072789458746, 0.10239647199535884, 0.11719891388836545, 0.09800365197187022, 0.10866357279006988, 0.1273403065875569, 0.03825202236591618, 0.11770845293757282, 0.9935692023340627, 0.9877341899132137, 0.9732856468899975, 0.9905087237737237, 0.9876320840694031, 0.9939120322857875, 0.9854385107362047, 0.9763668529264812, 0.9910220274709394, 0.3418373421481581, 0.3734443205205561, 0.30730835298437664, 0.34254588096204164, 0.3348410868269749, 0.23153388549060572, 0.2010329986071211, 0.2423026827869078, 0.1361192508263004, 0.7465300381172262, 0.6079414843468729, 0.16508120249029945, 0.6077941567618935, 0.010764599023735166, 0.18908449595710086, 0.6822012410680167, 0.010741712406535098, 0.7653129305366719, 0.25505887504586144, 0.2233196430558112, 0.16811239564063074, 0.22836086070200667, 0.19089942992954256, 0.23865429339110122, 0.19700130669486426, 0.23305512096558145, 0.2693937016664727, 0.2789987004308997, 0.12876765424125947, 0.14950672493845518, 0.2859228032241946, 0.17512425296994738, 0.20437673827834235, 0.34139804419604214, 0.03234051192231269, 0.2629721765714691, 0.12252263114409145, 0.03222062025721206, 0.06838715127854178, 0.0023085185305015132, 0.09370451694886817, 9.999999999998899e-05, 0.07339474344216956, 0.058811672873186005, 0.00018633874569096154, 0.1096069689218877, 0.20846102748452855, 0.0217712130696327, 0.024032402336230385, 0.050091899443755805, 0.08298615042114321, 0.0466020933108825, 0.07294994949636169, 0.04649220663235698, 0.09349649678914285, 0.024926659706590137, 0.045545120997234845, 0.12270420176124319, 0.05344809187916144, 0.09667662476150851, 0.10444183186768607, 0.07004100672224389, 0.085653570578473, 0.1819682717758212, 0.1549393383537483, 0.1418970115437782, 0.08597072852611876, 0.18557212698717107, 0.18004959741706772, 0.1574840811167929, 0.18346435705310893, 0.1898858222371197, 0.49999689144453907, 0.5234956651504384, 0.5192691538689055, 0.5324335641189292, 0.48723756209929137, 0.5346886938268579, 0.5124887561826359, 0.5238639150684405, 0.4996749898126652, 0.10104279053604948, 0.09803289853600128, 0.06269613195548751, 0.126523325251513, 0.11143186154523632, 0.13868829908807345, 0.12378451917939093, 0.12113304941222236, 0.11941181846562632, 0.1723018806623512, 0.17761639389473294, 0.20673492585281572, 0.31161788647089106, 0.23883909907978373, 0.22055096713862588, 0.16512889098848904, 0.1835378728706123, 0.19169779116193253, 0.3479174413494299, 0.2335429241824537, 0.3334191687133754, 0.3515940287222803, 0.3234065251684719, 0.31915758625736357, 0.3643755085624618, 0.27207293239614205, 0.36038955311286414, 0.22607582151767902, 0.13378532364967177, 0.2768016107993858, 0.3031221181371724, 0.2632816797374009, 0.1908208890522518, 0.25323544494289874, 0.30054164826827345, 0.14093887280792428, 0.20157277434614307, 0.18257459880770044, 0.17201490963646227, 0.22140150081019006, 0.18117718770347568, 0.18651841117720636, 0.19879409900302492, 0.20008079714210902, 0.1979173206782755, 0.20674659676305362, 0.1843135262170682, 0.3035164857014191, 0.2014543570743319, 0.17999636348203152, 0.22176997282602295, 0.1918724051378714, 0.24727480672730662, 0.18560750889754518, 0.17072353226768933, 0.7822974116724413, 0.1977967315809117, 0.1218282930129233, 0.1687248030308789, 0.7848594878208316, 0.17846620779534894, 0.1633640773114996, 0.140672584758484, 0.15077331387394755, 0.16701951640464163, 0.16471942553488605, 0.11153786250969666, 0.728188386613811, 0.1412725362490317, 0.2119288046322365, 0.20868251180359487, 0.15532371883568352, 0.20022535796385033, 0.18358869544645517, 0.19394555692802318, 0.182546199118502, 0.19087736204105588, 0.17933415641332107, 0.19952957433592478, 0.19718497048710038, 0.1872391783284102, 0.0902612320709546, 0.08348094594290323, 0.08187412312956455, 0.08934338951215592, 0.08535004962795023, 0.07465052678354478, 0.08909194428765599, 0.08613685562665507, 0.09296981961703443]}, "mutation_prompt": null}
{"id": "2b72b7c4-ebb0-4c73-8d8c-d1cc9736f594", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "aaf43b3d-b722-4344-9983-04475210fa50", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "13481480-1411-4122-be75-366050cbbf19", "solution": "import numpy as np\n\nclass DynamicAdaptiveEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        adj_matrix = np.random.rand(self.population_size, self.population_size) < 0.25\n        np.fill_diagonal(adj_matrix, 0)\n        \n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                \n                neighbors = np.where(adj_matrix[i])[0]\n                if len(neighbors) < 3:\n                    adj_matrix = np.random.rand(self.population_size, self.population_size) < 0.25\n                    np.fill_diagonal(adj_matrix, 0)\n                    neighbors = np.where(adj_matrix[i])[0]\n                \n                a, b, c = np.random.choice(neighbors, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + dynamic_mutation * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "DynamicAdaptiveEA", "description": "Dynamic Adaptive Evolutionary Algorithm using random topology and fitness-based mutation for enhanced diversity and convergence.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {}, "mutation_prompt": null}
{"id": "cc659edf-127f-443d-bd76-acade5d07f41", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(12, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.3\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            order = np.argsort(fitness_values)\n            fitness_order = fitness_values[order]\n            \n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                \n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic learning rates, stochastic ranking, and perturbation to balance exploration and exploitation.", "configspace": "", "generation": 69, "fitness": 0.33409874908289333, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7974597399207618, 0.7977022879490046, 0.8039039083369117, 0.7880027460971747, 0.7809678032766018, 0.8134528956316545, 0.7782405788481164, 0.7941093844078634, 0.7593801480887479, 0.36503537880743275, 0.3709065841101733, 0.4063238374999333, 0.36950507732596494, 0.2949928250501491, 0.4107726554322587, 0.38345319858967664, 0.3955988345617024, 0.4165118783659143, 0.10868036691129712, 0.16168112679604296, 0.11253879950473022, 0.10229561209449967, 0.15199185170584006, 0.1472709114822759, 0.09209961644274733, 0.11846397994336877, 0.40385118069887904, 0.11350901300938532, 0.0883254576255067, 0.08887533928113389, 0.09283442538964903, 0.08763098010798553, 0.10697729216202623, 0.09227135993509217, 0.08065390200906186, 0.10086032626032215, 0.8928185313424353, 0.89012466073937, 0.938919671777769, 0.9153940842264883, 0.8775642906039675, 0.919246535828723, 0.9116541580730064, 0.8649512389675544, 0.9250426433470332, 0.49917116055471866, 0.4027460713780776, 0.3889976622750201, 0.42681604586610955, 0.4639298305122995, 0.39181388653890004, 0.49940530042296416, 0.45365139282793443, 0.3546255949906916, 0.7625312745453847, 0.7276276890879134, 0.7659526401926805, 0.8011546448552254, 0.7486284818112363, 0.7930928936216576, 0.3649970166422992, 0.6651638044143724, 0.8256259703366093, 0.27254154922016094, 0.1818645730823566, 0.22817209963953888, 0.1672012294000511, 0.22149318444523602, 0.21192608434881333, 0.2962732218979226, 0.18263624147542235, 0.19100316751416224, 0.14916887204850315, 0.3954830854160615, 0.0717358182193899, 0.1235480663465125, 0.25731171877772296, 0.16743325477023796, 0.21769614041294505, 0.19203466535453995, 0.4147030716870067, 0.2627855524697804, 0.11296657393442588, 0.2643851988337218, 0.31807906557489385, 0.24745266191441495, 0.05964825306903365, 0.2543870918241652, 0.2919756153198202, 0.30414073265456465, 0.3464304622859301, 0.3657870114127463, 0.3919148922258904, 0.32512276755297775, 0.344024400337545, 0.3300432749076857, 0.33204523752237014, 0.3071069013541593, 0.2429121521090416, 0.07981009467151312, 0.12439712199212949, 0.07764563906063626, 0.13900016758645128, 0.08715347583921007, 0.13849093516841693, 0.22073620577765318, 0.11061957728314376, 0.18178053012984852, 0.2582208990595668, 0.26160717150286605, 0.2719211977079923, 0.2529050758215039, 0.26172252295220666, 0.2514068467458592, 0.26048511812944575, 0.25083717628066904, 0.251355836619785, 0.5542643811848995, 0.546745064147559, 0.5920612319485529, 0.5627831157681715, 0.5721060608618054, 0.564727514177882, 0.5786961928635213, 0.580451995801725, 0.5670595540963378, 0.08738893051242835, 0.08131900275318771, 0.08158861604310219, 0.09768715987154286, 0.15027052108448424, 0.08363345093210717, 0.09177168140000136, 0.10389241320654996, 0.0852213928700356, 0.14339200279640085, 0.45993745158383403, 0.34692349472296125, 0.13420103686256812, 0.3390863568159619, 0.1454580942590512, 0.25252455036919563, 0.14088545725841273, 0.1857013493394808, 0.3339495428384043, 0.3420992608723157, 0.3964119855471462, 0.3877785137666885, 0.35897666666536177, 0.3618682702994317, 0.39666698466043004, 0.42537773607478224, 0.3551095562734635, 0.2878936713739174, 0.29604012881265485, 0.3086351459003652, 0.2980953505231385, 0.2510514947447948, 0.34471116576425953, 0.3087871246699586, 0.3671001248665039, 0.3103720791309179, 0.19463721732116435, 0.17346735272884728, 0.20524327440101786, 0.17742660503748775, 0.1889686276313539, 0.1682587017839684, 0.17858544269817034, 0.19261490968936934, 0.1877869825037094, 0.1805259507938214, 0.1849590122560658, 0.22174066876564658, 0.17484164832216198, 0.23036804666030708, 0.1831563081804879, 0.16913577622194975, 0.17549573694279186, 0.16798265035855198, 0.8572498710389433, 0.18333011274725142, 0.15093325344135233, 0.8198406573071833, 0.18838648607066466, 0.15954338301293958, 0.7908015603196114, 0.6809943213147054, 0.7545821653073417, 0.8195552206185064, 0.20362532181194148, 0.7961249511649313, 0.16440326903902003, 0.15603029742231445, 0.6709878386234646, 0.20348513683503955, 0.20577194729140502, 0.6971053125718158, 0.17019996330370413, 0.2006059024118898, 0.1653199088366788, 0.17602707127624306, 0.1782916457284346, 0.1891144772305049, 0.17027638177778703, 0.20022763660561005, 0.1753850146929128, 0.06698620067914562, 0.0637519889926913, 0.06706696639827536, 0.07972259328552778, 0.07505706321502181, 0.07141001539809588, 0.07546769312840462, 0.07117296449339261, 0.0782894587700621]}, "mutation_prompt": null}
{"id": "22d469f5-961f-4e42-a96f-33d4c301d3cd", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.dynamic_mutation_factor = 0.05\n        self.resize_threshold = 0.1\n        self.resize_factor = 0.9\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size * self.resize_threshold:\n                self.population_size = max(10, int(self.population_size * self.resize_factor))\n                self.population = self.population[:self.population_size]\n\n            self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n            self.learning_rate = max(self.learning_rate * 0.85, 0.01)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic population resizing and stochastic ranking to enhance convergence and prevent premature stagnation.", "configspace": "", "generation": 70, "fitness": 0.26264151390132795, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7861876514848402, 0.7879029571187075, 0.7862012547925414, 0.8034560686578078, 0.7766454253025346, 0.7534457361151607, 0.7746145339001904, 0.7914066273540826, 0.7800923234575851, 0.33384324960223033, 0.39229452326529, 0.42220816172020303, 0.4262790810748114, 0.3885358963420621, 0.3773958720398859, 0.38305078576097285, 0.05594745986172822, 0.4133982976803382, 0.10440695400926747, 0.14442147579488973, 0.11284839152732296, 0.1449668407408644, 0.1353982790762277, 0.14629334396621052, 0.14980962411137022, 0.2582844576941258, 0.12323730722100312, 0.11736155757188482, 0.09295269253957561, 0.08751025557209957, 0.11915377367151303, 0.12473392963984464, 0.11946586139100213, 0.12573171775119574, 0.1289209648694466, 0.12569467276221147, 0.9059594093275877, 0.9005518588847082, 0.8969325558641917, 0.9471862322358906, 0.8656846103855496, 0.8374738967457017, 0.8794356972194535, 0.9216678364284421, 0.9145124972537508, 0.07812236418606533, 0.3811386812135039, 0.36212735897672277, 0.3386713201297723, 0.3577038185409296, 0.3322344493771051, 0.23802453281354552, 0.09513065287321676, 0.08619525625484403, 0.8034100208646426, 0.3195173282170738, 0.3422240764801253, 0.34040700326133855, 0.34057321963231135, 0.666845943102127, 0.7149590045246517, 0.7164106071355786, 0.7051627792790819, 0.13743044946985805, 0.31035562033899267, 0.1379034145805399, 0.10387595012864259, 0.12247882126307141, 0.14386081019284724, 0.2414650118351812, 0.15615436356134815, 0.16456159043518515, 0.1451768072083922, 0.0503686017409698, 0.1581312897093956, 0.17178271966042213, 0.1275179491092291, 0.11795440102289634, 0.2278148661357272, 0.14629561007641656, 0.11333083215157569, 9.999999999998899e-05, 0.12519528363818155, 0.16838785652759902, 0.042442223552449865, 0.06958077831798759, 9.999999999998899e-05, 0.12078046193652647, 0.05412076810916566, 0.05676470565852265, 0.17912240230296972, 0.18734718900770908, 0.08865198388238715, 0.07909819285949637, 0.30799506181740455, 0.06766188688627084, 0.10373432404453686, 0.26861038363983536, 0.1256317961643061, 0.21844778268498166, 0.006711911528703762, 0.07085061021749495, 0.08993465937740619, 0.21821472788922724, 0.09184403869565572, 0.25417899365541174, 0.11651150874194138, 0.1404990592452412, 0.1966396261045854, 0.21195706512803036, 0.17866291535652035, 0.1753784335183316, 0.13183219006135827, 0.12583568075389318, 0.20672110724254322, 0.14981278267656017, 0.11481825131957724, 0.43709814669723224, 0.4762806669111064, 0.5894938552946432, 0.5269040004993579, 0.20788152276769778, 0.48660851350442, 0.4985022474355246, 0.5499860296967655, 0.4412103097074678, 0.11308855688771602, 0.1006529798462763, 0.08558437426139531, 0.08141959142523991, 0.0944511179613381, 0.10144449784593612, 0.09361602259135526, 0.10428658336542851, 0.12102549592459566, 0.11588047070082397, 0.14650152414383288, 0.14330271301204944, 0.20251853602342862, 0.13429549177560873, 0.16925603082240304, 0.12910386821548858, 0.11796067183895209, 0.16864603841402437, 0.4470680577031978, 0.39662300090121294, 0.18071620527976084, 0.30094666073413157, 0.22336233112696657, 0.18559544296715613, 0.37661670800101, 0.27225624231796264, 0.398913358106574, 0.3151166318497801, 0.2143251822274922, 0.22539146963993795, 0.21578451874696036, 0.2800694146095688, 0.1731466137750305, 0.27379577205355576, 0.24691956276548432, 0.23317703385784438, 0.16708083929223072, 0.1725852146386474, 0.19182802558233425, 0.1798230016011727, 0.16475755846354734, 0.21597682788892958, 0.20306306703125954, 0.20315089637353922, 0.18400910165416906, 0.17010382933897017, 0.19031778927040788, 0.19661941750786505, 0.16849708147909714, 0.17282924417213386, 0.19557293898069184, 0.19173979042081057, 0.22869970199054235, 0.18081386161131485, 0.1923365850352402, 0.15819000601155564, 0.1609162637843634, 0.1678416597259631, 0.18901234277671441, 0.1730903806104559, 0.18197889996682515, 0.22547324234953847, 0.15112788892820095, 0.16698451941559067, 0.4662516748876361, 0.20630306587464486, 0.156682565915767, 0.5222904218188967, 0.2105553134962369, 0.19765764042721712, 0.16362097881184223, 0.2833299589447995, 0.2164531327783772, 0.20622226110308206, 0.1853448529469519, 0.1857170546545478, 0.21312682589666443, 0.21457162214450043, 0.2095771923524905, 0.22877920642487892, 0.21079605581023564, 0.0783589548529604, 0.08536189135316474, 0.07364444243360957, 0.06867730026825614, 0.08484704961141487, 0.06699968770705855, 0.08021598201317681, 0.07912386669839211, 0.09181719551174938]}, "mutation_prompt": null}
{"id": "89a484ac-aaa1-4611-9be1-882f98e215ba", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n        self.temp = 1.0\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            new_population = np.copy(self.population)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                elif np.exp((fitness_values[i] - trial_fitness) / self.temp) > np.random.rand():\n                    new_population[i] = trial_perturbed\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.temp *= 0.98  # Cooling schedule for simulated annealing\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution incorporating local search via simulated annealing for enhanced convergence on BBOB functions.", "configspace": "", "generation": 71, "fitness": 0.2846667605853528, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.15.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.4119348361293801, 0.42039518939302367, 0.4165958719614964, 0.4597663384531204, 0.4406597286766204, 0.43129836757858786, 0.4405359452299208, 0.41450108426663346, 0.44188795233534406, 0.373799128094187, 0.36480130871255234, 0.36901688184174875, 0.3735392769532554, 0.36493401814200876, 0.3529624880651039, 0.3780095010356883, 0.37260929575301527, 0.3625473384014739, 0.2753435710725811, 0.30201564879073717, 0.29724203910335534, 0.2640645294203027, 0.3002673452240612, 0.26006971786791777, 0.22754896122794166, 0.13041652258838654, 0.2354121564796714, 0.13763079974168757, 0.11635468835373941, 0.14106256802053108, 0.12736215712754073, 0.12267403418503631, 0.13522544475444953, 0.11420284668663971, 0.11806109016722877, 0.10618313754013964, 0.6306307891959956, 0.8109502012274095, 0.5682092933775019, 0.8405493851937607, 0.51917542768316, 0.7870180590016785, 0.6409306514313268, 0.6732551527905069, 0.5416972962363595, 0.31705681180706646, 0.3286210368213709, 0.32143710782116763, 0.339502031284853, 0.3364003731227836, 0.32552603734561925, 0.3268366970729082, 0.3136062759952305, 0.3132993352306076, 0.727099085104933, 0.5831031085226284, 0.6325787529396352, 0.7015296092078446, 0.6869252645325793, 0.6667443885091334, 0.5245618252284794, 0.6875601701218164, 0.6922535037211941, 0.15198398813709524, 0.28849066707226667, 0.23553052043863565, 0.23958495148035797, 0.27841456671547016, 0.20507645535820407, 0.2567425039844955, 0.15596274995393267, 0.29868943091251243, 0.3412378423727025, 0.209515949926958, 0.20970478961723782, 0.2747241488142147, 0.3515403419289992, 0.3475766757460289, 0.362591838711822, 0.2911512703729119, 0.25287661152231056, 0.10023534952024205, 0.31044829197983526, 0.22288445052532746, 0.07874133891800905, 0.30492203928575223, 0.093120737679382, 0.31553904889279516, 0.30651814131173793, 0.3202100785811115, 0.24713600601114416, 0.26826619037132204, 0.2099974963275978, 0.3100742384583276, 0.06919971117827028, 0.3512560316517416, 0.35864784338143285, 0.37401313949678594, 0.35392377509003514, 0.11000748160964635, 0.09835132280668735, 0.14220274329197258, 0.23259877829616027, 0.15027856337935097, 0.14148268121651708, 0.20764439270617951, 0.21721999335815045, 0.10921549652103768, 0.2548149872684494, 0.26116106229045055, 0.28257572146804444, 0.256755954498499, 0.26912083229627304, 0.2592695260317396, 0.2794315333733429, 0.26621037414831206, 0.2512424446337205, 0.3898085220935723, 0.38965016371848127, 0.39632272713666783, 0.3877670045278422, 0.40493307581555127, 0.3933960740684129, 0.39343805046563485, 0.40442728591919297, 0.403315824407563, 0.09300621242181917, 0.11816259373041049, 0.15470592532701088, 0.23222321962994874, 0.08140075795745416, 0.1126545962911627, 0.11766313007760287, 0.13289941089455037, 0.0962603717537932, 0.14148300481274767, 0.1598809394756936, 0.20380881094454795, 0.1933001471411664, 0.3545373876137994, 0.1485422484297988, 0.14537663968230585, 0.1588363987998519, 0.1908654245741922, 0.3296461131048505, 0.33676125930295964, 0.32449222657554033, 0.3371508014340254, 0.3337512847161862, 0.32554940756433337, 0.33759871744788383, 0.32854678119926395, 0.3278387147877879, 0.28165317907435705, 0.2934458808919109, 0.2796598680082386, 0.30197893267294007, 0.30708334784511737, 0.29435742333797166, 0.2955185781993884, 0.29739002436187434, 0.19303280735941408, 0.1818296739204257, 0.1830780003797079, 0.2051397823362957, 0.20221596037166412, 0.21311843094155525, 0.20613427235788817, 0.1929032061415421, 0.19953067105468214, 0.19070728687304894, 0.2096782115948076, 0.20178257424156187, 0.20763223222772498, 0.19231630215799655, 0.2985275746964282, 0.2039262228848866, 0.19748507549512673, 0.22245728558980327, 0.20844469934741972, 0.5252184181859398, 0.20549021581934246, 0.16674295321426502, 0.16486510348874195, 0.186182299050359, 0.18152410920864825, 0.09909587778071383, 0.16926564220814977, 0.19244826463613895, 0.1525725492453721, 0.2024813072801087, 0.43570902069898465, 0.19864631105822927, 0.4576643087332012, 0.49319328655660566, 0.20890055603997293, 0.2096561397058897, 0.12277000010377159, 0.2624129336782459, 0.2662981520463992, 0.22308042824396634, 0.18075178264766256, 0.26052778841493096, 0.20415240403821444, 0.27771990735968055, 0.20169421083528594, 0.2454448645923878, 0.07827870743989718, 0.08395814366744703, 0.0844813804473612, 0.09378957572722024, 0.08815637285293065, 0.08258008089170232, 0.08496622384555153, 0.09329692015176316, 0.08887270750953213]}, "mutation_prompt": null}
{"id": "5a3f06f4-8cb6-4ad1-bfa1-3e8a377b65f4", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n        self.secondary_population = np.copy(self.population)\n        self.secondary_population_size = self.population_size // 2\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            secondary_fitness_values = np.apply_along_axis(func, 1, self.secondary_population)\n            evaluations += self.population_size + self.secondary_population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            swap_index = np.random.randint(0, self.secondary_population_size)\n            self.secondary_population[swap_index] = self.best_solution\n            \n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Adaptive Multi-Population Strategy and Dynamic Parameter Control for Robust Optimization.", "configspace": "", "generation": 72, "fitness": 0.2722078219980364, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6825100133978652, 0.6551850675211123, 0.6949010336752963, 0.6838176436405901, 0.6998768047201092, 0.7366730132829986, 0.70728714011223, 0.6989845556167658, 0.6679982395111438, 0.33861266786127886, 0.34218161938082203, 0.3726608146384649, 0.3679340383224341, 0.3418582899397288, 0.3514930570654792, 0.35955435622707277, 0.3050607601447679, 0.3288932197653487, 0.13450806810929605, 0.212627794247624, 0.10485452395511563, 0.12274443832271664, 0.094747576686393, 0.16161512007016865, 0.09190334911341247, 0.0857308465781631, 0.09033385673638239, 0.07973850939779337, 0.08210466481145651, 0.11203897436900478, 0.07443243318292958, 0.11084407055554057, 0.08272405704315533, 0.0798504147236141, 0.07538338944602074, 0.08370203006399601, 0.9400288001772915, 0.7959225281672184, 0.8572334267523227, 0.8356754281643782, 0.8357111788147404, 0.8914670845255397, 0.7648269090104707, 0.8178822329131098, 0.7505240485649883, 0.207198697964303, 0.31532709516985546, 0.297855120405787, 0.31537454981023993, 0.35064478774531993, 0.3598894027746484, 0.32233439821932053, 0.34619091242769107, 0.0939324796392732, 0.5936820082374787, 0.5826735747360897, 0.5851124755700359, 0.6649954533608169, 0.7641353165084462, 0.687066453170279, 0.7489436031045951, 0.6840973030688, 0.7906889749705723, 0.23791576023374728, 0.15132072734049928, 0.19862055795497635, 0.16483608933517535, 0.16220048130178022, 0.18550150768642393, 0.2224126868548989, 0.13584064905767268, 0.15587632447071265, 0.04850905958400331, 0.18946706573499272, 0.18132456027775812, 0.17199478009234392, 0.1562318122088473, 0.18234534321277052, 0.19309124010067558, 0.152281182183451, 0.17416640207379674, 0.0685713768677304, 0.07255986534482439, 0.09294945367495133, 0.19140715397379804, 0.2239860653134309, 0.06813052106173967, 0.09947641564586429, 0.22659914976810536, 0.1989205328455459, 0.18902162934902078, 0.1839463499085071, 0.2407677432667219, 0.1833941232638885, 0.1612205384080727, 0.33334494821735994, 0.19522748008462099, 0.3203815979533957, 0.09761436986952743, 0.08013766446050763, 0.035861671514349824, 0.06402202022636216, 0.0807230373928689, 0.07467543428820245, 0.13119642486512217, 0.07803900577889367, 0.10307505672606276, 0.07385039399497784, 0.1778226218000506, 0.18980034259784784, 0.20505502201236991, 0.19715635714972912, 0.21524654182415093, 0.20985657509909217, 0.21124007904807252, 0.1917529204116346, 0.1984034526244033, 0.50979466644867, 0.49834640621133186, 0.5298927010221994, 0.48673287855628355, 0.49314361493065084, 0.5759679373232245, 0.5084274861982514, 0.501625860541462, 0.509761897369762, 0.08035499495809562, 0.07415789749640822, 0.08652004609851371, 0.10662262224690366, 0.06908565581521675, 0.07747959552544692, 0.08306975298409303, 0.07997742427703525, 0.07349859066664444, 0.12436161211608376, 0.13056222160051745, 0.15453626539521825, 0.12410353734112156, 0.1279194310224322, 0.22713592195138754, 0.1451426040038667, 0.1731924420191424, 0.1642170099991297, 0.3171021383557443, 0.30113130061845783, 0.3479944006890445, 0.2642313552379767, 0.3069746873495727, 0.30509128335385005, 0.3472080348825566, 0.3675473932356459, 0.3026006323080247, 0.2655850523434652, 0.25308714004475863, 0.2807892266927773, 0.226140980041166, 0.25966079215505666, 0.22491381554718082, 0.30219440598197045, 0.2534969766469237, 0.24048859435722092, 0.16658468033644058, 0.18742306094121908, 0.16948477757625313, 0.16474994472287308, 0.19342399089494822, 0.17542192735376427, 0.24140115918609872, 0.16720122124102532, 0.1692519084394789, 0.16706831130946942, 0.1718684600410021, 0.2961584465376711, 0.2206390461020905, 0.17630108621596718, 0.18400907502471786, 0.18104687535267827, 0.24944875440100145, 0.16793939949318026, 0.680852069536046, 0.16179374094123466, 0.14803231442073428, 0.1470014341139071, 0.19222789765274328, 0.6380872867086862, 0.1586098294898045, 0.1616025775311244, 0.6763865850521122, 0.44940545122000375, 0.16684023018999417, 0.14951379428570066, 0.19288495514999626, 0.18040438004314596, 0.3262197674326842, 0.10781480134842913, 0.47669521499023115, 0.12272263497031832, 0.20032505415382262, 0.1809688610874306, 0.1742200722836289, 0.1771684224236526, 0.16558359750059204, 0.18017390583096526, 0.17576499588639438, 0.1605579915488472, 0.1607475024168813, 0.06393656318124463, 0.058705902349611594, 0.07772045363045776, 0.05998571998976132, 0.0584056022147279, 0.06580978453276931, 0.07027611657618527, 0.07177119877752847, 0.08223057043786508]}, "mutation_prompt": null}
{"id": "e0da9d81-f4d5-4771-a80f-93b9e1f0689f", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(12, 12 * dim // 3)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.7, 1.3]\n        self.learning_rate = 0.06\n        self.min_learning_rate = 0.015\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.4, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.8, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution incorporating quantum superposition principles for enhanced diversity and convergence.", "configspace": "", "generation": 73, "fitness": 0.22012010403290724, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.5842033376864375, 0.594006226116476, 0.6114609625417617, 0.6162730175731786, 0.5523849831861722, 0.5904557690766058, 0.5629774974850077, 0.6191408076260418, 0.6234502004185112, 0.2629558797148678, 0.2605390742702247, 0.2909303412194656, 0.23823458368109474, 0.27155786366797885, 0.24721931351928772, 0.28308553468861275, 0.2522884323422784, 0.27642131169944206, 0.09656903712174592, 0.08705196714263708, 0.08424620807648187, 0.08628337234299255, 0.07729812678607084, 0.08007500740157625, 0.06918762507582799, 0.08210888484785883, 0.0867808110946724, 0.07092911218627085, 0.07579587868649418, 0.07155117671232747, 0.07558025181327288, 0.0697163118092381, 0.06851084757221948, 0.08306216957938528, 0.07793307528642146, 0.06919566978092684, 0.8801561169823207, 0.8766299501998379, 0.9369562490944957, 0.9019917388061122, 0.9116896659194441, 0.8465641743411658, 0.9054251574870712, 0.9035669047876389, 0.9552757321943991, 0.25162345217539483, 0.2402456875922987, 0.30658675070310604, 0.25369163472697465, 0.2413831799006404, 0.2608272330926308, 0.13421768278111468, 0.1606379076951331, 0.22131964070614774, 0.24701432663793743, 0.4544328297914957, 0.21772263633871713, 0.39180655665559083, 0.4599899268202464, 0.39857344657790794, 0.26885984180705114, 0.4485848719194705, 0.32778887733578554, 0.14455656718972565, 0.20091071275518257, 0.12770140206062608, 0.1283719528900088, 0.1732976703524015, 0.14511013722148547, 0.17830168513636513, 0.15417064158202798, 0.14655609672439518, 0.11552634879734136, 0.14130091297412506, 0.16947862314763606, 0.14935846722468304, 0.1240456600460873, 0.172385873618095, 0.17553121460320964, 0.1631028268395508, 0.11779043210884188, 0.05123812050934706, 0.053907620343074836, 0.0777284844844145, 0.06060758920382492, 0.05982447588121231, 0.07586497390499736, 0.06926038731882433, 9.999999999998899e-05, 0.005045181783023822, 0.09495050704276142, 0.07200811103843974, 0.18497407139185218, 0.0640451817902038, 0.05098978754805916, 0.0548986838402159, 0.20588544461486213, 0.18160019489816104, 0.20713009762573265, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022408274929098804, 0.005663158096787413, 0.14052358198914228, 0.11305570701256096, 0.11800737368176739, 0.14776617334915687, 0.115817375243632, 0.1090639465230534, 0.1260867160330923, 0.12785874708142275, 0.10960149285254994, 0.4368688482738182, 0.45572943655394227, 0.43217320867892195, 0.41836253641588406, 0.4234625253873745, 0.4334825112807926, 0.43049227596171313, 0.43365079099111836, 0.4545286394473482, 0.08330803147160126, 0.07089907014599717, 0.07379089341160672, 0.07300577458080748, 0.06984638701714552, 0.07540983060982054, 0.07086487584536694, 0.08490173739552842, 0.07285959003269804, 0.1367627395620682, 0.1336702217993645, 0.15022857847644644, 0.1566159535128656, 0.19024644552889702, 0.1345676943612143, 0.12367508077102884, 0.13952176870443833, 0.14916054282753322, 0.27752829761789455, 0.26318244873846397, 0.2556162376137069, 0.230897084890888, 0.2288102488340451, 0.23359578304775597, 0.2533333587613428, 0.2652644026626664, 0.24338239498579683, 0.2096583518444899, 0.18259918798623864, 0.17757815692064682, 0.17848005166321823, 0.17032559721069607, 0.17912755159566318, 0.1970483792799551, 0.1653874911702229, 0.2047556021614667, 0.1867959710746544, 0.15695458577865573, 0.16278954159423464, 0.1555930969092928, 0.15245009470534587, 0.19400858075109795, 0.177173334231718, 0.16719123418837356, 0.16775566024257427, 0.1637420994346116, 0.16737626641238967, 0.16652851411054803, 0.17613084359360587, 0.15791304142503426, 0.16907708700683288, 0.16319750282164536, 0.1692097472228954, 0.17010500861265354, 0.15790700915852718, 0.5638250375925904, 0.14845690076161022, 0.5850969161851102, 0.18183840390182238, 0.18087901310503507, 0.15961288017118203, 0.4901021108697162, 0.18387536441313146, 0.1622535793179377, 0.19759477958224514, 0.18828842162003845, 0.4381790466123586, 0.173692161074803, 0.1755043175106339, 0.21018550423668092, 0.14117298880076445, 0.20000309018292362, 0.18289479249688323, 0.18222376206315372, 0.16786110013357303, 0.205133912481389, 0.17134031882468737, 0.1827363761842199, 0.16528781026525974, 0.17370411275843778, 0.17546522020313404, 0.05890365684452914, 0.0612565834656531, 0.06491996037938863, 0.06426886697933154, 0.0629502418830803, 0.062357739632335374, 0.06040287294751179, 0.06385711916171344, 0.06613014497685477]}, "mutation_prompt": null}
{"id": "0a8c3ca5-0090-4ac3-a62d-a3a64745b801", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 12 * dim // 3)\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.5, 1.2]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < np.random.normal(self.crossover_rate, 0.05), mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive exploration and dynamic crossover for balanced convergence.", "configspace": "", "generation": 74, "fitness": 0.2709005403542992, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7346107199883065, 0.7029193823489045, 0.7371614951581689, 0.7129389276391623, 0.7173897456869097, 0.7374998379102002, 0.7408386358322422, 0.7203232292462696, 0.710958331097515, 0.3893535841404576, 0.34350223491853216, 0.3476158485737485, 0.3722766628199432, 0.3524677109992742, 0.3499434492142328, 0.3500196538177526, 0.37218574350906963, 0.37455577993666667, 0.09216297172531307, 0.10420356466512126, 0.09835992335312516, 0.08855339849899468, 0.10772150541764947, 0.10518092864574213, 0.10243818952780748, 0.09903990893306458, 0.11213422440610288, 0.10989702256053546, 0.09680052849619347, 0.10471520736895323, 0.09556028437303488, 0.10032697614642672, 0.11393234891024728, 0.08330900919343964, 0.11067743606482905, 0.08759733710390138, 0.9387104500779586, 0.8892216037329441, 0.8950656857389487, 0.8949152453828435, 0.9153332155123417, 0.9034833330770861, 0.9220056984584393, 0.8680345039962646, 0.9029828490416367, 0.3303261179515754, 0.3394190886954668, 0.3581734425106199, 0.32166418112059414, 0.34535893491758896, 0.3624072076262149, 0.2571302508888984, 0.42442810322692737, 0.33637563305409934, 0.5803191140663481, 0.623124625042137, 0.5445959524922174, 0.5408203643565574, 0.6588460867339669, 0.23622145585872634, 0.5116018607633648, 0.5916136485803571, 0.5610025448073596, 0.19430718693168247, 0.17581779141812492, 0.21331183796367603, 0.18397060670009946, 0.2491703440602272, 0.16762946297048753, 0.20070608263358414, 0.2068283936170987, 0.2730958497517937, 0.1829008457242396, 0.1706030210586812, 0.25507913966776996, 0.1782892177748583, 0.29008226097384726, 0.17023443266936045, 0.14405607622255867, 0.12861162303334872, 0.23553013278613422, 0.0935986142144799, 0.11457797390497049, 0.1549172060603038, 0.11805232933625853, 0.0930907411024271, 0.11175547777355821, 0.057400819986982654, 0.11910056058534846, 0.13958321294845388, 0.23592293938937436, 0.17949374405467156, 0.21076056748808125, 0.1976067709237973, 0.1675249620613296, 0.15479604636791833, 0.2322013247374991, 0.24548226736101664, 0.2807652849586646, 0.045057461771110696, 0.049756549128458394, 0.09638194614313, 0.07807541033141718, 0.08604745656308055, 0.053738236609160994, 0.03328712147056345, 0.09288938860728391, 0.03239853771505097, 0.1662366831542169, 0.1858719837348738, 0.17406917184569193, 0.15218311522631378, 0.18777468015330245, 0.16533956611221545, 0.14842209754255764, 0.14947009677181033, 0.14443613195424443, 0.5035785523592531, 0.505323783421833, 0.5039080332254233, 0.5178852284976214, 0.5835323725998842, 0.5270669056415631, 0.5358304857486513, 0.4962645943337941, 0.5096740960010129, 0.07425721418465603, 0.08754781150517332, 0.09614164018932592, 0.08247401418053502, 0.09858241563571157, 0.09485512553802111, 0.11152383930623577, 0.0772924698368106, 0.08446504038823022, 0.1399138100085071, 0.12229805771576574, 0.13504527823865808, 0.1610678362610133, 0.13117463885929614, 0.12948820761324153, 0.14634599074531784, 0.13458252574224316, 0.15650854436624317, 0.3095440118570073, 0.3082825260943558, 0.3003707932949563, 0.31931570901020645, 0.3278317214210572, 0.317715131748184, 0.29564875795371903, 0.32597644573299744, 0.38125215498017684, 0.2274302549137296, 0.23947545029810724, 0.23075822486045716, 0.21433723558275253, 0.24934681122162483, 0.21284984570542065, 0.23114808584404067, 0.2508963088059447, 0.2678667462710528, 0.1956862819524332, 0.19901935164544216, 0.17937801089335115, 0.18118307989461369, 0.17884398768271492, 0.19896722899213415, 0.18126718651730234, 0.1980980880811739, 0.1684945671270558, 0.18406571170139896, 0.1695070058110355, 0.18413870098896534, 0.17763814618783058, 0.16787505999509045, 0.171942659460795, 0.17161713977564197, 0.2011101121880121, 0.1703039257006892, 0.1685828409613962, 0.5287753968375253, 0.6656949543733546, 0.17170802313000277, 0.17969638172406344, 0.6831523630955196, 0.12429132770248541, 0.16374942840896822, 0.1794226937616309, 0.19496282544666133, 0.19170013643556494, 0.5983548599097099, 0.19774754583195908, 0.15852224683126137, 0.15722053058222374, 0.20001942872453315, 0.20424728071493714, 0.2081649684882515, 0.19930130077831532, 0.18063298655700366, 0.18227571770028494, 0.17073381441205582, 0.1819880130246646, 0.18143772156453142, 0.17907545266615688, 0.16484685169000113, 0.18770595356366626, 0.06996451674082271, 0.06941236471483314, 0.0722303293311698, 0.05965400143587085, 0.08843959913295907, 0.07873981989721979, 0.0721114263130832, 0.08312329695721021, 0.08037562476672977]}, "mutation_prompt": null}
{"id": "b0496e98-2cbb-41d0-9881-7f12b835fc2d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 4)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.6, 1.2]\n        self.learning_rate = 0.04\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.4, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.8, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with Gaussian mutation and dynamic learning rate for enhanced convergence speed and solution accuracy.", "configspace": "", "generation": 75, "fitness": 0.25803802578801677, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6632284366212056, 0.762287105166688, 0.6950935913362537, 0.7393200569477729, 0.7514991874925318, 0.7558518960885918, 0.7053960984491966, 0.7693534101097323, 0.7465202464546161, 0.2969324432234757, 0.2548981100028256, 0.3255565118272823, 0.29231480525812814, 0.3367855129302667, 0.34068503895933844, 0.34892964661701154, 0.31130058387797566, 0.34822951688182446, 0.09011479093695429, 0.08512899723627221, 0.08996801404670696, 0.08149546004176011, 0.0780641456597666, 0.10204607527494114, 0.1053203137774833, 0.09067822396922187, 0.08653714339928142, 0.08231100145627712, 0.09787752729832677, 0.08887946178219686, 0.09937452058483687, 0.08008850101102494, 0.08398827837868361, 0.07857192818767833, 0.10969440416295584, 0.07390551527728062, 0.9262892818307827, 0.9406026738350481, 0.9349582124142783, 0.9514267672542589, 0.9288038403065114, 0.9183585282183376, 0.9524087279088089, 0.9265743003548971, 0.9427150083960089, 0.3977691991980665, 0.4622040792416108, 0.3352813958949401, 0.42037423811626584, 0.3386126837863249, 0.4264059689990637, 0.4153029874632618, 0.46683894225273503, 0.4273599809481964, 0.25319960981592526, 0.316461442712345, 0.2856904335895599, 0.7501339873900066, 0.3593116575727676, 0.2534454265497288, 0.29618315551961527, 0.6994838883374015, 0.7499203672924406, 0.28750826742534696, 0.13952180511902856, 0.20370776733811669, 0.20704000960104596, 0.20702133906490738, 0.26957908727011226, 0.23264515959440246, 0.20025573531125895, 0.2063262391129741, 0.12704687361586553, 0.2584020961200931, 0.21350079059478344, 0.23031552311592385, 0.11706735937314738, 0.25691790958632843, 0.23015638671048977, 0.21725803054817827, 0.1251238473721853, 0.0069179420725389296, 0.10158086269105082, 0.024040000351645552, 9.999999999998899e-05, 9.999999999998899e-05, 0.09757471010457774, 0.056910403060624004, 9.999999999998899e-05, 9.999999999998899e-05, 0.06483852956499236, 0.04372716999993076, 0.0623025648128549, 0.04265120566567582, 0.058548782791007725, 0.017089030838915997, 0.18260230043691705, 0.15364455205932426, 0.09019008681943452, 0.045925694378002646, 9.999999999998899e-05, 0.10750990046169151, 0.06877786021085652, 9.999999999998899e-05, 9.999999999998899e-05, 0.020103138491747496, 9.999999999998899e-05, 9.999999999998899e-05, 0.07484797591790793, 0.09317786723910648, 0.09690390260141868, 0.16428057559555287, 0.0834234910703735, 0.14883514775245843, 0.11390236090185102, 0.10765095958173676, 0.1287202740596778, 0.47502388423569997, 0.4030225156436118, 0.4841705707380586, 0.436088277500545, 0.5168448295013252, 0.4435976987017862, 0.5251576533247195, 0.4873304428179175, 0.5251265882113114, 0.09224935903712872, 0.09887828596607451, 0.08259620239283372, 0.08576202766535024, 0.0745049602866511, 0.08018941395121071, 0.07441165633320457, 0.1125286550980924, 0.08171884853816935, 0.1664378875656255, 0.18956254914347204, 0.1601235062434414, 0.1356157567005417, 0.16284926626555118, 0.12206008277593605, 0.1270392929697347, 0.19962905461490232, 0.17843223243523376, 0.26614661497062075, 0.2709559007237552, 0.24593748573426644, 0.30446068446197483, 0.34703127093657427, 0.25730169225485977, 0.3597186488881856, 0.26948961404577065, 0.35237982983657323, 0.23416967906298924, 0.21262271464301852, 0.23108434257244748, 0.18110566493220503, 0.19169479101591635, 0.166046606437809, 0.27132082467281093, 0.24367222019957113, 0.20380617785675736, 0.17911089897016286, 0.18523125955621766, 0.1736371052886574, 0.16387092833637817, 0.18928211507134363, 0.1894463655042945, 0.17995732018143173, 0.17288319712698885, 0.18621927973083485, 0.17519732931677734, 0.18299502839819104, 0.17858336177443523, 0.18245127515971726, 0.16662202752351418, 0.1773372597689129, 0.18004606948245105, 0.1822332468482405, 0.17883308502296058, 0.7110941091418781, 0.8686674817686585, 0.1663683482375765, 0.7835686505007494, 0.18725950798408675, 0.17515898975687505, 0.1547454329304886, 0.7839804794650707, 0.1490949246071328, 0.16590424356859634, 0.20264357807632682, 0.1228041540154341, 0.2040655061840918, 0.20342412932248943, 0.19751113064420156, 0.5465953575693445, 0.20308653485960326, 0.2057743972309396, 0.18643524276068302, 0.16743653473126885, 0.17339063645896857, 0.16800348969660683, 0.16903467113967308, 0.178255489650342, 0.19998463920637066, 0.18120657216539415, 0.19095573993592785, 0.06425175203830369, 0.07724120794381739, 0.0633688172895509, 0.06440968206967101, 0.05826771949115461, 0.07469278366342225, 0.07344676819277718, 0.08100422557447051, 0.06793242504231145]}, "mutation_prompt": null}
{"id": "41a2e586-6c17-48a6-87a5-49e379c02e29", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(12, 12 * dim // 3)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.7, 1.2]\n        self.learning_rate = 0.07\n        self.min_learning_rate = 0.015\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.02)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic mutation strategy and stochastic ranking for enhanced convergence and diversity.", "configspace": "", "generation": 76, "fitness": 0.23124924573679134, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6335278917008288, 0.5879357291538727, 0.5854870982050467, 0.6049153459329335, 0.5946906882093455, 0.6352850660538051, 0.6344655963245148, 0.6170531406951594, 0.6223837584453429, 0.27603498553068617, 0.23328291511716426, 0.22907423902190982, 0.26544697421418595, 0.2560724770752286, 0.2413857090757615, 0.232592622350986, 0.2524354292608336, 0.24826371207240205, 0.0858930045327585, 0.0790528783038692, 0.0924795165012876, 0.08373679026444658, 0.09239331835482756, 0.08190316781396301, 0.08605762501029401, 0.08151141409740503, 0.07521450081978942, 0.08409762237269802, 0.07404447624711752, 0.07311544709758733, 0.08192860036124039, 0.07898516253233778, 0.09192029399927237, 0.09574676068714849, 0.0768312554012417, 0.07548759644771419, 0.91287816492016, 0.8890267791902341, 0.8939926266075665, 0.8821190438582822, 0.909015577537467, 0.8901300362850961, 0.9036576532128243, 0.8841201261946929, 0.8786982656426854, 0.29121451264549447, 0.27099355831266203, 0.25034849088077704, 0.2652905425245543, 0.27246283222187995, 0.2721889686715916, 0.1763895192499766, 0.3221068183173258, 0.2979017728677692, 0.46524304766906677, 0.4943520821832672, 0.4520183342488643, 0.5167686013904129, 0.3646353890459727, 0.5167241945997192, 0.29526874300995654, 0.48297203846451875, 0.42148563365035374, 0.17507710864724235, 0.1738246310144299, 0.16229814262116937, 0.12713632290771182, 0.18043344874389622, 0.14181880203834663, 0.20022830160346017, 0.16830078542250215, 0.17168616168829698, 0.18111156452640453, 0.09270232213973029, 0.1576668981400986, 0.15840577210100726, 0.10937250508874563, 0.1606629119501205, 0.10681903268754744, 0.16258813323809518, 0.18546452016108916, 0.10977815487063691, 0.09208155029119047, 0.024366176563546338, 0.11944863082459267, 0.08435622697576606, 0.056627907802005883, 0.032425128384878876, 0.012761540925616321, 0.06633502151343995, 0.07711808838947998, 0.1741138840549682, 0.0708841386328577, 0.20750158132356744, 0.10693849370545938, 0.12742866533262842, 0.19276282077265638, 0.19538807757308307, 0.12116410049380832, 9.999999999998899e-05, 0.014756578523149932, 0.005180704330390862, 9.999999999998899e-05, 0.04095459857546957, 0.0032298628883460356, 0.04766739236062201, 0.02149692837781092, 0.008369142779051653, 0.15843803037345439, 0.12543753480028386, 0.13676423056871723, 0.13640134686365624, 0.15885212014333427, 0.14243132932518854, 0.14655414057567395, 0.13753493787653193, 0.13769849249160748, 0.42907074459018335, 0.46032250994267687, 0.4316962445418726, 0.4503684794659797, 0.4482733231161923, 0.4470439620553869, 0.4435227712296377, 0.45708266237030093, 0.4526386389170217, 0.07855721661506354, 0.0755992426424813, 0.08780549940312243, 0.09712818247956312, 0.07698006860621642, 0.06919345664307364, 0.06705663706085196, 0.07974034083585868, 0.07616661188778073, 0.13871170013426803, 0.14477952876817968, 0.20596722788439703, 0.34709006346482296, 0.1221969430514066, 0.1265874430705013, 0.1413860213021526, 0.14969049278198798, 0.13910206186159135, 0.24568693753765014, 0.2740558701172324, 0.2583363005258309, 0.23954539676769204, 0.23488465493962463, 0.27094540080464335, 0.2757682449974026, 0.28548659850337, 0.227351933486582, 0.18927273062656613, 0.18333003073871124, 0.17093315145991583, 0.20220385022919518, 0.17205432190884473, 0.16017923283866353, 0.21642693290399395, 0.19738737802929407, 0.16149784850103188, 0.16355819382967307, 0.16797051701412513, 0.16098726503957694, 0.1821747035809299, 0.15450894950810867, 0.16073486292204564, 0.19017752375604347, 0.15816916186563534, 0.1860020485350985, 0.18071825242836426, 0.1650702189582829, 0.177374097068407, 0.1637897607561506, 0.16092127251370025, 0.16739014408177477, 0.15932117699138348, 0.19060163332428792, 0.16767706833619067, 0.15775749039084308, 0.3037385741010299, 0.5895695361034146, 0.5006254143817377, 0.18140627975862422, 0.16070940480659868, 0.2519142597074294, 0.14277272666551144, 0.4578822285491536, 0.14571283894451226, 0.16560472314103736, 0.4030467681764137, 0.1535005306096917, 0.17719395459983767, 0.27438514397467484, 0.20930559300422824, 0.2002162908652414, 0.18107327062806278, 0.17256513433768428, 0.17141201609169998, 0.18205836482780802, 0.18831566853760862, 0.17194310448523098, 0.18490647475617394, 0.18397388115842395, 0.1849188284328106, 0.1716998020345365, 0.0802621447926618, 0.06415458138033303, 0.0623391332128127, 0.0757887352872092, 0.06008995345244461, 0.06477280522266537, 0.06414077112972116, 0.059989349096135625, 0.062058475662793544]}, "mutation_prompt": null}
{"id": "631427e3-7bf7-4183-a3b4-763c5e2bd0c5", "solution": "import numpy as np\nfrom sklearn.ensemble import RandomForestRegressor\n\nclass AdaptiveDifferentialEvolutionRF:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n        self.rf_model = RandomForestRegressor(n_estimators=10)\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        historical_pop = []\n        historical_fitness = []\n        \n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            \n            historical_pop.extend(self.population)\n            historical_fitness.extend(fitness_values)\n            \n            self.rf_model.fit(historical_pop, historical_fitness)\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolutionRF", "description": "Adaptive Differential Evolution with random forest-assisted fitness approximation for efficient exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": -Infinity, "feedback": "An exception occurred: ModuleNotFoundError(\"No module named 'sklearn'\").", "error": "ModuleNotFoundError(\"No module named 'sklearn'\")", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {}, "mutation_prompt": null}
{"id": "a547d3ef-a857-4d16-907f-1aca5eabd3d4", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n                self.population_size = min(self.population_size + 1, int(self.budget / 10))\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic population size control and learning rate adjustment for enhanced diversity and convergence.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 16 is out of bounds for axis 0 with size 16').", "error": "IndexError('index 16 is out of bounds for axis 0 with size 16')", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {}, "mutation_prompt": null}
{"id": "cc206e6c-1140-4c37-a68b-f2a190bb5ea7", "solution": "import numpy as np\n\nclass QuantumInspiredEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 12 * dim // 3)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.2\n        self.mutation_strategy = [0.5, 1.5]\n        self.learning_rate = 0.07\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.4, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.8, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredEnhancedDifferentialEvolution", "description": "Quantum-Inspired Enhanced Differential Evolution leveraging quantum superposition for enhanced diversity and convergence.", "configspace": "", "generation": 79, "fitness": 0.2464187790692556, "feedback": "The algorithm QuantumInspiredEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.21.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7098328798436508, 0.6790531479305325, 0.6941275151886097, 0.6946504488184051, 0.6638387311610454, 0.7052081274915172, 0.6913152338280413, 0.6688379544871697, 0.6934043021190388, 0.33103042551920103, 0.28849014707243636, 0.2744958467438572, 0.2866108174478741, 0.2955448242409908, 0.28639790446304436, 0.26636803844577994, 0.3062601412558982, 0.287501580055081, 0.08173739638292044, 0.07957530579497163, 0.09435858407621145, 0.08339162364757247, 0.10491955589566093, 0.0825991025791365, 0.08486812583972536, 0.09313954252716483, 0.07883872775385548, 0.07227803319394444, 0.08715824143438022, 0.08147730051257274, 0.08561630750346882, 0.0961439619616451, 0.07497119070667757, 0.07142904444502907, 0.09990194997336144, 0.08811456167062293, 0.9131206921353596, 0.9237205007230624, 0.9061410824474907, 0.9080534709763763, 0.9265903365804291, 0.8980009111287253, 0.8842184077408587, 0.9242795661249423, 0.9151644145668437, 0.32221428132043284, 0.3250890844370168, 0.31499043444751984, 0.32233724933151187, 0.29737052619957094, 0.3274447980844213, 0.34986408282614334, 0.3083127847572862, 0.21807934292954834, 0.46987854758968284, 0.4716652757998897, 0.26951053541120396, 0.660416676604656, 0.4875162873938039, 0.5337854544707252, 0.32301618996014414, 0.5493468096013623, 0.5668481277833665, 0.20664294674526829, 0.16390919208730337, 0.15905005115399706, 0.1696932651181825, 0.18994243038766967, 0.1866055356036188, 0.1771017347546513, 0.17798765584729626, 0.17926516106671864, 0.0997717796383728, 0.09508663800750872, 0.3197396037299324, 0.10684929226414441, 0.17002048153662108, 0.1999571996333207, 0.1714919985900173, 0.09651485281997885, 0.20436860207614005, 0.06559147323835457, 0.08037655338913319, 9.999999999998899e-05, 0.10573768422214502, 0.08260966854318308, 0.027515162966503692, 0.12452925294748896, 0.1474578930463507, 0.00320967056672139, 0.2081271267040199, 0.14152945357176705, 0.08569015903564592, 0.14012702327796056, 0.15871883675901988, 0.07152856580084299, 0.2072239438659731, 0.21121429284410165, 0.26442668605505526, 0.024212112993345136, 0.015441496955949652, 9.999999999998899e-05, 0.007094426868062498, 0.04672297054212682, 0.014846763364803839, 0.045866105742134455, 0.033063472853102405, 0.05936476495023946, 0.13087756544630813, 0.18745162343569433, 0.1568316800501609, 0.13685704905938223, 0.1750690769069786, 0.1590722338163325, 0.13022935688779003, 0.14376533640438816, 0.13978871568458084, 0.4557969773614645, 0.46153732035385353, 0.43968160416701363, 0.44441580057387586, 0.47434317227425726, 0.4466040587080703, 0.46365584279948624, 0.483147587621819, 0.4531803943593261, 0.07881729123875159, 0.08555166024571081, 0.08310024029431828, 0.08277428018497524, 0.08374284064981785, 0.08326876127082128, 0.08280355789705884, 0.07792454820991057, 0.07336331297174004, 0.1195004446604564, 0.11152427717925506, 0.14325583419140042, 0.12789037796823943, 0.16719128871298383, 0.13991369356167693, 0.13742230265800315, 0.15040774339190488, 0.1433765863386416, 0.29589375691042186, 0.28626075386626904, 0.2865201211000913, 0.28752925480649916, 0.29594259654762867, 0.290095335964375, 0.3374245704895066, 0.3562841490812442, 0.3103963033450624, 0.2317048160666264, 0.19254336064135957, 0.1587818758299432, 0.19939134948516812, 0.20157215982281673, 0.16966427627524738, 0.24393454095125466, 0.23713701440573765, 0.22303977265130448, 0.15528080086137397, 0.16924222094320718, 0.17611231879126477, 0.1823500525602778, 0.1736183204998526, 0.20394674389856304, 0.17253167014238902, 0.15927698556785996, 0.19321153557070236, 0.16387431630973492, 0.18310439020324232, 0.18904849993608208, 0.17698449988462417, 0.1802535684511828, 0.1803272978259025, 0.16687295353595633, 0.1767177491487446, 0.1846944288706449, 0.1888751537773271, 0.15535111188950645, 0.15974262969106034, 0.6506559869528885, 0.18494379892900759, 0.17544970070919697, 0.14818201699072908, 0.13096873528386044, 0.18009420658975572, 0.3906980837770435, 0.1965784574090289, 0.521787779405711, 0.15163186689026953, 0.2819886680319573, 0.19641843077196897, 0.20702879960941034, 0.42653771795325945, 0.20775248586187667, 0.16723807659297563, 0.1919214931363019, 0.18479148915470933, 0.20932327327740952, 0.17348415207750256, 0.17720297092038395, 0.18891196194090198, 0.17444523750746288, 0.2085140947694537, 0.06913267398772038, 0.07211600962287068, 0.058620737093941, 0.07087387317055704, 0.08013442330054443, 0.0608739526107811, 0.07587204323104746, 0.0620016790688489, 0.07372723264508496]}, "mutation_prompt": null}
{"id": "ff6b3b8c-db25-4ff6-b98e-86a4e2b092fc", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 12 * dim // 3)  # Increased for diverse exploration\n        self.mutation_factor = 0.85  # Slightly increased for better exploration\n        self.crossover_rate = 0.85  # Slightly decreased to boost exploration\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15  # Increased to enhance perturbation\n        self.mutation_strategy = [0.6, 1.2]  # Broadened range for strategy\n        self.learning_rate = 0.1  # Increased initial learning rate\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.25  # Increased max learning rate\n        self.dynamic_mutation_factor = 0.1  # Increased for more dynamic adaptation\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.4, 1.0)  # Faster increase\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)  # Faster increase\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)  # Faster decrease\n                self.learning_rate = max(self.learning_rate * 0.8, self.min_learning_rate)  # Faster decrease\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "Hybrid Adaptive Differential Evolution with Self-tuning Strategies and Dynamic Learning Rates for Robust Optimization", "configspace": "", "generation": 80, "fitness": 0.2589301610155366, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6510285559012319, 0.6789919792277671, 0.6559037651774755, 0.6658696220660056, 0.6467417116199676, 0.6580168956943133, 0.6801467640654904, 0.6766107555285904, 0.6914929498378657, 0.31015699169075595, 0.2713855879919822, 0.3064505395220879, 0.3166548094977121, 0.3317944679706829, 0.31980717287466565, 0.2976978019423586, 0.34063761204480747, 0.30456863043790905, 0.1015357873184457, 0.10356348581481511, 0.0948521040587651, 0.08598370866833827, 0.09328561001145752, 0.07787131219814436, 0.10257579135823502, 0.08776558795622802, 0.09582738284002512, 0.09659783432554392, 0.09871584307653469, 0.10573564133902236, 0.08031557759092756, 0.08444151956855239, 0.07616291703374811, 0.0710606434493326, 0.08516579832397508, 0.10404668889146018, 0.9245861847789203, 0.8601305298537512, 0.8697740995252706, 0.9015614272938528, 0.892183914841587, 0.8610654011854418, 0.9170765604092441, 0.9199875457906956, 0.8730768344228405, 0.31500591101393005, 0.3609227510187597, 0.3049437507378959, 0.3222240073958734, 0.2998286183000263, 0.32539217802757725, 0.33922135631537, 0.3650109712203684, 0.3353551836290787, 0.4212951568911478, 0.40091506405575317, 0.47334221080481775, 0.5563874933842397, 0.5722549717887673, 0.5390208362431484, 0.5283337254018377, 0.592832307278472, 0.47848646034447606, 0.18744974607007214, 0.17768927336714024, 0.21337875731764833, 0.20633308279149298, 0.2215363404702705, 0.20137006201194718, 0.1745270172153074, 0.18275439428667783, 0.19551255057616956, 0.07719626333480523, 0.13407688408718188, 0.23219336182999661, 0.2006569734639586, 0.19048527328083642, 0.1836202862172026, 0.19063539568125254, 0.2192427593545495, 0.16452700032688572, 0.13073666681608553, 0.1040542190625765, 0.12253312923965243, 0.13066621242718535, 0.1537995888094167, 0.059220002339029465, 0.12313481438261875, 0.12640430854649654, 0.15107738401106852, 0.21320882866529478, 0.26300755624366556, 0.27806963700560183, 0.18334843347398022, 0.07477207292016685, 0.06726886792285314, 0.25124839284158595, 0.25145902133395437, 0.2882468006902372, 9.999999999998899e-05, 0.015073959687098015, 0.0423192681645882, 0.07967981856703987, 0.0864605788336994, 0.04755187243415293, 0.06386532317446747, 0.07962380454244378, 0.04790890563953287, 0.14626883637003862, 0.16612889359482508, 0.16991324869423585, 0.16380775216119836, 0.18860624049413766, 0.18473800153521347, 0.17974181992357097, 0.15419412233435414, 0.18826810778003966, 0.4528347173121392, 0.5272010094899809, 0.49360160698179845, 0.4932197910592242, 0.4504621493452119, 0.4420699704021427, 0.4754653650262226, 0.49037156244516367, 0.4811732702700836, 0.06867962390666782, 0.08125073685799866, 0.08260731819105915, 0.08250279255324278, 0.10314345937653502, 0.07689413216595675, 0.08387974502344353, 0.07664134658993249, 0.07602768806634486, 0.1431516224339997, 0.16192369944759244, 0.1469197953967567, 0.1529441427411653, 0.14485515245640368, 0.1763095340901042, 0.14448409007192076, 0.14518426012117602, 0.13171995126295843, 0.2887889260322114, 0.2943862148120997, 0.2829246641688412, 0.2805267392936638, 0.297341825603169, 0.2540634834843336, 0.30303827678270034, 0.34691713313847183, 0.292337016099407, 0.22847864165215992, 0.23080105788876748, 0.20147452089394446, 0.21229285781662988, 0.22063205210331094, 0.2227230318180059, 0.24438498181101131, 0.22391388012600155, 0.25137001072462095, 0.17547381719240807, 0.16299746206171584, 0.18075239196358017, 0.1859619100852996, 0.17257154707580102, 0.17797660824514372, 0.2033848902840949, 0.15978318801624825, 0.18333917380079479, 0.16831183136637462, 0.17330981141042123, 0.17341820267207164, 0.17163707717744126, 0.18635151479323064, 0.18449674388237336, 0.16784493313452353, 0.17973039277915592, 0.1642599710335837, 0.14380608102358672, 0.5471120103701053, 0.1500184459467757, 0.1785805432656976, 0.17988986773433424, 0.1678479302845568, 0.15814687765025848, 0.50864268209608, 0.25618357998725505, 0.5351169401009283, 0.20260885184265642, 0.14855914535885473, 0.17092471466091574, 0.6520453779267479, 0.4887128554884125, 0.2094902003338981, 0.20823148813838155, 0.14853789700646103, 0.169885073332396, 0.20253364491437398, 0.17733436084364418, 0.23537451058279957, 0.17892467503146914, 0.17136452669066116, 0.19748551326585073, 0.18259009009442861, 0.16981364070091254, 0.06519298677026475, 0.06356661265109376, 0.07374304313377356, 0.07050314682402115, 0.07017017215799282, 0.06937171342079751, 0.07926028932908014, 0.06652404263858147, 0.06793872223515851]}, "mutation_prompt": null}
{"id": "e4c70879-8f6b-4368-9e3a-6ecb49e8e429", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 15 * dim // 3)  # Adjusted population size for enhanced diversity\n        self.mutation_factor = 0.7  # Slightly reduced to balance exploration\n        self.crossover_rate = 0.85  # Slightly reduced to increase local search potential\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15  # Increased for stronger perturbation effects\n        self.mutation_strategy = [0.4, 0.9]  # Adjusted for diversity in mutation strength\n        self.learning_rate = 0.06  # Slightly increased for faster convergence\n        self.min_learning_rate = 0.015  # Adjusted for stability\n        self.max_learning_rate = 0.25  # Increased for aggressive search\n        self.dynamic_mutation_factor = 0.07  # Increased for greater effect in dynamic mutation\n        self.dynamic_population = True  # New flag for dynamic population resizing\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n                if self.dynamic_population:\n                    self.population_size = min(self.population_size + 5, self.budget // self.dim)\n                    new_individuals = np.random.uniform(self.bounds[0], self.bounds[1], (5, self.dim))\n                    new_population = np.vstack((new_population, new_individuals))\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n                if self.dynamic_population and self.population_size > 10:\n                    self.population_size -= 5\n                    new_population = new_population[:self.population_size]\n\n            self.population = new_population[:self.population_size]\n        \n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution integrating adaptive Gaussian perturbation and dynamic population resizing to enhance global-local search balance.", "configspace": "", "generation": 81, "fitness": 0.2719522766081919, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.871452413282927, 0.8677393704143477, 0.7932719932629129, 0.8758679778727985, 0.8750448023123727, 0.8822884415827048, 0.8643959640376927, 0.8661011427276079, 0.8743860403384579, 0.4529064989214072, 0.41627315966953404, 0.09410515149335441, 0.4651074101364192, 0.04513563608006965, 0.4189248107846608, 0.3859703348729645, 0.3572422501624636, 0.5053746206280831, 0.10064633405447299, 0.12366683072182916, 0.14821218354204735, 0.3724233460463938, 0.1310741841620806, 0.1489787342798209, 0.13657246549055813, 0.1451899460989634, 0.38024026841019476, 0.0968384835639321, 0.3115290365417215, 0.11771657495993548, 0.1335839729573357, 0.07205876291120017, 0.14032938215986446, 0.13615980550847073, 0.12157041333360774, 0.11750825714885593, 0.9527854208072786, 0.9090936730608965, 0.9514950317334655, 0.8796219686722898, 0.9631540245993561, 0.9257922940679962, 0.9058134417570025, 0.9173847481476516, 0.9361483966869352, 0.2337038294468463, 0.2960063371017503, 0.39727531194733623, 0.1594276919287002, 0.5372470891778096, 0.30903786389745336, 0.10856255234354684, 0.11186617174849778, 0.16676308538942752, 0.3377287209300084, 0.824249253353769, 0.1692069601027173, 0.20848188249473154, 0.2694584275512468, 0.21123996485631857, 0.7879799824114366, 0.2280479261094479, 0.22583097761237525, 0.11965644828395705, 0.34876925448200047, 0.15856081971437708, 0.1470337102654221, 0.15534422499663814, 0.14389389380673734, 0.17405140612613035, 0.17575500045083858, 0.2741945608487518, 0.1958410658854265, 0.12991111259336519, 0.21539350028186188, 0.14511502053842795, 0.3177049893572568, 0.23098160994240624, 0.19629332182387693, 0.1779877345841383, 0.22481495473663227, 9.999999999998899e-05, 9.999999999998899e-05, 0.08228668510055814, 0.11140876712078951, 0.19846394986868876, 9.999999999998899e-05, 9.999999999998899e-05, 0.007767797972018653, 0.28020396930254765, 0.16946193111738417, 0.14142828625986947, 0.1476600881148975, 0.0738708843258914, 0.14263389590887032, 0.08877314095540423, 0.2783350229661983, 0.08451452001085924, 0.14338747776802774, 0.1690239170808855, 0.05946937245192074, 0.1678313658350502, 0.1876905294013863, 0.22558748201156564, 0.01763086366914468, 0.17059985674734202, 0.10120639922599439, 0.11381874617738108, 0.12126483958750234, 0.03347555583826145, 0.2004385531673165, 0.10466190959093147, 0.016552072586014543, 0.2959290931848684, 0.15483368197828662, 0.0013000117139435607, 0.24050288115382967, 0.4964983826444087, 0.5045557142271351, 0.4968822287469741, 0.34194931268423157, 0.5064369624241423, 0.5649738584149565, 0.5474458622231574, 0.5363777170628017, 0.5040051037613845, 0.11367454691138446, 0.12678017176428258, 0.12529839025786182, 0.09660972353485198, 0.08545419314384273, 0.12960772295374678, 0.10421279487722657, 0.12118110164761364, 0.09047962204414506, 0.12789295949536628, 0.13153937470206967, 0.2028904871084969, 0.23299067070992274, 0.16454316841958716, 0.14643210739774004, 0.17517626058119318, 0.12732024290177324, 0.1376140313556885, 0.34559723297057465, 0.2563452503469785, 0.3868210644860748, 0.46906601249152324, 0.4301820177056347, 0.4044393914933829, 0.42648430793181846, 0.4433465942189426, 0.4451019244147444, 0.2730423386713552, 0.23193608844936053, 0.3398079730052417, 0.27237810861077627, 0.20655937102642308, 0.28383091177062847, 0.30242468560130775, 0.18358410001237557, 0.2047259957704317, 0.21805762081099478, 0.19332356070174106, 0.18658441759434996, 0.1981375836377285, 0.19792276126158925, 0.1739439667957553, 0.17844039362624076, 0.20200762608313616, 0.17699902198536477, 0.2063399753844154, 0.173551414234004, 0.2155808507571575, 0.19378245862085597, 0.19283924745051284, 0.18140601348166352, 0.20504028303198651, 0.1785918976700921, 0.264964134984377, 0.2057860465117528, 0.182864538400071, 0.16171292118796177, 0.1769885523296254, 0.19772669717749203, 0.1672527362239118, 0.1636603650017847, 0.8599698683010429, 0.15960760889638803, 0.1666674933450415, 0.1657488940874402, 0.20207932214881108, 0.2293872085383406, 0.1674304950055896, 0.18457925470638925, 0.17056934826155867, 0.16173277987398782, 0.6100697766161522, 0.18265233529960778, 0.1942794681052541, 0.18047735973668477, 0.18070928696971789, 0.19269948650873558, 0.19455686563986652, 0.1805985677828441, 0.18157004981534297, 0.20523919056048, 0.07664248288904874, 0.0866023873834243, 0.0812889324785252, 0.0647231982201183, 0.08097318462214675, 0.07364551351907322, 0.06735244997598988, 0.08890887682404414, 0.07992269001944619]}, "mutation_prompt": null}
{"id": "cc4eb247-e833-4bc3-8c95-88e98d68ddf2", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(12, 8 * dim // 3)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.2\n        self.mutation_strategy = [0.5, 1.2]\n        self.learning_rate = 0.07\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.15\n        self.dynamic_mutation_factor = 0.03\n\n    def __call__(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            diversity = np.std(self.population, axis=0)\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                else:\n                    new_population[i] = self.population[i]\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            self.adaptive_sigma = min(max(0.1, 0.7 * np.mean(diversity)), 0.3)\n            self.learning_rate = min(max(self.learning_rate * 0.9, self.min_learning_rate), self.max_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic scaling based on population diversity and mutation probability modulation for enhanced global search.", "configspace": "", "generation": 82, "fitness": 0.3037754885188624, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6796561236964247, 0.6665816919337385, 0.6896164205530897, 0.7096168896003119, 0.7024379540705522, 0.6976760442233539, 0.6970878774645828, 0.6747651880240896, 0.731944460754723, 0.27742259253705037, 0.28115367935179103, 0.19046925339416243, 0.35146197588185646, 0.2639600554564622, 0.2824672752084879, 0.3071829547474564, 0.2661159024768053, 0.27384259905126573, 0.3137554197004141, 0.10310383326033479, 0.13519348348953408, 0.13699734911374217, 0.23270676175728322, 0.29276786024298984, 0.20708384421341708, 0.14841741005767906, 0.16739504264809935, 0.11330821007204073, 0.1201802861849397, 0.1279234133344206, 0.1280286248744944, 0.10327126197202485, 0.21825795139067694, 0.11364926498702865, 0.12231867789633177, 0.10144815038974797, 0.9126011799391196, 0.941057697842354, 0.8772050256095819, 0.9077670318620794, 0.896453302401578, 0.9344468344991235, 0.9011151577747586, 0.9144011511338616, 0.9182058804699834, 0.4596911833992453, 0.42407811195488576, 0.3857768854328182, 0.45849610828304244, 0.39354743636268463, 0.43961832703353065, 0.42361368726722315, 0.43778874869155093, 0.42250832399087823, 0.37913309651802807, 0.7655488887109826, 0.3553565067027633, 0.7308771906365117, 0.7608040385997454, 0.7914119515587523, 0.75337744402224, 0.7591632609682648, 0.7594963628640579, 0.1795451096864228, 0.1762211823398504, 0.3013656303343655, 0.2660492436041123, 0.19995038121706132, 0.11712186368224409, 0.21825798901305593, 0.23062727940707117, 0.3891627827031853, 0.16940489352646948, 0.12028926857383704, 0.14354441459751577, 0.27777168677492714, 0.38555087671699184, 0.3048480871840813, 0.2762871916326245, 0.2681549094176099, 0.31947685795764835, 0.19617063594999185, 0.1521752223902324, 0.17804667471235303, 0.1471349953499803, 0.06332512241539057, 0.13530747735277038, 0.11161027962366477, 0.1337993925595149, 0.06351314047064693, 0.18597196626074186, 0.1869550676728433, 0.2324892216140001, 0.1331158923398933, 0.12077394323344393, 0.0323479600708404, 0.08944330944866596, 0.15614799594768447, 0.23994728611872684, 0.08804953845495289, 0.1143045570120097, 0.15875390142705126, 0.14848872865914786, 0.10225715589472906, 0.1289777501713646, 0.18501283539732072, 0.07030734657931315, 0.06928776196660225, 0.2124108478704414, 0.19613069245692527, 0.21619918984233277, 0.2152972926410497, 0.21926138017999897, 0.20985604181168482, 0.2172949105184927, 0.18051437124853453, 0.21984560426890953, 0.5742434267809531, 0.5522452701905018, 0.5395248426335575, 0.5464418266627393, 0.5297058548364355, 0.5167296873398652, 0.5333551490479949, 0.5669177153707717, 0.547232200552324, 0.11105753919742178, 0.08942102930533602, 0.10007017399626006, 0.09640844503345491, 0.11213545496047661, 0.12713310192766514, 0.1059226480935398, 0.24740143080583488, 0.09669651406640256, 0.23251912022383114, 0.15811860038202963, 0.14364777647669502, 0.1356111662102325, 0.36197732529390136, 0.16370006365549727, 0.16406333165489562, 0.16571485619542103, 0.23153847960754526, 0.39758549236975205, 0.37674546553101473, 0.3573178619828724, 0.37707228992383945, 0.36391333069848997, 0.36828646374221685, 0.3815867767430755, 0.3643096532882357, 0.38994186094667016, 0.29358927493876563, 0.28959035240984954, 0.2888572048879775, 0.2882291877719083, 0.29323635764694955, 0.19012185323976205, 0.25203876669176584, 0.3028908450608563, 0.30795529915542863, 0.18377487082024468, 0.17277999581145764, 0.18527888805660297, 0.2049860835727162, 0.18612387542500752, 0.16898930557786063, 0.2028884040225395, 0.194063596486573, 0.18822131537983278, 0.19667934966376255, 0.18708651339021098, 0.18490847866756455, 0.19786181948966786, 0.38975817836893534, 0.20738596918623797, 0.1892381523974458, 0.3190604373839738, 0.21559794957214673, 0.8265849458683244, 0.19422974818821703, 0.1533116068654533, 0.17065990709863832, 0.18196719956627816, 0.7466640381185712, 0.20374194603806206, 0.18128393021567935, 0.15325400476448847, 0.7008221530648162, 0.20143773230553808, 0.682165574698682, 0.16352064371189268, 0.19346448207119582, 0.20042731976090233, 0.19458882873980943, 0.7987514544526542, 0.21074448746280583, 0.17563398970417077, 0.1817844345999522, 0.2032533213217116, 0.19308068843816883, 0.20189687483246999, 0.19730368661918585, 0.20834506504395822, 0.2050951004733782, 0.1965165293672786, 0.08286951103967533, 0.08240700569246018, 0.07814384966743837, 0.0894071967392811, 0.07436218229315361, 0.07325119001191271, 0.0656317144975288, 0.08117289619383972, 0.07328399290054732]}, "mutation_prompt": null}
{"id": "07fbda92-5db0-4a8d-97c1-32d5b6a2b40e", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.4, 1.2]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def tournament_selection(self, fitness_values, k=3):\n        selected_index = np.argmin(np.random.choice(fitness_values, k))\n        return selected_index\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                index = self.tournament_selection(fitness_values)\n                a, b, c = np.random.choice([j for j in range(self.population_size) if j != i], 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n\n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive convergence control using tournament selection and dynamic mutation for diverse exploration.", "configspace": "", "generation": 83, "fitness": 0.31631231574739194, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7760277789578107, 0.8266853265555706, 0.782444420636526, 0.8278668689301464, 0.7573515630122684, 0.8259695444253772, 0.8041868646168073, 0.777154034713078, 0.8414097610308029, 0.39111266771951236, 0.4127095204619119, 0.3577390390875608, 0.356002004506617, 0.392170420129904, 0.40042170748346084, 0.4026150296702846, 0.36651694109147626, 0.4795059234773018, 0.1169708679055147, 0.10739654026284173, 0.0888806877320596, 0.09650271121169518, 0.09688653556101212, 0.10507516119758964, 0.09437552404569083, 0.12175403565071719, 0.10201064326033937, 0.08642942256058361, 0.090929929533755, 0.08876004037545648, 0.11184550353587452, 0.10880418247327128, 0.12066529293912298, 0.12379805361489504, 0.08394483498932004, 0.08474105023526846, 0.9352714213196436, 0.9113233125643686, 0.9170147512387028, 0.9236825708540753, 0.8755138861848207, 0.8618999031933932, 0.9254377756017957, 0.9173150299596181, 0.931089463214313, 0.4585433840174161, 0.4137615440769761, 0.42001359966473606, 0.4751855480935445, 0.45143573262914327, 0.46328379639091277, 0.40303816192045316, 0.47074201928351844, 0.4519640888780815, 0.7612189475966309, 0.6541048035883685, 0.7911312777692135, 0.7759220217698499, 0.780128839020619, 0.7474150940182553, 0.22626631822397347, 0.7567204379080049, 0.7860999514936903, 0.1872978608811262, 0.3986949014439801, 0.23359546824283528, 0.26894482101407, 0.17402560921693055, 0.17304249533446814, 0.12753091599805244, 0.19871268693654087, 0.2625434719814824, 0.15143081467976172, 0.23252815749213396, 0.15800301677272988, 0.15803759238411408, 0.3435921268119607, 0.20129238368943903, 0.3556387653138158, 0.33482238562491196, 0.4672302940303884, 0.24925410555075145, 0.1521442014951735, 0.29749362186770345, 0.19103972175415662, 0.11036321010650152, 0.042856115301784126, 0.29109548295319587, 0.14320242634947478, 0.09938120162750708, 0.3084266914707354, 0.3830015251902589, 0.17259420837766026, 0.31652974903374675, 0.13521624447541358, 0.32693213550760125, 0.20133764712611968, 0.38996028928532067, 0.30979475795914424, 0.07318271607658366, 0.0925767306245785, 0.15376597680631543, 0.1405642656837217, 0.20186299979812816, 0.21871273440658856, 0.12182697768877004, 0.08517382862534195, 0.25530770255045754, 0.23715740642338168, 0.16984901280609244, 0.2505473380499489, 0.268331154664775, 0.2636433432582711, 0.24784339937091948, 0.28639798397204963, 0.2482720363151114, 0.2439532449591839, 0.5286661412818354, 0.5882612964739711, 0.5630894828257195, 0.5829728396606972, 0.4738486178862993, 0.551118085508846, 0.5484078475058554, 0.5572206789256531, 0.5568358349536906, 0.09255102807632376, 0.10513313769910382, 0.09875494781307026, 0.08790985698419662, 0.07546049553931411, 0.08658163523585316, 0.08957663053190446, 0.08556334431868218, 0.10437794928318911, 0.15346885361920648, 0.14605088668794142, 0.1468426078718128, 0.2919575843629064, 0.4630921857102398, 0.47408260496902, 0.19514096463826192, 0.3462164615352924, 0.1531536005284896, 0.4056503510430767, 0.37973163270676746, 0.28282550823010455, 0.3566091994647925, 0.32631839022078823, 0.4411812984859562, 0.42750510634535177, 0.42332534087210394, 0.40225674161257075, 0.3239922372282297, 0.3298124564371756, 0.2975826393361194, 0.3128960991925811, 0.2815205699211516, 0.21102285634756468, 0.20634885568891748, 0.3300302409061535, 0.27503921220969096, 0.19361265630753488, 0.20800416509132835, 0.18528691959843124, 0.19614498063340302, 0.2115150029173778, 0.2013700643340388, 0.18738742746163228, 0.17687301644288722, 0.1972312714683484, 0.17486003951783735, 0.19403775757597164, 0.2363078480055668, 0.1775000658308018, 0.17858276915112115, 0.1715386151288738, 0.1876013125164322, 0.2274355407653592, 0.19343702445762878, 0.17194983002196262, 0.7540687326924886, 0.1300091952900102, 0.18384916989838662, 0.18324473231276273, 0.7764054010111162, 0.14430418672455558, 0.1565624720666543, 0.18307280702371254, 0.16307629227795895, 0.20527169859078576, 0.20429015545320406, 0.6595007225476348, 0.2032541739604964, 0.20674287772521616, 0.41765544502210683, 0.12599470584696515, 0.20231270868180184, 0.20256442681798903, 0.18351753334578347, 0.18619162954701884, 0.18979071255075497, 0.17979077325978088, 0.181351712618388, 0.19425970352847666, 0.1768798730451736, 0.1961644210658703, 0.08307843191701925, 0.07233224344918765, 0.07437205677283076, 0.06694087921471492, 0.0745924544837806, 0.08224239468321815, 0.08050850268691812, 0.07948758041110926, 0.08937868158304263]}, "mutation_prompt": null}
{"id": "361946cc-17ff-476b-a5cd-686a819f7fec", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)  # Adjusted population scaling\n        self.mutation_factor = 0.9  # Slightly increased initial mutation factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0, 1.5]  # Additional mutation strategy\n        self.learning_rate = 0.04  # Adjusted learning rate\n        self.min_learning_rate = 0.005  # Adjusted min learning rate\n        self.max_learning_rate = 0.25  # Adjusted max learning rate\n        self.dynamic_mutation_factor = 0.1  # Increased variability in mutation\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.5, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.8, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic mutation strategies and self-tuning crossover to enhance global exploration and local exploitation.", "configspace": "", "generation": 84, "fitness": 0.21431002622297143, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.5193726309231398, 0.5630772199485969, 0.6172597273676226, 0.5902622073352444, 0.5925348022094235, 0.584865325604271, 0.6163553668943507, 0.5778689433932267, 0.5710721066609403, 0.26153074558732736, 0.250007148405453, 0.2650527889316723, 0.270047420436074, 0.2620221512928509, 0.24675753491273789, 0.28583791397017244, 0.27332370011450646, 0.266058449488505, 0.085235143864828, 0.09114527262748018, 0.09043388021211429, 0.10964195969221058, 0.09511005945458417, 0.08030717983854319, 0.09039657427339076, 0.09629483404356032, 0.09160676043494076, 0.0943192934995446, 0.09339162092567588, 0.08559857258629877, 0.0765797680871354, 0.09169049705846788, 0.08837575356045035, 0.07886376253633098, 0.10358974484708217, 0.09643386238627505, 0.8922335143039646, 0.8660065008127508, 0.909818437739937, 0.8493834101464106, 0.9096718356789734, 0.8965630238723433, 0.8485261464755145, 0.879758650211288, 0.8758439439133393, 0.22424650321002282, 0.24963526317731777, 0.22040502635299886, 0.23974970394224426, 0.20019062904571816, 0.24302778835071914, 0.23173326318987952, 0.22406574748707409, 0.25926141448718987, 0.3669797653072052, 0.40917081311481773, 0.3963699559374131, 0.4057906152836419, 0.39821735600157715, 0.43959631337287786, 0.35396422422200513, 0.37146486781738397, 0.30789555676072256, 0.1497388242246962, 0.10407001130334759, 0.14162255004747182, 0.11895032551720919, 0.1472702610370532, 0.14363660126374944, 0.12952893246760555, 0.14054562547994742, 0.17025936488964621, 0.08796381449907809, 0.07566878233750418, 0.15415041317558043, 0.13169377336783705, 0.1583221596542902, 0.14357526046292002, 0.1467503110101528, 0.11570891928865024, 0.13097248932902406, 0.03987589741120412, 0.037376964954292324, 0.04314172018199003, 0.013809373533385405, 0.02355843292174209, 0.009308215115845675, 0.023214222257147754, 0.054244187521449216, 0.05823302858618884, 0.08115639990053036, 0.056420223515788015, 0.08411955855131836, 0.06402494032737072, 0.0866249692823492, 0.1351925991342745, 0.17017173930124008, 0.10969046823999329, 0.16695967394415734, 0.020592473082251983, 0.007513948209742716, 0.0048074728353662, 0.008029460976614278, 0.022809542840739216, 0.005476643655160318, 0.004318871744805941, 9.999999999998899e-05, 0.01084055547423557, 0.07801252711504125, 0.11470112535385235, 0.10521248170035358, 0.09820260148554738, 0.11040360719955045, 0.11121294106814439, 0.09859675934209522, 0.12783738960397173, 0.11097471542304016, 0.44307399761438604, 0.41654936844314394, 0.4157579672359034, 0.4347386444195961, 0.4179621892927782, 0.44680025018045033, 0.41626285360568005, 0.40184262894307277, 0.43149542594913626, 0.06927638036685146, 0.07245107149743013, 0.0829321186227322, 0.07603623631176448, 0.08266134943011949, 0.08154454018634405, 0.07678324157554539, 0.07308288924484041, 0.08552131605271629, 0.13112313710129497, 0.18055511833883242, 0.12018025418069178, 0.13184598945612602, 0.15440240907164893, 0.1415017303919781, 0.14063319920935213, 0.13340851900816164, 0.15747742952981203, 0.23538391971962525, 0.23310340177622557, 0.23899024032558513, 0.2238679181162494, 0.22484304063767802, 0.2681115573230156, 0.2714081625482787, 0.26233948036506094, 0.30163982657585786, 0.16685357372123522, 0.17352217732507946, 0.1830889400603044, 0.1840228633996911, 0.15935296207463356, 0.15062335887634404, 0.2084995540401775, 0.20508873389530113, 0.19871180077203576, 0.17545498134244975, 0.16029061634596564, 0.17958398157302946, 0.1655057877281343, 0.20912482647872932, 0.1580900169833247, 0.17015687623778053, 0.16835601170014092, 0.17930055629481845, 0.1705400638339648, 0.16342641979918604, 0.16195282121373344, 0.16095094793767095, 0.18610201430064455, 0.16625192352215468, 0.1662396170030972, 0.17448977449626668, 0.1744059474005466, 0.4000559364635152, 0.1620657748749047, 0.15721406879515798, 0.17080244048888038, 0.16617803555456034, 0.32005256477692734, 0.17803006143477507, 0.15400860005259198, 0.14999490938857651, 0.18873241580134414, 0.3315112209050044, 0.26581117618700245, 0.21241535252379695, 0.19117748166452986, 0.15815679650921988, 0.20511642575919964, 0.19673294658781948, 0.19864943107147892, 0.1658838835927332, 0.17603625668204492, 0.2023349349278739, 0.17698885303231204, 0.1916483207250156, 0.17821264327676178, 0.19275077482632574, 0.1825444533326016, 0.18085419285611948, 0.06536309626735515, 0.07996245171489536, 0.07143351597058623, 0.05235440658812496, 0.08866179681075903, 0.07598076307791202, 0.06442255578337375, 0.07152056510363003, 0.06264646498281257]}, "mutation_prompt": null}
{"id": "74233861-acdd-4f16-bf8b-b086d3130033", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "bbbd36bd-2dae-470b-b5ac-4230cae21c7a", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.2]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with dynamic mutation and local search to enhance convergence and diversity.", "configspace": "", "generation": 86, "fitness": 0.3263393422381237, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7676490699447114, 0.7677471844823511, 0.7910413224956213, 0.7791188871936934, 0.7958662661083011, 0.744994967746685, 0.7878117020890879, 0.800144849268464, 0.7643500542257832, 0.3682644380479966, 0.36423446004976656, 0.36166349465270575, 0.3754536868253826, 0.36678186720983974, 0.3738883107859655, 0.41055048941959327, 0.41335318236761665, 0.36228257017585097, 0.08357993004309916, 0.12300188851073057, 0.1045981927868308, 0.09918288403667141, 0.11175936526232877, 0.10082881763071205, 0.0908449237421537, 0.07863981827211575, 0.1366421404424445, 0.11366683168485525, 0.104191746461746, 0.12227983421879851, 0.09191224113078933, 0.0770193099600579, 0.08945675376209816, 0.08666319204878714, 0.11745484012238738, 0.11136564273767435, 0.9144313102663671, 0.8155954563117872, 0.9504218649062417, 0.9491717304149376, 0.9500687900198908, 0.9074071622002275, 0.9476927862426746, 0.9187798245945141, 0.939681037832976, 0.4143048712958888, 0.39681620135104156, 0.4330916979829863, 0.4873683232243148, 0.4845309175652823, 0.44732450539758095, 0.454542549610352, 0.3740329841541846, 0.42029396707868605, 0.7434495999651749, 0.7780275771521414, 0.752986914310729, 0.7281200456456574, 0.7606132870613673, 0.74446082864752, 0.7205244237475047, 0.772867297093363, 0.6914943195812319, 0.2338407665604405, 0.32630726071534966, 0.26839233112894023, 0.32282776762553167, 0.12650015403656212, 0.12139265381601794, 0.34847766640969513, 0.23666857899689464, 0.40509742044718, 0.5062075226545283, 0.1745387236484015, 0.08963300335891167, 0.2708056317542151, 0.26915604277496574, 0.1633709520885399, 0.23811357135481748, 0.19994209324740175, 0.3541164946653236, 0.27091027204784723, 0.21081016417455556, 0.26703636766089633, 0.14897476318241876, 0.3548162334681577, 0.313895888904532, 0.2191042559395966, 0.19304259022039816, 0.2890617080619008, 0.2292403506954841, 0.3156835496901057, 0.3411841446627536, 0.3662062925480233, 0.30605947349502916, 0.3515017639640039, 0.3023837386398055, 0.39375938023149004, 0.3291423926577587, 0.09926851980960472, 0.07341383346694164, 0.13973293632909556, 0.14513010299539564, 0.19674587917767983, 0.1923162272107406, 0.20728458576989284, 0.1410338077979464, 0.07368087862915162, 0.2443871755512742, 0.2780517074373111, 0.2503572599892102, 0.23320940315121297, 0.2355324834374669, 0.24827137441152913, 0.2474928268901906, 0.24433488016340665, 0.2105045147872313, 0.5198554707743976, 0.5688668346928847, 0.5679741037328869, 0.5341349025070969, 0.5258159451900974, 0.5804026295743686, 0.5557624456886934, 0.5796585737975675, 0.5438616887364236, 0.09090854550217298, 0.09576685112108807, 0.09119061896851566, 0.10540774539200937, 0.083894597000985, 0.07418678142593238, 0.0912043381965143, 0.09221377528526131, 0.08616377842178768, 0.16732959401276626, 0.3608065027800156, 0.1523494800495646, 0.14618130071310897, 0.19030085880903003, 0.15255557874131154, 0.18770542967627968, 0.2388415616373709, 0.12313511517563436, 0.323736660235051, 0.3890414096854482, 0.38177465485927353, 0.4029430712197336, 0.3923644742132255, 0.37870025127110285, 0.37822924301969696, 0.4218811803029011, 0.3631806041825477, 0.25549590349064943, 0.2946264311929555, 0.3200727496516472, 0.29969097639835274, 0.28667654885184723, 0.28975191696285907, 0.21178828326228172, 0.330787030440034, 0.28453493630278803, 0.18911430967601017, 0.1732541426075963, 0.17776204601072854, 0.17520090152980228, 0.19336289324330713, 0.21039657724843153, 0.1816290599810092, 0.1859191759474722, 0.196159103107998, 0.17046008419136593, 0.1933204520690045, 0.1621349348410962, 0.22600363002168433, 0.17607569725439842, 0.17363156527266843, 0.19849267441775087, 0.18876745935957007, 0.18938681123144496, 0.7985387123721748, 0.7478404126538167, 0.16863605690110506, 0.16545730972140116, 0.18429627013693517, 0.1879395746034217, 0.5985514564931884, 0.1833754566509903, 0.8358038380628607, 0.20588234200093014, 0.20558171388210744, 0.5706562109893676, 0.5729677032738805, 0.7146890640571013, 0.15715682929968067, 0.2065291630870637, 0.20377535753750198, 0.11876089301971315, 0.1681339994653216, 0.18264987447819092, 0.16742186777159984, 0.20323848751668594, 0.18226485214042099, 0.1786453867353912, 0.18678144045420852, 0.19461929382073961, 0.19469680948565382, 0.07836581884987337, 0.08308973288469113, 0.08200224166611081, 0.07596606421771235, 0.07942774433072863, 0.06974870892205398, 0.06742926479115263, 0.07333427604767895, 0.06688501182369422]}, "mutation_prompt": null}
{"id": "48a93c34-03af-40c6-81c6-066e840554a8", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "d42fd2d4-5252-4f01-bff7-b3af29704bdd", "solution": "import numpy as np\n\nclass AdaptiveMemeticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(15, 12 * dim // 3)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.2\n        self.learning_rate = 0.07\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.3\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + dynamic_mutation * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                local_search_improvement = 0\n                if evaluations < self.budget and np.random.rand() < 0.1:\n                    local_search_perturbation = np.random.normal(0, 0.05, self.dim)\n                    local_trial = trial_perturbed + 0.3 * local_search_perturbation\n                    local_trial = np.clip(local_trial, *self.bounds)\n                    local_fitness = func(local_trial)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        trial_perturbed = local_trial\n                        trial_fitness = local_fitness\n                        local_search_improvement = 1\n\n                if trial_fitness < fitness_values[i] + local_search_improvement:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.4, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemeticDifferentialEvolution", "description": "Adaptive Memetic Differential Evolution with local search enhancements and dynamic parameter tuning for robust performance across varied landscapes.", "configspace": "", "generation": 88, "fitness": 0.21330864054803042, "feedback": "The algorithm AdaptiveMemeticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.20.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.5438934800517372, 0.5277297531415128, 0.5177098974309113, 0.5950777532221623, 0.5809995523894597, 0.5699198177522969, 0.5194545092216126, 0.552445878745339, 0.5494831031841609, 0.23365865340198744, 0.12238710877212833, 0.27578429657671, 0.2574912218509421, 0.2707874759398573, 0.24008616425595297, 0.24675391748306463, 0.28012444929721914, 0.2505287488865112, 0.07814690205374841, 0.10593486392296747, 0.08675600326345123, 0.07697328840161755, 0.09568895869621041, 0.0884829888951959, 0.10240459725804996, 0.07527938911537335, 0.08161357362762933, 0.07121109410520277, 0.08147165692995806, 0.07046996295917507, 0.09786864704707532, 0.07133633777221715, 0.0946827034098191, 0.06778134119201418, 0.07631366490761338, 0.06252797389578535, 0.8892560667056896, 0.8957008661730755, 0.8599412153897721, 0.8726621193597917, 0.9152919557748113, 0.9478328265301931, 0.9149748876366369, 0.8813498190363449, 0.8976274067344135, 0.26229962792758266, 0.22063225077259963, 0.21892909798182558, 0.25265329068405284, 0.26203621027621027, 0.27467759539133796, 0.2376661502248265, 0.20252116901184158, 0.17112521939493874, 0.36614405930425686, 0.20876388233039056, 0.2749527581076756, 0.5141041102785798, 0.5958653683777155, 0.4834230383807461, 0.22191393219491806, 0.2562432588446113, 0.5162172940355791, 0.16414000118190375, 0.1719747528411414, 0.1385250573490957, 0.17236590024853227, 0.11747622004933256, 0.14253524326766942, 0.1620095722520677, 0.1558529270458896, 0.14249450863404, 0.12502939818477465, 0.10881412822142633, 0.11097851196238295, 0.12697402013788128, 0.13286196642021209, 0.17788330643329042, 0.11170474518619633, 0.10086517414237584, 0.1559327339522042, 0.007366762332914778, 9.999999999998899e-05, 0.05416246267547753, 0.028467890342872115, 0.05966180212789984, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.062841671333144, 0.07977961988959126, 0.09212225452170475, 0.0803364750613953, 0.035323890904379374, 0.055026142646341425, 0.1883916795001146, 0.13245383735122118, 0.15417522966425679, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.021703627742314713, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12149749342966243, 0.10494844373961043, 0.12287523575777737, 0.13830303239088448, 0.11626254890382803, 0.13277549905161345, 0.10675073361995568, 0.12440619164258382, 0.1487042658421458, 0.4228542281328286, 0.3692632600630752, 0.40233375317090025, 0.40839944563181296, 0.42101020274854717, 0.4265984703590041, 0.39465063521423316, 0.39728744966517215, 0.40485598675824175, 0.07177053853875881, 0.07636457548113207, 0.07923997000069938, 0.0714653311678145, 0.08076198255779132, 0.08034728066842323, 0.07082152373715067, 0.08840460266162242, 0.092029799526955, 0.1818518512960322, 0.18211956402037022, 0.14164765736450757, 0.1825219186377237, 0.16856359317419445, 0.12430426813299833, 0.1388572127391755, 0.11627710228885257, 0.15858335001803703, 0.2377860458959603, 0.23445702926313783, 0.2712132622833987, 0.23746630152692727, 0.2286635378204348, 0.21932447007846734, 0.2485246586875126, 0.24148194276166224, 0.2676991170047378, 0.16205492631122376, 0.18739184345753657, 0.1759590289467725, 0.1841390134816424, 0.19290567384406532, 0.1796861400574018, 0.18016905895197055, 0.1693890780925571, 0.187670412728967, 0.19420181666903114, 0.19085655565528536, 0.16536784776456903, 0.173693533785498, 0.16951060095983872, 0.17515479924167354, 0.17708553980056674, 0.18590928080819635, 0.15740829651315835, 0.16490779603109873, 0.17377882238982545, 0.1706563089859584, 0.1731847085980649, 0.16523420564096647, 0.1787841806137953, 0.15959037778187413, 0.16575394136974608, 0.16404268920984633, 0.5791679940701486, 0.1743892027488808, 0.166150316797272, 0.1656807595151064, 0.5595327880777011, 0.16957107422614848, 0.16790762075076981, 0.17619484650112827, 0.16178374204687807, 0.4375400221486476, 0.18840359624461422, 0.18609756862148163, 0.19664442836277085, 0.20359642435437786, 0.17887743352539764, 0.20609168505632358, 0.205612913206207, 0.14640258087590519, 0.1903788717126097, 0.17338199282099342, 0.19277012634520208, 0.1732964854651825, 0.17473390914054376, 0.17519362050817344, 0.19823897689470704, 0.19669023987807133, 0.16714397120589441, 0.06449434466092685, 0.06762475138351931, 0.059229523822536434, 0.06677447846483697, 0.06667068189285541, 0.058725278251149704, 0.06578066296034246, 0.06780703388839415, 0.059677851280258265]}, "mutation_prompt": null}
{"id": "fdb0592b-3a85-4fd8-838f-7fb543de92db", "solution": "import numpy as np\n\nclass AdaptiveGradientDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.5, 1.5]\n        self.learning_rate = 0.1\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.3\n        self.dynamic_mutation_factor = 0.1\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        gradient = np.zeros(self.dim)\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                gradient[:] = (trial - self.population[i]) * self.learning_rate\n                trial_perturbed = trial + gradient + perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveGradientDifferentialEvolution", "description": "Adaptive Gradient-Inspired Differential Evolution using dynamic learning, mutation factors, and gradient-based perturbations for enhanced optimization.", "configspace": "", "generation": 89, "fitness": 0.22585988860040693, "feedback": "The algorithm AdaptiveGradientDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.5139562833590342, 0.4914699850238903, 0.5342334085923085, 0.5176302694932992, 0.5439042822954809, 0.6176555521423548, 0.5508887849857309, 0.5245223437434546, 0.5040570332492358, 0.11145224650655305, 0.09976851166748579, 0.09138377766578576, 0.085379619870941, 0.1005195410644183, 0.0591549546951301, 0.10629653108945347, 0.16395778653707316, 0.08344174326035625, 0.09866034055033612, 0.09255248096622493, 0.07689386601371295, 0.08612257366845566, 0.083683035380828, 0.07486564689386521, 0.08185586206392159, 0.07612219813060528, 0.0772693076433234, 0.08054856538350852, 0.08622117702834653, 0.0834609378257084, 0.06786389997334297, 0.0770330493106901, 0.07824784603510526, 0.06303268442813037, 0.07718378293358841, 0.06558686158538263, 0.9051408851640148, 0.9271523800892261, 0.9921970763449961, 0.9112268214458215, 0.9845266008478463, 0.9360554967162356, 0.92003547981843, 0.891801746829215, 0.9271038630708657, 0.3164468331090551, 0.277986095728857, 0.27984439379079606, 0.31037695730333914, 0.3202793144042444, 0.32529216496643754, 0.2654140001495967, 0.31271461303999293, 0.28497756927105145, 0.6484336116915262, 0.34510118120130506, 0.60595557417201, 0.7803407793900158, 0.7329640358259444, 0.20234642190418595, 0.36219470894005434, 0.72067020135791, 0.5984260536463399, 0.22487162032512176, 0.11973112795725172, 0.19498281931284023, 0.2165213663585308, 0.1886004485587478, 0.17713211237810955, 0.21624904404342737, 0.18613441399798825, 0.19762790645195583, 0.18053512186133025, 0.14268532890349594, 0.1305830374209418, 0.1831997391010216, 0.1945527162188594, 0.21704833192710926, 0.16634344245891297, 0.20669508731306208, 0.16818156050355393, 0.04869832706583688, 0.033272225491690954, 0.04702424378756054, 0.06331621493809692, 0.005673197101784377, 0.054405038716487275, 0.030531799700956097, 0.062044753117199036, 0.09408533277937225, 0.11815911980580163, 0.04001888330934944, 0.08166367407434405, 0.08913124953434104, 0.05932911850847977, 0.10994183257064583, 0.07622593140800549, 0.05256688354085304, 0.09201129769594207, 9.999999999998899e-05, 9.999999999998899e-05, 0.021038987475159976, 0.04043523967705609, 0.0013598839687166686, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007395815469983025, 0.12266135428516978, 0.11283855110787067, 0.14262831852629898, 0.1636933233482316, 0.14842759003825245, 0.1498607515411603, 0.13032339568430507, 0.13158898808226238, 0.13233303064553414, 0.4362718545651504, 0.4218876490643354, 0.44069173624979974, 0.43892976351421864, 0.4381926836187293, 0.4266632207446337, 0.4007081393331088, 0.4458578791570149, 0.4306331897050145, 0.07927734449791224, 0.06098839895408725, 0.06478250387708506, 0.0672774286906126, 0.09506377254291032, 0.06510215682267595, 0.062329746472394976, 0.07267998526960151, 0.0876904969179193, 0.1332035499567502, 0.16076692013219596, 0.13956265279205093, 0.14459521229767247, 0.11628618531945356, 0.12982415633473465, 0.15061155988319952, 0.20633817304913393, 0.127404243275818, 0.2741248724382299, 0.2850536401929463, 0.2975748249621012, 0.28385592747637356, 0.2835046022558322, 0.29417096628893347, 0.28556339638960604, 0.33277401725069156, 0.3052491846008516, 0.2300739350360682, 0.1928947665285019, 0.24726319388794904, 0.13995428920485464, 0.19904299853033702, 0.1894263187531382, 0.24585789891693488, 0.24666113679496537, 0.19795895914248363, 0.17936556495868916, 0.1785192647613285, 0.1912804883022311, 0.15569865143149142, 0.15271429866148267, 0.16280037128692637, 0.16783042104623214, 0.1629745050330983, 0.21081808860761708, 0.16739205453443806, 0.1683869609504387, 0.16497947123711032, 0.15796353559938847, 0.16615697562962084, 0.16165562286928836, 0.17582203099482518, 0.16424719616720973, 0.1792007234499986, 0.7288512644300809, 0.13244870263156205, 0.16945625754414972, 0.17367458789129053, 0.18310269115218625, 0.1201571029802957, 0.20181541857184637, 0.1540819350280208, 0.15326308288424573, 0.16348468235682356, 0.16698030349709714, 0.6197054003009212, 0.18956258240271107, 0.1888412407336032, 0.1977356369133283, 0.2035661510268827, 0.20859454579956604, 0.20348175678277958, 0.16308204746938848, 0.17717490206379038, 0.1663306412358455, 0.17672546874701056, 0.1894328235765994, 0.17095546884708002, 0.16984352728737717, 0.1937658701065199, 0.19932146741319334, 0.06710787108993777, 0.07496500162852282, 0.058650748239494566, 0.06484273306970567, 0.0645611892592226, 0.06407282744050591, 0.05870673765320367, 0.06327825538764831, 0.07494204766964796]}, "mutation_prompt": null}
{"id": "1ed4492c-8e37-44f0-8d93-1be9be4e7967", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n        self.dynamic_population = True  # Introduce a dynamic population flag\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            if self.dynamic_population and stagnation_counter > self.population_size // 4:\n                self.population_size = max(10, self.population_size // 2)\n                self.population = self.population[:self.population_size]\n                stagnation_counter = 0\n\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (\n                            self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n\n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with stochastic ranking, adaptive learning rate, and dynamic population size for improved global search and convergence.", "configspace": "", "generation": 90, "fitness": 0.270164336986953, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8230675998058066, 0.8391334341537859, 0.8531264308256621, 0.7248970932124565, 0.8309819034299453, 0.8163237743353767, 0.7541105993543772, 0.8441249519407142, 0.7909717190507051, 0.31182200382367553, 0.34329877199865555, 0.3781286233341188, 0.40292825247097386, 0.4383250068618053, 0.4048246334191473, 0.3847443477804132, 0.05800736616908486, 0.057845697505304106, 0.17608943435546065, 0.1378451735935079, 0.09675254727184435, 0.10913981454940636, 0.13684512927517756, 0.0751843195830274, 0.151644190058013, 0.11916938632510432, 0.1101264843162324, 0.14586718447182845, 0.10670966641508672, 0.07371873929838657, 0.10079238872431384, 0.13545011818370045, 0.10452021084255136, 0.1334383107530439, 0.09113231179706183, 0.10478714990965432, 0.8765206808474232, 0.9117390142133049, 0.9532340255414946, 0.9198776078051596, 0.9716946928871026, 0.9058969069516034, 0.8949321425606679, 0.9359433568389157, 0.9290375886489552, 0.15713254181671032, 0.31101638180129876, 0.2716236883486406, 0.5178786780729817, 0.3885815547238113, 0.45523912298238867, 0.45109256702781286, 0.551473876718553, 0.4092318992480424, 0.4450424704760346, 0.3144018233059922, 0.37213478774167785, 0.1919076722467935, 0.20583937176552092, 0.2980411246099961, 0.3209641998110273, 0.17386236529626187, 0.3813430698556344, 0.15027178131411278, 0.16963116711560344, 0.1711754228340766, 0.1280326451297391, 0.1729812767523754, 0.2058265863395109, 0.1466780236107308, 0.13619147649938768, 0.18459192124960666, 0.13136201233656752, 0.14976912012832688, 0.1316627890319011, 0.17428644459406462, 0.24585411039192218, 0.2822498416005301, 0.11923221941420781, 0.15283246896796898, 0.13287297952989707, 0.0022370813540897316, 9.999999999998899e-05, 9.999999999998899e-05, 0.06537425596178925, 0.033490871215796636, 0.06629823673174251, 0.0605954963078007, 0.23644184194741413, 0.10780558242001248, 0.15458574338807407, 0.34285302764789516, 0.18879864934286372, 0.12628114027635784, 0.07353558854085784, 0.07968534599535737, 0.09688546538021459, 0.21061828035897145, 0.19768851472076054, 0.06166542077446879, 0.06373729969760955, 0.08948153507346923, 0.09195698910876615, 0.08012271721867148, 0.2608715470337225, 0.026039824719357396, 0.0813317053364151, 0.16231965505878854, 0.2457158801622209, 0.26195945448578417, 0.26710229710046496, 0.227010451654444, 0.26384887414430147, 0.05984892999373914, 0.1230385018865573, 0.2001054719910268, 0.2339755578490318, 0.4980373325644185, 0.5655501404121477, 0.5367187858340341, 0.5194311641424721, 0.5024598694070272, 0.47477291191107374, 0.6067957862105862, 0.5117831744616357, 0.518137387294656, 0.1489290905030235, 0.09894994067525242, 0.07232373339403397, 0.09786988402935914, 0.12044589279921547, 0.15228684083886945, 0.10778275769176326, 0.0778467247488579, 0.10308052643476862, 0.24079683650357708, 0.12639408035311628, 0.2202870475424965, 0.23920568704192058, 0.12991369700522737, 0.11988711518667661, 0.15154842316860162, 0.20205838513804752, 0.26559112176834276, 0.44482886716688685, 0.37419297550623365, 0.29785526354547365, 0.3742634134698515, 0.2239837162439582, 0.41527646796953044, 0.1962464314838388, 0.4086516239468848, 0.41943231481245724, 0.25117085828255115, 0.23924310074974187, 0.30138887911933887, 0.19066393167736462, 0.26977096955910473, 0.2008534158066997, 0.2769324337956063, 0.2405163543337131, 0.20052146565353302, 0.21847436504550688, 0.18582132434629295, 0.17750063648074355, 0.21078125481314558, 0.1948048422082611, 0.2000509027645656, 0.18038884987258696, 0.19092668671835455, 0.20494484170328708, 0.1818033010767246, 0.2414569511558965, 0.20265850683935926, 0.19119856679400637, 0.18512087373229902, 0.21977545901644435, 0.20184157174500528, 0.19245268589159448, 0.1754487515055354, 0.6744045521435561, 0.9035739430943017, 0.1553573448544614, 0.17036743061903747, 0.18385199417774312, 0.16946179076766643, 0.19690370969293858, 0.2041889218920272, 0.14346355106957254, 0.1644436474900458, 0.20128806665470234, 0.4058272312107658, 0.8594654475183136, 0.19267232061333117, 0.1544565207544094, 0.11188278642898108, 0.11421390102990203, 0.14433683884621173, 0.16881355161277878, 0.21509834752828605, 0.17966257705501554, 0.17864874199601521, 0.17326824387202544, 0.17185368267330814, 0.1715455758065838, 0.19755675531314543, 0.16781108619016727, 0.09290179112679742, 0.09057035872097763, 0.08592770834241092, 0.09141653774175829, 0.08064060670663276, 0.09556305757208028, 0.08442135385114669, 0.08064698393407344, 0.07829513532852539]}, "mutation_prompt": null}
{"id": "37a5c286-2bf3-465c-a325-a00539ba590c", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 2)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.noise_factor = 0.1\n        self.min_population_size = self.population_size // 2\n        self.max_population_size = self.population_size * 2\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant = self.population[a] + self.mutation_factor * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                noise = np.random.normal(0, self.noise_factor, self.dim)\n                trial_noisy = trial + noise\n                trial_noisy = np.clip(trial_noisy, *self.bounds)\n                \n                trial_fitness = func(trial_noisy)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_noisy\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_noisy\n\n            if stagnation_counter > self.population_size // 2:\n                self.population_size = min(self.population_size + 1, self.max_population_size)\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.noise_factor = min(self.noise_factor * 1.2, 0.2)\n            else:\n                self.population_size = max(self.population_size - 1, self.min_population_size)\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.noise_factor = max(self.noise_factor * 0.9, 0.05)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic population adjustment and noise integration for enhanced convergence speed.", "configspace": "", "generation": 91, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 25 is out of bounds for axis 0 with size 25').", "error": "IndexError('index 25 is out of bounds for axis 0 with size 25')", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {}, "mutation_prompt": null}
{"id": "b9d21244-9af2-4b34-91a9-788415b607bb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.3  # Adjusted max_learning_rate\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)  # Adjusted learning rate increase\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Enhanced Adaptive Differential Evolution with probabilistic mutation/crossover tuning and adaptive learning for dynamic search adaptability.", "configspace": "", "generation": 92, "fitness": 0.32479965030523694, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8067425417741725, 0.7851797569087601, 0.8059149838708068, 0.7950372470093185, 0.7899879037144284, 0.8142896037911744, 0.7889755190888386, 0.8140794282710191, 0.78567189368136, 0.40913208599362483, 0.37224999024819283, 0.3592008148675694, 0.39076941247878316, 0.34414550840847236, 0.34224159311166213, 0.3650114392366708, 0.38415917680150513, 0.3460876840841738, 0.08758252270863942, 0.10720800681220066, 0.08195988831980938, 0.35847867775283637, 0.10145340005080272, 0.12049533569544257, 0.105201423085591, 0.09437473873015079, 0.09245468970286186, 0.08724750708805262, 0.0881783047210194, 0.095107868925143, 0.09775100595139297, 0.08560070010109555, 0.08407577111167974, 0.09984776785741145, 0.08837069734143665, 0.07890001396122537, 0.9026586973728742, 0.8907511258958781, 0.9506142392553693, 0.8960600087860934, 0.8974097993888259, 0.9009740735733391, 0.9216546367255352, 0.8527521959561013, 0.9253623198795058, 0.4419716972845489, 0.4401531822966457, 0.45329750519083223, 0.4112189348060533, 0.4652488816754716, 0.43769279993859256, 0.4516186672781476, 0.46780258731810476, 0.3471500085775453, 0.7441851393444163, 0.7415004272931791, 0.7530775750324996, 0.8096140563793426, 0.20000579354507886, 0.7669518814513736, 0.7725792782407359, 0.7669948100988235, 0.8168092315191703, 0.2274093989433391, 0.14920813202915506, 0.3659197519245251, 0.17680860203033721, 0.20277349467505412, 0.24716875448783882, 0.206780010132532, 0.1979815748864866, 0.21710905071341424, 0.15933900941755452, 0.41644540303565014, 0.05941538659210677, 0.19114241639332252, 0.2304803401342751, 0.2729585514236039, 0.2629313305809986, 0.1944352146832251, 0.2449185172040892, 0.12732664454842557, 0.18047166582747687, 0.30151201781211545, 0.2750899006458447, 0.13137395356787385, 0.35669737620895725, 0.05085075351117596, 0.2698437005415243, 0.2911329989659782, 0.23913279225426198, 0.280513476284582, 0.34141425135500203, 0.12273022636255615, 0.23990119030762203, 0.29254376004983207, 0.3426467320394908, 0.3461886608819126, 0.24150081483152697, 0.06725722055172445, 0.11502378360577181, 0.06783346105250843, 0.14141764608545326, 0.07164688957571907, 0.04297967324460228, 0.13374280198458677, 0.17852927936165996, 0.153008123311433, 0.23730776469083403, 0.24178203090298445, 0.258848246468531, 0.24362059782753642, 0.2604849927138766, 0.2532126612526694, 0.24270783079020442, 0.25150830468922314, 0.24121025139029162, 0.5863627569404216, 0.5940349280684045, 0.5719319778379428, 0.5324879061436041, 0.5498477884839068, 0.5337607321724795, 0.5466540495448954, 0.5931963033155189, 0.5132391425099943, 0.10839089039318917, 0.087201925174347, 0.07348777999384948, 0.1622950562748081, 0.08149671583824669, 0.08727186721294, 0.11210687953317722, 0.09706760104460377, 0.08137439954761927, 0.15695720168319316, 0.12818717608096353, 0.19486349970829164, 0.1414043967001558, 0.1261217543036235, 0.12989584306455815, 0.20302933586307015, 0.2225215523456724, 0.18466215472908243, 0.3994319574702878, 0.2825736833755965, 0.3864546909135296, 0.3710183899385725, 0.36645612563469177, 0.3592666637706379, 0.40782131078376294, 0.4231176253831679, 0.3953140000327403, 0.2727047903607791, 0.23065734429960127, 0.3022011153460006, 0.2794781434696102, 0.29142423743086643, 0.3487160548819145, 0.31002448630982715, 0.35834574870519886, 0.30845419879770763, 0.2070140634061629, 0.18965220504328772, 0.1913374506576061, 0.18685892331744014, 0.19627540883914452, 0.20328565179117153, 0.1932758146614294, 0.18314616254659466, 0.1881099341895658, 0.19065876955328198, 0.1747507997343457, 0.16253264002613887, 0.1668516995796836, 0.21071239623740257, 0.18234788410655178, 0.17016412945837056, 0.17258429003680942, 0.16565320750361, 0.8579213073463411, 0.18327858389522822, 0.15093389611621932, 0.8250079784457782, 0.18837215330296375, 0.1595278293143938, 0.7762898367307836, 0.6810014712185162, 0.7596805718571906, 0.8242500766288232, 0.2036374622565863, 0.8368899443311659, 0.1644031511512729, 0.15605960428858712, 0.6675363774598679, 0.2034955667424786, 0.20639076511218835, 0.7239008145901185, 0.17958593790685318, 0.16774335853971933, 0.17246228064782787, 0.17540058884518062, 0.1656538911109885, 0.18551823155858627, 0.17315300417471702, 0.18238496523933567, 0.17434604614274374, 0.07537126607559164, 0.06877381980971009, 0.07032241697561326, 0.06542146081824862, 0.07075230641285946, 0.07820308034387835, 0.06888074156414403, 0.06541459083669632, 0.08474360389364388]}, "mutation_prompt": null}
{"id": "1d478232-47a9-4c7e-a461-a76cbf0a0005", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "fc8677e4-91d0-40c2-9e61-c5f9c0bab873", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n        self.chaos_sequence = np.random.rand(self.population_size)\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + self.chaos_sequence[i] * self.dynamic_mutation_factor\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.chaos_sequence = (self.chaos_sequence * 3.9 * (1 - self.chaos_sequence)) % 1\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution integrating fitness-based dynamic mutation and chaotic learning strategies for enhanced convergence.", "configspace": "", "generation": 94, "fitness": 0.310775147846991, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7900050834624582, 0.7807577212198736, 0.7683782721989638, 0.7611450311101513, 0.8067531914193423, 0.8020379053199294, 0.7427331754233493, 0.7852124478990437, 0.7846042179678165, 0.3828796510228646, 0.3813130050760414, 0.37976282217546053, 0.3651352671671979, 0.37346204088144175, 0.3992095258341193, 0.4110530937772139, 0.3995917923215023, 0.4255627786611995, 0.11662175639837546, 0.10187179197601204, 0.08808098536762954, 0.11170004176290371, 0.09962767117271976, 0.10251234962881395, 0.13146281726545805, 0.13590529192800238, 0.1305389664171649, 0.08844577759421068, 0.09693241837272637, 0.08867633854173529, 0.08240034658061901, 0.09009502982888462, 0.09938075363503862, 0.1318502805069537, 0.15001352922288136, 0.11954417021842911, 0.8541157415260432, 0.8960939900387168, 0.8584258118098846, 0.9364297278055588, 0.9306606773645318, 0.881468927746931, 0.8886409793878507, 0.9124692678117023, 0.9161681052953794, 0.5075414113834906, 0.47701283683763307, 0.4545689888267799, 0.4222262835502689, 0.4375644926841995, 0.48163372259032444, 0.4522655366635283, 0.46192116285949314, 0.4738450936954135, 0.7337443107369354, 0.7784148034644306, 0.7974235980356268, 0.7384858421167579, 0.20560483989992162, 0.7316098289702582, 0.3553221849287821, 0.7816414504064602, 0.8181341159491285, 0.24358124159693106, 0.2887221240149819, 0.2679961525765351, 0.12764785270303414, 0.3928392597875042, 0.24768182849746612, 0.19266978575886662, 0.2070148700452218, 0.19562896248002648, 0.16730503987599565, 0.08342252992235877, 0.22290901748692027, 0.2715626289566919, 0.17939087260446507, 0.23010669851873422, 0.4617769986496597, 0.18926942402650582, 0.25193641295736957, 0.3344901333787156, 0.10327006744538647, 0.24728743874723058, 0.13383847013632344, 0.30948738346897064, 0.1661183541215112, 0.3083309923381722, 0.277726314136696, 0.3396577226775055, 0.3220617404067484, 0.3210412922247863, 0.35672128317560625, 0.153893777132743, 0.08554133769482508, 0.3410991622182129, 0.4033266049926001, 0.3400982890948099, 0.30814273814273596, 0.08736290138544134, 0.15161077283359248, 0.036125172430992225, 0.15337860914359314, 0.18574311432574075, 0.14422395185162717, 0.15491814345595345, 0.17633849423072812, 0.11923598066404051, 0.23494856524494157, 0.20967519880580632, 0.2526889444071744, 0.28084573419916237, 0.2624576210055235, 0.26715264606112976, 0.2543431586610059, 0.2574132054731747, 0.2656909805982073, 0.5602320598539188, 0.5540125387518351, 0.5349188947820658, 0.5863132037672183, 0.5836747358951717, 0.5411266248799104, 0.5612136365440166, 0.5534108729189806, 0.5834667622515042, 0.10225530352044532, 0.08333656786034538, 0.08449705197388702, 0.09259652635610505, 0.09534139076361081, 0.08855155044017049, 0.1221968405144247, 0.09797579915096744, 0.10732643331476244, 0.14915461832575516, 0.16263369735028677, 0.13954055612902683, 0.1381099616501268, 0.16905349934477198, 0.149275039425809, 0.20489403958580366, 0.19374613052474865, 0.19781764339059282, 0.4104400701976789, 0.37740565612912025, 0.40505947034653134, 0.3671597641090196, 0.4034199489596817, 0.3795689622387747, 0.3787844683277849, 0.4083417001266799, 0.4199089829625885, 0.33263565369007897, 0.31210782958431604, 0.3146462492849169, 0.26860589506270394, 0.34067766731048565, 0.2607831303911782, 0.21884501185661442, 0.3389133626584214, 0.2583522095774059, 0.18988752214388338, 0.16857182738621646, 0.18518430761460125, 0.21077476306133913, 0.1910904906319304, 0.179352115240607, 0.17472895018310775, 0.18948926861133442, 0.19905003787095388, 0.1924681586696162, 0.49441846217132723, 0.20103466672856252, 0.21962689804610358, 0.21241406475341396, 0.17888486183799757, 0.20426732907918377, 0.529344001336957, 0.17920943680913315, 0.16912247420216586, 0.13288921733343162, 0.139885878951429, 0.8533769292360376, 0.1907406203012949, 0.1755011872553336, 0.1785150820970104, 0.16555536777779523, 0.17064426843610203, 0.20054751298660556, 0.20388098072114758, 0.20466475766124326, 0.20570934272444674, 0.16312815603822783, 0.1984770463504858, 0.11964093728773151, 0.14864099319331947, 0.19694427516497026, 0.18603262698832979, 0.1958850324830793, 0.17131411306515876, 0.17953918946241687, 0.18037160737029867, 0.1787534681885592, 0.18618056803542238, 0.17916543214963476, 0.17346292070147828, 0.07898684994048799, 0.07103611671317922, 0.06201819543722775, 0.07342658530864898, 0.0807672177454275, 0.0901533734479002, 0.07247890241677846, 0.08498707318886878, 0.07644339181862636]}, "mutation_prompt": null}
{"id": "10c77f70-8ff6-46e2-b3b4-c2fd3a6a1201", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(20, 20 * dim // 4)  # Adjusted population size for more diversity\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.3, 0.9]  # Adjusted mutation strategies\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.005\n        self.max_learning_rate = 0.15\n        self.dynamic_mutation_factor = 0.02\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.1, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.05, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with adaptive multi-population strategy for enhanced global and local search balance.", "configspace": "", "generation": 95, "fitness": 0.30157646225545487, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7464951685940836, 0.7295727675209263, 0.7617284137695436, 0.718452412135056, 0.7922857919940576, 0.7693026484477596, 0.7721620233316843, 0.7103656566780578, 0.7591633480061215, 0.4450827283024119, 0.39350158563522497, 0.403676469306661, 0.390739963147121, 0.4284523137575411, 0.41085108197757214, 0.49511152053680285, 0.41211849184168836, 0.39759556340055935, 0.11815223526485075, 0.1324519423012056, 0.10541606291840233, 0.09564993276025047, 0.12474401710828276, 0.13448637332863034, 0.1028867551095698, 0.13703647549776232, 0.09693432019466286, 0.11520813266994412, 0.10244065584152162, 0.1361047378184621, 0.1051711704241739, 0.0985883253846569, 0.0880383060563148, 0.10853627151385659, 0.1296807055333471, 0.10019299824046468, 0.8386554559814482, 0.7855684002845573, 0.8112149196716554, 0.920961243355747, 0.8337583869427064, 0.7954222136748594, 0.827723332188202, 0.8880699637963504, 0.8113183265289918, 0.2927749707276672, 0.28506173181442684, 0.3320192855623212, 0.34745753820021397, 0.27699732298712654, 0.3309815947926613, 0.3835547578982743, 0.33829732112759725, 0.323602215593106, 0.6896586060149092, 0.6575020175840885, 0.5676064633620408, 0.7844350694638396, 0.6895797610265785, 0.7947259425996537, 0.7719415702581863, 0.7017555627707288, 0.7579024343798607, 0.419806061079359, 0.2566384963492314, 0.2229768630090746, 0.3572874684866649, 0.16785199391051642, 0.14591622623393052, 0.1589695595834253, 0.1669669647537244, 0.23798371070169677, 0.19288546181802635, 0.3396517946361223, 0.316701941881507, 0.19230489076910018, 0.18540956976479717, 0.1247418065795608, 0.2206946197994859, 0.19251098517645926, 0.18809120556409842, 0.1738586325479844, 0.2930532707402309, 0.04210727359474509, 0.03704478360399566, 0.22146989205961587, 0.22603312151044241, 0.05411637945250891, 0.11644722295857157, 0.23792364180115788, 0.3767164580480291, 0.3278596091595014, 0.257298439207052, 0.40777276828038544, 0.09303557235382509, 0.08747912269741609, 0.3951667294155242, 0.32741390360475997, 0.41741624237480823, 0.06668838668676857, 0.08372125359466975, 0.1535223284795746, 0.16435494668859063, 0.17426201315102863, 0.077603918579628, 0.2104755579642965, 0.11525876386209188, 0.18708483451158386, 0.24509606437260012, 0.22607719840214036, 0.2245627437147537, 0.2530482229976173, 0.22614101858889002, 0.2741328179362926, 0.23196152384946722, 0.20731298100962325, 0.2372396820029089, 0.5769614953500976, 0.5399244206201104, 0.576204922799628, 0.5777521205307921, 0.5613650339190418, 0.5799685120876381, 0.5872946954386883, 0.5397026840877283, 0.5848689786212941, 0.0947943678000207, 0.08634352231360476, 0.3094161395405426, 0.1090913201401712, 0.09650571665327246, 0.11480739031215648, 0.08900970072850178, 0.08692549600676247, 0.10113196114794465, 0.20398223556624173, 0.22006252301812235, 0.17445974751151894, 0.1371569099598008, 0.15933616890172886, 0.1476850736993327, 0.21327528382397998, 0.1875630061108421, 0.14743120230400386, 0.3699336725488511, 0.4032960128260169, 0.42071099435357173, 0.39132611388872396, 0.3718790952786052, 0.37932402046144875, 0.40473722162749126, 0.420737208223822, 0.41222388343305794, 0.30694626802076974, 0.2676816882533831, 0.273210233659813, 0.2824635609501003, 0.15623868162967192, 0.2665135906855174, 0.33996320566012705, 0.31395946676478037, 0.3309328445274833, 0.21475184424828053, 0.20845581583885575, 0.18493592470833575, 0.20964986968795996, 0.18667284352831715, 0.19896856720487976, 0.1982739895730481, 0.21191081491619745, 0.19968669563987895, 0.18452530165548586, 0.28154784067586014, 0.20715463414663982, 0.20886510183650076, 0.19203631218933404, 0.2930567810265732, 0.19270373010963338, 0.4434769740612432, 0.27962204073482533, 0.16719985230014978, 0.1543017354429188, 0.1496147132013268, 0.175578395347586, 0.18203987238109143, 0.17629485946330936, 0.13132436790264035, 0.174852126861054, 0.16783692409680206, 0.6783563356224716, 0.19976724805625112, 0.1962241747543907, 0.1975413268473991, 0.12288645135012555, 0.4590505831440014, 0.20406236239980924, 0.15228432716392615, 0.1519889380059487, 0.19232113711741972, 0.18209682658460769, 0.18106090095851646, 0.1670522582176005, 0.17830727157301574, 0.16736299988166925, 0.17249408826167834, 0.23710656528182839, 0.18774840669915094, 0.0784445566019536, 0.07140168223715104, 0.08276181196345223, 0.08037712969495947, 0.07091478949115448, 0.07140858437084685, 0.07197654380976093, 0.07499539417241319, 0.07501611751432524]}, "mutation_prompt": null}
{"id": "3ca7f69a-00c2-4276-b293-161ae67e1541", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(12, 12 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.6, 1.2]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.5, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.7, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic parameter control and fitness-based population adaptation for efficient exploration.", "configspace": "", "generation": 96, "fitness": 0.27600142270497646, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6673597217426566, 0.6324436847831864, 0.6542176023917581, 0.7032107026523262, 0.6637944898233464, 0.6644522742583632, 0.6468373226274386, 0.6921502034799993, 0.6740897896411233, 0.3161747873545354, 0.2850140133161765, 0.2772258809581759, 0.34864618113136747, 0.32091752737293877, 0.3086980801939281, 0.3123085468035446, 0.34925191459272886, 0.3211143081815385, 0.08178746768045075, 0.08816338888528097, 0.09029337335761389, 0.10456152093658144, 0.08587773122998021, 0.10735106347865309, 0.09477667953502311, 0.07808393455887219, 0.09585376723401695, 0.07739438046712188, 0.06772152141693422, 0.07836000477963057, 0.07806167538330977, 0.10662393343929566, 0.08709897574662684, 0.06880717305463024, 0.0827270000728404, 0.08124083076076916, 0.8696222958915079, 0.8848594646738854, 0.8592215580659934, 0.8981572096434769, 0.917836419977611, 0.8848508087207546, 0.8816964833637193, 0.9186483711391816, 0.8439664934284511, 0.3065479139190971, 0.3297209510035992, 0.3058810253078109, 0.2986813971922888, 0.35064400409586227, 0.32518970873589237, 0.33840868225443044, 0.36109739379754635, 0.3647798674643573, 0.604080360348133, 0.6604633718533199, 0.5182550969135461, 0.5721855195009637, 0.7117756039916184, 0.6172853283783988, 0.6635423200422824, 0.648127258277488, 0.6554117436069011, 0.14085736885536737, 0.2599429461396616, 0.21850871030239793, 0.19410499064986042, 0.17603070352551253, 0.21499542816357375, 0.20508872812332046, 0.21696621717681763, 0.2252479042685167, 0.08966220514929768, 0.12071459578716803, 0.1890826290237213, 0.17878851045945643, 0.2649626165409663, 0.1935563543797887, 0.2370074753873017, 0.19386962548953612, 0.1553946311324833, 0.1731994958060955, 0.18074852105580652, 0.19597719281039638, 0.21212316137613363, 0.16726177655225072, 0.1855505599706715, 0.2022641769700998, 0.20158474240380997, 0.19236126833974665, 0.26382651892824516, 0.26642873000887657, 0.26820665294861346, 0.28697410096713405, 0.2467480486577387, 0.1561233815257279, 0.2912507022016766, 0.2702154081760646, 0.305395540998735, 0.03600562400626439, 0.06558487444022376, 0.0687912665489997, 0.07975090915307281, 0.0789439257568243, 9.999999999998899e-05, 0.05653223838836652, 9.999999999998899e-05, 0.08709026197136027, 0.1866577968015355, 0.1931054894542492, 0.16587063274110025, 0.17236827509585706, 0.21319687243023777, 0.16981153122976633, 0.19879790830702027, 0.19480015486958924, 0.18054133331294886, 0.4777436592503941, 0.49854497297441125, 0.4946202380081318, 0.5004706880725369, 0.5063266810142886, 0.5046789090511594, 0.4884467682862277, 0.46469155815746976, 0.4993403370987187, 0.0789580300943753, 0.09960957856474784, 0.07281240534628886, 0.08994807094713198, 0.07436536843029318, 0.07559523080578545, 0.08084998129941123, 0.08558418924448907, 0.0909668194621589, 0.15036014243854512, 0.2044018731470283, 0.19666461561138704, 0.21651824567962108, 0.15615595766805923, 0.1927826457733065, 0.23516160467473868, 0.2094331539616312, 0.12770048849119375, 0.2891779977444229, 0.297284486207115, 0.3219494881887073, 0.27027556670174013, 0.27456083432348555, 0.30774446978428605, 0.27030058396286727, 0.32987997699048277, 0.3058107452405606, 0.25470531070710367, 0.20983915143104814, 0.2793030359739489, 0.2083618808238129, 0.21251282086324086, 0.21799262987674806, 0.2528075063983619, 0.2406585480158453, 0.23581236067944478, 0.1838636491792125, 0.1970522807140186, 0.1696554639756117, 0.18633676399217503, 0.18383840792501893, 0.19636125953111738, 0.17684465816602712, 0.17328540383132496, 0.1624783437931121, 0.16716828942955253, 0.17832732028894538, 0.1739399802749384, 0.1670942883897999, 0.16795736225089952, 0.17224339238473618, 0.1766380196581505, 0.1761976972975119, 0.1716688309152964, 0.5984716863537413, 0.15356728616904602, 0.14809304707083704, 0.7183958513955435, 0.18524698380330284, 0.7086519358461176, 0.594899989747433, 0.36552799095803823, 0.6286046511010226, 0.1593737089541677, 0.16471738671178704, 0.19480538260904967, 0.1862607536446491, 0.196391149983284, 0.3629228512488586, 0.20773920650541144, 0.12097851469042853, 0.15194333342065058, 0.1878631045300947, 0.18395364429911465, 0.1735296151846769, 0.18006597403639502, 0.17699636268004182, 0.18320588239722124, 0.19838378378478305, 0.1784318188099362, 0.1740496635097819, 0.06460267639836204, 0.06626734583542004, 0.06892123117107762, 0.07756797866702947, 0.07781512615225694, 0.06952818892498558, 0.06867301290220762, 0.06737165000364076, 0.0671286956394499]}, "mutation_prompt": null}
{"id": "abb83f3c-fbf3-4bfa-9b1d-5f109b93c6e7", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.1\n        self.mutation_strategy = [0.5, 1.0]\n        self.learning_rate = 0.05\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.2\n        self.dynamic_mutation_factor = 0.05\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.3, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.1, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.75, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.85, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution using stochastic ranking and self-adaptive control of mutation and crossover rates for improved exploration-exploitation balance.", "configspace": "", "generation": 43, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.8079451027650578, 0.7974549801604278, 0.788315103303868, 0.8041814395024904, 0.7803315527189609, 0.8035467432877113, 0.7891999005272794, 0.8158068067021349, 0.7850811995307554, 0.40171599129860214, 0.4289248097766768, 0.3723090702471137, 0.4030399530046257, 0.3568057985640587, 0.4029063824248964, 0.3808430968262574, 0.3707080635951273, 0.3556783625428038, 0.11407919974736158, 0.10361024967704247, 0.0842997314107704, 0.3995568650689979, 0.10927405689954994, 0.1637299450134002, 0.11161217215238262, 0.3332533908401938, 0.14166530819087897, 0.13046215267471273, 0.10531353634237073, 0.09433966740912869, 0.1162896930716244, 0.1120336228247657, 0.10487720123190358, 0.10831064741833174, 0.09268931951843695, 0.09315856052672844, 0.9026586973728742, 0.8905961879610733, 0.9506142392553693, 0.8960600087860934, 0.8974179289876903, 0.9009740735733391, 0.9216546367255352, 0.8493253414938441, 0.9254250488904994, 0.3845641613580686, 0.46705982129160806, 0.4344891572532581, 0.3656648777502235, 0.5035113172895421, 0.4350684751451216, 0.43444774345132753, 0.4376096402240328, 0.3839440852481544, 0.7397876765879186, 0.6843032389870047, 0.7238244603271895, 0.8096140563793426, 0.18227437438611993, 0.7669518814513736, 0.7195941598700426, 0.7345270565733919, 0.8168092315191703, 0.2752390072898362, 0.22300801664158876, 0.28091483111689053, 0.1718596949617811, 0.20462819879090965, 0.33593549702849657, 0.250701335027141, 0.23016980312929636, 0.24419846554152025, 0.17792734767526563, 0.4442976649724878, 0.06320262028780999, 0.2574535161826954, 0.26485606377913173, 0.3328277572290498, 0.3666843375692578, 0.21621641705741035, 0.29686796664262705, 0.15193502671552783, 0.15604724799419656, 0.29343919573562516, 0.2621569992920171, 0.2037147764709374, 0.36172163150709236, 0.09493880565392843, 0.31454030416909273, 0.3072979327818057, 0.12343598887001339, 0.3712211424783103, 0.38178800454788175, 0.09769545403548041, 0.31636677545941694, 0.32807262403889526, 0.36284024047016616, 0.4007227285345847, 0.09268725640291542, 0.10577334060111665, 0.11132913604864425, 0.06000838633860117, 0.15382733625062228, 0.07174091143405148, 0.09495758189499937, 0.14171702007773523, 0.16972888934029218, 0.14721618447604323, 0.2293226529897544, 0.24235631064732732, 0.2530260253856754, 0.25120181280048004, 0.2607859851903541, 0.23319135934492763, 0.2730107095497697, 0.2542934904065356, 0.234717030297794, 0.5623985499207296, 0.5907754234233552, 0.6446414869170038, 0.5277122124114089, 0.5457036418743906, 0.5431343116399491, 0.5417497603142089, 0.5631059373804876, 0.5599564754290067, 0.09542901487890354, 0.09597334544905511, 0.07673945863160736, 0.16212598816763657, 0.15083156430099975, 0.09277091536432758, 0.10993604057578155, 0.11909725994143172, 0.09047676057896847, 0.3966876865298815, 0.16281402087175068, 0.254821994367354, 0.3403342284235764, 0.13796105580352247, 0.1461216699075425, 0.18026106886577675, 0.24847551755608266, 0.193142852746352, 0.3927050640514195, 0.37340616497145096, 0.4030934071643115, 0.36076506125430474, 0.3804237051105648, 0.3847700169850873, 0.3977736548533456, 0.43873721767193763, 0.4136642191111991, 0.26173291265833654, 0.2391581990281928, 0.30465623951016607, 0.2956576563107437, 0.30056816858313207, 0.29406298442524936, 0.30768239424662613, 0.33618952801855106, 0.34228766897548113, 0.20120537168691988, 0.16913311017721877, 0.19195397494409994, 0.1878604623025676, 0.18280105504835442, 0.1773628102081779, 0.19901316574234074, 0.1694885382691158, 0.1786448183388225, 0.1831729591096961, 0.40068371365679945, 0.17940276343995576, 0.17536810250422563, 0.5345744557937242, 0.22038752505632586, 0.1832147219173107, 0.4662360605906398, 0.1678071842402905, 0.8569398252614182, 0.18328340328815818, 0.1509335431271991, 0.8250166061429879, 0.18841379190229557, 0.15957797948342645, 0.7733039901735485, 0.697637281428868, 0.7598819584512977, 0.82180863029761, 0.20364012902282191, 0.8320461988714924, 0.1644044239326693, 0.6417159642070736, 0.6762292490206747, 0.20349318406560635, 0.20749539075719237, 0.6942388248704725, 0.17744619135159811, 0.17590524097396087, 0.18858344496524926, 0.19121063288417295, 0.19767889541192563, 0.18769489190493382, 0.17811928539395971, 0.1811996766307864, 0.1687966537437906, 0.07264410124412879, 0.07483607488765176, 0.07084573765092372, 0.06685340338492629, 0.06541961241657301, 0.08342746516554722, 0.0668662760173182, 0.07503840807415618, 0.08460467211058931]}, "mutation_prompt": null}
{"id": "d8975664-16bb-4637-848a-d90c6351a0db", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(10, 10 * dim // 3)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.12\n        self.mutation_strategy = [0.6, 1.2]\n        self.learning_rate = 0.04\n        self.min_learning_rate = 0.01\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.07\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n\n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n\n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n\n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 2:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.15, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedDifferentialEvolution", "description": "Adaptive Differential Evolution with dynamic strategy adjustments and enhanced perturbation control for robust optimization performance.", "configspace": "", "generation": 98, "fitness": 0.264572659966982, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.7415789191979878, 0.7418694268568216, 0.7491002046975267, 0.7484477186055061, 0.7706201715841761, 0.7524245574238977, 0.7383096259928768, 0.7757557929089911, 0.7109734636057525, 0.3161489510634914, 0.3904947066077781, 0.3509543435575412, 0.3162408544197365, 0.3376408478742501, 0.3891916139919992, 0.29533604854246354, 0.3425130402162123, 0.3639164027655627, 0.10760240522572762, 0.08777215616787615, 0.09501445180539503, 0.09947406257406177, 0.08714016974653149, 0.08984796884024238, 0.0887262249120393, 0.09048361954560513, 0.0942453885162784, 0.10364652544513608, 0.12287372063129787, 0.08895406690234886, 0.1033757564935861, 0.08895524652912334, 0.09447306116136278, 0.08956001602599573, 0.08566572533275563, 0.10906977886939473, 0.9173540509200719, 0.9095965194295631, 0.9226577920824126, 0.9103544084079142, 0.9457379094577201, 0.9255535566315267, 0.9283604636121455, 0.9113175731457304, 0.923292553849772, 0.39136128526910086, 0.3160433840483191, 0.36165475036836703, 0.31490565024574624, 0.4076517220860586, 0.34832840690984845, 0.22543408635895368, 0.34533519418413017, 0.3818406025342843, 0.6200668177899993, 0.6035892673085254, 0.23797229241337625, 0.637302579281505, 0.661945790932351, 0.19988988385128803, 0.539508873202377, 0.5879690648552345, 0.610572622077286, 0.21033892867120352, 0.21559242769248144, 0.23533775506728538, 0.1812016920895031, 0.23949152677181018, 0.20723176548593059, 0.331746329380879, 0.2590923038917541, 0.2120956688682223, 0.17224093809111163, 0.09442686197480821, 0.20810504066275037, 0.24638112138548418, 0.19458914916128522, 0.2009089323466633, 0.18476787034966824, 0.17779999010742153, 0.09655033041962924, 0.05114501181732123, 0.05640933059470521, 0.06153436710711846, 0.15751211870112514, 0.07956235918013388, 0.09893702196628307, 0.05301441094307957, 0.07896765062012523, 0.09818871910008997, 0.13330306475134313, 0.09205304808523984, 0.1210401924548773, 0.10042961627004898, 0.08925547654035204, 0.144058873256788, 0.1486015226416726, 0.22175606697617234, 0.14941158763341078, 0.029434037105874444, 0.031317239417752885, 9.999999999998899e-05, 0.0508499942230346, 0.07633022525093314, 9.999999999998899e-05, 0.004367642193200294, 0.03940830421204955, 0.07172866614761919, 0.1770837784015057, 0.1717203343958652, 0.14026845505464314, 0.1978986206299128, 0.1329657796056345, 0.20511607134008125, 0.1592964880858886, 0.1134370410724127, 0.1733995680809599, 0.46555579336608144, 0.5120015533498428, 0.5053280165328575, 0.5052488568187252, 0.5206999228844342, 0.49307828024467293, 0.4895426516851482, 0.47069222714415027, 0.5090996469003801, 0.08501317318139423, 0.08330769474947597, 0.06193816206327718, 0.09380879522215568, 0.0737494080697898, 0.08602969899166224, 0.07840851282842976, 0.07628573491525081, 0.08276474633802933, 0.14649084964331527, 0.20540323124211446, 0.1521487634495079, 0.13389350275976852, 0.14343132537377024, 0.12747521904167625, 0.14579941230627957, 0.17229077170960394, 0.130532619212962, 0.298432636482446, 0.32247821378418706, 0.27608205626262006, 0.3050387954820143, 0.304801899634933, 0.2621253210607162, 0.3360485006983942, 0.36026898432529597, 0.35887858251984395, 0.21624834007643, 0.23996972618460954, 0.18820861450303572, 0.22826010213932002, 0.18699563703606192, 0.2358610883006017, 0.2348919827890854, 0.22807304713036902, 0.194597773441327, 0.171740639826225, 0.17534205696896354, 0.15792084376151527, 0.20265121409477171, 0.15229816493145676, 0.17589641680779733, 0.16971148253343726, 0.1708041175429309, 0.17128042120120512, 0.1670847080728186, 0.18034048938428238, 0.18303092978037783, 0.17014696026894927, 0.17302214046971476, 0.16835766977205802, 0.16960692527076549, 0.1799533119297042, 0.16879682648743166, 0.6384896700806917, 0.6023427631939837, 0.14751992885955967, 0.17191844839608206, 0.6046940757795422, 0.16092046157496354, 0.18060095417780087, 0.1730437235016803, 0.15354393706221303, 0.16000541025364634, 0.16379195876303088, 0.4493699338558569, 0.19442322419752467, 0.1839777047308676, 0.3791282818974393, 0.20094587649476114, 0.6969513031584066, 0.1943592150082405, 0.18831868275375963, 0.18429541612403955, 0.17343900402715062, 0.19659513573481413, 0.17570024909568693, 0.17443693100714686, 0.1691698128843413, 0.17105029762676383, 0.19200144006086717, 0.06987945459096923, 0.07041882970779312, 0.06540048617953143, 0.0681739777519822, 0.06360509648790724, 0.06778928438037113, 0.07561651307990791, 0.06739481185867247, 0.06122161538357118]}, "mutation_prompt": null}
{"id": "de99fc1c-f574-45c0-88ea-c2d6b99ea0c2", "solution": "import numpy as np\n\nclass AdaptiveEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.bounds = (-5.0, 5.0)\n        self.population_size = max(20, 15 * dim // 3)\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.adaptive_sigma = 0.15\n        self.mutation_strategy = [0.4, 0.9]\n        self.learning_rate = 0.04\n        self.min_learning_rate = 0.02\n        self.max_learning_rate = 0.25\n        self.dynamic_mutation_factor = 0.03\n\n    def __call__(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            new_population = np.empty_like(self.population)\n            fitness_values = np.apply_along_axis(func, 1, self.population)\n            evaluations += self.population_size\n            for i in range(self.population_size):\n                if evaluations >= self.budget:\n                    break\n                indices = list(range(self.population_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                dynamic_mutation = self.mutation_factor + np.random.normal(0, self.dynamic_mutation_factor)\n                mutant = self.population[a] + np.random.choice(self.mutation_strategy) * (self.population[b] - self.population[c])\n                mutant = np.clip(mutant, *self.bounds)\n                \n                trial = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant, self.population[i])\n                \n                perturbation = np.random.normal(0, self.adaptive_sigma, self.dim)\n                trial_perturbed = trial + self.learning_rate * perturbation\n                trial_perturbed = np.clip(trial_perturbed, *self.bounds)\n                \n                trial_fitness = func(trial_perturbed)\n                evaluations += 1\n\n                if trial_fitness < fitness_values[i]:\n                    new_population[i] = trial_perturbed\n                    stagnation_counter = 0\n                else:\n                    new_population[i] = self.population[i]\n                    stagnation_counter += 1\n\n                if trial_fitness < self.best_fitness:\n                    self.best_fitness = trial_fitness\n                    self.best_solution = trial_perturbed\n\n            if stagnation_counter > self.population_size // 3:\n                self.adaptive_sigma = min(self.adaptive_sigma * 1.2, 1.0)\n                self.learning_rate = min(self.learning_rate * 1.2, self.max_learning_rate)\n            else:\n                self.adaptive_sigma = max(self.adaptive_sigma * 0.8, 0.01)\n                self.learning_rate = max(self.learning_rate * 0.9, self.min_learning_rate)\n\n            self.population = new_population\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveEvolutionaryStrategy", "description": "Adaptive Evolutionary Strategy using dynamic learning and mutation, with fitness-based self-adjustment for enhanced search efficacy.", "configspace": "", "generation": 99, "fitness": 0.28463037726092905, "feedback": "The algorithm AdaptiveEvolutionaryStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "fbd19aae-197e-4379-af67-6baa9b709c11", "metadata": {"aucs": [0.6861699148497382, 0.6993535626074598, 0.7053547727342372, 0.7027128127352298, 0.7089349809361061, 0.7247603361118489, 0.6914095396543188, 0.7068862659113689, 0.7060919010232792, 0.3276653935061017, 0.3312862610370584, 0.34484388516116704, 0.32747676685752725, 0.33273051177306334, 0.34380896014798235, 0.34167774970036724, 0.2858854502469087, 0.3216611420621779, 0.13383675344258883, 0.10560898745183911, 0.10064568784624894, 0.09676574931122428, 0.13939600337315383, 0.10581728119623202, 0.10110113713004942, 0.12066950779091434, 0.08722750104304233, 0.09162748870289028, 0.08261302917004976, 0.10052907321819327, 0.08630706917705844, 0.0994542118015721, 0.10614433467255457, 0.08670662236823068, 0.07804024785130992, 0.09176629112358037, 0.8650225732374426, 0.8666437046312745, 0.8943793543253276, 0.8812326817087456, 0.8821167328492617, 0.7714518056141277, 0.8186449314212214, 0.8648077466954031, 0.8862099787302773, 0.33581730208996263, 0.303072996913342, 0.34807126693124146, 0.3365386303210013, 0.3469537914690024, 0.3076846431541378, 0.3634079265224215, 0.342682446621277, 0.35007104217738594, 0.6755183848861808, 0.6473159899685068, 0.6843265498672055, 0.20754960652930754, 0.6887502063927362, 0.6055712179536656, 0.7319541958601624, 0.6813589624030125, 0.5515705795834602, 0.157671752896694, 0.23460414770740556, 0.2344895063333955, 0.33297976310467037, 0.33229738369434814, 0.19221974776629402, 0.21284291543732292, 0.2295467631719218, 0.23005367756320694, 0.17634675726622595, 0.1420008715309239, 0.1203878231300134, 0.1831653686150061, 0.18877433954169331, 0.17127692400100392, 0.23429342873661085, 0.18573967446859674, 0.1643052494942585, 0.1962497024532377, 0.12922187920227401, 0.15555460258848197, 0.1556051038326446, 0.1994321941689624, 0.15183977000587434, 0.12642178360486744, 0.1314712814227088, 0.20261908092769576, 0.08571910469449306, 0.2309972102854011, 0.2848802072688764, 0.2770197143108538, 0.2517895339833883, 0.2092449015310328, 0.2705503978364129, 0.27275676979663954, 0.2670611155268281, 0.06063047633065877, 0.060400450458001576, 0.06774529602612345, 0.09522297712865113, 0.09337854060078876, 0.10741813582181259, 0.06539550275086281, 0.10174212130599136, 0.07566027284501797, 0.1958801701201217, 0.17723629062587498, 0.2119168496795606, 0.1895210221195588, 0.18726195270507773, 0.18268710989114356, 0.2086285695469664, 0.18138456376441991, 0.21626197737152442, 0.5308117799205196, 0.507024152440812, 0.5233138644974901, 0.523828377568643, 0.4928019102174348, 0.4909420211729004, 0.5030539988476899, 0.4940514748496522, 0.5179157864876076, 0.08853499814360255, 0.07506588659744795, 0.0917259216266395, 0.0849929573954229, 0.0900833876163073, 0.0893075295268776, 0.09132241435403798, 0.08409698700571988, 0.10734764393503482, 0.17131434018580893, 0.14628086405554075, 0.1447824231688848, 0.13351798185724206, 0.15269068345785963, 0.14781829464461604, 0.13872463401138646, 0.1605971940067762, 0.14970201897275548, 0.3367527246785521, 0.3114882138709105, 0.3349629093510691, 0.36715251945352456, 0.29856326794662824, 0.35332820658343445, 0.33989291352023354, 0.3609046231409335, 0.3194408724836516, 0.269795090004911, 0.2281862281712953, 0.19823424001706347, 0.2611899298553071, 0.21906137172610507, 0.21681914731420315, 0.27101976125354155, 0.24489846961996542, 0.2817062945914649, 0.17722883615223162, 0.19378165332556896, 0.2127605843320236, 0.17002236697201756, 0.17753548919367734, 0.23861948267193933, 0.18726159849518775, 0.18776337275541777, 0.17684089479056075, 0.16883026221402342, 0.17031613528329126, 0.1747174336199383, 0.1776525281324528, 0.2033701448291717, 0.177054557811533, 0.17294591758565925, 0.1776678021362521, 0.17220323779304691, 0.7130966023169394, 0.1569244144686731, 0.1485430317734543, 0.7010425075389158, 0.6672500322537869, 0.6710460415963142, 0.15794325515161323, 0.445059716032988, 0.5677995125394677, 0.6502270443637448, 0.16687497065094248, 0.1586494603474744, 0.6430380348062573, 0.18857085158547093, 0.15909957097630045, 0.20866544675901388, 0.19492559747668825, 0.20239388520501977, 0.186740278613044, 0.17452463304893007, 0.17765462444814017, 0.18351933273119125, 0.16967880866154705, 0.1751866088796401, 0.17187097631775072, 0.18919856337524454, 0.17649278591242834, 0.06800407441321532, 0.07659620232652686, 0.08194801925134887, 0.07414946278997236, 0.07648536740260248, 0.07358808604316402, 0.06895461510822865, 0.07651105267520819, 0.07479425270173268]}, "mutation_prompt": null}
