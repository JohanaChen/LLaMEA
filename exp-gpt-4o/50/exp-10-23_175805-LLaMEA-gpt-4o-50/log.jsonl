{"id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 0, "fitness": 0.26129299788939, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "75e56ff0-dd73-44f7-ab13-f11706728313", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "8d125747-959e-4113-8252-d96371ac05f6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "b3cc5f92-8fa4-4f9d-a7ba-7af701992772", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "9d506d87-8cf6-4f8b-81ff-6147efacd01d", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "efd1c1aa-8b2d-4b43-a225-09f16da173c8", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "e06345d1-7be7-4f5e-9fcf-939c9df32204", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "1abb82ee-bf4a-4bf5-bdb6-8900c2aca442", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "c0e71831-6ef1-4e42-b7ff-32aa326ec6bb", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "731fd271-0258-4b74-936a-7607023add81", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + self.F * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n        return best", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm using dynamic parameters and local search enhancements.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.6303233439287501, 0.5881740726649367, 0.5891367376365919, 0.656952091600689, 0.6555401612365537, 0.65296100072555, 0.6637250105621948, 0.6265200288477026, 0.6187073213074975, 0.37440949281807245, 0.3800832742909276, 0.40121637057003157, 0.362413280490975, 0.39349809186942775, 0.37504237839940546, 0.36833233056271397, 0.4193998164447448, 0.37875790113541397, 0.08457234728953755, 0.09768538036614738, 0.09939994212135517, 0.09869526375611914, 0.10221110508964115, 0.09338603933660983, 0.09402119400699771, 0.08731927456072386, 0.0975070629226138, 0.0846779025785136, 0.08475860204237373, 0.10875946924860236, 0.08593690562373735, 0.09274532457230034, 0.08477075380675247, 0.08852976634851817, 0.08869646286835409, 0.09196649997552997, 0.9806164642140757, 0.9131818418276485, 0.9674545387139455, 0.9574454447453314, 0.9162789564746359, 0.937231638163827, 0.9708179656152067, 0.9572804101259852, 0.9689147118055341, 0.28184553364334264, 0.27664866878666927, 0.2767787090641307, 0.28493920020768615, 0.2936114022452716, 0.2978810074614271, 0.3049580789019337, 0.2947505647469819, 0.3244318716073322, 0.4526956263143981, 0.5248197934116622, 0.41221304718668095, 0.5446581167637885, 0.5107403124377873, 0.5252956318567661, 0.48803742374257464, 0.5922773014258165, 0.505131848408342, 0.18994771786815068, 0.17033309018921095, 0.18962320003970023, 0.1910976729789471, 0.20456379799817226, 0.2070114110775435, 0.20234895949134035, 0.15631712961686228, 0.1529920834026519, 0.3004425431853298, 0.1845900816905398, 0.2276708148330614, 0.18309171089383114, 0.1441194727355769, 0.1969768063407772, 0.14134762277706048, 0.1792125223003732, 0.19596984723449518, 0.10690126412567114, 0.10967396084522951, 0.13301285818910424, 0.12525735077891154, 0.12275425545154262, 0.11890239086965615, 0.133685315045173, 0.11501453728025224, 0.11283451563224478, 0.2592471405643486, 0.25896604227405284, 0.25913870931783944, 0.2419827723367597, 0.2149830053963011, 0.2187834475285385, 0.28104317594856676, 0.2924978657640861, 0.28086858341926335, 0.02847416052881724, 0.039852708190292296, 0.017294577783444454, 0.04472645772664108, 0.02461714117929914, 0.04127468037370052, 0.04327819683910983, 0.04587756189208636, 0.05844591588151238, 0.16341253152143798, 0.15526429165349842, 0.15266820615463972, 0.16384632922330133, 0.15995796486835245, 0.16239319887670844, 0.15369415611647597, 0.15767720857427558, 0.16742728621304837, 0.45794963002029976, 0.47302634420768974, 0.48483373588285883, 0.5086286141823626, 0.4832328721843345, 0.4946498136198044, 0.4602369260347182, 0.48678270611797436, 0.48532356754305794, 0.0844803077644134, 0.08415303633101867, 0.10025593786815001, 0.08432894306818195, 0.09502256669064424, 0.08987697026955177, 0.08039373434577479, 0.07934987507880142, 0.09686658210897281, 0.16801503062757928, 0.17302141451976039, 0.15502553429251453, 0.16352084702203262, 0.13602443403332198, 0.13638572837206264, 0.1600242087079925, 0.12693231315176212, 0.16391225786162578, 0.2874423904336383, 0.25031984715689437, 0.2840692816521003, 0.24230536005838954, 0.23905103299313368, 0.2594671564596721, 0.2745066456106342, 0.294969186889666, 0.28426947115397716, 0.21751662185266252, 0.19659104531943938, 0.1939266368330259, 0.19054678573538264, 0.190122406672665, 0.20111429963049443, 0.20059032798034504, 0.2110290629383278, 0.21386775057452556, 0.18996915365687672, 0.1663641699353139, 0.19324255631970033, 0.17364760462161344, 0.1870411048485292, 0.19408361306047373, 0.19284687291941127, 0.17892342692630614, 0.20398711381524892, 0.17199982132945135, 0.1967187745695591, 0.18302442806360586, 0.1828325565220874, 0.1765885235593807, 0.17347456612798162, 0.17570215356731045, 0.17522357168451674, 0.18793134262210875, 0.15921784574531428, 0.6129508645813364, 0.6642467290753948, 0.1786883181637413, 0.18378424769521984, 0.18073628786737195, 0.15401305807538723, 0.20886084501698632, 0.342656479443594, 0.18670758934509224, 0.19405961062195598, 0.18446824984255095, 0.3453569657953932, 0.2680880141132066, 0.18146512164890416, 0.20313234900629218, 0.4998942066599751, 0.20536619896909192, 0.18783732924635088, 0.18023815829916234, 0.20220339461419934, 0.18749187771032993, 0.16688167222158756, 0.19104640338469214, 0.1754204263818494, 0.18923353842363744, 0.17298381898649295, 0.06350994990888392, 0.07711820996947749, 0.06395195290550271, 0.07669306676589549, 0.07181442078783418, 0.06805418663340457, 0.07552370055913327, 0.06568610617668169, 0.07719139294140276]}, "mutation_prompt": null}
{"id": "dbee2b6f-5ec7-4766-b359-787d497d3b17", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.5:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                else:\n                    indices = np.random.choice(self.pop_size // 2, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F_dynamic = self.F + 0.1 * (np.random.rand() - 0.5)\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n                \n                if evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.argmin(fitness)\n                    local_solution = population[local_search_idx]\n                    local_mutant = np.clip(local_solution + 0.1 * np.random.randn(self.dim), self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution with a dynamic mutation strategy and local search using elite solutions.", "configspace": "", "generation": 10, "fitness": 0.27973849587331645, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "1f3c5818-6678-41e2-8851-e8a17b221fe3", "metadata": {"aucs": [0.610930877456955, 0.6215143730227167, 0.649073294133755, 0.6134089658325355, 0.6629173881661856, 0.6325787945918644, 0.610639628490365, 0.6363738592486993, 0.6317574405321289, 0.4095003965713393, 0.3461149564673276, 0.3445250540599819, 0.39326409306277266, 0.3721366787108378, 0.3901465440177716, 0.3542486883868847, 0.344468714434104, 0.38335343788864606, 0.11492086355991338, 0.1179614280979997, 0.0967477297600069, 0.09990977252500455, 0.10495957796370547, 0.11794637153718213, 0.1083667855263184, 0.1144744139328423, 0.10445474839025959, 0.10492344018015154, 0.0863474494862172, 0.1077678705483337, 0.11207034831203944, 0.09324298298535161, 0.079105184701042, 0.09211848936287825, 0.09553471012520498, 0.09956677136977865, 0.943307937714039, 0.9432522088680221, 0.9646917536336009, 0.9509604426574331, 0.9288012792205582, 0.9574749934935424, 0.9340647553974136, 0.942633289748122, 0.9668257032646772, 0.2822495640953626, 0.27317581211253605, 0.29054145023296774, 0.2648729738432788, 0.30538027867587814, 0.32383786122965685, 0.31036328654660217, 0.28092855098436487, 0.30562321264888703, 0.43658633536677693, 0.6099864772063864, 0.4698677549055301, 0.5495273818159484, 0.48212886686793077, 0.590502023136339, 0.6009383919476582, 0.6181165587267714, 0.48369720305892305, 0.19348174104446136, 0.17321068090641745, 0.22037778783258977, 0.2092186586961563, 0.2134263412549452, 0.19406913029777062, 0.211788007145997, 0.19815361101608753, 0.22890177212921248, 0.2182693581925429, 0.1849671822334371, 0.1381414721283727, 0.23237988298168832, 0.17077917711977264, 0.16347191593410626, 0.21135344241112086, 0.18295107109886832, 0.20534425272523282, 0.14201487284784942, 0.09965380639947907, 0.14813307735168468, 0.12327139712096213, 0.16265804095837577, 0.11342072134428127, 0.1414685584368306, 0.10865609197609394, 0.1045034322703201, 0.25960465749891515, 0.2448633863586519, 0.23233022267097336, 0.2296813216978023, 0.2708411555458139, 0.2383729409780032, 0.22427010408360326, 0.2546165672342038, 0.2892113871227743, 0.017573080547788278, 0.024923686455266214, 0.039536477798523983, 0.048123097713059004, 0.028738339847939276, 0.04967320361540628, 0.051385721235077786, 0.0173311172155598, 0.022075527884257484, 0.16549432402662878, 0.14954740014809753, 0.1578273571339237, 0.1695386198624832, 0.1668632053571264, 0.17984243963745628, 0.17607103688475745, 0.15470878113141862, 0.15904361606604467, 0.4775916016519355, 0.488856969868131, 0.5153117297133631, 0.4960052295236683, 0.46808133727875456, 0.46990927029686036, 0.494176311849719, 0.480578674972883, 0.49148734139877426, 0.09624897580908687, 0.09843612881023478, 0.09847069282636167, 0.10905973715925321, 0.09887540392909755, 0.11265553249479543, 0.1106573763263119, 0.09433500092657998, 0.12191333888820677, 0.17783687432197492, 0.20659388110698396, 0.16691312652791035, 0.1900622689199002, 0.2215935723745206, 0.1367917158548465, 0.2609096066688035, 0.18119968521299223, 0.21369202252569242, 0.27712216197577644, 0.2586822765751181, 0.3047188260434329, 0.2502253175533584, 0.2603833156775591, 0.2439396883315731, 0.29054874483839976, 0.27681066710019764, 0.29540125634755554, 0.20452934820470803, 0.20136026947321584, 0.21160029817826664, 0.19934912106838032, 0.2238031841836262, 0.1965280905511766, 0.22539413689666343, 0.23675760280342906, 0.2283146996719012, 0.20129309777891136, 0.1779214413353346, 0.2013431320888429, 0.2013319339515418, 0.17156962884348026, 0.19532374353169757, 0.19538900805793524, 0.19796901983696813, 0.17605875587164832, 0.18981645409769632, 0.19360212171740754, 0.22846620743024137, 0.19030685482658694, 0.17690935849019118, 0.2210959601044017, 0.18710268363213367, 0.1990876893418081, 0.19426584348187848, 0.5756102921079156, 0.49717094286780117, 0.6577861528674087, 0.18250895238762155, 0.6125456385857695, 0.5966647163451193, 0.18207810850277706, 0.4241511848410042, 0.4528871140854581, 0.4397269305552478, 0.20297087073628206, 0.4391466548402534, 0.4053396882946695, 0.370857321292852, 0.5210372307306557, 0.2052726897404097, 0.5968039846652252, 0.20892864633021946, 0.1859790143504454, 0.19378665931025985, 0.1902199553787669, 0.17633820769087638, 0.1741971848131143, 0.17738550450804158, 0.19010094398224442, 0.1976726446510707, 0.1833053048257518, 0.06930955246326176, 0.07275971267144454, 0.07282278010053034, 0.06017776434329558, 0.07055607564602961, 0.07859228597774615, 0.0726661226367814, 0.06721057135264796, 0.07251962658214528]}, "mutation_prompt": null}
{"id": "009755f1-367a-4b09-aa07-e12536b6dd10", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if np.random.rand() < 0.5:\n                    indices = np.random.choice(self.pop_size, 3, replace=False)\n                else:\n                    indices = np.random.choice(self.pop_size // 2, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F_dynamic = self.F + 0.1 * (np.random.rand() - 0.5)\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < self.CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n                \n                if evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.argmin(fitness)\n                    local_solution = population[local_search_idx]\n                    local_mutant = np.clip(local_solution + 0.1 * np.random.randn(self.dim), self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid adaptive differential evolution with a dynamic mutation strategy and local search using elite solutions.", "configspace": "", "generation": 11, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "dbee2b6f-5ec7-4766-b359-787d497d3b17", "metadata": {"aucs": [0.610930877456955, 0.6215143730227167, 0.649073294133755, 0.6134089658325355, 0.6629173881661856, 0.6325787945918644, 0.610639628490365, 0.6363738592486993, 0.6317574405321289, 0.4095003965713393, 0.3461149564673276, 0.3445250540599819, 0.39326409306277266, 0.3721366787108378, 0.3901465440177716, 0.3542486883868847, 0.344468714434104, 0.38335343788864606, 0.11492086355991338, 0.1179614280979997, 0.0967477297600069, 0.09990977252500455, 0.10495957796370547, 0.11794637153718213, 0.1083667855263184, 0.1144744139328423, 0.10445474839025959, 0.10492344018015154, 0.0863474494862172, 0.1077678705483337, 0.11207034831203944, 0.09324298298535161, 0.079105184701042, 0.09211848936287825, 0.09553471012520498, 0.09956677136977865, 0.943307937714039, 0.9432522088680221, 0.9646917536336009, 0.9509604426574331, 0.9288012792205582, 0.9574749934935424, 0.9340647553974136, 0.942633289748122, 0.9668257032646772, 0.2822495640953626, 0.27317581211253605, 0.29054145023296774, 0.2648729738432788, 0.30538027867587814, 0.32383786122965685, 0.31036328654660217, 0.28092855098436487, 0.30562321264888703, 0.43658633536677693, 0.6099864772063864, 0.4698677549055301, 0.5495273818159484, 0.48212886686793077, 0.590502023136339, 0.6009383919476582, 0.6181165587267714, 0.48369720305892305, 0.19348174104446136, 0.17321068090641745, 0.22037778783258977, 0.2092186586961563, 0.2134263412549452, 0.19406913029777062, 0.211788007145997, 0.19815361101608753, 0.22890177212921248, 0.2182693581925429, 0.1849671822334371, 0.1381414721283727, 0.23237988298168832, 0.17077917711977264, 0.16347191593410626, 0.21135344241112086, 0.18295107109886832, 0.20534425272523282, 0.14201487284784942, 0.09965380639947907, 0.14813307735168468, 0.12327139712096213, 0.16265804095837577, 0.11342072134428127, 0.1414685584368306, 0.10865609197609394, 0.1045034322703201, 0.25960465749891515, 0.2448633863586519, 0.23233022267097336, 0.2296813216978023, 0.2708411555458139, 0.2383729409780032, 0.22427010408360326, 0.2546165672342038, 0.2892113871227743, 0.017573080547788278, 0.024923686455266214, 0.039536477798523983, 0.048123097713059004, 0.028738339847939276, 0.04967320361540628, 0.051385721235077786, 0.0173311172155598, 0.022075527884257484, 0.16549432402662878, 0.14954740014809753, 0.1578273571339237, 0.1695386198624832, 0.1668632053571264, 0.17984243963745628, 0.17607103688475745, 0.15470878113141862, 0.15904361606604467, 0.4775916016519355, 0.488856969868131, 0.5153117297133631, 0.4960052295236683, 0.46808133727875456, 0.46990927029686036, 0.494176311849719, 0.480578674972883, 0.49148734139877426, 0.09624897580908687, 0.09843612881023478, 0.09847069282636167, 0.10905973715925321, 0.09887540392909755, 0.11265553249479543, 0.1106573763263119, 0.09433500092657998, 0.12191333888820677, 0.17783687432197492, 0.20659388110698396, 0.16691312652791035, 0.1900622689199002, 0.2215935723745206, 0.1367917158548465, 0.2609096066688035, 0.18119968521299223, 0.21369202252569242, 0.27712216197577644, 0.2586822765751181, 0.3047188260434329, 0.2502253175533584, 0.2603833156775591, 0.2439396883315731, 0.29054874483839976, 0.27681066710019764, 0.29540125634755554, 0.20452934820470803, 0.20136026947321584, 0.21160029817826664, 0.19934912106838032, 0.2238031841836262, 0.1965280905511766, 0.22539413689666343, 0.23675760280342906, 0.2283146996719012, 0.20129309777891136, 0.1779214413353346, 0.2013431320888429, 0.2013319339515418, 0.17156962884348026, 0.19532374353169757, 0.19538900805793524, 0.19796901983696813, 0.17605875587164832, 0.18981645409769632, 0.19360212171740754, 0.22846620743024137, 0.19030685482658694, 0.17690935849019118, 0.2210959601044017, 0.18710268363213367, 0.1990876893418081, 0.19426584348187848, 0.5756102921079156, 0.49717094286780117, 0.6577861528674087, 0.18250895238762155, 0.6125456385857695, 0.5966647163451193, 0.18207810850277706, 0.4241511848410042, 0.4528871140854581, 0.4397269305552478, 0.20297087073628206, 0.4391466548402534, 0.4053396882946695, 0.370857321292852, 0.5210372307306557, 0.2052726897404097, 0.5968039846652252, 0.20892864633021946, 0.1859790143504454, 0.19378665931025985, 0.1902199553787669, 0.17633820769087638, 0.1741971848131143, 0.17738550450804158, 0.19010094398224442, 0.1976726446510707, 0.1833053048257518, 0.06930955246326176, 0.07275971267144454, 0.07282278010053034, 0.06017776434329558, 0.07055607564602961, 0.07859228597774615, 0.0726661226367814, 0.06721057135264796, 0.07251962658214528]}, "mutation_prompt": null}
{"id": "ddf0e099-8ddf-4657-8549-21ea90d3e9e7", "solution": "import numpy as np\n\nclass NovelAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.8, CR=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        diversity = np.std(fitness)\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F_dynamic = self.F + 0.1 * (np.random.rand() - 0.5) * (1 - diversity)\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                CR_dynamic = self.CR + 0.1 * (np.random.rand() - 0.5) * diversity\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n                \n                if evaluations % self.pop_size == 0:\n                    diversity = np.std(fitness)\n                    local_search_idx = np.argmin(fitness)\n                    local_solution = population[local_search_idx]\n                    local_mutant = np.clip(local_solution + 0.1 * np.random.randn(self.dim), self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "NovelAdaptiveDifferentialEvolution", "description": "A novel adaptive differential evolution with dynamic crossover and adaptive mutation based on fitness diversity.", "configspace": "", "generation": 12, "fitness": 0.22610977542706762, "feedback": "The algorithm NovelAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "dbee2b6f-5ec7-4766-b359-787d497d3b17", "metadata": {"aucs": [0.6406520808980688, 0.6365611586916359, 0.6371705020169768, 0.6325812580640311, 0.6268261983079665, 0.6603153009898677, 0.6383374181523427, 0.6396250554539679, 0.6275359456274305, 0.006437661722036525, 0.00915300937824759, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.025259122161510494, 0.029719281250684126, 0.11237116788292079, 0.11235608753730608, 0.11081421310260409, 0.09808979725389377, 0.11503244373476462, 0.11320345896235029, 0.09805183689961139, 0.11468330381697212, 0.11138222064350156, 0.0869656143393639, 0.09828662382451381, 0.09500136037287288, 0.09038808512216201, 0.09387251583112688, 0.07775222200004916, 0.08425430362020436, 0.08313134810594458, 0.09133094781094864, 0.9078752544765321, 0.9412896234336887, 0.9407284483637619, 0.9450390246311159, 0.9567271342249448, 0.9541416051168553, 0.959216478680956, 0.9412254508734835, 0.9897278339811053, 0.2238649031278518, 0.26055847825315637, 0.2203239506073431, 0.24217738271830158, 0.2216735920010906, 0.24603023628024612, 0.1953060418550413, 0.11584706901876762, 0.1797004928037078, 0.34763570569009083, 0.44632076631992323, 0.3900310702452131, 0.5734714771615816, 0.4779889329533683, 0.5248705082685512, 0.44350531934412507, 0.5015634531343474, 0.4910591232066507, 0.0018378800265002049, 0.07232437311586304, 9.999999999998899e-05, 0.08704195148915839, 0.056516400410727474, 0.014373225458072958, 0.041751846904500955, 0.14393759662814087, 0.10203779190774043, 0.0679192547605817, 0.10355467799069484, 0.06487270904345166, 0.08312439741302702, 9.999999999998899e-05, 0.07818316432134764, 0.12845898459119598, 0.048380834251828486, 0.07673874724207908, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0007306276724854399, 0.040337404494977136, 0.05898896296481293, 0.050460225092361144, 0.03253270743267911, 0.06398538063969716, 0.05764946486649947, 0.13637028161066722, 0.20480344829583152, 0.10406170077811416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00018027994786062873, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09425085257149801, 0.08821330019824614, 0.08744659832384571, 0.11181570280081798, 0.1134219107428115, 0.11601125299283832, 0.10486035680361183, 0.12393585679578356, 0.12394935398196427, 0.4557825406577536, 0.46901073729894327, 0.4741224199178481, 0.473730670216594, 0.4522740962491514, 0.49778166444680894, 0.4724385536314817, 0.4884341163053887, 0.49247243179069555, 0.08833508096954445, 0.0941938077534703, 0.09523632988619357, 0.08957720949787851, 0.08895327297703137, 0.09199609541432441, 0.08539248100253827, 0.10142360716560905, 0.10579130579721674, 0.22442130560914497, 0.17297746805349856, 0.15496356455777227, 0.19891498095853744, 0.16878321302093413, 0.23929730015127992, 0.18046540001746492, 0.16517211135667953, 0.16019597594254498, 0.2747998104458227, 0.2773118503848413, 0.27454122066146547, 0.26095942352943524, 0.2647512410563603, 0.26533579908806615, 0.292826166787429, 0.28688217724491505, 0.2794044458049496, 0.21808946494032277, 0.19475013420583376, 0.19890109766104125, 0.20796622030795675, 0.1843923335595855, 0.19965487071367283, 0.22082166175144424, 0.22315650694775968, 0.2122519443072569, 0.1767457119977589, 0.1683862338858969, 0.1806316627613871, 0.22296479656103108, 0.18569788283403155, 0.17678374346724723, 0.21300607297547447, 0.1884597608303632, 0.18355720821107258, 0.1519357063792931, 0.15717632958584493, 0.1549907881319903, 0.1571187763729307, 0.11510935642724385, 0.1506370019538672, 0.15999671971055363, 0.10281068178297392, 0.13196935886936756, 0.6688535130729254, 0.18433227975929267, 0.1883084601874161, 0.6927996337233311, 0.3358354807156736, 0.5799023860451923, 0.17332063890903504, 0.44478997001289344, 0.17369146765269394, 0.5547218011555457, 0.3988638361078575, 0.6405363275935283, 0.3491859942504887, 0.48967484619096546, 0.4068494497937146, 0.6220752565047825, 0.2057022265603088, 0.2052786372983706, 0.18302486188994216, 0.17829297666767507, 0.18080489837483305, 0.17654450580451064, 0.1816412961973941, 0.1808039372676823, 0.18332203759853838, 0.19701945728282388, 0.17512766922306888, 0.07500797822537408, 0.0664810478807516, 0.07515069005333552, 0.0645050627832896, 0.07879253099837258, 0.07302769020160282, 0.07214711389724526, 0.07692840770818088, 0.08705481696515749]}, "mutation_prompt": null}
{"id": "f998cb9f-8e2d-496a-9faf-755415061be2", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F=0.9, CR=0.8):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F = F\n        self.CR = CR\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                F_dynamic = self.F + 0.2 * (np.random.rand() - 0.5)\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                cross_points = np.random.rand(self.dim) < (self.CR + 0.1 * np.random.rand())\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n                \n                if evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.argmin(fitness)\n                    local_solution = population[local_search_idx]\n                    local_mutant = np.clip(local_solution + 0.2 * np.random.randn(self.dim), self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with dynamic neighborhood search and adaptive crossover rate.", "configspace": "", "generation": 13, "fitness": 0.23213679288274136, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "dbee2b6f-5ec7-4766-b359-787d497d3b17", "metadata": {"aucs": [0.5276076255556247, 0.5486795861384905, 0.5372632806333248, 0.5511519853182846, 0.5854076086898115, 0.5993386886193947, 0.5746390242676587, 0.5672499187789923, 0.5732542624527424, 0.2883727321053412, 0.3090650041025601, 0.2785493521355076, 0.2751938766598624, 0.326402919682773, 0.26836579393994986, 0.31305387600329804, 0.28731898641020825, 0.29522728890897043, 0.093273048849563, 0.09740969784236408, 0.0952516824556533, 0.0985245757151868, 0.09746861682233643, 0.10339486580119228, 0.11080062356352649, 0.11023098713153578, 0.10081258405707971, 0.09209477783584774, 0.08925938797215971, 0.09079433852876884, 0.0896486849288265, 0.09395788751543022, 0.08394149884738222, 0.0962095727585931, 0.1011440655464978, 0.10779516307904546, 0.9510775637230618, 0.948831702203925, 0.9599562276335931, 0.9596780680001413, 0.9454429406845364, 0.9696836297878946, 0.9832764318554181, 0.9471192401059535, 0.9049496095607945, 0.2137512477680933, 0.2383419178384496, 0.23589010936202182, 0.2225250120832124, 0.2274595773057564, 0.2289520240559112, 0.25599817158919735, 0.24414163724783333, 0.24399024018316573, 0.25657020639194206, 0.3023919326004676, 0.29877008908212743, 0.3053246513015234, 0.3614633055843913, 0.33550029535381354, 0.27096967780404013, 0.2510560117182804, 0.2912765571168968, 0.1676856886157546, 0.14905547379197082, 0.12962186861844205, 0.15737716657706846, 0.15497531566299516, 0.12631987456991023, 0.16193207022388179, 0.13924001491800153, 0.14213884533008636, 0.09959627390627845, 0.1032620036120907, 0.18809374436909088, 0.13843179914347836, 0.14292833628782375, 0.13224108631213405, 0.13500833976666105, 0.1404475582249255, 0.1371824585144168, 0.04332142077209922, 0.055896887952532004, 0.03975721985005909, 0.022837263738409996, 0.05418499681327482, 0.03498180536282347, 0.0331452576644482, 0.06215122555676644, 0.051470171332522074, 0.16113470297591026, 0.12110539658325559, 0.13980055466281616, 0.1522357506812343, 0.17115932421321645, 0.13341081628965856, 0.1658048655347678, 0.17094101136423923, 0.17163193321316816, 0.009349275202900076, 0.0013389635478510131, 0.004171082845938923, 0.0027675806169102923, 9.999999999998899e-05, 0.00013918027866677285, 0.00033510488612975564, 0.003403285031242209, 0.006781516484767991, 0.11117212182120673, 0.09818640991298011, 0.11085286959525498, 0.10307778235543796, 0.12297006382973286, 0.1049048565305658, 0.11253111667071791, 0.09642600166693194, 0.10298236971663921, 0.41843203864036616, 0.42645236306006895, 0.4135690852413263, 0.4213165709516177, 0.42789431347551476, 0.400711310299702, 0.4320849976105364, 0.43648408060699384, 0.42969527077137537, 0.08999655736704282, 0.08856209678064697, 0.09124357019973905, 0.08499617934259618, 0.08196761127986718, 0.09045118332941782, 0.09282415901946328, 0.07197132375999504, 0.091626430058109, 0.17114102074224735, 0.1684002667253468, 0.17813199676232216, 0.1703392266038718, 0.24111950783883918, 0.1814715895946276, 0.18659048977999726, 0.18017855922174864, 0.22067826123102507, 0.24760452302595992, 0.22828644859870106, 0.24204756588669452, 0.2166268551066366, 0.22597545476401426, 0.2356681480486753, 0.24390089187586605, 0.2753156155458153, 0.2585099386141366, 0.18840760097682474, 0.16898594275574053, 0.19834475166689947, 0.1821485728125749, 0.16569463770742698, 0.16168003426453392, 0.17437490871769679, 0.20276613997954707, 0.1729459437899088, 0.17900789656137972, 0.17493753304712867, 0.1863370310773831, 0.17349953021741515, 0.1940508800266657, 0.17798308534211738, 0.19809415602213865, 0.1851134730867462, 0.18063185152840744, 0.17349493367843294, 0.18554836207643466, 0.1693556550573525, 0.18603748718494084, 0.18238601658501796, 0.20110167438889526, 0.1970799299246312, 0.17388717577107693, 0.18546705760326854, 0.1717148387994839, 0.5880180218718853, 0.5872656927734193, 0.5223214870050805, 0.28084516967334305, 0.3126274337475773, 0.2588496716833387, 0.37931282033606173, 0.24782403596002145, 0.4621916814600757, 0.20477784329637827, 0.19254002928308, 0.19141947285913974, 0.33474114438220715, 0.2810647965839951, 0.5673442457597058, 0.21160851473593778, 0.46208822267262695, 0.19866869382512764, 0.19526054941903526, 0.19311885196941248, 0.186034273822971, 0.19394003027951934, 0.1819126760382983, 0.1838460163677066, 0.18254298620368714, 0.20261436177880965, 0.0795099129568485, 0.06674834303070187, 0.08591831091402324, 0.06876963300201844, 0.0641604745636698, 0.06604546862295224, 0.06878328717595172, 0.08467285798404356, 0.06627759662619337]}, "mutation_prompt": null}
{"id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 14, "fitness": 0.28343151398649424, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "dbee2b6f-5ec7-4766-b359-787d497d3b17", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "5ccf0a90-d0f8-468c-9946-7a0c55e09557", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "423a1365-ddb2-491a-876f-bc50113b6a8f", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "30c0a322-c5b4-4120-bc47-414ecb31e038", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "078308fe-4b5b-40ce-b983-5391447c9487", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "0ab974ec-622d-4e82-a6bc-01775e6f00c2", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "2ad6d32e-fef5-457e-b8f2-176b531acbcf", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "5cf26756-6aaa-4edd-ad49-9b1ad03d0119", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "0583669d-cc84-4f7c-94b8-8b7c4297b12e", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "5a7e73db-e9a7-4fda-8427-26ee2aac9485", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "1f332d41-5c42-48f5-ae59-97327c32b4c4", "solution": "import numpy as np\n\nclass EnhancedExplorationExploitationDE:\n    def __init__(self, budget, dim, pop_size=60, F_base=0.8, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Adaptive scaling with learning component\n                F_adaptive = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_adaptive * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Dynamic crossover probability\n                CR_adaptive = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_adaptive\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Enhanced local search with adaptive perturbation\n                if evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedExplorationExploitationDE", "description": "Enhanced Exploration-Exploitation Differential Evolution utilizing adaptive learning for mutation and crossover rates.", "configspace": "", "generation": 24, "fitness": 0.24020643017100063, "feedback": "The algorithm EnhancedExplorationExploitationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.5441280475484621, 0.5586419447098909, 0.5444745669280879, 0.5863615066038745, 0.5487471285237626, 0.5791215234640121, 0.5705254790803902, 0.542717654083321, 0.5474804906665328, 0.2737694377096984, 0.2737319310463445, 0.2967389199969219, 0.29871915812039485, 0.2880259148343697, 0.2850494309168998, 0.29367671452247057, 0.29348424601556367, 0.30673225823120287, 0.08911003269854012, 0.09429352807421987, 0.08991335209162021, 0.09579849081989122, 0.10489080339313128, 0.09175432011267037, 0.08058687562889266, 0.09753831064722651, 0.10498629126120795, 0.07431978073267997, 0.08968792519480817, 0.0787441382574996, 0.08618201691202654, 0.08867467901099757, 0.08557156497805374, 0.08719706507120628, 0.08303939090887014, 0.06977736087009567, 0.9590970935729279, 0.9442646340938554, 0.9690042846131176, 0.980790191831761, 0.9065969432885743, 0.8942339518447908, 0.9002149629877416, 0.9421743860690858, 0.9543638201074133, 0.24725874094384015, 0.24501899267104188, 0.2503830401834962, 0.24032754149899804, 0.2242175019127992, 0.26122506383215105, 0.2588110214473124, 0.25508715465432774, 0.2328092917139375, 0.4406401481076714, 0.4441690242786708, 0.410475954584267, 0.38762623078106584, 0.5411222767777796, 0.49150940051574266, 0.43594866478584404, 0.415606725160379, 0.445072510206997, 0.15521170596008615, 0.13898246528665736, 0.1633200917890072, 0.1666474686206082, 0.1479289088944713, 0.16146599911051784, 0.1611330094172606, 0.153366692191224, 0.1400306710467517, 0.19769512724685578, 0.2423039074400103, 0.12622174757382376, 0.14721507333093942, 0.15391305945942713, 0.13429588293555828, 0.14076524891486186, 0.14034019334700187, 0.1356266475337119, 0.06928519731473681, 0.09940371038834694, 0.10215652333092218, 0.09535274581653597, 0.09203598352595543, 0.07952706068047477, 0.09093044447607357, 0.10715393755195435, 0.09290101182661181, 0.20977847346465273, 0.21397126178429515, 0.21161511807714573, 0.2141073511553414, 0.21003146342289725, 0.1749906850288806, 0.24376274862896075, 0.2457440979448815, 0.2215790398977341, 0.009059450890077314, 0.023917071126860923, 0.010997034226393754, 0.0163467268004579, 0.025492142960589104, 0.009436625116031938, 0.022396133243561378, 0.017299389205369886, 0.011660742255661494, 0.12145452106303734, 0.13460888942910587, 0.12113734065947779, 0.1165896498263832, 0.13810171686940143, 0.11667587292415738, 0.1428567836434268, 0.15953993071535755, 0.13466911809699944, 0.43155809718629656, 0.43250715718623167, 0.4365128228191958, 0.4240166943543412, 0.430089742174775, 0.4402819619181567, 0.4470698470697374, 0.45531884268374523, 0.4214958611444899, 0.07845667889279206, 0.08586623680421013, 0.0866276860681211, 0.0832857094923678, 0.0753037930677889, 0.07172971474917578, 0.08882596688265598, 0.07930668694267295, 0.08443050676375474, 0.14322640511707052, 0.20840606930710526, 0.13955019202439456, 0.16095414237348027, 0.13713889393981404, 0.1699031861915783, 0.13433269076934284, 0.2026951278368473, 0.14002694818542027, 0.25934338159683357, 0.23741313187301383, 0.27001070587251597, 0.2615016831134894, 0.23455557522461845, 0.250394788239224, 0.26580832602075033, 0.2612686496935347, 0.2918129534301718, 0.18895671541140002, 0.16962326751228596, 0.19238540636634016, 0.18640840059913277, 0.18510745892677682, 0.18415887067306191, 0.21140641376101454, 0.21592751423987921, 0.19608495760508293, 0.17928870495367355, 0.18677614898801154, 0.17214892452983477, 0.17078478679981868, 0.17673758007040308, 0.1712740888807902, 0.18480689740775547, 0.1884061382078025, 0.18677127302770147, 0.17454539916125578, 0.17547430692399435, 0.18044413784837865, 0.17032047423260122, 0.17970845643573552, 0.17139309378509715, 0.167730591328499, 0.1735021424908405, 0.17559719113221495, 0.15954959406760738, 0.5551618392826967, 0.6219628592694816, 0.1710662741722272, 0.2931521562902598, 0.16036260414356418, 0.24103308646753563, 0.191635345361994, 0.2291733857559466, 0.34462016493912717, 0.19860965446838474, 0.27459677533497295, 0.19541703443730107, 0.2048489739432897, 0.23905739341483356, 0.20533026874579596, 0.5571596832089034, 0.5616284084654584, 0.17968390726419348, 0.1816950500558009, 0.183871027899162, 0.17882031019765632, 0.19719389426437728, 0.1820837426511277, 0.23371178569455475, 0.18771326830762847, 0.1760680087969564, 0.07071229860291128, 0.060620524661407216, 0.06997361361311993, 0.06624066996413314, 0.07431599515033871, 0.06909225380455519, 0.06942202925690022, 0.07752664398164266, 0.06941046709224119]}, "mutation_prompt": null}
{"id": "b956612d-5220-4830-8aec-76cb0825120d", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        archive = population[np.argsort(fitness)[:self.pop_size // 5]].copy()\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base * (1 + np.random.normal(0, 0.1))\n                else:\n                    F_dynamic = self.F_base + np.random.rand() * (fitness[best_idx] / (fitness[i] + 1e-8))\n\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                CR_dynamic = self.CR_base * (1 + np.random.normal(0, 0.05))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n            archive = np.concatenate((archive, population))\n            archive_fitness = np.apply_along_axis(func, 1, archive)\n            best_archive_idx = np.argmin(archive_fitness)\n            if archive_fitness[best_archive_idx] < fitness[best_idx]:\n                best_idx = best_archive_idx\n                best = archive[best_archive_idx].copy()\n            archive = archive[np.argsort(archive_fitness)[:self.pop_size // 5]]\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Hybrid Differential Evolution with probabilistic neighborhood mutation and elitist archive for diversity maintenance.", "configspace": "", "generation": 25, "fitness": 0.16177579336188222, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.2897757473421749, 0.28700343160949615, 0.28020564249508717, 0.3064345589691999, 0.33617737761730804, 0.3199727847388465, 0.3134772359968526, 0.28506989749157896, 0.31331768863569354, 0.09206700655395639, 0.09254944222231498, 0.10820567811108539, 0.08339317533523372, 0.10116768208682148, 0.09850592311949435, 0.080457878045329, 0.08726949325252209, 0.10593969220958699, 0.05766160475294657, 0.06345331543702049, 0.0748546628021326, 0.07942757580843718, 0.07573895159383015, 0.06537140201156255, 0.08489007184138297, 0.09488941174148369, 0.0727467975374515, 0.05117382342854393, 0.0459718825194797, 0.04715783319767053, 0.05629173103029794, 0.05687602835969008, 0.05536948223341265, 0.049969501729838384, 0.05707363321323755, 0.0678904838274269, 0.8247622830220381, 0.9355996086478502, 0.8433572189989245, 0.9633631899446105, 0.9713250610585175, 0.932794751800519, 0.8734407213243313, 0.9275611838653981, 0.9251115393652863, 0.13508657162833482, 0.14170726671612432, 0.13256802295133308, 0.12324122602305287, 0.12538774168237976, 0.1385910093550552, 0.13466076856427922, 0.13187423377306895, 0.14407029741009136, 0.1876516352467137, 0.18736517533037056, 0.16864046724281434, 0.24419396392190384, 0.19518741627667013, 0.18194794381885226, 0.19952231062894155, 0.23404631007693355, 0.22914328092979352, 0.0857861378812711, 0.06972681531665059, 0.07897204783911638, 0.0907452616495722, 0.07645405364036018, 0.06179509806876826, 0.07407075962214182, 0.07649985836045037, 0.10013619698407861, 0.08574544167280418, 0.10255088874069751, 0.09420380089233804, 0.0772643998374768, 0.08133016907794732, 0.08208132163859394, 0.0603438657321822, 0.06175336332584136, 0.09624970394137966, 0.0034229739136677484, 0.024255444255753544, 0.011186865752709885, 0.0034869494061152695, 0.018007848670691273, 0.0205478540858548, 0.007966128105396875, 0.014760246909589991, 0.023081968403243835, 0.09581722396599324, 0.10816518174302292, 0.10174175300928523, 0.10345754372782323, 0.09179352438664978, 0.13777384490398958, 0.1191564813901177, 0.12017082523148215, 0.12904116628980222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052698375333951164, 0.04227076268630192, 0.03534867622022686, 0.06024508122394323, 0.05298993029047394, 0.05690988730443258, 0.05523114599290402, 0.04909403594991857, 0.04524416397897335, 0.27282700830749007, 0.309790844406589, 0.2808950959019768, 0.28509345747673787, 0.305929486728465, 0.26815273990665256, 0.30176551195147017, 0.29110583022881065, 0.3140461212363602, 0.07051687834264664, 0.08215854748479923, 0.06783852334867957, 0.0644876759418117, 0.060615070693871176, 0.06185223364779646, 0.07125130619237885, 0.07072582647529857, 0.06563598658837089, 0.1445440247915829, 0.12558053697869287, 0.18992227346118928, 0.14623308060874174, 0.17213959571734272, 0.15402146532418248, 0.13462427287910772, 0.13558050118748433, 0.13519319856269485, 0.18055023922216873, 0.17845796063598485, 0.18981098493679271, 0.18263916759392662, 0.18336454671115165, 0.17221208062385318, 0.17916206004889879, 0.20877549684695285, 0.1903636665346411, 0.13967865470722884, 0.1439145353634933, 0.14778545601441473, 0.13138337215411322, 0.151986762263849, 0.12094819481475283, 0.13502446074884278, 0.135163546788732, 0.14243937911456428, 0.15453312262661134, 0.16043163099290947, 0.163616058724404, 0.1911468126340713, 0.159887286260482, 0.16288851232862744, 0.16728694973821423, 0.1566616876217839, 0.20672128815888424, 0.16992527995726558, 0.16262905678356165, 0.16812394579964074, 0.15085672958889895, 0.15324578881116946, 0.14850141810068873, 0.15187544542730103, 0.16213832495825065, 0.1656956811490019, 0.2259686411452284, 0.3004993419729348, 0.25999945024095705, 0.16259289368202468, 0.19533252026367287, 0.1681498345014737, 0.16096793807549548, 0.16349920949345764, 0.15002003694128963, 0.192438201783925, 0.1600336211185973, 0.15746451751310064, 0.1488990128605472, 0.1479832678869698, 0.16946759388804145, 0.18797931321553085, 0.1989937845430525, 0.19614042301226986, 0.17695063773920683, 0.1865098616083658, 0.18858935466941262, 0.1949810779520802, 0.17517205842097505, 0.16602763256417252, 0.19995742646454817, 0.16940586703467198, 0.16368162101005723, 0.0596478976702689, 0.05115334828571272, 0.06870618235942583, 0.04713270137117742, 0.05774358258934831, 0.05107127622251595, 0.05754208458851462, 0.060182886264082636, 0.05985879219950152]}, "mutation_prompt": null}
{"id": "250a0853-7827-4095-acd1-e1cb2db1511a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with enhanced feedback\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability with increased variability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search with adjustable frequency\n                if np.random.rand() < 0.2:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "A robust hybrid differential evolution incorporating adaptive strategies with a focus on dynamic feedback control and probabilistic local search enhancements.", "configspace": "", "generation": 26, "fitness": 0.2717835296517211, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.676326396818872, 0.6556292035923317, 0.6699495097571649, 0.6643373071750653, 0.6837901105999418, 0.6925297064877013, 0.6485211213715485, 0.7002957466141391, 0.6774153276064836, 0.4363356060917928, 0.41478812595049663, 0.39133681830125255, 0.3939442058622836, 0.3796886456704832, 0.4226411610071307, 0.4106608740719746, 0.3797190217223567, 0.4500018149491981, 0.09939307079204796, 0.1088199396296714, 0.10761991489716527, 0.1151700605213164, 0.09319419046344501, 0.10639502386401922, 0.10156527398082249, 0.10567687056822683, 0.10953497033942383, 0.08773617995361926, 0.08964929382431053, 0.09133368469306646, 0.10179507165214763, 0.095240699101387, 0.09102278645767092, 0.0909703516358592, 0.08778704516079738, 0.0931130616903656, 0.9594889068221383, 0.916996388245636, 0.9272471323189411, 0.9215444449484873, 0.9684427670016897, 0.9433210315127578, 0.9179657261693314, 0.9037320222261869, 0.9426042197381822, 0.3023163533545028, 0.2834845174052253, 0.29410455459852325, 0.3102749477994162, 0.26697709149796744, 0.2841871014432057, 0.2926420520794566, 0.30856794455502534, 0.32919301088355823, 0.5791651781526319, 0.48335853347511104, 0.5399364955134929, 0.5213698468528792, 0.5654765674232722, 0.5627970905005553, 0.5411634744260323, 0.5045274416920168, 0.585372602040815, 0.22631229303418, 0.20959582244267194, 0.1874871668788194, 0.19872741678116546, 0.1847371540506939, 0.15248824061485133, 0.20077139364327845, 0.22291289328602282, 0.18833153953757786, 0.18220763187202293, 0.19717087626807384, 0.1951150349033446, 0.16664754184368846, 0.197082425345654, 0.17782283460208181, 0.17188276728169571, 0.1489825356417055, 0.21060811905334842, 0.09180834225987855, 0.115417744183124, 0.084203871627336, 0.10265138280152519, 0.10688251829928941, 0.10908775650601488, 0.1191055663845847, 0.09326326337728752, 0.11415799636542434, 0.2551193520000271, 0.2527820387467242, 0.2269953350984324, 0.2125541696424006, 0.22338934106487973, 0.2540341628133346, 0.285137716139062, 0.2659541875176151, 0.23234896670263427, 0.023005244340420505, 0.02847792043507158, 0.022974463526747257, 0.04469786720459701, 0.026905211223432923, 0.0199370287999171, 0.025538485664392874, 0.03424360479090771, 0.0555022651539393, 0.170343200003096, 0.14437595042058116, 0.1485023320015476, 0.16713955616161547, 0.16609432365043453, 0.15483332566177233, 0.15038232843283728, 0.14748226091761585, 0.1487639422625867, 0.4974324544908221, 0.4921496542749816, 0.48126001531763474, 0.4962202561704022, 0.4970853778232228, 0.5266659361582062, 0.47211707856928964, 0.4736724295469912, 0.5084656229342057, 0.09040780551989958, 0.09640145843514258, 0.09223188419598971, 0.08980868075637372, 0.09506600743226501, 0.08855881883736894, 0.07832400434296072, 0.09167316006818382, 0.08131417922407436, 0.15087104441631005, 0.2209445272204431, 0.1775389743105592, 0.1718983452052515, 0.17720708787946537, 0.16510498826479403, 0.15741890963669958, 0.1736975813582431, 0.15031188940645823, 0.2837774744784205, 0.2835357481770763, 0.29654790791414276, 0.2748086912972687, 0.26694051289161713, 0.2672259462814922, 0.31036085449865336, 0.2878061097843675, 0.32943082472488994, 0.2262155945425991, 0.20882117069519734, 0.20135817911709908, 0.19009220058748444, 0.1922444223850066, 0.20973525136693083, 0.2077434143585457, 0.24261735299491105, 0.22947710405548238, 0.20875937953582502, 0.19946427015747104, 0.1894613408299083, 0.19726064266188903, 0.1747016491316361, 0.19860886436791092, 0.1753070167877515, 0.18412923638834244, 0.2005701017733964, 0.17865485992976793, 0.1806815543519038, 0.17658909358200559, 0.19490840475896198, 0.17738137973842671, 0.18070781976187777, 0.19035609350027238, 0.17624440171882594, 0.17877880263505153, 0.596505724443779, 0.5139147343941008, 0.3746939929399148, 0.17593705787676372, 0.23052769967213282, 0.3891875748790129, 0.3055489779215633, 0.42265070792455584, 0.4204384335901077, 0.1908251364631245, 0.16655694428198242, 0.4059681962845998, 0.19574235105193716, 0.32318804576411886, 0.33939986602084204, 0.20632637957933686, 0.529898149684721, 0.205646244702119, 0.18589838550333493, 0.1796683989508412, 0.177531443005847, 0.1767967569729435, 0.1863720119459391, 0.18463032676821056, 0.18409215770162146, 0.1862947880909287, 0.1881408439979989, 0.07067984619855072, 0.07913477220582477, 0.07331992014330135, 0.07828092400977604, 0.07506361362573644, 0.07030371870862306, 0.0762503865758346, 0.06560256172197987, 0.08591114279652479]}, "mutation_prompt": null}
{"id": "11047f2d-5b50-4267-bb5c-209624191d4a", "solution": "import numpy as np\n\nclass HybridImprovedDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=60, F_base=0.8, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Enhanced dynamic scaling factor with adaptive and guided component\n                F_dynamic = self.F_base * (1 + 0.2 * (np.random.rand() - 0.5)) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Improved crossover probability with guided adaptive component\n                CR_dynamic = self.CR_base + 0.05 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Guided local search with deterministic interval\n                if evaluations % (self.pop_size // 4) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.4, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridImprovedDifferentialEvolution", "description": "An improved hybrid differential evolution with adaptive mutation, crossover, and guided local search for enhanced exploration and exploitation balance.", "configspace": "", "generation": 27, "fitness": 0.25110215212332, "feedback": "The algorithm HybridImprovedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.20.", "error": "", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.5618322244554204, 0.5635775746009031, 0.5682799264429743, 0.5944766424480804, 0.5697414884373189, 0.5605962749076393, 0.5460213174216056, 0.5406911529912743, 0.5718308485870811, 0.1422345257906238, 0.09510700947179773, 0.08002747407571353, 0.13675138031504086, 0.12359125379754476, 0.1324371755610444, 0.1553948156262822, 0.0875848208234844, 0.11638923544941115, 0.08672771261355461, 0.07836822988640202, 0.09305864211698023, 0.11711506939804517, 0.09273491518870447, 0.09148533998182962, 0.09993877620320857, 0.10177603973248739, 0.10016617632900471, 0.06544841003064761, 0.0525140016395097, 0.05751658509407642, 0.10651058977167194, 0.08708119684084648, 0.09745821468030647, 0.09043189173536526, 0.10206788674331913, 0.08753461601296753, 0.9294745160474766, 0.9303499058139374, 0.9122335513903992, 0.9462733399799909, 0.9655755894473561, 0.8875251597288785, 0.9087957704475572, 0.8681285646411179, 0.9405531767408842, 0.305550879787294, 0.3109949902278012, 0.28477402024467957, 0.28702405187765156, 0.27434501532859534, 0.3154208284280283, 0.24962419540820946, 0.2500199328407512, 0.22192954014474287, 0.368974511609764, 0.3180632979072411, 0.4825306961750383, 0.5479192910313078, 0.47999221952382376, 0.528119495799024, 0.6431849393023622, 0.6496985685535355, 0.6402250461752353, 0.2798748076179671, 0.2778357194599905, 0.2350841435460881, 0.0994446882286828, 0.10906021223888818, 0.09020808993987595, 0.23474752273692134, 0.22032873855741808, 0.23358785314360642, 0.2046128501916663, 0.2291335395138694, 0.23085057684497057, 0.2438018956494551, 0.25435917490539406, 0.3016577683546412, 0.2917738908273251, 0.27707399465319527, 0.26940556285579864, 0.054477373565345655, 0.0951002366377579, 0.04689390392337678, 0.15570833034967002, 0.15139973800632378, 0.14405478357303614, 0.012478460190484264, 0.00040185771075540444, 0.05946982832645176, 0.2880371835746415, 0.33477850896477934, 0.3359364669525906, 0.15859388025684806, 0.1254466497328911, 0.08188642272905577, 0.31475759453952024, 0.37271525401623584, 0.2767495189295921, 0.07426305056683957, 0.013018619271784715, 0.09417105816035454, 0.060355480420344665, 0.08157784457945216, 0.09716950201184504, 0.12650462185010525, 0.24233967712425353, 0.18937873735145527, 0.21228198572018586, 0.22141540226786183, 0.21181338662919968, 0.07867095252330181, 0.08529473416611255, 0.07394298064099125, 0.045043880565310834, 0.038096424868842904, 0.03657283218046736, 0.38976239286287806, 0.38871007197777574, 0.3954468252793961, 0.4258554424871388, 0.4337319017879624, 0.4182016258440756, 0.43981604243708405, 0.431637498730745, 0.4389089113861564, 0.09517382143717423, 0.07907006572238406, 0.10161056010284375, 0.0889363360949228, 0.0976037240418336, 0.08659413257566706, 0.07787943394152042, 0.0693484319998765, 0.06953438980475624, 0.1529389512670365, 0.17286601674237723, 0.14720708193314824, 0.15133491664669474, 0.13572474806266965, 0.1709391697051984, 0.1724932948754513, 0.1515589382410204, 0.14149121239651197, 0.16817850854072747, 0.18361090243033407, 0.17955232961434964, 0.2693420875933996, 0.27813141924502205, 0.24941573855550103, 0.2854664378042091, 0.26945084479626724, 0.276183062240964, 0.1385737078598226, 0.1432023791522784, 0.147810823147701, 0.22009212935470723, 0.2369058907362781, 0.214920838862802, 0.20340049919570014, 0.21091447617121595, 0.21451505101759882, 0.1789246085936449, 0.17447828890148542, 0.16540692586672323, 0.19143214471454884, 0.168901514912017, 0.2006297043024592, 0.1843705280961967, 0.1689571688798478, 0.19072768580211008, 0.20216810695616072, 0.18754882007719764, 0.173401760029268, 0.17162733989599366, 0.18293716052654907, 0.18229584309976465, 0.17722588582736987, 0.1802637841786875, 0.20096712274048034, 0.570598201471133, 0.66298037921278, 0.5013296859766423, 0.39968423783148255, 0.19603587423612612, 0.48544464272264, 0.41107032802223964, 0.27983114737208126, 0.48512118466689824, 0.4175595217667084, 0.19502181550779463, 0.40068206642143034, 0.23749173828592018, 0.1840171740518587, 0.21465942813644445, 0.19080965621643686, 0.19614301356266006, 0.4518595332770575, 0.19421311775484096, 0.2102209331672631, 0.23590078991588692, 0.17978566242907268, 0.18263917060524215, 0.18372505042438358, 0.18127339831347267, 0.1648770283121661, 0.1806006699959456, 0.0704737015548752, 0.07197775554177055, 0.07583856964706504, 0.07016001246984338, 0.07010454087179441, 0.07994064311532878, 0.0791714082914825, 0.07636967192851585, 0.07870692550748248]}, "mutation_prompt": null}
{"id": "1095ac95-8482-44a3-a8bd-8f3d55f9f8df", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "ba87b094-7d86-4a57-adde-0089d2e0d1ff", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "0bb0feeb-2d15-48dd-ab9e-5b80c90dfa6b", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "2a0cab56-213c-491e-acff-ebbc49a1e840", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "e88080bd-4389-459f-8a23-9a1ffb184220", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "5ab3ae0e-7fd2-40a2-86f9-35a48c595aa1", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "b20c41b3-5b3f-4377-a9d2-ac2cfb3c5d8b", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "59282479-6a4b-4fe2-8890-dc18a56601ea", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Probabilistic scaling factor with enhanced adaptive component\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Probabilistic crossover probability with component-wise crossover\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Multi-scale local search\n                if evaluations % (self.pop_size // 4) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, np.random.uniform(0.1, 0.6), self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution with probabilistic component-wise crossover and multi-scale local search.", "configspace": "", "generation": 35, "fitness": 0.28193923289288336, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.6826225475925523, 0.645494928185526, 0.6657573860578456, 0.7037899830812882, 0.7073374761167998, 0.724475033124481, 0.7048042892559899, 0.6994522601164239, 0.6891250734282792, 0.46476427267213927, 0.4583428580089072, 0.44760481737099556, 0.47463998327186596, 0.41828212713070767, 0.49427336850102943, 0.44433392511620606, 0.43129868820889883, 0.4582949493184275, 0.10389647261448187, 0.10119302702938315, 0.09987490943793365, 0.10842738511082317, 0.10709260559972933, 0.10289167747438255, 0.09789371159260751, 0.10887323536916904, 0.10732294264293307, 0.090203111747717, 0.09854533780283115, 0.10497186233984157, 0.09199041855022283, 0.08769372285140653, 0.10211584450353872, 0.09258187642704219, 0.08516139304316328, 0.10060037174840986, 0.9476157114354147, 0.9339967006448785, 0.9622365904593637, 0.9518085381926241, 0.9374834540695502, 0.9665416884453877, 0.9591383698709627, 0.9155585038138511, 0.9666504492498325, 0.30195360602864385, 0.29882581496928884, 0.28943260514515345, 0.32944858226493223, 0.2894417507529381, 0.30634584539572285, 0.3495139620039347, 0.3334890723874989, 0.32194831267932855, 0.5597191810437616, 0.5648177703827604, 0.5200018543785108, 0.6073845542457239, 0.6671977614396769, 0.5654897369061875, 0.572642847726995, 0.5231827597734432, 0.5857322455611336, 0.18373702431610883, 0.20613402432639283, 0.20794538483580427, 0.20144995060309034, 0.20561588116935758, 0.2224696899586075, 0.23181679644895947, 0.2179791278966825, 0.19335160741306845, 0.22045077294416837, 0.16150184809200296, 0.16968088421177185, 0.19810358422581098, 0.25173715568345556, 0.18368524625703642, 0.2007704292957182, 0.1863006603493823, 0.2194857050032223, 0.1175950135128091, 0.12201027390480068, 0.1385172953990057, 0.14484594652480043, 0.14405570180866512, 0.13661542543533267, 0.12261333900504456, 0.10425014419211531, 0.12142050207967403, 0.2840116372249475, 0.257479016042789, 0.2638848771235883, 0.21878114739294496, 0.23049884747179794, 0.23313486046667597, 0.270458088901283, 0.2689087099926505, 0.28526782034900466, 0.04031353836141682, 0.021070662399153117, 0.03984141308005096, 0.01890424527157919, 0.02404363909571805, 0.047354679651922194, 0.03207882248615501, 0.024392961994728624, 0.037653345561266316, 0.16166470783522457, 0.16151972857145647, 0.15782361031723235, 0.16644906836603546, 0.15220388962164633, 0.1974272872824584, 0.1600508111395338, 0.17458787582420632, 0.1493545146450277, 0.5198074337980227, 0.5005735626618582, 0.4981734504930707, 0.5160342773894304, 0.5057947422794251, 0.5136328813143713, 0.5020572060578089, 0.5333298624010512, 0.5323935329153746, 0.09031949317576671, 0.08595063649232892, 0.09524083566583719, 0.090881005489448, 0.0854549639816019, 0.08902844780068242, 0.10976757570501372, 0.09002547145963014, 0.09723056530327867, 0.3228421417646127, 0.14614097880118848, 0.14934422697654137, 0.1521412505305929, 0.14611976319872688, 0.14665300740282106, 0.19444644398364264, 0.18424789189622692, 0.16436269721991048, 0.29902920158719837, 0.2882282237690684, 0.28138148435659727, 0.2926887171437995, 0.2827625316841985, 0.2870071481277703, 0.3142381634308181, 0.3086739682368719, 0.3090597511526989, 0.20487093851356253, 0.21386937118175642, 0.22863365584083728, 0.1918435298291582, 0.21026256225932416, 0.21578078185520522, 0.2282400764767697, 0.2318499440100943, 0.22888058831688662, 0.2211288938214354, 0.1953803993194293, 0.1701135425400353, 0.17486332672423088, 0.18679891234573598, 0.20414225101909123, 0.21095215515032628, 0.19246242806643643, 0.19332942970641187, 0.17699529818766224, 0.17499175401842315, 0.18075370131151736, 0.17904387882643258, 0.18129450816739234, 0.1824821059456574, 0.18120294553180583, 0.19367504258968016, 0.1789944779018824, 0.1812494941358196, 0.17611097805464793, 0.1643075716700132, 0.5532504056676788, 0.5028928257470404, 0.25653598703991987, 0.4641283864593373, 0.32073990397761387, 0.49054282954087836, 0.48664536892352794, 0.20197575108683297, 0.3264397809130094, 0.5464371403052136, 0.18965417831587172, 0.5063305258982518, 0.2014115796765391, 0.20657116480276794, 0.2088768370400419, 0.17384773225788108, 0.1892286429658543, 0.17901010402820905, 0.1999115085520765, 0.1996831431134558, 0.1917162172930511, 0.17849531908929295, 0.18019712744333938, 0.17941463546498448, 0.06878597258198771, 0.07220401747686678, 0.07266885670668599, 0.07430592964918503, 0.06828881861557767, 0.08058527344829547, 0.07247795871360596, 0.08151907020713822, 0.06761186982097]}, "mutation_prompt": null}
{"id": "4da4a40b-9657-42e0-aacf-1e6cf575de45", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "9941c6af-f0ba-40f0-8fe6-a4af75c90b3d", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                \n                # Dynamic scaling factor with adaptive component\n                F_dynamic = self.F_base + 0.1 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover probability\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                    \n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Stochastic local search\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.5, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "HybridAdaptiveDifferentialEvolution", "description": "A novel hybrid differential evolution with adaptive crossover and dynamic scaling factor using stochastic local search improvements.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.7002773161552357, 0.7150016034282719, 0.6790966957674971, 0.7184408290642175, 0.7206504929566685, 0.6940623933889585, 0.7174317534091161, 0.705929735632246, 0.7065725707333157, 0.48702519304450687, 0.4884346494794338, 0.45720665164442376, 0.483201218334257, 0.4750335134745156, 0.48010554046939047, 0.4791612844950235, 0.4694463855867038, 0.4812086348802488, 0.09953909707580566, 0.10811354485060454, 0.0974515339208647, 0.09954691506526547, 0.10379877385568781, 0.11058867035440456, 0.11476320960021691, 0.10523811479200595, 0.1017226265716017, 0.08285086501282968, 0.09404134294311584, 0.10068019653444749, 0.10040705588421517, 0.09838451181111141, 0.09321483545384712, 0.09384760485324717, 0.09915019164521766, 0.09765531860967125, 0.9480309061895318, 0.9597014340656472, 0.9422895004333505, 0.9301038394872824, 0.9107512614465237, 0.9000642195266725, 0.9315721518146662, 0.931094743287346, 0.9523116898222064, 0.31228779866644085, 0.2998019014325467, 0.2862152757157088, 0.3077324817608237, 0.3038585546130196, 0.3065595289942771, 0.3290798336450115, 0.3200319501718515, 0.33429444344460213, 0.5436629217566864, 0.5972465197069865, 0.5335694167397502, 0.6434818943698853, 0.5696063660989158, 0.6383414576158379, 0.6447541442997367, 0.5529975865801562, 0.5469007719243042, 0.21184889309269306, 0.16734972738735154, 0.23786682007827964, 0.23348721344015833, 0.1625227547880902, 0.20340799433329282, 0.19914672825681545, 0.21328466260988455, 0.19292172711557043, 0.22883836002242142, 0.20909421806002115, 0.22607392057051034, 0.20289568484524434, 0.19742969420256395, 0.19602346221697364, 0.25593376339009466, 0.2186019706334782, 0.24761047701403505, 0.12973307613369345, 0.10269055358414969, 0.10394907420233446, 0.1397377418537724, 0.12438061208273088, 0.09184387871768285, 0.11684321986241264, 0.10056557271261501, 0.14728142145775291, 0.24463008109453754, 0.2640803634227702, 0.24098447858030014, 0.2359623213937745, 0.23788646204951247, 0.22206409713557773, 0.27719686560305246, 0.2848897391893783, 0.25976984837266603, 0.034466176452909725, 0.037818121249276415, 0.04413685019124225, 0.05549282830379265, 0.05178657226043193, 0.042738127503289425, 0.03974454201915145, 0.05002934941685111, 0.044000245516489844, 0.1622052095426164, 0.16159944647134794, 0.15578218657442067, 0.17926351745319824, 0.1645088426211878, 0.17954225278871638, 0.1792571067166263, 0.15710660823039957, 0.1585837678276235, 0.509490278552942, 0.5109512736085129, 0.5217724562115573, 0.5295563962933653, 0.5117349219926186, 0.5188310397140219, 0.5029194330046916, 0.5269002111652126, 0.517225161686476, 0.10845901928592228, 0.09005849843036517, 0.09915178306130878, 0.08606088839050785, 0.09111303572373985, 0.08709069608143549, 0.07906083577563017, 0.0998906114892607, 0.08628720056846795, 0.1573598552625044, 0.22445222582610602, 0.22373183370237437, 0.15948115847847488, 0.1440257687827161, 0.16586648238682755, 0.18221921942162367, 0.16057799410463958, 0.14495786635432928, 0.29783528481084554, 0.2947054579579974, 0.2905969981501063, 0.28341789264051986, 0.265571607627041, 0.2675107442985343, 0.31832452111287657, 0.31568027242779184, 0.31982910107052676, 0.21340701793049366, 0.20439374617005435, 0.22305887304448946, 0.2158584589244288, 0.2084141043809946, 0.21026796609098142, 0.22560153618629597, 0.23725711354664436, 0.23519872596771996, 0.18998824299144768, 0.17519573057536786, 0.2085991351213542, 0.17528402168396118, 0.19533336130824974, 0.17958532044917142, 0.17563742521466352, 0.2128979409072259, 0.20645668590994737, 0.1792576406577957, 0.18054408826358537, 0.18901527154800435, 0.21799212844854, 0.1831980306044828, 0.1900451259446282, 0.16776812089546334, 0.1825163555010334, 0.17108498384411885, 0.48734554575489075, 0.3204016887801798, 0.15076797370815598, 0.4222202586275692, 0.43049327093420553, 0.370728390948058, 0.26531255174357815, 0.2527064749954049, 0.27634648324882294, 0.5453074547900005, 0.4356546998877413, 0.1916347041501032, 0.19121241426448887, 0.3747713934492165, 0.18631826290298525, 0.5826419340652849, 0.19489393301763636, 0.20747732934470975, 0.1902283981162054, 0.18737220018932055, 0.1734263946967607, 0.1800757244979514, 0.17450911870273267, 0.20066229341005015, 0.18426609396753058, 0.17568922945519094, 0.18043332535504175, 0.07735143543764755, 0.08599838328449627, 0.07645035991515103, 0.07460767366235055, 0.08726904119861789, 0.06774933788753768, 0.07123800211882048, 0.0669244204587447, 0.07165295151884199]}, "mutation_prompt": null}
{"id": "d8f29110-8562-4378-9516-5aca07d39ccc", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 38, "fitness": 0.31327453294926344, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "0cb111d6-62c0-47bb-b503-41eb56e30fe9", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "b1841ef5-0109-42ad-8526-e9212a4433ed", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "5b509803-0add-4bc2-9762-244327f1a3c0", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "a64c1738-4c25-470e-b80b-e5efb42142b4", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "2a3109de-5e19-4afc-94f6-63089a33e822", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "07824ff8-90fa-4b5b-85d5-783f724305ff", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "c05a330d-d545-4cb5-a4ae-afd2d8af7e95", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "128e71a7-ad29-4219-af3f-f5ce2d9613d5", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "5810d482-7599-4971-bb81-79fd5908283c", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "c0499c97-ef4a-48dd-8038-106e6f36499f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "fd4a3f51-1769-4d75-9af6-c061cd38e9a3", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "a1d6eec9-122b-4c5f-9912-97fa4f823c2f", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "a70b4e1e-f6a6-4430-988d-5fbb7b4adfbf", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "edfde50b-d192-4db0-926a-f058c6cbde1b", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        best_idx = np.argmin(fitness)\n        best = population[best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n\n                # Dynamic scaling factor with broader adaptation\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (fitness[best_idx] / (fitness[i] + 1e-8))\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < fitness[best_idx]:\n                        best_idx = i\n                        best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[best_idx]:\n                            best_idx = local_search_idx\n                            best = local_mutant.copy()\n\n        return best", "name": "EnhancedHybridDifferentialEvolution", "description": "An enhanced hybrid differential evolution algorithm with adaptive dynamic mutation and probabilistic local search for robust optimization.", "configspace": "", "generation": 39, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.6900792962038305, 0.7044791319125945, 0.6870493433895366, 0.7199147934050925, 0.7295046783355781, 0.7290244001503294, 0.6919844348762688, 0.7018211966304884, 0.7167849704569043, 0.4690371973993791, 0.47592870733009207, 0.47573023530609293, 0.49104486679954473, 0.5071693317433853, 0.4761472226515019, 0.49979270584830393, 0.5235202751048074, 0.4855706668352837, 0.10431964174298447, 0.12155542655516582, 0.10301238741146701, 0.10061799609176669, 0.11447272179285517, 0.09823458936581098, 0.09502683775670617, 0.09532952594711164, 0.0930608474496506, 0.09938167357517991, 0.09341647561631539, 0.094333318345443, 0.09701522753527203, 0.09825810181479788, 0.09217495587114044, 0.08946331847791211, 0.08687260865764224, 0.09197325437919501, 0.9342292837066558, 0.9570839085466761, 0.9113782723700738, 0.9646116739335193, 0.9759974812156748, 0.9401695223127654, 0.9588270197285989, 0.9439590374866746, 0.9231730647001433, 0.3654391403884699, 0.33041858136425273, 0.32019835204134306, 0.35703620572310546, 0.35336081271133857, 0.34548370963805086, 0.35086850678398973, 0.34723008678419576, 0.32139223761511715, 0.6321977656029526, 0.6509316322357268, 0.5999948109654378, 0.7522456196983712, 0.6547391206709848, 0.6477590328895961, 0.6579183166720182, 0.653208279891164, 0.6699352888334209, 0.24306510728780217, 0.2735413008660491, 0.29220383049983334, 0.23450409424439178, 0.26782935543989583, 0.24948239338699174, 0.27159681118206047, 0.2667559289907947, 0.3016953180239953, 0.1688443275627144, 0.18320054761109306, 0.11472583663042402, 0.2654902633307037, 0.26426813773913094, 0.23219259919906587, 0.2811536937316882, 0.22238429865802878, 0.27021522823688093, 0.2527612128015285, 0.1844203342626063, 0.21594266017089137, 0.20782145316207634, 0.23295101835261156, 0.22996185844495576, 0.18581626590787537, 0.23149325409672006, 0.2165907026516577, 0.2987407644257062, 0.3619867243077496, 0.3714596867704739, 0.3498939867947466, 0.3305469573015195, 0.305420615094406, 0.3966951869291371, 0.4117379740329098, 0.3930306494108349, 0.052256012788752915, 0.042863532647443914, 0.05125083112194828, 0.08034083657829194, 0.11218111273377451, 0.09488377952971316, 0.08006244308133015, 0.05479007289337989, 0.05657600247449934, 0.20875506981484948, 0.18768458797956866, 0.19515377491965724, 0.21657039647394394, 0.2089088820443855, 0.19209905686755246, 0.18906938148882313, 0.21085895375188535, 0.1844497024517202, 0.5420579030215196, 0.5677145151132426, 0.5672494744578506, 0.5595757241728085, 0.5516658785736248, 0.5208017599501453, 0.5592804314989179, 0.5724873915957958, 0.5663450150768641, 0.09600427934603628, 0.08257781234242101, 0.08566763204740979, 0.0935835245093034, 0.08763168337179617, 0.08651792400399716, 0.08937244735769001, 0.08251474488697186, 0.10472350014293064, 0.14751678448663874, 0.17207734023935883, 0.2112527112899888, 0.16154461581732082, 0.15633452364156508, 0.13789889912739128, 0.18022600893537932, 0.14080035824489168, 0.13004603977060725, 0.30966080935722196, 0.3084561808224612, 0.30153897958464015, 0.3183313876249728, 0.28985941045624863, 0.28058641506707827, 0.3492568114517898, 0.3205573839726992, 0.3180325203757073, 0.24091615297877866, 0.25390486805352996, 0.23399946691746698, 0.23526108038228566, 0.2392083095820945, 0.21845741986522627, 0.24401402207471679, 0.2512795213050121, 0.2453090476928076, 0.1911188527021066, 0.2203726964980136, 0.21706357125411269, 0.18134857912354674, 0.18524402879657242, 0.1806334869193894, 0.19777263825550107, 0.17920427323116694, 0.17689329290465883, 0.1740140227439284, 0.17927710076748316, 0.17979137776450493, 0.188780583845922, 0.1782142533319786, 0.18368516637915655, 0.17552034076059664, 0.1779995572050046, 0.17567243331209137, 0.5635314786038715, 0.5125168688134927, 0.1669735796712032, 0.5719731052951962, 0.5091967779094225, 0.18138999980513137, 0.5755708388072064, 0.490153323919411, 0.4754024881414406, 0.5812679449986513, 0.6421124495550208, 0.6481068210966541, 0.4605152204044156, 0.19073767100210348, 0.5367531728011843, 0.2043577005834275, 0.20399955037349893, 0.20660852828851162, 0.19135274990492213, 0.1723114550089494, 0.18452481228135043, 0.18759908778848666, 0.19366773214186128, 0.17793814234418004, 0.18308602050396028, 0.18442455076786624, 0.17753709006259122, 0.06848668391591495, 0.08378330567902015, 0.07542080730745748, 0.07423677400438733, 0.08560529689112006, 0.07849479772084889, 0.06617693232436761, 0.07133895715400262, 0.07337750032960544]}, "mutation_prompt": null}
{"id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9, inertia_weight=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                # Dynamic scaling factor with particle swarm elements\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search with particle influence\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveParticleSwarmDifferentialEvolution", "description": "Adaptive Particle Swarm Differential Evolution combines particle swarm dynamics with adaptive differential mutation for enhanced exploitation and exploration.", "configspace": "", "generation": 52, "fitness": 0.4885904601752976, "feedback": "The algorithm AdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "d8f29110-8562-4378-9516-5aca07d39ccc", "metadata": {"aucs": [0.8838649026386449, 0.8715557918660944, 0.8749902775758528, 0.8820572583221025, 0.8698800920908262, 0.882287512374292, 0.8860417656292253, 0.8835486956297138, 0.8725712557403398, 0.7549924184956099, 0.7623576426004728, 0.7742742829210374, 0.7752404140585529, 0.7555943388522153, 0.7716235503845769, 0.7526712763250821, 0.7128399661437188, 0.7759773224291062, 0.6894695540526645, 0.14970635340121152, 0.12205175714808325, 0.15400159020229964, 0.14518889076186647, 0.11248458351457247, 0.15315734881632803, 0.1796585308499432, 0.14019866398111314, 0.09918790536877331, 0.09045532239360532, 0.10756170775194607, 0.12729309210313444, 0.1665996499992971, 0.1079061769461539, 0.11466037873371371, 0.11677616343661534, 0.11865966617918, 0.9691873143240695, 0.9725288404046546, 0.9844377148823121, 0.9561918756726415, 0.9720210778134255, 0.9728252996168898, 0.986849235527256, 0.9850992221375445, 0.9796137395497819, 0.7667221579490293, 0.7609037966118269, 0.7293016869524599, 0.7676191248288152, 0.7286170543904873, 0.7620214165018802, 0.77280434975912, 0.7521419142182314, 0.7657765785757906, 0.8984747213013706, 0.8748605854026601, 0.8958217800360131, 0.8774865475822782, 0.8746709552208097, 0.27612743307754595, 0.8896837301603359, 0.889841165241956, 0.23335426716393626, 0.6797984797323355, 0.6102326691666352, 0.13005912235497563, 0.7026077763570056, 0.7770441137007198, 0.1271675409999682, 0.6314894403073178, 0.1322137637195152, 0.7417752550490893, 0.6061568328545652, 0.5511811193323721, 0.13002592631217869, 0.6773831345150727, 0.5199519906890364, 0.6343870679166816, 0.6802137913511745, 0.7104298938097606, 0.7079978038121602, 0.6563717851145361, 0.6134156959221806, 0.6129601988222647, 0.6536817974161732, 0.6358372524214881, 0.7037524444452619, 0.6945500127964843, 0.6733711258580303, 0.7260920243220774, 0.743301607738821, 0.7756572514218376, 0.7631999827151282, 0.692582523295486, 0.5633362138553744, 0.745171781807294, 0.74692459570695, 0.7632329988266624, 0.7648081824305603, 0.2715362024738821, 0.14056424541712964, 0.4614473881217679, 0.6292625868409203, 0.3703381398350091, 0.4884656540372333, 0.4152346615876167, 0.4009675541718586, 0.24418333608700582, 0.6200600822218769, 0.5956407487743804, 0.6206136376569786, 0.6183587420526694, 0.5772372706661971, 0.6404988187077068, 0.5851586191272172, 0.5755863949872821, 0.6104212068777728, 0.8309040668365719, 0.8413421917924477, 0.84883300424476, 0.8257726117024363, 0.8267192206070213, 0.8422890703125908, 0.8394012425868569, 0.8276265315770212, 0.8086243944188334, 0.09495579302430468, 0.11277418605028378, 0.18362702013144672, 0.136561449257942, 0.12107800099900923, 0.14087666359045925, 0.12217065594650778, 0.12133008923204247, 0.15463727756641732, 0.5859130292872816, 0.3814987875958211, 0.5438569324690721, 0.2723291948756774, 0.7748363545273533, 0.504325189336075, 0.7039864855764596, 0.18730551219823166, 0.23082766463082516, 0.6180505878753939, 0.627200629786377, 0.7179923792015795, 0.6077137327722877, 0.6117334117172608, 0.5339272776804496, 0.7148200698943041, 0.7123763814241123, 0.6940249018549587, 0.505474691128323, 0.6016520464407957, 0.3282435623099995, 0.48469914372374645, 0.5982613936211143, 0.3871122543355485, 0.5341770866447895, 0.5439091012583619, 0.6611630333409884, 0.22134498090533872, 0.2404095529125938, 0.21282504980264605, 0.22194284002958842, 0.2055680548729132, 0.19038439406305807, 0.2113485753356712, 0.41222540950977005, 0.25401759450670214, 0.22329136789300152, 0.19296753623709118, 0.199841167859811, 0.25015859764676696, 0.21937188187205203, 0.18644753922823243, 0.19244670958401633, 0.20798859465098352, 0.19677083727040667, 0.8778611226034041, 0.18650878934237136, 0.15374294377779585, 0.1711101648285408, 0.19937413230461465, 0.17212943801114433, 0.14239023615880464, 0.1637905715944582, 0.20605690697552725, 0.9026132768946252, 0.21167189954444898, 0.12459903733188527, 0.20895373190681266, 0.21163458019183978, 0.15383410392653785, 0.21080216493659332, 0.12725100750918883, 0.1670074197295367, 0.17887140332333096, 0.17263383163098733, 0.17723053656134558, 0.2286239715637831, 0.17661878956370602, 0.17443729960680954, 0.17551031327689948, 0.19214550697548805, 0.18925117677586056, 0.0825995033082969, 0.09404180883668345, 0.09172464640028888, 0.09892697636552972, 0.08497820910557241, 0.09137420507889105, 0.08006260245258112, 0.0978975977139509, 0.09468633102859936]}, "mutation_prompt": null}
{"id": "23c81c15-9b51-4dcb-bfe1-689042fec6f3", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9, inertia_weight=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                # Dynamic scaling factor with particle swarm elements\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search with particle influence\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveParticleSwarmDifferentialEvolution", "description": "Adaptive Particle Swarm Differential Evolution combines particle swarm dynamics with adaptive differential mutation for enhanced exploitation and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.8838649026386449, 0.8715557918660944, 0.8749902775758528, 0.8820572583221025, 0.8698800920908262, 0.882287512374292, 0.8860417656292253, 0.8835486956297138, 0.8725712557403398, 0.7549924184956099, 0.7623576426004728, 0.7742742829210374, 0.7752404140585529, 0.7555943388522153, 0.7716235503845769, 0.7526712763250821, 0.7128399661437188, 0.7759773224291062, 0.6894695540526645, 0.14970635340121152, 0.12205175714808325, 0.15400159020229964, 0.14518889076186647, 0.11248458351457247, 0.15315734881632803, 0.1796585308499432, 0.14019866398111314, 0.09918790536877331, 0.09045532239360532, 0.10756170775194607, 0.12729309210313444, 0.1665996499992971, 0.1079061769461539, 0.11466037873371371, 0.11677616343661534, 0.11865966617918, 0.9691873143240695, 0.9725288404046546, 0.9844377148823121, 0.9561918756726415, 0.9720210778134255, 0.9728252996168898, 0.986849235527256, 0.9850992221375445, 0.9796137395497819, 0.7667221579490293, 0.7609037966118269, 0.7293016869524599, 0.7676191248288152, 0.7286170543904873, 0.7620214165018802, 0.77280434975912, 0.7521419142182314, 0.7657765785757906, 0.8984747213013706, 0.8748605854026601, 0.8958217800360131, 0.8774865475822782, 0.8746709552208097, 0.27612743307754595, 0.8896837301603359, 0.889841165241956, 0.23335426716393626, 0.6797984797323355, 0.6102326691666352, 0.13005912235497563, 0.7026077763570056, 0.7770441137007198, 0.1271675409999682, 0.6314894403073178, 0.1322137637195152, 0.7417752550490893, 0.6061568328545652, 0.5511811193323721, 0.13002592631217869, 0.6773831345150727, 0.5199519906890364, 0.6343870679166816, 0.6802137913511745, 0.7104298938097606, 0.7079978038121602, 0.6563717851145361, 0.6134156959221806, 0.6129601988222647, 0.6536817974161732, 0.6358372524214881, 0.7037524444452619, 0.6945500127964843, 0.6733711258580303, 0.7260920243220774, 0.743301607738821, 0.7756572514218376, 0.7631999827151282, 0.692582523295486, 0.5633362138553744, 0.745171781807294, 0.74692459570695, 0.7632329988266624, 0.7648081824305603, 0.2715362024738821, 0.14056424541712964, 0.4614473881217679, 0.6292625868409203, 0.3703381398350091, 0.4884656540372333, 0.4152346615876167, 0.4009675541718586, 0.24418333608700582, 0.6200600822218769, 0.5956407487743804, 0.6206136376569786, 0.6183587420526694, 0.5772372706661971, 0.6404988187077068, 0.5851586191272172, 0.5755863949872821, 0.6104212068777728, 0.8309040668365719, 0.8413421917924477, 0.84883300424476, 0.8257726117024363, 0.8267192206070213, 0.8422890703125908, 0.8394012425868569, 0.8276265315770212, 0.8086243944188334, 0.09495579302430468, 0.11277418605028378, 0.18362702013144672, 0.136561449257942, 0.12107800099900923, 0.14087666359045925, 0.12217065594650778, 0.12133008923204247, 0.15463727756641732, 0.5859130292872816, 0.3814987875958211, 0.5438569324690721, 0.2723291948756774, 0.7748363545273533, 0.504325189336075, 0.7039864855764596, 0.18730551219823166, 0.23082766463082516, 0.6180505878753939, 0.627200629786377, 0.7179923792015795, 0.6077137327722877, 0.6117334117172608, 0.5339272776804496, 0.7148200698943041, 0.7123763814241123, 0.6940249018549587, 0.505474691128323, 0.6016520464407957, 0.3282435623099995, 0.48469914372374645, 0.5982613936211143, 0.3871122543355485, 0.5341770866447895, 0.5439091012583619, 0.6611630333409884, 0.22134498090533872, 0.2404095529125938, 0.21282504980264605, 0.22194284002958842, 0.2055680548729132, 0.19038439406305807, 0.2113485753356712, 0.41222540950977005, 0.25401759450670214, 0.22329136789300152, 0.19296753623709118, 0.199841167859811, 0.25015859764676696, 0.21937188187205203, 0.18644753922823243, 0.19244670958401633, 0.20798859465098352, 0.19677083727040667, 0.8778611226034041, 0.18650878934237136, 0.15374294377779585, 0.1711101648285408, 0.19937413230461465, 0.17212943801114433, 0.14239023615880464, 0.1637905715944582, 0.20605690697552725, 0.9026132768946252, 0.21167189954444898, 0.12459903733188527, 0.20895373190681266, 0.21163458019183978, 0.15383410392653785, 0.21080216493659332, 0.12725100750918883, 0.1670074197295367, 0.17887140332333096, 0.17263383163098733, 0.17723053656134558, 0.2286239715637831, 0.17661878956370602, 0.17443729960680954, 0.17551031327689948, 0.19214550697548805, 0.18925117677586056, 0.0825995033082969, 0.09404180883668345, 0.09172464640028888, 0.09892697636552972, 0.08497820910557241, 0.09137420507889105, 0.08006260245258112, 0.0978975977139509, 0.09468633102859936]}, "mutation_prompt": null}
{"id": "35fdd462-7617-478c-9dea-c17e5cacae80", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9, inertia_weight=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                # Dynamic scaling factor with particle swarm elements\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search with particle influence\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveParticleSwarmDifferentialEvolution", "description": "Adaptive Particle Swarm Differential Evolution combines particle swarm dynamics with adaptive differential mutation for enhanced exploitation and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.8838649026386449, 0.8715557918660944, 0.8749902775758528, 0.8820572583221025, 0.8698800920908262, 0.882287512374292, 0.8860417656292253, 0.8835486956297138, 0.8725712557403398, 0.7549924184956099, 0.7623576426004728, 0.7742742829210374, 0.7752404140585529, 0.7555943388522153, 0.7716235503845769, 0.7526712763250821, 0.7128399661437188, 0.7759773224291062, 0.6894695540526645, 0.14970635340121152, 0.12205175714808325, 0.15400159020229964, 0.14518889076186647, 0.11248458351457247, 0.15315734881632803, 0.1796585308499432, 0.14019866398111314, 0.09918790536877331, 0.09045532239360532, 0.10756170775194607, 0.12729309210313444, 0.1665996499992971, 0.1079061769461539, 0.11466037873371371, 0.11677616343661534, 0.11865966617918, 0.9691873143240695, 0.9725288404046546, 0.9844377148823121, 0.9561918756726415, 0.9720210778134255, 0.9728252996168898, 0.986849235527256, 0.9850992221375445, 0.9796137395497819, 0.7667221579490293, 0.7609037966118269, 0.7293016869524599, 0.7676191248288152, 0.7286170543904873, 0.7620214165018802, 0.77280434975912, 0.7521419142182314, 0.7657765785757906, 0.8984747213013706, 0.8748605854026601, 0.8958217800360131, 0.8774865475822782, 0.8746709552208097, 0.27612743307754595, 0.8896837301603359, 0.889841165241956, 0.23335426716393626, 0.6797984797323355, 0.6102326691666352, 0.13005912235497563, 0.7026077763570056, 0.7770441137007198, 0.1271675409999682, 0.6314894403073178, 0.1322137637195152, 0.7417752550490893, 0.6061568328545652, 0.5511811193323721, 0.13002592631217869, 0.6773831345150727, 0.5199519906890364, 0.6343870679166816, 0.6802137913511745, 0.7104298938097606, 0.7079978038121602, 0.6563717851145361, 0.6134156959221806, 0.6129601988222647, 0.6536817974161732, 0.6358372524214881, 0.7037524444452619, 0.6945500127964843, 0.6733711258580303, 0.7260920243220774, 0.743301607738821, 0.7756572514218376, 0.7631999827151282, 0.692582523295486, 0.5633362138553744, 0.745171781807294, 0.74692459570695, 0.7632329988266624, 0.7648081824305603, 0.2715362024738821, 0.14056424541712964, 0.4614473881217679, 0.6292625868409203, 0.3703381398350091, 0.4884656540372333, 0.4152346615876167, 0.4009675541718586, 0.24418333608700582, 0.6200600822218769, 0.5956407487743804, 0.6206136376569786, 0.6183587420526694, 0.5772372706661971, 0.6404988187077068, 0.5851586191272172, 0.5755863949872821, 0.6104212068777728, 0.8309040668365719, 0.8413421917924477, 0.84883300424476, 0.8257726117024363, 0.8267192206070213, 0.8422890703125908, 0.8394012425868569, 0.8276265315770212, 0.8086243944188334, 0.09495579302430468, 0.11277418605028378, 0.18362702013144672, 0.136561449257942, 0.12107800099900923, 0.14087666359045925, 0.12217065594650778, 0.12133008923204247, 0.15463727756641732, 0.5859130292872816, 0.3814987875958211, 0.5438569324690721, 0.2723291948756774, 0.7748363545273533, 0.504325189336075, 0.7039864855764596, 0.18730551219823166, 0.23082766463082516, 0.6180505878753939, 0.627200629786377, 0.7179923792015795, 0.6077137327722877, 0.6117334117172608, 0.5339272776804496, 0.7148200698943041, 0.7123763814241123, 0.6940249018549587, 0.505474691128323, 0.6016520464407957, 0.3282435623099995, 0.48469914372374645, 0.5982613936211143, 0.3871122543355485, 0.5341770866447895, 0.5439091012583619, 0.6611630333409884, 0.22134498090533872, 0.2404095529125938, 0.21282504980264605, 0.22194284002958842, 0.2055680548729132, 0.19038439406305807, 0.2113485753356712, 0.41222540950977005, 0.25401759450670214, 0.22329136789300152, 0.19296753623709118, 0.199841167859811, 0.25015859764676696, 0.21937188187205203, 0.18644753922823243, 0.19244670958401633, 0.20798859465098352, 0.19677083727040667, 0.8778611226034041, 0.18650878934237136, 0.15374294377779585, 0.1711101648285408, 0.19937413230461465, 0.17212943801114433, 0.14239023615880464, 0.1637905715944582, 0.20605690697552725, 0.9026132768946252, 0.21167189954444898, 0.12459903733188527, 0.20895373190681266, 0.21163458019183978, 0.15383410392653785, 0.21080216493659332, 0.12725100750918883, 0.1670074197295367, 0.17887140332333096, 0.17263383163098733, 0.17723053656134558, 0.2286239715637831, 0.17661878956370602, 0.17443729960680954, 0.17551031327689948, 0.19214550697548805, 0.18925117677586056, 0.0825995033082969, 0.09404180883668345, 0.09172464640028888, 0.09892697636552972, 0.08497820910557241, 0.09137420507889105, 0.08006260245258112, 0.0978975977139509, 0.09468633102859936]}, "mutation_prompt": null}
{"id": "619d7921-25bb-4de2-a2f3-2c3e5e77da92", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9, inertia_weight=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                # Dynamic scaling factor with particle swarm elements\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search with particle influence\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveParticleSwarmDifferentialEvolution", "description": "Adaptive Particle Swarm Differential Evolution combines particle swarm dynamics with adaptive differential mutation for enhanced exploitation and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.8838649026386449, 0.8715557918660944, 0.8749902775758528, 0.8820572583221025, 0.8698800920908262, 0.882287512374292, 0.8860417656292253, 0.8835486956297138, 0.8725712557403398, 0.7549924184956099, 0.7623576426004728, 0.7742742829210374, 0.7752404140585529, 0.7555943388522153, 0.7716235503845769, 0.7526712763250821, 0.7128399661437188, 0.7759773224291062, 0.6894695540526645, 0.14970635340121152, 0.12205175714808325, 0.15400159020229964, 0.14518889076186647, 0.11248458351457247, 0.15315734881632803, 0.1796585308499432, 0.14019866398111314, 0.09918790536877331, 0.09045532239360532, 0.10756170775194607, 0.12729309210313444, 0.1665996499992971, 0.1079061769461539, 0.11466037873371371, 0.11677616343661534, 0.11865966617918, 0.9691873143240695, 0.9725288404046546, 0.9844377148823121, 0.9561918756726415, 0.9720210778134255, 0.9728252996168898, 0.986849235527256, 0.9850992221375445, 0.9796137395497819, 0.7667221579490293, 0.7609037966118269, 0.7293016869524599, 0.7676191248288152, 0.7286170543904873, 0.7620214165018802, 0.77280434975912, 0.7521419142182314, 0.7657765785757906, 0.8984747213013706, 0.8748605854026601, 0.8958217800360131, 0.8774865475822782, 0.8746709552208097, 0.27612743307754595, 0.8896837301603359, 0.889841165241956, 0.23335426716393626, 0.6797984797323355, 0.6102326691666352, 0.13005912235497563, 0.7026077763570056, 0.7770441137007198, 0.1271675409999682, 0.6314894403073178, 0.1322137637195152, 0.7417752550490893, 0.6061568328545652, 0.5511811193323721, 0.13002592631217869, 0.6773831345150727, 0.5199519906890364, 0.6343870679166816, 0.6802137913511745, 0.7104298938097606, 0.7079978038121602, 0.6563717851145361, 0.6134156959221806, 0.6129601988222647, 0.6536817974161732, 0.6358372524214881, 0.7037524444452619, 0.6945500127964843, 0.6733711258580303, 0.7260920243220774, 0.743301607738821, 0.7756572514218376, 0.7631999827151282, 0.692582523295486, 0.5633362138553744, 0.745171781807294, 0.74692459570695, 0.7632329988266624, 0.7648081824305603, 0.2715362024738821, 0.14056424541712964, 0.4614473881217679, 0.6292625868409203, 0.3703381398350091, 0.4884656540372333, 0.4152346615876167, 0.4009675541718586, 0.24418333608700582, 0.6200600822218769, 0.5956407487743804, 0.6206136376569786, 0.6183587420526694, 0.5772372706661971, 0.6404988187077068, 0.5851586191272172, 0.5755863949872821, 0.6104212068777728, 0.8309040668365719, 0.8413421917924477, 0.84883300424476, 0.8257726117024363, 0.8267192206070213, 0.8422890703125908, 0.8394012425868569, 0.8276265315770212, 0.8086243944188334, 0.09495579302430468, 0.11277418605028378, 0.18362702013144672, 0.136561449257942, 0.12107800099900923, 0.14087666359045925, 0.12217065594650778, 0.12133008923204247, 0.15463727756641732, 0.5859130292872816, 0.3814987875958211, 0.5438569324690721, 0.2723291948756774, 0.7748363545273533, 0.504325189336075, 0.7039864855764596, 0.18730551219823166, 0.23082766463082516, 0.6180505878753939, 0.627200629786377, 0.7179923792015795, 0.6077137327722877, 0.6117334117172608, 0.5339272776804496, 0.7148200698943041, 0.7123763814241123, 0.6940249018549587, 0.505474691128323, 0.6016520464407957, 0.3282435623099995, 0.48469914372374645, 0.5982613936211143, 0.3871122543355485, 0.5341770866447895, 0.5439091012583619, 0.6611630333409884, 0.22134498090533872, 0.2404095529125938, 0.21282504980264605, 0.22194284002958842, 0.2055680548729132, 0.19038439406305807, 0.2113485753356712, 0.41222540950977005, 0.25401759450670214, 0.22329136789300152, 0.19296753623709118, 0.199841167859811, 0.25015859764676696, 0.21937188187205203, 0.18644753922823243, 0.19244670958401633, 0.20798859465098352, 0.19677083727040667, 0.8778611226034041, 0.18650878934237136, 0.15374294377779585, 0.1711101648285408, 0.19937413230461465, 0.17212943801114433, 0.14239023615880464, 0.1637905715944582, 0.20605690697552725, 0.9026132768946252, 0.21167189954444898, 0.12459903733188527, 0.20895373190681266, 0.21163458019183978, 0.15383410392653785, 0.21080216493659332, 0.12725100750918883, 0.1670074197295367, 0.17887140332333096, 0.17263383163098733, 0.17723053656134558, 0.2286239715637831, 0.17661878956370602, 0.17443729960680954, 0.17551031327689948, 0.19214550697548805, 0.18925117677586056, 0.0825995033082969, 0.09404180883668345, 0.09172464640028888, 0.09892697636552972, 0.08497820910557241, 0.09137420507889105, 0.08006260245258112, 0.0978975977139509, 0.09468633102859936]}, "mutation_prompt": null}
{"id": "de764374-2fef-4523-8f63-c4895cb2b9ad", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9, inertia_weight=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                # Dynamic scaling factor with particle swarm elements\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search with particle influence\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveParticleSwarmDifferentialEvolution", "description": "Adaptive Particle Swarm Differential Evolution combines particle swarm dynamics with adaptive differential mutation for enhanced exploitation and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.8838649026386449, 0.8715557918660944, 0.8749902775758528, 0.8820572583221025, 0.8698800920908262, 0.882287512374292, 0.8860417656292253, 0.8835486956297138, 0.8725712557403398, 0.7549924184956099, 0.7623576426004728, 0.7742742829210374, 0.7752404140585529, 0.7555943388522153, 0.7716235503845769, 0.7526712763250821, 0.7128399661437188, 0.7759773224291062, 0.6894695540526645, 0.14970635340121152, 0.12205175714808325, 0.15400159020229964, 0.14518889076186647, 0.11248458351457247, 0.15315734881632803, 0.1796585308499432, 0.14019866398111314, 0.09918790536877331, 0.09045532239360532, 0.10756170775194607, 0.12729309210313444, 0.1665996499992971, 0.1079061769461539, 0.11466037873371371, 0.11677616343661534, 0.11865966617918, 0.9691873143240695, 0.9725288404046546, 0.9844377148823121, 0.9561918756726415, 0.9720210778134255, 0.9728252996168898, 0.986849235527256, 0.9850992221375445, 0.9796137395497819, 0.7667221579490293, 0.7609037966118269, 0.7293016869524599, 0.7676191248288152, 0.7286170543904873, 0.7620214165018802, 0.77280434975912, 0.7521419142182314, 0.7657765785757906, 0.8984747213013706, 0.8748605854026601, 0.8958217800360131, 0.8774865475822782, 0.8746709552208097, 0.27612743307754595, 0.8896837301603359, 0.889841165241956, 0.23335426716393626, 0.6797984797323355, 0.6102326691666352, 0.13005912235497563, 0.7026077763570056, 0.7770441137007198, 0.1271675409999682, 0.6314894403073178, 0.1322137637195152, 0.7417752550490893, 0.6061568328545652, 0.5511811193323721, 0.13002592631217869, 0.6773831345150727, 0.5199519906890364, 0.6343870679166816, 0.6802137913511745, 0.7104298938097606, 0.7079978038121602, 0.6563717851145361, 0.6134156959221806, 0.6129601988222647, 0.6536817974161732, 0.6358372524214881, 0.7037524444452619, 0.6945500127964843, 0.6733711258580303, 0.7260920243220774, 0.743301607738821, 0.7756572514218376, 0.7631999827151282, 0.692582523295486, 0.5633362138553744, 0.745171781807294, 0.74692459570695, 0.7632329988266624, 0.7648081824305603, 0.2715362024738821, 0.14056424541712964, 0.4614473881217679, 0.6292625868409203, 0.3703381398350091, 0.4884656540372333, 0.4152346615876167, 0.4009675541718586, 0.24418333608700582, 0.6200600822218769, 0.5956407487743804, 0.6206136376569786, 0.6183587420526694, 0.5772372706661971, 0.6404988187077068, 0.5851586191272172, 0.5755863949872821, 0.6104212068777728, 0.8309040668365719, 0.8413421917924477, 0.84883300424476, 0.8257726117024363, 0.8267192206070213, 0.8422890703125908, 0.8394012425868569, 0.8276265315770212, 0.8086243944188334, 0.09495579302430468, 0.11277418605028378, 0.18362702013144672, 0.136561449257942, 0.12107800099900923, 0.14087666359045925, 0.12217065594650778, 0.12133008923204247, 0.15463727756641732, 0.5859130292872816, 0.3814987875958211, 0.5438569324690721, 0.2723291948756774, 0.7748363545273533, 0.504325189336075, 0.7039864855764596, 0.18730551219823166, 0.23082766463082516, 0.6180505878753939, 0.627200629786377, 0.7179923792015795, 0.6077137327722877, 0.6117334117172608, 0.5339272776804496, 0.7148200698943041, 0.7123763814241123, 0.6940249018549587, 0.505474691128323, 0.6016520464407957, 0.3282435623099995, 0.48469914372374645, 0.5982613936211143, 0.3871122543355485, 0.5341770866447895, 0.5439091012583619, 0.6611630333409884, 0.22134498090533872, 0.2404095529125938, 0.21282504980264605, 0.22194284002958842, 0.2055680548729132, 0.19038439406305807, 0.2113485753356712, 0.41222540950977005, 0.25401759450670214, 0.22329136789300152, 0.19296753623709118, 0.199841167859811, 0.25015859764676696, 0.21937188187205203, 0.18644753922823243, 0.19244670958401633, 0.20798859465098352, 0.19677083727040667, 0.8778611226034041, 0.18650878934237136, 0.15374294377779585, 0.1711101648285408, 0.19937413230461465, 0.17212943801114433, 0.14239023615880464, 0.1637905715944582, 0.20605690697552725, 0.9026132768946252, 0.21167189954444898, 0.12459903733188527, 0.20895373190681266, 0.21163458019183978, 0.15383410392653785, 0.21080216493659332, 0.12725100750918883, 0.1670074197295367, 0.17887140332333096, 0.17263383163098733, 0.17723053656134558, 0.2286239715637831, 0.17661878956370602, 0.17443729960680954, 0.17551031327689948, 0.19214550697548805, 0.18925117677586056, 0.0825995033082969, 0.09404180883668345, 0.09172464640028888, 0.09892697636552972, 0.08497820910557241, 0.09137420507889105, 0.08006260245258112, 0.0978975977139509, 0.09468633102859936]}, "mutation_prompt": null}
{"id": "dbd832f4-1406-41b3-b98d-a63af514b8be", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9, inertia_weight=0.5, q_factor=0.05):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.q_factor = q_factor\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                quantum_motion = self.q_factor * np.random.uniform(-1, 1, self.dim)\n                population[i] = np.clip(population[i] + velocities[i] + quantum_motion, self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "QuantumInspiredAdaptiveParticleSwarmDifferentialEvolution", "description": "Quantum-inspired Adaptive Particle Swarm Differential Evolution employs quantum superposition principles with adaptive differential mutation for enhanced exploration and exploitation.", "configspace": "", "generation": 57, "fitness": 0.29258599101749067, "feedback": "The algorithm QuantumInspiredAdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.5111156998827016, 0.509318654242837, 0.5067332509750961, 0.5056869209099755, 0.5260118012804518, 0.5039841857422369, 0.5150876238479729, 0.49908225225218605, 0.5325485203713415, 0.07115258588345352, 0.04886038257585312, 0.1032359445133163, 0.12169695373629075, 0.1541208715423974, 0.12677472547668256, 0.048188935226662566, 0.11840978307570804, 0.12283883898965575, 0.14153039659172884, 0.13427564303234707, 0.15021610581160638, 0.13652926707434232, 0.11836883901280959, 0.14882014247528874, 0.1302004236770823, 0.12265539304800221, 0.1357361081540841, 0.1393640990912287, 0.11066794041669836, 0.11644393349203641, 0.09004261240668487, 0.13758487605012237, 0.11037483550763605, 0.10412586688295611, 0.09948680336984927, 0.10070191158363373, 0.9707328484980933, 0.972927521943553, 0.9775263962340363, 0.9730718512899275, 0.9751107988044595, 0.9737245601250295, 0.974491852715865, 0.9655677174894758, 0.9742400284533079, 0.3689126467071372, 0.35778843177405695, 0.36200512890588343, 0.3711150866850358, 0.3617036428959344, 0.37200348812366424, 0.34639697087853916, 0.3585398754732638, 0.35783809432299696, 0.8597378392285242, 0.8509816348989996, 0.8697222285594177, 0.8809937406884307, 0.8904930239707088, 0.8679760510448181, 0.852214423769415, 0.8338081071860788, 0.8714631464842981, 0.1323729831442172, 0.21850161727668183, 0.23913819847273243, 0.1300053456317939, 0.22669358213303992, 0.21200682182242658, 0.207956205744519, 0.20723854472465342, 0.1957616085671513, 0.2273739322768109, 0.232424567051835, 0.2306050279834796, 0.2284180318698975, 0.2227943283892193, 0.2217405619225069, 0.22484517212270028, 0.2303953505460128, 0.21908293013340507, 0.0664173941725208, 0.11140463982878246, 0.08079112808602495, 0.10978073850142422, 0.13788233449338605, 0.010649615946847768, 0.04200921354904874, 0.09319218988439804, 0.13413613607496755, 0.18296675148487218, 0.15789093443377278, 0.24261370310235753, 0.12192878623118153, 0.13052810032223683, 0.15769505212093649, 0.1805990765155342, 0.10796256444932695, 0.1999553987227719, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008045208272988047, 9.999999999998899e-05, 9.999999999998899e-05, 0.006064327683631743, 0.008536460677186164, 0.16496256028295742, 0.1328656388907843, 0.13730344458657984, 0.13835811534994025, 0.15287028840366457, 0.13864359642276392, 0.11346801137961282, 0.14450310378730669, 0.12645406760642797, 0.4477485939432373, 0.46628481548329015, 0.4550267466449661, 0.4740984061094057, 0.4716446192407209, 0.4522156631762827, 0.48293868191992984, 0.4818903440297613, 0.4681811471256757, 0.14943871272927567, 0.22548973287401353, 0.1640563344213518, 0.15349653927445817, 0.11539316414417522, 0.14746140106932804, 0.14470276543044258, 0.22895285456639236, 0.10119061767810822, 0.18332346686166912, 0.2950608605572521, 0.19197035633601, 0.30633966988853245, 0.33118242040698853, 0.18610224287512178, 0.3008449711982556, 0.1926477357789006, 0.29594633907561296, 0.3219194035097196, 0.33950369643444267, 0.3424948555432765, 0.34645474577041924, 0.3342351044459706, 0.322804799795232, 0.3304642758381431, 0.3362772240959453, 0.3230568029888451, 0.267758062264817, 0.23263779236894255, 0.2683228824085946, 0.2700190923374639, 0.27292883813624025, 0.2078044863552898, 0.2785669792355352, 0.27028451950690113, 0.23596592540243333, 0.25504400259753635, 0.19952820591186904, 0.23082079200568317, 0.22317225756075654, 0.23506230886921564, 0.2698461781298924, 0.2206248498160972, 0.22520273853462747, 0.22088197969993972, 0.20521282255744855, 0.18723677151413054, 0.21627981357973514, 0.21425613556895928, 0.24524582424812402, 0.20402299654747702, 0.2236163124957128, 0.18707381040747284, 0.19428661846213946, 0.8205791507573879, 0.12609827534727813, 0.15360564532310306, 0.1477457237041192, 0.19921184159528127, 0.8505518933146451, 0.819974192172829, 0.16257776830129678, 0.8004639507068585, 0.7549551394698575, 0.2110419929529096, 0.7732010596628329, 0.2104427697536143, 0.7737623702869748, 0.7178495832004834, 0.7456950816331049, 0.21217047083124252, 0.1552512925973204, 0.1814222633609991, 0.18859804847887796, 0.18340138089510705, 0.19202202762932763, 0.1774805475673531, 0.18802860500432106, 0.1721494771239377, 0.21121146523652334, 0.17971037406804535, 0.1315556251307416, 0.0847750738462193, 0.0938341015917864, 0.08630219742609313, 0.09127702108039215, 0.08902900918922263, 0.08231670507017663, 0.08600396384284359, 0.08024120740946505]}, "mutation_prompt": null}
{"id": "d1107b44-8c44-4c0f-b9b0-4c62b32054d0", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9, inertia_weight=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                # Dynamic scaling factor with particle swarm elements\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search with particle influence\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveParticleSwarmDifferentialEvolution", "description": "Adaptive Particle Swarm Differential Evolution combines particle swarm dynamics with adaptive differential mutation for enhanced exploitation and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.8838649026386449, 0.8715557918660944, 0.8749902775758528, 0.8820572583221025, 0.8698800920908262, 0.882287512374292, 0.8860417656292253, 0.8835486956297138, 0.8725712557403398, 0.7549924184956099, 0.7623576426004728, 0.7742742829210374, 0.7752404140585529, 0.7555943388522153, 0.7716235503845769, 0.7526712763250821, 0.7128399661437188, 0.7759773224291062, 0.6894695540526645, 0.14970635340121152, 0.12205175714808325, 0.15400159020229964, 0.14518889076186647, 0.11248458351457247, 0.15315734881632803, 0.1796585308499432, 0.14019866398111314, 0.09918790536877331, 0.09045532239360532, 0.10756170775194607, 0.12729309210313444, 0.1665996499992971, 0.1079061769461539, 0.11466037873371371, 0.11677616343661534, 0.11865966617918, 0.9691873143240695, 0.9725288404046546, 0.9844377148823121, 0.9561918756726415, 0.9720210778134255, 0.9728252996168898, 0.986849235527256, 0.9850992221375445, 0.9796137395497819, 0.7667221579490293, 0.7609037966118269, 0.7293016869524599, 0.7676191248288152, 0.7286170543904873, 0.7620214165018802, 0.77280434975912, 0.7521419142182314, 0.7657765785757906, 0.8984747213013706, 0.8748605854026601, 0.8958217800360131, 0.8774865475822782, 0.8746709552208097, 0.27612743307754595, 0.8896837301603359, 0.889841165241956, 0.23335426716393626, 0.6797984797323355, 0.6102326691666352, 0.13005912235497563, 0.7026077763570056, 0.7770441137007198, 0.1271675409999682, 0.6314894403073178, 0.1322137637195152, 0.7417752550490893, 0.6061568328545652, 0.5511811193323721, 0.13002592631217869, 0.6773831345150727, 0.5199519906890364, 0.6343870679166816, 0.6802137913511745, 0.7104298938097606, 0.7079978038121602, 0.6563717851145361, 0.6134156959221806, 0.6129601988222647, 0.6536817974161732, 0.6358372524214881, 0.7037524444452619, 0.6945500127964843, 0.6733711258580303, 0.7260920243220774, 0.743301607738821, 0.7756572514218376, 0.7631999827151282, 0.692582523295486, 0.5633362138553744, 0.745171781807294, 0.74692459570695, 0.7632329988266624, 0.7648081824305603, 0.2715362024738821, 0.14056424541712964, 0.4614473881217679, 0.6292625868409203, 0.3703381398350091, 0.4884656540372333, 0.4152346615876167, 0.4009675541718586, 0.24418333608700582, 0.6200600822218769, 0.5956407487743804, 0.6206136376569786, 0.6183587420526694, 0.5772372706661971, 0.6404988187077068, 0.5851586191272172, 0.5755863949872821, 0.6104212068777728, 0.8309040668365719, 0.8413421917924477, 0.84883300424476, 0.8257726117024363, 0.8267192206070213, 0.8422890703125908, 0.8394012425868569, 0.8276265315770212, 0.8086243944188334, 0.09495579302430468, 0.11277418605028378, 0.18362702013144672, 0.136561449257942, 0.12107800099900923, 0.14087666359045925, 0.12217065594650778, 0.12133008923204247, 0.15463727756641732, 0.5859130292872816, 0.3814987875958211, 0.5438569324690721, 0.2723291948756774, 0.7748363545273533, 0.504325189336075, 0.7039864855764596, 0.18730551219823166, 0.23082766463082516, 0.6180505878753939, 0.627200629786377, 0.7179923792015795, 0.6077137327722877, 0.6117334117172608, 0.5339272776804496, 0.7148200698943041, 0.7123763814241123, 0.6940249018549587, 0.505474691128323, 0.6016520464407957, 0.3282435623099995, 0.48469914372374645, 0.5982613936211143, 0.3871122543355485, 0.5341770866447895, 0.5439091012583619, 0.6611630333409884, 0.22134498090533872, 0.2404095529125938, 0.21282504980264605, 0.22194284002958842, 0.2055680548729132, 0.19038439406305807, 0.2113485753356712, 0.41222540950977005, 0.25401759450670214, 0.22329136789300152, 0.19296753623709118, 0.199841167859811, 0.25015859764676696, 0.21937188187205203, 0.18644753922823243, 0.19244670958401633, 0.20798859465098352, 0.19677083727040667, 0.8778611226034041, 0.18650878934237136, 0.15374294377779585, 0.1711101648285408, 0.19937413230461465, 0.17212943801114433, 0.14239023615880464, 0.1637905715944582, 0.20605690697552725, 0.9026132768946252, 0.21167189954444898, 0.12459903733188527, 0.20895373190681266, 0.21163458019183978, 0.15383410392653785, 0.21080216493659332, 0.12725100750918883, 0.1670074197295367, 0.17887140332333096, 0.17263383163098733, 0.17723053656134558, 0.2286239715637831, 0.17661878956370602, 0.17443729960680954, 0.17551031327689948, 0.19214550697548805, 0.18925117677586056, 0.0825995033082969, 0.09404180883668345, 0.09172464640028888, 0.09892697636552972, 0.08497820910557241, 0.09137420507889105, 0.08006260245258112, 0.0978975977139509, 0.09468633102859936]}, "mutation_prompt": null}
{"id": "cdea4642-b307-4ccb-a038-fb35542dfd0e", "solution": "import numpy as np\n\nclass HybridParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.6, CR_base=0.8, inertia_weight_start=0.9, inertia_weight_end=0.4):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight_start = inertia_weight_start\n        self.inertia_weight_end = inertia_weight_end\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        evals_per_inertia = self.budget / 2\n        while evaluations < self.budget:\n            inertia_weight = self.inertia_weight_start - (self.inertia_weight_start - self.inertia_weight_end) * (evaluations / evals_per_inertia)\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridParticleSwarmDifferentialEvolution", "description": "Hybrid Particle Swarm with Variable Inertia and Fused Differential Evolution for dynamic exploration-exploitation balance.", "configspace": "", "generation": 59, "fitness": 0.4022196410242169, "feedback": "The algorithm HybridParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.28.", "error": "", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.8029764308390519, 0.8053045074105636, 0.8129706541461872, 0.8273305936886226, 0.8201384053234158, 0.8182476855077849, 0.8189544428914188, 0.812312119115402, 0.8110733815917937, 0.6612073462857169, 0.6621250746745266, 0.653687603878808, 0.671066771095391, 0.6517659984230011, 0.6324750969404476, 0.6437757675601274, 0.640932015044513, 0.6771217758645511, 0.14759173633143186, 0.1258022012085055, 0.10924572644047426, 0.14637375795012597, 0.14309127979208003, 0.14402596004742485, 0.16618863585007215, 0.13343660440908622, 0.1070460908490013, 0.1555449546253319, 0.13788471830512172, 0.09846723387444112, 0.12967954869349618, 0.10304149181601174, 0.13530094731915998, 0.127108937986941, 0.10755031589448394, 0.10266472791759262, 0.9707909946707284, 0.9810704774287279, 0.9831970140375855, 0.9768277488766156, 0.981167469251554, 0.9664819038680358, 0.9814509801229314, 0.9768079331091344, 0.9877281733297948, 0.6740429945044251, 0.6930139827529374, 0.6759696822091423, 0.6728539262072402, 0.6846511888467888, 0.6911986063803808, 0.6839326664424523, 0.675018939129405, 0.6959478032503332, 0.22368724686839092, 0.8164975225745985, 0.7855579596923736, 0.8089620972201019, 0.8011368187196943, 0.7898927930268196, 0.7887290892939438, 0.8026662768199961, 0.22853345630396915, 0.5190175201669475, 0.5769572170053958, 0.5237794094919372, 0.5301475835014995, 0.2337549974410541, 0.520498506129379, 0.46854421239483923, 0.5210342024938186, 0.27972177314151436, 0.3331311928257935, 0.380205563138456, 0.5279818206092346, 0.544864392398135, 0.5607102649944569, 0.5583859422099773, 0.5597021982942348, 0.550910502476535, 0.2014338867182348, 0.436311478317879, 0.17357955891816368, 0.11502740766504171, 0.03158321468253744, 0.2911343473481185, 0.043023862530603085, 0.4555768103942186, 0.10070414800786509, 0.4675553201078013, 0.11363432975551235, 0.534456125767429, 0.25729537625817755, 0.45226513664160417, 0.06236126984563384, 0.45107921104091, 0.5739455614580691, 0.5808182801353541, 0.6147795080445866, 0.0375783065195352, 0.0904441329742034, 0.16597285709206222, 0.22046056188338214, 0.20834857180013933, 0.06893584073687742, 0.10725515724933243, 0.08887498341248534, 0.09481197963940702, 0.07152673928637143, 0.3717342040249293, 0.44221687689472733, 0.3669142201496304, 0.38304979567621344, 0.36275399464068425, 0.05302353767183976, 0.28042557216873887, 0.3395236944013813, 0.6884722716666207, 0.6877947946602101, 0.7426712511885794, 0.7478524817499556, 0.704228021690374, 0.7586760635124701, 0.7283946880956695, 0.7570296082435819, 0.7401439925939115, 0.0962246122169712, 0.12229019028528687, 0.13199552933793401, 0.1453910789222307, 0.15733925880179667, 0.12571945170862486, 0.10227636254491224, 0.14715826196140713, 0.14420045414372273, 0.17012204438019762, 0.6539072045110284, 0.6210694014046213, 0.6437390379978001, 0.1774290834045238, 0.27995360063239916, 0.6411107683937367, 0.6322336953378442, 0.25360648736824165, 0.4052309511932519, 0.5633628244667179, 0.3762443453518678, 0.6557318764895458, 0.5507822050383628, 0.4267197196793924, 0.6675305302902104, 0.5259184006424213, 0.6554716370783954, 0.3214979558709461, 0.2366972713470109, 0.4468627322641584, 0.36522415534520347, 0.2038411307830036, 0.3408589884463874, 0.5175466416283045, 0.36874964879827943, 0.3626098294762977, 0.2630312871248266, 0.1991941885655235, 0.19970228292850367, 0.21961777151123973, 0.20758017473734336, 0.20798143071395347, 0.2029348204684509, 0.20121535769154386, 0.21243943167636714, 0.19892398815860002, 0.7016869812325572, 0.2032316555562076, 0.18843167756799584, 0.21519089431923122, 0.2371153921698289, 0.2091488378680928, 0.21208646139310605, 0.17949414314373158, 0.18128007264593138, 0.18585322523889614, 0.1526785538200207, 0.8669467412977226, 0.1976842744459506, 0.8520173232265827, 0.14148487885418182, 0.16048892517579838, 0.20843360070245276, 0.8155958755517836, 0.20964385568613952, 0.07332012753655415, 0.8115227034178258, 0.20945679292334307, 0.15330346015732887, 0.20844515709484635, 0.21046509293942384, 0.20992154454288992, 0.18723057242821917, 0.18583275306090896, 0.18115262071739613, 0.20905679919366338, 0.19265648831423943, 0.17812959727385624, 0.18444223968120144, 0.1751497250793156, 0.17289168925546006, 0.08832336861150147, 0.12268867699946218, 0.08946015725019274, 0.09629399121014137, 0.09273081741286182, 0.0953758684881868, 0.08621857199445526, 0.10453586444307716, 0.0967236936844289]}, "mutation_prompt": null}
{"id": "80bbc6b5-b98b-47c7-a700-595060ace99e", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9, inertia_weight=0.5):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                # Dynamic scaling factor with particle swarm elements\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Adjusted crossover probability\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Probabilistic local search with particle influence\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveParticleSwarmDifferentialEvolution", "description": "Adaptive Particle Swarm Differential Evolution combines particle swarm dynamics with adaptive differential mutation for enhanced exploitation and exploration.", "configspace": "", "generation": 53, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.8838649026386449, 0.8715557918660944, 0.8749902775758528, 0.8820572583221025, 0.8698800920908262, 0.882287512374292, 0.8860417656292253, 0.8835486956297138, 0.8725712557403398, 0.7549924184956099, 0.7623576426004728, 0.7742742829210374, 0.7752404140585529, 0.7555943388522153, 0.7716235503845769, 0.7526712763250821, 0.7128399661437188, 0.7759773224291062, 0.6894695540526645, 0.14970635340121152, 0.12205175714808325, 0.15400159020229964, 0.14518889076186647, 0.11248458351457247, 0.15315734881632803, 0.1796585308499432, 0.14019866398111314, 0.09918790536877331, 0.09045532239360532, 0.10756170775194607, 0.12729309210313444, 0.1665996499992971, 0.1079061769461539, 0.11466037873371371, 0.11677616343661534, 0.11865966617918, 0.9691873143240695, 0.9725288404046546, 0.9844377148823121, 0.9561918756726415, 0.9720210778134255, 0.9728252996168898, 0.986849235527256, 0.9850992221375445, 0.9796137395497819, 0.7667221579490293, 0.7609037966118269, 0.7293016869524599, 0.7676191248288152, 0.7286170543904873, 0.7620214165018802, 0.77280434975912, 0.7521419142182314, 0.7657765785757906, 0.8984747213013706, 0.8748605854026601, 0.8958217800360131, 0.8774865475822782, 0.8746709552208097, 0.27612743307754595, 0.8896837301603359, 0.889841165241956, 0.23335426716393626, 0.6797984797323355, 0.6102326691666352, 0.13005912235497563, 0.7026077763570056, 0.7770441137007198, 0.1271675409999682, 0.6314894403073178, 0.1322137637195152, 0.7417752550490893, 0.6061568328545652, 0.5511811193323721, 0.13002592631217869, 0.6773831345150727, 0.5199519906890364, 0.6343870679166816, 0.6802137913511745, 0.7104298938097606, 0.7079978038121602, 0.6563717851145361, 0.6134156959221806, 0.6129601988222647, 0.6536817974161732, 0.6358372524214881, 0.7037524444452619, 0.6945500127964843, 0.6733711258580303, 0.7260920243220774, 0.743301607738821, 0.7756572514218376, 0.7631999827151282, 0.692582523295486, 0.5633362138553744, 0.745171781807294, 0.74692459570695, 0.7632329988266624, 0.7648081824305603, 0.2715362024738821, 0.14056424541712964, 0.4614473881217679, 0.6292625868409203, 0.3703381398350091, 0.4884656540372333, 0.4152346615876167, 0.4009675541718586, 0.24418333608700582, 0.6200600822218769, 0.5956407487743804, 0.6206136376569786, 0.6183587420526694, 0.5772372706661971, 0.6404988187077068, 0.5851586191272172, 0.5755863949872821, 0.6104212068777728, 0.8309040668365719, 0.8413421917924477, 0.84883300424476, 0.8257726117024363, 0.8267192206070213, 0.8422890703125908, 0.8394012425868569, 0.8276265315770212, 0.8086243944188334, 0.09495579302430468, 0.11277418605028378, 0.18362702013144672, 0.136561449257942, 0.12107800099900923, 0.14087666359045925, 0.12217065594650778, 0.12133008923204247, 0.15463727756641732, 0.5859130292872816, 0.3814987875958211, 0.5438569324690721, 0.2723291948756774, 0.7748363545273533, 0.504325189336075, 0.7039864855764596, 0.18730551219823166, 0.23082766463082516, 0.6180505878753939, 0.627200629786377, 0.7179923792015795, 0.6077137327722877, 0.6117334117172608, 0.5339272776804496, 0.7148200698943041, 0.7123763814241123, 0.6940249018549587, 0.505474691128323, 0.6016520464407957, 0.3282435623099995, 0.48469914372374645, 0.5982613936211143, 0.3871122543355485, 0.5341770866447895, 0.5439091012583619, 0.6611630333409884, 0.22134498090533872, 0.2404095529125938, 0.21282504980264605, 0.22194284002958842, 0.2055680548729132, 0.19038439406305807, 0.2113485753356712, 0.41222540950977005, 0.25401759450670214, 0.22329136789300152, 0.19296753623709118, 0.199841167859811, 0.25015859764676696, 0.21937188187205203, 0.18644753922823243, 0.19244670958401633, 0.20798859465098352, 0.19677083727040667, 0.8778611226034041, 0.18650878934237136, 0.15374294377779585, 0.1711101648285408, 0.19937413230461465, 0.17212943801114433, 0.14239023615880464, 0.1637905715944582, 0.20605690697552725, 0.9026132768946252, 0.21167189954444898, 0.12459903733188527, 0.20895373190681266, 0.21163458019183978, 0.15383410392653785, 0.21080216493659332, 0.12725100750918883, 0.1670074197295367, 0.17887140332333096, 0.17263383163098733, 0.17723053656134558, 0.2286239715637831, 0.17661878956370602, 0.17443729960680954, 0.17551031327689948, 0.19214550697548805, 0.18925117677586056, 0.0825995033082969, 0.09404180883668345, 0.09172464640028888, 0.09892697636552972, 0.08497820910557241, 0.09137420507889105, 0.08006260245258112, 0.0978975977139509, 0.09468633102859936]}, "mutation_prompt": null}
{"id": "ea18c897-5991-48ca-828f-220ff16d535d", "solution": "import numpy as np\n\nclass EnhancedParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=60, F_base=0.8, CR_base=0.85, inertia_weight=0.6):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.15 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.05 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedParticleSwarmDifferentialEvolution", "description": "Enhanced Particle Swarm Differential Evolution with Adaptive Local Perturbations and Dynamic Strategy Adjustment.", "configspace": "", "generation": 61, "fitness": 0.32697084424159684, "feedback": "The algorithm EnhancedParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.7387475596878434, 0.7356879937336782, 0.7029375834935498, 0.7347861292751937, 0.7457694238396825, 0.7293289372789953, 0.7429255553547398, 0.7419812536630437, 0.7482217862092322, 0.45757789087345213, 0.4746531837264393, 0.4488966119666087, 0.46026060244544154, 0.4466486634345559, 0.43697361953303926, 0.4358622560100268, 0.4263328566832316, 0.4507338504225623, 0.20232956169800898, 0.09253176730424417, 0.10799552704128179, 0.10601969591156013, 0.13534048267212162, 0.12876408786549132, 0.1235782113991214, 0.177574774249045, 0.14973857849341587, 0.10803474061659435, 0.12030292799343789, 0.11517097855180802, 0.1075559047294189, 0.10903364183127795, 0.09170739014742135, 0.10864453005061037, 0.10390149257446502, 0.09518878018455179, 0.9755708288618412, 0.9675672792667558, 0.9696254731947854, 0.9512723290886618, 0.9645544768506117, 0.9676600059962318, 0.9626964355128667, 0.9697546457563415, 0.982000406145554, 0.37441338774981536, 0.36876189138339066, 0.29245883223477653, 0.3498572183740053, 0.348393173713336, 0.38140035552695106, 0.41927652664473913, 0.4467278759786304, 0.40717630906592084, 0.7098409826189664, 0.7385519428873147, 0.7192291028425901, 0.7436603987297985, 0.3427099715918823, 0.6583039514797141, 0.7049164528449663, 0.721247077688856, 0.7395944346430805, 0.44528793574553927, 0.44464298879477826, 0.3218508477696739, 0.32193015441783523, 0.2818282082283705, 0.11917457827030753, 0.12282162285428788, 0.3855152400838472, 0.3465066486911643, 0.3850493710952331, 0.15971870202846838, 0.27883162885839496, 0.23441905984156408, 0.3310891445587305, 0.28127860748712297, 0.30894177686506963, 0.3121086743827103, 0.2137545059838033, 0.08472807110386527, 0.27479238328469524, 0.24805893422557868, 0.1808168037548391, 0.28804003583267646, 0.11342484965967792, 0.11127823422178895, 0.11496993482273521, 0.10745121616132947, 0.23581779052048968, 0.24506070298315485, 0.19731413675966158, 0.2640174502403565, 0.16976994280640534, 0.22618399704381864, 0.24809311276768353, 0.313589424694276, 0.3019618027118066, 0.19421019461291866, 0.04338465075279507, 0.05960337409984462, 0.1875421595062764, 0.18915155033268394, 0.08245557708540507, 0.06638867564651973, 0.21330926076265289, 0.05375443512974476, 0.24908784396289618, 0.251601523398154, 0.2284202247338316, 0.237535235121219, 0.2535211234853988, 0.2411298175619443, 0.23674516807548185, 0.2451937980538753, 0.2430410230263116, 0.5897871107505366, 0.6310663511187463, 0.613411779304101, 0.5838588080898377, 0.5960520589921214, 0.6248360680793155, 0.595055905563564, 0.5808568089631975, 0.6188728566974897, 0.11448410603677117, 0.11310485365518053, 0.1037666799796867, 0.10697690622015454, 0.1320624483731806, 0.09549965691984685, 0.1244045519884095, 0.11560086671916181, 0.09458126378666909, 0.17817151367131334, 0.15453489575779045, 0.17091500942802518, 0.19564589998560045, 0.3233291494223115, 0.3013455714764346, 0.19240440077778476, 0.1685126994518088, 0.1744734279844019, 0.407231080435144, 0.3883712589514442, 0.4206178171592003, 0.4087786379605973, 0.4170485016292842, 0.3923755524460215, 0.40467969515482693, 0.4415926785971165, 0.4195393116081063, 0.3088421283991908, 0.3056679914965976, 0.317709919941346, 0.3234315438749982, 0.2261807837550892, 0.3152836549920437, 0.323275972694296, 0.3307918558593168, 0.19377054406854488, 0.20236926850756798, 0.20517396943636323, 0.23224515990039774, 0.20015066845920815, 0.25595994374095876, 0.2124179617581844, 0.21482787451403917, 0.2265141582315946, 0.2164739874243209, 0.36945577101630167, 0.22107807779051314, 0.20220019891486918, 0.18498374099386528, 0.2199687676887716, 0.3935404010509935, 0.19288442797745708, 0.22720990581334577, 0.19779705621427013, 0.1840515752835148, 0.18597379019145444, 0.18414809392420495, 0.819089764611087, 0.19683696678953322, 0.1968487375703365, 0.14137536494893344, 0.16198813831985104, 0.7526783445279149, 0.7608301036960984, 0.21115796385251784, 0.12652910643788218, 0.7295829699776557, 0.16751886274142436, 0.1505338878958422, 0.10384163584261419, 0.20923927742762904, 0.7492084181929246, 0.19417466717691856, 0.19071112519467293, 0.19882185220444304, 0.17598631310169333, 0.19046074026140258, 0.1870466872035409, 0.1869084701440813, 0.18513265671495138, 0.1898661534495799, 0.08276749415341711, 0.08075246655672841, 0.1028179471439904, 0.08928061498275108, 0.08321478067312216, 0.08161378700462796, 0.07443202090938139, 0.08936616472211223, 0.08170874218919177]}, "mutation_prompt": null}
{"id": "c60369ad-6cd7-4270-9dc5-b323a2c36ffe", "solution": "import numpy as np\n\nclass EnhancedHybridSwarmEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                # Stochastic scaling factor with environmental influence\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5) * (global_best_idx / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                # Enhanced crossover probability with random adaptation\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                # Proactive local search with particle adaptation\n                if np.random.rand() < 0.7 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.4, self.dim) + 0.2 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedHybridSwarmEvolution", "description": "Enhanced Hybrid Swarm Evolution combines adaptive particle dynamics with stochastic differential mutations and environmental adaptation for robust optimization.", "configspace": "", "generation": 62, "fitness": 0.44936056265602914, "feedback": "The algorithm EnhancedHybridSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.8324810940330134, 0.8157394663887114, 0.8114102966741545, 0.8341569888769217, 0.8056244446773619, 0.8444037735296401, 0.8250661326315366, 0.8247691349611138, 0.8125695668512686, 0.6539537537721564, 0.6417648539587929, 0.6151153279272652, 0.6202806251343831, 0.598737094268577, 0.6306345130686256, 0.6226881544512188, 0.5732752294470718, 0.6308460192386695, 0.17618562100175772, 0.15962066520067253, 0.12835694090668492, 0.13483300480297966, 0.16380674712044296, 0.16503509757172252, 0.37894751521070535, 0.15288874543389974, 0.10937144078233052, 0.13594691678643012, 0.12075275781602746, 0.14432117537871236, 0.13785745621499845, 0.15415716422345782, 0.12639251287020148, 0.11338750340945714, 0.09667712117787464, 0.1215375808981598, 0.9792884389449451, 0.9767572425143481, 0.9811344924190578, 0.9604997338884094, 0.9788679529871726, 0.9737583083681322, 0.9783351640642447, 0.9766855364376374, 0.9729387294957591, 0.6372004508162581, 0.6457759422408393, 0.5870253544593327, 0.6472757687486106, 0.631823813602655, 0.6601211149779622, 0.6499510621438338, 0.6126277474887869, 0.6295318788859834, 0.8239844823008465, 0.7552073872162325, 0.8355587366659362, 0.8203884798987386, 0.8006472713503858, 0.7873430426600058, 0.8589801512805793, 0.856400243606426, 0.8031509880873993, 0.5952714493000879, 0.6123692453964995, 0.5731939345923591, 0.636596314885227, 0.641465236767893, 0.13049021806016226, 0.6025044757028639, 0.5914763752967795, 0.607476576833097, 0.5954147613981329, 0.5489928008252107, 0.5857662274083578, 0.6373884201308818, 0.5214753445640365, 0.5534564784019208, 0.6162318269895688, 0.12134900468024001, 0.5726071939274986, 0.5235414760600582, 0.5265560414201319, 0.5373952428849029, 0.03683267308233262, 0.00245034847757275, 0.48026175487783196, 0.5285455691908176, 0.5504310065118921, 0.5565393012618502, 0.5863666392160871, 0.5229479754247579, 0.5371368514913466, 0.5313312508714054, 0.5822580461712212, 0.4427680420093365, 0.6016743242148753, 0.5772193508935011, 0.6253870142434517, 0.19015520187684998, 0.2175929530373849, 0.3578121974153051, 0.4871490437950635, 0.27971074272950613, 0.1894565437115464, 0.35105393178454747, 0.2508194549231806, 0.14507677082572845, 0.4525275414636408, 0.43001073627550024, 0.45114452222932666, 0.45843834736765343, 0.4296982945340154, 0.4509052697780903, 0.462534979354454, 0.4409323018795238, 0.42977054662482583, 0.7636141115851444, 0.7585410453373093, 0.7739114940777233, 0.7707368910774945, 0.7577675759647797, 0.759317262525982, 0.7721342882825588, 0.7521961963943002, 0.7707635300778921, 0.11673439515972783, 0.1146499890416115, 0.1426808543256327, 0.4960364781931529, 0.1372066067189186, 0.15327940162641984, 0.13887346930544942, 0.14904159770162806, 0.12980812217969617, 0.3200754175948056, 0.19456895149516962, 0.5655773110688844, 0.638173957025326, 0.49983478271820725, 0.15953228207036552, 0.16983717691154465, 0.17932392352179616, 0.1979988290351653, 0.5453331073940022, 0.2781305367898721, 0.5649168897720906, 0.545560106684248, 0.531078221677741, 0.5634726446993646, 0.5626569284781536, 0.5601042505519582, 0.5944100988606063, 0.2897530372682775, 0.456726401090891, 0.45812251652522795, 0.514829133007312, 0.2044649253696169, 0.3795862423652837, 0.4668595842360561, 0.4610991813204359, 0.4380403117442001, 0.20400922133239596, 0.22966438386093446, 0.2096390149064321, 0.21323597765167168, 0.21062580949589849, 0.2400870674070077, 0.224894720276683, 0.2073012238394193, 0.23853847113478233, 0.19510563544911763, 0.6780120956971811, 0.196550783470396, 0.19325878817837405, 0.572290129682431, 0.21799018003838988, 0.20852201429724493, 0.2154664546979339, 0.22671391909165173, 0.17098821497691952, 0.8871411800696982, 0.1540760995843068, 0.856600803336949, 0.19810309276404647, 0.8496462231084981, 0.6954129443259576, 0.1855695282225801, 0.16052247802541353, 0.8517775485756982, 0.2104332648127477, 0.07345649411956312, 0.8443653522327917, 0.21047630914979076, 0.15421083569592897, 0.16660311962958296, 0.12719109965696096, 0.8208368336093168, 0.20890801953045834, 0.17574062649265265, 0.1712991580077955, 0.17630254452878102, 0.1755447673370576, 0.1739876988161494, 0.1944027163672023, 0.18514957797941356, 0.20075563652320583, 0.09312618797187455, 0.08466091020808886, 0.09050726800646136, 0.08136154053659761, 0.09186941912048951, 0.09417174401616835, 0.08517012930996548, 0.09542404872474286, 0.08401204365063131]}, "mutation_prompt": null}
{"id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.15 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedAdaptiveParticleSwarmDifferentialEvolution", "description": "Enhanced Adaptive Particle Swarm Differential Evolution incorporates adaptive inertia and mutation strategies for balanced exploration-exploitation.", "configspace": "", "generation": 63, "fitness": 0.49110749445986057, "feedback": "The algorithm EnhancedAdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.28.", "error": "", "parent_id": "0e79e682-35b5-44cd-bf9b-094753e9f9e4", "metadata": {"aucs": [0.8500587276586233, 0.8393297956352658, 0.8536358271083151, 0.8404188340575113, 0.8378788012024376, 0.8345322610084017, 0.8417078042554902, 0.840823165461575, 0.834724138905704, 0.6980904892541777, 0.5361666165194587, 0.7103522630866015, 0.7094040877934275, 0.707001565065184, 0.7073552436984976, 0.717209070105833, 0.6960803706891419, 0.6887648121822114, 0.13245764309235142, 0.16689319434457173, 0.11195769710301051, 0.13347140912397681, 0.14903554241391026, 0.16545776623818542, 0.14678805201176892, 0.6145286452432877, 0.1377619213865945, 0.1289574978977256, 0.10683956171484355, 0.09854879337624622, 0.0978925138266834, 0.14427938145891617, 0.10743711709916481, 0.11697784819370427, 0.1245157308333561, 0.09599746930677389, 0.9816934991236178, 0.9806963227906501, 0.9785043231088756, 0.9814964855053749, 0.9753660353003819, 0.9799083817041437, 0.982452796891018, 0.9827826541205467, 0.9726215357318144, 0.7150455677995684, 0.7131986713519862, 0.7196171010120731, 0.7246883785670191, 0.7055871347702466, 0.7225230925689972, 0.7237897325326115, 0.7037961571369891, 0.7037465519316646, 0.8575249700896703, 0.8750646341694386, 0.8483922007093199, 0.846283312159307, 0.8193260783302906, 0.26883980989914125, 0.820387923854257, 0.8614525812359318, 0.8356584321919797, 0.7018016222858495, 0.6173216008966709, 0.6309412168669556, 0.5880648938263864, 0.6862437500946589, 0.584614532382953, 0.702799915656818, 0.6190907229981855, 0.6723797373744136, 0.6089239997789979, 0.6079258816849875, 0.6455422311919338, 0.6359845843918788, 0.5797746140675498, 0.6706370034139202, 0.5756049692942299, 0.6559502503419541, 0.6643463665299043, 0.6146158327185348, 0.4454020612715701, 0.644405774340935, 0.16504824548188157, 0.6383544161593435, 0.4300148340761125, 0.5927173864169516, 0.654352091573793, 0.6224279640235032, 0.665773555366431, 0.6460503729549989, 0.6605603099957409, 0.6420459343709141, 0.6925013724563336, 0.6388894239152377, 0.7096265159133857, 0.6762232654177733, 0.69278154445065, 0.14366094107448246, 0.1371580219380547, 0.4750438298881642, 0.5347509185591841, 0.5720102030064644, 0.34922371478312986, 0.12854249881660418, 0.3063287276910309, 0.33013361067143887, 0.5370290912241378, 0.5635899836356539, 0.5504403871365549, 0.5692855196898163, 0.5667102318643583, 0.5723296982057525, 0.5736440746649352, 0.5172404947713387, 0.4849724810400968, 0.7976480793011823, 0.8029349887075484, 0.7945286374323823, 0.7836721262439252, 0.7962275009171446, 0.7987591528284863, 0.7830177655713308, 0.8023192968249139, 0.8021742229774345, 0.1291523071645161, 0.561557168246466, 0.13104327090800638, 0.14415877848212677, 0.13406015164615603, 0.15092660182599316, 0.15041670633884952, 0.14632214971984592, 0.16614117050821675, 0.21802209870900224, 0.6788210825522554, 0.22572531085297576, 0.6829053522590944, 0.33497120590545315, 0.205531993537291, 0.5093800762504364, 0.37512658227764184, 0.5270855186372665, 0.5106527359391372, 0.6720441195257443, 0.6652311081743296, 0.5323317701433957, 0.6423520301096919, 0.656401368575783, 0.6704337240735279, 0.6827850781099738, 0.6817807741913787, 0.48815457149577013, 0.39923992397764985, 0.4692250398496164, 0.5716296658799125, 0.43522475313795617, 0.6039343245844956, 0.5699815285020562, 0.5266012386299318, 0.5789666154827939, 0.22685697634500934, 0.23315030901100797, 0.21726226575714414, 0.21133892233371132, 0.21798562964313228, 0.24023734151697163, 0.20081941931949387, 0.22567097694733296, 0.21854277009185885, 0.19514730288606175, 0.18741806013648288, 0.20230555707830333, 0.21662456932690266, 0.24322756002632828, 0.21726812422517694, 0.7527954809218548, 0.23754280347276358, 0.21638823490034598, 0.1820135690243042, 0.18553385669114797, 0.1530874763846234, 0.8508934761143182, 0.8559627434144151, 0.1666885727885714, 0.1410986941064839, 0.15996570695042878, 0.17206847982113382, 0.8695995434361168, 0.8576460090890367, 0.865908249490049, 0.20162618137714516, 0.16692280464129494, 0.15302709141228021, 0.16697653599917794, 0.21235519566426042, 0.7966842811067417, 0.17918024937769317, 0.18139510570427997, 0.17659470716992398, 0.20542550575909702, 0.18353254350449988, 0.18932930785249624, 0.18881334384944348, 0.1921147471422976, 0.18966261386987504, 0.08550612028993565, 0.08713220092704654, 0.0954432805637021, 0.0845591815656489, 0.0811993136261242, 0.09160317423402431, 0.08488661947751897, 0.09223614648385714, 0.08675495788853915]}, "mutation_prompt": null}
{"id": "25d1c416-14c0-4448-987a-2ad0c8866841", "solution": "import numpy as np\n\nclass HybridPSODEWithAdaptiveLocalSearch:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.5)\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            if np.random.rand() < 0.5:\n                local_search_idx = np.random.choice(self.pop_size)\n                local_solution = population[local_search_idx]\n                perturbation = np.random.normal(0, 0.1, self.dim) + 0.2 * velocities[local_search_idx]\n                local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                local_fitness = func(local_mutant)\n                evaluations += 1\n                if local_fitness < fitness[local_search_idx]:\n                    population[local_search_idx] = local_mutant\n                    fitness[local_search_idx] = local_fitness\n                    if local_fitness < fitness[global_best_idx]:\n                        global_best_idx = local_search_idx\n                        global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridPSODEWithAdaptiveLocalSearch", "description": "Hybridizing Particle Swarm Optimization and Differential Evolution with adaptive control parameters and selective local search for enhanced convergence.", "configspace": "", "generation": 64, "fitness": 0.486294554659482, "feedback": "The algorithm HybridPSODEWithAdaptiveLocalSearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8331658264946132, 0.8344645431553193, 0.8463023695337685, 0.8523050777988271, 0.8453997718940247, 0.8413513258964688, 0.8472808081703753, 0.8510584946973975, 0.8331069657019019, 0.7129946839796795, 0.6929105176898622, 0.712459277940872, 0.7119832913596407, 0.7175159148005581, 0.7267058406209408, 0.6847901879834941, 0.6969212996980363, 0.7205863751615468, 0.11669958650907652, 0.1327973481829533, 0.17146011344841716, 0.11602247511745423, 0.14344673047321888, 0.11438148033496676, 0.12600927986979737, 0.17455551319747342, 0.6066514319857559, 0.1231712481986178, 0.11433017950714419, 0.11996793607024814, 0.11747452245588863, 0.1184586895580988, 0.1274268181446736, 0.13359885633374613, 0.13255284530931732, 0.10110274154394361, 0.9753461131366634, 0.982088546102711, 0.9834914564207344, 0.9704154501062333, 0.9771812779531156, 0.9795488718795147, 0.9822701230959179, 0.9781276127464731, 0.9926910174312105, 0.7177045344488914, 0.7158059188320269, 0.7172479550482934, 0.710766469883046, 0.7082128943659836, 0.6821547624142961, 0.7205592909697036, 0.7005745071240465, 0.7025941831587899, 0.8468487268349516, 0.2265625720155544, 0.8497053231710152, 0.20521102021947213, 0.8666222323772345, 0.8708299725326485, 0.8466169503613019, 0.8159786272162277, 0.8618068771140097, 0.6701308621310083, 0.561166333235826, 0.6258573567921313, 0.6646063881450823, 0.5906414049808224, 0.6101667743567332, 0.7291183115259057, 0.6178181513597955, 0.6468496032880541, 0.6211514512518572, 0.5766160020856457, 0.12753164788827598, 0.5738761025782749, 0.6599230372568687, 0.7078564313573708, 0.7018687030378443, 0.6133376940144412, 0.1341935151500595, 0.5955421077532149, 0.49727431255085397, 0.642085801079479, 0.051039859086683514, 0.6505587904717061, 0.5764011323497134, 0.645354710890388, 0.6477230444889283, 0.6401750754621234, 0.6889211685212472, 0.6473685716364918, 0.7056608446975982, 0.6682520913505301, 0.6482344667873223, 0.6217453202690029, 0.5368129683215515, 0.6820237574070537, 0.688509311323545, 0.0875598104133789, 0.08602762838420008, 0.3506897255366862, 0.32859314379896887, 0.5581617375173031, 0.5341166522091148, 0.13778595547632744, 0.1448018800527925, 0.19946176295803908, 0.5129485350159321, 0.5634406235441123, 0.5554048804517528, 0.565260225834516, 0.5911447661736126, 0.5824028252697451, 0.3112907940848222, 0.576846119643801, 0.47667237465255374, 0.7875926292676212, 0.7932654523997327, 0.8054577970868094, 0.8132537498185604, 0.7877932158060774, 0.8019986882127204, 0.7941801697249213, 0.7943610227647184, 0.7989544335139526, 0.11698467229107923, 0.17082683190340608, 0.1624327038780875, 0.1054213279228643, 0.13522498899341662, 0.14097753042649674, 0.14573223369188704, 0.13476977053084505, 0.16836291747972787, 0.43235209136900443, 0.4247123120392049, 0.21596976167349147, 0.22341448223568883, 0.6478901629109719, 0.6799629713351976, 0.18856094185973604, 0.6045098547429335, 0.3557333582410792, 0.6451481586451, 0.49616720761095234, 0.5388551763048112, 0.6471092437637647, 0.6588303010746461, 0.6474994934595923, 0.6681815724390711, 0.7075482384822599, 0.6704172755587158, 0.4424160381462734, 0.6008445418172915, 0.2921550517279977, 0.39279147607110654, 0.40127059455601166, 0.6152902923398861, 0.5239330865364087, 0.6248280863365214, 0.5740104518188426, 0.22262093617497059, 0.21275298689389555, 0.200243645615359, 0.19963974689978725, 0.20438768169175492, 0.20198812891704188, 0.21729962701983496, 0.21220153028261157, 0.226818207991361, 0.21363100818396674, 0.18156603569384178, 0.18905006454203288, 0.6908363277600336, 0.24199265204431553, 0.19550824681644874, 0.7224844107406664, 0.24492036271227668, 0.2187657997770247, 0.16131571012493806, 0.1847666506809834, 0.15299570681189267, 0.8843148888990049, 0.19849469205363934, 0.19883803302132108, 0.14186193360961064, 0.8411184446293798, 0.879827741322561, 0.8606081166241977, 0.21047125978707304, 0.8608096672902037, 0.8696936353358893, 0.20914063097014302, 0.8320172284527334, 0.15504217443407797, 0.10338200676558973, 0.8511477026275954, 0.19428071368650746, 0.18433110713694112, 0.18492752947598257, 0.18730289176411086, 0.18399222110512692, 0.1913635110945061, 0.1762347908551375, 0.18633244061336918, 0.18316558404874228, 0.09396835485143329, 0.09632997782976094, 0.0958688991938097, 0.0922510841725438, 0.09625007611341185, 0.08866971635165244, 0.08856158654362933, 0.091007184307772, 0.08686395361687194]}, "mutation_prompt": null}
{"id": "d552b396-714b-44cd-8ca2-017fe1996d76", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.5)\n                else:\n                    F_dynamic = self.F_base * (1 + r3 * (personal_best_fitness[i] / (fitness[i] + 1e-8)))\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.15 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedAdaptiveParticleSwarmDifferentialEvolution", "description": "Hybrid Particle Swarm and Differential Evolution with dynamic inertia and mutation scaling for enhanced adaptability and exploration.", "configspace": "", "generation": 65, "fitness": 0.46703597389241847, "feedback": "The algorithm EnhancedAdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8268632884891368, 0.8183349756117348, 0.8259314076217796, 0.832479699513957, 0.8280482864852579, 0.8265260047232367, 0.825734934511001, 0.8208510241488519, 0.8308172474515698, 0.668971119995206, 0.6904154349492206, 0.6882257866047736, 0.6710508533155475, 0.6806156153657041, 0.6739804490149218, 0.6687733442543646, 0.6754312154508325, 0.667509567628249, 0.10574776831279309, 0.15844227128127641, 0.13708735825163298, 0.12941018951671956, 0.13351774079129464, 0.17001913734489404, 0.12700079499346706, 0.1048305071720822, 0.1354824966484779, 0.10624601813398293, 0.13845987193956277, 0.1374148867287226, 0.10743607935288035, 0.09599419382095564, 0.12168842431611415, 0.1233626924566843, 0.10365227360021467, 0.11669388926778079, 0.9770023831158068, 0.9842946965219197, 0.9759920894954577, 0.985896704879331, 0.9793577795156618, 0.9866255714094979, 0.9893124431123217, 0.984818023463023, 0.9816786251595294, 0.6834147234811201, 0.6742991554269502, 0.6671117650787344, 0.6881078552488944, 0.6629551082996619, 0.6823175928063294, 0.6584040552133485, 0.6790176663208096, 0.6549722515967984, 0.8219431021956316, 0.8325496355112838, 0.8215877232230268, 0.831423955445799, 0.8255314245310321, 0.20701017736349325, 0.8491203370345362, 0.8249058471602906, 0.7999869038360038, 0.5982985181942791, 0.5851466104573964, 0.5962253057755316, 0.5515766184781007, 0.6427741584953832, 0.5951657899972653, 0.5753725636826708, 0.1261409239699557, 0.5985990774490284, 0.5607650656630535, 0.547111582131896, 0.4890428785650255, 0.630072246891164, 0.5347132879309167, 0.6144299341032197, 0.5094045537725682, 0.5983996598728003, 0.5572874095229432, 0.5826300266381161, 0.5234793090278447, 0.5249756917539883, 0.6270920529734221, 0.4546442863604476, 0.4669711151299756, 0.5699390083904976, 0.5630462088768887, 0.5487324174521833, 0.6713283075578003, 0.6405632651619797, 0.5878551171845956, 0.5936977450596059, 0.5734536366578551, 0.4943482977926912, 0.6569527926163685, 0.6754031059265974, 0.6439435702112578, 0.451111464867741, 0.40237972893778773, 0.07773025723195481, 0.5092073525089524, 0.1390214736215516, 0.4985110647554518, 0.16663816322522595, 0.3023072740734215, 0.34396190581531805, 0.490335082248088, 0.48277521645164356, 0.4913384759676822, 0.537789807054872, 0.5014260083622475, 0.4967409039864883, 0.48786762913001325, 0.4822699510459275, 0.4891603476574917, 0.7777189740033756, 0.765626223223674, 0.7795832857931955, 0.7798603386003604, 0.7659624088811651, 0.7741712559832735, 0.7591429604687931, 0.7533767654864482, 0.7691970560721811, 0.1655431594632133, 0.1061100554736708, 0.13394265693016771, 0.12088581528263986, 0.1259192033042822, 0.13975807629476045, 0.17659126902860078, 0.16935045275664828, 0.14459439648136008, 0.5173216371179676, 0.1997354054005861, 0.16927169200863845, 0.23295915114399468, 0.6597052446176903, 0.547301236306823, 0.549099772864182, 0.532935440597089, 0.164038419829855, 0.5938134092274375, 0.6118397640224604, 0.6055077012189186, 0.5474157251725318, 0.5965360014886587, 0.6226538520745355, 0.6206702892280704, 0.6375154237705236, 0.5547424854221346, 0.2661198068569093, 0.19369512446269732, 0.44677858417387284, 0.40484333701035913, 0.4020406071136987, 0.4541895902786518, 0.5386952158643539, 0.5220757318140015, 0.5335851981324637, 0.22553786399009101, 0.197549158383012, 0.2132403053227091, 0.23058148924483335, 0.20276993135986776, 0.22677222230029415, 0.2745582419035494, 0.20172282324885848, 0.22159655673183165, 0.6872297889708021, 0.20067107349806934, 0.18336914429757967, 0.24039002724790848, 0.21347483963973823, 0.2353133297558856, 0.23317046852366408, 0.2349841417809998, 0.19406350626705848, 0.20948387136478952, 0.1819465598217581, 0.19661346410267266, 0.18126904245053532, 0.1983815557813633, 0.8510448291640438, 0.8600400833242268, 0.16904418241648833, 0.8404036960017259, 0.8192932861718172, 0.2106955252221705, 0.8580303307562354, 0.7988811759935333, 0.16677726802072845, 0.15264188865487016, 0.2119985283096486, 0.82547416794914, 0.2122094771786195, 0.1877119263847815, 0.17809183372323556, 0.17845581858048754, 0.18109250074147099, 0.18386011511621292, 0.18592470700292174, 0.1782390304001461, 0.1860805127418088, 0.1830460742490041, 0.08891922681798858, 0.08769831818670248, 0.09125593206379723, 0.08723442419862859, 0.08396981215490829, 0.08832114356563447, 0.09454196996627595, 0.08552315376679487, 0.0933211230252109]}, "mutation_prompt": null}
{"id": "ef156365-743d-4af2-9e8e-d4cc9b3e2963", "solution": "import numpy as np\n\nclass HybridPSO_DE_Adaptive:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5) * (fitness[i] / (personal_best_fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridPSO_DE_Adaptive", "description": "Hybrid Particle Swarm and Differential Evolution with dynamic learning and adaptive local search strategy.", "configspace": "", "generation": 66, "fitness": 0.48433850698887904, "feedback": "The algorithm HybridPSO_DE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8347243257865136, 0.831246923296358, 0.8395390907766439, 0.8366799896690711, 0.8416016389009581, 0.8428546852644355, 0.8404350267593299, 0.8272435493634455, 0.8456030492239217, 0.7168076609720975, 0.706120854688854, 0.7064641261487712, 0.7226333377914559, 0.7065777317793578, 0.7093555728387984, 0.7140258678769061, 0.6980361670037434, 0.6952618087942622, 0.14875123780495436, 0.14544644352595626, 0.14090166180021912, 0.14137321397168312, 0.16864190012009583, 0.1395556543173101, 0.16089773850178735, 0.14937581428745816, 0.1775811521138556, 0.11139425182699547, 0.10086521780476765, 0.11046693430529797, 0.17484131308029915, 0.12202560574547627, 0.10918691468621544, 0.11660296949979543, 0.12910306010298933, 0.12282478254856655, 0.9833877857293236, 0.9691145280449991, 0.9767187538827989, 0.9818038688894303, 0.9770626370606824, 0.977780544667653, 0.9804444256879765, 0.9831614983396723, 0.9784184324091932, 0.6870639850149196, 0.7131968117643954, 0.6838679439517426, 0.7144362289918595, 0.6808473085489145, 0.7081252563850768, 0.6750176241996959, 0.7036663553973151, 0.7144047278677086, 0.8561402234516011, 0.8628034803190078, 0.8427114724060096, 0.8631345084745876, 0.8411255054204962, 0.8471214966058829, 0.839719384414773, 0.8403900657777756, 0.8259124085856931, 0.6465135694362258, 0.7038965153472816, 0.6601499612764674, 0.6149447448791002, 0.6108637959471593, 0.6310793981026092, 0.6680360611673722, 0.5679380613065595, 0.12934198131110575, 0.5286668297576416, 0.5369714654974291, 0.689081588423, 0.5864622489796549, 0.6486598850413996, 0.6852554042551131, 0.673347016476969, 0.5190757984838716, 0.647241968058077, 0.6258671389612908, 0.6398195018271062, 0.6533943438281051, 0.5032609592070143, 0.6326271373877663, 0.5235063068386641, 0.6142593583870135, 0.5827937592716225, 0.5250386881741242, 0.683589276237382, 0.6628178668148117, 0.6715197278701817, 0.6980057354861924, 0.6685073024649506, 0.6379632527680194, 0.6675069406406812, 0.6785690053116935, 0.6657613394501293, 0.08620910447978436, 0.20224109209898733, 0.080123026430161, 0.5543546579801895, 0.5804331418227074, 0.5502490946809209, 0.12520847473141894, 0.16641455433720898, 0.23386325293184884, 0.5498112169177412, 0.532406286858792, 0.5379693160388437, 0.5491365599445672, 0.5566885974541359, 0.540374083415788, 0.5368644746952401, 0.5358609989633156, 0.5216805410779224, 0.7874288198282572, 0.7870443509239996, 0.7914274204183576, 0.8095695445624176, 0.7868049678484619, 0.7852896030415786, 0.8029785884724687, 0.7894852301872604, 0.8018773222857463, 0.1448105383414391, 0.11111637121438511, 0.10757496082276197, 0.14329173521243488, 0.14616047733631365, 0.12649070986971578, 0.1170885233463701, 0.10863666659261195, 0.12854368195707044, 0.6157245259505126, 0.2682878820975413, 0.7080986847670723, 0.26208574356405223, 0.6066984571179157, 0.178851335015203, 0.27189387534846443, 0.23499894192615267, 0.4202068153119901, 0.5730388272048288, 0.6589545116968998, 0.6626346058085775, 0.6617915670071557, 0.6426116000793476, 0.6594647973506821, 0.6749954566651435, 0.6879107461509709, 0.6426754598647653, 0.3833212387232957, 0.26762641878954574, 0.551101788581327, 0.6082684519286203, 0.4303401600013256, 0.5257655904697016, 0.5066689410407983, 0.37676553802899193, 0.5966407267991521, 0.21133047634749935, 0.22292432508152638, 0.2234654888739238, 0.2169631322247242, 0.19435367139596105, 0.2114693087542744, 0.21000006891969536, 0.21581349158021124, 0.20596031833802797, 0.23939607555261122, 0.20308604149242304, 0.2392082640390235, 0.19508980370032836, 0.21744086642665006, 0.20924147217859734, 0.19662458006119, 0.6666102723389239, 0.21261925473567111, 0.20799110670836773, 0.8773155400144396, 0.1535301865445715, 0.8792258822549589, 0.19768925031628182, 0.19681586178666044, 0.17747251319021484, 0.16448098905202935, 0.17374217190889407, 0.8650497888665463, 0.1275082930570447, 0.2075354921657515, 0.20512849954109602, 0.7690155873345594, 0.8363841645580591, 0.2114198195590088, 0.21108255899836503, 0.8428466612146017, 0.17410147252498442, 0.17670634168601596, 0.17555182195401098, 0.1871031108771588, 0.1839163526601082, 0.18237665595198105, 0.18782823038133512, 0.17992013405908547, 0.19062872300802525, 0.09271088259002058, 0.08349144268224751, 0.08603596319474693, 0.08444366877849119, 0.10043610845640216, 0.0845188551790459, 0.08668403004143821, 0.1002754347407947, 0.09666785736640027]}, "mutation_prompt": null}
{"id": "2b0581ba-5af6-4523-9e3f-a08ce09739ab", "solution": "import numpy as np\n\nclass AdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.4 * (np.random.rand() - 0.5)\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveParticleSwarmDifferentialEvolution", "description": "Adaptive Particle Swarm Differential Evolution combines dynamic inertia, mutation, and crossover strategies with local search for robust optimization.", "configspace": "", "generation": 67, "fitness": 0.47536024662796444, "feedback": "The algorithm AdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8425600468073614, 0.8273375038227351, 0.8460016533746004, 0.8510393217359605, 0.8334278529194358, 0.8470753724878586, 0.8378092940132267, 0.833314369167983, 0.832305585110447, 0.6736460929682148, 0.7053081415717029, 0.6985797017374796, 0.7113755500208092, 0.68998365356764, 0.7139531673373597, 0.7043834780547205, 0.6989777774243022, 0.7227794354147721, 0.13472161955985595, 0.12767344526258917, 0.1618567217046284, 0.13159311298344423, 0.1529516246583722, 0.14292507636048613, 0.16602489069408544, 0.1379168994793024, 0.6793628209273939, 0.10579294581320842, 0.12067338505690439, 0.10161506802741171, 0.1053531797816073, 0.1026988124143039, 0.12484132169995388, 0.12052237468354343, 0.13210450174383548, 0.10883180709697626, 0.9742280937749225, 0.9811221252859618, 0.986395315293742, 0.9784485818353782, 0.9831003740586691, 0.9788730365858592, 0.9868638477952438, 0.9811279901827069, 0.9816903055665648, 0.7201929229190858, 0.7136227079712736, 0.7097172480468508, 0.7308240982846974, 0.7058483725521465, 0.7197436033574025, 0.7069494352150913, 0.7054224012692158, 0.7154962674567897, 0.22584102838861786, 0.8642980773036705, 0.836760496708747, 0.20928205476694428, 0.8683934768356234, 0.7051063284860817, 0.846911830016557, 0.8337396688153647, 0.8641669932463018, 0.6575387504372894, 0.5916311779331083, 0.6657018458458753, 0.12998077460375568, 0.6080354284271251, 0.6181417419002262, 0.6427397867124349, 0.6430364638524484, 0.6862691930999416, 0.6575447769621703, 0.12768461368315187, 0.6655284563865728, 0.5472962653889069, 0.6676874561605378, 0.684960518195068, 0.5869962346251358, 0.6640696848171381, 0.6597734602503674, 0.46345663647453383, 0.6368092209445299, 0.6316314988513136, 0.46183192017937413, 0.5525225257328084, 0.6218619149941575, 0.6164607156961283, 0.6268344274147515, 0.5973611999443754, 0.6727863320522005, 0.6802714742034676, 0.686590144067107, 0.6898226047473535, 0.6555841451918061, 0.6945672964785476, 0.6748502585480114, 0.640029239350214, 0.6935663999502889, 0.1374775543729747, 0.3702343366670734, 0.300698426102622, 0.5749590892065646, 0.5934418388623566, 0.5697451565562377, 0.14767723096892382, 0.1705345836346852, 0.3524428075669419, 0.5662331349197609, 0.5617815113979101, 0.5527207235493552, 0.5687382098840638, 0.549398452783188, 0.557592969120849, 0.5460494914005506, 0.5573821244650371, 0.5199981867629029, 0.8057338235952269, 0.7995996944443182, 0.8041216954179945, 0.8070235338303979, 0.7968800793020112, 0.8047636372228926, 0.7957334651025154, 0.7723829180595709, 0.8127118583068816, 0.11487410922721919, 0.1427264441457251, 0.11572874238274056, 0.13768054146398168, 0.09967741276480324, 0.1255190748041075, 0.10490981775587094, 0.145888662487347, 0.1179716895317362, 0.17852372871404165, 0.2100009417767802, 0.38237807365570875, 0.5662768289833089, 0.6794262995328213, 0.5608422175474832, 0.25151976983632696, 0.24149443275389704, 0.24494121479588837, 0.3743203545471293, 0.6449135830091344, 0.6570854327731519, 0.5126729651785065, 0.49596607117028413, 0.6464144852188246, 0.4953170353238513, 0.6791267462865527, 0.6618950242176923, 0.2885942142397877, 0.49170980628411676, 0.4309301149909789, 0.5024870417495635, 0.4938499164864222, 0.521955180913659, 0.4515280802858763, 0.3724230124022184, 0.589703875290706, 0.246510447287556, 0.19975621326879578, 0.2078305850259483, 0.1996309070539778, 0.1985056962708499, 0.19535214480345553, 0.20114724747855783, 0.2130199193400254, 0.20815336930876072, 0.7442724862410772, 0.21304966871041342, 0.2212538912410953, 0.2413710870997685, 0.21337257632363327, 0.2181503323086006, 0.18801092209082004, 0.24185820975915684, 0.21890950968813483, 0.17535448745037396, 0.1849273887773939, 0.15332776297237483, 0.8819756045745596, 0.19897897503310502, 0.19821601366345964, 0.1416276824223267, 0.16248017941678594, 0.2085397832443, 0.885796477442294, 0.21084061541474575, 0.8749940954949814, 0.2100300604640436, 0.16699408180887165, 0.8421879042042913, 0.8387565014660041, 0.12694453056780786, 0.20766598017496807, 0.1805668467809073, 0.17814004222940982, 0.19162644324654432, 0.19031428565734476, 0.17646654926249394, 0.17135865995327826, 0.18998607810839097, 0.17139342134603486, 0.20182592045832537, 0.09118838522904482, 0.10042513776784212, 0.08102517519076224, 0.09129769833022294, 0.08700294604373904, 0.09496590921724202, 0.09432334927248898, 0.08438603036802739, 0.09145870764661213]}, "mutation_prompt": null}
{"id": "c6f7faac-68e3-4b56-b057-985a3dc995d1", "solution": "import numpy as np\n\nclass HybridAdaptivePSODE:\n    def __init__(self, budget, dim, pop_size=60, F_base=0.85, CR_base=0.95, inertia_weight=0.6):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - np.cos(np.pi * evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if np.random.rand() < 0.3 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.05, self.dim) + 0.10 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridAdaptivePSODE", "description": "Hybrid Particle Swarm and Differential Evolution with dynamic parameter adaptation and local search to improve convergence across diverse optimization landscapes.", "configspace": "", "generation": 68, "fitness": 0.47775152607623056, "feedback": "The algorithm HybridAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8550016529549564, 0.8531080048375828, 0.8492920392350585, 0.8662696530381514, 0.8539153408032303, 0.8408848133360346, 0.8574404817154637, 0.8662525714848742, 0.8565355777198236, 0.7455566119154993, 0.7300623646541219, 0.7437617678001891, 0.7096838377204919, 0.7148313002121616, 0.7227084108787859, 0.72956039818841, 0.69823560952742, 0.7219633355698218, 0.13884609438920725, 0.16731010145101022, 0.12524805609635437, 0.1468735218853242, 0.11720463890287791, 0.16833233799389524, 0.13915295116739634, 0.11597619738644194, 0.1208050553683222, 0.10489986667898088, 0.10437167241471779, 0.15057120688441405, 0.10551126840487901, 0.11992563625945551, 0.1077941446800742, 0.12436176833259727, 0.10830642945189028, 0.14861304620719384, 0.9808111732851306, 0.9270415002747553, 0.9810626359975275, 0.9780634984975293, 0.8957749615762726, 0.9816512485247202, 0.9788148050859252, 0.9580807984911989, 0.9757629174292859, 0.6996648203061416, 0.6740935570946163, 0.7377355927916929, 0.7001523951398839, 0.6720333908871104, 0.6972851795270856, 0.6998219860467116, 0.7124460050085997, 0.7132080141158031, 0.8661556579322159, 0.8544050981866231, 0.8726683294142576, 0.8867033346701026, 0.8813699891252573, 0.874065589842921, 0.8723814178319957, 0.8749844288427406, 0.8866604433512812, 0.12912686893771042, 0.5919282333085505, 0.5792684768090506, 0.5193312169121252, 0.5103505687303598, 0.6604179822811937, 0.6380206245897115, 0.6415494557254738, 0.6202425952655317, 0.13012245860125826, 0.7252715518993399, 0.3890278326314953, 0.5422427355453623, 0.42224987453493645, 0.6604219931070647, 0.6545665935847539, 0.5643984753925226, 0.7088985905571843, 0.6576958559079971, 0.6870572471426057, 0.6081247918427286, 0.6453716967910131, 0.6731145664359321, 0.6583048734719819, 0.675490074723215, 0.6648021888157689, 0.6562929268931357, 0.756447618371789, 0.7370112794402816, 0.726066384586954, 0.7426831545119992, 0.7450467182086113, 0.7640679587800179, 0.7360837998608709, 0.7580868281261837, 0.7562663471140268, 0.3112102438854156, 0.24482493170882613, 0.13526049307202392, 0.22888202083167442, 0.4517120836205373, 0.19758324909918112, 0.30028446162721634, 0.36536189768535476, 0.3716053451336022, 0.4955532964192376, 0.442641935587469, 0.465064848594422, 0.4807202470924411, 0.47919166912412015, 0.4901126321365822, 0.4536590747840875, 0.4484380678917653, 0.4906775568617836, 0.8092477223364527, 0.8137075240286581, 0.8099441695112857, 0.8106300138735993, 0.8179220479322783, 0.8154230563777618, 0.811727318024735, 0.8069873210021707, 0.8050866661794791, 0.3472172711978101, 0.1487247179628255, 0.13930536254417458, 0.138039248018206, 0.14848180043291437, 0.14454942522738168, 0.13240133131440412, 0.138574601335536, 0.15257216307018828, 0.21900128753405723, 0.23043011054630302, 0.3478388921061105, 0.35645861505863874, 0.5275388797475296, 0.6409992685033798, 0.34369867255199793, 0.24079033722153365, 0.2468541633603072, 0.5528752823277796, 0.5842590904181697, 0.5923864417863335, 0.5379424727336002, 0.5589189582263006, 0.5596721879518853, 0.554236489773113, 0.5998754107195872, 0.6098371822555873, 0.3866788268732967, 0.500878969250989, 0.5123698969020443, 0.4817859889231829, 0.4871642231678567, 0.48310712176054604, 0.43377257123359336, 0.5202276331908446, 0.5055634404839766, 0.2218152138791103, 0.23317229257887184, 0.2186549087399009, 0.22592424459858662, 0.21197325010267298, 0.19876740833383022, 0.2283445656330091, 0.2204940636765479, 0.19769170862179775, 0.21835211105465346, 0.234063635290491, 0.24004588848651698, 0.20590478305334992, 0.2164742457908697, 0.21561360655394057, 0.20934570016757093, 0.2164172830936517, 0.21474822799547655, 0.8921883533157744, 0.1855978477647957, 0.8967522459442898, 0.8835343228646068, 0.19896737087584893, 0.17710954052400507, 0.8225962248245959, 0.16166246179024002, 0.1573417817880911, 0.8905804785325192, 0.2116765487735367, 0.2096415944619705, 0.20767137992368856, 0.1669438336726693, 0.1644934594401699, 0.21129377364515145, 0.21222981195170443, 0.1550833561157955, 0.17959223640116528, 0.1737324925030902, 0.18837481113976473, 0.19034754528833586, 0.176638293870354, 0.19057954705344382, 0.17893042850779128, 0.18956035289712658, 0.1852826730616367, 0.09348754113367308, 0.117478178764987, 0.09386470227331556, 0.08800357578961104, 0.09623795132383839, 0.08710971612806284, 0.09359251541524483, 0.0867652945493208, 0.09557904810735363]}, "mutation_prompt": null}
{"id": "1d7e2f7e-0d8b-4614-b80d-3209887e8a71", "solution": "import numpy as np\n\nclass HybridAdaptiveParticleEvolution:\n    def __init__(self, budget, dim, pop_size=60, F_base=0.7, CR_base=0.85, inertia_weight=0.75):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n        \n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget) * np.random.rand())\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base * (1 + 0.5 * np.random.randn()) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridAdaptiveParticleEvolution", "description": "Hybrid Adaptive Particle Evolution optimizes exploration-exploitation balance with stochastic inertia and dynamic mutation strategies.", "configspace": "", "generation": 69, "fitness": 0.43809830356801777, "feedback": "The algorithm HybridAdaptiveParticleEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8255852189587379, 0.8232914808343728, 0.8188192562469379, 0.8311914901654884, 0.8375739959441572, 0.828689332177774, 0.8336823407582118, 0.8210361022540733, 0.8233078675025215, 0.6403860492687228, 0.6388829410510846, 0.6373253432865558, 0.6361029212292972, 0.6532531446373226, 0.6281424958223651, 0.6301005975045011, 0.6456778615552263, 0.650817937704324, 0.13346482496718237, 0.12943785513885453, 0.1689659968698386, 0.16685661399464058, 0.14359286939270366, 0.14756967484861394, 0.12484004161539519, 0.14799594930364257, 0.1249621651527757, 0.12936293397658083, 0.14573653231528894, 0.10790830682074137, 0.13190373603177208, 0.1385027443748177, 0.12619539343163177, 0.11731566484091471, 0.0988034052580975, 0.10839158338943056, 0.9672158406528899, 0.9846408232609433, 0.97905920572681, 0.9582989076847386, 0.978170016794559, 0.9801488932729343, 0.9759535080087377, 0.9807813782654299, 0.9788815104817419, 0.6529502849854564, 0.666522662875191, 0.6041133664004805, 0.6535299090129534, 0.6551767070724879, 0.6639512445371464, 0.6627995331796024, 0.6415469672332353, 0.6515653292057536, 0.8365849012154933, 0.8433206987692053, 0.7853324421584515, 0.270067091537768, 0.8470973952681957, 0.8159493977884041, 0.8119710216313935, 0.8348998542450488, 0.8506841630484174, 0.527457430385418, 0.12311465393952636, 0.12243868142895975, 0.5874686337973112, 0.49034615415642624, 0.5759353638729041, 0.12840059265110826, 0.5497395888625809, 0.5190938269944878, 0.5900047076996096, 0.6214569467837994, 0.5706693963315466, 0.5674292800219243, 0.6133444728939037, 0.5250069211669595, 0.5233375516392269, 0.5781320471288702, 0.6096716877219048, 0.49567698647696246, 0.3990275745085161, 0.5162820240283312, 0.04648207893163758, 0.02033865940914259, 0.19852097140361624, 0.5422121499397334, 0.49101780052615296, 0.5157591159589179, 0.5416434235393395, 0.5709982493429396, 0.507402601873492, 0.527047032550998, 0.5551554475751568, 0.5809683048861738, 0.5906514972986723, 0.5285017774100773, 0.5260200573823506, 0.0603782554034451, 0.3303982027318858, 0.23612832916869342, 0.38424224685595965, 0.33065532133146924, 0.4409901889547334, 0.14556678271194745, 0.08181710812740317, 0.08511119683122903, 0.3673104397399197, 0.4184795002917573, 0.3855243154151212, 0.44752996461674444, 0.4344662335208743, 0.45961665644722516, 0.39854307085680063, 0.39033625845071396, 0.2701432310274515, 0.7386873133486128, 0.7351031947310235, 0.752619994170627, 0.7560966388769286, 0.763819395037918, 0.7506759972452507, 0.7456762886735715, 0.7355402567492011, 0.7520544974469219, 0.1229265403460722, 0.1477038868644993, 0.12225203681468955, 0.11353740146855795, 0.09576608204727488, 0.12438906673616235, 0.12865457516559253, 0.1075156982236638, 0.6191426980959882, 0.17960861128704997, 0.5283025502527152, 0.21288629498066347, 0.25682078126355123, 0.6836722451661973, 0.4369371091878791, 0.21626588713969475, 0.560605050275675, 0.5492006762235695, 0.451990212875357, 0.5045505889276518, 0.573364367731524, 0.5293712055578981, 0.6016905451441419, 0.5344135531531804, 0.6335814202467751, 0.6119035389873236, 0.612558739373021, 0.3515052169140601, 0.36597389146656367, 0.41961066829396665, 0.3314824832472548, 0.26054768741731793, 0.3377213311457956, 0.4672336317786481, 0.4990799534382063, 0.4363802926493704, 0.2173267098533903, 0.211669626777359, 0.20889860514709202, 0.2270033882895789, 0.2139978732264618, 0.20919904013449764, 0.2123822051107891, 0.21889809654934578, 0.2103722430208782, 0.20127674453366573, 0.2440932071687446, 0.18888078227311822, 0.2165785049202008, 0.64145249969725, 0.18755916301403053, 0.20198108241604484, 0.6561803717329893, 0.20518410425294464, 0.8483350996536191, 0.18513393608688278, 0.18510254176723473, 0.8484707255403569, 0.1980927803303365, 0.1940707964856987, 0.8695755168755929, 0.16277773744019364, 0.17187167087569055, 0.8243727868499711, 0.20888250558043997, 0.20912258564261033, 0.8394151975738096, 0.16768531474160975, 0.15460704722060714, 0.20928470645198494, 0.10409874579807488, 0.8294683512335579, 0.19793937201187273, 0.17735844998655725, 0.18916878400249137, 0.1810999780387631, 0.1950414975709095, 0.1770628616526706, 0.18975279497163167, 0.17771569389962383, 0.1837071760905924, 0.10101429919866389, 0.08696676361473132, 0.09061237055934912, 0.09170938826026553, 0.09034267939817942, 0.09730534240016564, 0.11063471056045637, 0.09495756282417955, 0.0832447392763559]}, "mutation_prompt": null}
{"id": "32f1aa36-a4de-4fa9-bfb2-4824b204bb4b", "solution": "import numpy as np\n\nclass HybridParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.4 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.25 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridParticleSwarmDifferentialEvolution", "description": "Hybrid Particle Swarm and Differential Evolution with adaptive mutation rate and dynamic particle acceleration.", "configspace": "", "generation": 70, "fitness": 0.48531020561153704, "feedback": "The algorithm HybridParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.28.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8223004074749457, 0.8325957461995408, 0.8379559360423816, 0.8378394666768522, 0.8397925005238591, 0.8439924750411328, 0.847958468683708, 0.843857952890283, 0.8441405642081672, 0.648622225405603, 0.711153118716592, 0.7092437595999621, 0.6927879479683294, 0.7208461155975662, 0.6323558813286276, 0.7160201174660661, 0.7108436920402827, 0.7116574405090583, 0.10062863023887425, 0.6003945083621111, 0.1466017030827006, 0.16663647875083298, 0.14484567115977132, 0.14239647014922685, 0.14635912917918392, 0.134861649251378, 0.16415210291120197, 0.13470321935881124, 0.14154703070856212, 0.09463425301144834, 0.16593542713137832, 0.1332730174490554, 0.1040813277819771, 0.11055576369573406, 0.09761896050109697, 0.10375005657959113, 0.9803212623759818, 0.9711488445111838, 0.9644619964960989, 0.9828669039081753, 0.9769793273423328, 0.9777862564603003, 0.9877382422519275, 0.9831145705303435, 0.9789987047178528, 0.6896205171481817, 0.71343353970314, 0.6931009206578611, 0.7286383633899707, 0.7124440389971969, 0.7146866090840032, 0.7035494656564574, 0.6994082427418751, 0.7075760145277108, 0.8037053398905392, 0.848409074809676, 0.8369928258351287, 0.8518056436154453, 0.8737145087499691, 0.8389946827177057, 0.8460007453098876, 0.8425449044815904, 0.7175779766814077, 0.6192001539819398, 0.700948486673763, 0.5537805768695225, 0.12956671352686067, 0.6743461847375604, 0.6238381071648612, 0.6282583734811806, 0.6994260250413984, 0.6141145450998695, 0.592634343168328, 0.12519839989404702, 0.5830244590394815, 0.6266129730692895, 0.6763993789175178, 0.6059006457630896, 0.12302385648098246, 0.6682077242280886, 0.5688911139507948, 0.6322378679345056, 0.6236107425880165, 0.5603422300197151, 0.5854262931107515, 0.6258889240179754, 0.6265028694671863, 0.5367717816594284, 0.6231916153582427, 0.616786201858367, 0.7016082330592313, 0.6716419765494908, 0.6581990375385781, 0.6272740517166824, 0.687918972483738, 0.6355264890710564, 0.6729056742978814, 0.7045297937319168, 0.6540708882422521, 0.14574178616891276, 0.32230302503798125, 0.3101068552226097, 0.5544899138396244, 0.45390611696610683, 0.4635676573103811, 0.44185544267516375, 0.20096109055208067, 0.3492477926967267, 0.5673656062262503, 0.5431403110621615, 0.5607876410625585, 0.5447380635480822, 0.5572353428885612, 0.5509909363533841, 0.5514218959992709, 0.5057758908441616, 0.5280423652767434, 0.7858252541708562, 0.7987145500409462, 0.8054517112088148, 0.7926512619517145, 0.7883254469788178, 0.8039204635689363, 0.7908517518424454, 0.7893313447955499, 0.7922401728996938, 0.13992037354312592, 0.12689353732544983, 0.10725656592678812, 0.13477914627432708, 0.11545925558102477, 0.14979889674287894, 0.1311051679080174, 0.1464728997685878, 0.1306982105391411, 0.6784793658284904, 0.6504138452617424, 0.60438839424602, 0.2603406392130446, 0.28437819381448226, 0.2987708795364513, 0.22093478098100194, 0.6700888355152339, 0.27345767797873644, 0.5451121703963429, 0.5455243496494326, 0.5584916667832438, 0.4959421910796077, 0.5702612330961623, 0.6490516515522637, 0.7008053266154947, 0.6687460639862268, 0.6679175420018633, 0.5491085784543761, 0.5091448822177262, 0.24242246524975097, 0.4347191451284188, 0.5013241477719479, 0.49174917523652206, 0.6100441241223141, 0.501261391231347, 0.5641530994947805, 0.20937226803855402, 0.22631254296484027, 0.23725870698920215, 0.22858803370505631, 0.2083204342998939, 0.22367445792041918, 0.19753865451406394, 0.21883140849731086, 0.22476804196925193, 0.21102756621929353, 0.2143188349289714, 0.21839372116946731, 0.6863456814365648, 0.24005352743488262, 0.2411135550081661, 0.19405785141617282, 0.22221829465548393, 0.6549514441662754, 0.18667965190155977, 0.16839484010934735, 0.1540934718386705, 0.880839505978777, 0.19965115540000966, 0.1977781649774546, 0.19562997941178195, 0.16506689940633534, 0.8808760305374597, 0.8655595492634819, 0.21133238848141112, 0.2058152049986378, 0.20463066455229495, 0.8507575895137223, 0.153967496307022, 0.21110440681940246, 0.859034283265418, 0.15411747083197935, 0.1953053223960236, 0.18611251894314262, 0.18090966925174679, 0.18448074978757767, 0.18445092548405007, 0.1782994844005883, 0.17767278761335548, 0.17399106386998597, 0.18205241445445408, 0.09129287641683836, 0.08841719612567889, 0.08631385513139744, 0.08922653684614579, 0.09328078577301802, 0.09797914444889777, 0.10776605857721966, 0.09147568981590615, 0.08673355052499643]}, "mutation_prompt": null}
{"id": "ccb390e6-6853-44c3-91c6-c3022f9ce8a3", "solution": "import numpy as np\n\nclass HybridPSODEStochasticBalance:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * np.random.uniform(0.8, 1.2) * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * np.random.normal(x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.15, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridPSODEStochasticBalance", "description": "Hybrid Particle Swarm and Differential Evolution with stochastic component balancing for diverse exploration and adaptive exploitation.", "configspace": "", "generation": 71, "fitness": 0.20175603500699704, "feedback": "The algorithm HybridPSODEStochasticBalance got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.3700293734492983, 0.36230767510138984, 0.35517727284509715, 0.33953125372353365, 0.3613526519297877, 0.3701003511249018, 0.35888695390210146, 0.34001278751808217, 0.34081522156579735, 0.03556729662040803, 0.02803630200992724, 0.03757902538339819, 0.019565737110203152, 0.02093412452244925, 0.0070002275765751465, 0.027551258510471244, 0.03747206433621064, 0.021921993628085334, 0.10711585600505369, 0.09935705388244465, 0.08857354168922338, 0.10123904678073892, 0.09599641308095563, 0.11007082551985636, 0.10088162988842941, 0.09436595488162258, 0.0950647303074369, 0.11131960772349025, 0.09761171541801394, 0.08982519301608971, 0.0840842037457058, 0.08329765831710023, 0.10556502136430079, 0.08195213405441648, 0.08130056339757119, 0.09041350906716783, 0.9700990943920674, 0.9892869782261158, 0.9796500421440162, 0.9737571548879929, 0.9651192216288458, 0.983034154510492, 0.9804214523210528, 0.9689551043613371, 0.9830297963347665, 0.20776860044068712, 0.1937759418394257, 0.21562059019015145, 0.31283451313363664, 0.21644620027175787, 0.21212345593194182, 0.20542438499788285, 0.19600553028177548, 0.20516870947387433, 0.27310508566738956, 0.28115501810679167, 0.31833087775676716, 0.2834474126414205, 0.2784768366903557, 0.2785684960032305, 0.2520747715159539, 0.2798580527163149, 0.23253906839999416, 0.13810095246036547, 0.12665247450924566, 0.16101966160621572, 0.12106202632423302, 0.1301452136230491, 0.11928005181914869, 0.12917225887520767, 0.12482085350709493, 0.1162430366918541, 0.10794715075115147, 0.07326416855439888, 0.12932172796945962, 0.14239242317214762, 0.12468925850960699, 0.12735265705097587, 0.1645653420438824, 0.15349506763204812, 0.14014929437387413, 0.02084500482201168, 9.999999999998899e-05, 0.011772564810714536, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03579347236670727, 9.999999999998899e-05, 0.009265753050736403, 0.1022974940727237, 0.09705306035810168, 0.132693505363354, 0.13042827889900332, 0.04412025461617941, 0.05509184863231387, 0.08862246486861936, 0.09349057706169728, 0.06129470520577984, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.049262271794859425, 0.07281647733435348, 0.0423309257360428, 0.06111722511655515, 0.08269221406635274, 0.0753256461102243, 0.08593999169505984, 0.07624246503245236, 0.06793263405765537, 0.3257519013270266, 0.3348994241649609, 0.33983285806189234, 0.3403747638487592, 0.3389753782106273, 0.33883197555161493, 0.33867087164427634, 0.3354882995211942, 0.33769433120040937, 0.0916166990498839, 0.09485708633638024, 0.09087095599973727, 0.08081157051830301, 0.10073945363753412, 0.09814715809550922, 0.10329837467684133, 0.08716792272673357, 0.10601584399481345, 0.1982146583537583, 0.15494006858477638, 0.1680089882018192, 0.18339301797137542, 0.17340146218096708, 0.1378962282132179, 0.18104798194503058, 0.16005106975918093, 0.19002545291410955, 0.2558947396702954, 0.2509862523349873, 0.2611310454351863, 0.24743952101890865, 0.2702996023413007, 0.24336199029876593, 0.2817797143678382, 0.2526490315543065, 0.251307457882747, 0.20150924450744245, 0.18735252411275694, 0.19062437050863523, 0.20533328147462016, 0.19850487911684234, 0.1807584077455442, 0.18431255227918297, 0.2121783326392408, 0.1972675033901552, 0.2086728697867879, 0.20482807161994654, 0.18959496795245512, 0.21251721524134304, 0.20767462911886203, 0.2196063732124448, 0.20174714125609694, 0.21777988601734521, 0.2025062070655611, 0.19854369713821707, 0.19400595852897162, 0.17975239948442046, 0.17524446363430257, 0.1755739387013464, 0.18364818242986625, 0.17853695383863433, 0.18222019345155438, 0.1765769843996603, 0.4902203030796539, 0.491811274605812, 0.1715502929595637, 0.20246565184024334, 0.19683100939456366, 0.5034777546867805, 0.4613133163607369, 0.4713184395021145, 0.45740379248142593, 0.4581874674508932, 0.20443597905300936, 0.16745227129078433, 0.19998836091488215, 0.16133300157852204, 0.4159205274473, 0.2050406880751694, 0.3436551809011289, 0.32316112052238166, 0.17998733719281845, 0.19108374287019547, 0.17964178659120422, 0.18815124231900138, 0.18240702860790692, 0.1789672342861699, 0.18443878020610305, 0.18521569543070604, 0.19019247796172112, 0.08214694149390289, 0.09541016737625907, 0.08921095188132533, 0.09220698040272712, 0.0771621142028005, 0.08514884399366696, 0.08270949324671106, 0.0787814146393554, 0.08267528800768598]}, "mutation_prompt": null}
{"id": "c2193e2f-bb52-4870-96d4-9098aff0959b", "solution": "import numpy as np\n\nclass AdaptiveDualStrategyParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5)\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n                \n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.25 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveDualStrategyParticleSwarmDifferentialEvolution", "description": "Adaptive Dual-Strategy Particle Swarm with Differential Evolution uses dynamic mutation and crossover alongside stochastic local search for robust optimization.", "configspace": "", "generation": 72, "fitness": 0.43499567751280593, "feedback": "The algorithm AdaptiveDualStrategyParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.7960775933898276, 0.7888019534439463, 0.7901372987968216, 0.8119924499182201, 0.7912675488920144, 0.815695129869692, 0.8099019537874137, 0.8042380944257581, 0.8204474374419929, 0.5827997235003651, 0.6182435669973189, 0.5948504070132034, 0.5696851428621617, 0.6342611452570096, 0.6287850393354237, 0.6462320473252859, 0.604913747204749, 0.601338161849364, 0.15622684171234213, 0.1491700542748038, 0.12165421269786603, 0.15646075772458967, 0.15712002841799644, 0.15650153486177953, 0.12424587621167227, 0.4230579112156664, 0.11551582965501606, 0.10802555518074985, 0.10306020516168812, 0.12128271704178772, 0.14363420441638175, 0.12105932428678168, 0.10100435039000422, 0.09862909809199993, 0.13879818346069484, 0.126104056275414, 0.9833840785130116, 0.9765159967498411, 0.9784576634004746, 0.9826372225539051, 0.9787443003801382, 0.9801432631893774, 0.9863453759892021, 0.9799633118545573, 0.9786165716489585, 0.614852443968368, 0.6098805759762969, 0.5879081930984904, 0.5983349243456377, 0.5926869127473152, 0.6014029408352695, 0.6163887621884654, 0.6372216872990477, 0.6190288201670717, 0.8475133593002393, 0.8008998512647199, 0.7936701750413679, 0.8415417698729588, 0.20748445614741118, 0.8378474306160562, 0.7907605056869134, 0.8379967347997188, 0.8449409461606957, 0.5998861095920653, 0.13047401658472768, 0.5255718211422398, 0.5544314833136504, 0.5829273337537768, 0.5567678895893042, 0.5363248128014451, 0.6157798908997405, 0.6218193481308354, 0.5316276008061864, 0.5835895579322775, 0.1279024853304378, 0.5101680147213283, 0.6083745672360037, 0.5173489470309311, 0.5658215124039288, 0.5076847809753696, 0.597265024994067, 0.46816444139286617, 0.4138502701684672, 0.4771389657952423, 0.5017809484107214, 0.5066983544352919, 0.5482967363721177, 0.5201003220083874, 0.3809066004885342, 0.5000387318254653, 0.54504250729481, 0.49502666507463144, 0.578791207095489, 0.5524931563688729, 0.6030203220105794, 0.5157543646304679, 0.5244802109622223, 0.562213457491094, 0.525607658535758, 0.11707025864556486, 0.21259833630193936, 0.293108363736014, 0.3042540019293959, 0.4039798943613505, 0.342806638126809, 0.2592084202938617, 0.11249952566660415, 0.1021618557503794, 0.359046722895931, 0.3927188299197478, 0.40101672739656247, 0.4122475779959037, 0.40175930842790664, 0.41408639764780697, 0.40458640629622544, 0.3970395111679623, 0.22548612939409618, 0.7346431401329676, 0.714916448853072, 0.7380324793398376, 0.7483972428665179, 0.7551493925734036, 0.7577697727067204, 0.730770638170742, 0.7437161431373323, 0.758339868264488, 0.13160286485054162, 0.12481481957470753, 0.14648478211084115, 0.15778974377908295, 0.15472044128790674, 0.1243350651371169, 0.1374095894070415, 0.12995485246776262, 0.15745982206820752, 0.292669114993825, 0.28874600708786824, 0.5311592124330922, 0.16073411772748025, 0.1467722634164258, 0.2947421484962397, 0.22803877547804063, 0.2555416159041588, 0.2437100651175319, 0.5131546494946213, 0.493839246113865, 0.48570854601997093, 0.5563796870467888, 0.5046738343850248, 0.486509806419007, 0.5129893295720026, 0.49551453055536077, 0.5218910985296646, 0.24371260740916145, 0.40343663198105006, 0.44095362513367775, 0.3889274445937261, 0.41618124516309096, 0.43515127637649953, 0.40682233825249736, 0.44723819060603476, 0.2703625843932046, 0.2219033029201275, 0.1946721915825741, 0.19767356539700753, 0.23894171923508822, 0.2307391040397977, 0.21855874459240288, 0.22319951441253594, 0.1943906442793697, 0.21449447281074996, 0.21303716343330847, 0.23414718559415892, 0.23377831204071364, 0.19800521030576412, 0.23843495422169614, 0.23320259013722078, 0.20181823434927038, 0.5455213714794116, 0.20541251535815763, 0.20588194647039004, 0.7760220256467527, 0.15336922881061454, 0.86762904588049, 0.19718209113838336, 0.16646715119852196, 0.8147560591179617, 0.19323746323637347, 0.17262784346041737, 0.8454753968041913, 0.7977783907092432, 0.20856726859366337, 0.8470233344901033, 0.20424399554757977, 0.15367488152322695, 0.21133346640773887, 0.7526957353909289, 0.7641890826226314, 0.18641759236208344, 0.2002597064203675, 0.18312894638104948, 0.17100951538489495, 0.1781273759365356, 0.1984426952718059, 0.1874476738450619, 0.19994032663651629, 0.19038011481126915, 0.08275510494260363, 0.09713758644513304, 0.08354933766428008, 0.09919619790739675, 0.10025230891681203, 0.077350984513475, 0.09098024207661926, 0.07659108929582858, 0.08891476155087963]}, "mutation_prompt": null}
{"id": "b6ed30b6-b54e-45fb-a7e8-a6b9c05e56b1", "solution": "import numpy as np\n\nclass AdaptiveHybridParticleSwarmOptimization:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()  # Reduced to two random numbers\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i])) \n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.5)  # Adjusted dynamic factor\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.5)  # Adjusted crossover rate\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 3) == 0:  # Adjusted local search frequency\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.15, self.dim) + 0.1 * velocities[local_search_idx]  # Adjusted perturbation\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveHybridParticleSwarmOptimization", "description": "Adaptive Hybrid Particle Swarm Optimization with Local Search for improved exploration and exploitation.", "configspace": "", "generation": 73, "fitness": 0.4784847604133201, "feedback": "The algorithm AdaptiveHybridParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8338262355031651, 0.8346024901335728, 0.8536188206533366, 0.8538191966887857, 0.8463436698294202, 0.8457523782682693, 0.8513729168454822, 0.8379921910466901, 0.8305844379881395, 0.7072718074877327, 0.7069792889393296, 0.7045915788238506, 0.6896175630551309, 0.6960306185862674, 0.6674586335623386, 0.691708754284655, 0.7069115976921667, 0.6995417342503153, 0.15162982362398814, 0.14130611472083998, 0.6849536541200769, 0.15097940850266856, 0.15116831499141592, 0.1106437759151051, 0.14914530010199745, 0.16207585319129902, 0.15077471187603442, 0.13567198824606008, 0.1250990559956464, 0.13372497226655955, 0.12033889997122027, 0.1045554180325966, 0.09712218854636834, 0.11528393617339339, 0.1267532336228171, 0.14528961143740304, 0.9690773499117993, 0.9764645249520304, 0.981438299927139, 0.9750919549836905, 0.9854950524492034, 0.9775968771759322, 0.9779720981558591, 0.973333380609794, 0.9809636812180963, 0.7065862748067737, 0.7157064373427895, 0.6972893143635412, 0.7162613206541957, 0.7153253336675824, 0.6825136198998571, 0.6958872079380496, 0.6914777608965981, 0.702916943518, 0.849761085422415, 0.8602701837659318, 0.8570170059566847, 0.8680922230386429, 0.8289695226335887, 0.21020633792770227, 0.8174341661894686, 0.8644260186642627, 0.8539409612271963, 0.6379387628061198, 0.6293068193586578, 0.6741623009986965, 0.6206451148810582, 0.5911499511035306, 0.12865288909206174, 0.5993573734993133, 0.12659836719628204, 0.6475678414884201, 0.6213112036805746, 0.6018478368994815, 0.6380903161464153, 0.6765841276447031, 0.6871713602366007, 0.630207878465982, 0.671965829558504, 0.1300308815580249, 0.5416310411818723, 0.26570764126742363, 0.6325838112471397, 0.551567090820567, 0.04667197933477596, 0.49838447578303013, 0.6201597897942067, 0.6623106283918168, 0.6150271605887805, 0.6125992321298734, 0.684387582746716, 0.6830813419984242, 0.6733844842358627, 0.6657948008322452, 0.6692701638523995, 0.6882658767841059, 0.6843779065805263, 0.7080517418700456, 0.6952711829349765, 0.1338430968747092, 0.10612664516667614, 0.23623402227352053, 0.36207187633892335, 0.3601610061518209, 0.3166858331426342, 0.40269344810161123, 0.17940380252439625, 0.11534023926778258, 0.563250967782618, 0.5668194387566188, 0.5540052201139221, 0.5570748618038829, 0.5414054614500224, 0.5525871635827335, 0.5424850081095478, 0.5193500495323062, 0.5481104612523943, 0.7759188802970981, 0.7903598072358576, 0.8043413386203997, 0.7849647506566972, 0.7793854870784745, 0.808535649525321, 0.7925106997503272, 0.8015714951899896, 0.8024871313882842, 0.1256139825566257, 0.13542864113016273, 0.145900103933719, 0.17241521437848328, 0.156223104535416, 0.13943515551045094, 0.13187576746728424, 0.11637793098829785, 0.09896283139564588, 0.6789176217518109, 0.2744995472432291, 0.4020867651795661, 0.5377413660201675, 0.41426666073624585, 0.2162898579330721, 0.23323188407476447, 0.6104598990283384, 0.18477589295521635, 0.6508369159973413, 0.49709861931113564, 0.5389734632254308, 0.6375292329230642, 0.6351669224641474, 0.5404357132471632, 0.5783989945920058, 0.5551803058847038, 0.6737615095860081, 0.4870098359655334, 0.5271607833354588, 0.35156370379029245, 0.5629737943289204, 0.5631098403088325, 0.495943083097263, 0.5017881419096195, 0.5843831302997984, 0.5123355583832483, 0.2059927405679295, 0.2030389432673354, 0.21281430160989434, 0.20938141903343999, 0.22100016202880202, 0.22677319899259984, 0.2149804741627026, 0.23122632147364197, 0.2251849098900378, 0.23464712873156812, 0.20269299024441167, 0.19596479137913414, 0.21966256284315555, 0.23934314990124084, 0.20691961715157337, 0.20210360216232426, 0.21791952507234702, 0.19722142856330538, 0.15241361895093064, 0.18408394193589706, 0.1541179777890842, 0.9004003854487351, 0.19892307344002058, 0.8525811661092536, 0.14106268722291238, 0.8610904346831736, 0.1650919908896944, 0.8630745742334275, 0.16877121666923778, 0.8453943866648385, 0.8267907489911137, 0.20815139429104101, 0.8513390615876643, 0.21205887663592593, 0.21153542569786798, 0.7932319032860653, 0.18338519742482629, 0.19607123767007772, 0.1872215223771695, 0.17096400444047632, 0.17594918359551104, 0.17633697978551932, 0.17952899828981828, 0.1852767095559189, 0.20507309257685868, 0.08209780408594447, 0.09203807985934431, 0.09531467797064141, 0.09191379178272674, 0.09519927629441083, 0.08586795876213071, 0.09096871987158028, 0.09194450901314577, 0.08752885762151164]}, "mutation_prompt": null}
{"id": "d16cdbb2-ded4-4142-b6b0-3a82bddbf5d8", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=60, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5)\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedAdaptiveParticleSwarmDifferentialEvolution", "description": "Fusion of Differential Evolution, Particle Swarm, and Adaptive Strategies with Local Search Intensification for Global Optimization.", "configspace": "", "generation": 74, "fitness": 0.4636222216646961, "feedback": "The algorithm EnhancedAdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.807940708429918, 0.8011524357007844, 0.8106190993130763, 0.8152455660010399, 0.8242634363460491, 0.8264876174811838, 0.8079352983885872, 0.8078452894081201, 0.8095387534088316, 0.6722327441635565, 0.6672502102214339, 0.6781898720467027, 0.6636920666731319, 0.6636914635499931, 0.6748806927613091, 0.6487093904658857, 0.6556509583378105, 0.6640106837286833, 0.13520878185723317, 0.1551205163431767, 0.16182393405889584, 0.10856885022260754, 0.14714520963238698, 0.1648278197804739, 0.14474899563132226, 0.16734927223485752, 0.13071078881229026, 0.10175302078018245, 0.10561719572676831, 0.11802481768302164, 0.13057492647486124, 0.11562159201878675, 0.11057535406684404, 0.13552468600506273, 0.08830419663404987, 0.11852006727447328, 0.9686482461763222, 0.9673396549275174, 0.9723350932394145, 0.9761715124771898, 0.9658191380257706, 0.9853657648555387, 0.9724452022871596, 0.9798265061710042, 0.9731600601168231, 0.6569877026876006, 0.6659345123073163, 0.6420987691903648, 0.6420507783599179, 0.6720897755260455, 0.6835784319012623, 0.6692285997733307, 0.6609350123817632, 0.6842265194038977, 0.8194116907832414, 0.3785959414902763, 0.8124118453360151, 0.8244063808423002, 0.8274846024571325, 0.8310477914990289, 0.8077550245217897, 0.8208143967474696, 0.8152720590230537, 0.6368451736681267, 0.568105672032051, 0.5745618941374564, 0.5526963486231882, 0.6321846696558397, 0.5144641978309081, 0.6118849606515151, 0.6284236178905716, 0.6214026792954042, 0.4717915887642703, 0.6532844556696005, 0.5836068729965207, 0.5415256005583304, 0.6643115524766425, 0.5391975601161783, 0.5823969372639619, 0.5196970474002318, 0.549908495188849, 0.6177372117691229, 0.5701691570484778, 0.5472392207873458, 0.5213900049244358, 0.5396207435787443, 0.5564042745201125, 0.5766308077010249, 0.4753857586024618, 0.5877190909709546, 0.6197713416177312, 0.6308587847468221, 0.6433622185421228, 0.5889508711434512, 0.5785198904831942, 0.6357823217396417, 0.6093404686536179, 0.6524279305421414, 0.6397656410343875, 0.35710561221748927, 0.1110141133907413, 0.34267658318258165, 0.45789629825814737, 0.5194135351749389, 0.1374517601182237, 0.3165056061105215, 0.10851115902856512, 0.10413697148370304, 0.49879234704495057, 0.48636313276674026, 0.48237705505421413, 0.48455334318553367, 0.4887463210199886, 0.49230835540654483, 0.4560693108973576, 0.48980379922029804, 0.454734369287221, 0.7530581439780493, 0.7508542907093831, 0.7508537536197151, 0.7705638881314476, 0.7683007402193842, 0.7620157529632263, 0.7487791658028973, 0.7506706735687176, 0.7576314289049322, 0.11043779577173118, 0.12997282239363572, 0.49515682762737423, 0.13855594166040464, 0.13288213320381004, 0.13295075418225932, 0.13371842277980572, 0.11201287673432558, 0.13761184350556255, 0.2580582754677071, 0.20929212443090506, 0.21315234241949876, 0.15679968803860278, 0.23948545045781455, 0.6066889597924077, 0.6470477391321425, 0.4931629571504905, 0.25754441412999163, 0.5216303905572336, 0.5816917396332313, 0.6070630992380737, 0.6254957910834075, 0.6137567371155026, 0.5818513497791888, 0.6080073875149523, 0.6316804131336126, 0.6290109716972556, 0.3205177285325447, 0.2321191866462553, 0.46953761017434026, 0.429979420451054, 0.4878197156779034, 0.5171813141859205, 0.5372723790456785, 0.5417037726602206, 0.5428175290196797, 0.20710595264679144, 0.19826241105521714, 0.2286675588034932, 0.21056248370795239, 0.23678060748714835, 0.22019027540343172, 0.19754565549154002, 0.2030734881097087, 0.19254486773817747, 0.23460403351814196, 0.18902765343046757, 0.17754436536118523, 0.2185956661244387, 0.20734194124200123, 0.21476618735240016, 0.23801986766592909, 0.21063125851231157, 0.2161251210190659, 0.16315288132571348, 0.8619432163523542, 0.18435342377301234, 0.19729291616279643, 0.19847558147798372, 0.17197611434015125, 0.17738263802750787, 0.16014521734118348, 0.16942805621719814, 0.8131506369163906, 0.20919740212779092, 0.8093281291911969, 0.7887952405703963, 0.8209333362092897, 0.16298342527025467, 0.21148679098429557, 0.8455348248049463, 0.8159050496424378, 0.18293677808076403, 0.18029727085632274, 0.19824909418832792, 0.1769239035723723, 0.1730987768934361, 0.2022700709840981, 0.1807721166521058, 0.1899204340673869, 0.21869235921104346, 0.11291400260173667, 0.09116710163116348, 0.08298072578455795, 0.0804505258667838, 0.09207935940484457, 0.07371400202282052, 0.08650848517907017, 0.08935495267406457, 0.13019784193175143]}, "mutation_prompt": null}
{"id": "d4d1ea6a-9c34-4db0-a928-213334e6f102", "solution": "import numpy as np\n\nclass HybridParticleSwarmOptimization:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.8, inertia_weight=0.6):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * np.random.rand() * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * np.random.rand()\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridParticleSwarmOptimization", "description": "Hybrid Particle Swarm Optimization with Adaptive Mutation and Local Search for Improved Convergence.", "configspace": "", "generation": 75, "fitness": 0.4747684650605153, "feedback": "The algorithm HybridParticleSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8261427884411392, 0.8206929782639398, 0.82674640840303, 0.8197904899453231, 0.8348912907331226, 0.8308911130495692, 0.8290243476444076, 0.8283493236370039, 0.8367903216143895, 0.6722901026357245, 0.6117094095690383, 0.6658993864975621, 0.6703399658199423, 0.6765317103007535, 0.6167088303066577, 0.6685455525178416, 0.6529687510906672, 0.6791205210301972, 0.13923944215124373, 0.14292385858663925, 0.11945551540199262, 0.11673148064440342, 0.10761227198583123, 0.14235340384698725, 0.15058096652267927, 0.10524093733227147, 0.16139146412272454, 0.14056139260414235, 0.09719560534403315, 0.09907468428970645, 0.12493699231338395, 0.12415086789806828, 0.15555606583333537, 0.08937212815794815, 0.1230118771529416, 0.11346100363797418, 0.9821571069344042, 0.9725295321489872, 0.9693856965448582, 0.9635848301269782, 0.9702145187875771, 0.96328857079627, 0.9828660317104155, 0.9736236497057504, 0.9763187758009203, 0.6352430161045416, 0.6250468281663362, 0.646811875768219, 0.6477213795341187, 0.6527197340236219, 0.6592895189400745, 0.6551040258734377, 0.6662391931440044, 0.647336276550823, 0.8474257021061319, 0.848487065249471, 0.8501682970708057, 0.8285668472649838, 0.8353360976961701, 0.8430448757896924, 0.8444821892580803, 0.8469023569923801, 0.8544928326278408, 0.6074347464710436, 0.6241283078659743, 0.5937810832063095, 0.6333839270293251, 0.6320039779154257, 0.1261648218966318, 0.6106864102133082, 0.6511974118593633, 0.6047640132869665, 0.547782121270048, 0.6509345242598302, 0.6892076805219033, 0.6139499639649667, 0.4849520977226024, 0.542084359346692, 0.5717144992456348, 0.12025170930271911, 0.6018368196822519, 0.5734622070913297, 0.5402526459756893, 0.5974561214218591, 0.6245608017752953, 0.5874703560587687, 0.5717988318686744, 0.5836477230618273, 0.5786786090839408, 0.6240291321236133, 0.6670512176946153, 0.6841857850461146, 0.5567496044733911, 0.6747319715911024, 0.6014139067875068, 0.6477140620874305, 0.6247718548076693, 0.6522335871653462, 0.6758346975677386, 0.11868168164789372, 0.41747226934986736, 0.2792962411753507, 0.3220502425038678, 0.5331823945313088, 0.3799110582010202, 0.1382826160738514, 0.1790341595121181, 0.21490778736977822, 0.4670900699271441, 0.4676358334103655, 0.5119827883167667, 0.5018579999415007, 0.48449262025625417, 0.47375633179272336, 0.4941284778693714, 0.4991697144374835, 0.4704188741059132, 0.7589481055800509, 0.763570337039481, 0.7780574443635508, 0.7709660653019039, 0.7588838902046583, 0.7867250689881601, 0.7963815955749989, 0.769223147377592, 0.7652132963122702, 0.1328960113242914, 0.11854992455897195, 0.13477181009209793, 0.14417533911544156, 0.12614139371694488, 0.12375647749430518, 0.13822977014952798, 0.15592447179651192, 0.17500563531202684, 0.43762527870162526, 0.5412348846067756, 0.6217165073934261, 0.15195794279030983, 0.2649616696792457, 0.3550708516420382, 0.5345559527969583, 0.28819741066482707, 0.2141460292386711, 0.5992037967540986, 0.5532618445492659, 0.580220194293775, 0.5691501789712197, 0.55809555318367, 0.5526618877451531, 0.5853363213355466, 0.5836839531501207, 0.5841072881204996, 0.48512792317131237, 0.46535680566967974, 0.49348482211868894, 0.48436300384943876, 0.4919156258981585, 0.47449891858472926, 0.49290715123123585, 0.49912646934348415, 0.49580924918855585, 0.21435700145695702, 0.22754267832141095, 0.20339932131844507, 0.2124834271363807, 0.20637464094555724, 0.21138830263940744, 0.25150906971951625, 0.19590240710593698, 0.21627379870537178, 0.24106125375302945, 0.18872828226132554, 0.21204835889730178, 0.6548525439759675, 0.6592440742913483, 0.645430151401337, 0.20204127172528674, 0.24028515476166323, 0.21991606649468953, 0.18570255151906023, 0.873768068650402, 0.2105022306287081, 0.8641583900279006, 0.19775478740386032, 0.17679062313940197, 0.17690032893676455, 0.833321400908936, 0.8059426171216213, 0.8613294541028783, 0.16937183159156943, 0.12628127093402342, 0.2075169495119602, 0.16699348749201248, 0.20883288013983226, 0.8308601282461184, 0.8358253186766396, 0.21137904797251839, 0.18856126506601256, 0.17757676176272852, 0.20404569834176023, 0.18181795001106216, 0.1846923806745745, 0.18426597870906103, 0.1924212245974133, 0.18603989338389615, 0.1861740677959749, 0.0815773419430681, 0.11403946914947849, 0.0943029181831655, 0.08519119063849134, 0.0840225290292268, 0.0979496685171991, 0.09116058422641382, 0.09383718832624877, 0.08672304661609997]}, "mutation_prompt": null}
{"id": "ee3db7bb-372f-4e9b-9ddd-683dece3f5ab", "solution": "import numpy as np\n\nclass AdaptiveHybridParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5)\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 4) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.05, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveHybridParticleSwarmDifferentialEvolution", "description": "Adaptive Hybrid Particle Swarm Differential Evolution with Local Search utilizes dynamic parameters and local search enhancements for robust optimization.", "configspace": "", "generation": 76, "fitness": 0.4752955391297315, "feedback": "The algorithm AdaptiveHybridParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8341228536400663, 0.8283077627646538, 0.835146982225177, 0.8472873860167338, 0.8418099185074894, 0.8440156102734993, 0.8496283833466542, 0.8428946679201033, 0.8352786872779734, 0.7072562995876963, 0.6847042857589203, 0.609621856961345, 0.6812332437104995, 0.6950463404738807, 0.6955247886078438, 0.692182601971997, 0.7103841723880917, 0.7082503683440491, 0.15061285639818411, 0.14622820465832032, 0.17749208101639802, 0.14576141624371142, 0.11924624623767599, 0.1251035869373205, 0.1203255094999176, 0.15019917844006814, 0.15731008956568093, 0.10990606411824333, 0.10529322605479285, 0.09226082723415563, 0.10493705877726711, 0.1324331962537384, 0.10472153037433107, 0.11065388325596814, 0.09428544675412487, 0.11962900445100477, 0.9821600391862516, 0.9825040218978333, 0.9859836779818306, 0.9841104484335343, 0.9783652541315316, 0.9821873375586959, 0.9852759560594412, 0.972976604143622, 0.9858238619046581, 0.6819479297788362, 0.7157192318176132, 0.6948766820183043, 0.7064530942692502, 0.7082871766560019, 0.7042063828681835, 0.7069581863048173, 0.7008682359318036, 0.6982374288511581, 0.8588260820131313, 0.8480175082517583, 0.856309277632797, 0.19217144478870818, 0.2742376831409802, 0.8523430761299173, 0.8476604307781404, 0.8716550963326772, 0.17533086810719256, 0.7286913850535084, 0.6277284011541293, 0.5945429482165001, 0.5811664205189435, 0.6197608898250069, 0.592729071217342, 0.5817898674647458, 0.5816340026390099, 0.6386518983655936, 0.5703647733920654, 0.6667461121177647, 0.6963907975483943, 0.5921755743996018, 0.587145228038966, 0.631304258311296, 0.5970148212467913, 0.6712341112054301, 0.5829526350018922, 0.603060307904459, 0.5911544805245135, 0.6086432947894271, 0.5392961786952927, 0.598137230051782, 0.5816508029775684, 0.6544134451874598, 0.6078144486080133, 0.6222999602908785, 0.6947384899197253, 0.6530628707419472, 0.67073316372824, 0.7110680654026269, 0.6932041243112809, 0.6572918439438941, 0.6872540535742091, 0.6868320619059884, 0.6926934187698532, 0.152795981223795, 0.4064497534857996, 0.22313258866562669, 0.32695185922453984, 0.2982522914325012, 0.46278851513215236, 0.11825812397122715, 0.36845418141675335, 0.16336344199218766, 0.5384799695055191, 0.5449047555417665, 0.5366745094578843, 0.5540193024536018, 0.539225573007541, 0.5764291768167036, 0.5429888693332628, 0.5388146101458893, 0.5368611229811784, 0.7962963584095845, 0.7978605208522938, 0.804420626041912, 0.790267931291356, 0.7846762966378482, 0.7902487138933351, 0.8015874732069931, 0.7826114139781508, 0.7825660503460519, 0.1103971921120086, 0.17508286812836305, 0.09775303150391923, 0.14867176375801971, 0.12950202326645122, 0.13707442257580604, 0.14016145026220161, 0.10395520556770221, 0.16183322604815586, 0.4748067134388382, 0.5026614945360217, 0.7043383548084703, 0.5701125837472629, 0.7115746436013309, 0.6663401982370531, 0.218192376855879, 0.6001810921541044, 0.6286656784170715, 0.6423486256952105, 0.6288619398249877, 0.6355611125077398, 0.6476274100342287, 0.6635362381737753, 0.44553430885821543, 0.6703558524283848, 0.6642284688617837, 0.6559951045920817, 0.5360238479167067, 0.4328696731996108, 0.4820947171632466, 0.5171075096741933, 0.4035475497844252, 0.32327030743495144, 0.3881601688557216, 0.4274339744994292, 0.5791665166983955, 0.20221962628901258, 0.20764941767994805, 0.20789857949273005, 0.2309826136925891, 0.22323731082902276, 0.23304640221573403, 0.2531876730365029, 0.2408527197532968, 0.20774264050886038, 0.2212251891210103, 0.23810404346099268, 0.19381693052909132, 0.21131994911476937, 0.2026181689618527, 0.21702155632129227, 0.2014861657022038, 0.24067094067501316, 0.21666539601308354, 0.8789240080637145, 0.1866684864163315, 0.15402006446240613, 0.9029370150940559, 0.1993280801706817, 0.16688406283573365, 0.16528090002832252, 0.15853071217136327, 0.1652720398589771, 0.8486201224845982, 0.2104839349443276, 0.8243682474231573, 0.16784417146527686, 0.15512417591801242, 0.16507864229292712, 0.21025960169347013, 0.21193780403779583, 0.21152930496349742, 0.17639933473096736, 0.18964158305668588, 0.18413590374273126, 0.19112611371116706, 0.19495815720587062, 0.17916903321249333, 0.17683227968192727, 0.2046374127374967, 0.19408585565727865, 0.09159762370452795, 0.08100049473434323, 0.09427302914174107, 0.09423944051555322, 0.09343404230289565, 0.09373045999484797, 0.0863882526705303, 0.09322723353469486, 0.08975577823699388]}, "mutation_prompt": null}
{"id": "d98e1a8f-f6c9-4587-9d73-27e2c99188fe", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.15 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedAdaptiveParticleSwarmDifferentialEvolution", "description": "Enhanced Adaptive Particle Swarm Differential Evolution incorporates adaptive inertia and mutation strategies for balanced exploration-exploitation.", "configspace": "", "generation": 64, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8500587276586233, 0.8393297956352658, 0.8536358271083151, 0.8404188340575113, 0.8378788012024376, 0.8345322610084017, 0.8417078042554902, 0.840823165461575, 0.834724138905704, 0.6980904892541777, 0.5361666165194587, 0.7103522630866015, 0.7094040877934275, 0.707001565065184, 0.7073552436984976, 0.717209070105833, 0.6960803706891419, 0.6887648121822114, 0.13245764309235142, 0.16689319434457173, 0.11195769710301051, 0.13347140912397681, 0.14903554241391026, 0.16545776623818542, 0.14678805201176892, 0.6145286452432877, 0.1377619213865945, 0.1289574978977256, 0.10683956171484355, 0.09854879337624622, 0.0978925138266834, 0.14427938145891617, 0.10743711709916481, 0.11697784819370427, 0.1245157308333561, 0.09599746930677389, 0.9816934991236178, 0.9806963227906501, 0.9785043231088756, 0.9814964855053749, 0.9753660353003819, 0.9799083817041437, 0.982452796891018, 0.9827826541205467, 0.9726215357318144, 0.7150455677995684, 0.7131986713519862, 0.7196171010120731, 0.7246883785670191, 0.7055871347702466, 0.7225230925689972, 0.7237897325326115, 0.7037961571369891, 0.7037465519316646, 0.8575249700896703, 0.8750646341694386, 0.8483922007093199, 0.846283312159307, 0.8193260783302906, 0.26883980989914125, 0.820387923854257, 0.8614525812359318, 0.8356584321919797, 0.7018016222858495, 0.6173216008966709, 0.6309412168669556, 0.5880648938263864, 0.6862437500946589, 0.584614532382953, 0.702799915656818, 0.6190907229981855, 0.6723797373744136, 0.6089239997789979, 0.6079258816849875, 0.6455422311919338, 0.6359845843918788, 0.5797746140675498, 0.6706370034139202, 0.5756049692942299, 0.6559502503419541, 0.6643463665299043, 0.6146158327185348, 0.4454020612715701, 0.644405774340935, 0.16504824548188157, 0.6383544161593435, 0.4300148340761125, 0.5927173864169516, 0.654352091573793, 0.6224279640235032, 0.665773555366431, 0.6460503729549989, 0.6605603099957409, 0.6420459343709141, 0.6925013724563336, 0.6388894239152377, 0.7096265159133857, 0.6762232654177733, 0.69278154445065, 0.14366094107448246, 0.1371580219380547, 0.4750438298881642, 0.5347509185591841, 0.5720102030064644, 0.34922371478312986, 0.12854249881660418, 0.3063287276910309, 0.33013361067143887, 0.5370290912241378, 0.5635899836356539, 0.5504403871365549, 0.5692855196898163, 0.5667102318643583, 0.5723296982057525, 0.5736440746649352, 0.5172404947713387, 0.4849724810400968, 0.7976480793011823, 0.8029349887075484, 0.7945286374323823, 0.7836721262439252, 0.7962275009171446, 0.7987591528284863, 0.7830177655713308, 0.8023192968249139, 0.8021742229774345, 0.1291523071645161, 0.561557168246466, 0.13104327090800638, 0.14415877848212677, 0.13406015164615603, 0.15092660182599316, 0.15041670633884952, 0.14632214971984592, 0.16614117050821675, 0.21802209870900224, 0.6788210825522554, 0.22572531085297576, 0.6829053522590944, 0.33497120590545315, 0.205531993537291, 0.5093800762504364, 0.37512658227764184, 0.5270855186372665, 0.5106527359391372, 0.6720441195257443, 0.6652311081743296, 0.5323317701433957, 0.6423520301096919, 0.656401368575783, 0.6704337240735279, 0.6827850781099738, 0.6817807741913787, 0.48815457149577013, 0.39923992397764985, 0.4692250398496164, 0.5716296658799125, 0.43522475313795617, 0.6039343245844956, 0.5699815285020562, 0.5266012386299318, 0.5789666154827939, 0.22685697634500934, 0.23315030901100797, 0.21726226575714414, 0.21133892233371132, 0.21798562964313228, 0.24023734151697163, 0.20081941931949387, 0.22567097694733296, 0.21854277009185885, 0.19514730288606175, 0.18741806013648288, 0.20230555707830333, 0.21662456932690266, 0.24322756002632828, 0.21726812422517694, 0.7527954809218548, 0.23754280347276358, 0.21638823490034598, 0.1820135690243042, 0.18553385669114797, 0.1530874763846234, 0.8508934761143182, 0.8559627434144151, 0.1666885727885714, 0.1410986941064839, 0.15996570695042878, 0.17206847982113382, 0.8695995434361168, 0.8576460090890367, 0.865908249490049, 0.20162618137714516, 0.16692280464129494, 0.15302709141228021, 0.16697653599917794, 0.21235519566426042, 0.7966842811067417, 0.17918024937769317, 0.18139510570427997, 0.17659470716992398, 0.20542550575909702, 0.18353254350449988, 0.18932930785249624, 0.18881334384944348, 0.1921147471422976, 0.18966261386987504, 0.08550612028993565, 0.08713220092704654, 0.0954432805637021, 0.0845591815656489, 0.0811993136261242, 0.09160317423402431, 0.08488661947751897, 0.09223614648385714, 0.08675495788853915]}, "mutation_prompt": null}
{"id": "02c4f530-cfca-4e3f-87ad-3c1d1e50ea9d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.5 * np.random.rand() * (fitness[i] / (personal_best_fitness[i] + 1e-8))\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.15 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedAdaptiveParticleSwarmDifferentialEvolution", "description": "Enhanced Adaptive Particle Swarm Differential Evolution with adaptive crossover and mutation dynamics for robust exploration-exploitation.", "configspace": "", "generation": 78, "fitness": 0.42556727732288874, "feedback": "The algorithm EnhancedAdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.25.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.7638730207684459, 0.7717175636742379, 0.7468558523742483, 0.7701280970452217, 0.7710029014002273, 0.772458549730409, 0.7599803533905998, 0.7486296174481805, 0.7582654224983266, 0.5185113986669099, 0.5593113728578394, 0.5715083924896934, 0.5783734160143947, 0.5264644436543606, 0.5053156576143495, 0.5445360456202746, 0.5545793518903135, 0.5486907033192103, 0.13839380029945003, 0.1407981451384841, 0.16038647454364474, 0.14374912373199822, 0.10959796742526084, 0.14102482578019992, 0.1504191212450463, 0.3288884677292644, 0.13142677956075244, 0.09732265723225741, 0.12117727768460296, 0.13014168478296995, 0.09252256803883496, 0.1276440708886719, 0.13443471890528635, 0.2229252493707945, 0.11156256251355168, 0.08653446800253006, 0.9671262236979853, 0.9595111919524312, 0.9693907544874069, 0.9785000644992893, 0.9812041652821575, 0.978227546895217, 0.9765277648233045, 0.9708189740280215, 0.9734721733377363, 0.5580261527089594, 0.4245594356449983, 0.4410247620602743, 0.5347336074750231, 0.5360813190393383, 0.4593895065888317, 0.5755870484586758, 0.5283375977132494, 0.5105719462429702, 0.7882061754097548, 0.7838617343098742, 0.7935790440107453, 0.7784539183501024, 0.7931790399515977, 0.7629793646184605, 0.7159805403922379, 0.7613820000163125, 0.8100750819045126, 0.12499385937196528, 0.11300605164405808, 0.23349509410878255, 0.500080118590637, 0.5659664974575886, 0.4807825540154461, 0.40139472160428447, 0.6029638623289888, 0.43369077492030805, 0.5637151877697022, 0.3651685969740214, 0.4296161972149165, 0.5543544612538691, 0.1230606556079279, 0.45743430570890864, 0.41824839862760466, 0.12787720039158612, 0.1271674498097637, 0.46437849213607785, 0.4878740872214363, 0.4957060306252721, 0.524455991906554, 0.5260950192980225, 0.4655444205906496, 0.5427244326908643, 0.41696642459994804, 0.5505106732429823, 0.5176502672912626, 0.5123838811272866, 0.5096881747373315, 0.4782858247518301, 0.4662979232420351, 0.3806927584471036, 0.47025482602884305, 0.5483360409706223, 0.486182467474939, 0.085112990663747, 0.28036638256200097, 0.2051803778128728, 0.43863968920549723, 0.3081099906928503, 0.10881904650779228, 0.33013826240463773, 0.1509290523041309, 0.09262564699871578, 0.4162501406446274, 0.41670286029767767, 0.4631324111655356, 0.4272296929384667, 0.43212744359583866, 0.43725029637455637, 0.44857082816428306, 0.46784927832185885, 0.4227074674870197, 0.7226198733991753, 0.7133788810826112, 0.7087782359087907, 0.7183233361227719, 0.7169938675192685, 0.7153555675941035, 0.7184846600360453, 0.7178198555996049, 0.7300440642541781, 0.13488776152691573, 0.165394083945559, 0.15714929123428356, 0.13855700004583194, 0.12046432188465483, 0.14101547619335486, 0.481342311846054, 0.12394679439545575, 0.10480250607539143, 0.17601662394913598, 0.21203921515281354, 0.3780268441304728, 0.19727912003747639, 0.45625737720286763, 0.2600685821888007, 0.1458406199160348, 0.15895268666579154, 0.6353146676333803, 0.4985401956438136, 0.466610807129647, 0.47700759672472526, 0.5192583753570976, 0.49721881201914575, 0.5201119402744869, 0.5058582239831579, 0.500808821971024, 0.4982736399061205, 0.36532918900526934, 0.424702837086529, 0.43245388593556344, 0.43004445391538115, 0.3809377674468726, 0.38521765787812834, 0.4511764483117453, 0.40046012245970064, 0.4557553155506533, 0.2005300937083082, 0.2250929352964004, 0.21912773190249468, 0.2139641090769372, 0.24896443789025202, 0.21447348229717023, 0.23804891963005825, 0.2080396778303043, 0.21048451417900738, 0.19182335546865648, 0.5794711511624362, 0.1999979023361944, 0.1972959986601105, 0.19240812357826986, 0.18928916112257088, 0.2326363106561471, 0.2311240871502308, 0.2030131671896206, 0.8471120598066008, 0.16806415200560754, 0.15325895320282834, 0.8333022055472379, 0.19834468164978958, 0.19571194701785732, 0.8036181777062078, 0.7865928324011189, 0.8012238153855273, 0.8207820714844083, 0.7547536556951882, 0.11188236009015529, 0.7731529668759047, 0.7340997011830288, 0.7496973548217933, 0.6317140256614524, 0.7462418832844978, 0.20857679678078156, 0.19101083566509458, 0.18978454236908537, 0.2251252971772144, 0.19856734227505624, 0.18327402365988488, 0.1894242303653274, 0.18162888874623528, 0.1812634721117844, 0.18485210881547176, 0.08035739740619152, 0.08681142172104317, 0.08397361196357489, 0.07898012697788659, 0.08440411579440765, 0.09061677230103726, 0.09204552662202181, 0.0902398401215907, 0.08861299262018041]}, "mutation_prompt": null}
{"id": "d4acd394-9f0c-4840-a77b-a1ea1928bc0e", "solution": "import numpy as np\n\nclass DynamicAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5)\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) * (personal_best_positions[local_search_idx] - local_solution)\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "DynamicAdaptiveParticleSwarmDifferentialEvolution", "description": "Dynamic Adaptive Particle Swarm Differential Evolution with local learning to enhance convergence.", "configspace": "", "generation": 79, "fitness": 0.4868809194084744, "feedback": "The algorithm DynamicAdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.28.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.84599583662299, 0.8364621976197569, 0.8442306234271384, 0.8501321149255692, 0.8429027404263527, 0.8417247776524901, 0.8384899720372143, 0.830656277047922, 0.839907712154623, 0.7007520624141955, 0.699832297278606, 0.6800919528890144, 0.7083401162991697, 0.7036737782931175, 0.713212084179641, 0.7107578309852278, 0.7042925228267924, 0.7105546607134459, 0.136213472387265, 0.153820425330641, 0.12099990567086027, 0.11879077632802437, 0.171346551192341, 0.13589470431370287, 0.1438047885188536, 0.11256259096827037, 0.13854362820821775, 0.13699752053765135, 0.12224913487388134, 0.6129877022606435, 0.1328243996209434, 0.12197437977877401, 0.13335332411472844, 0.10681078589861248, 0.10235405900713923, 0.09935408940531365, 0.9816934991236135, 0.9776063719591351, 0.9789768153028552, 0.9814964855053605, 0.9753967141515006, 0.979419720249226, 0.9824527968910071, 0.9827826541205391, 0.9726217707135796, 0.7123155953229133, 0.6953839795916749, 0.7039819812234069, 0.7111939056676733, 0.6961968752464657, 0.7248878378148285, 0.7129776062890116, 0.6864646925740201, 0.7179999149902242, 0.8582323105285613, 0.8602575001602708, 0.8569860483736054, 0.8570599350115409, 0.8486564144927916, 0.21016887247217675, 0.8311602228950948, 0.8587334641368762, 0.8395494492054747, 0.7296787472365951, 0.6940802653581356, 0.6536015177467267, 0.6354614359764192, 0.6272486333127344, 0.6281446693716544, 0.707320018631975, 0.6470181048192455, 0.6133679107222232, 0.7224515470456927, 0.6120840471915789, 0.613258523142084, 0.5710706460360147, 0.6143745744097867, 0.6171032551038802, 0.6142732911555034, 0.5908278070217909, 0.6265558997637513, 0.6197330774479212, 0.6564261641305762, 0.6379301708689308, 0.6136441356538687, 0.6175598853790233, 0.5846573095152781, 0.56057407233601, 0.624827024986409, 0.6521143544871196, 0.6711807588535372, 0.6575560358813402, 0.7012338819324423, 0.6706364536345106, 0.7035321230538006, 0.6590661533391037, 0.7088778886022832, 0.6777297677330332, 0.6951563647902366, 0.33733773654823906, 0.1737865898351182, 0.20257792366790806, 0.5523107420310907, 0.3033550168939593, 0.4951529854353609, 0.5995700844574282, 0.16396396977004712, 0.09851211782729674, 0.5323040275733998, 0.5362260310019065, 0.5491082042780975, 0.5324335229004081, 0.5055320347891561, 0.5550820801194579, 0.506349815470257, 0.5550859881759472, 0.5128900862061516, 0.791043605045909, 0.774378541657723, 0.7938275416428495, 0.7839967469029628, 0.795167041526286, 0.7925114632513663, 0.8195027862574443, 0.8009482813760691, 0.7882688132563895, 0.1402416486689685, 0.16161083830267342, 0.1363934925569643, 0.13138988374692162, 0.1747766474044138, 0.12034406768928729, 0.1690262797926929, 0.11467715711341953, 0.11968007789672863, 0.3527144031070395, 0.5904178976487879, 0.5350109723119716, 0.6784106639600065, 0.68982254138675, 0.27087188799658224, 0.5378973157329772, 0.6283050440006664, 0.2665129295063702, 0.3829816086927418, 0.583705337470878, 0.6600518528158243, 0.631457462759252, 0.647147974725411, 0.659133614295991, 0.6418874705223682, 0.666632254656746, 0.6518013303228409, 0.5739629003823183, 0.26863379081776806, 0.5218264592773671, 0.46556932196481604, 0.5668905012673648, 0.29088182757546477, 0.5546008946450932, 0.4764314758831171, 0.601713593060879, 0.2100247303124001, 0.24375978878347893, 0.20356999879515147, 0.22242678896901102, 0.21273511911968768, 0.21822941285726316, 0.2560345585158198, 0.2092776902811434, 0.20089418286798966, 0.18729677384031462, 0.2396476679463212, 0.21755061601665304, 0.18577310417938775, 0.21745318073872644, 0.21432203501370206, 0.7128407236917856, 0.23541772980992792, 0.2039685939323661, 0.18220550592505247, 0.18556735650574496, 0.15284586815692636, 0.1685204417252395, 0.198455676257707, 0.1673336551237271, 0.14217313220653927, 0.16956325289197394, 0.17161476056647695, 0.869512127446038, 0.12769110763007552, 0.8655108905959715, 0.8456886016641719, 0.16605317005540743, 0.15423010636600643, 0.1669858589156854, 0.21179456723829138, 0.7216457953897406, 0.1792797253160836, 0.18723811594376671, 0.17782592320173918, 0.1764153812017214, 0.18136040937018616, 0.17905162787510942, 0.18976561682998938, 0.1759873339315885, 0.19688081626451737, 0.08979744532875833, 0.09065685441542481, 0.08626434134036787, 0.09055442922696089, 0.08865040107136335, 0.09001909198397551, 0.0955211887466243, 0.09144431990421886, 0.09841205519468732]}, "mutation_prompt": null}
{"id": "431a041a-9bf7-480d-8ee0-e20c88aa23a6", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimization:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.7, CR_base=0.85, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.9 + 0.1 * (1 - (evaluations / self.budget)))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.15, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveHybridOptimization", "description": "Adaptive Hybrid Optimization integrates dynamic inertia and mutation strategies with stochastic local search enhancement for improved convergence.", "configspace": "", "generation": 80, "fitness": 0.4493839063312695, "feedback": "The algorithm AdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8246645617998323, 0.8129054654665528, 0.8255880303266234, 0.8372155722768384, 0.8282593400665863, 0.8316872715981872, 0.8292889254916685, 0.8421098161216606, 0.8275989180457993, 0.6866675895573542, 0.6866631637635234, 0.6700252136943237, 0.6630015885921365, 0.6700562843338385, 0.6568634625400647, 0.6601615320256355, 0.6819950672965669, 0.6708073597106861, 0.14378726278042508, 0.11024478680967753, 0.14354676949196143, 0.13810746130231633, 0.17086577408724113, 0.16774462906417298, 0.1129984198253956, 0.1437133410347402, 0.12530389354477445, 0.1274786170637242, 0.1485802619612987, 0.11640034680243994, 0.11990328455286925, 0.11590753029669254, 0.13750016962723333, 0.1351355975059645, 0.13019937223414269, 0.15501427099919762, 0.9829646988888832, 0.9758913416714994, 0.9843283937373961, 0.9761481412644647, 0.9741847231685619, 0.9693187071161937, 0.9843644095513313, 0.9734331192984993, 0.9795541851485484, 0.6853783009922725, 0.6321904967080676, 0.632018165864953, 0.6670448506528079, 0.6522163381352859, 0.6272636169040813, 0.6799381609911082, 0.6642850616529086, 0.6439606728784117, 0.8545983151088917, 0.8744228759448325, 0.835453233135437, 0.19054917491732315, 0.8402613661109037, 0.8533679467174118, 0.8133530067389609, 0.841518182284868, 0.8323642409936586, 0.6395006217119219, 0.581509709436344, 0.5900335340080924, 0.5461897033051798, 0.5724826450085816, 0.5613456815381686, 0.573325497593153, 0.6031059683939035, 0.5747435451797631, 0.6427993653519624, 0.5744103648117751, 0.5689753552960197, 0.5970765807682261, 0.5078229381360495, 0.5889839492404756, 0.12932988435767767, 0.11358950653585376, 0.6215283856736513, 0.4516253184833847, 0.4320064983794536, 0.3860350243706444, 0.4669728222823587, 0.5127424920539415, 0.5407737245820317, 0.5599442169028349, 0.36299608941267236, 0.504303155189171, 0.5727950508787303, 0.5890360359493532, 0.5995328422835573, 0.5509157393693097, 0.5225316109010134, 0.36603246607632123, 0.560596867027898, 0.5853868700537408, 0.5477750649989475, 0.10518337561572444, 0.3547423711101426, 0.0960697368075043, 0.3950214933785514, 0.4666775090455054, 0.21134187699618767, 0.3307564577114839, 0.1297706320783082, 0.10091631395496548, 0.42396296348107276, 0.4100073121819512, 0.4148897959455713, 0.4542141129764027, 0.42895259318171597, 0.43604626391543166, 0.4315653436152278, 0.41229021268113397, 0.4150911888372568, 0.742128051876304, 0.760775428395636, 0.7519094320382438, 0.7583385178840103, 0.7625633343416346, 0.7734450819472666, 0.7666420712156596, 0.761401273519806, 0.7731410292584242, 0.13101553430643487, 0.1472721909218433, 0.11014462301312289, 0.12446442070907193, 0.1619062976941339, 0.12904201216439493, 0.17010158321000568, 0.14648000666995453, 0.14771960441085863, 0.607847785798388, 0.5329631045231672, 0.5070814009066544, 0.6311447905147585, 0.21534024474190927, 0.2753364340502489, 0.25996484658145624, 0.21281124809905527, 0.2200807545517085, 0.5691227016719879, 0.5066797448169407, 0.5337792771533446, 0.5322316646079774, 0.5872127841261761, 0.5443115291583278, 0.49376405456506267, 0.5851662260609938, 0.5902481043784757, 0.2712899080244082, 0.41293924493271783, 0.49087471389647175, 0.3372939915553256, 0.46500073026424993, 0.4885486872714748, 0.4747273037536883, 0.5195561399695762, 0.4690094267892564, 0.19784298981445259, 0.210615608638957, 0.19235422321104612, 0.2202438148325475, 0.2260900518224288, 0.21765729565338932, 0.2544072304660854, 0.275542850389513, 0.19215709969739792, 0.21118268658699113, 0.20391435846780837, 0.24043725703046936, 0.2376042649079686, 0.22040717341176552, 0.24170447935749695, 0.21624901903146032, 0.2305087979795325, 0.20965081951034403, 0.21019559586050673, 0.16486430114540251, 0.15350493527712405, 0.8838686700034966, 0.8592543492566779, 0.16605227459616068, 0.8746251842598924, 0.16300022599039243, 0.855603695638045, 0.8781846439759371, 0.20972561625574038, 0.8212889409217804, 0.6517558022904102, 0.1662337293076831, 0.15232988300152395, 0.16578951417779209, 0.21213055886376397, 0.21056365813383804, 0.1813492202814323, 0.1773106534586223, 0.17811956151552366, 0.20204851121292344, 0.19782143781260098, 0.17827673579415093, 0.17901812351419755, 0.20709849744322795, 0.20231998468383405, 0.09634265199700076, 0.08769690978547806, 0.08520915407610552, 0.09331505862390932, 0.08009760138818489, 0.09063736035124115, 0.08541815976693667, 0.12225047626331798, 0.08761737615308207]}, "mutation_prompt": null}
{"id": "5516d1a7-8363-4244-a976-b89e9688fffb", "solution": "import numpy as np\n\nclass AdaptiveStrategyParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.6):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 0.5 * r1 * (personal_best_positions[i] - population[i]) +\n                                 0.5 * r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base * (1 + 0.1 * np.sin(2 * np.pi * evaluations / self.budget))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdaptiveStrategyParticleSwarmDifferentialEvolution", "description": "Adaptive Strategy Particle Swarm Differential Evolution employs dynamic adaptive strategies for enhanced convergence in high-dimensional search spaces.", "configspace": "", "generation": 81, "fitness": 0.48939038187524564, "feedback": "The algorithm AdaptiveStrategyParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8490122376325278, 0.8457953960422662, 0.8437641450796938, 0.8493366794823322, 0.8452368028996141, 0.8499363859968849, 0.8564912568720014, 0.8533659766602555, 0.8543314010435217, 0.732364308923537, 0.7209651229978787, 0.7246029508806231, 0.7069131145900878, 0.709007367080482, 0.7206891758980777, 0.714930004984007, 0.733300419255142, 0.749253871628444, 0.13873088942445866, 0.17501303628797626, 0.1481188106842436, 0.11483049216871077, 0.14764211968111862, 0.126484718702791, 0.16391977666261393, 0.1534396375012551, 0.515410692904048, 0.1086117230563205, 0.09854345383610197, 0.11061398494720065, 0.11241547917832706, 0.11987580572634138, 0.10653761713963972, 0.13144155034361393, 0.11088819255815219, 0.11488471867755545, 0.9652770768224281, 0.9664959002776042, 0.9651983827039328, 0.9573342172178837, 0.9646478714033243, 0.9708606939448804, 0.970182996127139, 0.9592033208889146, 0.9746002614287406, 0.7418813730387823, 0.6946571677598992, 0.703406710214855, 0.7425365120082285, 0.733397517090157, 0.7202653361209232, 0.735991476614217, 0.7188606566057305, 0.7330247600232445, 0.8672801209432853, 0.8433521006813036, 0.873799114108038, 0.8613419079936416, 0.8609885835585015, 0.8617991076418368, 0.8653217766975526, 0.8632968695874583, 0.8872316201964892, 0.6257349215505803, 0.47620391948886576, 0.6444668864211944, 0.603508985457532, 0.12844038593485674, 0.4495594703952678, 0.6689079474801697, 0.6164278213495349, 0.634283136866552, 0.6558295799446593, 0.6785327634731451, 0.2660124919852799, 0.5701874539742364, 0.45729033340738356, 0.4997834175335968, 0.6451919701861468, 0.6433134452131672, 0.6788804037593583, 0.6158743501891579, 0.6828859242188883, 0.6455590036114911, 0.6574532464606029, 0.6424446113484172, 0.6083596161070379, 0.67173228550322, 0.6346728465201876, 0.6535692994430938, 0.7308029835597399, 0.6918277205722254, 0.7179759798771082, 0.726999613638595, 0.7044603618207503, 0.7071129288048652, 0.7309361814249913, 0.7049523322869217, 0.7318085186693774, 0.2290359290311288, 0.1546148334131351, 0.1083772755042266, 0.5775820879546942, 0.16712602406373278, 0.354759333879194, 0.23913131394769693, 0.15768533594434941, 0.2144550871081985, 0.5359535749410549, 0.5561441964146396, 0.5310818571579086, 0.5698706267224177, 0.5500450973348676, 0.5358625931782897, 0.5215554449482821, 0.5279149781142489, 0.5181717154721728, 0.7962074145127791, 0.8141498922900579, 0.8144999391804764, 0.8186809038105152, 0.8076283176560455, 0.7907611861986512, 0.8145708018663054, 0.7965201769505048, 0.7812589050370061, 0.12423354173154344, 0.1299893886377338, 0.5597778684795784, 0.15073885179518398, 0.16432129568135756, 0.1680794286351096, 0.11570604366184634, 0.12236760831992433, 0.13389587586104157, 0.721787351647764, 0.35374752406152843, 0.5578180838272728, 0.7077176436853944, 0.44318221413572534, 0.340899030560186, 0.21444686409709213, 0.23968793270978517, 0.22224498833797968, 0.6550202103880659, 0.6327977494275976, 0.6705211289681071, 0.6333716680463035, 0.6375313804657459, 0.6755996710035299, 0.6831681081547618, 0.6455873064558066, 0.673209264682904, 0.5765442154116179, 0.5056821884541787, 0.5621345112778555, 0.5750499687384869, 0.38163848327801475, 0.46861967547483174, 0.599178715425261, 0.5588963156715934, 0.5803519697660589, 0.21095759449850238, 0.21966841368220613, 0.21492876606817035, 0.22890910669206832, 0.1946652476361962, 0.2064223498934522, 0.2083479938456939, 0.22459712244233565, 0.25636893068114364, 0.20033753254003217, 0.18518826247842013, 0.21737583537112293, 0.21528809739403532, 0.20417651336174547, 0.19333278921684938, 0.24025388845133688, 0.21583200605071062, 0.19311177352567455, 0.18488829207282842, 0.8934077133646826, 0.17209230131960407, 0.20754483080012265, 0.1982107108553095, 0.19918000507400102, 0.14199877103597025, 0.1755341907440603, 0.8952777150795568, 0.8898728164349596, 0.21028696133243663, 0.2077949834181556, 0.8751781792566069, 0.20742950149309247, 0.8472650944126278, 0.16725859440836555, 0.12656666844356534, 0.21132623417269247, 0.20050873844592143, 0.1955702253173761, 0.18072878746325438, 0.1786200417504915, 0.1864409169665847, 0.18222976977474403, 0.18282676447174795, 0.20612156333247633, 0.1707120964032831, 0.09431381128796545, 0.09476245924820814, 0.09781018624908211, 0.09693739641981469, 0.09654180115000488, 0.0908542414512924, 0.09154840424208288, 0.09194903980900504, 0.09886565652701029]}, "mutation_prompt": null}
{"id": "8f982d3d-3838-49b5-88ad-451a5466d66a", "solution": "import numpy as np\n\nclass DynamicHybridOptimization:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.9, CR_base=0.8, inertia_weight=0.6):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-0.5, 0.5, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.2 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "DynamicHybridOptimization", "description": "Dynamic Hybrid Optimization integrates adaptive velocity control and dynamic mutation scaling for improved convergence.", "configspace": "", "generation": 82, "fitness": 0.44807922977689607, "feedback": "The algorithm DynamicHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8588101498227927, 0.8442755581593883, 0.8554904658323144, 0.8537111900269638, 0.8548177138165219, 0.8599246016787245, 0.8564165411110454, 0.8638467388587259, 0.8525820800427115, 0.7246219175685733, 0.6850683017744651, 0.7377279464706294, 0.7150673202618519, 0.7322172109958698, 0.738413811323599, 0.7162474244971321, 0.7317993195262921, 0.7279138556509024, 0.16888536230396844, 0.11553299235671022, 0.1531847087769842, 0.16979786308378575, 0.6248893360352796, 0.1745939356047289, 0.14714381437981972, 0.15196139938519404, 0.14154630494967424, 0.11201527291951474, 0.1307994991762269, 0.09076676069551726, 0.10070890926424292, 0.09305748624496046, 0.14458292566551523, 0.14090078688965169, 0.12544042723655602, 0.10446440042919569, 0.9720595568946145, 0.970072923908465, 0.9863966443784639, 0.9866606633639593, 0.9822872347960598, 0.9709979374174481, 0.9895473357470357, 0.9686967584408065, 0.9784463038882837, 0.7231349073459413, 0.7281509469883127, 0.7276338754657112, 0.7043394936636835, 0.7257924320385911, 0.6975714054913055, 0.7293872545155979, 0.7300562421174024, 0.700854034324116, 0.823683260425042, 0.8313328811332354, 0.8451701695528675, 0.2755509115298591, 0.21798797492327815, 0.8301659296421839, 0.8516284852220778, 0.8321686020051564, 0.8775439637159742, 0.549026066464416, 0.5859983989914139, 0.589580669259119, 0.5523344948716732, 0.1303497567975821, 0.5521626046675889, 0.5064890760223167, 0.5520076848238775, 0.563037090287197, 0.5764157544579505, 0.39216724062149255, 0.41710355143788236, 0.12946933599992394, 0.6566049320306262, 0.6088309242456142, 0.5496639920391878, 0.6357781774087874, 0.5464928643926131, 0.46064235949494026, 0.5160504616087149, 0.5385616982331078, 0.4162044144001956, 0.49051151412994654, 0.5316803247424925, 0.46760208634876455, 0.5007240108193975, 0.5162642546009415, 0.5629552616014746, 0.6146007908612918, 0.5977184121046, 0.5530399887268417, 0.4481387466988993, 0.5726620066139925, 0.6046755735558924, 0.6444808478936698, 0.6385364755112342, 0.1449307191418273, 0.10085851549658842, 0.16725581504908837, 0.24889754905460615, 0.14753558189236282, 0.35554883399543946, 0.10542498621770102, 0.14089735525937852, 0.15245952687896114, 0.41588787622548684, 0.41001947844467146, 0.387911577089872, 0.4255187803575402, 0.41594372403286706, 0.4666487652004021, 0.3238341325957126, 0.3941168815997158, 0.3835215924421833, 0.7641989434927747, 0.7820311728952041, 0.789939386446623, 0.7669785275882381, 0.7678118213009877, 0.7739825812331693, 0.7922435379234001, 0.7840219374064956, 0.7765015052821922, 0.1672338715806838, 0.09781004483727851, 0.13911454932513212, 0.13255662786458577, 0.16898688677020857, 0.12226371744141673, 0.14765402182965826, 0.1203798634664559, 0.08222403029991088, 0.6094619140512919, 0.18577431716564696, 0.23640801388132848, 0.448200006677293, 0.5033055039127374, 0.5275759799333302, 0.7072186337859356, 0.6281101424086664, 0.20536619521814214, 0.5214325608161161, 0.4690586810581503, 0.5480490686311732, 0.4709487404698002, 0.43053445674914614, 0.6800770157108396, 0.6942346169651535, 0.6656971594047942, 0.6782273216753548, 0.3126644750087296, 0.31360353352858306, 0.46638597967894535, 0.4561685940538487, 0.24736401992817603, 0.43794412139079697, 0.5453534367002086, 0.4415846117373615, 0.5113295624204691, 0.19850447875091692, 0.17750077780012474, 0.19481202955303756, 0.20082944109693535, 0.2019727899640671, 0.19610491562518118, 0.2143154151886113, 0.22080719119195746, 0.2069566812334085, 0.21916886214647635, 0.23718458355846783, 0.20150836497079228, 0.2284560954371625, 0.18925972111734268, 0.2096150495674035, 0.20918287653153034, 0.18449548990940512, 0.20531125041222986, 0.17062041987514298, 0.1930889857928112, 0.1531409659215407, 0.8999766787080402, 0.1991731493339418, 0.8726636316261549, 0.8658012403800404, 0.16250931025307835, 0.20840412459857338, 0.8594380368253122, 0.2102193557090294, 0.21034790869767417, 0.20718169042306878, 0.16651599416278973, 0.8463930807586725, 0.2101720792628755, 0.2115163082214805, 0.15521978996598595, 0.18167966899620958, 0.179802683198361, 0.18453387854683256, 0.17963632869906376, 0.18022407957783493, 0.19184748552927466, 0.19330704114532915, 0.171507245674821, 0.17642316086647114, 0.0969526640316224, 0.09375267203553683, 0.08381051015596674, 0.08385298721443246, 0.08895453441033074, 0.09509107887717416, 0.0930151245008577, 0.0939755338028011, 0.08805050453737617]}, "mutation_prompt": null}
{"id": "c3788062-993b-47f7-bcee-34feeb9862b7", "solution": "import numpy as np\n\nclass EnhancedAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (1 - (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.3 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.5)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.15 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n            # Introduce dynamic population strategy to enhance diversity\n            if np.random.rand() < 0.5:\n                new_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size // 10, self.dim))\n                new_fitness = np.apply_along_axis(func, 1, new_individuals)\n                evaluations += self.pop_size // 10\n                combined_population = np.vstack((population, new_individuals))\n                combined_fitness = np.hstack((fitness, new_fitness))\n                selected_indices = np.argsort(combined_fitness)[:self.pop_size]\n                population, fitness = combined_population[selected_indices], combined_fitness[selected_indices]\n                personal_best_positions[selected_indices] = population\n                personal_best_fitness[selected_indices] = fitness\n\n        return global_best", "name": "EnhancedAdaptiveParticleSwarmDifferentialEvolution", "description": "Enhanced Adaptive Particle Swarm Differential Evolution with Dynamic Population for increased diversity and adaptability.", "configspace": "", "generation": 83, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 53 is out of bounds for axis 0 with size 50').", "error": "IndexError('index 53 is out of bounds for axis 0 with size 50')", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {}, "mutation_prompt": null}
{"id": "0ec4e18c-410f-48a0-8a39-7151f583cb20", "solution": "import numpy as np\n\nclass DynamicAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r3 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.25) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.2 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.1)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "DynamicAdaptiveParticleSwarmDifferentialEvolution", "description": "Dynamic Adaptive Particle Swarm Differential Evolution employs dynamic strategies and local search to optimize exploration-exploitation balance.", "configspace": "", "generation": 84, "fitness": 0.5064343465524965, "feedback": "The algorithm DynamicAdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.29.", "error": "", "parent_id": "c0a8dc61-26a5-44da-85f5-65077bec4fc6", "metadata": {"aucs": [0.8707552494565642, 0.8453857177296805, 0.8623216073123912, 0.8639634056205705, 0.860099406349679, 0.8765174814497569, 0.8574743244522545, 0.8558868606726054, 0.87297939341506, 0.7243729322766688, 0.7331840983305267, 0.7220534101984792, 0.7316274859765667, 0.734434232045909, 0.726943189241064, 0.7389493800862412, 0.7526491230898371, 0.7496230539109217, 0.14494066531034655, 0.1260310369963652, 0.13363165815580758, 0.13656971948914964, 0.17245596692931942, 0.15228446972629084, 0.13785917119357016, 0.1369681543633291, 0.1524411975979474, 0.07882027010243253, 0.1157336015662298, 0.12469434414749281, 0.12430200556196269, 0.13555589423269487, 0.11192004459858984, 0.12290745343359466, 0.14904815610898026, 0.10688078686123359, 0.968249677894721, 0.9772663867970012, 0.9778758482228881, 0.9830873440225228, 0.9612499851513675, 0.9671818449284495, 0.9684787420177051, 0.9868214437712359, 0.9718264198671591, 0.7266296741462954, 0.7231018159776667, 0.6949995481763922, 0.738085022610898, 0.7064418940142774, 0.72886420980048, 0.7247044208631245, 0.6820075932404472, 0.7237320667654852, 0.8889510554235082, 0.8816723795674369, 0.8896767473708151, 0.8999055714252742, 0.8904310488792816, 0.8722480198087406, 0.8902907316435267, 0.8947735778872629, 0.885630701450423, 0.6522705391983059, 0.6396509138050408, 0.65788385787317, 0.6392396591299647, 0.7202315397186358, 0.7507300145542418, 0.6930813144060535, 0.7060236235599336, 0.6554280567624197, 0.6395047770464868, 0.5912344806137912, 0.12988641864205197, 0.13222183110374097, 0.5374343117404403, 0.6582447752644696, 0.7304697336121762, 0.6157800079661135, 0.7104617994108302, 0.6578571762029488, 0.6609281527995889, 0.6084481734086952, 0.7250661553036244, 0.6998779743383048, 0.6796466514523587, 0.6912951776686628, 0.7058957198460697, 0.700930299790764, 0.7300449550701393, 0.7709624834156741, 0.7937846326013281, 0.7421038947879264, 0.7460148921041905, 0.7611930142413965, 0.741383589891443, 0.7711436316377749, 0.7640024393528514, 0.4182890877230897, 0.3488717723555458, 0.4202567499230495, 0.6175511496335404, 0.5354779306659578, 0.19828393285960733, 0.4341778847791218, 0.31169520831594855, 0.3324317372262441, 0.4967644453504897, 0.5507301825814768, 0.5213158374566962, 0.4994451948750871, 0.5328573024564888, 0.5578406699962606, 0.5182051736168617, 0.5108456449603405, 0.48419920307059205, 0.8160980527822864, 0.8029268481675572, 0.8330611624500153, 0.8263296430974616, 0.8092117917243724, 0.8315556622905507, 0.8345334255592145, 0.822294151875024, 0.8247913382984053, 0.09996607996813967, 0.11597393724833416, 0.15334154838465253, 0.12143860356566616, 0.11922040926559807, 0.11911777261936385, 0.1471017595243167, 0.5107190186554396, 0.17354245431647364, 0.37999127090536444, 0.1959338999755188, 0.22233099803734901, 0.6763421834113561, 0.38093870383574835, 0.24138388399900945, 0.2717857201886088, 0.6935884395716501, 0.564348400882545, 0.5198106381301248, 0.5274366719374128, 0.3980289724992785, 0.6314193292976384, 0.6164366058993498, 0.5845124121773961, 0.6144871051743697, 0.6375936206327149, 0.5035390505886337, 0.4631007382131883, 0.5086290946176593, 0.5700676672608216, 0.45349408801434166, 0.4766267396155416, 0.42971592823317795, 0.5711807553424265, 0.4608043389130705, 0.5723349634620165, 0.21791126614710632, 0.22243575957716855, 0.20677090455654767, 0.21896518288064126, 0.2135292491854932, 0.22335470042502237, 0.19424742861151778, 0.1961981253978462, 0.21810544943312404, 0.24611418745647118, 0.24792900207793134, 0.23867523844372762, 0.21393137468343948, 0.18084056898952972, 0.2199252569256832, 0.2058751406724868, 0.19683508736966737, 0.21574099518016532, 0.2088247798466023, 0.16709920932745403, 0.15336743790932172, 0.18574873977443995, 0.20022519715365938, 0.1664555255328074, 0.89059662737315, 0.8972969316983, 0.8964320504610284, 0.21026105643516801, 0.8453090195917459, 0.0734976032789576, 0.8635436347232608, 0.8771258538056363, 0.8676376175098057, 0.2121102145973519, 0.21019341609088615, 0.8838516077056169, 0.18441294677706688, 0.1915610751451593, 0.18984002850805493, 0.19297474307803764, 0.18571810491647744, 0.1918504373926455, 0.1823499551186153, 0.19257187393718556, 0.18897600049054308, 0.09039187977345942, 0.08237653213176999, 0.08269842917301917, 0.08791316722357656, 0.11725787216782357, 0.0951670606162166, 0.08525913252279005, 0.09331166200076768, 0.09509613704557729]}, "mutation_prompt": null}
{"id": "c3bfd1e6-465f-45c4-bed7-2aeb87a61649", "solution": "import numpy as np\n\nclass DynamicAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r3 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.25) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.2 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.1)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "DynamicAdaptiveParticleSwarmDifferentialEvolution", "description": "Dynamic Adaptive Particle Swarm Differential Evolution employs dynamic strategies and local search to optimize exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0ec4e18c-410f-48a0-8a39-7151f583cb20", "metadata": {"aucs": [0.8707552494565642, 0.8453857177296805, 0.8623216073123912, 0.8639634056205705, 0.860099406349679, 0.8765174814497569, 0.8574743244522545, 0.8558868606726054, 0.87297939341506, 0.7243729322766688, 0.7331840983305267, 0.7220534101984792, 0.7316274859765667, 0.734434232045909, 0.726943189241064, 0.7389493800862412, 0.7526491230898371, 0.7496230539109217, 0.14494066531034655, 0.1260310369963652, 0.13363165815580758, 0.13656971948914964, 0.17245596692931942, 0.15228446972629084, 0.13785917119357016, 0.1369681543633291, 0.1524411975979474, 0.07882027010243253, 0.1157336015662298, 0.12469434414749281, 0.12430200556196269, 0.13555589423269487, 0.11192004459858984, 0.12290745343359466, 0.14904815610898026, 0.10688078686123359, 0.968249677894721, 0.9772663867970012, 0.9778758482228881, 0.9830873440225228, 0.9612499851513675, 0.9671818449284495, 0.9684787420177051, 0.9868214437712359, 0.9718264198671591, 0.7266296741462954, 0.7231018159776667, 0.6949995481763922, 0.738085022610898, 0.7064418940142774, 0.72886420980048, 0.7247044208631245, 0.6820075932404472, 0.7237320667654852, 0.8889510554235082, 0.8816723795674369, 0.8896767473708151, 0.8999055714252742, 0.8904310488792816, 0.8722480198087406, 0.8902907316435267, 0.8947735778872629, 0.885630701450423, 0.6522705391983059, 0.6396509138050408, 0.65788385787317, 0.6392396591299647, 0.7202315397186358, 0.7507300145542418, 0.6930813144060535, 0.7060236235599336, 0.6554280567624197, 0.6395047770464868, 0.5912344806137912, 0.12988641864205197, 0.13222183110374097, 0.5374343117404403, 0.6582447752644696, 0.7304697336121762, 0.6157800079661135, 0.7104617994108302, 0.6578571762029488, 0.6609281527995889, 0.6084481734086952, 0.7250661553036244, 0.6998779743383048, 0.6796466514523587, 0.6912951776686628, 0.7058957198460697, 0.700930299790764, 0.7300449550701393, 0.7709624834156741, 0.7937846326013281, 0.7421038947879264, 0.7460148921041905, 0.7611930142413965, 0.741383589891443, 0.7711436316377749, 0.7640024393528514, 0.4182890877230897, 0.3488717723555458, 0.4202567499230495, 0.6175511496335404, 0.5354779306659578, 0.19828393285960733, 0.4341778847791218, 0.31169520831594855, 0.3324317372262441, 0.4967644453504897, 0.5507301825814768, 0.5213158374566962, 0.4994451948750871, 0.5328573024564888, 0.5578406699962606, 0.5182051736168617, 0.5108456449603405, 0.48419920307059205, 0.8160980527822864, 0.8029268481675572, 0.8330611624500153, 0.8263296430974616, 0.8092117917243724, 0.8315556622905507, 0.8345334255592145, 0.822294151875024, 0.8247913382984053, 0.09996607996813967, 0.11597393724833416, 0.15334154838465253, 0.12143860356566616, 0.11922040926559807, 0.11911777261936385, 0.1471017595243167, 0.5107190186554396, 0.17354245431647364, 0.37999127090536444, 0.1959338999755188, 0.22233099803734901, 0.6763421834113561, 0.38093870383574835, 0.24138388399900945, 0.2717857201886088, 0.6935884395716501, 0.564348400882545, 0.5198106381301248, 0.5274366719374128, 0.3980289724992785, 0.6314193292976384, 0.6164366058993498, 0.5845124121773961, 0.6144871051743697, 0.6375936206327149, 0.5035390505886337, 0.4631007382131883, 0.5086290946176593, 0.5700676672608216, 0.45349408801434166, 0.4766267396155416, 0.42971592823317795, 0.5711807553424265, 0.4608043389130705, 0.5723349634620165, 0.21791126614710632, 0.22243575957716855, 0.20677090455654767, 0.21896518288064126, 0.2135292491854932, 0.22335470042502237, 0.19424742861151778, 0.1961981253978462, 0.21810544943312404, 0.24611418745647118, 0.24792900207793134, 0.23867523844372762, 0.21393137468343948, 0.18084056898952972, 0.2199252569256832, 0.2058751406724868, 0.19683508736966737, 0.21574099518016532, 0.2088247798466023, 0.16709920932745403, 0.15336743790932172, 0.18574873977443995, 0.20022519715365938, 0.1664555255328074, 0.89059662737315, 0.8972969316983, 0.8964320504610284, 0.21026105643516801, 0.8453090195917459, 0.0734976032789576, 0.8635436347232608, 0.8771258538056363, 0.8676376175098057, 0.2121102145973519, 0.21019341609088615, 0.8838516077056169, 0.18441294677706688, 0.1915610751451593, 0.18984002850805493, 0.19297474307803764, 0.18571810491647744, 0.1918504373926455, 0.1823499551186153, 0.19257187393718556, 0.18897600049054308, 0.09039187977345942, 0.08237653213176999, 0.08269842917301917, 0.08791316722357656, 0.11725787216782357, 0.0951670606162166, 0.08525913252279005, 0.09331166200076768, 0.09509613704557729]}, "mutation_prompt": null}
{"id": "93da79e3-f2c1-4020-a4d7-ef5be9a744b0", "solution": "import numpy as np\n\nclass DynamicAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r3 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.25) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.2 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.1)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "DynamicAdaptiveParticleSwarmDifferentialEvolution", "description": "Dynamic Adaptive Particle Swarm Differential Evolution employs dynamic strategies and local search to optimize exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0ec4e18c-410f-48a0-8a39-7151f583cb20", "metadata": {"aucs": [0.8707552494565642, 0.8453857177296805, 0.8623216073123912, 0.8639634056205705, 0.860099406349679, 0.8765174814497569, 0.8574743244522545, 0.8558868606726054, 0.87297939341506, 0.7243729322766688, 0.7331840983305267, 0.7220534101984792, 0.7316274859765667, 0.734434232045909, 0.726943189241064, 0.7389493800862412, 0.7526491230898371, 0.7496230539109217, 0.14494066531034655, 0.1260310369963652, 0.13363165815580758, 0.13656971948914964, 0.17245596692931942, 0.15228446972629084, 0.13785917119357016, 0.1369681543633291, 0.1524411975979474, 0.07882027010243253, 0.1157336015662298, 0.12469434414749281, 0.12430200556196269, 0.13555589423269487, 0.11192004459858984, 0.12290745343359466, 0.14904815610898026, 0.10688078686123359, 0.968249677894721, 0.9772663867970012, 0.9778758482228881, 0.9830873440225228, 0.9612499851513675, 0.9671818449284495, 0.9684787420177051, 0.9868214437712359, 0.9718264198671591, 0.7266296741462954, 0.7231018159776667, 0.6949995481763922, 0.738085022610898, 0.7064418940142774, 0.72886420980048, 0.7247044208631245, 0.6820075932404472, 0.7237320667654852, 0.8889510554235082, 0.8816723795674369, 0.8896767473708151, 0.8999055714252742, 0.8904310488792816, 0.8722480198087406, 0.8902907316435267, 0.8947735778872629, 0.885630701450423, 0.6522705391983059, 0.6396509138050408, 0.65788385787317, 0.6392396591299647, 0.7202315397186358, 0.7507300145542418, 0.6930813144060535, 0.7060236235599336, 0.6554280567624197, 0.6395047770464868, 0.5912344806137912, 0.12988641864205197, 0.13222183110374097, 0.5374343117404403, 0.6582447752644696, 0.7304697336121762, 0.6157800079661135, 0.7104617994108302, 0.6578571762029488, 0.6609281527995889, 0.6084481734086952, 0.7250661553036244, 0.6998779743383048, 0.6796466514523587, 0.6912951776686628, 0.7058957198460697, 0.700930299790764, 0.7300449550701393, 0.7709624834156741, 0.7937846326013281, 0.7421038947879264, 0.7460148921041905, 0.7611930142413965, 0.741383589891443, 0.7711436316377749, 0.7640024393528514, 0.4182890877230897, 0.3488717723555458, 0.4202567499230495, 0.6175511496335404, 0.5354779306659578, 0.19828393285960733, 0.4341778847791218, 0.31169520831594855, 0.3324317372262441, 0.4967644453504897, 0.5507301825814768, 0.5213158374566962, 0.4994451948750871, 0.5328573024564888, 0.5578406699962606, 0.5182051736168617, 0.5108456449603405, 0.48419920307059205, 0.8160980527822864, 0.8029268481675572, 0.8330611624500153, 0.8263296430974616, 0.8092117917243724, 0.8315556622905507, 0.8345334255592145, 0.822294151875024, 0.8247913382984053, 0.09996607996813967, 0.11597393724833416, 0.15334154838465253, 0.12143860356566616, 0.11922040926559807, 0.11911777261936385, 0.1471017595243167, 0.5107190186554396, 0.17354245431647364, 0.37999127090536444, 0.1959338999755188, 0.22233099803734901, 0.6763421834113561, 0.38093870383574835, 0.24138388399900945, 0.2717857201886088, 0.6935884395716501, 0.564348400882545, 0.5198106381301248, 0.5274366719374128, 0.3980289724992785, 0.6314193292976384, 0.6164366058993498, 0.5845124121773961, 0.6144871051743697, 0.6375936206327149, 0.5035390505886337, 0.4631007382131883, 0.5086290946176593, 0.5700676672608216, 0.45349408801434166, 0.4766267396155416, 0.42971592823317795, 0.5711807553424265, 0.4608043389130705, 0.5723349634620165, 0.21791126614710632, 0.22243575957716855, 0.20677090455654767, 0.21896518288064126, 0.2135292491854932, 0.22335470042502237, 0.19424742861151778, 0.1961981253978462, 0.21810544943312404, 0.24611418745647118, 0.24792900207793134, 0.23867523844372762, 0.21393137468343948, 0.18084056898952972, 0.2199252569256832, 0.2058751406724868, 0.19683508736966737, 0.21574099518016532, 0.2088247798466023, 0.16709920932745403, 0.15336743790932172, 0.18574873977443995, 0.20022519715365938, 0.1664555255328074, 0.89059662737315, 0.8972969316983, 0.8964320504610284, 0.21026105643516801, 0.8453090195917459, 0.0734976032789576, 0.8635436347232608, 0.8771258538056363, 0.8676376175098057, 0.2121102145973519, 0.21019341609088615, 0.8838516077056169, 0.18441294677706688, 0.1915610751451593, 0.18984002850805493, 0.19297474307803764, 0.18571810491647744, 0.1918504373926455, 0.1823499551186153, 0.19257187393718556, 0.18897600049054308, 0.09039187977345942, 0.08237653213176999, 0.08269842917301917, 0.08791316722357656, 0.11725787216782357, 0.0951670606162166, 0.08525913252279005, 0.09331166200076768, 0.09509613704557729]}, "mutation_prompt": null}
{"id": "9b3d854d-82bc-43c7-ae30-97d99cf2f436", "solution": "import numpy as np\n\nclass EnhancedParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7, mutation_rate=0.3):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.mutation_rate = mutation_rate\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.6 + (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.mutation_rate:\n                    F_dynamic = self.F_base + 0.6 * r3 * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.3 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.3 * (np.random.rand() - 0.15)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim) + 0.15 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedParticleSwarmDifferentialEvolution", "description": "Enhanced Particle Swarm Differential Evolution integrates adaptive mutation and crossover with local search to improve exploration and exploitation balance.", "configspace": "", "generation": 87, "fitness": 0.4890503889403202, "feedback": "The algorithm EnhancedParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "0ec4e18c-410f-48a0-8a39-7151f583cb20", "metadata": {"aucs": [0.8666898952293949, 0.8632832082079028, 0.8592475725283127, 0.8638025627868492, 0.8508193445450145, 0.8670658619839726, 0.8647542368244517, 0.8626020958734547, 0.8580340740736638, 0.7160226105721454, 0.7194356537144728, 0.7030702544112395, 0.7247338132436133, 0.7503550353419336, 0.709536103826617, 0.7295157474266674, 0.7325749702172217, 0.6522334312591341, 0.1512456572968056, 0.1090858879799469, 0.15114344350022824, 0.1349497768664969, 0.11294947181946113, 0.10346721602523301, 0.142634108740597, 0.14017365686637417, 0.1555897787299757, 0.12480144089003642, 0.0922846046675142, 0.09176279409144805, 0.10457079810859138, 0.12855161154963002, 0.09960078341974199, 0.11920241889947647, 0.09145288512316851, 0.09725459465725295, 0.9839192553135758, 0.9667175196267912, 0.98095655380614, 0.981839852939945, 0.9843384131189971, 0.9567267598024601, 0.978637396947025, 0.977221327983957, 0.9918789976792786, 0.6313028162563932, 0.6848546971947664, 0.6789888084436344, 0.6766391603100983, 0.6053049942975813, 0.6915894261471928, 0.7552468542061102, 0.6118404444029037, 0.687869184836208, 0.8975028096922364, 0.8845603940648175, 0.8721329744119509, 0.8671652684679858, 0.8918362133447499, 0.8836387529324768, 0.8728010224708992, 0.8772816452303923, 0.8734310225126558, 0.7656979837884916, 0.6336603798766532, 0.6582151153599936, 0.6832497126067454, 0.13247020103601737, 0.6730991656735686, 0.665483926794908, 0.6589276546767516, 0.6218278549988201, 0.663786976867674, 0.5694164711324571, 0.583193848071776, 0.5392016465555127, 0.7341819954343853, 0.6893348129988266, 0.6205752565049101, 0.543034319417393, 0.7365068560007932, 0.6524806547577348, 0.7229814595551693, 0.6585042366394014, 0.6902516900009915, 0.6121440344611131, 0.7123432233631585, 0.6515716926110904, 0.6713384345426991, 0.6634683279766806, 0.7716795552029568, 0.7674355696927473, 0.7434349576421516, 0.7385396903645882, 0.7179217143252785, 0.7075839248955702, 0.7180211331820086, 0.7118628592117732, 0.7055456441080836, 0.3592626597077542, 0.13644984551436268, 0.166172578136903, 0.5605972642061433, 0.5050451085159232, 0.5592576336341986, 0.39788676168504644, 0.31018552791764, 0.29513829853788465, 0.477062126901344, 0.5037765438416487, 0.4633524086152895, 0.4707949212046836, 0.4922674823081584, 0.47058365837372973, 0.5003424424778273, 0.4644475944414529, 0.4519814968188751, 0.8152167311422231, 0.8324028180922727, 0.8120297893184836, 0.8202225621820677, 0.8142038318954625, 0.8292048978725222, 0.8194323135002198, 0.8227029701378981, 0.8202722904820572, 0.14166059811047693, 0.11420796907394304, 0.16576390699198795, 0.1141490818925287, 0.6862755963897106, 0.14974484427880252, 0.15239912362538144, 0.15276103810695296, 0.15787463599486506, 0.18630590533023128, 0.18850756190936457, 0.5979383716678331, 0.5662043887192931, 0.22906394556293963, 0.2306390104231767, 0.3578240175418608, 0.19821814757582468, 0.2724203633334218, 0.44886231347681993, 0.5785976764148464, 0.5835745440641684, 0.5437415262238215, 0.5202902624218496, 0.5062282078617901, 0.5604016602059056, 0.3883104561575186, 0.5443003792720786, 0.444523780580253, 0.4202309204554031, 0.4774382887272903, 0.39169574943476604, 0.4880310268495627, 0.476766971590714, 0.4688908397889383, 0.4604786899776744, 0.5043006795881422, 0.22974301052942414, 0.2136848563613798, 0.19268459876982746, 0.20560867557443763, 0.2150133317983125, 0.21472621710440754, 0.25455125454338245, 0.20462675387788054, 0.19810993575530322, 0.2407854577586328, 0.239474811350309, 0.1953694672262728, 0.7225864512388684, 0.19498031019626616, 0.18737578440497948, 0.20654027636797356, 0.2457345378993091, 0.2439672712884603, 0.16621510990030242, 0.18647364996843163, 0.18642928644924017, 0.1971019743174981, 0.1994649757372713, 0.21011343721220077, 0.1411377794263009, 0.1959899951600319, 0.8928062956813705, 0.8885101227838129, 0.2114133042651002, 0.12715050342539502, 0.8808848169049247, 0.8718992583926525, 0.8785476611774873, 0.11242704144210913, 0.21201877049823847, 0.8849673179637949, 0.17528274532041754, 0.1853025018023684, 0.17426857824796427, 0.17782657677935165, 0.19751364544798222, 0.18737231976815616, 0.18453828508616588, 0.18248395785719929, 0.17898453296326355, 0.08355777475143, 0.08859460771684824, 0.08623748489910399, 0.09735601926411164, 0.0861360781654048, 0.0916391129443247, 0.09864278601989662, 0.08696780970523377, 0.10445690646801886]}, "mutation_prompt": null}
{"id": "771fb731-3cb6-4e3a-b86f-b7a4d4e59eec", "solution": "import numpy as np\n\nclass DynamicAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r3 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.25) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.2 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.1)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.2, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "DynamicAdaptiveParticleSwarmDifferentialEvolution", "description": "Dynamic Adaptive Particle Swarm Differential Evolution employs dynamic strategies and local search to optimize exploration-exploitation balance.", "configspace": "", "generation": 85, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "0ec4e18c-410f-48a0-8a39-7151f583cb20", "metadata": {"aucs": [0.8707552494565642, 0.8453857177296805, 0.8623216073123912, 0.8639634056205705, 0.860099406349679, 0.8765174814497569, 0.8574743244522545, 0.8558868606726054, 0.87297939341506, 0.7243729322766688, 0.7331840983305267, 0.7220534101984792, 0.7316274859765667, 0.734434232045909, 0.726943189241064, 0.7389493800862412, 0.7526491230898371, 0.7496230539109217, 0.14494066531034655, 0.1260310369963652, 0.13363165815580758, 0.13656971948914964, 0.17245596692931942, 0.15228446972629084, 0.13785917119357016, 0.1369681543633291, 0.1524411975979474, 0.07882027010243253, 0.1157336015662298, 0.12469434414749281, 0.12430200556196269, 0.13555589423269487, 0.11192004459858984, 0.12290745343359466, 0.14904815610898026, 0.10688078686123359, 0.968249677894721, 0.9772663867970012, 0.9778758482228881, 0.9830873440225228, 0.9612499851513675, 0.9671818449284495, 0.9684787420177051, 0.9868214437712359, 0.9718264198671591, 0.7266296741462954, 0.7231018159776667, 0.6949995481763922, 0.738085022610898, 0.7064418940142774, 0.72886420980048, 0.7247044208631245, 0.6820075932404472, 0.7237320667654852, 0.8889510554235082, 0.8816723795674369, 0.8896767473708151, 0.8999055714252742, 0.8904310488792816, 0.8722480198087406, 0.8902907316435267, 0.8947735778872629, 0.885630701450423, 0.6522705391983059, 0.6396509138050408, 0.65788385787317, 0.6392396591299647, 0.7202315397186358, 0.7507300145542418, 0.6930813144060535, 0.7060236235599336, 0.6554280567624197, 0.6395047770464868, 0.5912344806137912, 0.12988641864205197, 0.13222183110374097, 0.5374343117404403, 0.6582447752644696, 0.7304697336121762, 0.6157800079661135, 0.7104617994108302, 0.6578571762029488, 0.6609281527995889, 0.6084481734086952, 0.7250661553036244, 0.6998779743383048, 0.6796466514523587, 0.6912951776686628, 0.7058957198460697, 0.700930299790764, 0.7300449550701393, 0.7709624834156741, 0.7937846326013281, 0.7421038947879264, 0.7460148921041905, 0.7611930142413965, 0.741383589891443, 0.7711436316377749, 0.7640024393528514, 0.4182890877230897, 0.3488717723555458, 0.4202567499230495, 0.6175511496335404, 0.5354779306659578, 0.19828393285960733, 0.4341778847791218, 0.31169520831594855, 0.3324317372262441, 0.4967644453504897, 0.5507301825814768, 0.5213158374566962, 0.4994451948750871, 0.5328573024564888, 0.5578406699962606, 0.5182051736168617, 0.5108456449603405, 0.48419920307059205, 0.8160980527822864, 0.8029268481675572, 0.8330611624500153, 0.8263296430974616, 0.8092117917243724, 0.8315556622905507, 0.8345334255592145, 0.822294151875024, 0.8247913382984053, 0.09996607996813967, 0.11597393724833416, 0.15334154838465253, 0.12143860356566616, 0.11922040926559807, 0.11911777261936385, 0.1471017595243167, 0.5107190186554396, 0.17354245431647364, 0.37999127090536444, 0.1959338999755188, 0.22233099803734901, 0.6763421834113561, 0.38093870383574835, 0.24138388399900945, 0.2717857201886088, 0.6935884395716501, 0.564348400882545, 0.5198106381301248, 0.5274366719374128, 0.3980289724992785, 0.6314193292976384, 0.6164366058993498, 0.5845124121773961, 0.6144871051743697, 0.6375936206327149, 0.5035390505886337, 0.4631007382131883, 0.5086290946176593, 0.5700676672608216, 0.45349408801434166, 0.4766267396155416, 0.42971592823317795, 0.5711807553424265, 0.4608043389130705, 0.5723349634620165, 0.21791126614710632, 0.22243575957716855, 0.20677090455654767, 0.21896518288064126, 0.2135292491854932, 0.22335470042502237, 0.19424742861151778, 0.1961981253978462, 0.21810544943312404, 0.24611418745647118, 0.24792900207793134, 0.23867523844372762, 0.21393137468343948, 0.18084056898952972, 0.2199252569256832, 0.2058751406724868, 0.19683508736966737, 0.21574099518016532, 0.2088247798466023, 0.16709920932745403, 0.15336743790932172, 0.18574873977443995, 0.20022519715365938, 0.1664555255328074, 0.89059662737315, 0.8972969316983, 0.8964320504610284, 0.21026105643516801, 0.8453090195917459, 0.0734976032789576, 0.8635436347232608, 0.8771258538056363, 0.8676376175098057, 0.2121102145973519, 0.21019341609088615, 0.8838516077056169, 0.18441294677706688, 0.1915610751451593, 0.18984002850805493, 0.19297474307803764, 0.18571810491647744, 0.1918504373926455, 0.1823499551186153, 0.19257187393718556, 0.18897600049054308, 0.09039187977345942, 0.08237653213176999, 0.08269842917301917, 0.08791316722357656, 0.11725787216782357, 0.0951670606162166, 0.08525913252279005, 0.09331166200076768, 0.09509613704557729]}, "mutation_prompt": null}
{"id": "3fceebbe-72ed-4647-8ab0-50a7f8ce5296", "solution": "import numpy as np\n\nclass HybridAdaptivePSODE:\n    def __init__(self, budget, dim, pop_size=60, F_base=0.9, CR_base=0.85, inertia_weight=0.6):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.4 + (0.6 * (evaluations / self.budget)))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.6:\n                    F_dynamic = self.F_base + 0.4 * (np.random.rand() - 0.2) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.25 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                a, b, c = population[indices]\n                mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.25 * (np.random.rand() - 0.125)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.3, self.dim) + 0.15 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridAdaptivePSODE", "description": "Hybridized Particle Swarm and Differential Evolution with adaptive parameter tuning and enhanced local search for robust optimization.", "configspace": "", "generation": 89, "fitness": 0.48609381150626685, "feedback": "The algorithm HybridAdaptivePSODE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.28.", "error": "", "parent_id": "0ec4e18c-410f-48a0-8a39-7151f583cb20", "metadata": {"aucs": [0.8416529946260599, 0.8205274581226167, 0.8366031410647173, 0.8464446160344113, 0.8440652700837624, 0.839221248070242, 0.8446037255495505, 0.8374441728434906, 0.8310900494003259, 0.7091826908290332, 0.6993247606480407, 0.6993227822192385, 0.7077413629665998, 0.7065035553454989, 0.7130158061170034, 0.696416275072649, 0.7181241691615992, 0.6942200468855216, 0.11143523450395809, 0.153543147872237, 0.12340831107907946, 0.12945508107002557, 0.15522331435138115, 0.1710559811744362, 0.12192117356980359, 0.11592045736920209, 0.42710970465118203, 0.11462767935782414, 0.11770097217873865, 0.10523369674325189, 0.12067498842652569, 0.10569566937936781, 0.10456124088107277, 0.10536224180797615, 0.10479317143383937, 0.10812361218563149, 0.9635099326189468, 0.978906789760114, 0.9705538008428968, 0.9771819627088609, 0.9591708157387451, 0.9843021715909639, 0.9605498711920039, 0.9784125559871166, 0.9751431000794604, 0.696770162712205, 0.6987892067146891, 0.6834534794664386, 0.7041832623558992, 0.6906640818207957, 0.6500747743411399, 0.6756344377816816, 0.6751412874716105, 0.6860377072167219, 0.840031647841579, 0.8637982044530861, 0.8634573545971048, 0.8679290081865726, 0.8463088449568974, 0.8616480169058934, 0.8190764925551668, 0.8579055301723449, 0.8457489532932064, 0.5448085715435136, 0.6342458044331994, 0.5809065243649186, 0.5647104995330327, 0.6604552965027646, 0.6455253497732514, 0.612855173963537, 0.589855894283899, 0.6268966473113142, 0.6183201671835682, 0.6012018003959654, 0.5462652884761905, 0.6448415831554045, 0.6046990135486625, 0.5041786313556109, 0.1286088840254761, 0.7150311186636484, 0.5635869225712877, 0.6678988590228856, 0.5872337348371178, 0.6243828907977044, 0.6077606500473419, 0.6737637554253832, 0.6378872377331238, 0.5938744940733492, 0.61813368470582, 0.6336783685809321, 0.7260816778483072, 0.7136389163929725, 0.7114110448068802, 0.7194038874622245, 0.71561387296547, 0.6896346166257524, 0.7070943453210777, 0.714396935562684, 0.7099079717052996, 0.20472424629252284, 0.16314873530999086, 0.10220787069245196, 0.36429646382944125, 0.46020973140036425, 0.5484503039075932, 0.3867387446546918, 0.29762682061923673, 0.4045084398844325, 0.49278653114802784, 0.4937779980061465, 0.49059926795235365, 0.5101826531411915, 0.488597138381495, 0.5122417799540773, 0.47376986526572895, 0.47844523484937407, 0.49354512627429936, 0.7903762604748772, 0.7892352228901021, 0.7888656949187616, 0.8016651346529823, 0.7923327895131386, 0.7788426760997594, 0.7846974222646803, 0.7805653153215918, 0.7979561979428516, 0.5396155102328517, 0.16715581898244525, 0.13344572058921966, 0.12278291240180006, 0.12233835429765572, 0.11417902015834969, 0.15250537848597434, 0.6488087853178631, 0.15657687816080723, 0.3978055971779165, 0.1671705339530134, 0.3178187136572309, 0.24712806366787676, 0.5804855725179013, 0.3487615417362554, 0.5039014865847644, 0.4446369566468372, 0.20546826958297482, 0.5783484414247841, 0.48897562401419903, 0.6082906001052756, 0.5979411739233371, 0.5730713439395934, 0.6099709859784219, 0.5662526619760441, 0.6200032857606355, 0.5787158154139902, 0.49393858745475405, 0.5032972093025423, 0.4632400861462673, 0.38629901858701243, 0.4515613969328022, 0.47126973053562493, 0.5103766625675785, 0.4875275141073261, 0.5269374253793049, 0.2042291994229779, 0.2430153931037603, 0.2046810272601146, 0.21470338397879973, 0.2090681235927383, 0.23164595922163012, 0.20392427285139947, 0.23204320038386594, 0.22174919144430383, 0.21452261843233478, 0.6039626418398516, 0.23454916512799273, 0.23611077202020048, 0.21568657179460393, 0.21268081902815816, 0.21685939584676295, 0.21892637721007524, 0.21933580070443415, 0.17109311398309124, 0.18505220776575493, 0.8789680480975685, 0.8470906981778461, 0.19688990183814659, 0.8464622518061107, 0.17548700333865397, 0.2059260048993048, 0.8473052305897564, 0.8632185181086687, 0.20926016997345476, 0.1669892311303205, 0.16645395125787343, 0.16614362269883642, 0.8490800025484185, 0.2130563976058466, 0.211186979101186, 0.21167104713181584, 0.17529068103966006, 0.17570679089322805, 0.1785460318651465, 0.2041818566017798, 0.1772542081121583, 0.19322492245227296, 0.19411390946418505, 0.1928212640856325, 0.19173122131514697, 0.10789765746957258, 0.08125585082252784, 0.09060862860390284, 0.07882860276355963, 0.08298806750184173, 0.09507597969524795, 0.09069555907297777, 0.09322107375610489, 0.09227297174103766]}, "mutation_prompt": null}
{"id": "f87dd7f6-6d11-4730-ac0b-40014109c2e8", "solution": "import numpy as np\n\nclass HybridParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r3 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.25) * np.exp(-fitness[i])\n                else:\n                    F_dynamic = self.F_base + 0.1 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.05)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.15 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridParticleSwarmDifferentialEvolution", "description": "The Hybrid Particle Swarm Differential Evolution Algorithm enhances convergence by incorporating adaptive particle dynamics and local search strategies.", "configspace": "", "generation": 90, "fitness": 0.46153765142956127, "feedback": "The algorithm HybridParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "0ec4e18c-410f-48a0-8a39-7151f583cb20", "metadata": {"aucs": [0.8796362936009324, 0.8604622887956148, 0.8639663191460348, 0.860240950445315, 0.871955951607652, 0.8730279240817471, 0.8145131120859865, 0.8143153905641282, 0.8202787340176877, 0.7053387246849425, 0.6518043515534684, 0.6532696820254306, 0.6327240490944943, 0.6963646058963703, 0.6886945351157782, 0.7161911718135843, 0.6840559472916119, 0.6609596522320588, 0.11081369065361757, 0.10348412579823485, 0.11586298258721928, 0.1640054142175088, 0.1443356076963901, 0.14436198781941745, 0.1754981357293709, 0.15295511111826054, 0.1348069863037593, 0.11784951864700666, 0.07550402705022352, 0.1032542154948809, 0.11858036807319117, 0.10147596079806476, 0.1504457855888468, 0.13906265166089704, 0.08938126650876166, 0.10534891881764286, 0.9809391851734162, 0.9534314198922126, 0.9630857691145281, 0.9691018714250281, 0.9772630639660336, 0.9631849476209944, 0.9849482275806121, 0.9844827841092083, 0.9784977379535583, 0.7300907851922711, 0.7207855504810758, 0.7361554677624126, 0.7456392905784157, 0.7346523669104998, 0.7402821163278259, 0.5422940795137827, 0.5240419518963388, 0.5225942172786365, 0.8809473188674188, 0.8829305930637532, 0.8708297984938586, 0.8918755802446272, 0.27630610228788377, 0.8539370666211243, 0.8891688133799399, 0.9046854336230878, 0.8726828043769512, 0.757390289215784, 0.6991993578159169, 0.618180876653238, 0.4281451084991049, 0.13015345699471748, 0.38900460973352136, 0.648395140555792, 0.6993893529254354, 0.7601739196312015, 0.5929667742347646, 0.7800641498332326, 0.7379272736501226, 0.6475915235197296, 0.5554746731197466, 0.7543401628748357, 0.6487871479108795, 0.6905891999461427, 0.6811060349692046, 0.4673079931495845, 0.6101109930531309, 0.424131498535006, 0.35289156312362546, 0.717824644446364, 0.683648087807888, 0.40873301609529566, 0.5433071521950306, 0.4853789268742075, 0.7359706447269269, 0.7446990439383967, 0.7601962202822001, 0.6743968354639676, 0.6576845352166212, 0.6205218137265983, 0.7636251826347134, 0.7709525681009282, 0.7531562976221117, 0.06345156739728353, 0.07868733353467905, 0.1355242673173238, 0.1978256103313467, 0.24952421386705215, 0.4061254547137535, 0.1688299449556323, 0.3085099321533157, 0.42461194017604365, 0.5126536998661053, 0.5159499428606537, 0.550785428324704, 0.3576052590398754, 0.4080600002405559, 0.3883389674550387, 0.36440481354832377, 0.3731628108689149, 0.33762980621681205, 0.714462506318525, 0.7359340511174635, 0.716997084416394, 0.7233722064175317, 0.7382873801910986, 0.7447585265416773, 0.8454850387023884, 0.8251966700447246, 0.824027466521231, 0.13423678091195035, 0.1386610477189517, 0.128690036617774, 0.14979086576698886, 0.1684940117692484, 0.14133193784172582, 0.1304622862401721, 0.1285376255789471, 0.15350753542471574, 0.6852066482689125, 0.15164115248617582, 0.7142987460841218, 0.22944835228550076, 0.14264949977316532, 0.124244692385172, 0.3239694663376569, 0.484801280920911, 0.6610357352884333, 0.45583888351205126, 0.30482866745081294, 0.45761260491923916, 0.5726080867188432, 0.5984450346293951, 0.6376096736380505, 0.5514614894242063, 0.6382479244351115, 0.6114623514042129, 0.44551351518171634, 0.35690049417400027, 0.3082300440906852, 0.539032373419357, 0.5603800254384005, 0.4694604110380053, 0.5519252413507378, 0.282403387495024, 0.2958033096475531, 0.22520345242554407, 0.2148403630012815, 0.19866940071783912, 0.20404648092839694, 0.2402146444095674, 0.22614927302622967, 0.25970779962569535, 0.22337326075090025, 0.224022258690606, 0.18997437970408426, 0.20052805213263836, 0.20578005765428697, 0.2167208830200048, 0.20562342448818216, 0.22325720017649642, 0.20616524094590005, 0.1972863362770909, 0.20724031491967165, 0.1640171609981349, 0.1877920251991667, 0.1534271989514897, 0.1763501179818895, 0.19958628095243014, 0.16727802385752844, 0.15000241977361872, 0.17065545531933535, 0.8249614409640533, 0.8318233130129361, 0.2101250576109005, 0.21019930994076852, 0.8827734401593132, 0.8819719983202117, 0.8763272850027127, 0.2094093254859618, 0.21183871789790698, 0.21058959105513564, 0.20166382499948488, 0.19677584430528927, 0.18437896486200667, 0.1836852413486868, 0.17661243253009906, 0.20929894621421852, 0.17657069581310791, 0.17554819381391318, 0.17274067079924482, 0.0952968574211811, 0.08758979539031131, 0.10848115803768343, 0.08033199025628723, 0.08677544966756978, 0.10087441770112748, 0.0869110882196712, 0.08412443993478869, 0.09449171785869326]}, "mutation_prompt": null}
{"id": "4cd7c304-832e-43f5-a4c5-29638825fe67", "solution": "import numpy as np\n\nclass DynamicAdaptiveParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                F_dynamic = self.F_base + 0.2 * (np.random.randn() if np.random.rand() < 0.5 else np.random.rand() - 0.25)\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.1 * (np.random.randn() if np.random.rand() < 0.5 else np.random.rand() - 0.1)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 4) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.05 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "DynamicAdaptiveParticleSwarmDifferentialEvolution", "description": "Dynamic Adaptive Particle Swarm Differential Evolution with Stochastic Local Search combines exploration-exploitation dynamics with stochastic local search enhancements for robust optimization.", "configspace": "", "generation": 91, "fitness": 0.4794127475293932, "feedback": "The algorithm DynamicAdaptiveParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "0ec4e18c-410f-48a0-8a39-7151f583cb20", "metadata": {"aucs": [0.8682596022276208, 0.8556580213944425, 0.8694301107807983, 0.872786975554861, 0.8716771961698985, 0.8798760326677283, 0.8562543285039552, 0.8650200080563356, 0.8742376347189822, 0.7110169884442008, 0.754148350319556, 0.7546349066462431, 0.7381102908129962, 0.7213208347034752, 0.7389524416788656, 0.7419794935117209, 0.7599205591237814, 0.7429726607948581, 0.16077365266614907, 0.1403857374788906, 0.1394745755882565, 0.16858586126961694, 0.13931719407810184, 0.14352699132014035, 0.13396154435809382, 0.18012465505520325, 0.12777541529047343, 0.10423792209438032, 0.12330981981895439, 0.1066636134045309, 0.1386886059997574, 0.09793970818167363, 0.13278441220619097, 0.11307462774888155, 0.12176112352324875, 0.13702770273066256, 0.9754134359366526, 0.9596971520335109, 0.9757873562557526, 0.9717534895183871, 0.9744717522763905, 0.9760091699934104, 0.9762864873920272, 0.932904238237388, 0.9715354826406987, 0.7389949109918432, 0.7230231733441382, 0.7174240499927247, 0.7197541996344186, 0.7305358710935368, 0.7324586132664391, 0.6882057549263305, 0.7536119534686017, 0.6899532315871344, 0.8784431371644204, 0.22722895822874267, 0.8790387288561868, 0.8868112407669992, 0.8958284469023021, 0.8856567364962326, 0.8815639108123849, 0.8786150329848734, 0.8737718535169962, 0.5665351196206421, 0.5327648746129279, 0.5807282161132696, 0.6242788973590492, 0.612787330262049, 0.6555079640463455, 0.13168580479660452, 0.6199364511678273, 0.5976641078191229, 0.6346536079834731, 0.6053507555578579, 0.6221516722824264, 0.6560538372171086, 0.46433266249142235, 0.6819428282610973, 0.6465583508576741, 0.6973265348610751, 0.5483848352824332, 0.6617448186177849, 0.5645155964552052, 0.6746208679471193, 0.3432730248775926, 0.6586832322473772, 0.647456660332866, 0.6635006294187777, 0.6808785670306536, 0.6933220312858859, 0.6967614322502765, 0.747702369221324, 0.7477133934881334, 0.7349304285895648, 0.7245922824840476, 0.6879782022044464, 0.7275165041896443, 0.7514032277869175, 0.7330887166291449, 0.1152822970204117, 0.3824544921213665, 0.3637809032495871, 0.23175824254353627, 0.249360506498415, 0.45065834429024176, 0.2289379240365731, 0.1389488393165208, 0.27565311257249847, 0.5193822739199614, 0.49613413203069556, 0.4935301239227008, 0.5257369508114325, 0.5075607536512214, 0.4789129650551348, 0.500109534775099, 0.49133692622157643, 0.5017652728412245, 0.8115064887745018, 0.8208970192896271, 0.8122145999977775, 0.8137627212745906, 0.8050703173908413, 0.8238350672806658, 0.8362578088267296, 0.8278661450749071, 0.8437329164611987, 0.12633412406721234, 0.12561243497410557, 0.15497122085189863, 0.1568783711897448, 0.14191155301483527, 0.12585679988466858, 0.14709844587796528, 0.1415887594891061, 0.15596428021356146, 0.16649911991946809, 0.20601792901859295, 0.22611949901409112, 0.2047574092470007, 0.2589867061670399, 0.6318550643502702, 0.6302627800809982, 0.4126999393977556, 0.3413500165380289, 0.5520263076297923, 0.4723070748894228, 0.6193113392372295, 0.5232549787106731, 0.5808225679164862, 0.5752280852860727, 0.5699397063136148, 0.6130332656013311, 0.6091263123437729, 0.3073220742113624, 0.4925828329776648, 0.49929212100675824, 0.2131268717917928, 0.2283963589630149, 0.5019268015236711, 0.5747734921250506, 0.5309109936871873, 0.5090488715332349, 0.21332611441778515, 0.2359963898300611, 0.24564081978991692, 0.2336554874144946, 0.2168872686650628, 0.20826969241744386, 0.2226131403185464, 0.21329679288279435, 0.22591693010346914, 0.2465266719441317, 0.22040147598146753, 0.19714549796674996, 0.2176085395045625, 0.24578494715681432, 0.7172264674935841, 0.24214056201954848, 0.20482676282939694, 0.21747511940569075, 0.17204430120365954, 0.184476278160271, 0.1534294765165678, 0.925574172133977, 0.1994448711735315, 0.198251653575519, 0.1765659535126477, 0.16322821522323339, 0.8995582746189578, 0.8996353922676115, 0.21113387392444571, 0.12699762177577867, 0.8772258209467005, 0.2090073201417172, 0.15372589111720658, 0.2123479627670456, 0.8786722693688253, 0.21304228707719253, 0.19003554614216744, 0.19253807967889536, 0.18710285957384876, 0.17740989576566446, 0.17624654296062348, 0.19334755187335828, 0.18368029665347585, 0.19577108912325403, 0.18822333216007814, 0.08076124343598856, 0.09785692863466067, 0.09173454888039467, 0.08309282108869609, 0.08729062299928503, 0.08969715438253456, 0.09983786225627866, 0.09431138499598424, 0.09270039891259763]}, "mutation_prompt": null}
{"id": "169dc41d-eb10-4d98-9c31-a7ed3b1f969b", "solution": "import numpy as np\n\nclass HybridPSO_DE_AdaptiveDisturbance:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2, r3 = np.random.rand(), np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.3 + (evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))  # Changed r3 to r2 for better global influence\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.3 * np.random.randn()  # Increased variance for exploration\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.05)  # Reduced variance for stability\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.15, self.dim) + 0.15 * velocities[local_search_idx]  # Adaptive perturbation\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridPSO_DE_AdaptiveDisturbance", "description": "Hybrid Particle Swarm and Differential Evolution with Adaptive Disturbance to enhance exploration and convergence.", "configspace": "", "generation": 92, "fitness": 0.51476965269306, "feedback": "The algorithm HybridPSO_DE_AdaptiveDisturbance got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.", "error": "", "parent_id": "0ec4e18c-410f-48a0-8a39-7151f583cb20", "metadata": {"aucs": [0.8863068195708131, 0.8914343802163085, 0.8884664080089372, 0.8849705476923182, 0.8924444172763054, 0.9034464449226786, 0.886324473071355, 0.8812240239055001, 0.8797651331270239, 0.7960941160315385, 0.7922451272512598, 0.7662680231519511, 0.7649194813918558, 0.7869650675663232, 0.7721650572538795, 0.7755407983123576, 0.7610571527209538, 0.7694456718601231, 0.1407357360300744, 0.175781350470971, 0.759878259909956, 0.1524918157636328, 0.1301390772819352, 0.12438542033378419, 0.1358911961531698, 0.15687972558534236, 0.17882347321041092, 0.12199137403352267, 0.11202633307274901, 0.09512368016375383, 0.10334915106004539, 0.13505537069634288, 0.13630208381913667, 0.1243072043475909, 0.12636751062755525, 0.12256157379663823, 0.9838972248394545, 0.9453755166880825, 0.9557079590852995, 0.9684718392099986, 0.9684429357667471, 0.9792553563793462, 0.9754891619570413, 0.9750054812775634, 0.9897702695279921, 0.7563275883564607, 0.7743521299055429, 0.785176986254511, 0.7751880450964874, 0.7725372991265873, 0.779545365423619, 0.7769708145718001, 0.743554941983529, 0.7845950397041543, 0.9100334130872, 0.9037120659505979, 0.8850930854511825, 0.9178120271679422, 0.896471777306974, 0.8695218620119307, 0.9079554988649909, 0.8955346621225877, 0.2341902776575563, 0.69155676627705, 0.7043511571430987, 0.7207917054827218, 0.6245669497893656, 0.8107306332659433, 0.6340461123972073, 0.6556125925754768, 0.7240620069143962, 0.6168681539661265, 0.6169424713073756, 0.6360722920564637, 0.6267319839480362, 0.7202253999295014, 0.7402141932297597, 0.6764180873192833, 0.7983492091273493, 0.13203450797585425, 0.6225941711098616, 0.7167857708376975, 0.7151833187143826, 0.6154636543924276, 0.7502562032201494, 0.7562474805460461, 0.7606494945014726, 0.734243884658857, 0.7567009566352789, 0.7397039132146638, 0.810961761961692, 0.7779270713510054, 0.809518622204034, 0.7353034635979909, 0.7646709569537741, 0.7838799290084504, 0.8121894366409598, 0.7510427158319046, 0.8028792348433834, 0.16919067520710307, 0.2771574712134818, 0.3056594237845599, 0.6000616842369294, 0.549992028966489, 0.6435836414964367, 0.1970504491631394, 0.24407795042325364, 0.2984563353232744, 0.6432278231426971, 0.6412002726135884, 0.6306398414402613, 0.6383549000191626, 0.6750345598081593, 0.6626886454194294, 0.5954769957167457, 0.6122871394286997, 0.6351334121316687, 0.8352184455638939, 0.8605391508055146, 0.86556956320416, 0.8615449106222275, 0.8508218274255566, 0.861085378212882, 0.8639818689266513, 0.8563551119281712, 0.8597985743273256, 0.14931552696190542, 0.15103575946649384, 0.15495149760774507, 0.17458782376257787, 0.10919128741776152, 0.157419895619488, 0.1547642565642502, 0.1324792110669608, 0.09022105855797802, 0.6859993642073934, 0.4962947346977339, 0.7236020549995497, 0.2718172707188454, 0.32835498694198517, 0.6223495394695959, 0.2859413202039055, 0.5161475294045943, 0.29450029462775795, 0.6788266247148835, 0.35107978307826293, 0.7282570811901695, 0.7116613910797769, 0.6814706545052425, 0.7210549706615972, 0.6351655737737026, 0.5449703671415816, 0.7097100265746463, 0.26722251285502274, 0.6339837720486878, 0.39369461304589126, 0.5472381324012845, 0.4746457254726021, 0.4869142107220781, 0.34356977753465456, 0.6583637749591913, 0.639803928869006, 0.22707429184455696, 0.2156809865541952, 0.2064178497900404, 0.20583432383545852, 0.2052955004572845, 0.20912929647102962, 0.2085461532610995, 0.20828687834602355, 0.23026297134052653, 0.24916280519215805, 0.24903464569138134, 0.2153785444093762, 0.22415891175121982, 0.24348652815400906, 0.220139673664684, 0.21912694099243768, 0.24764115416440757, 0.779700706224961, 0.18657749592377704, 0.17721134466536825, 0.15396940616908927, 0.16755063644343082, 0.19993574733924357, 0.1607195689478178, 0.18727469032509603, 0.1424755619425001, 0.17265889872375628, 0.9056192357710884, 0.21184417112121323, 0.07350956585591162, 0.21017164244128062, 0.8543246615962318, 0.1674011626542713, 0.1678943774978876, 0.15532938541016506, 0.9045803690201235, 0.1960549826163871, 0.1773940412966356, 0.17558625828919816, 0.1834645015844638, 0.19351018847135215, 0.18957130754932106, 0.1941186949461292, 0.19383060441375466, 0.1870806854320769, 0.08816572418871549, 0.0846924177001811, 0.0901847943305264, 0.08413979863212862, 0.0952892526682686, 0.12441169936425522, 0.08380047820543057, 0.08528082418875438, 0.0925298629617004]}, "mutation_prompt": null}
{"id": "a1d0d704-28df-4b3b-94d5-03b0b21c4a4f", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (0.5 * evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.6 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.4 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.15 * (np.random.rand() - 0.075)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.2 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO and DE with Dynamic Selection Pressure and Adaptive Local Search for Improved Optimization.", "configspace": "", "generation": 93, "fitness": 0.5273567071326899, "feedback": "The algorithm EnhancedHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.31.", "error": "", "parent_id": "169dc41d-eb10-4d98-9c31-a7ed3b1f969b", "metadata": {"aucs": [0.8894814735986282, 0.8869292462598771, 0.8835990537879354, 0.8808761700086606, 0.8826422373408565, 0.8723546890549371, 0.8885248159740713, 0.8761131982296039, 0.8820354212831367, 0.7756710109659977, 0.7523833357244716, 0.7756012818899434, 0.761826947020919, 0.7822210103186568, 0.7359137821786348, 0.7840322642116533, 0.7671519993400255, 0.7411299543270917, 0.12542390330737685, 0.1413218274175484, 0.15478931732618495, 0.11021323143209849, 0.15459769424710235, 0.14069050440429132, 0.11072835110224166, 0.10810523336256206, 0.15521350400438683, 0.1073053588818359, 0.10585085361930235, 0.13764024736145242, 0.09142953345036675, 0.09730250165217946, 0.11228485820444001, 0.12704379747552974, 0.10663054025826746, 0.1054176656706044, 0.9800120089479953, 0.9840695139977038, 0.9776650182824518, 0.9735621871491856, 0.9769582233023212, 0.9820686614014941, 0.9753203012223953, 0.9712915174418523, 0.9635334626764802, 0.7830178672373305, 0.7675107960366389, 0.7598028576137772, 0.7789047980620551, 0.7660276169502476, 0.7849699024135044, 0.7561825383844087, 0.7626051712287706, 0.7737797499431258, 0.9008837192995497, 0.8915105885384306, 0.8863924969052845, 0.9235240427664632, 0.9070425764735475, 0.9094203429890774, 0.9061162796166163, 0.8931691505495691, 0.9064736500565077, 0.6530302222854829, 0.7178604301071037, 0.7429643053402687, 0.6270886586423197, 0.7012022417040391, 0.6671643692952345, 0.7190260006231515, 0.7317934892483391, 0.6661863181803622, 0.7784797148970428, 0.6193970890689642, 0.7404499797427917, 0.7677089715662702, 0.7044920277242245, 0.13151039660109565, 0.7394159434133856, 0.6686791174914817, 0.6930747358489691, 0.7401501931673595, 0.7110151896614179, 0.7381614350005541, 0.7144268901464549, 0.6948687076504284, 0.6421205298513163, 0.6566738124218284, 0.7597798569549137, 0.7505321737596615, 0.7963591868424073, 0.7725129365824384, 0.8127518715309563, 0.7858398249638436, 0.7860117092221117, 0.7672309122411363, 0.7886493456125588, 0.8025835665530496, 0.7748533347682005, 0.22764168825609188, 0.4425795886240652, 0.47736612428693903, 0.6450564119660036, 0.6495390538052048, 0.6717615241694935, 0.1593008505029937, 0.3418101798556732, 0.45788923374912127, 0.6011609889204712, 0.5799932259918792, 0.5867510041692823, 0.6511097275896913, 0.6825525498973755, 0.6213502785328608, 0.6426881034590344, 0.6613277799593564, 0.6678592779282659, 0.8397922102301489, 0.8579500308750353, 0.842319101593168, 0.8626676086279824, 0.8500740435904356, 0.8467830444318247, 0.8669072250711225, 0.8450595376612391, 0.8534588557742541, 0.1405751617471902, 0.15144964405775152, 0.1301392126152654, 0.15787327148371444, 0.15358079088773824, 0.15101421691617556, 0.1297381198705061, 0.18349043039134172, 0.11206946611272961, 0.5890018035113218, 0.22637596537933713, 0.397480363246723, 0.6255672038523795, 0.6721319886125638, 0.6841712130725108, 0.2520957391385499, 0.17707891569408662, 0.6844507271890863, 0.42766173681504116, 0.7280152625986699, 0.4312054529977861, 0.6281066837982723, 0.5273486791672362, 0.7011595998473661, 0.58762064229366, 0.7138606890824555, 0.7134065113427084, 0.4402567002279688, 0.2273936231712036, 0.5358230862115817, 0.6311042255012329, 0.6164592410189045, 0.3971564200881226, 0.6616752484284959, 0.43895595832367384, 0.4997190735809969, 0.26048388984616233, 0.20540173022629893, 0.22782753468587935, 0.21206399028543688, 0.21235964976430421, 0.2304081926867806, 0.22988451430450374, 0.2117971242584854, 0.20911909605334034, 0.2426381630289397, 0.22412926765480856, 0.8240649301664714, 0.18506657802821413, 0.21687321365588386, 0.2443949208592615, 0.19404951272550863, 0.21309947855398537, 0.20687775769054684, 0.1655811003021025, 0.15263651404613887, 0.15370990099898374, 0.1774877587970246, 0.2003906229428204, 0.9036823982754058, 0.8929288417667147, 0.17795640990768147, 0.1577948065163428, 0.9067047250583656, 0.21122631784361412, 0.9127017276388902, 0.9088099530629011, 0.16746649933683033, 0.8933451520693617, 0.1046062888108672, 0.10469682591586515, 0.16710401183952384, 0.19602312058303328, 0.19201778367601596, 0.1983949939613806, 0.1903106662017774, 0.1950629734382493, 0.17419679299530122, 0.17607241184098388, 0.233629497723279, 0.17775848543846773, 0.09288760724245582, 0.10486754764117445, 0.09273954503593163, 0.1002028214813081, 0.09064938371306397, 0.13265277277226795, 0.09206613095229554, 0.09588492462978515, 0.08996222104580087]}, "mutation_prompt": null}
{"id": "06fc1fd7-bd28-41f3-b790-ae7889dd7a84", "solution": "import numpy as np\n\nclass HybridSwarmOptimization:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.4 + (0.6 * evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.4 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.3 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.1 * (np.random.rand() - 0.05)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.5 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.05, self.dim) + 0.1 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "HybridSwarmOptimization", "description": "Hybrid Swarm Optimization with Adaptive Learning and Dynamic Mutation for Enhanced Convergence", "configspace": "", "generation": 94, "fitness": 0.518008363060003, "feedback": "The algorithm HybridSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.31.", "error": "", "parent_id": "a1d0d704-28df-4b3b-94d5-03b0b21c4a4f", "metadata": {"aucs": [0.9027427338159356, 0.8916769278333919, 0.8907139987971947, 0.897295552043196, 0.8853849399835765, 0.88399345825191, 0.8948252143191389, 0.8728150013743572, 0.8795723393563133, 0.7941323362881608, 0.7866304755799579, 0.7862407668115716, 0.7935541639565807, 0.8014713746799174, 0.7797920046597822, 0.7568386692033794, 0.7886758327412493, 0.7884227129250861, 0.7669352439798837, 0.15254728205859047, 0.11715539057466628, 0.1777967178878096, 0.09884409456541254, 0.11290675181662069, 0.1846352553390701, 0.14318964065061623, 0.14131539407745808, 0.18025805058797395, 0.09246600501876223, 0.11498015517976068, 0.09548949230530857, 0.11247368908442335, 0.10807785513587409, 0.10677985516151989, 0.120733879156255, 0.11357981492976543, 0.9850690622603382, 0.957653618547111, 0.9811110390158546, 0.9738193709325882, 0.9881542167228342, 0.9653339547878195, 0.960004358627105, 0.9538757764642681, 0.971036083474579, 0.8065247118200025, 0.7607964467726113, 0.7658156433889145, 0.7916923472291022, 0.7788854108386285, 0.7776550649847803, 0.7758033386136471, 0.7871309086506603, 0.7919798653746847, 0.9173170520254609, 0.8930203304183537, 0.9010106680361148, 0.9267951256098523, 0.2789173046087947, 0.9048056568472268, 0.8946926636340936, 0.9029288571149731, 0.8893651196696488, 0.7482039229405271, 0.6341230548747921, 0.7578104388162499, 0.6452423022786533, 0.6754765268892187, 0.1301708122797498, 0.7662788270365822, 0.5523594635445138, 0.6400946768146949, 0.1341036644756337, 0.7391823633990289, 0.7540946237464731, 0.13374652561778133, 0.625621913088519, 0.1318713896380388, 0.7390983906505166, 0.6915019937763098, 0.7388981242596808, 0.6281883586702008, 0.6320334439439843, 0.7423021933177922, 0.7594675949773027, 0.7184049804454387, 0.5797834754333085, 0.696550980499377, 0.7203986867953891, 0.7271039167005766, 0.8320081924124667, 0.7734576143196694, 0.8147364243337027, 0.8154164017797467, 0.7984775578769521, 0.7189763458782592, 0.8192517234549859, 0.8191510196747773, 0.7933045904524985, 0.3020285810142417, 0.17890622237448806, 0.20717012841286508, 0.637504007842145, 0.6100833111341513, 0.27220874331126166, 0.42785873727153223, 0.40974874613907686, 0.1560424291033864, 0.675568919960193, 0.6437482389778076, 0.6631874665949984, 0.6619955322519284, 0.6302098097501379, 0.6530889177227003, 0.6644306129973642, 0.6529790729040426, 0.65195541402134, 0.8719679355869713, 0.8628157389643486, 0.8470342009590404, 0.8474358474903374, 0.8468112615081994, 0.851076556354732, 0.8637496459417071, 0.8458442729201503, 0.839107297484803, 0.10732641986858982, 0.11255718796601744, 0.15660462081294968, 0.15886137605674444, 0.12908536501931833, 0.12683652261593747, 0.1553133364164725, 0.13715572686580613, 0.16011850876058764, 0.347221461886428, 0.2782252398134397, 0.6860425753806332, 0.7990441896519479, 0.2257322495062014, 0.7337137714270998, 0.39001126284267096, 0.2155252599444848, 0.6405532885031002, 0.5768250935831094, 0.6913438400627112, 0.7231073042969594, 0.711669720625375, 0.6797149554306126, 0.7171907991971851, 0.5781278811278798, 0.4946333037155266, 0.7258981209530984, 0.47857376340125324, 0.27253162115159746, 0.6482623919892337, 0.2964668819984905, 0.5737281108327772, 0.34737139207967216, 0.38795480358638346, 0.25263237964192364, 0.3486627761986748, 0.24889707865351895, 0.23918393567295948, 0.1977220650940753, 0.20046691361077107, 0.21664645251634407, 0.24114848862805927, 0.2081541738286532, 0.22952428279520487, 0.20123602552388098, 0.18696444075193142, 0.2007999986369121, 0.2202610437613114, 0.19059992239880452, 0.7661740080144475, 0.2469813175046841, 0.22488984794479694, 0.22828376963817343, 0.20621074669733697, 0.9190384715015096, 0.18377214028515798, 0.15354612642737597, 0.17790085929240163, 0.19965406102738248, 0.1998959390496361, 0.9089721280507548, 0.8529441277997666, 0.8743163395556269, 0.9181388471451162, 0.2119212558036211, 0.8878533506648465, 0.9092455249024808, 0.20754867376122388, 0.15378462046183017, 0.12747822221997107, 0.1561187847408415, 0.10455315048553859, 0.19552871210364986, 0.17284381669378235, 0.18190402203918665, 0.1925096986039666, 0.18761830938600887, 0.19107289467784971, 0.17520479369750397, 0.1843670539217539, 0.19178240316299333, 0.08481883634829823, 0.10239986961015624, 0.09099804813380363, 0.09351391460208447, 0.0876172456741906, 0.08798469910982354, 0.10930422886972813, 0.10361320793011763, 0.09368679765002363]}, "mutation_prompt": null}
{"id": "acff72a8-1e4f-495e-8ce2-e0584852b07d", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (0.5 * evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.6 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.4 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.15 * (np.random.rand() - 0.075)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.2 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO and DE with Dynamic Selection Pressure and Adaptive Local Search for Improved Optimization.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a1d0d704-28df-4b3b-94d5-03b0b21c4a4f", "metadata": {"aucs": [0.8894814735986282, 0.8869292462598771, 0.8835990537879354, 0.8808761700086606, 0.8826422373408565, 0.8723546890549371, 0.8885248159740713, 0.8761131982296039, 0.8820354212831367, 0.7756710109659977, 0.7523833357244716, 0.7756012818899434, 0.761826947020919, 0.7822210103186568, 0.7359137821786348, 0.7840322642116533, 0.7671519993400255, 0.7411299543270917, 0.12542390330737685, 0.1413218274175484, 0.15478931732618495, 0.11021323143209849, 0.15459769424710235, 0.14069050440429132, 0.11072835110224166, 0.10810523336256206, 0.15521350400438683, 0.1073053588818359, 0.10585085361930235, 0.13764024736145242, 0.09142953345036675, 0.09730250165217946, 0.11228485820444001, 0.12704379747552974, 0.10663054025826746, 0.1054176656706044, 0.9800120089479953, 0.9840695139977038, 0.9776650182824518, 0.9735621871491856, 0.9769582233023212, 0.9820686614014941, 0.9753203012223953, 0.9712915174418523, 0.9635334626764802, 0.7830178672373305, 0.7675107960366389, 0.7598028576137772, 0.7789047980620551, 0.7660276169502476, 0.7849699024135044, 0.7561825383844087, 0.7626051712287706, 0.7737797499431258, 0.9008837192995497, 0.8915105885384306, 0.8863924969052845, 0.9235240427664632, 0.9070425764735475, 0.9094203429890774, 0.9061162796166163, 0.8931691505495691, 0.9064736500565077, 0.6530302222854829, 0.7178604301071037, 0.7429643053402687, 0.6270886586423197, 0.7012022417040391, 0.6671643692952345, 0.7190260006231515, 0.7317934892483391, 0.6661863181803622, 0.7784797148970428, 0.6193970890689642, 0.7404499797427917, 0.7677089715662702, 0.7044920277242245, 0.13151039660109565, 0.7394159434133856, 0.6686791174914817, 0.6930747358489691, 0.7401501931673595, 0.7110151896614179, 0.7381614350005541, 0.7144268901464549, 0.6948687076504284, 0.6421205298513163, 0.6566738124218284, 0.7597798569549137, 0.7505321737596615, 0.7963591868424073, 0.7725129365824384, 0.8127518715309563, 0.7858398249638436, 0.7860117092221117, 0.7672309122411363, 0.7886493456125588, 0.8025835665530496, 0.7748533347682005, 0.22764168825609188, 0.4425795886240652, 0.47736612428693903, 0.6450564119660036, 0.6495390538052048, 0.6717615241694935, 0.1593008505029937, 0.3418101798556732, 0.45788923374912127, 0.6011609889204712, 0.5799932259918792, 0.5867510041692823, 0.6511097275896913, 0.6825525498973755, 0.6213502785328608, 0.6426881034590344, 0.6613277799593564, 0.6678592779282659, 0.8397922102301489, 0.8579500308750353, 0.842319101593168, 0.8626676086279824, 0.8500740435904356, 0.8467830444318247, 0.8669072250711225, 0.8450595376612391, 0.8534588557742541, 0.1405751617471902, 0.15144964405775152, 0.1301392126152654, 0.15787327148371444, 0.15358079088773824, 0.15101421691617556, 0.1297381198705061, 0.18349043039134172, 0.11206946611272961, 0.5890018035113218, 0.22637596537933713, 0.397480363246723, 0.6255672038523795, 0.6721319886125638, 0.6841712130725108, 0.2520957391385499, 0.17707891569408662, 0.6844507271890863, 0.42766173681504116, 0.7280152625986699, 0.4312054529977861, 0.6281066837982723, 0.5273486791672362, 0.7011595998473661, 0.58762064229366, 0.7138606890824555, 0.7134065113427084, 0.4402567002279688, 0.2273936231712036, 0.5358230862115817, 0.6311042255012329, 0.6164592410189045, 0.3971564200881226, 0.6616752484284959, 0.43895595832367384, 0.4997190735809969, 0.26048388984616233, 0.20540173022629893, 0.22782753468587935, 0.21206399028543688, 0.21235964976430421, 0.2304081926867806, 0.22988451430450374, 0.2117971242584854, 0.20911909605334034, 0.2426381630289397, 0.22412926765480856, 0.8240649301664714, 0.18506657802821413, 0.21687321365588386, 0.2443949208592615, 0.19404951272550863, 0.21309947855398537, 0.20687775769054684, 0.1655811003021025, 0.15263651404613887, 0.15370990099898374, 0.1774877587970246, 0.2003906229428204, 0.9036823982754058, 0.8929288417667147, 0.17795640990768147, 0.1577948065163428, 0.9067047250583656, 0.21122631784361412, 0.9127017276388902, 0.9088099530629011, 0.16746649933683033, 0.8933451520693617, 0.1046062888108672, 0.10469682591586515, 0.16710401183952384, 0.19602312058303328, 0.19201778367601596, 0.1983949939613806, 0.1903106662017774, 0.1950629734382493, 0.17419679299530122, 0.17607241184098388, 0.233629497723279, 0.17775848543846773, 0.09288760724245582, 0.10486754764117445, 0.09273954503593163, 0.1002028214813081, 0.09064938371306397, 0.13265277277226795, 0.09206613095229554, 0.09588492462978515, 0.08996222104580087]}, "mutation_prompt": null}
{"id": "66d23a7c-bd26-4bc3-bf07-948ec504ac21", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (0.5 * evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.6 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.4 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.15 * (np.random.rand() - 0.075)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.2 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO and DE with Dynamic Selection Pressure and Adaptive Local Search for Improved Optimization.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a1d0d704-28df-4b3b-94d5-03b0b21c4a4f", "metadata": {"aucs": [0.8894814735986282, 0.8869292462598771, 0.8835990537879354, 0.8808761700086606, 0.8826422373408565, 0.8723546890549371, 0.8885248159740713, 0.8761131982296039, 0.8820354212831367, 0.7756710109659977, 0.7523833357244716, 0.7756012818899434, 0.761826947020919, 0.7822210103186568, 0.7359137821786348, 0.7840322642116533, 0.7671519993400255, 0.7411299543270917, 0.12542390330737685, 0.1413218274175484, 0.15478931732618495, 0.11021323143209849, 0.15459769424710235, 0.14069050440429132, 0.11072835110224166, 0.10810523336256206, 0.15521350400438683, 0.1073053588818359, 0.10585085361930235, 0.13764024736145242, 0.09142953345036675, 0.09730250165217946, 0.11228485820444001, 0.12704379747552974, 0.10663054025826746, 0.1054176656706044, 0.9800120089479953, 0.9840695139977038, 0.9776650182824518, 0.9735621871491856, 0.9769582233023212, 0.9820686614014941, 0.9753203012223953, 0.9712915174418523, 0.9635334626764802, 0.7830178672373305, 0.7675107960366389, 0.7598028576137772, 0.7789047980620551, 0.7660276169502476, 0.7849699024135044, 0.7561825383844087, 0.7626051712287706, 0.7737797499431258, 0.9008837192995497, 0.8915105885384306, 0.8863924969052845, 0.9235240427664632, 0.9070425764735475, 0.9094203429890774, 0.9061162796166163, 0.8931691505495691, 0.9064736500565077, 0.6530302222854829, 0.7178604301071037, 0.7429643053402687, 0.6270886586423197, 0.7012022417040391, 0.6671643692952345, 0.7190260006231515, 0.7317934892483391, 0.6661863181803622, 0.7784797148970428, 0.6193970890689642, 0.7404499797427917, 0.7677089715662702, 0.7044920277242245, 0.13151039660109565, 0.7394159434133856, 0.6686791174914817, 0.6930747358489691, 0.7401501931673595, 0.7110151896614179, 0.7381614350005541, 0.7144268901464549, 0.6948687076504284, 0.6421205298513163, 0.6566738124218284, 0.7597798569549137, 0.7505321737596615, 0.7963591868424073, 0.7725129365824384, 0.8127518715309563, 0.7858398249638436, 0.7860117092221117, 0.7672309122411363, 0.7886493456125588, 0.8025835665530496, 0.7748533347682005, 0.22764168825609188, 0.4425795886240652, 0.47736612428693903, 0.6450564119660036, 0.6495390538052048, 0.6717615241694935, 0.1593008505029937, 0.3418101798556732, 0.45788923374912127, 0.6011609889204712, 0.5799932259918792, 0.5867510041692823, 0.6511097275896913, 0.6825525498973755, 0.6213502785328608, 0.6426881034590344, 0.6613277799593564, 0.6678592779282659, 0.8397922102301489, 0.8579500308750353, 0.842319101593168, 0.8626676086279824, 0.8500740435904356, 0.8467830444318247, 0.8669072250711225, 0.8450595376612391, 0.8534588557742541, 0.1405751617471902, 0.15144964405775152, 0.1301392126152654, 0.15787327148371444, 0.15358079088773824, 0.15101421691617556, 0.1297381198705061, 0.18349043039134172, 0.11206946611272961, 0.5890018035113218, 0.22637596537933713, 0.397480363246723, 0.6255672038523795, 0.6721319886125638, 0.6841712130725108, 0.2520957391385499, 0.17707891569408662, 0.6844507271890863, 0.42766173681504116, 0.7280152625986699, 0.4312054529977861, 0.6281066837982723, 0.5273486791672362, 0.7011595998473661, 0.58762064229366, 0.7138606890824555, 0.7134065113427084, 0.4402567002279688, 0.2273936231712036, 0.5358230862115817, 0.6311042255012329, 0.6164592410189045, 0.3971564200881226, 0.6616752484284959, 0.43895595832367384, 0.4997190735809969, 0.26048388984616233, 0.20540173022629893, 0.22782753468587935, 0.21206399028543688, 0.21235964976430421, 0.2304081926867806, 0.22988451430450374, 0.2117971242584854, 0.20911909605334034, 0.2426381630289397, 0.22412926765480856, 0.8240649301664714, 0.18506657802821413, 0.21687321365588386, 0.2443949208592615, 0.19404951272550863, 0.21309947855398537, 0.20687775769054684, 0.1655811003021025, 0.15263651404613887, 0.15370990099898374, 0.1774877587970246, 0.2003906229428204, 0.9036823982754058, 0.8929288417667147, 0.17795640990768147, 0.1577948065163428, 0.9067047250583656, 0.21122631784361412, 0.9127017276388902, 0.9088099530629011, 0.16746649933683033, 0.8933451520693617, 0.1046062888108672, 0.10469682591586515, 0.16710401183952384, 0.19602312058303328, 0.19201778367601596, 0.1983949939613806, 0.1903106662017774, 0.1950629734382493, 0.17419679299530122, 0.17607241184098388, 0.233629497723279, 0.17775848543846773, 0.09288760724245582, 0.10486754764117445, 0.09273954503593163, 0.1002028214813081, 0.09064938371306397, 0.13265277277226795, 0.09206613095229554, 0.09588492462978515, 0.08996222104580087]}, "mutation_prompt": null}
{"id": "93f6976c-1a58-44aa-b6b1-c55e7ee78b09", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (0.5 * evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.6 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.4 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.15 * (np.random.rand() - 0.075)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.2 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO and DE with Dynamic Selection Pressure and Adaptive Local Search for Improved Optimization.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a1d0d704-28df-4b3b-94d5-03b0b21c4a4f", "metadata": {"aucs": [0.8894814735986282, 0.8869292462598771, 0.8835990537879354, 0.8808761700086606, 0.8826422373408565, 0.8723546890549371, 0.8885248159740713, 0.8761131982296039, 0.8820354212831367, 0.7756710109659977, 0.7523833357244716, 0.7756012818899434, 0.761826947020919, 0.7822210103186568, 0.7359137821786348, 0.7840322642116533, 0.7671519993400255, 0.7411299543270917, 0.12542390330737685, 0.1413218274175484, 0.15478931732618495, 0.11021323143209849, 0.15459769424710235, 0.14069050440429132, 0.11072835110224166, 0.10810523336256206, 0.15521350400438683, 0.1073053588818359, 0.10585085361930235, 0.13764024736145242, 0.09142953345036675, 0.09730250165217946, 0.11228485820444001, 0.12704379747552974, 0.10663054025826746, 0.1054176656706044, 0.9800120089479953, 0.9840695139977038, 0.9776650182824518, 0.9735621871491856, 0.9769582233023212, 0.9820686614014941, 0.9753203012223953, 0.9712915174418523, 0.9635334626764802, 0.7830178672373305, 0.7675107960366389, 0.7598028576137772, 0.7789047980620551, 0.7660276169502476, 0.7849699024135044, 0.7561825383844087, 0.7626051712287706, 0.7737797499431258, 0.9008837192995497, 0.8915105885384306, 0.8863924969052845, 0.9235240427664632, 0.9070425764735475, 0.9094203429890774, 0.9061162796166163, 0.8931691505495691, 0.9064736500565077, 0.6530302222854829, 0.7178604301071037, 0.7429643053402687, 0.6270886586423197, 0.7012022417040391, 0.6671643692952345, 0.7190260006231515, 0.7317934892483391, 0.6661863181803622, 0.7784797148970428, 0.6193970890689642, 0.7404499797427917, 0.7677089715662702, 0.7044920277242245, 0.13151039660109565, 0.7394159434133856, 0.6686791174914817, 0.6930747358489691, 0.7401501931673595, 0.7110151896614179, 0.7381614350005541, 0.7144268901464549, 0.6948687076504284, 0.6421205298513163, 0.6566738124218284, 0.7597798569549137, 0.7505321737596615, 0.7963591868424073, 0.7725129365824384, 0.8127518715309563, 0.7858398249638436, 0.7860117092221117, 0.7672309122411363, 0.7886493456125588, 0.8025835665530496, 0.7748533347682005, 0.22764168825609188, 0.4425795886240652, 0.47736612428693903, 0.6450564119660036, 0.6495390538052048, 0.6717615241694935, 0.1593008505029937, 0.3418101798556732, 0.45788923374912127, 0.6011609889204712, 0.5799932259918792, 0.5867510041692823, 0.6511097275896913, 0.6825525498973755, 0.6213502785328608, 0.6426881034590344, 0.6613277799593564, 0.6678592779282659, 0.8397922102301489, 0.8579500308750353, 0.842319101593168, 0.8626676086279824, 0.8500740435904356, 0.8467830444318247, 0.8669072250711225, 0.8450595376612391, 0.8534588557742541, 0.1405751617471902, 0.15144964405775152, 0.1301392126152654, 0.15787327148371444, 0.15358079088773824, 0.15101421691617556, 0.1297381198705061, 0.18349043039134172, 0.11206946611272961, 0.5890018035113218, 0.22637596537933713, 0.397480363246723, 0.6255672038523795, 0.6721319886125638, 0.6841712130725108, 0.2520957391385499, 0.17707891569408662, 0.6844507271890863, 0.42766173681504116, 0.7280152625986699, 0.4312054529977861, 0.6281066837982723, 0.5273486791672362, 0.7011595998473661, 0.58762064229366, 0.7138606890824555, 0.7134065113427084, 0.4402567002279688, 0.2273936231712036, 0.5358230862115817, 0.6311042255012329, 0.6164592410189045, 0.3971564200881226, 0.6616752484284959, 0.43895595832367384, 0.4997190735809969, 0.26048388984616233, 0.20540173022629893, 0.22782753468587935, 0.21206399028543688, 0.21235964976430421, 0.2304081926867806, 0.22988451430450374, 0.2117971242584854, 0.20911909605334034, 0.2426381630289397, 0.22412926765480856, 0.8240649301664714, 0.18506657802821413, 0.21687321365588386, 0.2443949208592615, 0.19404951272550863, 0.21309947855398537, 0.20687775769054684, 0.1655811003021025, 0.15263651404613887, 0.15370990099898374, 0.1774877587970246, 0.2003906229428204, 0.9036823982754058, 0.8929288417667147, 0.17795640990768147, 0.1577948065163428, 0.9067047250583656, 0.21122631784361412, 0.9127017276388902, 0.9088099530629011, 0.16746649933683033, 0.8933451520693617, 0.1046062888108672, 0.10469682591586515, 0.16710401183952384, 0.19602312058303328, 0.19201778367601596, 0.1983949939613806, 0.1903106662017774, 0.1950629734382493, 0.17419679299530122, 0.17607241184098388, 0.233629497723279, 0.17775848543846773, 0.09288760724245582, 0.10486754764117445, 0.09273954503593163, 0.1002028214813081, 0.09064938371306397, 0.13265277277226795, 0.09206613095229554, 0.09588492462978515, 0.08996222104580087]}, "mutation_prompt": null}
{"id": "8d729075-6065-46c3-a19e-7c7990e45871", "solution": "import numpy as np\n\nclass AdvancedAdaptiveHybridPSO_DE:\n    def __init__(self, budget, dim, pop_size=60, F_base=0.9, CR_base=0.85, inertia_weight=0.9):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.9 * (1 - evaluations / self.budget) + 0.4)\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.5 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.3 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.2 * (np.random.rand() - 0.1)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 2) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.15, self.dim) + 0.3 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "AdvancedAdaptiveHybridPSO_DE", "description": "Advanced Adaptive Hybrid PSO-DE with Nonlinear Time-Varying Parameters and Stochastic Local Search.", "configspace": "", "generation": 98, "fitness": 0.22865543949874872, "feedback": "The algorithm AdvancedAdaptiveHybridPSO_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "a1d0d704-28df-4b3b-94d5-03b0b21c4a4f", "metadata": {"aucs": [0.4551832935782588, 0.46135438767333714, 0.47849284166187567, 0.4965489547547366, 0.5006501317459224, 0.4858632258838663, 0.4919617698523958, 0.483873734233793, 0.46269666381855146, 0.19695938375135935, 0.11666870654441464, 0.10075629273508258, 0.18240384633707285, 0.17532614932141422, 0.16950614171155154, 0.1882534695462441, 0.18970720572828992, 0.1689225944360926, 0.0971568054596722, 0.1116958965058864, 0.08612857296007803, 0.0820386205867153, 0.08433576632010631, 0.07372172812567301, 0.09465378645266742, 0.08920145388243439, 0.08533217407901195, 0.06658319005574354, 0.06628699917407688, 0.07650575937803072, 0.07764863142825018, 0.07082703102034682, 0.07222911269190169, 0.05855920381177615, 0.08488175993727287, 0.08072225484586248, 0.97474389837805, 0.9870358849864983, 0.9804414560274821, 0.9703577357007986, 0.9734974337723307, 0.9709364236980641, 0.9815133876796264, 0.9804419194870057, 0.9754240447944267, 0.25199882718709665, 0.249626174833109, 0.27493837032080515, 0.21845738693551042, 0.12234437189423897, 0.27775869734604763, 0.2698092463495756, 0.24802380452292205, 0.2460448176726442, 0.36126335315535585, 0.4195811325007849, 0.4450549644975438, 0.4474498482839303, 0.1713952506632619, 0.4271427380180236, 0.38723485298537663, 0.4713216002568159, 0.4735707793912014, 0.08506350074805069, 0.15237584431172313, 0.16206666938013115, 0.061455956802998535, 0.12897035281289393, 0.12302468502740449, 0.16015455985422045, 0.2168314104673924, 0.15987325228860483, 0.07825252593619769, 0.08627973428623104, 0.10120560937732137, 0.1866862616123961, 0.14131959449712872, 0.17862792550051987, 0.14700622167407928, 0.07119241402906717, 0.17327209007581168, 0.0821235831892334, 0.02855722619588652, 0.05107568715073596, 0.02398105030847586, 0.0014940372283179792, 0.11437321582252158, 0.10291428178984674, 0.0893565308317733, 0.06454380330910081, 0.11690985826356826, 0.14911453158344723, 0.10827032338333897, 0.1827106391136063, 0.1482497419050547, 0.12613207477188992, 0.15454149256034655, 0.16280739417251677, 0.1700499729560614, 0.020011608144391957, 0.03777902773980568, 0.019591314664306414, 0.028675193190199955, 0.03754470566388213, 0.03742759162986553, 0.052530450027587716, 0.03878130865662843, 0.038530916924889747, 0.12873149010173768, 0.11809840758458812, 0.13974018579877134, 0.14552848249101114, 0.12906242138335144, 0.14805593071884737, 0.11923336415767682, 0.08134295290109861, 0.13364359085157573, 0.395957341309656, 0.45285401311456364, 0.4148441104188956, 0.40273178722131475, 0.41799285491821414, 0.4392251293647039, 0.39916001501417353, 0.40825584435926043, 0.4183501270710628, 0.08141476756570087, 0.10305241736644166, 0.057638169377570714, 0.08308441714472281, 0.08723585609174511, 0.09611937347705302, 0.08914350368093948, 0.08215937829164399, 0.11466385182341787, 0.16800165287033908, 0.15060458632638674, 0.14895906799288172, 0.17912163278584736, 0.15787811674116825, 0.16583022931519487, 0.1873404762174521, 0.14389186235922802, 0.19313435170848203, 0.2889978993828808, 0.27884783831597193, 0.2913061532631155, 0.2837471757610984, 0.29097801805944423, 0.2566423400908471, 0.2918303879583354, 0.28342764864922343, 0.30402380611975954, 0.22102523452469836, 0.21899182082085367, 0.21576722666737502, 0.2110008237993215, 0.2113495288652384, 0.22409838792390624, 0.2261536079117975, 0.2375732283852987, 0.21316060294387984, 0.17957769975446358, 0.1756985447067747, 0.1832816914818559, 0.20086205019652492, 0.18438501016321107, 0.17849236944908065, 0.17351951461171444, 0.17512506592022214, 0.18322911487246818, 0.27900043804876873, 0.17200429844635712, 0.17191984275446082, 0.16465427752524775, 0.17934163469290065, 0.22916234353436016, 0.1726021278070886, 0.16576583380609466, 0.2065150166816323, 0.6000619169042098, 0.14246756286222084, 0.5401446805986174, 0.15515717845768062, 0.16780993899881358, 0.15989672437484603, 0.43938473233731057, 0.16501260310496368, 0.45155891408081705, 0.48881424319411537, 0.39096138219233467, 0.1845154537837218, 0.4599407435059155, 0.4218974446828886, 0.17371173460456046, 0.19980049609828288, 0.1983990258449173, 0.1973354767495602, 0.1860847120893928, 0.18132146256635873, 0.17841138735376605, 0.18864277085332004, 0.19317522931463393, 0.2015321077766804, 0.17784960535172378, 0.1878036173210309, 0.19662000634994892, 0.06259410303037916, 0.06882228004457447, 0.07499151162614903, 0.06380717590881291, 0.07775493152588353, 0.07211702896334704, 0.07034448505699387, 0.07734256650976079, 0.06456722267046533]}, "mutation_prompt": null}
{"id": "59645897-c4dd-464f-b65c-6308ca2a1eb8", "solution": "import numpy as np\n\nclass EnhancedHybridPSO_DE:\n    def __init__(self, budget, dim, pop_size=50, F_base=0.8, CR_base=0.9, inertia_weight=0.7):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = pop_size\n        self.F_base = F_base\n        self.CR_base = CR_base\n        self.inertia_weight = inertia_weight\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n        fitness = np.apply_along_axis(func, 1, population)\n        velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        personal_best_positions = population.copy()\n        personal_best_fitness = fitness.copy()\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx].copy()\n\n        evaluations = self.pop_size\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                r1, r2 = np.random.rand(), np.random.rand()\n                inertia_dynamic = self.inertia_weight * (0.5 + (0.5 * evaluations / self.budget))\n                velocities[i] = (inertia_dynamic * velocities[i] +\n                                 r1 * (personal_best_positions[i] - population[i]) +\n                                 r2 * (global_best - population[i]))\n\n                population[i] = np.clip(population[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < 0.5:\n                    F_dynamic = self.F_base + 0.6 * (np.random.rand() - 0.5) * (personal_best_fitness[i] / (fitness[i] + 1e-8))\n                else:\n                    F_dynamic = self.F_base + 0.4 * np.random.randn()\n\n                indices = np.random.choice(self.pop_size, 3, replace=False)\n                x0, x1, x2 = population[indices]\n                mutant = np.clip(x0 + F_dynamic * (x1 - x2), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = self.CR_base + 0.15 * (np.random.rand() - 0.075)\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n\n                trial = np.where(cross_points, mutant, population[i])\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < personal_best_fitness[i]:\n                        personal_best_positions[i] = trial\n                        personal_best_fitness[i] = trial_fitness\n                        if trial_fitness < fitness[global_best_idx]:\n                            global_best_idx = i\n                            global_best = trial.copy()\n\n                if evaluations >= self.budget:\n                    break\n\n                if np.random.rand() < 0.6 and evaluations % (self.pop_size // 3) == 0:\n                    local_search_idx = np.random.choice(self.pop_size)\n                    local_solution = population[local_search_idx]\n                    perturbation = np.random.normal(0, 0.1, self.dim) + 0.2 * velocities[local_search_idx]\n                    local_mutant = np.clip(local_solution + perturbation, self.lower_bound, self.upper_bound)\n                    local_fitness = func(local_mutant)\n                    evaluations += 1\n                    if local_fitness < fitness[local_search_idx]:\n                        population[local_search_idx] = local_mutant\n                        fitness[local_search_idx] = local_fitness\n                        if local_fitness < fitness[global_best_idx]:\n                            global_best_idx = local_search_idx\n                            global_best = local_mutant.copy()\n\n        return global_best", "name": "EnhancedHybridPSO_DE", "description": "Enhanced Hybrid PSO and DE with Dynamic Selection Pressure and Adaptive Local Search for Improved Optimization.", "configspace": "", "generation": 94, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "a1d0d704-28df-4b3b-94d5-03b0b21c4a4f", "metadata": {"aucs": [0.8894814735986282, 0.8869292462598771, 0.8835990537879354, 0.8808761700086606, 0.8826422373408565, 0.8723546890549371, 0.8885248159740713, 0.8761131982296039, 0.8820354212831367, 0.7756710109659977, 0.7523833357244716, 0.7756012818899434, 0.761826947020919, 0.7822210103186568, 0.7359137821786348, 0.7840322642116533, 0.7671519993400255, 0.7411299543270917, 0.12542390330737685, 0.1413218274175484, 0.15478931732618495, 0.11021323143209849, 0.15459769424710235, 0.14069050440429132, 0.11072835110224166, 0.10810523336256206, 0.15521350400438683, 0.1073053588818359, 0.10585085361930235, 0.13764024736145242, 0.09142953345036675, 0.09730250165217946, 0.11228485820444001, 0.12704379747552974, 0.10663054025826746, 0.1054176656706044, 0.9800120089479953, 0.9840695139977038, 0.9776650182824518, 0.9735621871491856, 0.9769582233023212, 0.9820686614014941, 0.9753203012223953, 0.9712915174418523, 0.9635334626764802, 0.7830178672373305, 0.7675107960366389, 0.7598028576137772, 0.7789047980620551, 0.7660276169502476, 0.7849699024135044, 0.7561825383844087, 0.7626051712287706, 0.7737797499431258, 0.9008837192995497, 0.8915105885384306, 0.8863924969052845, 0.9235240427664632, 0.9070425764735475, 0.9094203429890774, 0.9061162796166163, 0.8931691505495691, 0.9064736500565077, 0.6530302222854829, 0.7178604301071037, 0.7429643053402687, 0.6270886586423197, 0.7012022417040391, 0.6671643692952345, 0.7190260006231515, 0.7317934892483391, 0.6661863181803622, 0.7784797148970428, 0.6193970890689642, 0.7404499797427917, 0.7677089715662702, 0.7044920277242245, 0.13151039660109565, 0.7394159434133856, 0.6686791174914817, 0.6930747358489691, 0.7401501931673595, 0.7110151896614179, 0.7381614350005541, 0.7144268901464549, 0.6948687076504284, 0.6421205298513163, 0.6566738124218284, 0.7597798569549137, 0.7505321737596615, 0.7963591868424073, 0.7725129365824384, 0.8127518715309563, 0.7858398249638436, 0.7860117092221117, 0.7672309122411363, 0.7886493456125588, 0.8025835665530496, 0.7748533347682005, 0.22764168825609188, 0.4425795886240652, 0.47736612428693903, 0.6450564119660036, 0.6495390538052048, 0.6717615241694935, 0.1593008505029937, 0.3418101798556732, 0.45788923374912127, 0.6011609889204712, 0.5799932259918792, 0.5867510041692823, 0.6511097275896913, 0.6825525498973755, 0.6213502785328608, 0.6426881034590344, 0.6613277799593564, 0.6678592779282659, 0.8397922102301489, 0.8579500308750353, 0.842319101593168, 0.8626676086279824, 0.8500740435904356, 0.8467830444318247, 0.8669072250711225, 0.8450595376612391, 0.8534588557742541, 0.1405751617471902, 0.15144964405775152, 0.1301392126152654, 0.15787327148371444, 0.15358079088773824, 0.15101421691617556, 0.1297381198705061, 0.18349043039134172, 0.11206946611272961, 0.5890018035113218, 0.22637596537933713, 0.397480363246723, 0.6255672038523795, 0.6721319886125638, 0.6841712130725108, 0.2520957391385499, 0.17707891569408662, 0.6844507271890863, 0.42766173681504116, 0.7280152625986699, 0.4312054529977861, 0.6281066837982723, 0.5273486791672362, 0.7011595998473661, 0.58762064229366, 0.7138606890824555, 0.7134065113427084, 0.4402567002279688, 0.2273936231712036, 0.5358230862115817, 0.6311042255012329, 0.6164592410189045, 0.3971564200881226, 0.6616752484284959, 0.43895595832367384, 0.4997190735809969, 0.26048388984616233, 0.20540173022629893, 0.22782753468587935, 0.21206399028543688, 0.21235964976430421, 0.2304081926867806, 0.22988451430450374, 0.2117971242584854, 0.20911909605334034, 0.2426381630289397, 0.22412926765480856, 0.8240649301664714, 0.18506657802821413, 0.21687321365588386, 0.2443949208592615, 0.19404951272550863, 0.21309947855398537, 0.20687775769054684, 0.1655811003021025, 0.15263651404613887, 0.15370990099898374, 0.1774877587970246, 0.2003906229428204, 0.9036823982754058, 0.8929288417667147, 0.17795640990768147, 0.1577948065163428, 0.9067047250583656, 0.21122631784361412, 0.9127017276388902, 0.9088099530629011, 0.16746649933683033, 0.8933451520693617, 0.1046062888108672, 0.10469682591586515, 0.16710401183952384, 0.19602312058303328, 0.19201778367601596, 0.1983949939613806, 0.1903106662017774, 0.1950629734382493, 0.17419679299530122, 0.17607241184098388, 0.233629497723279, 0.17775848543846773, 0.09288760724245582, 0.10486754764117445, 0.09273954503593163, 0.1002028214813081, 0.09064938371306397, 0.13265277277226795, 0.09206613095229554, 0.09588492462978515, 0.08996222104580087]}, "mutation_prompt": null}
