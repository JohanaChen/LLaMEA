{"id": "d5e41046-36a3-42df-8635-b29e5fa063b6", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.5]  # Start with equal probability for strategies\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:  # Evaluate only if not yet evaluated\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def optimize(self, func):\n        evaluations = 0\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    # Update strategy probabilities\n                    self.strategy_probs = [0.6, 0.4] if strategy == 'rand_1_bin' else [0.4, 0.6]\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive population-based differential evolution algorithm with dynamic search strategy selection enhances exploration and exploitation balance for diverse optimization landscapes.", "configspace": "", "generation": 0, "fitness": 0.34772104757373123, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7431911540658249, 0.7257526485543081, 0.7282201968095441, 0.746096566671677, 0.7657427386300143, 0.7317573554446218, 0.7442883195301883, 0.7413902461913198, 0.7459981418724346, 0.549968199619685, 0.537593032132111, 0.5718610398710802, 0.5428901625233047, 0.5274067253409231, 0.5528965537057933, 0.5503484673298166, 0.540850449324892, 0.5675904215778892, 0.10082137542868985, 0.09821857149346291, 0.09527115754090187, 0.10074590938512917, 0.10421444098736188, 0.09869160196189963, 0.10483773232481874, 0.11740548530627215, 0.11376857518892391, 0.10752674548194152, 0.10393299043256743, 0.09185487013281946, 0.09909275186483646, 0.11538503647490883, 0.12398033489720006, 0.0984057463515533, 0.09438452174075007, 0.09891327567612429, 0.9812606161397334, 0.9760798229829546, 0.9533589238376101, 0.9559726839688362, 0.9715440217828678, 0.9759380125219769, 0.9828557671673216, 0.9903400132948077, 0.9718283763142558, 0.38936838027243525, 0.4559503744076886, 0.39146571780890915, 0.4314533922596123, 0.39794767475225423, 0.3971989211085014, 0.4346714981778612, 0.41608715688641984, 0.42406613111958447, 0.7262596208081593, 0.7183050930458468, 0.6914827239513797, 0.7353918608643406, 0.6848751769511494, 0.701766648971317, 0.6571347315185875, 0.7672757966916536, 0.717736429963155, 0.42042514060095315, 0.3675663294323893, 0.41528064962710365, 0.3360211864487159, 0.4078946755099043, 0.39971005464508147, 0.3859981248964087, 0.34227115993792456, 0.3329888754014201, 0.3457809866588659, 0.3043135552487978, 0.41634207987336735, 0.37186597343912386, 0.4043487506173139, 0.39734214331339335, 0.4205371083524013, 0.3854907531368835, 0.3722930101130755, 0.25806347079873704, 0.3071332168812205, 0.31713297317840283, 0.2607409104319688, 0.21105003025247826, 0.2885702814056351, 0.2942488102546237, 0.261502627068657, 0.30925626007470863, 0.44296818930289306, 0.4668529368263564, 0.44281392143447873, 0.39964610498157704, 0.40488185200882376, 0.40234752152567477, 0.45827090584374397, 0.46366892737867893, 0.39467706255798607, 0.13505663208923047, 0.09048345269316271, 0.09620883247306689, 0.11686376110490604, 0.09480871290381054, 0.1484956415604669, 0.08037441857984484, 0.12105020862184335, 0.12337651039504782, 0.24085105186279465, 0.23867739337710914, 0.24869547177518547, 0.27325427246438794, 0.2690990021666727, 0.2629685732830729, 0.24978421768517545, 0.25118875560555676, 0.2518285804895769, 0.625607259545236, 0.5955979800383995, 0.6303792232291634, 0.6533261186488764, 0.6297651068825114, 0.5991771201982798, 0.6554118728341782, 0.6154645836986807, 0.607920897393194, 0.08918579756178224, 0.09112445138467284, 0.09520699014098677, 0.09526455370572207, 0.0924378253856335, 0.09831733375241236, 0.08476179941163786, 0.08939775560161956, 0.09720972258479943, 0.1361259998090485, 0.1636621222527248, 0.15598609514327144, 0.13313905832832318, 0.1521955776920244, 0.13829072462414427, 0.16744685769771772, 0.14978483962631106, 0.13999182238825558, 0.3451496434796699, 0.3620298988738666, 0.35539472377868875, 0.3440066888136306, 0.32123735723801905, 0.343640028977483, 0.34569105567350633, 0.3569482355111516, 0.3464793900429788, 0.2567706383331835, 0.2839355535043836, 0.2677582584619298, 0.26549714265199176, 0.26384841160152384, 0.25850048432034267, 0.2961288411850296, 0.29037434079014735, 0.275735257723827, 0.17836637805716982, 0.20691960199540438, 0.17774769121118572, 0.18741611129075242, 0.195783727243935, 0.20468335641901536, 0.19927914997480034, 0.19409610483029405, 0.17933122413856872, 0.17629037482173715, 0.25507918101888394, 0.18328415770977713, 0.16916043132164071, 0.1931474282129555, 0.2065120822264096, 0.22446943232804328, 0.18062516775776205, 0.17657508340145744, 0.18679618304926326, 0.6795014469676423, 0.7043666411645926, 0.16087914379088974, 0.18989385094441613, 0.6822906305082248, 0.6419682250648655, 0.1935139905773572, 0.4964142795640003, 0.7006084649330646, 0.20702888204612047, 0.2008016374185203, 0.16162769878413363, 0.20049688759847673, 0.1846128028988856, 0.7427552135147658, 0.5720843371459366, 0.1959302973946948, 0.1808092243997378, 0.18844483140829638, 0.17946165192783992, 0.17546171780929676, 0.17441575078542082, 0.17845104638359266, 0.18087623798680186, 0.1799134688040982, 0.17202587626107924, 0.07444980451138727, 0.08327791150241337, 0.06441992577000633, 0.06837269911746402, 0.07474544408808137, 0.0673033403208061, 0.0721137086229332, 0.07931485759748425, 0.07997488275711062]}, "mutation_prompt": null}
{"id": "25f5ec95-8c97-41e2-9d97-bba93ebea08b", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.initial_pop_size, dim))\n        self.fitness = np.full(self.initial_pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.5]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.adaptive_resize_interval = 10\n        self.eval_count = 0\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(len(self.population)):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(len(self.population), 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(len(self.population), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def adapt_population_size(self):\n        if self.eval_count % self.adaptive_resize_interval == 0 and len(self.population) > 4:\n            self.population = self.population[:len(self.population)//2]\n            self.fitness = self.fitness[:len(self.fitness)//2]\n\n    def optimize(self, func):\n        while self.eval_count < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(len(self.population)):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                self.eval_count += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                    self.strategy_probs = [0.6, 0.4] if strategy == 'rand_1_bin' else [0.4, 0.6]\n                else:\n                    new_population[i] = self.population[i]\n\n                if self.eval_count >= self.budget:\n                    break\n\n            self.population = new_population\n            self.adapt_population_size()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "A self-adaptive differential evolution algorithm with adaptive population resizing and dynamic strategy selection balances exploration and exploitation for diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": 0.14417651436350282, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.17.", "error": "", "parent_id": "d5e41046-36a3-42df-8635-b29e5fa063b6", "metadata": {"aucs": [0.18570471078894257, 0.21143741381931647, 0.20186492198467654, 0.18566514065075967, 0.18498914894339014, 0.27416814690059077, 0.3145452517007732, 0.3168250157935869, 0.21135455261917013, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13349491845790729, 0.10826552038459936, 0.08537853314105104, 0.11512074153654595, 0.09387792335543677, 0.08750390545542419, 0.1003033931255306, 0.118872490989271, 0.09740670545822627, 0.11667687759962386, 0.02465754042402446, 0.07744112781803092, 0.04381352779074854, 0.029385457795339742, 0.05119701384175224, 0.05508840735109022, 0.06312077165685603, 0.041054326137247465, 0.1982820332665256, 0.9750670077057835, 0.9805205934870111, 0.2984326637933614, 0.9761767907816211, 0.9880189123643415, 0.9838748206540563, 0.9892635735877959, 0.9816250038196069, 0.11626427329499822, 0.09203209905699494, 0.059160144211443555, 0.13804501772136968, 0.06207217551212785, 0.14093651223425163, 0.02834520317189604, 0.0931404784691493, 0.08848231231764714, 0.17198119722965088, 0.21037821410698476, 0.1851681805850901, 0.17056121550055214, 0.19028331283092226, 0.16098697223269753, 0.1508903387254784, 0.18169715951648657, 0.09567586280140095, 0.13300104897479892, 0.007700804419235152, 9.999999999998899e-05, 0.0035285131495985667, 0.08621874156796205, 0.10501115836430874, 0.033982133315475394, 0.12609532113870614, 0.017816077669616015, 0.009937153195323845, 0.11498196137992567, 0.010078051468650817, 9.999999999998899e-05, 9.999999999998899e-05, 0.11281094487556798, 0.14253107096779882, 0.06845717705525767, 0.09235282986693616, 9.999999999998899e-05, 0.07499606928527014, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026713819326359634, 9.999999999998899e-05, 9.999999999998899e-05, 0.08664543395203983, 0.023625892406180182, 0.03315659845308405, 0.1284639950594153, 0.08091417832174552, 0.01715866608608596, 0.04701291225078297, 0.051036852908949326, 0.02421694313370859, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08298065854167691, 0.043812361200688654, 0.006139060238221639, 0.01596949433534023, 0.1087405042952132, 9.999999999998899e-05, 0.003739436138103569, 0.06159724003675415, 0.031194921685329224, 0.3001301769915775, 0.20909358135649203, 0.32536993487923205, 0.2869797639781506, 0.2187979438062404, 0.2611605100864003, 0.25575285669716996, 0.2498868101678985, 0.20862960045239765, 0.07387464659049459, 0.0858740737977074, 0.09395725595892002, 0.10378016586516947, 0.0975465388097595, 0.10768249845493261, 0.08846898295382366, 0.05933458461531227, 0.07463557534057486, 0.1556225528417735, 0.13860809255301976, 0.15044869129042437, 0.10601656185772446, 0.12723738505792737, 0.19075627319789323, 0.13266824934200627, 0.1385276037473695, 0.13958249365249054, 0.1910308195553856, 0.19634048283963657, 0.22256506259664632, 0.2547909727312604, 0.15737754331424747, 0.22001610168697416, 0.2656195589612722, 0.2659302172959115, 0.17822074470760274, 0.19179974151707324, 0.147450467787149, 0.14892891451681622, 0.14485380417169358, 0.16109864098783366, 0.15024770167033363, 0.16555783913205546, 0.1499765002190725, 0.1197308931796297, 0.18046332062597759, 0.14573048502180064, 0.16406916465988908, 0.16663781664642519, 0.14422249843018886, 0.1776859802630132, 0.16767587456667843, 0.19326899168181189, 0.15924577344190072, 0.169315616512405, 0.17888919797726643, 0.16629234030272133, 0.17612438367593553, 0.1767452563679528, 0.1568642547982878, 0.16306135454727333, 0.19657283505838874, 0.16903961765130515, 0.12749216872830815, 0.19038449845346783, 0.14861547609921377, 0.16710651179883862, 0.16639631496298501, 0.14903747338744144, 0.24242165600784615, 0.20144684194997153, 0.18770877814500941, 0.328220443471846, 0.12371793403518072, 0.10092729273680778, 0.11597023045424848, 0.12914729643637513, 0.17534686559854795, 0.11970113184785147, 0.1443726136218536, 0.16557952118307417, 0.17294727919325759, 0.16237889039184916, 0.1605467280900006, 0.16853539931356387, 0.15731690914378704, 0.15641272723598354, 0.18887276839750966, 0.18041848204638122, 0.1584340938497456, 0.07088605304728934, 0.0530400001474165, 0.08368962987756645, 0.07390344428084905, 0.06737603867323738, 0.06804318251130537, 0.07838719023393004, 0.06027308288654731, 0.08111440127155567]}, "mutation_prompt": null}
{"id": "6ab3873a-5406-432a-b8aa-c91a4f44604f", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.5]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            self.strategy_probs = [0.55, 0.45] if strategy == 'rand_1_bin' else [0.45, 0.55]\n        else:\n            self.strategy_probs = [0.45, 0.55] if strategy == 'rand_1_bin' else [0.55, 0.45]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > self.pop_size:\n                self.population += np.random.normal(0, 0.1, self.population.shape)\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveSwarmEvolution", "description": "An adaptive swarm-based evolution algorithm with dynamic probabilistic evolution strategy selection and diversity maintenance for robust optimization.", "configspace": "", "generation": 2, "fitness": 0.34836553983334434, "feedback": "The algorithm AdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "d5e41046-36a3-42df-8635-b29e5fa063b6", "metadata": {"aucs": [0.726723494132109, 0.7327150238700195, 0.7190256521322363, 0.7691215998426182, 0.7635956260390079, 0.7572758671987398, 0.7406258146587339, 0.7116252511473491, 0.7282543478721526, 0.5561446680712109, 0.5437896313110657, 0.530937764864081, 0.5413523656053002, 0.5181988102795284, 0.5198931468132021, 0.5661272516152939, 0.5629140316821015, 0.5615112909477308, 0.10736787033564865, 0.10863214565692358, 0.10257334643138383, 0.10918979405138507, 0.1065739364882291, 0.09805147263865033, 0.1299160306831465, 0.09366949743678765, 0.10761338196484738, 0.1065338155025165, 0.09245257961161335, 0.09318167916933084, 0.09268726638870395, 0.10231142608325483, 0.0991348472391348, 0.09766287652681405, 0.09854307112939265, 0.10494097045690831, 0.968169207330763, 0.9814898163823361, 0.9734524426096114, 0.9724003677614566, 0.9842446642015249, 0.9686092565844389, 0.9828557671673216, 0.9903400132948077, 0.9819273225469766, 0.44444849622650096, 0.37595508230144103, 0.4095870771120863, 0.42959495801296654, 0.3965530813270429, 0.41057087159829564, 0.4152161936470502, 0.36332055359846993, 0.43669361317123834, 0.7398499261584859, 0.6873419284762778, 0.7100465812164358, 0.737503379040868, 0.7037473577488623, 0.6838571874254272, 0.6574828073592206, 0.7040318774498424, 0.7028119775747188, 0.39135032032877504, 0.29438496215975996, 0.35678025735375707, 0.320136349891217, 0.12212782670893862, 0.3805356010319334, 0.3381122410350469, 0.35950721487407256, 0.37857966495413264, 0.40496247203295843, 0.39505823655972117, 0.36504708836696476, 0.303594741846253, 0.384951805788903, 0.3628477847319803, 0.3628423941956417, 0.30025235706937237, 0.35962085704111546, 0.27408086385054575, 0.33882721216007294, 0.3006908217629892, 0.27293577651388146, 0.2577834144390959, 0.26431830029997905, 0.29115696783554457, 0.29150852389638326, 0.27504501767567335, 0.41770471154370226, 0.4385907202723601, 0.4029277290471568, 0.36368007269497504, 0.4483583778409571, 0.37996898280444313, 0.39736037998425766, 0.43720122978419973, 0.45033607858097835, 0.08738177272839964, 0.06647522951438622, 0.07184580837970711, 0.15796878063489517, 0.1749908810934605, 0.09423258286230152, 0.11805768710407882, 0.11954564199356976, 0.1273955510114041, 0.2608218960214119, 0.24461693282406394, 0.2241960932702889, 0.25824168260758174, 0.2484129805795564, 0.2548222657468906, 0.21965336094326904, 0.23020858542341083, 0.26119283319576825, 0.6111014393417831, 0.6060343908101451, 0.6235319835851528, 0.6457921122225717, 0.614268051464107, 0.6075535954512523, 0.6264690429758493, 0.5897374797486491, 0.605841030561761, 0.10040753252997603, 0.09487965714151869, 0.11597998744579596, 0.10294774551478181, 0.09356678291883547, 0.09246305510358455, 0.09000909002410462, 0.09835622899257346, 0.10700241212184136, 0.14167865800432844, 0.1148543643404264, 0.15279841853964515, 0.12865829383878813, 0.13894353321932618, 0.15213755458941136, 0.13985426043277782, 0.15680863366606723, 0.15015794914537306, 0.3354330760307872, 0.3343799209844286, 0.34167438666310934, 0.33288227752985344, 0.329261656693969, 0.3332622581168443, 0.35126026952229483, 0.3793961969344509, 0.3571871135647934, 0.2712444439481273, 0.24611359543954903, 0.2641846812321058, 0.29490903797154455, 0.255317813479366, 0.2569522590216772, 0.28448622712603777, 0.2730895175115877, 0.2804632479334689, 0.18733589331261347, 0.19326062915185316, 0.2040623484596401, 0.2030062899099414, 0.17958453871771818, 0.17058580593445238, 0.18591520945798512, 0.2060562279074053, 0.19684971192887502, 0.18124007695119182, 0.18180764330642118, 0.18755968689707947, 0.19622234131384197, 0.17401867974222973, 0.17593104313782226, 0.20248499943279297, 0.17543850984021514, 0.2054797771453013, 0.1636662329330547, 0.7152267974048595, 0.7083013440499738, 0.639746891983758, 0.6037133596273513, 0.6202868853791381, 0.5449819107970791, 0.6329140581612696, 0.4801299115135774, 0.6458323659113632, 0.2061881751055621, 0.5104499576764052, 0.6230789512200983, 0.1989793489127295, 0.1611464755049783, 0.12626572391715596, 0.6515010220692475, 0.15255436821759083, 0.17724756307814948, 0.18726151103184108, 0.17680384691242323, 0.17775965811079475, 0.18747402317510342, 0.17009261043196033, 0.19332819506857524, 0.19762307258098988, 0.17297953732373395, 0.0698182822814517, 0.07467714441914708, 0.08803078686434584, 0.07809389512686826, 0.07725529145197418, 0.06572677786504955, 0.07745336729984953, 0.06857855083330777, 0.07542065768600081]}, "mutation_prompt": null}
{"id": "a0e5a39e-cc06-43c7-9a0a-7fe6ed05c36a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.5]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.exploration_factor = 0.1\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            self.strategy_probs = [0.6, 0.4] if strategy == 'rand_1_bin' else [0.4, 0.6]\n        else:\n            self.strategy_probs = [0.4, 0.6] if strategy == 'rand_1_bin' else [0.6, 0.4]\n\n    def dynamic_exploration_exploitation(self):\n        if np.random.rand() < self.exploration_factor:\n            self.population += np.random.uniform(self.lower_bound, self.upper_bound, self.population.shape)\n        else:\n            self.population += np.random.normal(0, 0.05, self.population.shape)\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > self.pop_size:\n                self.dynamic_exploration_exploitation()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveSwarmEvolution", "description": "Enhanced Adaptive Swarm Evolution using dynamic exploration-exploitation balance and local restart mechanism to prevent premature convergence.", "configspace": "", "generation": 3, "fitness": 0.34473902871113277, "feedback": "The algorithm EnhancedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "6ab3873a-5406-432a-b8aa-c91a4f44604f", "metadata": {"aucs": [0.7429097552386001, 0.7136884488696891, 0.7312692902672693, 0.7474364539668135, 0.7384611539907979, 0.7532445083151051, 0.7149910424286257, 0.7515797786787307, 0.729651661185149, 0.5363808600599864, 0.5365968990506411, 0.5607043053047405, 0.5591801665604487, 0.5005375094248798, 0.5323164830266338, 0.5294880219303427, 0.5870834368948845, 0.5815626686795895, 0.1009385052969608, 0.09821392956674213, 0.11124916108020011, 0.100768491360551, 0.09980008204119695, 0.09710268263297328, 0.09928862434533525, 0.09918728408585886, 0.09340581980011975, 0.10570101318397485, 0.09537876671270351, 0.09938006638190167, 0.11289774709754219, 0.08533368755524295, 0.08797679838304939, 0.09910818261706733, 0.10873846726763292, 0.09219861711447486, 0.9683679759890537, 0.9598348156706518, 0.9418062931671836, 0.9724003677614566, 0.9842446642015249, 0.9753953938404433, 0.977525618574024, 0.9903400132948077, 0.9693982104845348, 0.4125015605375002, 0.4133248976084041, 0.4038923431447955, 0.42303824481098895, 0.38760588885347147, 0.42259476973601995, 0.43217697026618473, 0.38529388969375655, 0.4406879464957064, 0.6766742994281676, 0.6724686306915978, 0.7149007020023326, 0.6881881947255715, 0.7146506663276608, 0.7737943024899396, 0.7051307674368537, 0.6918321843841122, 0.6960230054310961, 0.370059610246674, 0.33984746756137907, 0.3256987233045513, 0.33633526887886767, 0.324960265795193, 0.3916113087319568, 0.38021368416158385, 0.37321395548747804, 0.35758140763975754, 0.26047862342513595, 0.41301005443504046, 0.3812957498955112, 0.3840331452405824, 0.38052858857122696, 0.38052365466094307, 0.34176119971321617, 0.3790433238701716, 0.41537132737045757, 0.2735872063333412, 0.2612105402623809, 0.2396752868962071, 0.259401993999831, 0.2551422102948604, 0.24462547744079555, 0.24258682840789347, 0.35950974944380887, 0.2945799951752841, 0.3975445548386404, 0.373078955264868, 0.37419245967878245, 0.4047227065149711, 0.4038681115791214, 0.4090695097114966, 0.43821330521064406, 0.44721130171307455, 0.4589463050848729, 0.1479639997184129, 0.08649764587861997, 0.08984812608904702, 0.1448101685903983, 0.10099708739506441, 0.16282086352964475, 0.09369991012633949, 0.057697222592848485, 0.06621558806996986, 0.240859515671502, 0.25448439279998636, 0.23361832303249808, 0.2740946317408166, 0.2460967572215751, 0.2363555809217014, 0.2501438478930451, 0.22869562451086944, 0.24565418848335607, 0.6309625740028659, 0.61203978968369, 0.6516723373676152, 0.623934324658719, 0.5918879051471932, 0.5904617801164433, 0.6240898814481212, 0.6106576671798782, 0.6139422764180484, 0.09114074267070205, 0.10836406381118924, 0.09183687384145356, 0.09044172609780199, 0.08248102524932932, 0.09292461102840988, 0.08466779831466342, 0.10162042592961718, 0.09790463198352684, 0.15518411587477587, 0.2100149253810617, 0.15649831603455078, 0.11952845347956131, 0.13024095402742475, 0.19132371406460158, 0.12842285104564521, 0.1318505161152641, 0.1362595180063434, 0.325127143651015, 0.3440872136848693, 0.366280880454274, 0.34749140645743326, 0.337930938231391, 0.33463530134861785, 0.37708915409329313, 0.3659996458301089, 0.36696683129048047, 0.2838344218806623, 0.2711757500992227, 0.2771051618174344, 0.23113154896211763, 0.25052073588896107, 0.22703133348561177, 0.2776188759415441, 0.2781350821510399, 0.2969680359495628, 0.1934728814773614, 0.17993400030637163, 0.19055820303839177, 0.1914794697919675, 0.20170349074402938, 0.1835727684589462, 0.18804110621862424, 0.21752740323867514, 0.2040887855771606, 0.18513938632023474, 0.18463889644838039, 0.17701091126314772, 0.18340736871090246, 0.17609096939439262, 0.1861441619480413, 0.19935633335100333, 0.18319419137075543, 0.31569707219297527, 0.6434149237586744, 0.19052815408616475, 0.15177796619045825, 0.17655786831711817, 0.18700745435667354, 0.652590462518561, 0.6932144504614743, 0.5996100879568929, 0.47321114185417323, 0.6891452585722746, 0.5329433637074368, 0.19254446533827962, 0.6955738861432967, 0.20293805400391418, 0.15718156845807774, 0.7138992599103475, 0.1251403304233889, 0.2007961293180014, 0.18449730910898854, 0.18945066993805637, 0.19480228264840882, 0.18787123951771656, 0.18480968106665985, 0.18638780596413784, 0.18234009191448886, 0.1756272717236117, 0.17889624995284825, 0.07583507264505462, 0.08384430515862329, 0.06495597275284948, 0.09100120464586448, 0.07591602974513711, 0.07082825334781884, 0.08288497581660781, 0.08509509813904736, 0.07884088354546659]}, "mutation_prompt": null}
{"id": "0820da3d-1202-4396-8e1a-ff9105a2d601", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionImproved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.5]\n        self.mutation_factor = 0.9  # Slightly adjusted mutation factor\n        self.crossover_rate = 0.8  # Slightly adjusted crossover rate\n        self.noise_level = 0.05  # Introduced noise level for diversity\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound) + np.random.normal(0, self.noise_level, self.dim)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            self.strategy_probs = [0.55, 0.45] if strategy == 'rand_1_bin' else [0.45, 0.55]\n        else:\n            self.strategy_probs = [0.45, 0.55] if strategy == 'rand_1_bin' else [0.55, 0.45]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n\n            if stagnation_counter > self.pop_size:\n                self.population += np.random.normal(0, self.noise_level * 2, self.population.shape)\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveSwarmEvolutionImproved", "description": "A multi-strategy swarm evolutionary algorithm with adaptive strategy probabilities and noise-induced diversity to tackle stagnation.", "configspace": "", "generation": 4, "fitness": 0.22264210971520026, "feedback": "The algorithm AdaptiveSwarmEvolutionImproved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.20.", "error": "", "parent_id": "6ab3873a-5406-432a-b8aa-c91a4f44604f", "metadata": {"aucs": [0.45486476148519317, 0.45970406379961537, 0.4419218138458516, 0.47146199211497675, 0.493728066627369, 0.47661149925740687, 0.484162034250043, 0.47556344957846775, 0.46138236131472, 0.09891672894555592, 0.10590855849522263, 0.09559902578752932, 0.11759108779182281, 0.10237741527715039, 0.10365478926836824, 0.10405958700551943, 0.10695921512593665, 0.10394179148973903, 0.11121574875390616, 0.10303892802125081, 0.1124384256140053, 0.12051193432359963, 0.11676903231330793, 0.10691057161846362, 0.11778559246974163, 0.10960540353111592, 0.10152777910520294, 0.11240061592984585, 0.09492862570985616, 0.11221468931985745, 0.1008495533198287, 0.09471936559921779, 0.11721833334202603, 0.11135497487656065, 0.08797843162332697, 0.1118530784716466, 0.9551857876400712, 0.9467792258697735, 0.9456249682036033, 0.9652487102890445, 0.9560083364500536, 0.9654239011379273, 0.9672487318785451, 0.9304620399393991, 0.9653327244253134, 0.26803943073317504, 0.2719410685163589, 0.257102304250719, 0.24900791890185392, 0.25204601455943854, 0.2550471307022423, 0.2806051912828542, 0.2527749073865019, 0.26733559928002804, 0.34765653166025556, 0.4622674807733236, 0.279616647056795, 0.3536586177936646, 0.431574818688626, 0.2863319086173539, 0.4143402905107699, 0.28528445799206215, 0.3012905725307492, 0.16609186587773928, 0.1590511773723431, 0.1668715983887289, 0.156246147582199, 0.163616519693225, 0.1643675550734408, 0.16847288078720468, 0.17206108884029236, 0.167802280007741, 0.14933691304362673, 0.10896814044949532, 0.1933484368536177, 0.17648433388393547, 0.14306368449702678, 0.14330081353610824, 0.15659523653650465, 0.09011897002100722, 0.15573609586033765, 0.025877885577042403, 0.03323893327590177, 0.006456219170254407, 0.02946786188099526, 0.026221409661915107, 0.010318601661101434, 0.017709093568970435, 0.01192263674965488, 0.03361547321972469, 0.07023097517039734, 0.0667292934387218, 0.08403646328765568, 0.09140642609684424, 0.07453332791120226, 0.07922434962829972, 0.10364556001537673, 0.10675693168195144, 0.09070145943474894, 0.001660872941017244, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1056106168225941, 0.09678945405604411, 0.08819804166357803, 0.10193463790106416, 0.10115086465142598, 0.09487140797208138, 0.09749495011186204, 0.08881151422474087, 0.11289470465113172, 0.4040874950457981, 0.40435394701116334, 0.41049270608320176, 0.38470515581875275, 0.399940186335751, 0.4164135743552121, 0.40124575885291436, 0.41320865620950986, 0.3994495965213143, 0.08556938584947804, 0.10190994535305653, 0.09080447606806485, 0.09191724644717791, 0.08897160102393331, 0.08351072752728128, 0.09924272401011891, 0.08510956306454986, 0.08095272949116605, 0.16879604925037417, 0.19324053074541048, 0.1577471927939743, 0.2038297724947794, 0.18412383666575083, 0.16729890315065366, 0.22868350095052525, 0.14715492163354682, 0.1421560842835886, 0.2716802058200991, 0.2551231441512537, 0.26653277315869395, 0.24977414668607212, 0.2609522144828601, 0.26263597962844576, 0.2713905675151852, 0.2927756374341469, 0.28419735217648556, 0.21067105401450836, 0.18579172962665114, 0.1937952755969765, 0.17186797253986896, 0.18975407519094956, 0.18615983644259027, 0.21109656140141364, 0.20827625580815723, 0.19784733525002607, 0.1856335234871589, 0.16126077899303526, 0.17627623096273637, 0.19319947452187192, 0.176557808351558, 0.18421303305343406, 0.19700427986051705, 0.1810903074842749, 0.16855438065761286, 0.1926720300571204, 0.21746540065982767, 0.20376667365135703, 0.17519749976825372, 0.18063560814116608, 0.19133999996371398, 0.187138305701551, 0.18386606664164407, 0.19243718576758007, 0.166809048217181, 0.5706481506196714, 0.6100292027343366, 0.4171408039318626, 0.1799104425919248, 0.5768020886179592, 0.490562752511285, 0.38526285402858595, 0.48150661733486644, 0.3959496685123556, 0.2015663562373171, 0.38079654302427235, 0.19259589597321647, 0.15963664543442013, 0.19072625799060483, 0.21055954628176332, 0.20902037987457933, 0.5039822393688262, 0.1838589471840394, 0.18608718844390904, 0.18514870761505853, 0.2069331160609813, 0.18201943997274006, 0.17843089150952707, 0.1701987851543756, 0.19701891255469517, 0.19771096176887804, 0.0628779340209843, 0.07065697086901945, 0.0682421070421031, 0.0687857912887071, 0.06567737113172512, 0.08591498684995691, 0.08228161119673172, 0.07530704802803068, 0.07768411561629585]}, "mutation_prompt": null}
{"id": "991465fa-a552-42a0-9ac6-63d254c845a2", "solution": "import numpy as np\n\nclass RefinedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size for better exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.6, 0.4]  # Adjusted strategy probabilities\n        self.mutation_factor = 0.85  # Increased mutation factor for better diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        else:  # 'current_to_best_1_bin'\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [min(0.7, self.strategy_probs[0] + 0.05), max(0.3, self.strategy_probs[1] - 0.05)]\n            else:\n                self.strategy_probs = [max(0.3, self.strategy_probs[0] - 0.05), min(0.7, self.strategy_probs[1] + 0.05)]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n\n            if stagnation_counter > self.pop_size:\n                self.population += np.random.normal(0, 0.2, self.population.shape)  # Increased noise for more exploration\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedAdaptiveSwarmEvolution", "description": "A refined adaptive swarm-based evolution algorithm with improved strategy selection and enhanced mutation diversity.", "configspace": "", "generation": 5, "fitness": 0.28897628906712935, "feedback": "The algorithm RefinedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "6ab3873a-5406-432a-b8aa-c91a4f44604f", "metadata": {"aucs": [0.6529776137300622, 0.6509534878390392, 0.6582628171442719, 0.7010925866575066, 0.6681279519654868, 0.7127447996406171, 0.686038300705173, 0.6781326836324981, 0.6729364185463771, 0.43185166832860544, 0.4299206615399892, 0.4165141235696038, 0.4129227520648463, 0.3881007676427153, 0.39996225282448983, 0.4453775305355574, 0.44885640922620396, 0.4310901763578471, 0.10089092351851636, 0.09611842538036164, 0.11208400275896802, 0.09858717866179378, 0.09858361274354754, 0.10013693225929932, 0.10172990890148226, 0.10910794304677218, 0.11085188767269993, 0.09133942263246375, 0.09796053383245473, 0.1023117685694871, 0.11015429446672065, 0.10342558131688151, 0.10561661829639613, 0.10030920772978502, 0.09929962232253275, 0.09531864062521578, 0.9796567614715869, 0.9749697751212253, 0.9524896720735394, 0.9489699050252888, 0.9665582089765461, 0.9789867596924704, 0.9639517593367755, 0.9859822661440023, 0.9749172526234628, 0.3292264803192284, 0.3227714417227082, 0.3070311059924469, 0.3043378698918564, 0.3008832126763762, 0.2895389990765681, 0.3151123154286505, 0.36197944406161475, 0.31424152070652733, 0.5646352429717374, 0.595695677949952, 0.5653052088852153, 0.5840857078094018, 0.6670334662044997, 0.589557629260776, 0.6374058358995074, 0.569218053788513, 0.5292188434056189, 0.2614153627430482, 0.26564250869739603, 0.264931644446479, 0.22492546376101097, 0.24455627418528714, 0.24250093881911872, 0.2823491620694445, 0.28064266868853716, 0.26502043416017274, 0.23190609694355246, 0.2796366285860107, 0.21732436792556797, 0.21968766472254875, 0.2255327467444611, 0.2994391816842211, 0.2577376801350503, 0.21157033406345604, 0.24943093321024157, 0.14174454097562028, 0.1561069617904084, 0.11301428550456205, 0.17522205608166408, 0.14293552668687715, 0.16690500654335316, 0.08829831234364116, 0.11841229525380736, 0.13877154804362968, 0.18952334813881921, 0.25407768031492073, 0.24519331610281914, 0.1922558544804952, 0.28406308814817827, 0.22192014562199458, 0.2557333415520905, 0.2832429058863678, 0.2830070231099757, 0.05913736128876279, 0.058672156502502903, 0.060152615088652994, 0.051429605264930234, 0.061140558475447304, 0.07418436644416959, 0.04214242751964137, 0.04260631002692039, 0.035864602491150976, 0.15120099351948624, 0.1597746065698128, 0.15250210041925583, 0.1860997960029781, 0.16999410975025053, 0.18222108468053022, 0.17731179528613028, 0.16357505951681284, 0.14564746581982002, 0.5136848544245606, 0.5327723631896217, 0.515840758803748, 0.5090772245026377, 0.4929904989087116, 0.5118287700658087, 0.5211549790445711, 0.5004901461473097, 0.5217649785800242, 0.08306054169972721, 0.09770343350600019, 0.08409310382561508, 0.09070895922598143, 0.08764159678697359, 0.10696232013543472, 0.10365219189499641, 0.10551273186663179, 0.085672819732998, 0.14754371592842586, 0.15116968240256023, 0.1598816470871337, 0.16297900938333787, 0.15821972116327543, 0.14664805720396556, 0.13978764929761545, 0.13734603992689187, 0.1496405866038223, 0.3072650527138785, 0.3123038383132619, 0.3178035351068922, 0.29564248382057057, 0.28144252708694506, 0.2798086450389369, 0.3012081140275361, 0.34090164568703063, 0.3314445143422151, 0.2169005505192757, 0.23562097307111907, 0.21756036577464022, 0.2076700983640445, 0.23713328182127824, 0.2285313577402136, 0.22465251621119264, 0.24062069571729294, 0.2228583737886719, 0.21113868629935828, 0.185971965939852, 0.18208045205341405, 0.1892081063214197, 0.203301898564356, 0.17820844718309437, 0.19428985410238575, 0.17515648638592507, 0.18033399853950982, 0.17558863703402838, 0.16823452384854642, 0.19211606086047672, 0.1827413284564937, 0.18653109870167706, 0.18666278290046667, 0.17130194104429797, 0.18826639567529246, 0.18036418846345226, 0.6427387521556673, 0.6324682105541212, 0.1869141528278686, 0.18556002747939315, 0.1852496404507794, 0.18420412433237077, 0.6760245391850048, 0.6414154089539874, 0.512926441240833, 0.19270706912407576, 0.3120812914602299, 0.4340807591696889, 0.4288090453497537, 0.19369806421181535, 0.1547971840856157, 0.20857053367373735, 0.2098619161387396, 0.60603059072823, 0.1696116751957012, 0.20847853726830246, 0.20161976257898673, 0.18254481876573447, 0.18573492768954425, 0.18640403361020386, 0.1800643807632849, 0.18471280116617506, 0.18542131216065583, 0.07335664462883429, 0.08735150462495989, 0.07523086106787757, 0.07462324887156724, 0.06851702945773508, 0.0696267500354556, 0.06616630953959668, 0.07533595567269635, 0.06546206538883959]}, "mutation_prompt": null}
{"id": "6ed0507b-fff1-457c-9707-c43407b072ec", "solution": "import numpy as np\n\nclass RefinedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.5]\n        self.mutation_factor = 0.9  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs[0] += 0.05\n                self.strategy_probs[1] -= 0.05\n            else:\n                self.strategy_probs[0] -= 0.05\n                self.strategy_probs[1] += 0.05\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs[0] -= 0.05\n                self.strategy_probs[1] += 0.05\n            else:\n                self.strategy_probs[0] += 0.05\n                self.strategy_probs[1] -= 0.05\n        self.strategy_probs = np.clip(self.strategy_probs, 0.4, 0.6)  # Ensuring probabilities are bounded\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > self.pop_size:\n                self.population += np.random.normal(0, 0.2, self.population.shape)  # Increased noise for diversity\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedAdaptiveSwarmEvolution", "description": "A refined adaptive swarm evolution algorithm using a probabilistically-adjusted mutation and crossover strategy for enhanced exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.27998704705085964, "feedback": "The algorithm RefinedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "6ab3873a-5406-432a-b8aa-c91a4f44604f", "metadata": {"aucs": [0.6468928185510003, 0.6406028619078215, 0.6707154263886571, 0.6957437079532172, 0.6823402727521715, 0.6864106016550835, 0.6910354456717257, 0.7033581378018734, 0.678974727585232, 0.44622932734511955, 0.4096113101442719, 0.4272240689543132, 0.4339261716063716, 0.40907268864729385, 0.41599393622718306, 0.3965958428353956, 0.4198818083811582, 0.42532469517032345, 0.11973789541306101, 0.13689497548658514, 0.1121059863979843, 0.11212746287241337, 0.14052651284448403, 0.1219519570164963, 0.10404780240500733, 0.10107911778762557, 0.13208162894981668, 0.09786163857742125, 0.09280346846846499, 0.1003119750762902, 0.09715172302473407, 0.08850046416975743, 0.09957755768382137, 0.10968859595835434, 0.09901134381441856, 0.1101182974474405, 0.9907750214194151, 0.9829328645376768, 0.9887878715537796, 0.9748202081870107, 0.9540107932081403, 0.9831879059385552, 0.9743564517060174, 0.9907232661824595, 0.9857510302748007, 0.31247479632637065, 0.30287253758863875, 0.2958638264651221, 0.32355675418074215, 0.2910905681173318, 0.3020471194952278, 0.3066935900208766, 0.32625567630891195, 0.31705234592328, 0.5751017193358138, 0.4934754928178753, 0.5255319596183525, 0.5996209286930473, 0.4415977385704588, 0.5229469098265782, 0.5174274653351794, 0.506763048005149, 0.46189586959135653, 0.24605223332451953, 0.22878910078820103, 0.24280784868541827, 0.20512806778017612, 0.22192550679943202, 0.2339561063229938, 0.20391226134440998, 0.23660996404781742, 0.21512144293387747, 0.1907766817005303, 0.2012069851863436, 0.2072054858590069, 0.2291514787729214, 0.25238288793750285, 0.2320867191413124, 0.26763012470741765, 0.23772631215668083, 0.1756970884581286, 0.08830575993738643, 0.13970698468461507, 0.10776134793411385, 0.1436619364857521, 0.10065937798305691, 0.10064933003038345, 0.10489628648518523, 0.082002313444695, 0.1144744367013324, 0.21982744803446952, 0.23938927708641078, 0.23219187981737321, 0.2536538322416083, 0.24703840281894174, 0.1822515693174469, 0.28103332049775365, 0.3493750938903437, 0.2723463571905438, 0.049708668318497296, 0.03968564164510713, 0.02876283443772587, 0.03288712432988683, 0.027649760255883282, 0.03148853692700648, 0.030068892429667926, 0.04902257374360364, 0.07185360357898662, 0.15938889778142584, 0.15297003311768165, 0.14300628154520123, 0.14988010577990518, 0.1569116117698508, 0.1530113304685805, 0.15889412940964742, 0.1460989999857697, 0.15353818056111468, 0.48763135952645165, 0.4759370976974081, 0.4865662903796074, 0.4910320773787239, 0.490850490941682, 0.48839923584435796, 0.49823864817318186, 0.47606952188796503, 0.47432769906328653, 0.12959580467262188, 0.08240905691895728, 0.09047707654112291, 0.10211531149190944, 0.08560852284277065, 0.08207290735576989, 0.0943191279479002, 0.06910003998903635, 0.11186324793418101, 0.14634932279796298, 0.2604378630335614, 0.19312245951646545, 0.17257032728166288, 0.1347255742618625, 0.15336287782713243, 0.14423632208684178, 0.16126213148260626, 0.17781462013595517, 0.2903933774021965, 0.3012825859790659, 0.3020088584668913, 0.2968458116454209, 0.26985877845166795, 0.27102727851080166, 0.2959793322131551, 0.31861719849042525, 0.2986589495690146, 0.193929334494077, 0.19537282099450848, 0.21304405995469133, 0.2065025503967729, 0.20228897426367176, 0.19948181917476093, 0.22597508608337846, 0.22844763162563464, 0.2258345023515852, 0.17568453082711089, 0.18206127241601788, 0.18699859672007813, 0.19694068209670057, 0.17648749675814146, 0.20025782329204977, 0.18798805418285114, 0.1771075071256213, 0.1850508153676763, 0.2052530223315181, 0.1883095978893351, 0.1851172665894807, 0.17875967894329425, 0.20571178412922564, 0.20157601298395944, 0.19260822493435448, 0.1989588305767347, 0.18324343644909336, 0.17164367387977486, 0.7217300932074419, 0.7225512425232699, 0.17970647465787348, 0.18471801337142368, 0.17896063509597426, 0.4759637677076841, 0.47853306989279953, 0.571715716381324, 0.5381253940165729, 0.20114564020049885, 0.19184630886783594, 0.19111143430941002, 0.3704704464123574, 0.5130161955953639, 0.20721586860452512, 0.20768088869415047, 0.20120051339590128, 0.17793613336116143, 0.1896100196599132, 0.1866112793126311, 0.1970155553018258, 0.17953537947049336, 0.17579466407792899, 0.188871340533584, 0.20681770926393128, 0.1834738338725399, 0.07378115296288157, 0.06666315173901438, 0.06453801073107168, 0.06965681515434718, 0.06956211798279688, 0.07453908053675062, 0.07081603273942871, 0.07350612220908082, 0.09163531975596939]}, "mutation_prompt": null}
{"id": "253c4357-fce4-46c6-95a6-b9740646895d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.5]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.6, 0.4]\n            else:\n                self.strategy_probs = [0.4, 0.6]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.4, 0.6]\n            else:\n                self.strategy_probs = [0.6, 0.4]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if np.isclose(self.best_fitness, previous_best_fitness, atol=1e-8):\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > 2 * self.pop_size:\n                self.population += np.random.normal(0, 0.2, self.population.shape)\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveSwarm", "description": "An enhanced adaptive swarm-based evolutionary algorithm incorporating adaptive mutation and stagnation escape mechanisms for improved performance.", "configspace": "", "generation": 7, "fitness": 0.31120626153445, "feedback": "The algorithm EnhancedAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.22.", "error": "", "parent_id": "6ab3873a-5406-432a-b8aa-c91a4f44604f", "metadata": {"aucs": [0.6589255893613659, 0.6522016357544123, 0.6732494154345763, 0.7065596106764634, 0.7154650437754873, 0.7046603517759409, 0.7217223599450913, 0.6923370160117381, 0.6744023482061662, 0.45281034813801657, 0.4607517656597444, 0.46324839918054006, 0.41776000689230997, 0.4422137934965491, 0.45614495034912284, 0.45598223584300346, 0.4411613637367824, 0.4458220379897976, 0.10088391834012544, 0.10781764549150319, 0.10298388737238329, 0.09135805671500707, 0.10848042785801171, 0.12087360726340635, 0.1164837645232768, 0.09347003093845485, 0.09379807148509811, 0.11150273732702809, 0.08950539525797796, 0.10705959992031366, 0.09621555716940333, 0.09575085345488987, 0.0928131123293453, 0.0958355195892826, 0.10924853465541984, 0.07822625147039797, 0.9718936272272914, 0.9480614938843329, 0.9710783162580295, 0.9656771644357226, 0.9566601271709425, 0.9457085891023599, 0.9700413765922389, 0.9763307779613151, 0.9776228664562125, 0.33021437093054806, 0.33656726692386296, 0.35366431542720644, 0.3697426725224131, 0.3507886204128725, 0.38148508373871515, 0.3665370997798002, 0.33383169802557777, 0.3797493689356166, 0.6058648315271291, 0.639724586566861, 0.5870030873309088, 0.6029478241558305, 0.6581037137933163, 0.7011264281891333, 0.6407663398860861, 0.6222913455683234, 0.6827375655074297, 0.31281387649986536, 0.3052646808597046, 0.2886818688244128, 0.2759782196659202, 0.22990140803907266, 0.2737757881716606, 0.3055281570950127, 0.3104048382822816, 0.2475506230675555, 0.11334259982479489, 0.3094251732694393, 0.2965605163150359, 0.31343680938022267, 0.2918483605411466, 0.3050876264554565, 0.3271645118303339, 0.20889227483927675, 0.3189061119412686, 0.2621959700655848, 0.20091472663265508, 0.19655980858756306, 0.23014186394479041, 0.2531126791495816, 0.19226774260463586, 0.21388529585108795, 0.18794331895464678, 0.17817625417608252, 0.3043136188954494, 0.3658340787409893, 0.3693716628998237, 0.3502826211483637, 0.35674926509337745, 0.33469814638971573, 0.37418568051920387, 0.3569941938412785, 0.3566124936131607, 0.0877081596280086, 0.09727646289144798, 0.07576732680301179, 0.13501209120124458, 0.06793096898614892, 0.10486131793549536, 0.10860282751761641, 0.07253328549452742, 0.1028208176791997, 0.19084784918813802, 0.21601769300462192, 0.18581748632121786, 0.19734468906363267, 0.21119593525987912, 0.20582417974525147, 0.20769639554503538, 0.19452142559187313, 0.21487041315930366, 0.5249058309708085, 0.5387513495529275, 0.5469741887291761, 0.5258067261615171, 0.5641593185344446, 0.5485038262081969, 0.5466677899104916, 0.5341255882460639, 0.5277189834737173, 0.08881950381958192, 0.08292997425053816, 0.09390660470017831, 0.09505711656001237, 0.09232838905860152, 0.09252169120946652, 0.09099846380985532, 0.08687027269727532, 0.09553907119252403, 0.15556903530763866, 0.15701457539951935, 0.16949098508421645, 0.14919219997774058, 0.1685884284582615, 0.16359522060773235, 0.14772848442991293, 0.16074684258951566, 0.15531824156621166, 0.2986013324992024, 0.31726641877666373, 0.31661598408543545, 0.3071234675950687, 0.30282844477261783, 0.3171537150015368, 0.34187237363614853, 0.32326462743178086, 0.3071303946772349, 0.2437705192082379, 0.27040104605908877, 0.24736235667731155, 0.23013469125632324, 0.25493270727751083, 0.22563185027393406, 0.2694337111162981, 0.2754270043948759, 0.2507630392778707, 0.2003711270043328, 0.18103712455578003, 0.19323837168549507, 0.19829234873285173, 0.21444807610394523, 0.19291883001665255, 0.18163175406566512, 0.2064662920415008, 0.18428467230449863, 0.17951843480133733, 0.1821059559475442, 0.16748509441195714, 0.18001128095104846, 0.18760116326575238, 0.1972117349187139, 0.1769595678232725, 0.20044735137346692, 0.1981084575928599, 0.6308920435014338, 0.20112309244208326, 0.18071786420624592, 0.17811526478368178, 0.6617001383808148, 0.42205110253146194, 0.6397321707565946, 0.26160046988395047, 0.5604853462371575, 0.5174901849216869, 0.20072328112628401, 0.4555828597654662, 0.3773225258376208, 0.1613837941595404, 0.15700708249716167, 0.2095558775069679, 0.5834915859842612, 0.39278009468594133, 0.1875610840438996, 0.17959957449472552, 0.18504882088741015, 0.17319045920868226, 0.18228289768792016, 0.17867856381031721, 0.20360591091248237, 0.1864578355022396, 0.20131933219207188, 0.07270663839496705, 0.07512885937008507, 0.0738934943066768, 0.07309437985956069, 0.07907433573941669, 0.07058702906197356, 0.06680558292461358, 0.07864490491785059, 0.06603999207340261]}, "mutation_prompt": null}
{"id": "242dcc83-0ff5-4b5e-b595-b40760dce9ef", "solution": "import numpy as np\n\nclass AdaptiveSwarmEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Changed population size for enhanced exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.6]  # Adjusted strategy probability for diversity\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            self.strategy_probs = [0.45, 0.55] if strategy == 'rand_1_bin' else [0.4, 0.6]\n        else:\n            self.strategy_probs = [0.5, 0.5] if strategy == 'rand_1_bin' else [0.55, 0.45]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n        reinitialization_period = self.pop_size * 2\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n\n            if stagnation_counter > self.pop_size:\n                self.population += np.random.normal(0, 0.1, self.population.shape)\n\n            if evaluations % reinitialization_period == 0:  # Periodic reinitialization\n                self.population[np.random.choice(self.pop_size, self.pop_size // 5)] = np.random.uniform(\n                    self.lower_bound, self.upper_bound, (self.pop_size // 5, self.dim))\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveSwarmEvolutionV2", "description": "A diversity-guided adaptive swarm evolution algorithm with dynamic strategy selection and periodic reinitialization for enhanced convergence.", "configspace": "", "generation": 8, "fitness": 0.2731885728132936, "feedback": "The algorithm AdaptiveSwarmEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "6ab3873a-5406-432a-b8aa-c91a4f44604f", "metadata": {"aucs": [0.6433368478397914, 0.6448059618381561, 0.6622974016126921, 0.659642278177802, 0.6386566287540056, 0.6855293995089535, 0.6495740433354819, 0.6667526570721154, 0.6161871677752438, 0.4001163554404199, 0.38740304094077915, 0.3887301157616071, 0.34191577634199444, 0.3757245963541763, 0.3665817133985574, 0.363255377728811, 0.3593790578521916, 0.4052250578758523, 0.10854636472109636, 0.10495913834733017, 0.11328785725765411, 0.10380390650693572, 0.09874327297269991, 0.10572289623659947, 0.09906678871637453, 0.09515645610853718, 0.09640234037293083, 0.09585108981786394, 0.10038847463471667, 0.08642562774458307, 0.09247510566686001, 0.08995204994065187, 0.09146311632598114, 0.10068759492408719, 0.08848043947577844, 0.08932216932105819, 0.9724906779978114, 0.9721689687643369, 0.9738546947994571, 0.9662348668072154, 0.9856091490978018, 0.9790674797641074, 0.9702745245178545, 0.9859822661440023, 0.9749199817450996, 0.2853424227007324, 0.29452537179154437, 0.26734947100292306, 0.28914589758555076, 0.2845967999134691, 0.3088958489914244, 0.30886971422998155, 0.3163890599578907, 0.30971517700733175, 0.4827685474824891, 0.5101486975495647, 0.6336688494519165, 0.6080075772314, 0.5815990759391257, 0.5610137942689701, 0.5233995722580689, 0.5261420696451511, 0.542851548568415, 0.22535536388512767, 0.22210083389494484, 0.2355775091009331, 0.18569930726707395, 0.1139345618076264, 0.22802161937544596, 0.20086670750070856, 0.2152172973975628, 0.21245108303051552, 0.27908783198920106, 0.11349260160432206, 0.19122931062968818, 0.28336724457270224, 0.196788222929827, 0.20549455176724019, 0.2358811113452064, 0.20109678332566805, 0.220189302774371, 0.10758040337857744, 0.1012295043823691, 0.10260436039382859, 0.1651326869324481, 0.12637139459882418, 0.12484121492511535, 0.08742498472783045, 0.09696138255135278, 0.1388241127829415, 0.21148998305901034, 0.2289304217156658, 0.24183627166015154, 0.18243303881032147, 0.19850564332380205, 0.22407036321178764, 0.23138693087957496, 0.2715997161326268, 0.24673125989215927, 0.024780582675528073, 0.032533617952343, 0.021996834864990378, 0.04393010696454891, 0.030237501928900734, 0.013802432830631206, 0.04351780596500887, 0.05749269168102855, 0.01839507511144034, 0.14152125757278533, 0.14899955615514737, 0.15245245144273034, 0.15276989042209732, 0.14368950073378162, 0.16065452090184995, 0.1401734743290335, 0.1224652856891777, 0.17255147957316663, 0.5012399005996713, 0.48358302769090833, 0.4844282909615617, 0.49742339363121924, 0.4935410856028417, 0.48223694613263146, 0.5007265541443637, 0.4560574787165109, 0.50286110629627, 0.08313736905432201, 0.12490209337062474, 0.09919154471000857, 0.09505492272853666, 0.07960960189160904, 0.09702449005431246, 0.08545617465731425, 0.08362147435724288, 0.09698720750946055, 0.14923309141120755, 0.12591932287561158, 0.1984144676118046, 0.15915544983446905, 0.13351879390558274, 0.14696465865339647, 0.1494904558637623, 0.14018078177406224, 0.152915656820941, 0.28439544535931705, 0.2764948949757928, 0.27695164086241253, 0.24839214246455021, 0.25981623450351177, 0.25821222002451016, 0.3018039504506067, 0.3328066057377833, 0.3079269114066703, 0.22423121068253338, 0.2093832325864995, 0.2128706587019874, 0.23343718412765202, 0.18534758404962326, 0.20415332892354987, 0.2197070095986593, 0.2322499965203889, 0.2295994819920767, 0.18525351344470697, 0.19525512450176052, 0.1892009860065249, 0.22010930191369338, 0.21580561606320847, 0.17645768666368544, 0.18321563720527334, 0.18177759550552042, 0.19343791061532956, 0.1899683424607974, 0.1746461747413074, 0.17812980218162644, 0.1833745895899389, 0.1725905349201946, 0.17642930659524791, 0.17423235725555275, 0.18493336469755473, 0.17302947608706476, 0.6487439884921182, 0.20170557662885003, 0.17756912109882106, 0.5284708433030748, 0.41692611958700865, 0.5053603079231371, 0.1764283801533546, 0.17428524569263337, 0.4840212276037923, 0.1651983505288115, 0.1675555273000071, 0.44566314340088176, 0.4096384513207376, 0.3570769347631324, 0.41313719668424875, 0.20495568150239274, 0.20815426357165379, 0.6446471101412706, 0.19479352371466274, 0.17372105337736066, 0.1942477911707987, 0.19799065795141424, 0.18133057436833422, 0.17789554208328495, 0.19304495110851672, 0.1758935046184108, 0.19281292622468038, 0.0762815706788551, 0.08168423326007546, 0.07451853400189157, 0.06440046756730022, 0.0691305441279656, 0.0701732938729307, 0.06711945068389336, 0.07234730139334167, 0.06665668722967488]}, "mutation_prompt": null}
{"id": "d5ca54db-9d2f-40f7-8ee8-1e3ddb97b785", "solution": "import numpy as np\n\nclass RefinedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.5]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.learning_rate = 0.1  # Introduce learning rate\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        adjustment = self.learning_rate if success else -self.learning_rate\n        if strategy == 'rand_1_bin':\n            self.strategy_probs[0] = np.clip(self.strategy_probs[0] + adjustment, 0, 1)\n            self.strategy_probs[1] = 1 - self.strategy_probs[0]\n        else:\n            self.strategy_probs[1] = np.clip(self.strategy_probs[1] + adjustment, 0, 1)\n            self.strategy_probs[0] = 1 - self.strategy_probs[1]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n\n            if stagnation_counter > 2 * self.pop_size:  # Adjusted threshold and population perturbation\n                self.population += np.random.normal(0, 0.2, self.population.shape)\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedAdaptiveSwarmEvolution", "description": "A refined adaptive swarm evolution algorithm incorporating dynamic learning rates and environmental adaptation for enhanced optimization performance.", "configspace": "", "generation": 9, "fitness": 0.33133347752715714, "feedback": "The algorithm RefinedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "6ab3873a-5406-432a-b8aa-c91a4f44604f", "metadata": {"aucs": [0.6936523866203533, 0.6830685498773298, 0.7202192897684208, 0.7458136392442034, 0.7422175513650671, 0.738910214697551, 0.7199886283567638, 0.7407724564082034, 0.7280911154308194, 0.4811915708918717, 0.4668211388621376, 0.5031400538578921, 0.48622857798472374, 0.4618461749773103, 0.4908705769181977, 0.48635617872794745, 0.4971480863167067, 0.4995415802446771, 0.11474610887217718, 0.10521560293920773, 0.09617364305539744, 0.09671388897168076, 0.09492730300469243, 0.10169183680780647, 0.10174739054195325, 0.1159275256135388, 0.11377096566693834, 0.102802059916418, 0.08731695189759325, 0.09545484552649885, 0.09755391770065303, 0.10423948673741301, 0.09735387186996836, 0.09310439577075635, 0.0890047290539342, 0.09816790210770288, 0.9577097487947743, 0.9693107956968603, 0.9765011871407673, 0.9702891394692474, 0.9830828923726718, 0.9803552660235936, 0.9796401722258197, 0.982543538284052, 0.9750705312018343, 0.3555830269244481, 0.3660749436552361, 0.35502495019196867, 0.3590596353253458, 0.3774975879807495, 0.38800668800816085, 0.34742526824576747, 0.3730089118748152, 0.36256221223072405, 0.5281857610084227, 0.6988428314684352, 0.6632585436569864, 0.6388498816979377, 0.6939531432363966, 0.7085767019890167, 0.639630450060698, 0.6830916051214065, 0.7399268602765231, 0.3009195649637403, 0.3120369909744549, 0.34974132620313114, 0.32280088429666964, 0.3831864623085306, 0.31258107470079477, 0.31391897010316716, 0.3350064046384158, 0.22819642160505416, 0.3630701611415993, 0.4357315553682026, 0.3240027731696129, 0.34941014228460243, 0.3415450313257249, 0.34263367093403563, 0.3075576416666337, 0.3123605985981063, 0.3401713996456136, 0.22719878004913086, 0.25969229020157114, 0.22779917315311948, 0.2113063096547496, 0.27078481868416515, 0.20726341852931174, 0.27490592879059905, 0.23904213442940458, 0.20831866165157786, 0.3532240970141639, 0.3579228517224432, 0.36548345773670377, 0.3202409979250028, 0.38832072002597384, 0.3797501035849137, 0.41796236308769597, 0.4003761518906791, 0.4242600558880282, 0.0750751826456526, 0.0734550807317631, 0.08174757234006624, 0.05445008860958589, 0.11907545869238112, 0.08458247652133055, 0.08077128785911392, 0.1153662633857857, 0.14448836283314925, 0.20934551880488317, 0.21706129776133998, 0.20380936091605584, 0.2467191924014387, 0.23948512516429743, 0.24147965864974152, 0.23001664538102573, 0.2230973515042074, 0.22148894843518885, 0.5609919781034335, 0.5605580257804679, 0.5468631809789912, 0.5645805500122276, 0.5857308454404346, 0.5575768494955813, 0.5966783893956131, 0.5768911805076855, 0.5851002434231267, 0.08824630847341175, 0.09943706038067213, 0.08785731477076097, 0.09881372138131195, 0.0833080683325812, 0.07777980363296244, 0.08353169452027431, 0.09160732096654978, 0.0839951368573908, 0.1306856498501715, 0.14029897367083655, 0.13122131793440617, 0.14083559342136687, 0.14253170375756563, 0.13494451933244112, 0.13794682582226525, 0.1507754319113639, 0.12695551346239553, 0.34024380456022263, 0.33956000088159055, 0.34038872799415154, 0.3166719153240072, 0.30936998794499126, 0.32753140917542567, 0.3431579174171727, 0.32774791545185156, 0.36058698665223554, 0.2294193398101736, 0.2587479412281922, 0.25467366269447433, 0.24278679418829918, 0.2568394523931943, 0.2581825757534898, 0.2600398636567225, 0.2722933495174338, 0.28022751613790375, 0.21327282151787064, 0.19031261130827481, 0.20540606764908853, 0.18529018003449937, 0.1729597441166385, 0.17039278051216988, 0.18853612602904402, 0.18873528357077496, 0.20248184386316925, 0.1910458429603592, 0.17545678755821958, 0.1925859509656418, 0.19587669129909424, 0.20256269031134455, 0.1908489875111803, 0.18596926121139146, 0.1808651312748354, 0.18125338808542113, 0.751638630391976, 0.35946995381427693, 0.5829889411297935, 0.7486677869976308, 0.5850814057328286, 0.530962683341056, 0.17164103488945315, 0.5409750286071472, 0.600057703106426, 0.19757171993474698, 0.5564391624361389, 0.49352357325741936, 0.18271780929994053, 0.16304752848891257, 0.573738125068592, 0.21043035620929562, 0.20618468089502862, 0.7198905069873496, 0.1866175253548944, 0.17314388843260642, 0.17660115465955872, 0.22258231096626924, 0.1985479566074253, 0.18753563670765072, 0.198080207737643, 0.19235712391378312, 0.17585246370018814, 0.0683633238349054, 0.08597979874353223, 0.06803460541224027, 0.07427273457745631, 0.06790040526275276, 0.08078851888754812, 0.07003680022006353, 0.0771745399899213, 0.07598023674115006]}, "mutation_prompt": null}
{"id": "55105e4c-8571-4d8d-9d4b-ae0746997360", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Slightly increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]  # Introduced a new strategy\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))  # Memory for elite solutions\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)  # Update memory\n                        self.memory[-1] = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > self.pop_size:\n                self.population += np.random.normal(0, 0.1, self.population.shape)\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveSwarmEvolution", "description": "An enhanced adaptive swarm-based evolutionary algorithm incorporating multi-strategy cooperation and adaptive parameter control for improved convergence in complex optimization landscapes.", "configspace": "", "generation": 10, "fitness": 0.4667401330397972, "feedback": "The algorithm EnhancedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "6ab3873a-5406-432a-b8aa-c91a4f44604f", "metadata": {"aucs": [0.8887990208664761, 0.882135162571395, 0.8800021827170379, 0.8761506347206214, 0.868222380265006, 0.8864329023024237, 0.8913978600084962, 0.8750883202622485, 0.8765122913967979, 0.7996012961433303, 0.7601016716676223, 0.7888110792742642, 0.7855303740170825, 0.767010600176205, 0.7633036346196941, 0.7550984325884691, 0.7534718586594246, 0.7306413298930718, 0.11426354317746368, 0.14984948741046922, 0.1412110245933469, 0.1426326180054348, 0.1594257653166884, 0.12449979711561154, 0.18038837275043984, 0.11347197788441155, 0.15612838417218278, 0.12550094127561806, 0.10945739091138607, 0.13966875000034684, 0.14330965223091663, 0.15470518578775094, 0.11090301128745794, 0.1321292251291759, 0.1305326748798774, 0.12977835988325948, 0.9588563301308358, 0.9770186442740255, 0.9743467497156041, 0.9737578768733234, 0.9741610860444347, 0.9272975939797221, 0.9776450727123396, 0.982760044823005, 0.9821691330955189, 0.6542824293404894, 0.6824741960136936, 0.6738386724176656, 0.6839644732548134, 0.6260005901840742, 0.6897288039222864, 0.7317847824692857, 0.6887781922849043, 0.6887369371519623, 0.8351970587126109, 0.875108395002298, 0.8279747606600489, 0.8306204543740361, 0.2775736778920266, 0.8418335463365642, 0.23135706770400022, 0.8697675898176287, 0.8781427558078928, 0.6295696295708102, 0.39798133497523736, 0.5134179201182463, 0.6893883057950579, 0.5306827479956866, 0.5071174247715582, 0.6321299315750546, 0.6637498639689239, 0.5969235338312533, 0.6566505698967497, 0.6447785649575509, 0.714962182719847, 0.7228313929938426, 0.13339036920185665, 0.6045212512378936, 0.6863968198289694, 0.5674262720241092, 0.6663937293582061, 0.5689954142829856, 0.6794775272129433, 0.48255955287564556, 0.5687348770383682, 0.6750965305818859, 0.35107950932787513, 0.6213507276127914, 0.6451627041431374, 0.7444017700211563, 0.7373715200245796, 0.6831618487934314, 0.6865000124629842, 0.723743323515186, 0.719751825783786, 0.7172998690174345, 0.7395329207765633, 0.747945846350171, 0.7109113231090456, 0.29082023606376217, 0.3466787271450621, 0.16198636137468492, 0.3264878524654523, 0.2784305243962333, 0.49091744599354814, 0.3255831859623405, 0.11530709287258256, 0.26202152785058264, 0.4697473968100043, 0.3880540303094141, 0.5238892526408816, 0.545055872844695, 0.44738561912084274, 0.5929907507949895, 0.5026079615960085, 0.37298318306894607, 0.4592218261718608, 0.8322479347175425, 0.815745291982929, 0.7399032663152292, 0.8072262586434633, 0.815657488970593, 0.8128097242311388, 0.8525446608487148, 0.8220797173290308, 0.8096155156740124, 0.13917028473674964, 0.12471174269749064, 0.17627898241884454, 0.5774318261383671, 0.12396001903852538, 0.13929051895540467, 0.13022057784617025, 0.13162501648839264, 0.13294710850323954, 0.14728306609773933, 0.24510424869663905, 0.13069900171050408, 0.15419218442051263, 0.16133995827511893, 0.16445383669192093, 0.1483792807569686, 0.1446792451925949, 0.16612655515333807, 0.2641402037919117, 0.3894551489281699, 0.4250233762847102, 0.49089102624268444, 0.39726352947187815, 0.5170763738591784, 0.5689279377013869, 0.5450131351881142, 0.5809962388397318, 0.23127781644827672, 0.3509451623749118, 0.391782707077048, 0.25943151429857925, 0.2866780169671962, 0.2981829637352025, 0.24747332922890863, 0.4601995568790066, 0.3886995786532508, 0.2648401424922545, 0.2030234070859971, 0.23576133661119658, 0.2523432427212944, 0.1908377636755647, 0.2220177194398969, 0.23986492188937003, 0.24177229180347648, 0.257529130031969, 0.7026961156969743, 0.24027957033238279, 0.18618517976657412, 0.24143824432448668, 0.19535144842235275, 0.18956068592799458, 0.23608728010716973, 0.5325753545555545, 0.19978948927938367, 0.8915835420130211, 0.18666305960378649, 0.8862569774603997, 0.1935462299211923, 0.16611504841989977, 0.8990703216559006, 0.8785044686796355, 0.1662280669913293, 0.20301933008316642, 0.8774205088368929, 0.2086551337733813, 0.8254287570021093, 0.2101210258070304, 0.8107340497843116, 0.20966334706663214, 0.1553034077062765, 0.1657364678112162, 0.16497668423950052, 0.18189805717151353, 0.18794372711089313, 0.18247370575192423, 0.18633362584999313, 0.18654336495665735, 0.18468541467964283, 0.1786367664499885, 0.18275707264222096, 0.1905696612752441, 0.07808480138146223, 0.12418982073702589, 0.09745276848028739, 0.07633505307829547, 0.09692574628654416, 0.09708645323016896, 0.07622563302414131, 0.07865615777308088, 0.09600832300690998]}, "mutation_prompt": null}
{"id": "b6dd4de6-bc13-46d0-8e9d-ab6d8b7bd4fd", "solution": "import numpy as np\n\nclass DynamicAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.35, 0.35, 0.3]  # Diversified strategy probabilities\n        self.mutation_factor = 0.85  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.memory = np.zeros((5, self.dim))  # Memory for elite solutions\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.4, 0.3, 0.3]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.4, 0.3, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)  # Update memory\n                        self.memory[-1] = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > self.pop_size:\n                adaptation_factor = 0.05\n                self.population += np.random.normal(0, adaptation_factor, self.population.shape)\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicAdaptiveSwarmOptimization", "description": "A dynamic adaptive swarm algorithm with memory-enhanced mutation and strategic diversification for robust global optimization.", "configspace": "", "generation": 11, "fitness": 0.4273671184805201, "feedback": "The algorithm DynamicAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "55105e4c-8571-4d8d-9d4b-ae0746997360", "metadata": {"aucs": [0.9167677505099505, 0.9121866675170813, 0.9127072797435076, 0.8935432607998296, 0.9136793279075872, 0.9228553998205539, 0.9214569402247675, 0.9014001550259239, 0.9078437791586438, 0.8276333117739917, 0.7873877369035654, 0.8178970684800855, 0.8305466496097057, 0.8000502537863134, 0.831529862845409, 0.8169870569063005, 0.8097096657756018, 0.7883340152152949, 0.15758130716217167, 0.12136790462998337, 0.1578811576121809, 0.13183243092071584, 0.6667794055023435, 0.1281135499737044, 0.1503394007425406, 0.16122650727227705, 0.12744946202342633, 0.12247496627951582, 0.10507503408073404, 0.13578578275113173, 0.14265329774185775, 0.14587126618563928, 0.1393460283450655, 0.12006299735903936, 0.1661077385092432, 0.13758047521012884, 0.9792369039063156, 0.9784403392410908, 0.9767907500937457, 0.9620217315102595, 0.976910649304023, 0.9891314807873272, 0.9672694047964222, 0.9559120725539174, 0.9675464123818478, 0.6834303599226862, 0.7166815325875286, 0.7494116210546125, 0.7562443452741707, 0.7254294150642159, 0.7590640616653892, 0.7228720763007075, 0.7694196196393221, 0.7326502974100295, 0.22689207266897815, 0.25243058968844556, 0.22683764436532816, 0.21406809348196898, 0.19272279900663747, 0.9463573556964712, 0.8472331945128432, 0.8763217283150793, 0.17738985994443246, 0.5382505814268845, 0.5830505769535053, 0.6905717272759906, 0.6142909396447052, 0.5509476407689832, 0.5746214264565959, 0.6052627497497469, 0.733918895177944, 0.628534182556584, 0.6640008451920432, 0.5624714467609382, 0.5620776705508741, 0.7373945342327142, 0.6622939630729482, 0.46075675396790405, 0.6613876505057704, 0.6708084560419016, 0.724638129416151, 0.30507851241103623, 0.5010757408402289, 0.32091955791569426, 0.032906520075675294, 0.4257821944112812, 0.13349349075088834, 0.4894895591786983, 0.5286689748353959, 0.4903592937405723, 0.606603990445891, 0.6027541394866784, 0.5697600597512414, 0.568299012629206, 0.41557404952469756, 0.6503317340895014, 0.6650031592161361, 0.6721709097050516, 0.22970742224780683, 0.06813173983767751, 0.2787274413969304, 0.20132239689708642, 0.2874283974209233, 0.30668917875415036, 0.32729815765602455, 0.1547486341098242, 0.15025080678138525, 0.26336894385157594, 0.28727195144179696, 0.29398076032681975, 0.30056365767557924, 0.4573655325001569, 0.43585104239900385, 0.4312010793107405, 0.40988385137771843, 0.3978601752578129, 0.23886636966939545, 0.8222692408613906, 0.7826724983716778, 0.7621267833474339, 0.7428358246378561, 0.8040024957295505, 0.7712640632979424, 0.6624774736844941, 0.8095909012855961, 0.8222510741894078, 0.15900040055359654, 0.09098326061293482, 0.12836188338446664, 0.14913785527911916, 0.14318813680485798, 0.11178282280795615, 0.09666311324282872, 0.11023281180819466, 0.1200747083128425, 0.1833229462496314, 0.1596580980162049, 0.23015978386150004, 0.13539919262704392, 0.1736395390612564, 0.171823879203154, 0.15048862403423446, 0.1687263396797245, 0.16473129605463732, 0.2896938304894494, 0.3890203400810516, 0.4606493632243339, 0.3124004343425545, 0.3564876073308624, 0.4796170789507711, 0.4471265250616253, 0.3178463676466474, 0.37357053001833396, 0.2818854609031899, 0.2724792438850534, 0.33081569872185923, 0.38394838629154426, 0.2650030118984963, 0.21842333772917555, 0.24426323335801403, 0.26616095102182, 0.2714720494252406, 0.2766912553570354, 0.24659818951034196, 0.26388740687949774, 0.20153485007845828, 0.27475211313971637, 0.22140381001790355, 0.26298195314514505, 0.1923855124582472, 0.2466654244519123, 0.19425122281857932, 0.22701947341248907, 0.172899359037335, 0.17944251858373594, 0.19710416998797164, 0.1895391372016998, 0.18848845579356144, 0.5489448158147175, 0.21046125929139503, 0.18673801822108793, 0.18858655815069691, 0.18642839353526552, 0.1767710784270483, 0.16840246712327356, 0.1689155379155487, 0.8776096661328886, 0.21250650731211196, 0.16738011527285923, 0.8516651576811045, 0.21288827197124027, 0.9133500763133544, 0.21048740575520064, 0.16686622040373755, 0.8725371335424288, 0.8320178243588854, 0.8296803215613533, 0.16521514987552433, 0.18924649331510823, 0.1764704083015709, 0.18329440482172676, 0.18142384365598352, 0.18209878213439812, 0.18960053873342197, 0.17945066019965739, 0.18582729883899618, 0.17361142902096582, 0.0860256671833457, 0.1010121164201957, 0.10654737973669304, 0.07936048303562271, 0.0968057465379466, 0.10167615442113198, 0.08274995777473637, 0.0813439998670763, 0.08109898672877902]}, "mutation_prompt": null}
{"id": "c4167292-3912-457e-ad66-c16b1c8c62fb", "solution": "import numpy as np\n\nclass RefinedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))\n        self.elite_memory = np.zeros((3, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        adjust_factor = 0.05\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs[0] += adjust_factor\n                self.strategy_probs[1] -= adjust_factor\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs[1] += adjust_factor\n                self.strategy_probs[0] -= adjust_factor\n        self.strategy_probs = np.clip(self.strategy_probs, 0.2, 0.6)\n        self.strategy_probs /= np.sum(self.strategy_probs)\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.elite_memory = np.roll(self.elite_memory, shift=-1, axis=0)\n                        self.elite_memory[-1] = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > self.pop_size:\n                self.population += np.random.normal(0, 0.1, self.population.shape)\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedAdaptiveSwarmEvolution", "description": "A refined adaptive swarm evolutionary algorithm utilizing elite memory, adaptive mutation, and dynamic strategy weighting for enhanced optimization performance.", "configspace": "", "generation": 12, "fitness": 0.3264445216209329, "feedback": "The algorithm RefinedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.23.", "error": "", "parent_id": "55105e4c-8571-4d8d-9d4b-ae0746997360", "metadata": {"aucs": [0.7090586131050347, 0.6759479888262756, 0.6812802674858596, 0.667097568712639, 0.6716463241953359, 0.6633420538883272, 0.6602019506414952, 0.6750640917720917, 0.6753417858936093, 0.45056125625360544, 0.4104066304714221, 0.4453227659398834, 0.3943554925744178, 0.4421710881044708, 0.42235695042345267, 0.4025653082867592, 0.38408461088600176, 0.41477149399349145, 0.10252572273617266, 0.09444558342926901, 0.11151506600519645, 0.10322135198652072, 0.11239819895019953, 0.09372580051476276, 0.09853102415731896, 0.0966920375762802, 0.0918596209551581, 0.09975839688275245, 0.09287701771007817, 0.09489529952034281, 0.09052838818442721, 0.0928612062296339, 0.08911055556112701, 0.08662159815895099, 0.0861278119992297, 0.09520202929393906, 0.9872304520855995, 0.9621576271986509, 0.9849542191196834, 0.9719642604537129, 0.978883307449564, 0.9590001234532524, 0.9808143715425178, 0.980933373663475, 0.9879304747494545, 0.3137636861120334, 0.32782010858493194, 0.30633619820995683, 0.3688019968795676, 0.35154099032998176, 0.3148424914667527, 0.3159319501320975, 0.30308804413286594, 0.3385890212133078, 0.7623252746619296, 0.7651514948761905, 0.6710151863446516, 0.606030396372284, 0.627103601271187, 0.5851382407342424, 0.5783244431552812, 0.6362816775703897, 0.6222466013393488, 0.2904912822242731, 0.34704238275223975, 0.313117950478611, 0.2879107129785655, 0.32223695262897134, 0.2805298216580141, 0.29838422855802327, 0.3185903252409765, 0.2887671276291114, 0.4531178572644736, 0.4637136076916437, 0.4506586733901047, 0.47145881832705516, 0.4615969650567202, 0.44646955978140657, 0.42944766633486153, 0.4433283908225445, 0.43661549244723474, 0.1852207422116029, 0.16158034956362333, 0.19977583920684627, 0.24001395053030072, 0.16565807225357398, 0.20917403355603303, 0.2717995185166042, 0.26848713259839074, 0.2542570459869745, 0.30269268844280384, 0.3068807825845321, 0.30406622201429, 0.32749474586512184, 0.3117980956283918, 0.3202347278821518, 0.3546752385334466, 0.3510856289186426, 0.32999313119136187, 0.07649570051333243, 0.051469046157067155, 0.022977530413607394, 0.0916108611382086, 0.09113852432085423, 0.08610748054831929, 0.06044630208716206, 0.07277916417322416, 0.05729695268920987, 0.203820032908836, 0.17410043449802948, 0.186396964075358, 0.1943353903301589, 0.20519407127397837, 0.19908744914580634, 0.19409965462525847, 0.20600771988075606, 0.16710767092311107, 0.5363117901389245, 0.529838620424521, 0.5264073485023594, 0.5431776180448725, 0.548009935099613, 0.5321896289536745, 0.5642864076018583, 0.5421118846548241, 0.5609797518514669, 0.09112045305146799, 0.10133476011343678, 0.08608471595973555, 0.09335001331803672, 0.09093123445370244, 0.07825698543074922, 0.0888006072332368, 0.09300237903060482, 0.08904839870379999, 0.1539241318510416, 0.15105792293111409, 0.13711758408097086, 0.14489165744771126, 0.1270993008927479, 0.12444889841268636, 0.14320674221303398, 0.13630385584652127, 0.1706739821504656, 0.31025771645652844, 0.3234703290203861, 0.2951665649973182, 0.3183751261906258, 0.3468644051038522, 0.3469025315303438, 0.3201387345761004, 0.3278276468788579, 0.339075794148058, 0.2504893491342275, 0.2416867103406818, 0.2257500369266292, 0.24830781384398026, 0.22833166904009172, 0.26433413722534926, 0.251981337934033, 0.2593774109662471, 0.22065957627332733, 0.264293584619229, 0.22405287204240731, 0.2713413429310092, 0.28454741807374817, 0.25406931290619406, 0.2542454226750327, 0.25977566889143877, 0.25250873924994033, 0.265135134545316, 0.18965444243677898, 0.18183188400306682, 0.18691689903527553, 0.18126586348558626, 0.20160884546904723, 0.20201997312397302, 0.1848959475621469, 0.22707928431401958, 0.17804425908653376, 0.7752912865973584, 0.7836014259216241, 0.6721408778918871, 0.4465096350033495, 0.6093846224135433, 0.6822862122570019, 0.6319611697079821, 0.5334971164310016, 0.2505658897584493, 0.6833522090837829, 0.20417999002047071, 0.4990245043972348, 0.20360859524535746, 0.2025975028059761, 0.5116098647058731, 0.457593839937804, 0.15330603696312284, 0.5026986308721209, 0.17657463088862224, 0.1716588550293694, 0.18517090849075846, 0.18590753875554522, 0.17796286246773674, 0.18921271285853003, 0.17721799068971889, 0.17529298562884355, 0.18598577395608518, 0.07898627619316034, 0.07551970546443976, 0.07415515657851013, 0.0843635557256639, 0.10712259206281671, 0.072791813931124, 0.08458274643567565, 0.07374300464320716, 0.09079848201696605]}, "mutation_prompt": null}
{"id": "87abd75f-3337-47e3-a0c6-02cc457ab562", "solution": "import numpy as np\n\nclass DynamicAdaptiveSwarmOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 15 * dim  # Increased population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]  # Adjusted strategy probabilities\n        self.mutation_factor = 0.85  # Adjusted mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.memory = np.zeros((10, self.dim))  # Increased memory size\n        self.memory_weights = np.linspace(0.1, 1.0, 10)  # Memory weights for influence\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.choice(len(self.memory), p=self.memory_weights / self.memory_weights.sum())\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.3, 0.25]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.3, 0.3]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.4, 0.25]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > 2 * self.pop_size:\n                self.population += np.random.normal(0, 0.2, self.population.shape)  # Increased adjustment magnitude\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicAdaptiveSwarmOptimization", "description": "A dynamic multi-strategy population-based optimization algorithm integrating adaptive memory management and stagnation-driven adjustments to enhance exploration and convergence.", "configspace": "", "generation": 13, "fitness": 0.4149231457380264, "feedback": "The algorithm DynamicAdaptiveSwarmOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "55105e4c-8571-4d8d-9d4b-ae0746997360", "metadata": {"aucs": [0.8590895872643437, 0.8541234564441638, 0.8245623976147716, 0.855713346006599, 0.8446894910702046, 0.8475657076476719, 0.8656716346465653, 0.8444833966166222, 0.839324310754767, 0.7302871964550132, 0.7240242177419268, 0.7424789934697504, 0.7355748660596864, 0.7129054521615291, 0.7278077388290188, 0.7247223548207187, 0.6914133788894787, 0.6460871778376297, 0.1509585628697252, 0.16162460725897232, 0.16577998634415414, 0.1175014711609228, 0.17690386049600126, 0.6874232380062183, 0.1424317929461728, 0.13151620548942444, 0.14733996736658828, 0.11131852682778098, 0.11724391214290464, 0.13967248628668527, 0.13645738126348916, 0.14805239375966828, 0.10682169690582954, 0.11142495977551703, 0.12480382790267308, 0.1140457677269282, 0.9727078669271557, 0.9839808285171309, 0.9478579056613592, 0.9694157547687547, 0.9663593084299656, 0.9717118326392298, 0.9827355319486121, 0.9572347873711042, 0.9724573095695314, 0.5814940730282382, 0.6301315578523452, 0.5511261290433715, 0.5561868227566948, 0.5559509758667467, 0.5516512330583607, 0.5948814505357654, 0.6077159689926481, 0.5607901381287503, 0.8479941287250727, 0.16979131302601347, 0.7675830948254366, 0.2712627339288598, 0.8382452691660096, 0.27189205148646256, 0.23056493912579268, 0.23680294664989465, 0.7807801870195643, 0.6173122465004203, 0.48302777449752565, 0.5584894025280869, 0.12995487108298986, 0.62440498134824, 0.4740606948113787, 0.41812513535435414, 0.5380240019140656, 0.41349949332014957, 0.6367630121381023, 0.46989574372458975, 0.5869377689202193, 0.589147649384141, 0.49219799729659386, 0.6648936508768319, 0.5606883371503768, 0.6006250850604963, 0.5436443816416159, 0.34360224031944475, 0.2706282589405621, 0.44172992446690973, 0.37769578544814975, 0.3690900148312718, 0.4759636887465918, 0.4833944153629648, 0.4260716411374862, 0.4925104643410234, 0.6383632871030213, 0.5636518723815049, 0.38959391941995725, 0.5531192173167261, 0.6001441424884719, 0.5631327631968537, 0.5932008781900692, 0.6379298263934179, 0.558832569001599, 0.08700430486219846, 0.08563636320236423, 0.21653577256852563, 0.21944397798278714, 0.3608109813556223, 0.22790158724558818, 0.225290853241511, 0.08323829987818665, 0.13084240590806862, 0.3227348734766793, 0.342807218236988, 0.3500273259352641, 0.3485352786651088, 0.39662387166173374, 0.3446923893916459, 0.33106062810066994, 0.2804026635625362, 0.2509479124293059, 0.7496313343398322, 0.7562288975553795, 0.7069801382180286, 0.7634408071535039, 0.7385325410878442, 0.737291670047185, 0.7530808169797016, 0.7476184757607671, 0.7366988817995783, 0.12081830655224424, 0.13728758238802563, 0.11457784427760687, 0.16361615050533906, 0.14046875930066638, 0.132898518815731, 0.1521716000351, 0.10935739559966096, 0.1744459899910007, 0.16898385023918894, 0.1626045679384761, 0.12061439407646046, 0.15288630836571415, 0.2870563981738805, 0.20339670113967057, 0.16395972754234045, 0.24590288747164213, 0.17744733830197024, 0.4426433935122994, 0.45478442546482667, 0.4180299946972169, 0.32394737902933135, 0.3167126664376967, 0.38771782863028625, 0.45663755109311854, 0.4590947818606683, 0.49944998711749244, 0.2962277097701119, 0.3664096866696035, 0.260627965808808, 0.34271326931524226, 0.32218272311859264, 0.3425934262064627, 0.21974489527761498, 0.26340413097823323, 0.33415318955349527, 0.2461974938174829, 0.21034196776029324, 0.26837133225930954, 0.2414755686816652, 0.24926167511133668, 0.24309448281655122, 0.19446044510041327, 0.2057495113265836, 0.24960861340336005, 0.2055713051253344, 0.193707736188946, 0.19028379598228062, 0.19967193562877894, 0.22004731314956727, 0.1970676876972357, 0.21590543622587544, 0.18065106257005903, 0.21167362265641154, 0.1870440198625013, 0.18553633174599127, 0.1833624015716313, 0.18515476245173557, 0.1966523540858265, 0.838628443203379, 0.19223019698186938, 0.14550793626876002, 0.20871900110899366, 0.20895987297325413, 0.8417002807358981, 0.8240308475967857, 0.7447171664928969, 0.8275816338398831, 0.7346812497830414, 0.8047290092514953, 0.8498855610213211, 0.8528956000144736, 0.18433366777873494, 0.19459105753340078, 0.17954005930135186, 0.17466313942514022, 0.1788723323238195, 0.17413160349810808, 0.1863889354760736, 0.17836334628892858, 0.1821473500518498, 0.08138088177115554, 0.08792084405739098, 0.07909823099991176, 0.08233925924447305, 0.07955270658123681, 0.09776255201185757, 0.07560870840680323, 0.08303226996565405, 0.08740665975897977]}, "mutation_prompt": null}
{"id": "233b299f-0bbf-4514-a274-8d18185a8d5c", "solution": "import numpy as np\n\nclass DynamicSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Adjusted population size for balance\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.3, 0.4, 0.3]  # More balanced strategy distribution\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))  # Reduced memory for faster adaptation\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.35, 0.3]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.35, 0.35]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.35, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.3, 0.35]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > self.pop_size:\n                self.population += np.random.normal(0, 0.05, self.population.shape)  # Tuned exploration\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmEvolution", "description": "A dynamic swarm-based evolutionary algorithm integrating elite memory, adaptive mutations, and strategy diversification to enhance exploration and convergence.", "configspace": "", "generation": 14, "fitness": 0.4297146632476838, "feedback": "The algorithm DynamicSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.", "error": "", "parent_id": "55105e4c-8571-4d8d-9d4b-ae0746997360", "metadata": {"aucs": [0.913885146282401, 0.9089131728551136, 0.9310752809772902, 0.9109430801251175, 0.8974881317364064, 0.9329118978982656, 0.9234970067717564, 0.933531415071572, 0.9213883725765475, 0.8371119757117367, 0.8035262968479157, 0.8142184614542557, 0.8513607692467098, 0.8411558020996497, 0.8180600536604175, 0.830411599778411, 0.8395943141943651, 0.8010035337789221, 0.18516567738187695, 0.1516361136216905, 0.118346791653125, 0.7369149739195029, 0.14706015291985242, 0.11900159765206442, 0.099561143008426, 0.1346627287011115, 0.15505810526804364, 0.12986893895429696, 0.1041159761289846, 0.15585405569750677, 0.1210556800225484, 0.10319480641368683, 0.10807282376041438, 0.14316542306097513, 0.11620149351494291, 0.09682178231707816, 0.9494592721659975, 0.983944300927016, 0.97807379052683, 0.9642833499482334, 0.9573318616397173, 0.9884610090935895, 0.9810948865176916, 0.9716841811543806, 0.9790268875040083, 0.7481370488482713, 0.7610396573726229, 0.760238593991057, 0.7657254522691676, 0.781264043417617, 0.7740496295640504, 0.7526013848669335, 0.7719991184430831, 0.6534008775575162, 0.6421086875489469, 0.39317963791148236, 0.8981779391798955, 0.28111478091021436, 0.27339093944831416, 0.3859767662933066, 0.24093632556660605, 0.23892992798371404, 0.8362142927369519, 0.6570901078870328, 0.6574287566161119, 0.6648778824509183, 0.542970623921648, 0.6219443655105927, 0.5635861607055092, 0.6341167902678055, 0.5690437272692265, 0.5406073983501274, 0.6309897364133127, 0.7756412170567656, 0.13730011699232147, 0.5844791974621093, 0.758495497852837, 0.5228913038451155, 0.6565541170961819, 0.7086398147011826, 0.606180595560255, 0.3133456334592324, 0.1517401492089845, 0.42042142662131277, 0.062111121444256234, 0.19671783456423564, 0.18403539967022975, 0.5944405904165594, 0.3499751679197515, 0.3110971980185899, 0.48786874284224346, 0.5782386433860294, 0.10456677932136316, 0.4770907202767286, 0.16089984920991685, 0.22797245743299277, 0.6248799487427363, 0.3646129638508383, 0.6399444771518554, 0.25692174292438064, 0.24112376738810615, 0.22848307325080963, 0.409635220011454, 0.2826646000927725, 0.4926870277256705, 0.1746466130240134, 0.17387754618801432, 0.13714336190566412, 0.22387899283621837, 0.1848838703077722, 0.20382421753116298, 0.4215750486213634, 0.15403494880963575, 0.4024009861504829, 0.3354840291917288, 0.16078065634548333, 0.23925141150679496, 0.7574488159453756, 0.81580867861728, 0.7932589105010509, 0.8408566777563888, 0.823699212702089, 0.7157942461353737, 0.8111730523536065, 0.7796391698835304, 0.8066771079340118, 0.14389137463120838, 0.10303441950388192, 0.11781467335120765, 0.15578858841037235, 0.11554167394394621, 0.07209190012498823, 0.12385710805769035, 0.11717441796848671, 0.14331816579680923, 0.16748626041175707, 0.1675388896297514, 0.15377304812876225, 0.29412407661090023, 0.2620256991243788, 0.14775316166281882, 0.1761574082555437, 0.18168523820803417, 0.15376275068374068, 0.3998718153511769, 0.44898850811547864, 0.36266699457551754, 0.3431675339474455, 0.2894789763397033, 0.3456070242684156, 0.31256035734575704, 0.33007958825984474, 0.3157238065706086, 0.28699479088200264, 0.3247989448945875, 0.2651604725297496, 0.2522632285547093, 0.2518009079684562, 0.21664171477237093, 0.28942111363256184, 0.25901204861041216, 0.1923021008657435, 0.2349218211848071, 0.21862771611197063, 0.24378994215055672, 0.27639461141684785, 0.2003137612667918, 0.22026923502653795, 0.26909328376530905, 0.2422047140713134, 0.24115054173541461, 0.18951656576592735, 0.20633245151612356, 0.19587713014353303, 0.2450654073705285, 0.2009031661312255, 0.17061490037930183, 0.19166238767239474, 0.18968449825547407, 0.17715486495232835, 0.9557636557195934, 0.1569882769236588, 0.17747216780350517, 0.9408350404024147, 0.19954351305250007, 0.9350140167691461, 0.9274499297958908, 0.16825839878724969, 0.8983126357824389, 0.8623968026696025, 0.870353715133896, 0.8334172407073765, 0.8987148934197879, 0.16555372929098866, 0.7567062792358845, 0.20376256596721032, 0.7348704340511414, 0.21259672136266428, 0.17827799024555047, 0.1798354238136799, 0.18680857919112004, 0.1780149165248862, 0.18111556724468936, 0.1994201119574739, 0.17936676871569635, 0.19045921986379166, 0.21005752379773435, 0.09154015374656033, 0.08090673392620396, 0.07500082379647488, 0.08314301045307215, 0.06600665599630318, 0.08332619903083904, 0.08903156271836943, 0.08314455288965694, 0.08983695222009902]}, "mutation_prompt": null}
{"id": "26014ae0-8fc5-47c3-b15f-20087a3944ec", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Reduced population size for faster adaptation\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]  # Adjusted strategy probabilities\n        self.mutation_factor = 0.7  # Tuned mutation factor\n        self.crossover_rate = 0.8  # Lower crossover rate\n        self.memory = np.zeros((3, self.dim))  # Smaller memory for elite solutions\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'best_2_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'best_2_bin':\n            indices = np.random.choice(self.pop_size, 4, replace=False)\n            x0, x1, x2, x3 = self.population[indices]\n            mutant = self.best_solution + self.mutation_factor * (x1 - x2 + x3 - x0)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.6, 0.2, 0.2]\n            elif strategy == 'best_2_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.3, 0.3]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.4, 0.3, 0.3]\n            elif strategy == 'best_2_bin':\n                self.strategy_probs = [0.5, 0.2, 0.3]\n            else:\n                self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def optimize(self, func):\n        evaluations = 0\n        stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)  # Update memory\n                        self.memory[-1] = trial\n                        stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                stagnation_counter += 1\n            else:\n                stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            if stagnation_counter > (self.pop_size // 2):\n                # Introduce a random restart mechanism\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n                stagnation_counter = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridDifferentialEvolution", "description": "A hybrid differential evolution algorithm combining dynamic adaptation of strategy probabilities and random restarts to escape local optima and enhance global exploration.", "configspace": "", "generation": 15, "fitness": 0.4593927948701818, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "55105e4c-8571-4d8d-9d4b-ae0746997360", "metadata": {"aucs": [0.9122923288781017, 0.9052191715854851, 0.9043334266617502, 0.9080840218407781, 0.9118708709902781, 0.9113853387788498, 0.9016422596630285, 0.9097623970551374, 0.9003041784464945, 0.8322097365019383, 0.829982226108151, 0.7902979756638919, 0.8075123874498481, 0.8152530474409817, 0.8172415433775484, 0.8151621176094139, 0.8228322296576052, 0.7739393699944472, 0.3103448033509091, 0.14441753996283224, 0.6830622839146592, 0.1789808342716297, 0.370122798835837, 0.14104148424622887, 0.17145313797209216, 0.1474398983789772, 0.43395293087426834, 0.13514307971840012, 0.143147649074716, 0.14175901412851677, 0.17876478247760585, 0.11783962268161718, 0.15819342124111846, 0.1183969575182433, 0.1353721444676821, 0.1387065563363511, 0.9761333080531941, 0.9284202193097673, 0.9924988576314792, 0.9783592506569826, 0.9589347830089829, 0.9872669691053666, 0.9708778355283944, 0.9744807594711512, 0.9840963519185599, 0.6870694052410375, 0.7390874002994974, 0.7624531867654043, 0.7243665967080117, 0.7680122469486917, 0.7303533570655905, 0.7536537480408219, 0.7419385047738014, 0.7253860539678039, 0.885875128529943, 0.22928680127751722, 0.7323109235842946, 0.8806003159553986, 0.9171752663576989, 0.21338356608750808, 0.46810378440027567, 0.9265700888898131, 0.877960287618886, 0.5546939587827788, 0.625896941883275, 0.5443619370141681, 0.6269865851154272, 0.5303112484257768, 0.5749177398625864, 0.5694182309223259, 0.5792036044463602, 0.5441116640655583, 0.13427234827438805, 0.5077518578664783, 0.7075044255407188, 0.4779113813899025, 0.5811376826516577, 0.5974419938755001, 0.6629948993342718, 0.5303821418349847, 0.5188234222970145, 0.4683407618218719, 0.17398283797685177, 0.5782443929682008, 0.4703679546597723, 0.5555398782788366, 0.20302194034809384, 0.24391827525804433, 0.3392204539870832, 0.21375406501061955, 0.6813389944724497, 0.6149552324974468, 0.5918835286965205, 0.6100561503845556, 0.6292675976205826, 0.6539281273902635, 0.6171365499201249, 0.6237748630762898, 0.5421469710928108, 0.1623973983533309, 0.15283639409529692, 0.2343608624832867, 0.29057236910874507, 0.16345385708840565, 0.24526931719305312, 0.21132369585604915, 0.24469041546855297, 0.1341426498944568, 0.30260622682980554, 0.3398000301360423, 0.36552686161234704, 0.2644328488376779, 0.38275574010429847, 0.41605499437313864, 0.29826031607009607, 0.41612287052814934, 0.24401594969057583, 0.8342203666756585, 0.7840269045101058, 0.8337930615308669, 0.7296408100710817, 0.7627364335220025, 0.7750329525856965, 0.8249237093335945, 0.804115914332562, 0.7465817004164077, 0.15739659407780893, 0.31291502370378543, 0.12197293102099449, 0.13252722502474934, 0.11614368738970882, 0.12149262743419353, 0.10444751287690601, 0.1235478049005353, 0.1367808854344339, 0.16072279883107565, 0.13407912008858436, 0.20930059682940705, 0.19560282563313236, 0.1602383761957331, 0.16329493232162695, 0.15373210193976883, 0.18212869433987766, 0.21634451536700627, 0.3708141170093512, 0.32998573630871775, 0.4594920655495215, 0.49343155513814985, 0.5146611256996836, 0.3784853923013777, 0.5067386973327864, 0.6072186289154753, 0.4525018914531064, 0.35068659001310476, 0.32123329944085166, 0.301941782199423, 0.30633479940100916, 0.4017707600155762, 0.388109758934415, 0.37052690748599193, 0.24195750407201932, 0.20678806050114285, 0.22456759188022657, 0.22666010776369394, 0.22803884598506097, 0.20444278741615252, 0.2376430543984045, 0.23958012724047306, 0.20673546552196587, 0.20143842277976076, 0.21543567113139228, 0.2120347570340284, 0.20537918869648242, 0.21961264539285585, 0.6605092481626105, 0.20197829339562512, 0.1899074254680071, 0.43094764827907905, 0.2007016841692637, 0.23532923902675684, 0.9343362709245078, 0.8966066148644762, 0.18684038354276167, 0.9085877665575688, 0.8161973357609309, 0.16462770767237056, 0.8827988173140463, 0.19860019430722708, 0.912547680740719, 0.16518439085420633, 0.9153450197516155, 0.8450760856205611, 0.2064398496333808, 0.7956156379826637, 0.8314427552804454, 0.20921274469647633, 0.819851049731678, 0.20509831744254148, 0.17198321944599615, 0.18308152811302758, 0.18401251639472382, 0.17057394872494025, 0.19733581978901205, 0.17817667139008175, 0.17868878213368278, 0.19017934105202594, 0.1872781191780989, 0.07869576657909239, 0.0887704393186044, 0.0842229664595805, 0.08729446420511411, 0.0860383169569946, 0.09964943987375607, 0.08510213892018659, 0.07579430716772462, 0.08645430055941383]}, "mutation_prompt": null}
{"id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.2\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveSwarmEvolution", "description": "An enhanced swarm evolution algorithm integrating adaptive multimodal learning and restart mechanisms for diverse and robust optimization.", "configspace": "", "generation": 16, "fitness": 0.46845211376986967, "feedback": "The algorithm EnhancedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "55105e4c-8571-4d8d-9d4b-ae0746997360", "metadata": {"aucs": [0.8887990208664761, 0.882135162571395, 0.8800021827170379, 0.8761506347206214, 0.868222380265006, 0.8864329023024237, 0.8913978600084962, 0.8750883202622485, 0.8765122913967979, 0.7996012961433303, 0.7601016716676223, 0.7888110792742642, 0.7855303740170825, 0.767010600176205, 0.7633036346196941, 0.7550984325884691, 0.7534718586594246, 0.7306413298930718, 0.11426354317746368, 0.3792967645477765, 0.15480840383483552, 0.1426326180054348, 0.1594257653166884, 0.12449979711561154, 0.18038837275043984, 0.11347197788441155, 0.15612838417218278, 0.1253585294767945, 0.10945739091138607, 0.16285216771680355, 0.14405065827995367, 0.1540056850848308, 0.10814973313787835, 0.1321292251291759, 0.12761594222088313, 0.129062800687184, 0.9588563301308358, 0.9770186442740255, 0.9743467497156041, 0.9737578768733234, 0.9741610860444347, 0.9272975939797221, 0.9776450727123396, 0.982760044823005, 0.9821691330955189, 0.6542824293404894, 0.6824741960136936, 0.6738386724176656, 0.6839644732548134, 0.6260005901840742, 0.6897288039222864, 0.7317847824692857, 0.6887781922849043, 0.6887369371519623, 0.8351970587126109, 0.875108395002298, 0.8279747606600489, 0.8306204543740361, 0.2775736778920266, 0.8418335463365642, 0.23135706770400022, 0.8697675898176287, 0.8781427558078928, 0.6295696295708102, 0.39798133497523736, 0.5134179201182463, 0.6893883057950579, 0.5306827479956866, 0.5071174247715582, 0.6321299315750546, 0.6637498639689239, 0.5969235338312533, 0.6566505698967497, 0.6447785649575509, 0.714962182719847, 0.7228313929938426, 0.13339036920185665, 0.6045212512378936, 0.6863968198289694, 0.5674262720241092, 0.6663937293582061, 0.5689954142829856, 0.6794775272129433, 0.48255955287564556, 0.5687348770383682, 0.6750965305818859, 0.35107950932787513, 0.6213507276127914, 0.6451627041431374, 0.7444017700211563, 0.7373715200245796, 0.6831618487934314, 0.6865000124629842, 0.723743323515186, 0.719751825783786, 0.7172998690174345, 0.7395329207765633, 0.747945846350171, 0.7109113231090456, 0.29082023606376217, 0.3466787271450621, 0.16198636137468492, 0.3264878524654523, 0.2784305243962333, 0.49091744599354814, 0.3255831859623405, 0.11530709287258256, 0.26202152785058264, 0.4697473968100043, 0.3880540303094141, 0.5238892526408816, 0.545055872844695, 0.44738561912084274, 0.5929907507949895, 0.5026079615960085, 0.37298318306894607, 0.4592218261718608, 0.8322479347175425, 0.815745291982929, 0.7399032663152292, 0.8072262586434633, 0.815657488970593, 0.8128097242311388, 0.8525446608487148, 0.8220797173290308, 0.8096155156740124, 0.13917028473674964, 0.12662306190897177, 0.17627898241884454, 0.5774318261383671, 0.1067169427194643, 0.13929051895540467, 0.13022057784617025, 0.13162501648839264, 0.13294710850323954, 0.17577095594355052, 0.2405701642050051, 0.18387980055531528, 0.13766266535167793, 0.13808975186029493, 0.1759728142837177, 0.17649136159870848, 0.16044953219056146, 0.2123938211841333, 0.2641402037919117, 0.3894551489281699, 0.4250233762847102, 0.49089102624268444, 0.39726352947187815, 0.5170763738591784, 0.5689279377013869, 0.5450131351881142, 0.5809962388397318, 0.23127781644827672, 0.3509451623749118, 0.391782707077048, 0.25943151429857925, 0.2866779799363486, 0.2981829637352025, 0.24747332922890863, 0.4601995568790066, 0.3886995786532508, 0.2491117512308001, 0.2005322984866198, 0.236068022250695, 0.24192988503071156, 0.2168579145108669, 0.20803841657694766, 0.23986492188937003, 0.25094633972134694, 0.2588355784204359, 0.7026961156969743, 0.24027957033238279, 0.18618517976657412, 0.24143824432448668, 0.19873368629616484, 0.18956068592799458, 0.23608728010716973, 0.5325753545555545, 0.19978948927938367, 0.8915835420130211, 0.18666305960378649, 0.8862569774603997, 0.1935462299211923, 0.16611504841989977, 0.8990703216559006, 0.8785044686796355, 0.1662280669913293, 0.20301933008316642, 0.8774205088368929, 0.2086551337733813, 0.8254287570021093, 0.2101210258070304, 0.8107340497843116, 0.20966334706663214, 0.1553034077062765, 0.1657364678112162, 0.16497668423950052, 0.19334891535625476, 0.18746852336800301, 0.18118621311653937, 0.18371795944307168, 0.1763701938719867, 0.1804425472825797, 0.183244286576979, 0.18410329364134026, 0.18747936421939893, 0.07900073439118371, 0.11034659391235602, 0.10250319676559083, 0.07292895368773222, 0.09959528007087626, 0.09708645323016896, 0.07620543276391667, 0.07792887169345453, 0.09862647327252849]}, "mutation_prompt": null}
{"id": "4c9d614f-7794-4e5e-9e99-71646a3878f7", "solution": "import numpy as np\n\nclass AdaptiveMultimodalDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((5, self.dim))\n        self.stagnation_counter = 0\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        if self.stagnation_counter > self.pop_size * 0.2:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMultimodalDE", "description": "Adaptive Multimodal DE with memory-based mutation and dynamic strategy adaptation for robust optimization across varying landscapes.", "configspace": "", "generation": 17, "fitness": 0.4099985926142139, "feedback": "The algorithm AdaptiveMultimodalDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8665797812369177, 0.862165358621223, 0.879683763253836, 0.844358605676152, 0.8708341998069664, 0.851445188225798, 0.8787663481716987, 0.8761409785635318, 0.8734915648242112, 0.7361826651449144, 0.7378319081466832, 0.7556968632120452, 0.7475125286314062, 0.7487456018331642, 0.7595807958059796, 0.7073788776356469, 0.72971436843408, 0.674587035963223, 0.15545883695834595, 0.7341508358237016, 0.1766276394024051, 0.11152394809219113, 0.15147584613226805, 0.6428231277526311, 0.14769118039314777, 0.1454822224150083, 0.13653235318524803, 0.15403523358540383, 0.10644231117524783, 0.16108448048540336, 0.13811091631645045, 0.11294187593395943, 0.1322946651272503, 0.1336358841000057, 0.12392948132517834, 0.18003874705386136, 0.9745981634697045, 0.9803373887849417, 0.9589993814871585, 0.9739060486627266, 0.9737172349760398, 0.9693564195052615, 0.9648755104343018, 0.9832448730868829, 0.9908168254103331, 0.5115127443064325, 0.6080982412152903, 0.5762305562311187, 0.5646206555687137, 0.63277471635075, 0.5925766206587698, 0.6124544320762004, 0.5791639407894758, 0.613663542285992, 0.7483605171967249, 0.9081068929614368, 0.799900234749619, 0.18987918334995546, 0.20610093713587152, 0.27373412761391325, 0.5303720561465399, 0.7153802591360471, 0.22868309389748098, 0.47029661843069803, 0.4736212881639119, 0.5127048287486349, 0.4134279883480927, 0.3865561688348591, 0.49862329089586, 0.46470899988422376, 0.46960014519938154, 0.4756588531047753, 0.5415332270133395, 0.49098904553583, 0.6372218448648073, 0.5764395820829249, 0.6719089896543564, 0.6489088390242473, 0.5914177435787092, 0.461904967696511, 0.6083561177952623, 0.04691851725887519, 0.16625222326657474, 0.297569140237382, 0.15792124013690367, 0.07682381973413899, 0.27213769790871845, 0.41933831104471986, 0.3802516208669149, 0.27980475990258113, 0.5222892684938287, 0.5226173464147321, 0.5061936519653731, 0.46965926412882264, 0.4017798709734659, 0.3740541901330465, 0.5563784843136304, 0.5103843060695888, 0.613284204350538, 0.06656187778684075, 0.30390259376498474, 0.25059093797109666, 0.15699788454328023, 0.21408226400187735, 0.24512304845692, 0.2738548918498743, 0.0833931715130386, 0.11890195193963315, 0.29622535281794804, 0.23549943986963773, 0.3202772046199325, 0.3147792786282523, 0.331950695762548, 0.3109561032087256, 0.2875571631566015, 0.37086987380889536, 0.23189044767077271, 0.7083506354017086, 0.724995532143487, 0.7174012692335034, 0.7539049705914542, 0.7362143660781318, 0.7172001046412493, 0.7471077281852643, 0.7150890481114871, 0.7512364817240991, 0.11697613742335944, 0.11174801076147578, 0.1351015035598191, 0.10166618356664547, 0.15016198962703953, 0.11660546864945587, 0.14468122293459618, 0.12549207391871275, 0.1073296300587745, 0.3600068323176322, 0.6742277993638521, 0.14397243719688468, 0.13776179633742247, 0.23363713607042902, 0.15331441505919463, 0.17306766117816474, 0.19644910248767888, 0.20402573396203993, 0.4731683218726408, 0.44976859865633756, 0.2735821959890744, 0.3571277763454024, 0.36963995683258155, 0.40576616157972445, 0.3978257386554226, 0.5860363669229601, 0.47794079886248153, 0.2708114407292126, 0.21096040937389127, 0.3298217904811499, 0.2961982760019042, 0.2900341965329182, 0.2632702456785162, 0.31832465296607326, 0.393758262978117, 0.25167256546912753, 0.24943311098202758, 0.262746565821639, 0.26546137570648254, 0.24931103457955028, 0.21251710284313963, 0.2676948023579776, 0.24040241057562484, 0.2290211928923085, 0.2924415442824101, 0.20476845594172288, 0.2376299267026445, 0.23636983066793815, 0.20491690973617593, 0.2154925089898767, 0.1862612520267427, 0.1844744882853222, 0.21664986509033712, 0.21843507209209923, 0.8917381733042068, 0.8784009350258093, 0.16198013514307963, 0.9050961407646556, 0.19727890030396178, 0.8880447692592903, 0.184886347921562, 0.8449645068167482, 0.16622907815048693, 0.6454029846873987, 0.20577322253724917, 0.1547643346767683, 0.8156874032403133, 0.2074178835178242, 0.150594176319512, 0.20950202976273236, 0.8053038070373659, 0.2084186437920127, 0.17956234702298735, 0.18557313921877705, 0.17984298693521106, 0.1814032875052488, 0.18252184935275595, 0.17496560756813484, 0.18495197690575937, 0.1954546043613603, 0.19218745904264223, 0.09198801150555469, 0.080190589510855, 0.08267329738286866, 0.0852239791354994, 0.08322903475859644, 0.08203459882709596, 0.09301647369662114, 0.07793503342411567, 0.07060652681002955]}, "mutation_prompt": null}
{"id": "17d05bd3-4755-42f5-aef0-4e44b94b9eae", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))\n        self.dynamic_scaling = 0.5\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.dynamic_scaling * self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.2\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveSwarmEvolution", "description": "An enhanced swarm evolution algorithm using adaptive learning, dynamic scaling, and memory-based strategies for robust optimization.", "configspace": "", "generation": 18, "fitness": 0.43738152153212134, "feedback": "The algorithm EnhancedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8122538916451404, 0.8138074232374277, 0.8245368745713674, 0.8190730973748539, 0.8246466912831867, 0.8274969736150684, 0.8128754127182685, 0.8182113460190131, 0.8268530210596734, 0.6657810955118237, 0.6483546977372615, 0.6740844642135343, 0.6631075133301402, 0.6571672762572787, 0.6648595337638713, 0.6615560972652428, 0.6708610218388338, 0.5982943222916681, 0.13476339364634826, 0.1147068431054733, 0.12467398537833518, 0.11210264318574426, 0.11812988400852786, 0.09597856653169368, 0.12111157501708802, 0.10680847918218717, 0.10348918964542697, 0.11414101278801025, 0.10335966850262734, 0.12291204980873371, 0.1152772700558915, 0.12585300921812836, 0.11099143154701319, 0.09699603528287681, 0.10539411860376713, 0.1250359538701843, 0.962293297426531, 0.9769980175542367, 0.974346322830268, 0.9677983245556506, 0.9343181863476424, 0.958609532938901, 0.9768911196971429, 0.9829368291558568, 0.9775677868596402, 0.5794523821983936, 0.5396109370531439, 0.5626663975501435, 0.5898977133682818, 0.5786742956061289, 0.5583926568814697, 0.5921598863641071, 0.5938358731992561, 0.5820016655097012, 0.835838468938647, 0.8330772337325766, 0.7991660595053394, 0.7683590875721501, 0.8472809787062806, 0.839978632936924, 0.8092669050261839, 0.8166255997840481, 0.8283075147433425, 0.5431797418267532, 0.5387378968943755, 0.5327954097699856, 0.5363090175805383, 0.6163787499803488, 0.47556500339648233, 0.4966669965677383, 0.5536692587330505, 0.5086289902017413, 0.5354700685893974, 0.5269611293186909, 0.4900132954564953, 0.5667842691304201, 0.5028052030548884, 0.4932991405678996, 0.5951702230820601, 0.5281119747828062, 0.5449977199798495, 0.5036730604809773, 0.49537427128583933, 0.5198464161906187, 0.5108681139349383, 0.5043484258568831, 0.49540580453439564, 0.526360985808624, 0.5551449293727688, 0.4763387225808935, 0.6364847480384752, 0.6075155110130178, 0.6113217626787875, 0.6209348106361559, 0.5890018790164746, 0.604703540119308, 0.6444569104589029, 0.6339181200344534, 0.6461240600421586, 0.33606042836983296, 0.10448110403743249, 0.13246282777022045, 0.2897496677243103, 0.3584446493232626, 0.18266873506588577, 0.25446447552691387, 0.22513167184622296, 0.2813274462620847, 0.38786352296110294, 0.38980685431079976, 0.3920622928037918, 0.3992591662666798, 0.3977686791085021, 0.3924692264214603, 0.3925753448247239, 0.38895665330045237, 0.38706007179776714, 0.7338821160335122, 0.7357219331745848, 0.7580843211724044, 0.7651446124962489, 0.7420977706418233, 0.7517274813534975, 0.7340618011531692, 0.7355603980215117, 0.7518265289161469, 0.1237836157735468, 0.09891816446210666, 0.10719272632068533, 0.10784142795468799, 0.11460777925255372, 0.13333611563763137, 0.11858747345298903, 0.12909076582805334, 0.12016023218486849, 0.14007483627419148, 0.16718328906851054, 0.15190671552599966, 0.1384950325085167, 0.13290898181236277, 0.14659283452712701, 0.19127057432721772, 0.27362088977203525, 0.15136343042724565, 0.4067404606290712, 0.45023346279113163, 0.4518423264853585, 0.482915128343936, 0.44027556255973277, 0.4982156704731465, 0.4544741550414977, 0.48593335040180885, 0.4635342399873974, 0.38847173441417227, 0.350320347100747, 0.36983480000775826, 0.36162463159068214, 0.43864931850749356, 0.3791283249314077, 0.3748593329244616, 0.36440374047334134, 0.351151340117862, 0.20226436354282962, 0.2065817133046447, 0.25760709584583397, 0.20853823080688283, 0.19313997575803166, 0.20400017951070992, 0.20781745641448013, 0.21400392516279287, 0.22279475856034348, 0.18668608613381055, 0.43107111048369406, 0.19350667079574846, 0.1923926318205954, 0.18013185932548204, 0.2027348156308444, 0.18167418393552714, 0.2560531815995264, 0.4450994805430649, 0.18260286601189135, 0.8575754856160958, 0.7459780837768514, 0.8087465408278753, 0.7989418585420096, 0.7499021833500648, 0.16754049762888013, 0.7152191178259659, 0.5944202570938626, 0.8371014918315131, 0.20489596613572592, 0.7774014222498817, 0.20761758314472012, 0.1660198289072028, 0.19298378492991752, 0.2096772125120786, 0.7208753579633114, 0.16383882770074065, 0.17736605128820793, 0.1766088177289199, 0.19142257868127033, 0.18180987254628433, 0.1784830704645366, 0.1936881789716386, 0.18246720217483625, 0.17945956956020004, 0.17618897485723795, 0.07207056019880076, 0.09378355347301115, 0.07238400726733019, 0.0808714821120331, 0.07962400961577876, 0.09013718479939348, 0.08052731500213706, 0.07442818588244193, 0.07612562836415016]}, "mutation_prompt": null}
{"id": "79ea6a4c-78ec-48c9-a774-6c7cfeddb48c", "solution": "import numpy as np\n\nclass HybridEvolutionaryOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.35, 0.35, 0.3]\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((5, self.dim))\n        self.diversity_threshold = 0.1\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.4, 0.3, 0.3]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.4, 0.3, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n\n    def adaptive_restart(self):\n        restart_threshold = int(self.pop_size * 0.15)\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridEvolutionaryOptimizer", "description": "A hybrid evolutionary algorithm integrating diverse mutation strategies, adaptive learning, and resilience against stagnation, for robust black-box optimization.", "configspace": "", "generation": 19, "fitness": 0.4400491852476231, "feedback": "The algorithm HybridEvolutionaryOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.9068764211565827, 0.9121947919177087, 0.9095321202439457, 0.9162708945416727, 0.9022843634360519, 0.9137109664898561, 0.9125180808245236, 0.9105483666547016, 0.9121788376470901, 0.8035325506404483, 0.823082334891458, 0.8178067450380184, 0.8177401237644719, 0.7982285715214104, 0.8267100440483369, 0.7530221978363723, 0.7572759998588386, 0.7478936171704733, 0.18145943721539814, 0.1404713251599462, 0.11770029530218584, 0.14819360223528655, 0.16481171183288423, 0.16276620162936506, 0.12934310653774805, 0.154506332643347, 0.5903434676524265, 0.14158513194558964, 0.10465395522241239, 0.14592364991237572, 0.23569846548073714, 0.13936595222242465, 0.1530181875727481, 0.11668612757471042, 0.1326563088984687, 0.12106376799023999, 0.976626611866022, 0.978448078324367, 0.8664296749684515, 0.8820192164622462, 0.9513844154536394, 0.9319342688247855, 0.9491271597305578, 0.8963789089400744, 0.9888820330355402, 0.7230944123474548, 0.7530641409800701, 0.6981112604305585, 0.7506929698865841, 0.7670714975241424, 0.7705444914822286, 0.7475123948143171, 0.7344365021100614, 0.732247581410945, 0.7844048857771789, 0.8958777766541299, 0.8694232622547412, 0.9137981865878128, 0.8722848849078855, 0.8929130433830809, 0.24121693381672715, 0.8848592067351585, 0.24288273675007732, 0.5532305000342482, 0.46540052810514043, 0.5782756689839712, 0.5222284168184761, 0.7443160762099781, 0.453227878457233, 0.7015821921706527, 0.1330789302476083, 0.41538017387846227, 0.2902872403926323, 0.3819478331115844, 0.6421352088738106, 0.5657571110860324, 0.6002240304630719, 0.13632277573746288, 0.4356997199174112, 0.1337012940416209, 0.13447879514649663, 0.20194081531587915, 0.3989407662375214, 0.2050949984399324, 0.6102912117172534, 0.03681029387122503, 0.38622338920776766, 0.6997363927813981, 0.40129972074702724, 0.5173851422497875, 0.6961066850424924, 0.531903584160826, 0.7414259547221373, 0.587072673498636, 0.46898679993405534, 0.49484998492303256, 0.6285625941428143, 0.6355573420946418, 0.7202288507400375, 0.09254015619604272, 0.08401620276930932, 0.39664885560117924, 0.26844251447843703, 0.47740084656927306, 0.6117252059704701, 0.16836200901035825, 0.3493672908788743, 0.17162583388716324, 0.3354871255403178, 0.36823633319756366, 0.4212851354233207, 0.35374060617337566, 0.3919400606381178, 0.3967054418505569, 0.2044569613894438, 0.3430990028849983, 0.3801461171194853, 0.8263785653192215, 0.7977656298160103, 0.8167410275785244, 0.6958299605547016, 0.8258111686150452, 0.6376812388121326, 0.6726658310332894, 0.8347694191314113, 0.6628193666615346, 0.13286730959319104, 0.13196104381220086, 0.12444979687217406, 0.11890920413928197, 0.14114634542290327, 0.12038310134941399, 0.17890967166651495, 0.14391881271358065, 0.15044758515636336, 0.15907918293462475, 0.17053199010790743, 0.21991794254617048, 0.15637709878963668, 0.15065038227790317, 0.17692549725953455, 0.17178032679484423, 0.14722613701503307, 0.20814720535629438, 0.28389138513188217, 0.44106599933857016, 0.5380255887285369, 0.33168485837770956, 0.5558110998487209, 0.6377996619503682, 0.5347169914165865, 0.5195161978141339, 0.5886710140840639, 0.22519819558419618, 0.2912519149129482, 0.34435781828832157, 0.4607046920064929, 0.2431090350718791, 0.3297390972172367, 0.26830681511532095, 0.4119209314347847, 0.47412630242626075, 0.23485625867412252, 0.20294289362308915, 0.23278096323622222, 0.22379753999399932, 0.2178671811389853, 0.22958583571906088, 0.21390392982127082, 0.20902979320514614, 0.24647813867387514, 0.19918256616073826, 0.736474544395318, 0.1877259618360102, 0.21703099338891207, 0.2022455979940747, 0.18695889543453503, 0.24616655874830073, 0.18954523764946773, 0.18151767513541817, 0.18719047597692073, 0.18810339575647572, 0.18741679763154728, 0.17729315043058236, 0.19386461463201632, 0.869682943034285, 0.839235562340091, 0.17289540232068323, 0.16638426740929368, 0.8906217161642996, 0.7356117807176208, 0.8687373274434211, 0.2108029014274896, 0.20860795999853088, 0.7422385347790208, 0.16730738207374451, 0.7695660929351318, 0.8312802700080136, 0.18250306962478902, 0.18150570212412553, 0.17474519885066342, 0.18293157645984315, 0.16770205747767142, 0.18094185988160794, 0.18261072151659585, 0.18354155299509434, 0.18992266072709296, 0.10634004122156115, 0.09290076798894586, 0.09831072990065837, 0.08846638420362829, 0.0953931178783678, 0.08337473042439869, 0.0918623304944931, 0.07654478952903643, 0.08986927895309382]}, "mutation_prompt": null}
{"id": "9ce1004c-c80d-4ab4-a7c9-b0b9f1ea02a8", "solution": "import numpy as np\n\nclass RefinedSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim + 20\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.45, 0.35, 0.2]\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((5, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.4, 0.4, 0.2]\n            else:\n                self.strategy_probs = [0.45, 0.35, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.4, 0.4, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            else:\n                self.strategy_probs = [0.45, 0.35, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.15\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedSwarmEvolution", "description": "A refined swarm evolution algorithm with dynamic population size and enhanced mutation strategies for improved optimization performance.", "configspace": "", "generation": 20, "fitness": 0.4140909198967295, "feedback": "The algorithm RefinedSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.860272759956938, 0.8541604960076042, 0.8519770223638782, 0.8843712509977478, 0.8695853445780303, 0.8495119875031831, 0.8422122420973712, 0.8520267612478123, 0.8463633523392095, 0.712017450416444, 0.764822279110251, 0.7199522424271216, 0.7189510112003845, 0.7515086767800162, 0.7175942588832025, 0.6957725193881332, 0.7426850928619373, 0.6594320357352015, 0.1459102206914249, 0.12346459256137021, 0.1376598899627599, 0.16041671631390197, 0.14314781078420225, 0.12614705511640367, 0.13318388297157058, 0.14046217531372007, 0.1534619629773868, 0.14532256796671394, 0.11961803618965772, 0.1295083811437847, 0.10801048683749048, 0.12737410116864722, 0.1265795569480983, 0.14320310161794492, 0.12663903470538207, 0.11138743414589114, 0.9697748710490667, 0.9832161958880813, 0.9864763215597935, 0.9688632957622753, 0.9622642685704187, 0.969638661863178, 0.9702474031592904, 0.9778975541858184, 0.9725081131714115, 0.5166040567766594, 0.5865551149834272, 0.5938470552676134, 0.6099524377187944, 0.6120373206572625, 0.5835245193509768, 0.5716580004161687, 0.5990172893763226, 0.5904855445402002, 0.22601726211956863, 0.789006055346561, 0.8126844735226241, 0.8563344154506257, 0.7466493877639355, 0.20813042084427658, 0.7704981920750615, 0.8319361698040577, 0.7903187900638149, 0.5204043893146452, 0.4937058232319316, 0.5668051678343331, 0.4478628486755889, 0.1264911950373676, 0.1233442777758933, 0.48059029817835464, 0.5137595823059636, 0.48702702633096984, 0.6013012811196764, 0.5721030818610033, 0.5720061007057118, 0.4754146854900497, 0.5150807068380542, 0.6168328807986594, 0.495034856757094, 0.5251744688983353, 0.5150268004335343, 0.28790219539377726, 0.3829130661324569, 0.36158339296298914, 0.042792031698076105, 0.3380720033244947, 0.36383231106051994, 0.5148535777959844, 0.5134919346559221, 0.5368482305768223, 0.6030311913653894, 0.50159853360771, 0.613803196342241, 0.5095918420039994, 0.4964797125209558, 0.5413752283210178, 0.5837838365402994, 0.6135332443656729, 0.5404945181064024, 0.19621291795271267, 0.10938859778056553, 0.10953822470181807, 0.10229919869813364, 0.24257696422689345, 0.26884149732178986, 0.3344999899007657, 0.13493770410740746, 0.1127893161367165, 0.3244299428797629, 0.3706053156163206, 0.29367468408382635, 0.3926091715736364, 0.3447052108890897, 0.3684550479983927, 0.33310022924465565, 0.1861394015899327, 0.30926406187302746, 0.7551286384233168, 0.7352410437192302, 0.731502270144893, 0.756493709279743, 0.7478394916197122, 0.7055655668182277, 0.7639435754296133, 0.7617585036476824, 0.7670430116833503, 0.13658822371784463, 0.11510747632423357, 0.12741181690542813, 0.09211904292974327, 0.09310088601238109, 0.10083651509307079, 0.15127727104053135, 0.09874683222973668, 0.11145641639036785, 0.15992429599562252, 0.19030621672805825, 0.13140125815605752, 0.24365215407424334, 0.14449687016847934, 0.17865412618635057, 0.13928751517354354, 0.14411844272797658, 0.15827428809250976, 0.41104572127341554, 0.3132922213719347, 0.2953139861757086, 0.49756497970155533, 0.4977805467028136, 0.4883027598568569, 0.4439445188499469, 0.5455544599196257, 0.5510587231823573, 0.272786621226891, 0.2859859264959861, 0.22635357648898125, 0.279537681170958, 0.35557583794876957, 0.32663613344220077, 0.3118696905323619, 0.33710040064062297, 0.21667094748737303, 0.2205707328477512, 0.23294847563327825, 0.2675166897049467, 0.20988199687786557, 0.21815458804086418, 0.21389262194754388, 0.28577787530733767, 0.24270446499036558, 0.2063015248212926, 0.20191681647146187, 0.19446469492600404, 0.17510688783257555, 0.2028270871031076, 0.1767689184645176, 0.21161940893942577, 0.18863626608881834, 0.1853237494437976, 0.19984727771255506, 0.1841734523098847, 0.18625508426215975, 0.8852093489657259, 0.8503889008491983, 0.8759535903373012, 0.19680501489274904, 0.8359214315307004, 0.20727871708760326, 0.8577133149985183, 0.8211921564654074, 0.20737145528576695, 0.6739937663386264, 0.1632225527960499, 0.8050623910730751, 0.8053052388821359, 0.20933641493259603, 0.2094631038403736, 0.16656403650849283, 0.17769510393393573, 0.20054861269835988, 0.18253913978108705, 0.18344104301905306, 0.17992918910688882, 0.18185332263836895, 0.17085998317931494, 0.18332873913972825, 0.16838505876033016, 0.07727589749533059, 0.07780228115140797, 0.0786228823325168, 0.08569972864244924, 0.08417086157645337, 0.09870912673950594, 0.07901761270194074, 0.10071384749206735, 0.08105605007919947]}, "mutation_prompt": null}
{"id": "bc52b8c8-f6a8-4e97-9655-24b481b70e6b", "solution": "import numpy as np\n\nclass RefinedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 15 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((10, self.dim))\n        self.stagnation_limit = int(self.pop_size * 0.1)\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.stagnation_limit\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def dynamic_population_control(self):\n        if self.best_fitness < np.inf:\n            self.pop_size = max(10, int(self.pop_size * 0.9))\n            self.population = self.population[:self.pop_size]\n            self.fitness = self.fitness[:self.pop_size]\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.dynamic_population_control()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedAdaptiveSwarmEvolution", "description": "A refined adaptive strategy integrates improved memory and dynamic population control for robust optimization.", "configspace": "", "generation": 21, "fitness": 0.3816126183895907, "feedback": "The algorithm RefinedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.9068633326584321, 0.9019755463550464, 0.9130184861085876, 0.913733880755042, 0.9087979922116229, 0.9075725131286771, 0.9063511586000934, 0.9034227716644987, 0.9148439126064871, 0.8500591277610949, 0.8070168193763383, 0.8784377098666143, 0.8667780411622865, 0.8587729163573862, 0.8772423566816516, 0.8508511284461098, 0.8553516509043407, 0.8293931861611079, 0.1310963287291128, 0.15749370969451792, 0.15732619300755268, 0.12075951139857521, 0.12775494169519552, 0.15358402472780186, 0.12101068586661479, 0.1421970811952229, 0.15792600459629047, 0.06964670264171913, 0.10740584054414415, 0.060432961229521576, 0.11019279983447472, 0.1546035385551322, 0.10784944678007413, 0.0629217484284803, 0.10949406806211959, 0.12257483914811129, 0.9677683442392957, 0.9774457812492457, 0.9607315115863744, 0.9724063722812378, 0.9735577617472181, 0.9584020351359915, 0.9335589956729298, 0.9835983632296893, 0.9770863573212335, 0.75399535492148, 0.792191224922751, 0.8135165487739886, 0.7370492696289079, 0.817672513641852, 0.7920389582921312, 0.7735042249484219, 0.7917091007946795, 0.7691912998077934, 0.3629415955056017, 0.24121883383996934, 0.14051351411077617, 0.2719060816234915, 0.20316997134201098, 0.27391537016794554, 0.2271776632797725, 0.22775128861986127, 0.8674075288343697, 0.13223383784228937, 0.5804778170783318, 0.5911973047767782, 0.1321155391610198, 0.5459720383393047, 0.6301897637591962, 0.13223799900634492, 0.6988200168654544, 0.7050382470442038, 0.6040618677428528, 0.6068701546989936, 0.44823131931524685, 0.6836891245800311, 0.6959364932496357, 0.4578921280662801, 0.6460687233577578, 0.6725873984632682, 0.5888290211543947, 0.0687466369702493, 0.06669708970307298, 0.16764687694388014, 0.1012986233926878, 0.016842948946425573, 0.06587073883058603, 0.27358320522393764, 0.21277675357202275, 0.094327488096974, 0.17597463343825093, 0.1565621798864475, 0.24227486738681236, 0.09516492607315608, 0.33412290766044184, 0.178244271275656, 0.43688959301470787, 0.30329822577932586, 0.101270751797219, 0.10128634225983246, 0.23497826312452852, 0.5187095868335112, 0.13023431863059176, 0.19551932187551513, 0.2520552607896098, 0.19048485632678358, 0.35160862846206964, 0.13102407933149263, 0.32933368916141015, 0.23917728196119625, 0.29082468772459114, 0.3334597804876974, 0.41891758300445636, 0.33311328618739466, 0.4360270807324065, 0.329675518358018, 0.4260115938431993, 0.70943476865836, 0.6594470730058415, 0.6876087519817649, 0.6202816988524482, 0.6328255637717937, 0.5950970912919405, 0.6875784403530963, 0.6696674086673544, 0.766190678816013, 0.09832036459077154, 0.13646091289108264, 0.15661346670303533, 0.12311707447240972, 0.15275880955141352, 0.10910750067267394, 0.09070524119902801, 0.10126957816431381, 0.1151817391411647, 0.18272485957586693, 0.15243849441886925, 0.22689725644988978, 0.15528957649096553, 0.3011567190144706, 0.11784593132483057, 0.21844824748868097, 0.1618309791084106, 0.18384574021954536, 0.32734134252170943, 0.24719476314200717, 0.43617770558172564, 0.434385855609129, 0.4245011436629105, 0.28355172403473605, 0.28964268197269183, 0.3082498624991956, 0.4431094753395014, 0.23644368145597838, 0.2516770454938101, 0.25992524901125147, 0.24974030490929422, 0.26442351043812196, 0.36798769061488135, 0.3024843299631631, 0.3884373215871709, 0.2080673889790744, 0.3522603627781212, 0.3333919164611824, 0.35712300962577437, 0.346443110237209, 0.2776789766668313, 0.309241286768697, 0.33952463242700903, 0.3343220188087924, 0.2505666930122544, 0.1820555829290873, 0.24781254916588058, 0.2072675033149861, 0.20046548801450959, 0.20009857727389557, 0.20571163650402335, 0.2073939041741738, 0.7195908706061582, 0.18036595556600055, 0.1696809649331502, 0.9039357330634301, 0.1768230730457817, 0.21067385274041484, 0.1969736073417786, 0.1657779470241345, 0.16314694567272858, 0.16555297596896512, 0.21059054976771785, 0.16708834629777847, 0.7086161118950959, 0.20735739493482241, 0.16518500901637512, 0.8684813121133297, 0.09322799169890772, 0.16571570914781586, 0.8280251423190612, 0.20855123582057866, 0.18180016572042712, 0.18800341758938488, 0.1885464197781328, 0.17539000429290696, 0.21528084359400568, 0.17517967698232773, 0.17070318222647107, 0.18021854497967693, 0.17751548069489487, 0.08173158265660263, 0.0815297084907246, 0.0836611241145081, 0.07311285625205788, 0.11427805333089436, 0.08106493150769822, 0.07396846703388549, 0.0724954916843693, 0.07898110634715105]}, "mutation_prompt": null}
{"id": "86993f08-30c9-484c-89ce-acf30d89e487", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'target_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.15\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A novel swarm-based optimizer with dynamic strategy adaptation and diversity-preserving memory for enhanced global search efficiency.", "configspace": "", "generation": 22, "fitness": 0.4395577841815335, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8841738241221587, 0.8814821250237469, 0.8844892030921648, 0.8938495142105541, 0.8924630718479896, 0.8912810002526829, 0.8746586881145282, 0.9021548760881846, 0.9046368048550997, 0.7869602940615519, 0.7745371144888382, 0.7971015377044416, 0.7820626724395567, 0.8076466358517276, 0.773292963397629, 0.7905835924512954, 0.7769835013639977, 0.7802270499495798, 0.15560640883527865, 0.13746987031795033, 0.1816444477704029, 0.18042475408681036, 0.6936100392559728, 0.17352123649701057, 0.11112387875254992, 0.14004531057423775, 0.771412270073984, 0.09960130438287107, 0.07769992632625455, 0.09543447457466314, 0.1509681849030392, 0.06994650617471421, 0.12161946595070572, 0.15295442652513225, 0.14790735890347262, 0.1327599731766682, 0.9776784865282003, 0.9729138675492529, 0.9763258966131327, 0.9852871933814195, 0.9758467962096271, 0.9822970392174899, 0.9813644344785429, 0.9814953861639769, 0.9844194463081893, 0.6351770149087156, 0.685971682011196, 0.6811199780276808, 0.7084798913787784, 0.6860848329510607, 0.7128262026868804, 0.7054913056695723, 0.6972373733784917, 0.6651305457109145, 0.16871056061514644, 0.7435346367711381, 0.21889844448112006, 0.7970682824112347, 0.8850733261782491, 0.27059612325145244, 0.8906077478568631, 0.8788814518563071, 0.23583785590947282, 0.13121026813574532, 0.6352534160862313, 0.5503308000142877, 0.1263783419732919, 0.5467765418234019, 0.5883890575004047, 0.6504279013459708, 0.647829473178233, 0.6641761273789457, 0.5151944508096693, 0.4641222272258515, 0.49408628039775804, 0.5841604490054275, 0.7339111906507891, 0.5728348210356631, 0.4675888781962667, 0.5059130741672857, 0.5475289982211519, 0.508339459417476, 0.44670883276247175, 0.5206939723726823, 0.13331353408914326, 0.3004256866795999, 0.1759301634152276, 0.4684215483326908, 0.29863912106774126, 0.5294213574034625, 0.5417125866843169, 0.618594531392763, 0.6753961731204338, 0.5244724621143585, 0.6190610730800792, 0.6100257497948228, 0.6015190875108353, 0.5329608371722356, 0.6992348572466207, 0.1837839374931597, 0.266991011842986, 0.43238808165873266, 0.3496287419612457, 0.494706572649405, 0.3205834714703868, 0.32630823465125036, 0.16191298145821853, 0.17648451025796097, 0.4227409028253397, 0.3461354701417345, 0.34249312914763286, 0.4408329523049329, 0.4197493237944534, 0.4935001340120613, 0.3751003334784301, 0.27140978815319794, 0.3271524830533633, 0.8201751401412035, 0.761080234092727, 0.7440047817953309, 0.8156923151192423, 0.7709941036571383, 0.825405792276974, 0.8000991150579452, 0.7601263773546904, 0.7605443388304418, 0.09541044837410695, 0.09826840460048336, 0.13660060554649722, 0.10397586048604646, 0.1212672153418285, 0.09524166843858584, 0.09970117744402596, 0.11502320876100625, 0.1389518258378155, 0.1789087592746006, 0.26910562195385845, 0.16354366722435665, 0.22052361589368719, 0.32824314954251177, 0.14672665671067076, 0.2292665303888376, 0.22016561100793375, 0.27044546526374613, 0.299702394029559, 0.3041875285354514, 0.36891480589329795, 0.5784870479508935, 0.2811220481928468, 0.40053347426336017, 0.44901231971572386, 0.3836857164314824, 0.4357804588748633, 0.22947210271414997, 0.18872889700924034, 0.2582809708558138, 0.3794182701938573, 0.31387263028894985, 0.3330598512010744, 0.2525603207518843, 0.23963428762250383, 0.34735819471300233, 0.2001261972424241, 0.20139513752118388, 0.17651463444552495, 0.20517620994167485, 0.1948520236572121, 0.2892672125520418, 0.2172338685755445, 0.19852581626460675, 0.1666124505776334, 0.1912453129387942, 0.2074682193869778, 0.20689340570563008, 0.22169118455443226, 0.2114794077985762, 0.20395593478279994, 0.24404048118723654, 0.21159593676556387, 0.22628498431975796, 0.9113130947389024, 0.18747567257402908, 0.8563363476069252, 0.8860762256265869, 0.904598446030275, 0.20020787018999153, 0.19920422329567622, 0.17663183594922027, 0.9042158051071072, 0.8051080342058229, 0.21092193479537213, 0.8153916528300442, 0.21059009191778666, 0.2093873018652468, 0.20726015820369925, 0.21093218556571058, 0.8746888018802792, 0.6809818763521189, 0.2053162277590902, 0.18847773293659753, 0.17838472506252767, 0.17711698072836046, 0.19006604526939075, 0.17975984127223765, 0.18952979541016457, 0.18669913161653107, 0.18990863110619316, 0.08601330577248212, 0.08116271165793565, 0.08265715595079637, 0.08071056419329348, 0.08749064016702757, 0.07573599349650484, 0.09349869397220922, 0.09440784066991614, 0.07898687950394179]}, "mutation_prompt": null}
{"id": "f6ce81cc-be73-4842-8d9b-95b2a7a140d3", "solution": "import numpy as np\n\nclass DynamicSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))\n        self.stagnation_counter = 0\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.3, 0.25]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.45, 0.25]\n            else:\n                self.strategy_probs = [0.4, 0.3, 0.3]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.3, 0.45, 0.25]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.3, 0.25]\n            else:\n                self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.15\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmEvolution", "description": "A dynamic multi-strategy swarm evolution algorithm with enhanced adaptive learning and restart mechanisms for effective and robust optimization across diverse landscapes.", "configspace": "", "generation": 23, "fitness": 0.45227872702040367, "feedback": "The algorithm DynamicSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.9031837976790799, 0.9109603696129409, 0.897726766594586, 0.9045487805209544, 0.9121255942337673, 0.8983245803298816, 0.8801357576438853, 0.8982311852541858, 0.8801176834726108, 0.8164363042014333, 0.7822589249044278, 0.7507342616320366, 0.81994273873689, 0.7746182656915421, 0.8133575879788966, 0.7578195741415472, 0.7600192516419291, 0.7110591015351431, 0.5725450654751785, 0.13742934069174173, 0.7125067646323955, 0.13670919157729933, 0.07854102028947929, 0.13946627792137933, 0.1564282068428371, 0.12554512096310555, 0.10914644900762338, 0.12907528721847372, 0.15232541113798703, 0.13326903627559183, 0.07131887496504008, 0.14569954349952952, 0.14705409356683508, 0.1366758618212356, 0.1467422390628883, 0.15637566352191756, 0.9771878273420407, 0.9267926394340412, 0.96030718758786, 0.94813016135668, 0.9181042673286917, 0.9806987043251344, 0.9783858490779465, 0.9484165954603918, 0.9865636377095524, 0.6135705962362152, 0.7149414303951046, 0.6643861909420959, 0.7076553636394441, 0.7216639241595333, 0.7108728712260157, 0.7129621573559123, 0.7138982165518074, 0.7255757964037897, 0.7395173063672338, 0.879946894610643, 0.24289091154293074, 0.8564602077635564, 0.21325117965546436, 0.2562518280277517, 0.17521732085988895, 0.8753192957156233, 0.8241217062815873, 0.7820983030755716, 0.5877022533708847, 0.6341107746159715, 0.6018756973678918, 0.5348864155964528, 0.5745180948880202, 0.6359429433749219, 0.1287987865341591, 0.5489729854055925, 0.6892787868563038, 0.6589823340206795, 0.7860145394193898, 0.5941380914742842, 0.6859907270645706, 0.7157904241127433, 0.6842161287379829, 0.6376798826649971, 0.6332863889661363, 0.5288980334172113, 0.3713507554420522, 0.5317827510782565, 0.18867333058400315, 0.26265636994817054, 0.5779123011531658, 0.4677517030466606, 0.43652856562254605, 0.601790379047973, 0.6466736626744252, 0.7399412328462791, 0.7587394825481211, 0.6704785192423999, 0.7067232078204022, 0.6498612616592094, 0.6779317783358529, 0.7402432951400497, 0.6647741315912497, 0.4758151561477969, 0.14642913397569923, 0.18531538938871406, 0.21456475680250164, 0.11789966411149377, 0.5668733679189591, 0.18299988554239288, 0.3379717073078876, 0.5455971927366663, 0.5202357425271957, 0.5389780863686953, 0.37663643438518535, 0.4909596842642999, 0.531449462349525, 0.3529556989977588, 0.4539152586093034, 0.34993738795552964, 0.4008471313757923, 0.81894787272641, 0.7808097129553548, 0.8010070598505801, 0.7866672413891632, 0.7328313038215484, 0.8189842557593089, 0.8397796535719413, 0.8448172520107848, 0.8068152035446537, 0.0875699021545131, 0.07441476112286038, 0.09571467077221973, 0.0963816899388763, 0.08076372338044169, 0.1111777421608049, 0.16326263357974946, 0.15869126826394075, 0.11561865190926923, 0.2066361445380085, 0.18496637895091217, 0.13317492999064484, 0.15601399345978384, 0.16675342063626686, 0.16268527232319707, 0.19709621055605642, 0.12732658077083725, 0.1414422697821739, 0.27113072263403626, 0.3339466748024982, 0.2865894228100192, 0.3646462961022402, 0.3452274082418235, 0.3691437781142012, 0.39180894488427165, 0.4355072674812793, 0.3027782661908801, 0.25620613430190986, 0.3182491092190528, 0.2605284839332559, 0.2140243131830598, 0.29166123890770235, 0.1958065216271897, 0.41249367707446705, 0.23365687858117268, 0.23067284169665203, 0.2538232596377843, 0.2191157614185626, 0.27427614132156497, 0.23625678071308787, 0.3140398910672667, 0.24348746557807244, 0.2633717927750745, 0.2223852320871702, 0.31511768041079125, 0.20741854164242624, 0.7562328885441373, 0.23914996210611783, 0.21140767038313157, 0.1850315207627411, 0.1914742679692304, 0.19686574864383788, 0.20317084823413734, 0.1963250511644361, 0.16716109736657203, 0.16475475955939178, 0.18578631234686782, 0.899364532851726, 0.19549510764259903, 0.8872660354224566, 0.18537361225982008, 0.8241306019905498, 0.16576264391863837, 0.905506439933622, 0.20815050154918757, 0.8582185278138618, 0.16762476869252985, 0.15326224276767353, 0.7971503990050877, 0.8938123569401644, 0.1562728281077701, 0.864542119787586, 0.18367131027539796, 0.19774175124426507, 0.18822960106078923, 0.1983131174174827, 0.1780246832314608, 0.17598635963658782, 0.18198581344251485, 0.18422871135626684, 0.17723416832889893, 0.14119718808817028, 0.07425372504417516, 0.10523343575260258, 0.10190905519398497, 0.09031016330042951, 0.09841890953080168, 0.08609453264444122, 0.08134716786624796, 0.0770926697277804]}, "mutation_prompt": null}
{"id": "42c32637-e0e0-45bb-a4fa-3e30de6c7084", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.85  # Slightly increased mutation factor\n        self.crossover_rate = 0.85  # Slightly adjusted crossover rate\n        self.memory = np.zeros((5, self.dim))\n        self.stagnation_counter = 0  # Added initialization for stagnation counter\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.1  # Adjusted restart threshold\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n\n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveSwarmEvolution", "description": "An enhanced swarm evolution algorithm with dynamic strategy adaptation and memory-based mutation for improved convergence in diverse optimization landscapes.", "configspace": "", "generation": 24, "fitness": 0.46040625242712907, "feedback": "The algorithm EnhancedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8829310580858148, 0.9027166387404578, 0.8957673002722325, 0.8818734025761806, 0.885638206204384, 0.8892670221377437, 0.9057054611452431, 0.8873392814068884, 0.8924568334770233, 0.8058976997621805, 0.7780938010343909, 0.7813928645855633, 0.7748745717336025, 0.7742334939240731, 0.814255955044065, 0.7624208481425396, 0.7812230756096779, 0.7298727593788856, 0.12597086847125105, 0.15058847599977543, 0.15282251944436775, 0.15299795125511462, 0.15178271010962252, 0.16503799743666947, 0.15506912541637963, 0.1486562414999587, 0.15629168477898625, 0.2298223678456469, 0.08451540462245033, 0.12218399959205506, 0.1648741078933459, 0.10911815110939427, 0.13334824862098482, 0.1428418210274458, 0.1513779666993771, 0.1268322698099852, 0.9734432339679093, 0.9708355531902925, 0.9583024043033427, 0.9812695675290433, 0.9918278256223182, 0.9833528586340295, 0.9232715201322221, 0.9840550280311395, 0.9791017596922846, 0.7086076510280022, 0.7138298074470957, 0.6862785660373842, 0.7155407264781404, 0.7101041809603035, 0.7035063314132627, 0.6618437492150182, 0.7220532299407834, 0.6571281084122307, 0.8253411870018799, 0.831691589232222, 0.8195090653719677, 0.27475562226339456, 0.8641309968686788, 0.8961348882333482, 0.7775783015371112, 0.8159654438499944, 0.8575355399462253, 0.5422813064671956, 0.6076039816317012, 0.5444177661622105, 0.13105350737052013, 0.13060446107292212, 0.5425994648084829, 0.13368694538399561, 0.5166976588517771, 0.5609757822284822, 0.6660232216721175, 0.5873077062380352, 0.5138118402583471, 0.6422399751523045, 0.6127614527440817, 0.6031238564933394, 0.6780862188309307, 0.5644687098915276, 0.7434166255009339, 0.5023724522947475, 0.518224860616428, 0.5544908650735002, 0.4182900319606866, 0.4699345303238802, 0.5849947474479165, 0.5578166334412429, 0.5355046780182449, 0.6318568495225763, 0.6295019490448248, 0.6204052936901961, 0.6623755689601778, 0.6354401061259827, 0.6483971736069829, 0.5931837262576701, 0.6637266029411482, 0.46800085451044204, 0.7223018917619868, 0.07809333988519973, 0.07637857110379753, 0.6000588476288615, 0.30611061388726546, 0.3327898190746712, 0.281589083197474, 0.13698064615515193, 0.20086604379057493, 0.3609566538505421, 0.4021685545179252, 0.3737607742727206, 0.5406251668520565, 0.4907457477314683, 0.43792664580981044, 0.5012010938915927, 0.510847754403204, 0.3824259188638395, 0.3324296223051789, 0.7603673330341978, 0.7407476635855865, 0.7795679162353899, 0.7883322247630158, 0.8210831480320763, 0.7753244357411093, 0.8046841549592808, 0.7961873246221387, 0.8047177532247098, 0.15347306873886957, 0.10887399479839, 0.13708334977624326, 0.10562391229288637, 0.15310639259362346, 0.1838426936047105, 0.09575717456710242, 0.562991788869394, 0.10277965119899413, 0.15730650592878392, 0.23050310897599002, 0.13510199260795797, 0.2223504019769128, 0.18140776234375888, 0.12674096381960065, 0.16634280458956596, 0.1527243025694235, 0.18739892553634452, 0.6340709203140021, 0.3037304211465328, 0.33002989365287094, 0.4029998820004024, 0.42080606492134487, 0.42972020145802325, 0.24470783715660793, 0.5178546408030427, 0.4923212236034782, 0.2678054979907295, 0.28748726522694557, 0.37066937925344345, 0.34348190622744745, 0.38403176152127994, 0.3967161726855556, 0.2231717319080373, 0.2698543338924436, 0.2676388979962875, 0.22533564790065808, 0.1928450167268967, 0.23570988461078646, 0.207437385405421, 0.19953867310155393, 0.24220344590914444, 0.22033817520057786, 0.20512507242159972, 0.2544767417395247, 0.21526595742493293, 0.20588003039462033, 0.19725146211344913, 0.20553214076755244, 0.20799977281877602, 0.1956416765105905, 0.21566431127561025, 0.18781813248497692, 0.2051747677448359, 0.8717944564614913, 0.1776468559746267, 0.1542737096918798, 0.1718586223315317, 0.7923119513425716, 0.8487998121160456, 0.8347615826218833, 0.18407170610871193, 0.9240358313540564, 0.8846478696929543, 0.21126525591068634, 0.858814232444437, 0.8767922127026091, 0.19526655563557505, 0.8752359925558073, 0.1128534047723928, 0.836701184262836, 0.8153098236470485, 0.19184335442801448, 0.17953919493441084, 0.19566771695407792, 0.1758618109661183, 0.19016011302257385, 0.1898622784718721, 0.1955704382143295, 0.19495798647727058, 0.1814749522153285, 0.09963777735396817, 0.10026717455304757, 0.07963093002199073, 0.08577029771354516, 0.0933686797352744, 0.08055889722980569, 0.0788993991693826, 0.07725271038176429, 0.06920756268164918]}, "mutation_prompt": null}
{"id": "7b7670ad-cc1b-4577-a254-12f9a5875c4d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 15 * dim  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.35, 0.35, 0.3]  # Adjusted strategy probabilities\n        self.mutation_factor = 0.9  # Increased mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.memory = np.zeros((10, self.dim))  # Increased memory size\n        self.diversity_threshold = 0.1\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.40, 0.30, 0.3]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.30, 0.40, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.30, 0.40, 0.3]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.40, 0.30, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n\n    def adaptive_restart(self):\n        if self.stagnation_counter > self.pop_size * 0.1:\n            diversity = np.mean(np.std(self.population, axis=0))\n            if diversity < self.diversity_threshold:\n                self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            else:\n                perturbation = (np.random.rand(self.pop_size, self.dim) - 0.5) * (self.upper_bound - self.lower_bound) * 0.1\n                self.population = np.clip(self.population + perturbation, self.lower_bound, self.upper_bound)\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveSwarmEvolutionV2", "description": "A memory-enhanced adaptive swarm algorithm using flexible dynamic strategy adaptation and diversity mechanisms for improved global optimization.", "configspace": "", "generation": 25, "fitness": 0.3899011268946374, "feedback": "The algorithm EnhancedAdaptiveSwarmEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8353924609238867, 0.8360276999021832, 0.8331315164802884, 0.8377937197968872, 0.8391569342986489, 0.8293278509028581, 0.8204105708820517, 0.8348142795077054, 0.8289225472513444, 0.6987601614484152, 0.6751675593921942, 0.6622255765141434, 0.6825074191865951, 0.6887800115592393, 0.7072499340291456, 0.6748231990127065, 0.675103302215883, 0.6573384242869356, 0.13529574197758543, 0.5451721925958233, 0.11755601899939538, 0.14938732200302607, 0.15591534463689494, 0.5341050748139884, 0.15694746514694835, 0.17386855795247924, 0.17069179438053073, 0.12703155388051168, 0.10551321292682891, 0.09679650190227496, 0.15082740471849643, 0.1413869761962595, 0.14198437138596132, 0.10380586255970137, 0.12853227447247972, 0.10727128451840984, 0.9366982858915169, 0.9756129662606203, 0.9538105359671081, 0.9146617210511887, 0.9706301767204161, 0.9821916207427884, 0.9860267752687784, 0.9781523513756966, 0.9709050004825815, 0.5081572553284092, 0.5649871232575492, 0.5216040379500907, 0.5386358200435577, 0.5201250575417967, 0.5077202358579144, 0.5809473200282707, 0.5175879145837647, 0.5204220818763373, 0.6304310801006164, 0.2253822464126921, 0.7095132608213277, 0.2081125083915123, 0.3624936473758418, 0.1974178704231152, 0.752002806370385, 0.7264275933017921, 0.6692510491629187, 0.6793034275198897, 0.5288889296217245, 0.3948087993431679, 0.3637692075428365, 0.5758492115465004, 0.3420737267660242, 0.39677118898338626, 0.3674191281114938, 0.49852531501211894, 0.5527568148549984, 0.5566522485675358, 0.7054274024682733, 0.6125519696410784, 0.517954123176797, 0.48556422883731487, 0.5356830371331932, 0.5309981009243534, 0.47102696703855396, 0.22939610140418465, 0.18411300344823311, 0.30292607138425975, 0.13434288246028114, 0.26718272074263716, 0.07852093317012676, 0.46470901943909126, 0.22488813569686994, 0.2027059027036714, 0.5117993252547626, 0.2749055406022797, 0.5346850642987397, 0.4860095898518816, 0.528483423831745, 0.38088958176488774, 0.6120192372913765, 0.4737574408309352, 0.5235601907689841, 0.058717728770203426, 0.08537186077991377, 0.23309990072041742, 0.19691439523104137, 0.18868980515379208, 0.15037592617315498, 0.28822878917782513, 0.2792884635730939, 0.0850033585775336, 0.1706859912704305, 0.16004939936259688, 0.2607317634519749, 0.3638138861809701, 0.2799228962761413, 0.31446143582377617, 0.21989661563383733, 0.3002806821487456, 0.3267948584443444, 0.6840819333649533, 0.6533344720245288, 0.7057414305637246, 0.6799369450052686, 0.6714575970295336, 0.7309898349491422, 0.7260518411179411, 0.7394622945208178, 0.7270282376505071, 0.13737933813741987, 0.12323384758593714, 0.09060208136168912, 0.09370202924851889, 0.10111933182117205, 0.10998702937616123, 0.10739324224650515, 0.1275871973168602, 0.10621369755258347, 0.21062245579659344, 0.16386776236394562, 0.16954841899817708, 0.13820769302899627, 0.18727974617060283, 0.17201808259481755, 0.21214576275985386, 0.38507134112908625, 0.12978156705266652, 0.3536850632059131, 0.4787962413408301, 0.3369624834505637, 0.2986546641928429, 0.5081158076840899, 0.3941754401516949, 0.4867260562887522, 0.31486124293333595, 0.420484746858379, 0.2707622529960516, 0.2413915694451374, 0.3866501008471329, 0.23599427164516684, 0.31801964784092773, 0.28357007649764043, 0.3217199732437924, 0.34533830429406187, 0.2747991458865162, 0.30577687796839703, 0.29279182025988526, 0.3512143646441024, 0.30457907406068996, 0.29429214089478506, 0.26153889886967285, 0.3542097384788869, 0.2753703677205651, 0.3489286306109156, 0.17830924443775198, 0.20082682612427305, 0.232443043947141, 0.21986074921432286, 0.2181962200506251, 0.20476691512233036, 0.19042826734492846, 0.19311358143408874, 0.18716698177516522, 0.8588657455000632, 0.18703657478428193, 0.1859632436484, 0.21075947797874595, 0.19480878290728165, 0.16349515453926267, 0.7850481742581135, 0.8139876790111372, 0.8657269118021581, 0.7464072505459252, 0.741098169525064, 0.14836582668870069, 0.16617547926618337, 0.20878310460059424, 0.1615095065533727, 0.1634219244808751, 0.7967156283283614, 0.1555468398760388, 0.17799391866425918, 0.1832615659916671, 0.18594213457436126, 0.18013155921377488, 0.16933502715449633, 0.18607937630956384, 0.18267880604311326, 0.17985764390296322, 0.18568958542358827, 0.08545318718719919, 0.08218425299250609, 0.13570980102405172, 0.08151882619721751, 0.09272860398693827, 0.06871496532769783, 0.07665133041250616, 0.08250078828853913, 0.07795430569204287]}, "mutation_prompt": null}
{"id": "b0405941-7171-4f75-8fb9-942cce96c479", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((5, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_2_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_2_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_2_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_2_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.25\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A dynamic swarm-based optimization integrating adaptive learning, restart mechanisms, and memory-enhanced mutation for efficient problem-solving.", "configspace": "", "generation": 26, "fitness": 0.4434663908741175, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8863268387179295, 0.8759544842297313, 0.9024708957853236, 0.8817521177526492, 0.8917199580995626, 0.9003351705946098, 0.8872119321642159, 0.8902411092617148, 0.8931362170504646, 0.7766178619138173, 0.7975700452944658, 0.7827269209919577, 0.8136736010243479, 0.7679843610788197, 0.7866991913674664, 0.7732724115339497, 0.7679453610307859, 0.7749133425804394, 0.14137620433738085, 0.1512943332781419, 0.17698381773083693, 0.12796451179918256, 0.6414970420276842, 0.6013176190869828, 0.08723122554179097, 0.17787984316351046, 0.16444450406261601, 0.15068921362027465, 0.09892890726974546, 0.10845492840554449, 0.15242503943361463, 0.11208607724383635, 0.13774112619878887, 0.14181910203710213, 0.10945816739016934, 0.10874601949243445, 0.9873290875257745, 0.9779691874194628, 0.9644310968584467, 0.9814970012785358, 0.99183334323103, 0.9867472686772685, 0.9626645294455856, 0.9840642913628415, 0.9853252222693256, 0.6684294609457941, 0.6915656340785044, 0.6956186424609747, 0.6947841448054121, 0.6852948590665937, 0.6749716516214675, 0.6595249141666344, 0.7025520738045836, 0.6984583128294717, 0.7921599282399897, 0.21709207242636608, 0.22493962099512577, 0.21490624842315564, 0.2753627198848164, 0.9203883425105716, 0.24135240045150086, 0.8433740833112005, 0.8562449495691272, 0.5926455412393354, 0.6624524558425584, 0.626819120899234, 0.5698667619860265, 0.13032438081997844, 0.5845246412698877, 0.6921114682905831, 0.5894839381119896, 0.5664759573066115, 0.6596716361785536, 0.6604964236838639, 0.6574836757767638, 0.6930446098764713, 0.6390478615223847, 0.5967073190842396, 0.6909812697114489, 0.6239431504752289, 0.6410266377545673, 0.371665335394914, 0.505998367224573, 0.5669800365648086, 0.40435108472202985, 0.23123276225555323, 0.3890445444536914, 0.33693156290751636, 0.43288640218403773, 0.602180513283503, 0.4749537840565269, 0.6334664670818919, 0.5571703649116194, 0.46091203956436766, 0.5616707291046288, 0.5552809151485125, 0.6773736698637727, 0.5090495115306999, 0.6737865467357724, 0.06512493954125909, 0.13729639178032527, 0.28732651933654973, 0.24972641578997623, 0.3708749041984435, 0.6160897437471254, 0.1569724682664424, 0.3704987484569924, 0.3717208204396285, 0.41441965660592395, 0.3397763801029783, 0.5197658595061131, 0.4672652305326962, 0.45088638576721574, 0.3612293544524193, 0.44440331325594273, 0.38427072393685124, 0.2992443763807344, 0.7999177911160678, 0.8227444962053754, 0.7862770586584402, 0.7319089357645265, 0.747624091708069, 0.7663688352998371, 0.8092321352804819, 0.7548366402093103, 0.8208096298053047, 0.10076000178266242, 0.1151322281451519, 0.11012974308857992, 0.11155510393192214, 0.1549568038245096, 0.11737695870099274, 0.11401424345960987, 0.17936963477196188, 0.1161939458785326, 0.2046358395904646, 0.2887332133412718, 0.16722214628670085, 0.22025099590734099, 0.27028623276551855, 0.2535448329783374, 0.18387317289008764, 0.20174837685315639, 0.2614728454560781, 0.27869814190694286, 0.4494472325231851, 0.332548506724786, 0.4677177850024197, 0.41843166153593814, 0.4572598601952266, 0.3133738106157321, 0.6168920425198808, 0.29416014605380736, 0.22862405947793663, 0.3108047107722307, 0.2689476261318797, 0.2595985716666016, 0.2200576399705636, 0.3147303595801578, 0.38237859857333867, 0.28235722141317476, 0.3011435671829932, 0.2999896821078665, 0.21412988476260975, 0.3251315735714613, 0.3197215316433216, 0.3074832666284476, 0.26265915660910377, 0.2664521624917906, 0.21635190501330348, 0.2539668515557807, 0.17707901587269448, 0.20814756222728614, 0.22125969721222294, 0.18177811937933652, 0.20314646901038347, 0.1964883472625455, 0.18870848879410207, 0.2110892555762608, 0.18883088702552564, 0.8917855724775694, 0.8670505822677954, 0.15365281320390223, 0.9063775472800559, 0.1972553213834718, 0.901757079169845, 0.19768708435363203, 0.14245608446234803, 0.9144310584918863, 0.8323500246660946, 0.20910973057215787, 0.205765700414684, 0.20669946384695537, 0.7642714280892282, 0.1118053082966648, 0.11281323027516632, 0.1280844951500527, 0.779802312097598, 0.17968141611901378, 0.1781979782627745, 0.1886941270916188, 0.18147229423447198, 0.1794051277411718, 0.1851497024531763, 0.18373699865977566, 0.18625555578876063, 0.17999038165923886, 0.07934927629053234, 0.12751729401244705, 0.08285028668904992, 0.07878066944230377, 0.07864498076075854, 0.08967405715243426, 0.09122761652955635, 0.09614333749410175, 0.09954885047073037]}, "mutation_prompt": null}
{"id": "be7d203a-b31c-4079-92bd-008694cce179", "solution": "import numpy as np\n\nclass RefinedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.35, 0.4, 0.25]\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((5, self.dim))\n        self.memory_weight = 0.5\n        self.stagnation_counter = 0\n        self.max_stagnation = int(0.3 * self.pop_size)\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.memory_weight * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.4, 0.35, 0.25]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.4, 0.25]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.4, 0.25]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.4, 0.35, 0.25]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n\n    def adaptive_restart(self):\n        if self.stagnation_counter > self.max_stagnation:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedAdaptiveSwarmEvolution", "description": "A refined swarm evolution algorithm integrating adaptive learning, strategy diversification, memory adaptation, and restart mechanisms for enhanced optimization performance.", "configspace": "", "generation": 27, "fitness": 0.43736073606855513, "feedback": "The algorithm RefinedAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8415322265980921, 0.8518704117201026, 0.838818675797331, 0.8383704115829962, 0.8442371609462759, 0.8373370582931798, 0.8347560415399271, 0.8362865619503328, 0.8263221122555447, 0.6414264405955483, 0.6945100466196182, 0.6743740525720594, 0.6986292886792789, 0.6712014893540146, 0.667707956921328, 0.7088148805168082, 0.6581198419486807, 0.6460759764601993, 0.14971510560271128, 0.18971656947640814, 0.3949620073434157, 0.17677057776576943, 0.2510633237843264, 0.15797981526408, 0.18462436767620916, 0.18294185044775324, 0.1521322124232527, 0.12737003467934116, 0.1438735091450717, 0.15746031987493914, 0.12965266793357655, 0.13379963368101688, 0.13887206172496658, 0.1314761796628542, 0.13507492252002573, 0.133368299670082, 0.9786721316860622, 0.945658940950703, 0.9537019209689511, 0.964814198624445, 0.9769755976488169, 0.970845752768594, 0.978221063619366, 0.9406181329306297, 0.9796052607525744, 0.5118085408890121, 0.5603408421423486, 0.5585464476744666, 0.567466227014349, 0.5892589056984561, 0.5759338209262754, 0.5943182430223998, 0.5753060829694137, 0.5738780337693876, 0.8024244286374824, 0.8674804380117351, 0.8385162786366049, 0.8654602277258999, 0.828280372430244, 0.8593859973944443, 0.8411361164438331, 0.765823578112149, 0.8094854830301093, 0.12661722278071152, 0.4313593523102994, 0.47077383149248586, 0.459806337237714, 0.4876751535224919, 0.36046677646399194, 0.4199558072596966, 0.460696588230348, 0.4265989083290235, 0.5699578728893917, 0.49971669673648234, 0.6422508584698483, 0.43226347550559874, 0.5214581447565503, 0.4967467927167215, 0.5830446230477263, 0.5375725976226615, 0.42753474176528694, 0.4021543753502298, 0.4990986894434668, 0.47186250070031166, 0.4779581947246605, 0.4215017753885568, 0.4007242832711385, 0.46740242970887524, 0.4541486949761099, 0.4698830053676556, 0.5632916681193678, 0.5329835810822858, 0.5927552820808107, 0.5364676616291784, 0.5114103942434288, 0.5346838705686313, 0.5984657432412204, 0.50108435597399, 0.6088311363463158, 0.2945046439616661, 0.18045011027881774, 0.12455287351417899, 0.21704687868954808, 0.3473718677273252, 0.3915690389555905, 0.15403324159776077, 0.1442261413829854, 0.2338944130939844, 0.3729312584864135, 0.35365875456667106, 0.3729150343721144, 0.3820771005148391, 0.38358956831066315, 0.3696493912684835, 0.388404907151809, 0.3256437503036166, 0.35343470771067764, 0.7663207174292266, 0.7550256278933076, 0.7606207711451162, 0.7117505154396234, 0.7394289267169897, 0.7539026553782348, 0.7497465205239696, 0.7551314241111475, 0.7422195539130908, 0.11544016309647964, 0.12004176006268752, 0.10685104618848418, 0.16122557116426173, 0.12207907062878731, 0.14049341390404024, 0.13056364343673665, 0.1262566574990044, 0.12667740352170587, 0.16628420309953285, 0.14738971979651228, 0.19503137835628714, 0.17701263741344608, 0.13759639648632016, 0.12797273258121278, 0.15980921133443593, 0.15560562814147894, 0.17645033997020287, 0.47578844360029293, 0.5368908202508056, 0.4564034313093088, 0.5252967331365802, 0.45435960237554596, 0.5110646799470338, 0.5015067996086684, 0.4482320843897628, 0.5229433031467683, 0.39548321318180424, 0.3598548273669743, 0.3882593891882975, 0.29601619914662236, 0.3698471172762614, 0.31769285621612475, 0.3792992398542967, 0.3399350745697649, 0.36990031086565744, 0.24261438067453023, 0.2505111212294244, 0.19866366996522122, 0.21552568533651162, 0.23430482961559052, 0.2284722638803396, 0.20887522561468352, 0.22976297752622077, 0.1958555484712673, 0.18477094857315113, 0.19247048659356125, 0.4290456564102516, 0.34106692310973963, 0.18927733947102476, 0.2067572747203229, 0.20567389682766812, 0.22315359622816, 0.19632737782148024, 0.8145756112993585, 0.18557169284098163, 0.18431275893560328, 0.7494105976178635, 0.7003620618317237, 0.8007407516435909, 0.17727652514444758, 0.758335741213618, 0.1702709229537992, 0.6753226499456346, 0.8211209368834188, 0.8453547954534011, 0.5858073407233321, 0.7386932851888882, 0.78648606048208, 0.6399181310305072, 0.20710011646208315, 0.166407633657209, 0.1835945349213456, 0.1970462526422273, 0.18479054385655136, 0.20633200806503593, 0.18372342176219336, 0.19659204480318893, 0.19169644451247259, 0.18639488907659918, 0.18427656309816565, 0.0920495229594972, 0.08888235374215714, 0.10405685210248816, 0.08189922659676652, 0.11398393282542296, 0.09372172736256468, 0.08832383523225362, 0.09363071164490355, 0.09866123281822547]}, "mutation_prompt": null}
{"id": "0ad17f73-ec74-4b73-991c-c571e7a0f104", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim  # Reduced population size for efficiency\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.9  # Increased mutation factor for exploration\n        self.crossover_rate = 0.8  # Decreased crossover rate for diversity\n        self.memory = np.zeros((5, self.dim))\n        self.success_rates = np.zeros(3)  # Track success rates of strategies\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        indices = np.random.choice(self.pop_size, 3, replace=False)\n        if strategy == 'rand_1_bin':\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            x1, x2 = self.population[indices[:2]]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self):\n        total_success = np.sum(self.success_rates)\n        if total_success > 0:\n            self.strategy_probs = (self.success_rates + 1) / (total_success + 3)\n        self.success_rates = np.zeros(3)\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.1  # More frequent restarts\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.success_rates[['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'].index(strategy)] += 1\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n\n            self.update_strategy_probs()\n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveSwarmEvolutionV2", "description": "A multi-strategy swarm algorithm with adaptive strategy probabilities and memory-based mutation, featuring periodic restarts to escape local optima.", "configspace": "", "generation": 28, "fitness": 0.2773400172375374, "feedback": "The algorithm EnhancedAdaptiveSwarmEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8813622875479099, 0.8780527097230788, 0.9141433999008031, 0.8826497962620253, 0.7744754753566716, 0.9033990706896797, 0.9066215118026347, 0.9049302591717462, 0.8880729211859457, 0.7579315955382117, 0.7138147019968255, 0.7826729613981451, 0.6246086152652385, 0.6764455702603971, 0.7809359019073613, 0.7106556987846502, 0.7165795492368707, 0.8059816498669292, 0.08350496471686841, 0.07098328135921816, 0.14425853767898733, 0.11872361617282656, 0.10034680331095458, 0.18270726980029872, 0.09990494991243759, 0.11698650903800667, 0.15826200989711126, 0.08729693204955746, 0.0532629494025878, 0.08550647326414218, 0.10668311102430561, 0.08251718599111679, 0.11895082617415687, 0.09415094027538251, 0.11636609707775192, 0.08912651156229678, 0.9804413805864436, 0.9714037500050393, 0.9886909972713818, 0.9685820568064261, 0.9771839285292387, 0.9812565695305984, 0.978973094169754, 0.9825900890790479, 0.9677160084447055, 0.23364052151774162, 0.3975576982598644, 0.2945285244621342, 0.29606611799564186, 0.27822781976679045, 0.5046150735079322, 0.17649301512943127, 0.21155875686268133, 0.2743433913628508, 0.21720940341763595, 0.17200168845685637, 0.2211368556437625, 0.21363021494551615, 0.21153740796341103, 0.2834308196011279, 0.1447076959808935, 0.15134097147879289, 0.23129461364484238, 0.2410742594295021, 0.1947663997751563, 0.16502981956545304, 0.1297265889352287, 0.12484529062212424, 0.14570537904855096, 0.1659924567589589, 0.12827922188162033, 0.1793857881955313, 0.23828533464677581, 0.21525747930876282, 0.17359185517408804, 0.1729694431918315, 0.1938155670819196, 0.2795280023974388, 0.2150228239875489, 0.23304127936871533, 0.22691823190481708, 0.03816611191736907, 0.019905113545227282, 0.027590103470270133, 0.04609444810106511, 0.07791591893125294, 0.0513934443254056, 0.15638471916276775, 0.05735186509277923, 0.07768543596539568, 0.27121425056965287, 0.13069600292992145, 0.15157853043294067, 0.10339380086713024, 0.06642300647375265, 0.15111809384979025, 0.12304866935350733, 0.10516268794247174, 0.1540092237149422, 0.15072405641723685, 0.06072647576840062, 0.1500022224819224, 0.18233859989600476, 0.08841081159664788, 0.08056467235177167, 0.2038290764751276, 0.10896933911315498, 0.3976784965123439, 0.16400339413130005, 0.1737168263121024, 0.08379116784386209, 0.056224914156845496, 0.04839186357918812, 0.28638865410914116, 0.12914976999624328, 0.2242072323057409, 0.31799220087707325, 0.5675310393951174, 0.5679351766814346, 0.49597630836155426, 0.5126749678038646, 0.48845912671630354, 0.5075089660753291, 0.49478739795078996, 0.5707491299695933, 0.5046752964419645, 0.0503042673610129, 0.09731086855403792, 0.13156509947974904, 0.08126377005846075, 0.14621192981945919, 0.09633375677819023, 0.11784555488889359, 0.11750310784433715, 0.08559450756608822, 0.24203243259909235, 0.1723451891670531, 0.21541553496403443, 0.21539325857228253, 0.20655260765936678, 0.16885817477086873, 0.15365391516914717, 0.18155165322030065, 0.1547205250947956, 0.23877496315047475, 0.23059660345780453, 0.24924194775611386, 0.1930904086903774, 0.21390824817789966, 0.2436900391688107, 0.24272843586979365, 0.24679045091272123, 0.23737409998876968, 0.15858240980934224, 0.146100973222122, 0.20241345205663352, 0.14589039316123964, 0.2578003580884761, 0.24106343927891727, 0.19596116487079762, 0.19920902141417351, 0.1768059484012181, 0.2994946360503392, 0.2866107417926882, 0.3494153527378907, 0.30793837814303215, 0.32156262525989454, 0.30182918164569206, 0.34110053815568875, 0.23251971703469765, 0.272003565010528, 0.20903577365915427, 0.17519790440232597, 0.1701872508267923, 0.1887795547409864, 0.15997595076371474, 0.17152673301974297, 0.19368563907832026, 0.17195979923262728, 0.18188780143377137, 0.16813868929764342, 0.837440307134337, 0.1530283072626213, 0.1300094285994262, 0.19780721588432626, 0.16606723536831391, 0.13134953559113305, 0.8981338935219146, 0.16212050151675972, 0.16251411576621233, 0.2067265728652118, 0.16728480297199744, 0.16824044349689027, 0.08094740975606252, 0.16778975246440098, 0.09391112359023623, 0.16028216617645807, 0.1623975787640073, 0.18103582578375366, 0.1693531626843745, 0.17637162053836963, 0.18607796294525358, 0.18378334593556345, 0.17680351319169818, 0.17786843288065302, 0.17340204049245989, 0.18535659483318745, 0.07593689539985538, 0.1033264203948866, 0.07956588394758035, 0.07535723997144783, 0.07951903349495637, 0.06689713319623591, 0.0725645861865003, 0.08982474653202188, 0.07621561057717519]}, "mutation_prompt": null}
{"id": "ec0880ec-4d52-48fd-b202-658e2aa1a378", "solution": "import numpy as np\n\nclass AdaptiveProbabilisticSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.35, 0.35, 0.3]\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.stagnation_counter = 0\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'best_2_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'best_2_bin':\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.4, 0.3, 0.3]\n            elif strategy == 'best_2_bin':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            elif strategy == 'best_2_bin':\n                self.strategy_probs = [0.4, 0.3, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.25\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveProbabilisticSwarm", "description": "A novel adaptive swarm algorithm with probabilistic learning and dynamic parameter adaptation for resilient optimization.", "configspace": "", "generation": 29, "fitness": 0.46705825961299724, "feedback": "The algorithm AdaptiveProbabilisticSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.31.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.9169360647327327, 0.906094856649919, 0.9202503216552174, 0.9231884767992047, 0.9204698196418276, 0.9188512583383471, 0.9228828081467577, 0.9201859918772868, 0.9190785524143494, 0.8339297636448489, 0.812588030116435, 0.8383406633344384, 0.833991064823483, 0.8281522090504916, 0.842821545274071, 0.8339989134298749, 0.8133639429150187, 0.804857942846518, 0.18528536812403829, 0.1790651701560675, 0.17842843051304902, 0.10577217128598293, 0.1867507490860889, 0.12583335961615172, 0.17669269108115115, 0.1330419189893517, 0.13972720388360416, 0.14094020454334477, 0.1578732318509679, 0.12050359888153084, 0.12009797130046207, 0.15765996083538825, 0.10806899780121804, 0.14027734320430063, 0.1771782381324407, 0.10944198654710113, 0.9906480137158841, 0.9841133140531234, 0.9748276225241391, 0.9872951385774769, 0.9514512527243876, 0.9884539199096224, 0.9731783924892808, 0.972401104406104, 0.9888351174394486, 0.7854286929864283, 0.7791386837967559, 0.7357337105167963, 0.8045815422556486, 0.7800035273822457, 0.774822446267074, 0.7861401959468892, 0.7903341989062596, 0.7854182461441268, 0.8242959996639296, 0.2279801310438876, 0.22768808528508844, 0.2787664227678137, 0.19278167478339758, 0.8707403927899138, 0.9224302169097812, 0.22945268809582542, 0.2354456907614606, 0.1349310454195073, 0.57804692405195, 0.701524364725115, 0.7618921911311073, 0.7004371245624654, 0.7937814416555657, 0.6248463280824761, 0.6841019408768303, 0.6522820646061338, 0.5055604067110528, 0.637134469911985, 0.1354491351695677, 0.6734261363997371, 0.6919666155146402, 0.636863846629867, 0.6644391069629403, 0.6796162352705873, 0.6668073417889044, 0.5085823131107523, 0.18839566685474252, 0.11059946327013237, 0.6330100483494601, 0.11459407711980618, 0.49950869524539787, 0.23420943981293363, 0.6933200483799362, 0.47461558523464176, 0.6942200041340787, 0.697447687928289, 0.7346193580572822, 0.7163444299704484, 0.7157666148346181, 0.20675486228375117, 0.6808383319831062, 0.7340467779474258, 0.6605941169064771, 0.1541812251249537, 0.17773661422152653, 0.31526831582120607, 0.3720756133170273, 0.43354047253440664, 0.3936389763680065, 0.19047463337072434, 0.19529406259479376, 0.12502912970753877, 0.3964818443973538, 0.5163031777845146, 0.48028123027167846, 0.4136911520665958, 0.349585351697961, 0.2796692605295723, 0.33225102080918345, 0.3170805482762693, 0.33544968656059004, 0.7968101799412847, 0.8424919248579703, 0.7901252838104412, 0.8152119597730267, 0.7565667106780034, 0.8007469800962019, 0.8334141262082877, 0.8563891919719085, 0.8748611004700351, 0.10560449711418096, 0.13944926075722142, 0.14035365234833885, 0.12995153140481341, 0.11419924335956688, 0.09513915922201199, 0.10374721533361464, 0.12739102175393635, 0.16111223525354612, 0.2685574168554715, 0.17271517819571414, 0.1516748431519982, 0.20732372042153968, 0.165994157581824, 0.13399903420125703, 0.22951609059016975, 0.24273269652385243, 0.19749035974904838, 0.3377207267879574, 0.43660188475355965, 0.5539878691132211, 0.5472069803959709, 0.5256201086880068, 0.6653627665842965, 0.2597111834959034, 0.5545138181624956, 0.278841243267931, 0.3802289678441424, 0.2842818034740767, 0.44953753947176467, 0.33331018964380144, 0.21526059711361167, 0.43886537712800233, 0.39390547003938614, 0.4105171555290641, 0.29157941623401806, 0.22889025146534936, 0.21673808033661257, 0.22084884716884656, 0.22698107026908154, 0.22689992823014216, 0.3224018681203291, 0.23525971897986808, 0.21419114823083296, 0.24815207218620827, 0.17720647298853986, 0.20873250990439418, 0.16935981265009614, 0.2295819106681406, 0.2225739033549864, 0.1858645083258348, 0.18719358989714097, 0.19263268637431408, 0.2504297275634988, 0.9380089405912717, 0.16612662962317848, 0.9149890647323882, 0.9260204473738483, 0.1975058280581714, 0.9333498510563778, 0.8596903307627686, 0.8386421266058681, 0.9225568242477302, 0.8856660179040006, 0.1690838854236496, 0.8710999984522538, 0.854752306187696, 0.16891549166910258, 0.8386777951560661, 0.9119954663056032, 0.9144398541335587, 0.21273267971554755, 0.18691046612697992, 0.1854470325289712, 0.18026347408997645, 0.18194132432933863, 0.21242562299701018, 0.18347606910146674, 0.1788315195359642, 0.20066694968409993, 0.18106629413919872, 0.08812378573023016, 0.09036526397033429, 0.08514201555383971, 0.09604756210080034, 0.09374085451050396, 0.1132594685292928, 0.159166372951156, 0.07894997953391414, 0.09633270691509366]}, "mutation_prompt": null}
{"id": "5f056c19-9a6d-4ec5-bf04-f54149f5397c", "solution": "import numpy as np\n\nclass AdaptiveDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))\n        self.dynamic_scale_factor = 0.5\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def dynamic_population_scaling(self, success):\n        if success:\n            scale = min(1.0, self.dynamic_scale_factor * (self.best_fitness / np.min(self.fitness)))\n            self.pop_size = int(self.pop_size * scale)\n        else:\n            self.pop_size = min(12 * self.dim, self.pop_size + 1)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                    self.dynamic_population_scaling(True)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n                    self.dynamic_population_scaling(False)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDynamicSwarmOptimizer", "description": "A robust swarm-based optimizer leveraging adaptive strategy selection and dynamic population scaling to efficiently explore diverse search spaces.", "configspace": "", "generation": 30, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 9 is out of bounds for axis 0 with size 4').", "error": "IndexError('index 9 is out of bounds for axis 0 with size 4')", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {}, "mutation_prompt": null}
{"id": "d71a931a-7c71-41df-8355-da6f310caf98", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveSwarm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.9  # Adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # Adjusted crossover rate for diversity\n        self.memory = np.zeros((5, self.dim))\n        self.stagnation_counter = 0  # Initialized stagnation counter\n    \n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.3  # Adjusted threshold for restarting\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0  # Reset stagnation counter\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0  # Reset stagnation counter\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n\n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "ProbabilisticAdaptiveSwarm", "description": "A novel swarm evolution algorithm incorporating adaptive learning with a probabilistic line refinement strategy and a dynamic mutation scheme.", "configspace": "", "generation": 31, "fitness": 0.4268071734243571, "feedback": "The algorithm ProbabilisticAdaptiveSwarm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.28.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.883880637579717, 0.865932046925473, 0.8943998437993822, 0.8817049702356993, 0.8726501356065419, 0.8789605313613554, 0.8907577583385304, 0.8750292065387099, 0.8813340336886814, 0.7528531880758871, 0.7659676081014046, 0.7883455780605261, 0.7980948584674615, 0.7590363782805009, 0.7868546255852098, 0.757266719715076, 0.775229811218961, 0.739058526486051, 0.7343693769266659, 0.13826037080199383, 0.17084772503167478, 0.4864107008796702, 0.11688823184286723, 0.11293485999495279, 0.12209997993790933, 0.15174437517769057, 0.17058723794709896, 0.16252945835118482, 0.1339061584882698, 0.11330704689423798, 0.09247346297801429, 0.13624081309578617, 0.09465809092335964, 0.11273831660640898, 0.09533450164531498, 0.15660308879184215, 0.960576286784577, 0.9690791713682196, 0.9815164799245167, 0.9738687911594007, 0.9690220424193225, 0.975701229705459, 0.96520870284603, 0.983213341340341, 0.9908168254103331, 0.5825095205441584, 0.6571252849310334, 0.6290286538740506, 0.6356927574006362, 0.6529306521710844, 0.6523683679010926, 0.6395059792075958, 0.6523559530964296, 0.6581084381659874, 0.8322153406653712, 0.892856951191818, 0.2255780779230695, 0.8034557453207766, 0.21004236510454166, 0.2740007317919664, 0.8257382424721491, 0.7669163113708493, 0.7695296635988499, 0.48556958986285514, 0.12867562123005505, 0.516303757365255, 0.6564386078299301, 0.6591933258724916, 0.7146988142286705, 0.6118198764851912, 0.5779934313775383, 0.7150739143295228, 0.6073011886331322, 0.6438432026329752, 0.6334243999306519, 0.6619694899935851, 0.5915053351825195, 0.7323245906594191, 0.6248121194740881, 0.3551243489223882, 0.6891538872027294, 0.5479613747285397, 0.472100410709413, 0.46926044078950424, 0.4732330272630334, 0.503924998459562, 0.41416384680241836, 0.40767660480118584, 0.38910874819232033, 0.5474156098654024, 0.5881051807638228, 0.6681806767082561, 0.5174254884312687, 0.48121032638636785, 0.6062836068557951, 0.510075452378281, 0.6072552113442422, 0.6377498036374785, 0.6865446282831249, 0.11502180382567617, 0.15079654157643874, 0.25036934564628743, 0.28465039612104415, 0.23041806410521015, 0.24938512295584792, 0.22243699524108196, 0.16936836532933863, 0.1400381340657565, 0.38075992898784494, 0.30516083443984365, 0.3633515869700473, 0.38600206835098094, 0.38436677519000606, 0.4046706282729028, 0.24956189374460458, 0.33944146891026583, 0.31441740763953285, 0.7338673002227887, 0.7422009162779266, 0.7787676163922594, 0.7909641127139312, 0.7611196126746984, 0.7439946771281472, 0.7230450998511933, 0.7664490786076489, 0.7811252405776923, 0.10443571665912532, 0.12277817121219725, 0.12025209356795785, 0.16467751287760712, 0.11232791780835394, 0.0920838432795601, 0.13527350747260247, 0.11844465381917613, 0.1053397153352289, 0.48436522858394215, 0.2570579243369052, 0.1872756466181228, 0.13766266535167793, 0.1604805111652564, 0.14171286019839557, 0.17717529147389144, 0.23292824663001765, 0.22809625964175573, 0.3420600829388917, 0.43289139740401184, 0.32093758888133406, 0.5014903469123961, 0.31502692778541663, 0.28987121403055605, 0.4170128170686438, 0.25721462714404775, 0.34165228500927847, 0.29706993392607095, 0.25943064672890415, 0.29242943313638403, 0.3330727407660038, 0.2617520326246868, 0.4264599722528394, 0.24373952372292074, 0.22370004838416402, 0.21974395140109892, 0.23770755098392637, 0.2254760105237854, 0.263592141298826, 0.2656870326350782, 0.24007120277574645, 0.2884044406594932, 0.23145277600026848, 0.2187760147603478, 0.3295461031595909, 0.20314230203224615, 0.22291851036775479, 0.18530907239385175, 0.20447239106547266, 0.1868425231282852, 0.22330295019962532, 0.20643457580416302, 0.20685996222172431, 0.18195584187496683, 0.16344616622902375, 0.8738510828905282, 0.18683353701682703, 0.17132819934023724, 0.19660374716223905, 0.8996424645866598, 0.8702513822047567, 0.14218743478856688, 0.16592759493364573, 0.20169311490610553, 0.16757954471494418, 0.8424651329618571, 0.2117227584160949, 0.20991491807954998, 0.15340206258724398, 0.791743877004363, 0.20910553126408338, 0.15465357604142627, 0.17995748479093032, 0.19271908629139278, 0.18210909175225243, 0.17557629482057768, 0.18833982128579285, 0.21487894834989896, 0.1764613002281754, 0.18802076760602904, 0.177517655288272, 0.08746482716362403, 0.08307975915488641, 0.07530388224763851, 0.07306366655871588, 0.10472729622878019, 0.08716484624793552, 0.0694079472600484, 0.08235812483717642, 0.08706768088449968]}, "mutation_prompt": null}
{"id": "b5683b23-65e5-4d0d-bc59-363259379ece", "solution": "import numpy as np\n\nclass AdaptiveWeightedEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.35, 0.35, 0.3]\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((5, self.dim))\n        self.weight = np.ones(self.pop_size)\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_weight', 'current_to_best_weight', 'memory_weight'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_weight':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2) * self.weight[idx]\n        elif strategy == 'current_to_best_weight':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) * self.weight[idx] + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_weight':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x) * self.weight[idx]\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_weight':\n                self.strategy_probs = [0.4, 0.3, 0.3]\n            elif strategy == 'current_to_best_weight':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n        else:\n            if strategy == 'rand_1_weight':\n                self.strategy_probs = [0.3, 0.4, 0.3]\n            elif strategy == 'current_to_best_weight':\n                self.strategy_probs = [0.4, 0.3, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n\n    def adaptive_restart(self):\n        restart_threshold = int(self.pop_size * (0.15 + 0.1 * np.random.rand()))\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n            self.weight = np.ones(self.pop_size)\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.weight[i] *= 1.1  # Adaptive weight increase\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.weight[i] *= 0.9  # Adaptive weight decrease\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveWeightedEvolution", "description": "A multi-strategy evolutionary algorithm with self-adaptive weight adjustment and dynamic restart thresholds for effective exploration and exploitation.", "configspace": "", "generation": 32, "fitness": 0.38934401787941786, "feedback": "The algorithm AdaptiveWeightedEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8845834080171013, 0.883764193618434, 0.8886443988200263, 0.8985455813965306, 0.8936134695464771, 0.8866161262464817, 0.8914957590886947, 0.8926565632418133, 0.8895112042663209, 0.8051300561993365, 0.7868693777631233, 0.7950021942564405, 0.7828878771161338, 0.7633252846890752, 0.8275157015676076, 0.7984291321974318, 0.7847672181670522, 0.6980271716540349, 0.17005605549534486, 0.2866194863313002, 0.38472453058963474, 0.15051353811480406, 0.4422850287298796, 0.4402865042666274, 0.36939066146777066, 0.17873603640620572, 0.1533668621420815, 0.10703186287454058, 0.13442773244869188, 0.08246536235224944, 0.14387167810777668, 0.15565183045896214, 0.11275823671979501, 0.156603437466468, 0.13086042544763077, 0.1442211299040328, 0.983982377849929, 0.9767891513121002, 0.9705584831599948, 0.9826330524673398, 0.9810027165443519, 0.9894603285851054, 0.975875202692881, 0.973248246327449, 0.9903739863316126, 0.5139731070520915, 0.6344481282798051, 0.6660249056640598, 0.6501471439263001, 0.6295952348908977, 0.6581807849331327, 0.6065905318365032, 0.5820747537590597, 0.6886083430838464, 0.7847397447654576, 0.8118803582931227, 0.6901206640063899, 0.783728202395378, 0.2663703640568311, 0.194186882649535, 0.7622513592278544, 0.17782629777779535, 0.23370219264244563, 0.24676185911418902, 0.38317801079224423, 0.28512728885230076, 0.2395576480745366, 0.18196653434261933, 0.3531059433881134, 0.2797985321585771, 0.39884710706035054, 0.6099848924822721, 0.30292314370546203, 0.2790572479544102, 0.42003113162857386, 0.45909812927769944, 0.39268611738581016, 0.5256871453751679, 0.46610836292547375, 0.3259173030279535, 0.5756230083332468, 0.16839969550298306, 0.23854070301417962, 0.07435901147823265, 0.21832010919652167, 0.06795434240954634, 0.3719123182870929, 0.24147559170547572, 0.2611147813509075, 0.3525486938915995, 0.2961969233113734, 0.37340987708116746, 0.26325858893226983, 0.33889132232983, 0.41541823678193757, 0.3103722716430569, 0.3703510910585903, 0.3714960706088708, 0.15031332085423688, 0.1390748334151809, 0.05863408068666598, 0.17814993478494545, 0.11556651405148366, 0.26292032251544883, 0.1348447339525246, 0.271406968326674, 0.28988252059961783, 0.28438070239337687, 0.2386250096688568, 0.2993031567828893, 0.24386491473464467, 0.36910046463425294, 0.42054593202848745, 0.3420074627701022, 0.35946739221652146, 0.2796247225783012, 0.20511084462612805, 0.7633106414228628, 0.601997086115232, 0.7179454138468118, 0.6448481034052953, 0.6416287943323408, 0.709565091221869, 0.7486032592624804, 0.7726336306490322, 0.7117522298670997, 0.0982418802671291, 0.14657006736287492, 0.0829329967203627, 0.14107453412178383, 0.12835246540318024, 0.3754603050680857, 0.14803790647904913, 0.10718207501791088, 0.12950606776797446, 0.16889075359221517, 0.15425976923726648, 0.16189180166260098, 0.1321680817798344, 0.18489174386412488, 0.18550956174604782, 0.14814244133195154, 0.16106119043794564, 0.17998538090929017, 0.2271339630678214, 0.45434487855259253, 0.42690966997924296, 0.42320451548170823, 0.5030782017980306, 0.48205347874743576, 0.33244647678532846, 0.3551871549945894, 0.3901411372865725, 0.2284727163509146, 0.3121617412325418, 0.4026464459608534, 0.36378320916458173, 0.3603073898030883, 0.26097609419493206, 0.24538807132155283, 0.2497668713929898, 0.25514181859863294, 0.3024449627300493, 0.3334444806100896, 0.27210865363902925, 0.1981876709452869, 0.34296131704458144, 0.32797564949541125, 0.2638792102422426, 0.3560496950706008, 0.2614576428471769, 0.19382989416073138, 0.19778296523595595, 0.21742396591119306, 0.22122131143071655, 0.21360355916975238, 0.1782292802316442, 0.2048680607683101, 0.21513602661108266, 0.2145815112338897, 0.1859401920586814, 0.18741476741480234, 0.15217547447892343, 0.18487066595741786, 0.19441867041422545, 0.675427983549182, 0.6348617402819202, 0.6976382642211933, 0.1672665534831267, 0.8517646395995924, 0.21186156280303414, 0.7553294875000977, 0.2072637040459392, 0.20829689420231157, 0.6358083045406402, 0.2114369858832269, 0.703626858147734, 0.824850650722799, 0.18486314845574525, 0.20594149686298535, 0.1741011909703022, 0.1928454419328942, 0.17371920710232247, 0.17967786302975242, 0.1867627203890172, 0.18309601643870932, 0.17572995014941062, 0.08565854278332174, 0.07589360644525445, 0.08260001263536065, 0.08114572261460329, 0.07734393118177907, 0.08680512573626242, 0.1039205316166133, 0.08313363929545103, 0.0841128222556703]}, "mutation_prompt": null}
{"id": "34829109-33ae-4fff-9e39-d7eb3a1190c1", "solution": "import numpy as np\n\nclass DynamicHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.35, 0.35, 0.3]\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((7, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.40, 0.30, 0.3]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.30, 0.40, 0.3]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.4, 0.25]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.4, 0.35, 0.25]\n            else:\n                self.strategy_probs = [0.35, 0.35, 0.3]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.3\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicHybridOptimizer", "description": "A dynamic hybrid optimization algorithm blending competitive strategies and periodic restart to enhance exploration and exploitation balance.", "configspace": "", "generation": 33, "fitness": 0.429817691296016, "feedback": "The algorithm DynamicHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.27.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8559383250379877, 0.8787272833730209, 0.8589437350580774, 0.8793384169974413, 0.8563173547729381, 0.8394612363075582, 0.8661212379782744, 0.8632218941220455, 0.8606954916557833, 0.7380758924451621, 0.7357288234958861, 0.6742094396578436, 0.7667095413926595, 0.7147735908007494, 0.7173104947573535, 0.7246329471827168, 0.7374627982049371, 0.7010267527182321, 0.4884433888664075, 0.15820000377113952, 0.1390220080721094, 0.5152470956891955, 0.11603201742378877, 0.24902881422861245, 0.14590131536653517, 0.13262722562376184, 0.14545266598129403, 0.10810021678238668, 0.15116727608599068, 0.10589044855768392, 0.14087830947738966, 0.09927896062073993, 0.13547009087034034, 0.15215742973759094, 0.10518672004420737, 0.1291567464110489, 0.9773293409784455, 0.9913037723711384, 0.9512567334396493, 0.9782682753851711, 0.9789606791838453, 0.9753524752930807, 0.9763548016794604, 0.9527522247909224, 0.976369482285275, 0.655195488557811, 0.5813625947854519, 0.5691315804735136, 0.588076944083044, 0.6138924280039859, 0.589895224432913, 0.613913688702955, 0.5853736145090503, 0.5821548706452033, 0.8039066075760647, 0.7494232794454205, 0.8256985596368654, 0.7674837163297342, 0.7987362543672131, 0.8009894706958334, 0.7460967721082451, 0.8116554840418125, 0.22745080035965504, 0.5624197819702796, 0.5585780751642937, 0.5152641221530855, 0.4273159575366482, 0.4592305319367882, 0.465412224742757, 0.4544625933469634, 0.4437388467458284, 0.5019390000717232, 0.44982771227413787, 0.5859297072381717, 0.5391057298127329, 0.6014082444178862, 0.4371447330554835, 0.7243503483614682, 0.611573673057207, 0.6239334230693803, 0.5673970489010569, 0.34253963371846297, 0.35606833320362297, 0.39157586541811906, 0.24248254514816658, 0.43982509663238134, 0.38233401483622276, 0.5585266276309022, 0.2822562440005705, 0.4747983301281383, 0.6794502819975994, 0.49069628808900045, 0.5640412482764183, 0.5727465085466448, 0.5863497203784866, 0.512699411038525, 0.6693728764377758, 0.6189146358023473, 0.5883123865331108, 0.08936008699706521, 0.26309929852602687, 0.12958076353703651, 0.2696580171991484, 0.2473205431450367, 0.28322733474560835, 0.25496653641149813, 0.1376127996707348, 0.11853160078688618, 0.2742176410891337, 0.3552723162134003, 0.30147211699708154, 0.38735777017588024, 0.367084036654838, 0.33008238197173867, 0.31190688793107946, 0.32150522400901105, 0.3143452635434122, 0.7518525304996512, 0.7782834405063515, 0.701721659390852, 0.7518626696784985, 0.7974909600339565, 0.739028012749781, 0.7934153414475826, 0.756752383085912, 0.6983546683556803, 0.12786742392533723, 0.1345054797121451, 0.13301881631923984, 0.14390045022889608, 0.09938113250903258, 0.10140494112802756, 0.10673462924594224, 0.12416118717447389, 0.1069253025363085, 0.18649273401477562, 0.21821996295531276, 0.18174884164452054, 0.15082207477465948, 0.17080453001017049, 0.13712476272310037, 0.19697803309192152, 0.3772159323667451, 0.17377988525257193, 0.4024127515037704, 0.2599347998514766, 0.4393278118931673, 0.3548662741149218, 0.45862949002725517, 0.38343719957501043, 0.2920122727768, 0.5737269718430495, 0.5198295150757681, 0.33876496843217085, 0.2882314618542068, 0.2603402822147949, 0.26977953487140405, 0.29602534080563614, 0.3738392533882018, 0.28130519317644287, 0.3678723158455911, 0.21290463342414812, 0.282683960806006, 0.2568413181824015, 0.2429713188828999, 0.23290750392720083, 0.2281990641798055, 0.27401376299882063, 0.2854457701707305, 0.26246860055765175, 0.23323865613708594, 0.22153571471531985, 0.21477054843625953, 0.18757762589000526, 0.18827936252153799, 0.21582946483079635, 0.19282749343657346, 0.1918308883770664, 0.23491677265295152, 0.21326763569338636, 0.7445873101046177, 0.18739626903941264, 0.18657982352828573, 0.17655783557875016, 0.19689577124193214, 0.14541213367794792, 0.18264222549156062, 0.8449512763064331, 0.20719808743851487, 0.8447230119463534, 0.20976704050562234, 0.8161746621923378, 0.826585827881853, 0.7969673956163785, 0.8428586323657399, 0.20255516662827, 0.8093832933909407, 0.8207519847995675, 0.19524303186793646, 0.19797587274415962, 0.1780690683167706, 0.19981837736959596, 0.18252959507490907, 0.18798154557759594, 0.1767077323504178, 0.18129036328697645, 0.1800064236847374, 0.07338660373753969, 0.11453798393552284, 0.08570608987812922, 0.07472556141793862, 0.07491055522330703, 0.08133063136238083, 0.08515717776858744, 0.07125672855262988, 0.09236333661639895]}, "mutation_prompt": null}
{"id": "c34fbf69-0a98-444f-913d-8013faad1d41", "solution": "import numpy as np\n\nclass HybridSwarmAdaptation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 14 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((5, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < (self.crossover_rate if np.random.rand() < 0.5 else 0.95)\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.3, 0.25]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.45, 0.25]\n            else:\n                self.strategy_probs = [0.35, 0.3, 0.35]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.3, 0.45, 0.25]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.3, 0.25]\n            else:\n                self.strategy_probs = [0.35, 0.3, 0.35]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.15\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridSwarmAdaptation", "description": "HybridSwarmAdaptation uses hybrid mutation strategies and adaptive population restarts for efficient exploration and exploitation in optimization.", "configspace": "", "generation": 34, "fitness": 0.45896186273582146, "feedback": "The algorithm HybridSwarmAdaptation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8722331736010959, 0.8761457622435729, 0.8763388545587956, 0.8941352327535323, 0.8659590281467592, 0.8723483408131233, 0.8774018197944512, 0.8628811472977426, 0.8799123125937336, 0.703337730548661, 0.7486582066755467, 0.7453736221912821, 0.7694267494014291, 0.7530027467355996, 0.7587222658642685, 0.7031916727795611, 0.7315924253672632, 0.6502362639844783, 0.1356825333614683, 0.2800108576369196, 0.13495453251193756, 0.12286206553089052, 0.3886379266541854, 0.1579567113895589, 0.12615638908914084, 0.16152097329161574, 0.15295333987224768, 0.13652355752458245, 0.13212700224271556, 0.1307280327735505, 0.1077378325295103, 0.1222411343348051, 0.12990108849063675, 0.1488787290455892, 0.11894379003085598, 0.10678845770887424, 0.9778747323018783, 0.9474306590380857, 0.9509399635238749, 0.8972329024791477, 0.9001299701725463, 0.864770764865578, 0.9731312501370852, 0.9744511823770624, 0.95124008267225, 0.6858573099185614, 0.6728347008713398, 0.6749198940960897, 0.7009599294419362, 0.667056723092381, 0.6806553626937357, 0.6947304396291079, 0.6761284946640502, 0.7020462827601144, 0.22657744133972368, 0.7558499982200125, 0.807622604572865, 0.21052219599740352, 0.8403495818178146, 0.8152283498167755, 0.8924825565272734, 0.8409243569885586, 0.8264326646836868, 0.7283017868087883, 0.6172024941605248, 0.588360908921155, 0.5154520807758534, 0.5737659039578026, 0.12440851346222737, 0.1326334283324444, 0.562173597194972, 0.5062522916152644, 0.5569528182905705, 0.6065155325053179, 0.5813158491667493, 0.6010589441884739, 0.6228441267130742, 0.7431007203306355, 0.1325629597318697, 0.6946028117472876, 0.6092085888142675, 0.5605890811380394, 0.5758702853329215, 0.5105725228956346, 0.6030956083771748, 0.4406449161984546, 0.5739838809641724, 0.36800391530581233, 0.37675658911181853, 0.6250877768466567, 0.7088326392939885, 0.7171564159534944, 0.7081373112489977, 0.6686285331343493, 0.6826600547799921, 0.617465436220707, 0.6915837286180821, 0.7004205410143933, 0.6668558234257249, 0.12112721847421903, 0.0923174009675557, 0.10591772637168961, 0.32309443789526227, 0.46538423878377877, 0.23078153869484253, 0.21705761684876346, 0.3590681485981698, 0.11553691800601062, 0.4868289747029565, 0.39531129151274613, 0.4986530520039242, 0.5135097964668282, 0.5386912330010396, 0.5038408327678497, 0.5427535514398902, 0.37510626232382605, 0.4981496403471142, 0.8351864438918322, 0.7455635901261446, 0.8024622516810398, 0.7915378049594466, 0.8038414143626824, 0.7926966544601086, 0.8047563779671293, 0.8101753305300519, 0.7949016763757595, 0.13668859381139864, 0.10096453369192948, 0.1157248408674797, 0.1242488227892834, 0.09365862969135341, 0.15642658827770684, 0.13553992309051155, 0.13290641883088372, 0.1410830872848906, 0.1508193398735319, 0.23707420553466962, 0.14564782258728337, 0.13766266535167793, 0.17637518530014407, 0.16608239552723392, 0.1715791297283109, 0.1494732184691031, 0.20320558964579483, 0.3340733447944887, 0.4690973487341129, 0.4527416874265199, 0.4189832021961021, 0.6403015959151519, 0.35266576701840335, 0.5927657425547679, 0.4623413416608624, 0.5644983732152686, 0.4350199816046647, 0.31991432278857024, 0.2836737143226127, 0.29619440137341213, 0.46924336623593355, 0.35084921231443755, 0.3814009092804126, 0.4177956252010545, 0.49678512171460176, 0.21903393594056986, 0.23012865627962076, 0.24253318988425288, 0.219069139856938, 0.22077675811915543, 0.36032175510689035, 0.22755837338672014, 0.2300806009132299, 0.23278633031147788, 0.19168267583307974, 0.21906373136484059, 0.19870029391955057, 0.20532932797872738, 0.19978601802482077, 0.20509189286291707, 0.19281242525522113, 0.18634250306588407, 0.18208985700869973, 0.18606466020860568, 0.18771228811863538, 0.18748326587512187, 0.7903515601143625, 0.1950106182410808, 0.726139089290861, 0.8456110975118607, 0.1723760874512582, 0.8754708041746604, 0.8379485310994061, 0.2055201312439332, 0.780580211591224, 0.7944005753437462, 0.6280847576140316, 0.80150120995035, 0.7862909869841814, 0.6808420035097931, 0.7242320669833238, 0.17040000100159736, 0.19727377705162186, 0.17991798653696245, 0.1839087481277234, 0.17719311505112945, 0.17646085960346614, 0.19198637316576994, 0.1883357458128575, 0.18977586236511912, 0.0874603800528383, 0.08901275981093404, 0.1007874392493393, 0.09388213302686965, 0.0802435358939223, 0.08585902674940404, 0.09725947495946607, 0.07959392717492897, 0.08290520197261664]}, "mutation_prompt": null}
{"id": "384fb908-f231-4363-a5c4-a0baacd4f8ef", "solution": "import numpy as np\n\nclass EnhancedAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.45, 0.35, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.2\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedAdaptiveSwarmEvolution", "description": "An enhanced swarm evolution algorithm integrating adaptive multimodal learning and restart mechanisms for diverse and robust optimization.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8887990208664761, 0.882135162571395, 0.8800021827170379, 0.8761506347206214, 0.868222380265006, 0.8864329023024237, 0.8913978600084962, 0.8750883202622485, 0.8765122913967979, 0.7996012961433303, 0.7601016716676223, 0.7888110792742642, 0.7855303740170825, 0.767010600176205, 0.7633036346196941, 0.7550984325884691, 0.7534718586594246, 0.7306413298930718, 0.11426354317746368, 0.3792967645477765, 0.15480840383483552, 0.1426326180054348, 0.1594257653166884, 0.12449979711561154, 0.18038837275043984, 0.11347197788441155, 0.15612838417218278, 0.1253585294767945, 0.10945739091138607, 0.16285216771680355, 0.14405065827995367, 0.1540056850848308, 0.10814973313787835, 0.1321292251291759, 0.12761594222088313, 0.129062800687184, 0.9588563301308358, 0.9770186442740255, 0.9743467497156041, 0.9737578768733234, 0.9741610860444347, 0.9272975939797221, 0.9776450727123396, 0.982760044823005, 0.9821691330955189, 0.6542824293404894, 0.6824741960136936, 0.6738386724176656, 0.6839644732548134, 0.6260005901840742, 0.6897288039222864, 0.7317847824692857, 0.6887781922849043, 0.6887369371519623, 0.8351970587126109, 0.875108395002298, 0.8279747606600489, 0.8306204543740361, 0.2775736778920266, 0.8418335463365642, 0.23135706770400022, 0.8697675898176287, 0.8781427558078928, 0.6295696295708102, 0.39798133497523736, 0.5134179201182463, 0.6893883057950579, 0.5306827479956866, 0.5071174247715582, 0.6321299315750546, 0.6637498639689239, 0.5969235338312533, 0.6566505698967497, 0.6447785649575509, 0.714962182719847, 0.7228313929938426, 0.13339036920185665, 0.6045212512378936, 0.6863968198289694, 0.5674262720241092, 0.6663937293582061, 0.5689954142829856, 0.6794775272129433, 0.48255955287564556, 0.5687348770383682, 0.6750965305818859, 0.35107950932787513, 0.6213507276127914, 0.6451627041431374, 0.7444017700211563, 0.7373715200245796, 0.6831618487934314, 0.6865000124629842, 0.723743323515186, 0.719751825783786, 0.7172998690174345, 0.7395329207765633, 0.747945846350171, 0.7109113231090456, 0.29082023606376217, 0.3466787271450621, 0.16198636137468492, 0.3264878524654523, 0.2784305243962333, 0.49091744599354814, 0.3255831859623405, 0.11530709287258256, 0.26202152785058264, 0.4697473968100043, 0.3880540303094141, 0.5238892526408816, 0.545055872844695, 0.44738561912084274, 0.5929907507949895, 0.5026079615960085, 0.37298318306894607, 0.4592218261718608, 0.8322479347175425, 0.815745291982929, 0.7399032663152292, 0.8072262586434633, 0.815657488970593, 0.8128097242311388, 0.8525446608487148, 0.8220797173290308, 0.8096155156740124, 0.13917028473674964, 0.12662306190897177, 0.17627898241884454, 0.5774318261383671, 0.1067169427194643, 0.13929051895540467, 0.13022057784617025, 0.13162501648839264, 0.13294710850323954, 0.17577095594355052, 0.2405701642050051, 0.18387980055531528, 0.13766266535167793, 0.13808975186029493, 0.1759728142837177, 0.17649136159870848, 0.16044953219056146, 0.2123938211841333, 0.2641402037919117, 0.3894551489281699, 0.4250233762847102, 0.49089102624268444, 0.39726352947187815, 0.5170763738591784, 0.5689279377013869, 0.5450131351881142, 0.5809962388397318, 0.23127781644827672, 0.3509451623749118, 0.391782707077048, 0.25943151429857925, 0.2866779799363486, 0.2981829637352025, 0.24747332922890863, 0.4601995568790066, 0.3886995786532508, 0.2491117512308001, 0.2005322984866198, 0.236068022250695, 0.24192988503071156, 0.2168579145108669, 0.20803841657694766, 0.23986492188937003, 0.25094633972134694, 0.2588355784204359, 0.7026961156969743, 0.24027957033238279, 0.18618517976657412, 0.24143824432448668, 0.19873368629616484, 0.18956068592799458, 0.23608728010716973, 0.5325753545555545, 0.19978948927938367, 0.8915835420130211, 0.18666305960378649, 0.8862569774603997, 0.1935462299211923, 0.16611504841989977, 0.8990703216559006, 0.8785044686796355, 0.1662280669913293, 0.20301933008316642, 0.8774205088368929, 0.2086551337733813, 0.8254287570021093, 0.2101210258070304, 0.8107340497843116, 0.20966334706663214, 0.1553034077062765, 0.1657364678112162, 0.16497668423950052, 0.19334891535625476, 0.18746852336800301, 0.18118621311653937, 0.18371795944307168, 0.1763701938719867, 0.1804425472825797, 0.183244286576979, 0.18410329364134026, 0.18747936421939893, 0.07900073439118371, 0.11034659391235602, 0.10250319676559083, 0.07292895368773222, 0.09959528007087626, 0.09708645323016896, 0.07620543276391667, 0.07792887169345453, 0.09862647327252849]}, "mutation_prompt": null}
{"id": "a05efe99-582d-4e1f-bcb6-177498e20cc3", "solution": "import numpy as np\n\nclass NovelAdaptiveSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.3, 0.4, 0.3]\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((5, self.dim))\n        self.stagnation_counter = 0\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.35, 0.3]\n            elif strategy == 'best_1_bin':\n                self.strategy_probs = [0.3, 0.45, 0.25]\n            else:\n                self.strategy_probs = [0.3, 0.4, 0.3]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.25, 0.45, 0.3]\n            elif strategy == 'best_1_bin':\n                self.strategy_probs = [0.35, 0.35, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.4, 0.3]\n\n    def adaptive_restart(self):\n        diversity = np.mean([np.linalg.norm(self.population[i] - self.best_solution) for i in range(self.pop_size)])\n        if diversity < 0.1:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "NovelAdaptiveSwarmEvolution", "description": "A novel adaptive swarm evolution algorithm employing dynamic strategy selection and diversity-driven restart mechanisms.", "configspace": "", "generation": 36, "fitness": 0.3746114281007414, "feedback": "The algorithm NovelAdaptiveSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8828655205278111, 0.8959180682066904, 0.8991176574912805, 0.8806574017400592, 0.8771350827981694, 0.9049222653623799, 0.8792360885254151, 0.889584206283082, 0.8942479491743629, 0.8172750043358649, 0.8007186104820564, 0.7951526428140906, 0.7713835009494685, 0.8016130200965818, 0.8274993084928176, 0.7700704407907017, 0.8060619488435892, 0.7799001948111433, 0.1159537273134853, 0.1621594741583089, 0.14622056262425864, 0.14561355576584634, 0.12331193299657894, 0.14353011063532972, 0.1237567316240229, 0.1896809535435645, 0.15610074887449188, 0.08920699832566348, 0.05826589649811176, 0.18847309481082242, 0.13061580140618445, 0.15438681631508533, 0.135255616842201, 0.11482510840588167, 0.11911037877547848, 0.14173541817025448, 0.9860731658092546, 0.9817847986399183, 0.9756343168070847, 0.9761307175764566, 0.9920669477654303, 0.9695512680609102, 0.9796608049523433, 0.9831744319293682, 0.9737257914476098, 0.6026906305612424, 0.6766230968438798, 0.6390762968969705, 0.6714377381746586, 0.6253098163285251, 0.6259267552190843, 0.6166147785069644, 0.6150510877870876, 0.6182676959609441, 0.7936315545605195, 0.24083307769106999, 0.39559684303701315, 0.27672981582563827, 0.2726630756444258, 0.28080116517287024, 0.8680598559605197, 0.37441178796142605, 0.2353382486217389, 0.5456321752244957, 0.5435282575237012, 0.505308951100886, 0.6449050429099467, 0.1304379213880278, 0.13315233113143154, 0.1289045092654627, 0.4571161297722055, 0.3652843111659343, 0.49361905809323714, 0.31728984276658134, 0.5035514587088361, 0.5557317973162215, 0.5012832361802851, 0.5022180662164808, 0.5689786209732121, 0.5630693629891825, 0.596746627408939, 0.11743818648000814, 0.4199510522147244, 0.08692594993504843, 0.04698733935494315, 0.2776892520836446, 0.24388483784162396, 0.24931425620856584, 0.14007964708775522, 0.13558460950639106, 0.10173357408663375, 0.227286036569467, 0.1963337617720703, 0.2384942382113625, 0.3511674883300765, 0.09174729923458613, 0.2911184480452286, 0.3838451985574306, 0.13254006801761842, 0.36035634749645773, 0.06500304826071623, 0.3300354817662181, 0.13268802096821453, 0.2110916765561356, 0.2840753711495344, 0.2739277171352058, 0.0751266260163218, 0.14635205654432926, 0.19571683764690628, 0.23013584755781225, 0.09575049307868555, 0.1409109848161384, 0.17647243315377759, 0.2845761741935977, 0.13717193744505307, 0.29390030162347724, 0.11418645421783569, 0.7186233032101109, 0.6541191637070207, 0.6521745566252706, 0.6092231922166953, 0.7085470970817338, 0.7019041162409032, 0.6644593977752768, 0.6835436342742451, 0.6782467052251957, 0.11109228354917855, 0.11653129019122066, 0.0812764578813241, 0.10208090315876706, 0.08104624190603704, 0.09502436661148972, 0.10145836058813729, 0.10977736645386083, 0.07263174730153843, 0.26764058397022494, 0.1733726141970081, 0.2201960694082693, 0.16245137799053222, 0.32422268784231056, 0.23282107465474777, 0.12963223522793454, 0.18495856509233566, 0.3432723925828203, 0.2353236538218173, 0.4425995193344143, 0.3044198066089866, 0.2492633829904436, 0.5366055438693159, 0.2632999821752432, 0.29864241306051287, 0.34984561499236155, 0.2629825401719087, 0.24526992666392367, 0.28840162570673256, 0.1822915056971779, 0.3274939976900273, 0.28670273332945284, 0.29033593429382343, 0.2140633231632353, 0.2821902871247277, 0.3567205299583073, 0.2626561298933109, 0.2724239420178902, 0.3466610995549394, 0.3543698178170842, 0.28956226560622167, 0.3388593830267401, 0.26092981853315944, 0.3265813566275507, 0.33806180414522824, 0.18869419868397175, 0.8287706984190928, 0.24764438268016398, 0.18290094916997546, 0.17992462537884313, 0.1776533848394829, 0.19878931836431635, 0.19052716704671235, 0.22336325219862163, 0.9234805723026152, 0.18402637710647796, 0.15334506515777901, 0.18869988373912538, 0.2000923115030251, 0.9242153417100051, 0.1840411911359251, 0.16473642032748048, 0.13386107730904973, 0.9123676450529911, 0.20935849958697494, 0.8441841906024821, 0.21198606897089012, 0.20885972356539495, 0.15534379475282023, 0.1671809755214867, 0.9065589862266752, 0.8885496401835185, 0.17068864265026673, 0.18124825414997303, 0.18871250935711437, 0.20103147300307733, 0.18660445625098543, 0.20275125981282038, 0.1835672714977471, 0.17013049333969155, 0.18732474459282455, 0.12577329312938978, 0.08645836555963471, 0.06173835831814667, 0.07490827544279677, 0.09635702107838517, 0.1006928847383255, 0.10084009160515817, 0.13744762219575624, 0.0989678328106649]}, "mutation_prompt": null}
{"id": "bcc13abc-1821-4a86-82a6-a5cd0fedbf47", "solution": "import numpy as np\n\nclass RefinedSwarmEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.3, 0.5, 0.2]\n        self.mutation_factor = 0.85\n        self.crossover_rate = 0.95\n        self.memory = np.zeros((7, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['rand_1_bin', 'current_to_best_1_bin', 'memory_mutation'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'rand_1_bin':\n            indices = np.random.choice(self.pop_size, 3, replace=False)\n            x0, x1, x2 = self.population[indices]\n            mutant = x0 + self.mutation_factor * (x1 - x2)\n        elif strategy == 'current_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_mutation':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.5, 0.2]\n        else:\n            if strategy == 'rand_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            elif strategy == 'current_to_best_1_bin':\n                self.strategy_probs = [0.35, 0.45, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.5, 0.2]\n\n    def adaptive_restart(self):\n        restart_threshold = self.pop_size * 0.15\n        if self.stagnation_counter > restart_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_counter = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        self.stagnation_counter = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                        self.stagnation_counter = 0\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_counter += 1\n            else:\n                self.stagnation_counter = 0\n                previous_best_fitness = self.best_fitness\n            \n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedSwarmEvolution", "description": "A refined swarm evolution algorithm with dynamic memory and probabilistic mutation enhancements for better convergence.", "configspace": "", "generation": 37, "fitness": 0.45696760778936857, "feedback": "The algorithm RefinedSwarmEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.30.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.8714241562782448, 0.8838931784272983, 0.8965679783872917, 0.8736528924409647, 0.8736573013159167, 0.8779579521180808, 0.8780174815874957, 0.9003356189478824, 0.8745941006138346, 0.7542973373686703, 0.7498807094812016, 0.7648155933986578, 0.7732996085247265, 0.7541026316738757, 0.778810453887888, 0.7460395237308859, 0.7567077041376047, 0.7328616312325439, 0.12579373927424253, 0.09843109584668674, 0.16796304973764253, 0.11329062937935774, 0.13336800883386846, 0.108261632220789, 0.15461947363478923, 0.1407029451107059, 0.147985353891798, 0.12925874310747587, 0.06793020035696995, 0.09491338300191254, 0.13461959924176048, 0.09702527663464755, 0.1140522492791437, 0.11805255024470862, 0.1282593987307089, 0.12129810843152988, 0.9826010114232736, 0.9709104501626827, 0.9830388002467926, 0.9827772442698737, 0.9723788530987563, 0.9594188883887217, 0.9797540286046353, 0.9757689579335737, 0.99084304654381, 0.684110487803909, 0.6742496105034566, 0.6838228982035968, 0.6880257460080441, 0.7134276570889693, 0.7058429171995618, 0.6788110580540705, 0.6993657762196785, 0.7148533824984424, 0.8425627627469497, 0.8673998653697134, 0.24140415588397823, 0.8807620167071333, 0.2132569020846834, 0.8836134263831279, 0.7998716880025512, 0.8584552264911308, 0.8554210007416724, 0.718028411439955, 0.13142314250257625, 0.7501478503425097, 0.678691707842437, 0.12722255067299792, 0.12906351794707893, 0.6767505828347945, 0.12714619918151437, 0.6424548313217789, 0.686778386736606, 0.6823868817161406, 0.677860772647807, 0.644372085211907, 0.6196391230449851, 0.7711398366447652, 0.7295434703888326, 0.7717647623338961, 0.7251060460997371, 0.6345753009569206, 0.6769894005233286, 0.6442249018586853, 0.7094482174253938, 0.689794332391966, 0.5921424299109324, 0.7161031229225706, 0.6346626807192297, 0.5793807035394442, 0.7725521455104146, 0.7241953145310691, 0.7967490459401368, 0.7953403622707411, 0.7197103227470841, 0.6994712844449927, 0.6918956705176275, 0.725632492571429, 0.770706299693517, 0.3440726845806321, 0.1826538391375846, 0.46268687887828897, 0.19856620176674222, 0.39909020956836927, 0.25095861514847895, 0.21355683526078606, 0.42165591949537073, 0.19361258613536192, 0.5493689814973267, 0.5167869609417708, 0.5505876737046355, 0.6060886698727187, 0.5322119483496828, 0.5647493028750796, 0.4401404271929661, 0.5133308428245215, 0.5931781696556877, 0.797916680441393, 0.8050537135594412, 0.7944254383324383, 0.8074129976836045, 0.8037529176188416, 0.831237234742663, 0.8353123233862065, 0.8310567527768662, 0.8348389272177235, 0.11219071268227221, 0.12307037661606468, 0.12260136746257921, 0.11243990946484972, 0.09218339438318612, 0.1076560292000237, 0.07868856471671648, 0.10995073975812553, 0.13648708896446227, 0.5554037524563213, 0.15463630254204963, 0.2037612006968873, 0.13766266535167793, 0.2555634265931631, 0.16139623830340588, 0.2181041506328203, 0.20342606978694444, 0.20619521304878974, 0.3464299538171376, 0.43533981662421917, 0.4297427817351439, 0.35675235217649337, 0.49239148731022664, 0.3280905299878135, 0.31099593189817965, 0.515687121255913, 0.4324961506943559, 0.32713811904431356, 0.3649955930987775, 0.21992381144597084, 0.37469073920745943, 0.3091401725152828, 0.23552490006371263, 0.29490096340457717, 0.3029085094057372, 0.3431903319492208, 0.23221031401766767, 0.25167545602462615, 0.2687408886875261, 0.2492358100133133, 0.407745536722242, 0.23838775224032438, 0.2681368254252724, 0.221260006506252, 0.2273757082271476, 0.1751155346586456, 0.1760466636928386, 0.2093123763850091, 0.18235520667867222, 0.1854471259560384, 0.1767403449458116, 0.18559810387069564, 0.19907480412206524, 0.20365668994058728, 0.1851610900618028, 0.18707420404809116, 0.1859972344703218, 0.9357768679958669, 0.19787732656334456, 0.8775055362851485, 0.14155131317665492, 0.18229508383395687, 0.18510500803155006, 0.169853726628291, 0.2105918446364703, 0.8577845097755078, 0.7355453859309792, 0.20953135478710283, 0.20548378832368785, 0.12808680918902005, 0.826851783203517, 0.21081320435960593, 0.17078649022143122, 0.18245811411237112, 0.19016688672401583, 0.1697472774748754, 0.17246958044872918, 0.19278057487240974, 0.18186360841778149, 0.17478084875721944, 0.20093591110894427, 0.09073130990641498, 0.06259700410774927, 0.09303108432871554, 0.0760402410251989, 0.08234906108234064, 0.07714996124576246, 0.06890957882321125, 0.08343658060438264, 0.07512441232597156]}, "mutation_prompt": null}
{"id": "54cad2d4-d1fe-4081-81af-b3b50d49167d", "solution": "import numpy as np\n\nclass AdvancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.mutation_factor = 0.7\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((3, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.mutation_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(self.pop_size, 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.55, 0.25, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.55, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.4, 0.2]\n        else:\n            self.strategy_probs = [0.45, 0.35, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.1:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n            \n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdvancedSwarmOptimizer", "description": "An advanced swarm-based optimizer utilizing adaptive learning, diversity enhancement, and strategic restarts for efficient global search.", "configspace": "", "generation": 38, "fitness": 0.4732224458754679, "feedback": "The algorithm AdvancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "9c04f4b5-d43f-4d16-9d4d-74302384a781", "metadata": {"aucs": [0.9086314921413186, 0.9012278668901579, 0.9094654908986473, 0.9089121385259202, 0.9009848556906008, 0.9123139175836262, 0.9134135661180461, 0.910045774953493, 0.907352224586945, 0.8119411923207288, 0.8072098168440044, 0.7909377357107983, 0.8178982311395545, 0.8262268119798727, 0.8120803460360209, 0.8117150691166977, 0.8133569717600744, 0.8052150479222497, 0.6233414669909516, 0.6930671694747467, 0.11544568286593271, 0.7336743519587117, 0.14456325349847898, 0.135483431612912, 0.15908420464467432, 0.1826776110127175, 0.15537175359529898, 0.13115994307069745, 0.12012495386090305, 0.10626260544708044, 0.14969907682252237, 0.10932475101640049, 0.1388518164108915, 0.12199364409281566, 0.14883026950684453, 0.11511165649190758, 0.9881622907917963, 0.9815586720525042, 0.971699098135114, 0.9856402010974826, 0.9620447447349405, 0.9816713406826596, 0.987695648490481, 0.9823042069890898, 0.980329341158186, 0.7487134353289605, 0.7511569392507236, 0.7361701839302388, 0.7649789666145512, 0.7873079981510328, 0.7827443368140317, 0.7735418370400301, 0.7605166481976222, 0.7752088673160554, 0.9166539082999218, 0.8718596258189354, 0.9180284970318436, 0.8553794295804891, 0.27787857613668665, 0.9071545989408908, 0.8642508897552771, 0.8864125981255861, 0.908335499272764, 0.63111943407269, 0.6120520303975402, 0.7041620333612659, 0.5592932631417249, 0.6843052161074957, 0.6085852312601716, 0.7223928112926079, 0.6291189282087469, 0.6924820867846757, 0.6464480993434393, 0.6614768683336767, 0.66677895443472, 0.5311433837005353, 0.7351036744677687, 0.6812387527779286, 0.6753085088443171, 0.6928975941439071, 0.7494708588364221, 0.44597213132453917, 0.5329849042665084, 0.5279413908547697, 0.03529375025822812, 0.5687840756310661, 0.4005071118709791, 0.5876244806901332, 0.5917097839574801, 0.6767833618352261, 0.6198277624592917, 0.5702752736640104, 0.5405581130288337, 0.6898812651266967, 0.6538545288276749, 0.5132226740478808, 0.6294832359405653, 0.570800790865079, 0.7169527619941019, 0.14980720374544942, 0.20487024132959653, 0.48177270221458934, 0.3807471266359209, 0.4538353459690032, 0.40895675386613917, 0.14261065222653013, 0.12096067789045828, 0.21301494384868525, 0.4281063685748826, 0.501324292415529, 0.3902648180668091, 0.5717185497874375, 0.46856651289267226, 0.5033732725152035, 0.2949085841885577, 0.42017982722233227, 0.4848866598920335, 0.8147104862776897, 0.8095438775772343, 0.8065013574522697, 0.8316197093495569, 0.832679243267828, 0.8074793659390507, 0.8034636914734274, 0.844536063045003, 0.8313415714264428, 0.13873259039891106, 0.6272537181697752, 0.17635557986843486, 0.09456503956755602, 0.11154306951844029, 0.1186454133239444, 0.14154360082765893, 0.12005227764638915, 0.14122070653400676, 0.1866603558511024, 0.15361570670664204, 0.16114246861374704, 0.35865828188373294, 0.1660010550683566, 0.27280142015635744, 0.2598622261003525, 0.17152181207098693, 0.17788565632429343, 0.4449393932531348, 0.637867734289419, 0.7043270555084691, 0.49262860506695916, 0.4775926587198577, 0.45829463220930977, 0.340844122775379, 0.5471363406723702, 0.7533175399593722, 0.2668726744611377, 0.24950001368094177, 0.3223633766068842, 0.4679149519792287, 0.35486440243704265, 0.2834156429277812, 0.26781100636688693, 0.27921342442327424, 0.3613044235395185, 0.2122298200582874, 0.20710784812815597, 0.22838252780957602, 0.20697860674928148, 0.22285744835825239, 0.23192187208141568, 0.25289601571671594, 0.22099817051909176, 0.22309243800586187, 0.21980535572931392, 0.22145171976833, 0.2351065325707653, 0.2228557689603473, 0.19235599641629875, 0.2245689313912249, 0.24440458875623894, 0.20707166079803674, 0.2456485175145604, 0.9281183081740358, 0.1878376715708302, 0.15367673580709673, 0.9223098135010622, 0.19763074434931038, 0.16669436405498927, 0.18558230505760243, 0.16055589770526368, 0.167593343758891, 0.8629576868200828, 0.21142930915225633, 0.8403680856512381, 0.20856786716512, 0.16787932883738688, 0.21010007631902505, 0.15565872720890783, 0.1045666403014327, 0.15679609447428644, 0.18895467863043136, 0.17972914045934119, 0.18273947509219002, 0.18211924526525158, 0.18697597216610606, 0.19145018266885205, 0.17536517690442777, 0.19619160147828318, 0.17950498480049104, 0.09063287863186542, 0.08416959717687533, 0.11011455298836192, 0.07304063245740322, 0.0842997115745, 0.10303078255673903, 0.07915865591044147, 0.10074419185923777, 0.11349145415788842]}, "mutation_prompt": null}
{"id": "785acc84-43b3-4d2d-9656-258bc799aa36", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.mutation_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.mutation_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.mutation_factor * (self.best_solution - x) + self.mutation_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.mutation_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.6, 0.2, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.6, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.15:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A dynamic swarm optimizer that employs adaptive learning, diversity strategies, and periodic memory resets to enhance exploration and exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.4843627690514741, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.32.", "error": "", "parent_id": "54cad2d4-d1fe-4081-81af-b3b50d49167d", "metadata": {"aucs": [0.9404229242402159, 0.9230549391384685, 0.922349348179784, 0.9266106498632675, 0.931570869996047, 0.9167394598799133, 0.9192487000171323, 0.9285241824352936, 0.9192775728730881, 0.8320565369989632, 0.8375176508904639, 0.8547516894075624, 0.8296380911762486, 0.8287074372265699, 0.8395606133056053, 0.8211690887557701, 0.8387236901484899, 0.8171930013144695, 0.1178990712325243, 0.11435851590487378, 0.10900442204148098, 0.15659623238692622, 0.1614768581928956, 0.1630269381798657, 0.15615774435564378, 0.14276681691700777, 0.1450921688563227, 0.11043314541756077, 0.11397786243528607, 0.11402351701208169, 0.11102934414038212, 0.09521304971714284, 0.09855299938108364, 0.15922264944897124, 0.11488892685630958, 0.16137052146997977, 0.9762731285663182, 0.988724745787857, 0.9881787765736916, 0.9848764172140977, 0.9700578272160578, 0.9841639067809713, 0.9808197730269046, 0.9891744699619153, 0.986357703152909, 0.8202825815229744, 0.8113360830010014, 0.7809167531385981, 0.7947329418513841, 0.8111627894245832, 0.8183408147387917, 0.8262703714016408, 0.7715524284260497, 0.7989929147030123, 0.8849631633566527, 0.8963230717488346, 0.9021027477135857, 0.2788502067516838, 0.21273225802172513, 0.2783961593892924, 0.9320623193558703, 0.9272096410194415, 0.9142493537521679, 0.7333442596906625, 0.7782587853511433, 0.7495288736340444, 0.7459617393459841, 0.13403729531047115, 0.764102084259826, 0.763966395139964, 0.7410016643157291, 0.7628467160736305, 0.7443287323463104, 0.7661699525703757, 0.7587080921511635, 0.8360676295950644, 0.7919574540005774, 0.7421171560025599, 0.8058851272690626, 0.7885599968271395, 0.8091873346608137, 0.6664226468110981, 0.3087102314738076, 0.6591950477494202, 0.3613237443762276, 0.7216277620072289, 0.6127783016244204, 0.7287369667179904, 0.7435648379560238, 0.6956284891860303, 0.7381831141329883, 0.7946837429191367, 0.74358065599412, 0.7564642511925446, 0.7037836503004891, 0.7784858173969863, 0.8174930220929568, 0.7812592239576522, 0.7914946037972522, 0.6584290898332655, 0.3624024576484788, 0.27543678519429526, 0.49329792925082416, 0.6580676556816643, 0.3409485227314015, 0.19259303417259732, 0.30455235847012474, 0.17951285124623662, 0.5671059556588613, 0.37147373527141825, 0.6154383216591461, 0.5301037027636748, 0.5745937358657919, 0.5890846199828395, 0.5825532534641782, 0.3797229071879774, 0.42429882435924726, 0.8843633185708082, 0.8714978537846167, 0.8578554111820639, 0.8868255468047719, 0.8631960453778724, 0.8392526177198556, 0.8729017744146264, 0.8521942851135088, 0.8381316164280335, 0.10460820614585753, 0.1547183160899911, 0.08658621770065489, 0.1214449900465876, 0.142567650592077, 0.1453494419031891, 0.10553453291838799, 0.1151683198537985, 0.11448427363183689, 0.16553459299370465, 0.18334650939380204, 0.17537619882254618, 0.24888069767120047, 0.23940319025690826, 0.24709322047778481, 0.17074612535954525, 0.1943706108278379, 0.18982474364506796, 0.44283225107879975, 0.36120888279574914, 0.36596185221331734, 0.29069464119898436, 0.3801239458129916, 0.3749693443415306, 0.40267913104834374, 0.33815493668426677, 0.4010895488997629, 0.19673717645277256, 0.2172195979230903, 0.34989672801384397, 0.2556209615046139, 0.28486352435574935, 0.3103103580253266, 0.2382944440369008, 0.2709565825384793, 0.19871156128548717, 0.2215389382919868, 0.251190354670097, 0.29786881182657676, 0.1937239923297096, 0.2323819611962581, 0.22765042554906612, 0.2155706508333206, 0.19479677650588456, 0.21072541203574446, 0.18515278737216734, 0.22342929419079027, 0.1899004608255267, 0.18699727515783993, 0.17705529434859613, 0.25257039211232846, 0.19952175403564287, 0.2250464448177224, 0.19096516808532082, 0.944617172094663, 0.12273613568978003, 0.15354729566923375, 0.18830229708521462, 0.1979862556316524, 0.16582383244419197, 0.14224752541444063, 0.18986299056577804, 0.17609599212224236, 0.9380322853743753, 0.21185976174501986, 0.19890834604147645, 0.213170160148773, 0.8828694751336674, 0.8916920929177634, 0.21352972284306526, 0.8977771390278677, 0.9088398636369198, 0.18652475994582307, 0.19718030355457872, 0.174956929674829, 0.2142394450965801, 0.18441308381833554, 0.1821206920718218, 0.1928640556123269, 0.19190244040584425, 0.17657305840897775, 0.11594980457752957, 0.12997340625617637, 0.10384162173232503, 0.08945003017684705, 0.07825727553268114, 0.0795590931214023, 0.08629358780162233, 0.09603923767908706, 0.07628125987933365]}, "mutation_prompt": null}
{"id": "6cc03b3d-eed0-4230-b192-a54500425579", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.1\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.6, 0.2, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.6, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.15:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedSwarmOptimizer", "description": "An enhanced dynamic swarm optimizer that incorporates self-adaptive parameters, dynamic memory pruning, and multi-phase exploration-exploitation balancing.", "configspace": "", "generation": 40, "fitness": 0.4917652398376913, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.32.", "error": "", "parent_id": "785acc84-43b3-4d2d-9656-258bc799aa36", "metadata": {"aucs": [0.9203636414819907, 0.9110354875468256, 0.9101444487731869, 0.9250154362419095, 0.9162421166276989, 0.9078825835036042, 0.9010654452872606, 0.8975810554390091, 0.915548663588732, 0.8271738470874059, 0.8173672175191644, 0.8201994964844552, 0.8475191039785452, 0.8404648713415777, 0.8248661380060525, 0.8382411756729763, 0.811693751343337, 0.8051014565885513, 0.14153452693849433, 0.11014450452853797, 0.11567114661407707, 0.11417213880288368, 0.11604000158155214, 0.11896922347873407, 0.1005865450843908, 0.18006797046222056, 0.14618892266494077, 0.15585612388886527, 0.08076656098681123, 0.11535024322522747, 0.11555555308717702, 0.12761444339749783, 0.10514958968344124, 0.1335339060932902, 0.11601605488640221, 0.11610030658798265, 0.9803726667562922, 0.9927750080930922, 0.9830205043221357, 0.9926927069124625, 0.9827816638167622, 0.9680845605710546, 0.9652874200367441, 0.9743541128801846, 0.9748227780986654, 0.7565071770354932, 0.7884481999564505, 0.8177072763428195, 0.7992344133967719, 0.7759619517310538, 0.790964993703964, 0.7841912384447955, 0.7785500779978276, 0.799006203058276, 0.9065966183702455, 0.38886257232078225, 0.8699655245415345, 0.27462238653369364, 0.2135238212604067, 0.27845485102145906, 0.21801283020011708, 0.9031584806022448, 0.9076166394717683, 0.13330381020797522, 0.7990831946642415, 0.7120452514061469, 0.829920700189156, 0.7427661414985742, 0.7097377711917803, 0.7424122066706604, 0.7781706451348855, 0.7099079124535251, 0.7511996645748434, 0.7222149770267767, 0.7402505407752682, 0.7583320752122393, 0.7994106559420805, 0.8247753746259374, 0.7525579843210817, 0.8350081600071682, 0.8006025075034148, 0.6294173289101676, 0.5915722119660267, 0.6706413735714996, 0.7061837449645385, 0.6293082049087264, 0.5665492797425827, 0.7711142707277266, 0.6792070690612182, 0.7246568741372337, 0.8205222986988566, 0.7853774510712028, 0.7536173411120329, 0.7921139435842532, 0.7782214086775334, 0.7256529180679081, 0.7998062138296771, 0.7696032575236511, 0.8139894888929728, 0.5349129531805228, 0.2715858683643836, 0.5729439720921966, 0.6088263886991481, 0.20818986350123014, 0.6056122260477412, 0.2565469765562428, 0.21747349382392556, 0.46550364835825175, 0.5036261122210507, 0.5620831105427289, 0.5971775670011874, 0.6397615023026495, 0.6770173632963957, 0.6174080559489316, 0.5802645489774283, 0.6753691851356723, 0.43542613405382413, 0.8854378032663692, 0.8655868271695581, 0.8758756542823081, 0.8716874474882348, 0.8935639044292513, 0.8480524651130275, 0.8621277355164909, 0.8595485411218738, 0.8812419495751947, 0.0930731002591072, 0.11289348638005159, 0.11163017866501634, 0.1451782850851454, 0.09649536547343962, 0.13863848824882585, 0.1186037212155352, 0.11646872601046976, 0.1747986285418205, 0.32357663425551586, 0.16146131861629986, 0.14181733650402917, 0.2184248115963603, 0.1520179716300818, 0.21882205870488292, 0.31278068177926366, 0.18185298674676165, 0.1660817785497829, 0.36778789918328114, 0.4296955874114533, 0.32542351420702276, 0.4834168672475663, 0.48598336948127974, 0.34257338309537966, 0.45411515423348137, 0.5062363399940022, 0.45057806456756166, 0.28735227244951067, 0.31075162515743426, 0.20360913212393927, 0.29957869196497644, 0.3271322467216069, 0.25229334078185917, 0.3137045175320764, 0.5705429558103075, 0.21148390117060845, 0.23904007283329032, 0.21936503430579846, 0.22079337054335857, 0.21740595714964472, 0.22724425729123476, 0.23904243795737679, 0.3124496268260294, 0.20801481051067616, 0.24156138424918094, 0.2516793853942112, 0.22104955456484, 0.19828991923782502, 0.20060231720327204, 0.2068271770040342, 0.17554906657625124, 0.205250066890585, 0.18695565787796486, 0.20835967363319685, 0.9354425986966335, 0.20911527789910644, 0.15342097173031088, 0.9354487354430665, 0.19935737425216948, 0.16743779685212845, 0.9187450250773019, 0.8854535989956172, 0.21022586095114937, 0.9170086440460191, 0.21335522738947998, 0.21146976443064858, 0.9006120941352512, 0.16917190423093764, 0.15628776035418046, 0.16681552771614938, 0.1281226031784667, 0.9203273678287802, 0.19536745731459115, 0.19519501190351474, 0.18508915835187523, 0.19277271091673664, 0.18407999563153576, 0.196729952178047, 0.1860394171272306, 0.18548392295794014, 0.18628598878248326, 0.0790938214933169, 0.09210905186046603, 0.091698801582761, 0.08707233012669169, 0.07849675509277787, 0.07561888725599675, 0.07865836718450869, 0.08206606047124365, 0.13075586315641208]}, "mutation_prompt": null}
{"id": "1d4e8ec5-90d0-4e48-acf3-adc4bc3b2356", "solution": "import numpy as np\n\nclass HybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.75\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.2\n        self.chaos_sequence = self.logistic_map_sequence(self.pop_size, 0.7)\n\n    def logistic_map_sequence(self, size, r=3.99):\n        x = np.random.rand()\n        seq = np.zeros(size)\n        for i in range(size):\n            x = r * x * (1 - x)\n            seq[i] = x\n        return seq\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            chaos_idx = np.random.randint(0, len(self.chaos_sequence))\n            chaos_factor = self.chaos_sequence[chaos_idx]\n            mutant = self.best_solution + chaos_factor * np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.1:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridSwarmOptimizer", "description": "A hybrid swarm optimizer integrating chaos-driven exploration, adaptive strategy selection, and dynamic local search for robust global optimization.", "configspace": "", "generation": 41, "fitness": 0.4641212180572174, "feedback": "The algorithm HybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.30.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.9086967286391177, 0.8954270548003849, 0.921273027547492, 0.9114125343484368, 0.9131235994586218, 0.9156358081714571, 0.9099547349627382, 0.9119880889857434, 0.9069863182464913, 0.8028378738713782, 0.8197989975499824, 0.8089719491189599, 0.8259844105344256, 0.7905588005894876, 0.8243805036984798, 0.8009418525743446, 0.824882110855472, 0.8115783172587019, 0.09646772647951496, 0.10373836150508253, 0.16112639970427645, 0.14616143690660777, 0.11124085266607531, 0.0883224770406369, 0.11620520441945026, 0.14308583222865667, 0.15879736714752002, 0.13007243791975032, 0.12994051084292535, 0.09393587473269527, 0.12428206688144328, 0.15120375228856642, 0.14005565826073285, 0.1229128700731058, 0.11407550179544268, 0.1407517241501608, 0.9733632017459815, 0.9846941485781303, 0.9830038285269849, 0.9861783127576252, 0.9769323171987763, 0.9716296533850433, 0.9810665556717688, 0.9803198039749046, 0.9899176274550571, 0.7839137505750858, 0.7487131463611161, 0.7424863766113942, 0.7593349040947175, 0.7609976370702134, 0.7693285515068424, 0.7664832315760329, 0.7479366852538718, 0.7722223711888954, 0.2234749353202592, 0.903641648406791, 0.8848402065210295, 0.8865489833284834, 0.21175647919252716, 0.2777974350610417, 0.9080707947770619, 0.23370802311606487, 0.17489017593899459, 0.7091597782827093, 0.12911935195512292, 0.7822130258849271, 0.7038472054000839, 0.7530803131762422, 0.6625609340816623, 0.6892858659588146, 0.6741976163109976, 0.7010346002540517, 0.6658498419947313, 0.5949828335820944, 0.7073195524496517, 0.7148331383807589, 0.7571651532557249, 0.6776746882739744, 0.7632922252783172, 0.6980794084924666, 0.6597694041098323, 0.499338735008494, 0.4854438851385374, 0.5296331853170606, 0.5536754774247363, 0.4786428888992016, 0.4892046487227032, 0.6948166795368313, 0.6403265055669695, 0.5302140071211028, 0.6862753199792343, 0.7262851704382767, 0.4591080597422985, 0.6020821393703017, 0.652061399065897, 0.6952851076039227, 0.7656798881928237, 0.73696978823559, 0.6334252808979326, 0.35840343664590113, 0.14094107351077567, 0.11147268143962685, 0.4150772675727483, 0.4938988505510016, 0.19467623265556444, 0.14378137169587057, 0.17440021503595549, 0.1573387920333431, 0.38134961072971574, 0.5774443342205796, 0.3384969086211429, 0.3806393901530246, 0.5497730804474998, 0.42745404079145133, 0.48227640081734735, 0.527239423255618, 0.35594950070488274, 0.8270127715151439, 0.8377971779027034, 0.8453546521233479, 0.8161955053876615, 0.8317522851293879, 0.8595191365135889, 0.8456836011420661, 0.8442554285547536, 0.8265555140949404, 0.1329907426632877, 0.10053598822122789, 0.13267222046550764, 0.11090518233366453, 0.08605949948386571, 0.1339138934071754, 0.11217919885086014, 0.10578624218975197, 0.15981324641634742, 0.23843000375160228, 0.24856282914164163, 0.1766885673990346, 0.23930683612968684, 0.18917198170699068, 0.16672424700780863, 0.3760561348905056, 0.7094060310913705, 0.17274890906911822, 0.42523928567674096, 0.2907842347738764, 0.45699942251394754, 0.7700656305918004, 0.5991279877319329, 0.41544086329999175, 0.2825308781305339, 0.5685477490868727, 0.493106768403467, 0.20128435345830242, 0.36797476039760946, 0.3166964920938039, 0.3462473974705491, 0.2685960376187104, 0.21296155852754195, 0.165926810506678, 0.3412599955538377, 0.36466161967401367, 0.25046637277632255, 0.22272629222411888, 0.23881482280352706, 0.21158152918275286, 0.2849822141927808, 0.22345646181308942, 0.26823850402370153, 0.24660521713025796, 0.24516314330901323, 0.2239338749071481, 0.19718027154509576, 0.20865252792183053, 0.19817249376063717, 0.1908052498880265, 0.19649270880636904, 0.20686888018342264, 0.20703166126804984, 0.1780016310881951, 0.1875322793418044, 0.18888219829928043, 0.16833138607860398, 0.2083756548018736, 0.907001561498847, 0.8660673603325278, 0.1423452909334868, 0.16427839395475363, 0.9241637259746808, 0.908108109233114, 0.21180037078352276, 0.2095631752655841, 0.8744337914205921, 0.16703568923894074, 0.15484348389621827, 0.21159258385907964, 0.9075227899311358, 0.8961632620613623, 0.23955636601482244, 0.1832998565803854, 0.17755406385018102, 0.22062007570288844, 0.21213519408000547, 0.1915489678466169, 0.21223068554773405, 0.21259244394851406, 0.21818992174738328, 0.09620545865819985, 0.0665915325280183, 0.10034818660852451, 0.16894266117091916, 0.0838192903049445, 0.0678418538216281, 0.0559445437561249, 0.08711461264772402, 0.07229748400617042]}, "mutation_prompt": null}
{"id": "fc5a2cff-6505-41cd-99f0-fa1cef3b468d", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.35, 0.25]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.15\n\n    def select_strategy(self):\n        return np.random.choice(['mutate_best', 'mutate_target_to_best', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'mutate_best':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'mutate_target_to_best':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'mutate_best':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'mutate_target_to_best':\n                self.strategy_probs = [0.25, 0.5, 0.25]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.35, 0.25]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "ProbabilisticSwarmOptimizer", "description": "A probabilistic swarm optimizer integrating adaptive strategy selection, dynamic memory exploration, and periodic population diversification.", "configspace": "", "generation": 42, "fitness": 0.44259932132038116, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.9304635910722491, 0.9225505877854914, 0.929701837197708, 0.9168436071015055, 0.922200711659628, 0.9270789909992673, 0.9191906591462623, 0.9202332054656875, 0.926244009942637, 0.8557368661043727, 0.8273960444840853, 0.831374540922458, 0.8608023709623156, 0.8347579732590731, 0.8575598674331949, 0.7994834438981167, 0.8522901161101353, 0.8388292024974541, 0.11639062196304362, 0.8159135678211471, 0.1278071428245776, 0.15268997742833323, 0.15782022220006853, 0.1421149202665749, 0.8537290453313442, 0.15595395332574002, 0.15119260742271567, 0.15636181927904946, 0.10537311781792591, 0.1425948043143288, 0.19104410308587016, 0.13201532721360676, 0.11799127122170872, 0.13819060402131877, 0.0895776200564029, 0.12034897961550273, 0.9867059138827795, 0.9908497711338332, 0.9852998301476285, 0.9880991459757865, 0.9883304307632798, 0.9830526684399596, 0.9843969677221738, 0.9880847588544722, 0.9830863293774496, 0.757108248096931, 0.8165533960477346, 0.789089483315011, 0.7718535871277872, 0.7691700267704222, 0.800902350028249, 0.8278357087576489, 0.8013937251722373, 0.7868142670023646, 0.2296025695097309, 0.38244533964353333, 0.157079766743481, 0.2760488317603653, 0.19269662056603343, 0.27378201863322715, 0.24469156350619226, 0.2458537385727243, 0.1776304488315551, 0.8116403753322181, 0.13614389423532358, 0.8559982376259936, 0.6657026917653008, 0.7213147419537445, 0.6607327718324707, 0.7040385897380947, 0.13283676507255404, 0.7064960429792326, 0.7636832414051982, 0.7130520154000639, 0.7522779231336203, 0.7818571216648786, 0.7423224592792992, 0.13717504687630466, 0.7607862589203558, 0.7426638044004289, 0.7951165191756133, 0.44570804737432723, 0.5715268717559222, 0.605223355951992, 0.5998099173716864, 0.5110564556163181, 0.4825994178515127, 0.6525721515457206, 0.4832339896220911, 0.605168433362927, 0.7030085335078777, 0.7734232587888229, 0.7126848496440519, 0.6662380514279506, 0.6983064637100864, 0.5102461500448274, 0.7854540862378934, 0.6000871910751491, 0.7120872453114568, 0.16548005615875794, 0.1345502356695899, 0.3561562200256819, 0.5468098166813014, 0.17861392497605744, 0.6165850152838537, 0.25222841736051294, 0.1384778594676893, 0.15247936202644374, 0.5826109427190116, 0.33937950148480545, 0.447744176966656, 0.49462167032884585, 0.3375325769934263, 0.4429530724476959, 0.3838486855992318, 0.4957064100557512, 0.37771861246534977, 0.8827365681804497, 0.8470513729980643, 0.8516805233232583, 0.8017040543597553, 0.8456085357279929, 0.8595937837609854, 0.8336064319236914, 0.8042731500597154, 0.8493891504955006, 0.12984466921689475, 0.09625532979029539, 0.15548628327909808, 0.14437591107379888, 0.13040836281977575, 0.148660358995912, 0.1161573364259173, 0.12074661382819762, 0.09996542832912514, 0.21858020661538835, 0.2298542319346656, 0.2815211215633848, 0.20281719053528036, 0.2745148461892285, 0.20556566973376056, 0.18623747591700657, 0.2166118579273325, 0.24323420771904802, 0.5079155207521509, 0.3634611275882996, 0.30054685521464697, 0.3593190973973499, 0.26425127520461456, 0.25765709524322555, 0.5323192355850664, 0.41298674747765585, 0.4060896640087167, 0.2395509918807165, 0.20549144496082372, 0.2761362357737407, 0.20334527932789181, 0.35554101045257325, 0.15504400617691938, 0.3156936220438049, 0.29787981246131057, 0.3444079078853052, 0.2689654531166261, 0.247219466826052, 0.2354417311611926, 0.29850466267617226, 0.24471345357533136, 0.22836211825200048, 0.259563786793654, 0.21598343787314733, 0.319645274202082, 0.18879621890512677, 0.2531513250483143, 0.19323927640767558, 0.1997960447415158, 0.18938182038454543, 0.20932230240263594, 0.19803829520305505, 0.17650772596748643, 0.8589600310291609, 0.9253183500356309, 0.1886562850537059, 0.14828108016995378, 0.16288719744089653, 0.2012903719041521, 0.20090112592698994, 0.14199895697797038, 0.16929843283809187, 0.17190834349382, 0.9263197544858833, 0.21208788847460014, 0.12750767022157194, 0.20899056945815675, 0.12818278419966467, 0.15504724507379575, 0.2134612551588434, 0.2120233684644679, 0.21146968837453417, 0.18093574102660737, 0.18034348029543124, 0.17477378250715114, 0.17022251682310674, 0.17897607948744987, 0.17973419157348303, 0.21259525278340208, 0.1887270760476717, 0.1789669640376922, 0.10626424718146499, 0.08154633072723283, 0.09932166696241451, 0.10528135141756245, 0.09457630664460215, 0.0721214721883372, 0.08646831543727007, 0.10714122328428144, 0.0740426469648724]}, "mutation_prompt": null}
{"id": "32bb2c74-1e0d-40dc-a5c8-c1f9bef95bda", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'rand_2_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'rand_2_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = x1 + self.adaptive_factor * (x2 - x3)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'rand_2_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDifferentialEvolution", "description": "An adaptive differential evolution algorithm featuring dynamic crossover and mutation strategies, coupled with a restart mechanism and strategic memory adaptation for enhanced exploration and exploitation.", "configspace": "", "generation": 43, "fitness": 0.4150132057797408, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.9153939613299614, 0.9148114633960948, 0.9153738773919421, 0.916615675231246, 0.9156414051955953, 0.9118039999175477, 0.9149600738301285, 0.9019820045148452, 0.933322999968265, 0.8069807428476061, 0.8299065740613308, 0.7891101718027561, 0.8136553246645692, 0.8143400381398563, 0.8111425952695647, 0.8166311932718491, 0.8172368727003, 0.7420901223881031, 0.10458143236402406, 0.11031063628688009, 0.11699799664127297, 0.1149011705056664, 0.06564630710526198, 0.10666550379225503, 0.11515376105336383, 0.10480367516971034, 0.1866273263078717, 0.06963833973363343, 0.10979790872590545, 0.12284204174010305, 0.10190634948270694, 0.11267681225459125, 0.14208038009812662, 0.1441798134591752, 0.0722154509153402, 0.07570170120318032, 0.9863093712698915, 0.9784473910786673, 0.9847746444240184, 0.9797759802876562, 0.9831326125338996, 0.9679190261368306, 0.9830837221166164, 0.9795457688122835, 0.981284290495379, 0.7436217706576025, 0.7664453386578876, 0.7538155375843401, 0.7390835641858828, 0.7221968300209282, 0.737456417095488, 0.7316258081779727, 0.7439936392583325, 0.7636826372261072, 0.2281697152843234, 0.17223211708704034, 0.23016508641894273, 0.19411128897437102, 0.21374668841132793, 0.3836058456193694, 0.23712774686275073, 0.8780324236085559, 0.9223692220855222, 0.7176103976873346, 0.7160583391773923, 0.7190324177490406, 0.12366110773488037, 0.13254631561627228, 0.795282294898049, 0.6824577790579425, 0.1351355613581029, 0.7065511346369303, 0.7110960737841407, 0.7461244546588859, 0.7099231208208308, 0.7207883433164488, 0.7245070841409411, 0.7731086305383829, 0.7075654642690375, 0.686116751090355, 0.7388882766854532, 0.41704331019752183, 0.3981374224190546, 0.3117977384447206, 0.21061482433096768, 0.21495136040733664, 0.452144853820449, 0.2818846800319018, 0.2875200560330078, 0.626264841925158, 0.44887367148849366, 0.33872117171923133, 0.5388285101026197, 0.4317723763331808, 0.2597185888118243, 0.4803052406574807, 0.580189400561206, 0.6448251090784054, 0.3510247772491427, 0.12652262417311066, 0.3700304347501647, 0.16988811155798667, 0.3860086949813123, 0.42913054430289244, 0.49678576230725524, 0.22203686115606192, 0.2846243402921622, 0.2253501247130284, 0.5090198740620304, 0.4906667865112512, 0.27563531531169005, 0.365286040660327, 0.29858271833504724, 0.34209739884340706, 0.3373867174744024, 0.42121881802596606, 0.2985675708297194, 0.7773657837474965, 0.8181706584627226, 0.8541192417632428, 0.6420372906073523, 0.6498348319372524, 0.6953853422533733, 0.841273556266871, 0.7603438744641158, 0.8486700549627392, 0.0725355580998499, 0.1460768243265611, 0.11501036371257345, 0.09071669957860118, 0.04577970661002184, 0.12060994034041195, 0.1278461156189169, 0.11017820542462975, 0.08994372712172682, 0.1914937782702455, 0.18238434104674162, 0.176368679717554, 0.13777201052663823, 0.17542509119605643, 0.19991036624968506, 0.2331522003042069, 0.21857289309032968, 0.17704801103778822, 0.270938185017392, 0.23656188654413657, 0.27275223215970634, 0.2520401904986046, 0.3404809545782054, 0.20638374427712725, 0.23653220770057448, 0.2700080845658014, 0.3212726318160336, 0.17522336236299885, 0.25533562401963295, 0.24004308803209817, 0.2515565540422312, 0.300474843012829, 0.3760157593711203, 0.24570733694942903, 0.20462069620702883, 0.23355653089420725, 0.19762671929902353, 0.3536080376473788, 0.3414223413307803, 0.3513531093711032, 0.32829601537039377, 0.3460516417863849, 0.209230604314537, 0.21883769237986495, 0.3713900478601221, 0.17852447932063864, 0.17267229418046304, 0.1819288230982904, 0.20088566722159917, 0.17367660185188238, 0.1943311143618034, 0.18392688522930667, 0.1827991806316096, 0.19881789592329546, 0.9587775251396072, 0.18777985218506366, 0.15375294582279164, 0.17254902421941787, 0.19926939835573332, 0.2004818135424662, 0.1432992827274826, 0.16489983660394059, 0.9317768201260591, 0.9192603130941275, 0.20996265107888845, 0.12514214334968987, 0.20953283092399355, 0.8814346514553947, 0.1556481434585707, 0.111223722034691, 0.8922386813708981, 0.89956181083542, 0.20150737849658407, 0.1761152052315461, 0.18452806336375804, 0.20351858541501255, 0.201005303966186, 0.20382484044086768, 0.17277994414437325, 0.17760292855446802, 0.17592584261642064, 0.08517454964340232, 0.08988606583765923, 0.11152919047317422, 0.12427744636741278, 0.12181859666438177, 0.07240670075923739, 0.0736061210216099, 0.0884781868896033, 0.07597743599619511]}, "mutation_prompt": null}
{"id": "5984e702-19a2-45ec-b504-24d4d574fd75", "solution": "import numpy as np\n\nclass AdaptiveMemorySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))\n        self.dynamic_memory_threshold = 0.15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_exp', 'target_to_best_1_exp', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_exp':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_exp':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_exp':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_exp':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemorySwarmOptimizer", "description": "Adaptive memory-enhanced dynamic swarm optimizer with probabilistic strategy selection and restart mechanisms for enhanced exploration-exploitation balance.", "configspace": "", "generation": 44, "fitness": 0.46046908914119294, "feedback": "The algorithm AdaptiveMemorySwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.8584789952810662, 0.8839103762816648, 0.8733202658723913, 0.8753888439309958, 0.8954142659193932, 0.8793413049915269, 0.8926842200477564, 0.8723192490342461, 0.8665264468392379, 0.7886524782126175, 0.7430834908468689, 0.7798081611771628, 0.7653831174510004, 0.6964282801600602, 0.7823198010537552, 0.7344157781974787, 0.726327901850883, 0.6535032593445271, 0.1701100930011198, 0.16815008287632194, 0.11725824414077302, 0.12231608083399148, 0.14054040319286176, 0.10907983207279703, 0.15739020225786704, 0.138703983384739, 0.16197564448466673, 0.11633461278462887, 0.15161480006219352, 0.13484023205297124, 0.11196417943899872, 0.12473170541246947, 0.12206947018798908, 0.11071678271996865, 0.09808215816910104, 0.1453660698822118, 0.9834909708469398, 0.9917259492578939, 0.9829170525705786, 0.9874858705527428, 0.9809826994093493, 0.9830053580118607, 0.9858990680874661, 0.9880410718249613, 0.98981407767987, 0.6737469285237697, 0.6865618164367271, 0.71389784406283, 0.7200373249941241, 0.7268622226484108, 0.6937465137863053, 0.7002168157848604, 0.6959223073622728, 0.6715043320299428, 0.9027088371170309, 0.22796307697233564, 0.7520280604419849, 0.2203870704711388, 0.8399212809924852, 0.8690321280720223, 0.8373050810388982, 0.7924925241445127, 0.9288762273070955, 0.6412403757092482, 0.7765282862453815, 0.7024536166912028, 0.6881020029184799, 0.6447385490728511, 0.5660572567758326, 0.6924727927863852, 0.6529668810284905, 0.7063081655796981, 0.7075716508893458, 0.6996555250843184, 0.6346412286932529, 0.7049384670917456, 0.7433211464119635, 0.6402439671875095, 0.7451348931960529, 0.7218360878236927, 0.732447993277867, 0.5042983824241736, 0.5448859329117455, 0.6064647370055147, 0.3640919650056632, 0.6027793166397275, 0.48097899697460933, 0.5638396885018045, 0.46111975476675804, 0.606237273550814, 0.6618122850156782, 0.7137625245958953, 0.7010685066354707, 0.748240201642925, 0.7096731630040257, 0.661791823857153, 0.7241228665357501, 0.7374346395115512, 0.7203786660110375, 0.4810092416302696, 0.11338620499792362, 0.28353842978727306, 0.4266101729645657, 0.24896103328839292, 0.14803231919523097, 0.3963564473126374, 0.1658118049076751, 0.15463993259166253, 0.5310609865734506, 0.5017053939677261, 0.4801165362094699, 0.5765545323863424, 0.5569561826694455, 0.5215676965534618, 0.36097619654082214, 0.5056583628259819, 0.39407414458404855, 0.8089048555433356, 0.8166063268014788, 0.8179252945169395, 0.8253531912616958, 0.806742867537326, 0.7869240820908945, 0.7756742758495295, 0.7696253168836392, 0.7863669463188419, 0.1504676749053142, 0.09075293004899032, 0.08646672726536364, 0.12128204513968155, 0.1184982613248654, 0.10672816697972864, 0.12301592544311513, 0.08282300965440359, 0.12268533074681309, 0.19603716045412578, 0.17338839842424025, 0.18617084510507653, 0.17364850314920166, 0.24901080929684583, 0.5917203877569653, 0.14170061907872278, 0.2015109909386258, 0.19044824014534756, 0.4699684429575002, 0.4237060334081577, 0.3419923559965433, 0.3429927360454875, 0.23077513432172714, 0.47166789012922894, 0.4605354385515583, 0.30312049967923316, 0.40631997383566554, 0.33783936398499015, 0.23402880546936533, 0.2944898130299729, 0.3008667758640037, 0.27970916233536725, 0.43940314634841826, 0.2203744096705631, 0.24071343005894608, 0.41160284712826034, 0.21184153383634818, 0.2411376181612206, 0.3332213597909567, 0.26276976795179274, 0.20672743988610964, 0.2522834900852218, 0.2211823905374154, 0.27307972000337133, 0.218149836078105, 0.20942037462047414, 0.2020350421378253, 0.1906948216388531, 0.25033284333700356, 0.24944574761163918, 0.18225977961559048, 0.20301428805403332, 0.1974046659322839, 0.19063468624752122, 0.18620029211877787, 0.17719981148635067, 0.20970434616844758, 0.16293540167996867, 0.19938914076361502, 0.2001531351225766, 0.9094063990728911, 0.1621835145043402, 0.9001936380479528, 0.89928973350728, 0.21116791647740463, 0.8452955067445987, 0.20823438484487955, 0.12649408781889837, 0.21170878605628163, 0.8175645344507301, 0.21298386900963173, 0.9014487833637087, 0.18744479257033342, 0.18299524263877498, 0.18366355795755707, 0.1719427411538056, 0.17342650161626805, 0.1818067369082036, 0.1816727871639996, 0.19210717939177802, 0.20215943453473806, 0.09482697515329708, 0.12088136612112066, 0.0765997476780067, 0.10918857002983928, 0.09449721762397456, 0.07982286070915456, 0.07697075039848711, 0.07498208382102456, 0.07278202687040136]}, "mutation_prompt": null}
{"id": "97bd4235-a78c-4bab-80a4-0fd29cccec33", "solution": "import numpy as np\n\nclass ModifiedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.2\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.normal(0, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.2, 0.3, 0.5]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "ModifiedSwarmOptimizer", "description": "A modified swarm optimizer with adaptive memeplexes and stochastic recombination to enhance exploratory capabilities and convergence speed.", "configspace": "", "generation": 45, "fitness": 0.4727342591646992, "feedback": "The algorithm ModifiedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.906177753585786, 0.8829501160542859, 0.8905720857572017, 0.8949666926147289, 0.8849444041020855, 0.874339575882048, 0.896943130295745, 0.9078609901611411, 0.9015163305822531, 0.8041121215102391, 0.7967273459094454, 0.7943875079851767, 0.809939260632685, 0.788993200142636, 0.8038577263840719, 0.7942519555629034, 0.8164886155348681, 0.7724995353617967, 0.1761043287324222, 0.5812718140882371, 0.14003231832165197, 0.17683955131628204, 0.1407799041253991, 0.5971066610375881, 0.17157958003909624, 0.1657704774669122, 0.16531086491121172, 0.1467238659125193, 0.1105609191241067, 0.097820815088975, 0.13470847036040778, 0.13514947040963943, 0.13893670545693926, 0.11227251583829234, 0.14515881532079622, 0.12328789230862425, 0.9889683732315346, 0.9723468795176172, 0.9827351455557782, 0.9847013112468946, 0.9802379854991229, 0.9760209738003144, 0.9689433193018703, 0.9809466736321343, 0.9895584336577669, 0.6928010652630158, 0.7248249019309385, 0.7269761694961812, 0.7321549616781404, 0.7267006610089428, 0.7277866878367476, 0.7363677221749252, 0.6883639299388248, 0.7398167691788404, 0.22884946387099914, 0.835689462360633, 0.8780409022926161, 0.2811196934874164, 0.8247669511774142, 0.918284220689396, 0.8839359875788193, 0.8688283509297126, 0.8644181706568372, 0.5803813487817675, 0.6010001631414259, 0.6275408840552654, 0.6228549459222952, 0.6043567288083086, 0.6177399651418816, 0.6028346146140425, 0.6458486377311585, 0.6152037052473001, 0.13310778788681854, 0.5807999212696953, 0.5731151698980618, 0.6869314424664131, 0.6427901632815395, 0.6101014844885069, 0.6502840056216068, 0.6728707239060625, 0.13287328763810768, 0.4156209920353574, 0.5072620577535832, 0.5839002171752583, 0.4181870678237307, 0.4451754700933579, 0.3422873407026338, 0.5029806930511955, 0.507189205774355, 0.6346650446653945, 0.631235253956355, 0.6006911078507187, 0.6324087567026343, 0.6500654186435086, 0.5855953244987306, 0.5820109093704181, 0.648241360490224, 0.6640859395783965, 0.6260492352380107, 0.23675040636860134, 0.1354705559309377, 0.16208583178558766, 0.3235536554901809, 0.428566558059995, 0.4413399343140618, 0.17407172784546598, 0.23208230698170373, 0.41600651917214915, 0.46385114008382367, 0.3740744646471207, 0.4320277717249411, 0.4538577989935828, 0.4087955447788074, 0.48442913066325144, 0.436621335838808, 0.3764169250472803, 0.42474998469587744, 0.8233241979006282, 0.8110752118316036, 0.8011147943674101, 0.790790810646349, 0.7601217481928519, 0.7991601388117052, 0.7996554081991551, 0.8134699523471107, 0.8203648176347716, 0.1250882217634971, 0.11188631259459159, 0.13804593476118354, 0.15458266725677516, 0.08751616101270587, 0.12169796180978887, 0.10552192045769004, 0.11876703181218506, 0.12349143576245936, 0.3659578655702522, 0.6259490287489988, 0.19829000228041482, 0.25237854157955797, 0.24461694494878927, 0.14995396505306835, 0.28980898928049137, 0.15778084470577158, 0.20520604592479852, 0.4820136325965002, 0.25000396892245225, 0.32848077953950017, 0.5809800610219371, 0.5612230455729881, 0.46392186452085027, 0.6172799817199761, 0.47843818261410165, 0.615524778269851, 0.31485801938480473, 0.3966004015620712, 0.3364862546752928, 0.38643832429613445, 0.2675348763100319, 0.35592802782899957, 0.37752093029202793, 0.4512540711698745, 0.4107884734884285, 0.23105167871105736, 0.230234130748727, 0.22964913720024693, 0.20618107693180499, 0.19127786825451243, 0.22797032492354452, 0.2566255720255971, 0.23133699544889585, 0.23936068651328446, 0.23911177756460267, 0.2493503856450494, 0.18149601286485983, 0.7280228400982229, 0.2060724685932378, 0.20190583916728255, 0.22145939735758158, 0.21250387340021204, 0.21636542957107008, 0.18720649056325023, 0.20641363491906928, 0.18727727777641745, 0.9144386521354213, 0.19833215381957503, 0.9205981216476349, 0.8960636398208225, 0.8017743963627192, 0.9251400351860968, 0.8703553348802178, 0.2124235427294614, 0.8292397847828213, 0.8798131605862906, 0.168354774460598, 0.15403401324218358, 0.8167378933784295, 0.15514819922790435, 0.16561466270814162, 0.19192750133273462, 0.19356520603549032, 0.1815696948062112, 0.19833659371076506, 0.17394977715894167, 0.1785131553396786, 0.17581202043616395, 0.18734735646076606, 0.18741070827360162, 0.08640181461823582, 0.08431002674284194, 0.08959976589663532, 0.09783348736221831, 0.09033046545286272, 0.09109076082612377, 0.0883938844269716, 0.09224257882256659, 0.09396483694702051]}, "mutation_prompt": null}
{"id": "9c3923ae-41f9-4de0-b3e4-b738f8c5ad78", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.5, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveSwarmOptimizer", "description": "A self-adaptive swarm optimizer with enhanced exploration-exploitation balance using dynamic strategy adaptation and memory-based guidance.", "configspace": "", "generation": 46, "fitness": 0.49164015584546206, "feedback": "The algorithm AdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.9108351906780874, 0.9040452325011907, 0.8984391066393688, 0.9115208641824446, 0.9145510915060987, 0.9105250590432777, 0.9190684985844519, 0.9039379649498855, 0.918088086769189, 0.8291553474411699, 0.8177209829615173, 0.7912915071008535, 0.8201867500473612, 0.804821913395776, 0.8365707649583108, 0.8280732021449522, 0.8180413007523828, 0.8016447498753634, 0.13527778240292176, 0.5359558380582599, 0.17083066029504024, 0.16902894698889448, 0.562589948673847, 0.16500021743068194, 0.12794695295744063, 0.13508445199414254, 0.129893612172842, 0.1174909984521757, 0.13758461440733505, 0.13378823610952495, 0.15638169786960499, 0.11666332069880392, 0.13176839130428308, 0.10324985891856198, 0.13390660805797383, 0.13829496569991317, 0.9804147093874263, 0.9902728053587279, 0.9753116989746916, 0.9766444686759785, 0.9855799397779714, 0.9668172654509231, 0.9819008760640789, 0.9776887424741456, 0.9853389345590579, 0.7746929867190617, 0.7530187316692849, 0.7512630129072169, 0.7959540613628229, 0.7713258561831646, 0.7655496528100395, 0.7799857484162938, 0.7636075969984931, 0.7629896397823154, 0.8721229305970135, 0.8973865087065751, 0.22854856234719823, 0.27363968910244096, 0.8766824923827837, 0.27953895507240367, 0.8934893108355999, 0.8980477027225787, 0.9070021422147555, 0.6255112745020166, 0.7016372140059288, 0.7327100297636027, 0.7237443132420756, 0.5610180049897782, 0.1319413485235531, 0.6695771809112263, 0.680195552221071, 0.6914853388149731, 0.6240653406272605, 0.7312337152804382, 0.6238891095267403, 0.7655838108465467, 0.7047312475809469, 0.7372235405727451, 0.6891620451887149, 0.7249721557582798, 0.6875938158676214, 0.24971130311568457, 0.4135670177451971, 0.6382900853516444, 0.6027550572913125, 0.4835958983343642, 0.6127819402530479, 0.507422061806407, 0.6467649843269392, 0.6798324710373451, 0.6787443584876718, 0.7206223156284428, 0.7251689368063783, 0.6747046645610422, 0.5934147708031826, 0.7523811421780262, 0.7687081825481278, 0.7330691410295163, 0.7458118238629526, 0.43102779459750107, 0.22567101457379946, 0.44846737707405704, 0.40914254280638773, 0.25384767934036123, 0.4733011776474042, 0.406052185313478, 0.31366337638068154, 0.12303816214391006, 0.4703569096223451, 0.49814288948146, 0.5694023977900856, 0.5332185454538731, 0.6076202380509848, 0.45738033068902983, 0.462322238662906, 0.47931622583199096, 0.40936279046062896, 0.8516103782075711, 0.8321006339339005, 0.8491466577255182, 0.8249269161673742, 0.847740029205484, 0.8325841581674797, 0.8486075283817711, 0.8434955423753051, 0.8398743683493421, 0.10696599672781926, 0.15286103173867593, 0.13735227238437842, 0.10474856552881118, 0.17286892459869652, 0.10242153634609641, 0.13893762542132937, 0.1408019577650974, 0.12965213251571206, 0.5098228963605962, 0.170377185565873, 0.18260296032986467, 0.18675133690005774, 0.24021559815523985, 0.1629498806475509, 0.1865222069064042, 0.3089120505900923, 0.1868772659755542, 0.591100639498155, 0.3808339396237178, 0.40134025087773384, 0.6332910865392016, 0.5435721999945367, 0.4226389886866464, 0.791829536126498, 0.6194696383951219, 0.7325792908143889, 0.3006512698763468, 0.2866494343767413, 0.33908604937375, 0.506517373583278, 0.4097412692087814, 0.42280649572703943, 0.5381800282852058, 0.32541181956410925, 0.5044332200170926, 0.20433314176157558, 0.21626063653112504, 0.2523901900715707, 0.22970753928624388, 0.2236680967110466, 0.23069715028795412, 0.2195521562650481, 0.23669369272118945, 0.28262611902107415, 0.19336325109267805, 0.17564078560644936, 0.2241642676030695, 0.22287492750743032, 0.24422801724611098, 0.20647992544077243, 0.19687949388404935, 0.1860841547889428, 0.20856402352048287, 0.18784761922607351, 0.21042385733374103, 0.15308885711639397, 0.9078573084928607, 0.1992444728986117, 0.9340124365164973, 0.14279515895962036, 0.16179345544121593, 0.9141821018294652, 0.9081665480696934, 0.8678418634151296, 0.07343933830577665, 0.8975836112284306, 0.16772755497448366, 0.15617708069055192, 0.10448036205416267, 0.887252586572174, 0.8543127956886956, 0.18177168857162362, 0.18026517836819878, 0.205004579735396, 0.20452205722664862, 0.1917194070189625, 0.18430756747946253, 0.17648957231944984, 0.18905989703067805, 0.17825319832736297, 0.10651637627247978, 0.10667164312533262, 0.12499989871589312, 0.0787006175164553, 0.09283207486959677, 0.09319112563275345, 0.10112648003615199, 0.08443352565329731, 0.08108922213105785]}, "mutation_prompt": null}
{"id": "d0e731b6-56f1-4672-8811-0d49ff47d797", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.85\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (5, self.dim))\n        self.memory_usage_prob = 0.25\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() < self.memory_usage_prob:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() < self.memory_usage_prob:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveSwarmOptimizer", "description": "An adaptive swarm optimizer using dynamic strategy selection, memory-based mutation, and adaptive restart mechanisms.", "configspace": "", "generation": 47, "fitness": 0.3097122475128247, "feedback": "The algorithm AdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.7102888475802768, 0.6871938535283273, 0.6747424000485092, 0.7253295208678999, 0.6644595670959278, 0.6984288029981573, 0.667048232370379, 0.731064001236893, 0.7279730392302064, 0.35944018858414273, 0.3585726706314811, 0.3628292629432939, 0.34814817905674345, 0.3900704418543798, 0.40804612209115876, 0.42961461163501746, 0.38338711957311267, 0.3478011280253399, 0.14936994082636978, 0.23355721643753813, 0.13541644068449876, 0.1365785834012535, 0.15214615286674504, 0.13714804831186433, 0.1476109577021918, 0.14188012711957598, 0.18151839490589494, 0.11717560831218088, 0.13517925499326322, 0.14405215904938284, 0.13640342387569304, 0.13191400026783284, 0.13587005822452813, 0.10174933544381715, 0.13099845400150356, 0.1377286722678731, 0.9817443631056151, 0.9889699499471808, 0.9809779551546106, 0.9802499863762836, 0.979873793643591, 0.9783849118642408, 0.9858614070140055, 0.9816677731889021, 0.988788914702814, 0.2929772901370107, 0.35087942562351193, 0.35166519112076944, 0.3330976708308746, 0.3440337221018033, 0.342997044740568, 0.34531836257768256, 0.38181593801242386, 0.3699914357634191, 0.5874438563486325, 0.49114747108147605, 0.524158273826718, 0.569869110457953, 0.5780045458096794, 0.6458334915419938, 0.5201479253489563, 0.5252165336819201, 0.5818687669910083, 0.11097010942804664, 0.21739263128289998, 0.254047663122812, 0.2641596367299338, 0.3223191299459208, 0.3096568709708374, 0.3105633093322292, 0.3096694366033046, 0.1322521501020565, 0.31915659467051705, 0.21618179231123025, 0.2532596351833829, 0.2977547050224595, 0.29827687613842535, 0.2990925539416289, 0.29468209255282696, 0.26363598791197695, 0.22120149292545754, 0.14118584109311394, 0.18790297635755537, 0.0843165243909807, 0.10329123850864053, 0.0894639274409248, 0.1113034854903795, 0.12691405222642038, 0.17178490455492934, 0.21532420562665322, 0.27735197626016284, 0.221287879515905, 0.2547575042163176, 0.21056386302747054, 0.24552410060189545, 0.2776460756478596, 0.27241456169797473, 0.29762236542184317, 0.3390277931591721, 0.04841167964956694, 0.06427062624979607, 0.027995092154180723, 0.06367355396508068, 0.03754234559436209, 0.08413515516348291, 0.09280804498177164, 0.08286053735914134, 0.07430418283771201, 0.1743798030528445, 0.1707423627559831, 0.20645595181406684, 0.19145436932583715, 0.19032593893443228, 0.1731046086009872, 0.2010211222220779, 0.1718491066562441, 0.1721710917953576, 0.5465618378567878, 0.528069463360251, 0.5370483408054423, 0.5193049608524394, 0.5278038851507763, 0.4970632066994938, 0.5192801199956236, 0.5622724516588766, 0.5744495855457712, 0.10677893936541116, 0.11957488455805743, 0.10488756726649806, 0.09956465718438268, 0.10203046510432401, 0.12831227165871784, 0.1230960416751874, 0.09972232180711038, 0.10254855079240388, 0.23171848814518858, 0.34198394114082886, 0.17021408038023178, 0.22262141151795245, 0.2144170415651936, 0.2006652448079429, 0.2230316570727161, 0.2401819175305847, 0.14802415474913655, 0.3303865215277705, 0.3181439681414955, 0.2856178918671777, 0.34785266207598675, 0.3246964648907168, 0.27121307616425006, 0.37927335784201366, 0.347781032202064, 0.31762383292256546, 0.22159615588240245, 0.22920131198909088, 0.27862982267143155, 0.17905324408983558, 0.24047184429494217, 0.23929599421135495, 0.25704771923500114, 0.27368278213137787, 0.2355076657270122, 0.1922789187411117, 0.17655756168469017, 0.22146397879173996, 0.18422710394005726, 0.17790628832711664, 0.2012868912114707, 0.2211484691386032, 0.2010453779216228, 0.2074190443714058, 0.3304973315258709, 0.5249000396197557, 0.3423027020525444, 0.23376148729682888, 0.39950506316340995, 0.523165087501863, 0.2035249801971658, 0.23247932646422098, 0.21228804653773004, 0.7890295429754226, 0.16805651528422172, 0.16837546030204598, 0.13038361568663737, 0.19861325422011555, 0.1972526365750057, 0.8099735395239149, 0.15117278312696558, 0.2105090722724382, 0.720784289689924, 0.16934046282277937, 0.11057531875418714, 0.7154354992799852, 0.16832766745971695, 0.15260938495087317, 0.7778979658113319, 0.7316917296784735, 0.7394469926862982, 0.1837757314486389, 0.18127218041364013, 0.19084039058155655, 0.18234746715944516, 0.18703577977064811, 0.1932145190735357, 0.17248108985215382, 0.17892278206943424, 0.1739073135638759, 0.08033110779212327, 0.06675965442615961, 0.0682710316326931, 0.084791960616588, 0.07064499129902557, 0.08085093122991693, 0.08912102430335433, 0.07741025642367372, 0.0791495398483274]}, "mutation_prompt": null}
{"id": "dde95e51-2e96-4def-80cd-b95c8fdf3794", "solution": "import numpy as np\n\nclass HybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]\n        self.adaptive_factor = 0.85  # Slightly higher adaptive factor\n        self.crossover_rate = 0.85  # Fine-tuned crossover rate\n        self.memory = np.zeros((5, self.dim))  # Increased memory size\n        self.dynamic_memory_threshold = 0.15  # Adjusted threshold\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)  # Increased diversity\n            x1, x2, x3 = self.population[indices]\n            mutant = x1 + self.adaptive_factor * (x2 - x3)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.2, 0.3, 0.5]\n        else:\n            self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:  # Higher restart probability to escape local minima\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridSwarmOptimizer", "description": "A hybrid swarm optimizer that leverages adaptive strategies, diversity enhancement, and multi-strategy co-evolution to balance global exploration and local exploitation.", "configspace": "", "generation": 48, "fitness": 0.4171160587536786, "feedback": "The algorithm HybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.8937765750236801, 0.8773346588860851, 0.8770094721425962, 0.8877093849729547, 0.8772262567594652, 0.8286958848932933, 0.8715212543613942, 0.8583876036007598, 0.8808359949228699, 0.7252900294032156, 0.7403207540759928, 0.7060150731408836, 0.7962524336349488, 0.791142781475857, 0.7801103710771007, 0.7255017540415816, 0.737839299631764, 0.6631801197401916, 0.11129314551397618, 0.11432735132105643, 0.14858009984663, 0.13722999658821622, 0.1564055697328537, 0.11724868403368383, 0.10710335944801719, 0.433072187284654, 0.13200233989935528, 0.11754575706629644, 0.09810044576376042, 0.10933085360218864, 0.14350437791787918, 0.1350477889887146, 0.13116107056209858, 0.13217749415446378, 0.13390713239015006, 0.13622478292120432, 0.932295123465515, 0.9677064898337401, 0.966863162131832, 0.9593309337651049, 0.9321109430595647, 0.9600450702706704, 0.97471758559529, 0.9824487602176029, 0.9756185095899819, 0.6321870592469399, 0.6584181283689434, 0.6239391098795586, 0.5926740111526239, 0.6307336518073885, 0.6150443384936304, 0.6409637087181062, 0.6365613724536308, 0.6731577298333336, 0.8591789355071374, 0.713565987873179, 0.22623518439195167, 0.8426545629422776, 0.7732721862314174, 0.7930742238118753, 0.23218546483508218, 0.7016990433594474, 0.2435133376382359, 0.4838060196059669, 0.5322186969603087, 0.4853168730880917, 0.12597369823190419, 0.12586063722655094, 0.4523345217339204, 0.5265230347929737, 0.6227709566444092, 0.5066145041275615, 0.487467086620597, 0.5925198314935434, 0.640498359371823, 0.5370253974463564, 0.5968926617309603, 0.5816580114423244, 0.5979708099250267, 0.5887287352764508, 0.5721292884784774, 0.1965759101475365, 0.3525856340044746, 0.35769945836613704, 0.30441412815666, 0.3614369906409822, 0.23705728834427542, 0.2249281121492246, 0.4706716676470689, 0.4451556485806749, 0.5691158823294407, 0.532762307594361, 0.4974488442550893, 0.6650059022292485, 0.5241409089597, 0.5733408469272073, 0.6282651556299633, 0.557537046040131, 0.5580518076578298, 0.14141537912896507, 0.14358969662544407, 0.16465250571501544, 0.2147610800556623, 0.22276305547352526, 0.3161921117157165, 0.09189453804639047, 0.21807068351403947, 0.14399163992679953, 0.21264530177374996, 0.2751529165601144, 0.3794476307247784, 0.4317465060035749, 0.36163906305310534, 0.3234691606678911, 0.3783789695883465, 0.22161685978041878, 0.3413074768565387, 0.7767989163783875, 0.7591740418026736, 0.7330679698017076, 0.7413169029877152, 0.758848852898176, 0.7391262977414634, 0.7656683234005763, 0.7437227626741847, 0.7314951833268759, 0.1376086756879229, 0.12326850523149369, 0.10942481499862111, 0.12893060944658918, 0.1282472576438045, 0.11957602538680967, 0.14032170953078837, 0.1227091937515361, 0.10228033009444604, 0.17682733154407437, 0.15173630785207914, 0.12604005293999, 0.15100024005844226, 0.18818253731642431, 0.22566940648278977, 0.1815956095802289, 0.15007528934940673, 0.15539722432015102, 0.29562204244850865, 0.377735114195914, 0.4078070390739438, 0.32070677200288056, 0.25312838248185865, 0.42048582914402355, 0.6228784435967156, 0.3035028316141768, 0.5052689386806666, 0.21532715059039387, 0.24604009471022315, 0.2441363233560282, 0.2703862276053225, 0.25907008118373187, 0.35037711513063674, 0.20035142396512629, 0.37013738076067304, 0.313641885026272, 0.23503755386397263, 0.20374992087075183, 0.28305842308751894, 0.2325986309014627, 0.24827972769459483, 0.2833496553015886, 0.24908930383708594, 0.27167988510471874, 0.25851634870067897, 0.23848887980875866, 0.1920944853349157, 0.19729918211749486, 0.21808719320140213, 0.18812410639596266, 0.18622346509476984, 0.19113827069945843, 0.20521911815081173, 0.21022679858365856, 0.8671659673940032, 0.188065208212032, 0.21103908380018488, 0.9032990476062, 0.1984692657147903, 0.1997467809981056, 0.16330667209332428, 0.8798615949683498, 0.8963405299699467, 0.8400869089194586, 0.5169703855982837, 0.7808572700926077, 0.7858511032236668, 0.16554835797883394, 0.2093094691647892, 0.20784377265096865, 0.8636203074301507, 0.8420932527104772, 0.18208914136817234, 0.18173163969091188, 0.1828434447520373, 0.19738913529459723, 0.16929895070120216, 0.1785918446211726, 0.183922514013097, 0.1893051292525344, 0.19517440332650549, 0.07770547560019936, 0.08945612354929466, 0.07751842976991374, 0.09349456519786803, 0.07770123622146807, 0.07711251626170945, 0.0822099129482311, 0.07894044868485417, 0.07829041210935339]}, "mutation_prompt": null}
{"id": "4b23e9c5-a1ac-47a1-8e76-b0928cb1e98c", "solution": "import numpy as np\n\nclass HybridDynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.1\n        self.restart_prob = 0.15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.5, 0.25]\n            else:\n                self.strategy_probs = [0.25, 0.25, 0.5]\n        else:\n            self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def adaptive_restart(self):\n        if np.random.rand() < self.restart_prob:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridDynamicSwarmOptimizer", "description": "A hybrid dynamic swarm optimizer with adaptive mutation strategies and selective convergence restart mechanisms.", "configspace": "", "generation": 49, "fitness": 0.4714688220574062, "feedback": "The algorithm HybridDynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.31.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.926885160013526, 0.9299296690118968, 0.9289843400389848, 0.9301501666361484, 0.9306654221639531, 0.9334171012614073, 0.9251810948647258, 0.9208164429820019, 0.9360190732607134, 0.8321282232782369, 0.8272182128611583, 0.8068364501482643, 0.8552642187165632, 0.8477900849594526, 0.8275979993759065, 0.8510036006575185, 0.8550997109371843, 0.8123305172887575, 0.12405440309913662, 0.16066329791070055, 0.1498818846481922, 0.13858215013161845, 0.10918120555477107, 0.12543429956508367, 0.1569138686101016, 0.14381575804044877, 0.16229927437544323, 0.11193676882026882, 0.06049463615532136, 0.11731886667038594, 0.1158990414062171, 0.1081910460975043, 0.14279618755957124, 0.08264068102656896, 0.09584672381498183, 0.0989032931225513, 0.9806195651779186, 0.9886298618317605, 0.9818954976069469, 0.9887509734237448, 0.9670734825580917, 0.9667278938529509, 0.9851624142917124, 0.975977660159575, 0.9877843595169802, 0.7845706182309233, 0.8258406512705774, 0.82910347783679, 0.7788422070983514, 0.8177358249352182, 0.8228225860586371, 0.8315895094035004, 0.8006805583433361, 0.8281637428820159, 0.22926519686403035, 0.3970117150770106, 0.9023669794230041, 0.193182913254336, 0.2792246174353292, 0.20886067087702864, 0.3726756215033792, 0.8697596550628689, 0.923287864934093, 0.8227603330072789, 0.7391338477718548, 0.7433123054317275, 0.6948476678927243, 0.7591220816191802, 0.7198643892301579, 0.7626735636562332, 0.734989843073697, 0.7276645075529359, 0.7535911150435199, 0.7421825399278531, 0.13630096562297056, 0.7948080049495472, 0.7169412931435628, 0.7937139416645408, 0.7198975000867027, 0.7408352412656141, 0.8000095520749955, 0.6171658816820011, 0.6197524511482663, 0.6092068656235203, 0.6184793757777332, 0.6772470723337367, 0.5923534194585635, 0.6497901689010683, 0.5418044171926745, 0.7035453113764878, 0.7247514651738183, 0.6045273060886698, 0.7385543158381547, 0.7847126659633389, 0.4609566311106549, 0.695330083824319, 0.7831272418700829, 0.7354517828027802, 0.7786046701667476, 0.31282145733079747, 0.1841971477402471, 0.29610792717059453, 0.5720399052939498, 0.5044133374075461, 0.5208800219009978, 0.24210593498057453, 0.23146954381958618, 0.2357171240618663, 0.5882171156589893, 0.4130176203458116, 0.51379292714689, 0.3349763024483662, 0.49951385138934334, 0.6165116024798398, 0.483058101676188, 0.4811183904298513, 0.38405822782760446, 0.8692708082801159, 0.8646328049889961, 0.855574202301169, 0.8335178203151512, 0.8624580238513251, 0.8735982762889642, 0.9028675435609502, 0.8537942468255066, 0.8727754889547501, 0.11196478426780432, 0.10602813546071488, 0.14440073486636507, 0.11913247194009124, 0.1628366535171928, 0.10156597749928364, 0.1348421543992936, 0.14578510732851524, 0.11569808166947682, 0.20650404603342976, 0.2571909324241748, 0.15134084812533388, 0.18641586336753802, 0.1708771843591932, 0.27324314434213803, 0.17141996086244982, 0.19144212527316407, 0.23384103463078343, 0.2857396997670776, 0.269710281329648, 0.3296678079831046, 0.3415868213064981, 0.350598871796052, 0.43589824375931385, 0.4057299127429189, 0.40495077666714263, 0.3529322615651146, 0.2457143636109942, 0.215660180706978, 0.27245896106966583, 0.3329335858239977, 0.21706878578756628, 0.30172539148109456, 0.16455355281612138, 0.21672374736630085, 0.2433995330932074, 0.2411133625752191, 0.26636196402269907, 0.23750392463163417, 0.24987872053065907, 0.20532042998794897, 0.33046874529176773, 0.21069854878649186, 0.26989018726793645, 0.22280388578351817, 0.22375075350300044, 0.17869809706804574, 0.19982786947410558, 0.1888303371855592, 0.19077969704817, 0.1757740552085072, 0.19346452096380395, 0.17369011638961163, 0.17547611426441523, 0.16806094994093035, 0.18868455377497573, 0.15421666216683372, 0.9505661772870064, 0.19892767672393752, 0.1727578210121724, 0.14258256569663375, 0.8747266254732304, 0.20994542395056792, 0.8868829820113812, 0.21244155856021174, 0.21043034581535758, 0.9053675622922808, 0.1693890172423953, 0.15377499178666876, 0.9042757246242332, 0.9115758812150874, 0.9182323021521338, 0.18969232911999812, 0.17898484581794416, 0.2216469815813107, 0.17764130650646914, 0.18484194687076028, 0.1891611422223859, 0.1763063474884835, 0.19199134681486274, 0.1912724743605847, 0.09721437034770752, 0.08556959255561192, 0.10895564783003153, 0.12495126078517937, 0.10483285249505003, 0.08232546581219957, 0.06769947629562134, 0.11582158496191819, 0.06931185398567852]}, "mutation_prompt": null}
{"id": "ea2baa7c-6ceb-4603-aa85-9113f9445aa8", "solution": "import numpy as np\n\nclass HybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size for diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]  # Modified initial strategy probabilities\n        self.adaptive_factor = 0.85  # Slightly increased for more aggressive search\n        self.crossover_rate = 0.8  # Adapted crossover for balance\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.15  # Adjusted threshold for memory use\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:  # Increased probability for reinitialization\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridSwarmOptimizer", "description": "A novel hybrid swarm optimizer with probabilistic adaptive strategies and periodic reinitialization to enhance convergence.", "configspace": "", "generation": 50, "fitness": 0.429042085563886, "feedback": "The algorithm HybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.8828496962799404, 0.8919700237545543, 0.870602427805605, 0.8938425014600642, 0.8858971056291239, 0.9119544827330659, 0.8877877526852147, 0.8920171621722401, 0.8973257265566748, 0.7742608608207165, 0.7819493958059016, 0.7737631830431975, 0.7829938578641076, 0.7805105630679007, 0.8107374880143445, 0.7881011668877799, 0.7561773133823918, 0.7451699113977186, 0.7084705117096899, 0.1422541184243824, 0.18190433786338966, 0.17161898172010404, 0.15082021423551706, 0.15127591729928425, 0.16966504534655036, 0.17709685972374278, 0.17478630995756028, 0.1109020606936878, 0.12825543938155892, 0.15239566161552975, 0.11444991045373643, 0.16593012650190309, 0.140827566384503, 0.0912483360208255, 0.1208046283075932, 0.10072241639348356, 0.9877244790104515, 0.9831068569298657, 0.9708978752896632, 0.9895052545957951, 0.9732089091944741, 0.9704926313750077, 0.9824747771631857, 0.9809779429410622, 0.98981407767987, 0.6601239570595454, 0.6133920100703965, 0.6906216967300007, 0.6872223895716023, 0.6659722636846099, 0.6718435977389637, 0.6967552021861415, 0.6970140655707503, 0.6894332062302158, 0.8449409504116911, 0.8340499597080251, 0.8621040667426535, 0.27734323304746145, 0.27758185097142396, 0.8847762932213323, 0.8134352161732639, 0.23287103443940604, 0.23047628085427163, 0.6960023519477956, 0.5119867846807554, 0.6401154595755494, 0.5251581541689685, 0.1308644777659127, 0.547527539695937, 0.5255257559843227, 0.6217482318141254, 0.580766220091946, 0.5573958882970309, 0.5564996712381414, 0.5731074466383019, 0.6494282700399493, 0.6321998374563278, 0.7841321215907572, 0.5869416505722076, 0.6850528295938143, 0.612463090674559, 0.36562229328658047, 0.3217097818773401, 0.44211429921948575, 0.33593160873887373, 0.2557423077366935, 0.24239169543060213, 0.5093831917486822, 0.38026732824240794, 0.42489821384990434, 0.4242314243054639, 0.5289245531920719, 0.5174249382454505, 0.6218565900113509, 0.5601598524607638, 0.41942631355212046, 0.6289371046530295, 0.5257877158681608, 0.6032493800544252, 0.18258801822703308, 0.07321921472057746, 0.11214651184654445, 0.25620699675127767, 0.27739460615589207, 0.15694406863811494, 0.11794166141230777, 0.17336700749522316, 0.14955507200152263, 0.22132955994569625, 0.3800877755438521, 0.2991401561201241, 0.3344816219214629, 0.3812599628841872, 0.395714247924681, 0.2322006909342319, 0.3109129795784119, 0.36611554427052306, 0.7752618481205098, 0.7578738545830529, 0.7781583994939699, 0.7777675574850635, 0.7600578790439924, 0.7516655857428078, 0.8033518753849023, 0.7565286130981883, 0.7611907615070905, 0.11782891570112441, 0.1842312552646035, 0.1197480683684169, 0.11487987036214675, 0.11001058838030675, 0.12844096735405452, 0.13683764140066101, 0.1406329055104787, 0.09186831989022126, 0.17852315071246017, 0.26017236839772917, 0.17147934716881463, 0.17973298589982134, 0.21359504173082366, 0.1721873701458102, 0.29133351753344106, 0.24247424164520015, 0.1778592281317215, 0.32152313568291013, 0.5095391597986463, 0.42635154023197885, 0.3200412292160709, 0.5092127773203635, 0.37099140383448126, 0.5651682606321802, 0.4579505763475208, 0.3483025959461711, 0.16249758402140668, 0.3272215765470403, 0.293227327020514, 0.3233585394892017, 0.1600928851601433, 0.31960619280488367, 0.2590679545641388, 0.2627434153206907, 0.3952692766621436, 0.2761568747722275, 0.20683365038199986, 0.24270359795646756, 0.248060805420797, 0.2177171583185321, 0.24261211343011224, 0.26772866314511334, 0.19729061887627308, 0.2278623422516688, 0.22006395894525754, 0.20953649548385578, 0.20532631040946303, 0.20929674816792732, 0.20824351367117988, 0.20787421803606232, 0.1776190095229303, 0.195184724266108, 0.19027173031703914, 0.1855606085759557, 0.18642275552584797, 0.16787624861843709, 0.15886213242137925, 0.20060943700556078, 0.9069825586318954, 0.9182510044860857, 0.16513334741171237, 0.2111339742591093, 0.8858312181269477, 0.8255562334425485, 0.16736640820286375, 0.8627944025013841, 0.8310389950047664, 0.7939699645253085, 0.8564326786487153, 0.15533974552025942, 0.16747267408420852, 0.18819063855364537, 0.17892529024471115, 0.1880200424810884, 0.16868147377596365, 0.1811393207531653, 0.22183262959093575, 0.20322504097853022, 0.19105000926965754, 0.17538533637847575, 0.07597717101698365, 0.1070094148404791, 0.08796316613802557, 0.12718121514111191, 0.07108800766543844, 0.08350421731498558, 0.08653705927943611, 0.09001606588173594, 0.09941066281492039]}, "mutation_prompt": null}
{"id": "d36c0ce2-0fa7-4d3d-8f4e-656011c3eca4", "solution": "import numpy as np\n\nclass ProbabilisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "ProbabilisticSwarmOptimizer", "description": "A probabilistic swarm optimizer utilizing adaptive multi-strategy mutation and crossover with fitness-based strategy reinforcement and periodic exploration to enhance global search capability.", "configspace": "", "generation": 51, "fitness": 0.47261847497766857, "feedback": "The algorithm ProbabilisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.9107563047434611, 0.9091453591411147, 0.8995209834343287, 0.8944900446994054, 0.8986986064919663, 0.9046664193734018, 0.8976886424112464, 0.901181849956386, 0.9129892249762458, 0.7973521471572178, 0.775360702782818, 0.7869322481442751, 0.8021623783410026, 0.8041671602245163, 0.8037914562895481, 0.8041715719749273, 0.7830859883816802, 0.765899453627075, 0.16157610885023022, 0.14096947585408748, 0.6502566841249939, 0.16778190728831943, 0.16360847308445903, 0.12316717132640986, 0.14196753959966768, 0.14003148104530772, 0.17951928995409328, 0.13036576939159172, 0.11857986193083636, 0.11716957863780864, 0.13866698535795352, 0.14806663629407357, 0.12733278471435083, 0.11239804670932285, 0.5727616356888143, 0.1506703822593718, 0.9857878953013647, 0.9902691163384355, 0.9790553417082318, 0.9835829290814216, 0.9703088043125705, 0.9629821981754058, 0.9824143491625666, 0.9812589556374633, 0.9679418009552968, 0.698488579712804, 0.7234162114225464, 0.7559598566691774, 0.7525094253346161, 0.7331018118793624, 0.7637499545456791, 0.7410351750016152, 0.7203588427359562, 0.7299241915118606, 0.7921705162488812, 0.887233964428263, 0.893374619502072, 0.8282562958665731, 0.8667980663991679, 0.9093887125072732, 0.9081665038727421, 0.2353910287756652, 0.38961182170646524, 0.5357484516143656, 0.5526375216926622, 0.6627968100164512, 0.5698899539655999, 0.6742711744249017, 0.7320803506882056, 0.6850470641029514, 0.13196112539302374, 0.5610073925010137, 0.630791783478989, 0.6187006622108082, 0.130208511323208, 0.5241142231953998, 0.6767777484246429, 0.585901414267655, 0.6831304265311549, 0.6441542653251016, 0.672100581433414, 0.48123027445389976, 0.4120330592169693, 0.5149090438839852, 0.24097903868591264, 0.4461438427521647, 0.526418751222271, 0.5168355768787884, 0.467731579767769, 0.5437347489947788, 0.63936852139412, 0.5946738183495948, 0.6595776603347843, 0.6155273606346904, 0.5883949234444263, 0.606584399815979, 0.6155797449040936, 0.6701482696565808, 0.6522383718125335, 0.4777827654805369, 0.20927183703009322, 0.18416720412026577, 0.3532601633443818, 0.5838042264514125, 0.39307280739496886, 0.18927134973582538, 0.28799580987085716, 0.14291195049748362, 0.41752161665806475, 0.4836183642892308, 0.4196660937650871, 0.4284003003141835, 0.40600996281039803, 0.5549157297842893, 0.3944561019065812, 0.3848202964564914, 0.4351352791846631, 0.8201197722919101, 0.8344359373239494, 0.7992547839607038, 0.8077621335883819, 0.828725941536107, 0.8145516046028269, 0.8234079969377137, 0.8212345145990676, 0.8108252133514067, 0.130564611642913, 0.10715886679982689, 0.10593522680460732, 0.13920159671302867, 0.16014884671963214, 0.11918006442857898, 0.12051068476716242, 0.17966489936668573, 0.17179226163013084, 0.15159661921266976, 0.2900056385228048, 0.49655697375394625, 0.16601176106622628, 0.21241839230752257, 0.2938910266741891, 0.23716642419510936, 0.25140081067276243, 0.1962250951887391, 0.46586403298304224, 0.5528782249883192, 0.5910144384201728, 0.32014838726648076, 0.4393398392578258, 0.5970451915405801, 0.5907236768932429, 0.5671160172227525, 0.587890270724616, 0.34507457896860605, 0.3060705511606131, 0.2379199340010575, 0.3019308376895249, 0.38397536064773974, 0.3698476712965231, 0.38718155811589217, 0.3193788782551674, 0.4603267818959006, 0.19698733197342821, 0.1968648385007773, 0.23128371642759393, 0.21792771694831548, 0.2149982540060894, 0.23963956989268387, 0.22600806966462317, 0.20862916223240313, 0.2101581404319568, 0.21976255055143434, 0.199126506797496, 0.24357672604194114, 0.7621806173245695, 0.2053891362656336, 0.19804545829167186, 0.21745094001583953, 0.2143400947930063, 0.20701764925960675, 0.9188226586277922, 0.1878079101542075, 0.1532005587993186, 0.9181637456370298, 0.20073591225401577, 0.16839383674328, 0.9023500604435506, 0.8780459935035929, 0.9023515203737946, 0.8776014936258499, 0.16912065375547225, 0.21177518913879156, 0.8870836469315025, 0.16979487157212114, 0.1557795347376092, 0.8690145012373228, 0.10353678864163252, 0.16753036305476798, 0.17869215326751076, 0.21193153475360305, 0.1759925066946576, 0.17618286972490116, 0.1807609778473629, 0.17909573572681547, 0.21504348384942562, 0.1789293295193244, 0.1741468883958578, 0.07555751630279717, 0.11465935879709488, 0.0878659843261641, 0.08407302738430866, 0.0730995576546446, 0.0882183105528398, 0.08419698544424192, 0.07738510670512755, 0.08679199064886034]}, "mutation_prompt": null}
{"id": "a9b437a1-1584-4268-8899-61947303633a", "solution": "import numpy as np\n\nclass ProbabilisticMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Reduced population size for faster convergence\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]  # Adjusted strategy probabilities\n        self.adaptive_factor = 0.85  # Slightly increased adaptive factor\n        self.crossover_rate = 0.8   # Slightly reduced crossover rate\n        self.memory = np.zeros((5, self.dim))  # Increased memory size\n        self.dynamic_memory_threshold = 0.2  # Adjusted memory threshold\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.5, 0.25]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.2:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "ProbabilisticMultiStrategyOptimizer", "description": "A probabilistic multi-strategy optimizer integrating adaptive memory handling and dynamic restart mechanisms.", "configspace": "", "generation": 52, "fitness": 0.4405552751718582, "feedback": "The algorithm ProbabilisticMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.8916693019049269, 0.894713716614921, 0.9140836095770175, 0.8991251073511881, 0.8742565806366389, 0.9171365737848539, 0.8984103145480893, 0.900711011459905, 0.8904544520579278, 0.8032318675262202, 0.8136351423075294, 0.8307213554695196, 0.8071183218765061, 0.8346382477787774, 0.8149675443804169, 0.8092249286105193, 0.8171279140111531, 0.7791404233584802, 0.1376821597171034, 0.1318934868720073, 0.8208227135936965, 0.18344054455598602, 0.18029706386266242, 0.16368100809518782, 0.17547036369835955, 0.17908671912675456, 0.12081023783105482, 0.15250263702102207, 0.17695269710983152, 0.13921349184185206, 0.10043617215162826, 0.11323038021366161, 0.11459280030114627, 0.14992348806823252, 0.13730861938820127, 0.10294918465281244, 0.9897160247746126, 0.9916595157615739, 0.9825374685333772, 0.980740812157056, 0.9878324283729603, 0.9827181761259339, 0.9846478109961889, 0.9688204740547013, 0.9901359391153854, 0.7157164947229882, 0.7064022426076284, 0.7530760822951237, 0.7410551944004206, 0.7587850125200521, 0.7652270300713135, 0.7355275066165785, 0.692619108129137, 0.6619163978425657, 0.790327687690171, 0.2414595875109422, 0.23294652854925713, 0.21409709513415498, 0.366642583706694, 0.2749949853682154, 0.23234910698029387, 0.33191779558120493, 0.834009777736953, 0.6467799402432308, 0.7294548352355038, 0.5696702566458183, 0.6810817820876884, 0.6572592637225885, 0.6087018141378377, 0.630445999165837, 0.6187565268651392, 0.6882825455532205, 0.7515863482005886, 0.746973128801856, 0.6700135415053302, 0.7397926568978965, 0.7320679781612451, 0.6287352655171015, 0.7088612377040249, 0.6397455840809352, 0.7021615388603873, 0.2743596143625131, 0.36769457743267686, 0.3779247989137814, 0.038801256405652906, 0.44765253751726, 0.21527969502143096, 0.37186861217907796, 0.503866009734504, 0.4013805526096875, 0.3951757481856766, 0.4588180582584044, 0.5267106137954, 0.3779221748027317, 0.579599612107651, 0.5875105955803503, 0.6404000121576121, 0.5683122566308867, 0.5322534842192148, 0.06407709392421712, 0.1942970492726317, 0.16838215180912264, 0.2599514459068817, 0.2972145291666608, 0.2820872861904231, 0.14703621170596815, 0.16941905209274677, 0.24616701224959314, 0.34648142340717625, 0.40175585536137204, 0.3937898883432388, 0.35449290776222286, 0.46700290613355067, 0.45990455021248167, 0.23629275609466638, 0.38093580233783664, 0.42762457343561244, 0.7808427625471603, 0.8236290883842872, 0.7947162015672612, 0.7840082856340699, 0.7624174635736009, 0.7659595735896417, 0.8394906821399389, 0.8007247473872607, 0.747842965883595, 0.15597284787246712, 0.10949235817528424, 0.162175022402958, 0.10954576827768991, 0.13335519154816955, 0.14289600937648883, 0.11406282403962775, 0.15509468968965645, 0.10580087691935025, 0.22093912092848866, 0.18541405454607407, 0.353552325148796, 0.26706448052807297, 0.1923349587571851, 0.22821472509459728, 0.24980598239355745, 0.20900122703057955, 0.2818223555223214, 0.3374205272136859, 0.3487652350141789, 0.2977665567298733, 0.39068715028355483, 0.4819895008567402, 0.4753691878162145, 0.5156429392955955, 0.3722353043380373, 0.5406552988072093, 0.3231742350432768, 0.2810359463870169, 0.2236994310797763, 0.2880940726558473, 0.27685500933685203, 0.41809898929128986, 0.29434655713652014, 0.2609322800346219, 0.1961790258645547, 0.23883140689714044, 0.25913982447173844, 0.2800703472057886, 0.25727979080167884, 0.22623844324047326, 0.3584391400819815, 0.27977903651856617, 0.20242836792961127, 0.22166475027330323, 0.21981290814682442, 0.24694413077305988, 0.21136324600258294, 0.1913236818203854, 0.1914920032976698, 0.20731065912980706, 0.22612605020239485, 0.1989780803456298, 0.17693876692471877, 0.9236054452375623, 0.12616418359951753, 0.17152780816127033, 0.922835942635179, 0.20018670757710488, 0.906891731673044, 0.1423335045376034, 0.8990491516227798, 0.9345339127471998, 0.89930645895128, 0.21105765543270838, 0.15641429698962073, 0.8491479675692784, 0.11295328574376651, 0.20948552377508645, 0.21270718591705695, 0.12796922826113333, 0.9064726311755634, 0.18125156216859883, 0.20326909931023773, 0.1854674601296138, 0.17441406031560602, 0.18300058909252348, 0.20529749499013916, 0.18723724563962063, 0.17781972643804145, 0.17697317893064302, 0.08689639141924799, 0.08406815789594713, 0.14524939317968388, 0.10946467779201774, 0.14406965530360483, 0.06813364896565277, 0.08802101139341245, 0.07989960630175041, 0.08212738862347946]}, "mutation_prompt": null}
{"id": "71047f57-ce76-4a59-aca8-aa92164cfca9", "solution": "import numpy as np\n\nclass AdaptiveMemoryDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((5, self.dim))\n        self.memory_index = 0\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            increment = 0.1\n            index = ['best_1_bin', 'target_to_best_1_bin', 'memory_guided'].index(strategy)\n            self.strategy_probs[index] = min(1.0, self.strategy_probs[index] + increment)\n            self.strategy_probs = [prob / sum(self.strategy_probs) for prob in self.strategy_probs]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.1:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory[self.memory_index % len(self.memory)] = trial\n                        self.memory_index += 1\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemoryDifferentialEvolution", "description": "Adaptive Memory Differential Evolution with Enhanced Strategy Adaptation incorporates historical memory and adaptive strategy selection to balance exploration and exploitation effectively.", "configspace": "", "generation": 53, "fitness": 0.3721162075876979, "feedback": "The algorithm AdaptiveMemoryDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.8500188337790644, 0.93074296989895, 0.8676809446181223, 0.8729488604018004, 0.8906766798047746, 0.8804021123558421, 0.6262620671191943, 0.8885705842446296, 0.89243172748791, 0.7721505749095338, 0.7214340502265233, 0.7732041024454274, 9.999999999998899e-05, 0.7774465241586361, 0.7689881637025627, 0.7319740993908103, 0.7170426609531616, 0.7938387278854088, 0.15789827311772064, 0.07938608019911242, 0.12027691372549221, 0.10345434951928567, 0.07647715125183208, 0.1194369021250915, 0.14661554095615936, 0.1614628883332654, 0.16653556971155448, 0.09471027616531624, 0.10546267717829905, 0.1584920162854867, 0.07800162208962813, 0.06769968211379729, 0.11998802325324265, 0.09400404193637968, 0.02377084079404901, 0.12470432019005162, 0.9877706670922369, 0.9709936149347415, 0.9899038763732259, 0.9869735226001826, 0.9783274820733625, 0.976308000901899, 0.9835186921716892, 0.9895898843044033, 0.9892511366367891, 0.6838225915854687, 0.6968518718600227, 0.6755172837053758, 0.20696218412033618, 0.172955511927815, 0.6639392281583191, 0.14273347446104, 0.24528511472751535, 0.6846686930600705, 0.23098548367648342, 0.172541854938826, 0.8558691274280276, 0.2123176561975363, 0.8721098456390531, 0.20856444969300458, 0.9045268218312026, 0.18815279263272677, 0.8669386951164385, 0.2380326036975895, 0.4597499350983043, 0.6686403574357518, 0.04494376043603754, 0.2353086360232477, 0.6287763511364439, 0.16153882895321026, 0.1807287493787233, 0.6031402595312061, 0.1377338967597872, 0.22800303081932338, 0.11919805128879202, 0.19061726579946148, 0.23356201451381375, 0.626138122126194, 0.1571216806736755, 0.260474538738948, 0.6699228079398591, 0.6399308328667292, 0.5354853302575369, 0.5287000499424018, 0.03800894021173917, 0.5921113570959367, 0.5865941868076882, 0.05603831171336915, 0.07099896495107971, 0.5440688159748226, 0.7210774105114321, 0.6509829129477638, 0.6643454007790932, 0.13847117268685527, 0.037639834418768614, 0.6325515801678252, 0.06872560837752806, 0.7094437771238551, 0.6624638669472839, 0.014010247867519365, 0.048490836003332705, 0.29522386807225387, 0.5352640497183259, 0.27677953498497276, 0.4362422484704108, 0.32447977089539626, 0.4488816492857579, 0.20185393643596994, 0.4456503497343255, 0.147965480928258, 0.45859204061803627, 0.43769399345009274, 0.03849320483100582, 0.4889406173550148, 0.48345431480957834, 0.47842600684888437, 0.46699194918019316, 0.4467493218822767, 0.5844783847466608, 0.8102470880480319, 0.8033472294866901, 0.29348665886225855, 0.8191857682555326, 0.4632180066631375, 0.5688268377142052, 0.7941807525536606, 0.1288139079509839, 0.11068976830700905, 0.13416782681635542, 0.14019861725357263, 0.13837263682484868, 0.09333396540872085, 0.09924156254061822, 0.07447001444920565, 0.12078980659757799, 0.24749332140382052, 0.23927707282901678, 0.2716407053829303, 0.5244477776279802, 0.13935869240802623, 0.201765319552469, 0.2694678260624581, 0.21884912991113847, 0.2287922249782347, 0.19920097301292605, 0.17475596790710146, 0.5009224421681854, 0.35335779125143185, 0.2347243739445295, 0.5398768692899747, 0.22921668119492178, 0.30570684239346735, 0.5804062441857614, 0.153336594280713, 0.2578093005180143, 0.38307917502193, 0.2274329171303744, 0.23507063499559477, 0.4164263538189056, 0.4254089157911495, 0.25715148363725926, 0.4372769857531299, 0.2815597135417639, 0.22608811603991508, 0.22149957168271983, 0.2612615312903015, 0.2375296495186494, 0.19297466319271805, 0.2592488385919153, 0.27291858638403543, 0.20843869970289375, 0.1764526018498529, 0.17474371309440995, 0.19074359985138467, 0.22558138996725197, 0.19369617340696776, 0.7215149032601702, 0.1640674379452366, 0.24917735908255967, 0.2353570591717148, 0.18650072749706414, 0.17341769143167363, 0.1539124726276403, 0.271558388949125, 0.1955334884397586, 0.8090772131260427, 0.8983409949854182, 0.16912828808148084, 0.10632680944679707, 0.30589342090816163, 0.21061446949081863, 0.8495263150654498, 0.3036781717707231, 0.29104435601411716, 0.16608773535876098, 0.16949322326334826, 0.15510446815037504, 0.1662714002211756, 0.17964742381266807, 0.18290636081566425, 0.18237336629608725, 0.1803105905479293, 0.18285087670294808, 0.18599408658725536, 0.17720313882638472, 0.19391555825518048, 0.17840353181941881, 0.0714183643501638, 0.09634526872189486, 0.0864820626374514, 0.08329045079589181, 0.07815234559891038, 0.07858240847952291, 0.0847208653475402, 0.08312411212812643, 0.08059226020721322]}, "mutation_prompt": null}
{"id": "16a7ea00-4c9a-4026-a536-c00f6e036396", "solution": "import numpy as np\n\nclass RefinedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.dynamic_memory_threshold = 0.1\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided' and np.random.rand() > self.dynamic_memory_threshold:\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.55, 0.25, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.55, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.45, 0.35, 0.2]\n\n    def adaptive_restart(self):\n        if np.random.rand() < 0.15:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        if np.random.rand() > self.dynamic_memory_threshold:\n                            self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedSwarmOptimizer", "description": "A refined dynamic swarm optimizer with adaptive control mechanisms and enhanced strategy selection probabilities for better convergence.", "configspace": "", "generation": 54, "fitness": 0.4854442465190579, "feedback": "The algorithm RefinedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.31.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.9147257742849584, 0.8982907595700707, 0.9076526772441756, 0.9171072915857511, 0.9159886295725943, 0.9218778357753189, 0.9161018537295752, 0.9032995361038345, 0.9062740105158944, 0.830416325044186, 0.8273644679350552, 0.8192508229071017, 0.8139248593969881, 0.8352597100906304, 0.8222465217852286, 0.8367828455367968, 0.8092201216306851, 0.7874373393263655, 0.13031769727523956, 0.1784579742233966, 0.08299195214867339, 0.11550233035177115, 0.15737095391710754, 0.11129338687357282, 0.09631067845240737, 0.14425374940661617, 0.11250386059106132, 0.109187544666286, 0.07892092784851334, 0.11251989933030049, 0.11638290665020545, 0.12606606227895933, 0.10511382145284665, 0.11559072928878666, 0.12524508094074227, 0.13864992024135714, 0.9787280195286719, 0.990865986620497, 0.9824234042428001, 0.9910009960038985, 0.9833169518975059, 0.9743570635443368, 0.9780936647259577, 0.9764399302988117, 0.9863654365873666, 0.7545517074084488, 0.7873135937487007, 0.7636755646131026, 0.7853894697438862, 0.8099253090253236, 0.8172607708449926, 0.8050324666759343, 0.7658003407909201, 0.7824783594496715, 0.8858602653058569, 0.8860679485516948, 0.2436053827850092, 0.2804768557219076, 0.27898292224139953, 0.21232363923999786, 0.24494717055283977, 0.9268094548620626, 0.18570563905442106, 0.13395424369108755, 0.7511495118543525, 0.7251531096693268, 0.719727772570135, 0.7665160690118346, 0.6613790508270436, 0.7418098260520404, 0.7233154869928721, 0.6714834190904541, 0.7586094916584873, 0.7813284391483022, 0.6549279380261045, 0.7328289239977672, 0.829841160889956, 0.8288696542008238, 0.7664553240421428, 0.8224413898180662, 0.78369762603211, 0.7020711871140011, 0.7063738681133043, 0.6055090336896702, 0.7324281380350071, 0.692088895916639, 0.5107658001025424, 0.7604831563919714, 0.7006598052854042, 0.7479637135196036, 0.7913800460961425, 0.7700430518526415, 0.7944832233762105, 0.7720995390217618, 0.7101000661572644, 0.7418195246397351, 0.7880758356874278, 0.7967648864866402, 0.7651571841528761, 0.5463634444069028, 0.25729809680281357, 0.5450851575370901, 0.6316686086393026, 0.7358133511903139, 0.529014958238436, 0.4500569546712835, 0.19385453554176368, 0.19795078447612946, 0.6549213949192136, 0.5521207497004703, 0.6363767300844765, 0.5713388533191792, 0.5498417657524857, 0.5930219807897359, 0.6496905183508528, 0.3984044062682225, 0.5496261816847696, 0.8749872397749788, 0.8615574556724048, 0.8515899187749685, 0.8394670531474023, 0.8340094080827242, 0.859515527594199, 0.8681870794539766, 0.8781828124336549, 0.8659743242691608, 0.1081538483872928, 0.1233153189864522, 0.08007760671127906, 0.14559787407681346, 0.10038029307880225, 0.12450477906886137, 0.13521953217761185, 0.07983450374591516, 0.1277715609219675, 0.1810277712777152, 0.1711414292497182, 0.17489517627372786, 0.3875747478112157, 0.6528708307389074, 0.27605711045928205, 0.2493894375224851, 0.17860441247683922, 0.13344200915301352, 0.41699565622084855, 0.37759101740520373, 0.4654994213024124, 0.35743895522806524, 0.5374933976673586, 0.47971150920565986, 0.28654216489630213, 0.32966171081056406, 0.4758854093757068, 0.36482845878155246, 0.2572997609242291, 0.2855502201208474, 0.34108571728422443, 0.4297435925331311, 0.2910775527724381, 0.43773087317245074, 0.29980278829979135, 0.2037295623890253, 0.2954512686087737, 0.26152871212129947, 0.2038260959081003, 0.19123898604093426, 0.2056797194712362, 0.225420010802574, 0.2823238510993188, 0.24627900808825098, 0.21368016731854345, 0.24991403820137947, 0.22073171261146096, 0.19811221929945455, 0.22582503689851796, 0.19205518408627242, 0.18893770906774365, 0.18907225257218518, 0.17761145604362827, 0.1841608529212151, 0.9441658925083288, 0.1228248232045206, 0.15353234854791376, 0.9112330726697878, 0.199097340551753, 0.16742909179542254, 0.9056888397387635, 0.19493710734386482, 0.2097782897674909, 0.9297338137503504, 0.21347386110358701, 0.2116683328534692, 0.920268278538903, 0.16916701865311312, 0.1562255525102646, 0.16673999942345397, 0.12810697296386664, 0.9071303219050946, 0.18092609949512484, 0.180492270811917, 0.18106047458405872, 0.1690372183745672, 0.190219851738473, 0.1917803322545999, 0.20087907925567294, 0.17308431742943753, 0.1761678489954568, 0.09329225221337512, 0.1284428946478685, 0.09007019298172003, 0.09772909832781318, 0.07618090146181189, 0.08439769836390565, 0.08929865079620303, 0.09130087081715788, 0.11564808924106107]}, "mutation_prompt": null}
{"id": "10fd0689-388d-4c8d-93e0-dded075b87ac", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.1\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.6, 0.2, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.6, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveSwarmOptimizer", "description": "An adaptive swarm optimizer using self-adaptive exploration strategies and dynamic reinitialization based on diversity measures.", "configspace": "", "generation": 55, "fitness": 0.49262933262125, "feedback": "The algorithm AdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.32.", "error": "", "parent_id": "6cc03b3d-eed0-4230-b192-a54500425579", "metadata": {"aucs": [0.9387046178558623, 0.9110506739435561, 0.9260535772909955, 0.9198919524457958, 0.9255756902776957, 0.9202358110363618, 0.9221097343207919, 0.9263223516309628, 0.9187648140138327, 0.823272226629014, 0.8441706220221592, 0.8369467301546133, 0.8282103271638768, 0.8539904876103362, 0.8420816505723624, 0.8213741375059656, 0.8240009065976408, 0.7844376520461738, 0.1340892145484084, 0.10873025011262616, 0.14309573088272753, 0.1595841490297507, 0.161521098596638, 0.16344702374134834, 0.15640085965945927, 0.15858604486346506, 0.1436048482249178, 0.10943618562507673, 0.0808181747266784, 0.06839806782472535, 0.11098794486399333, 0.10071334912148266, 0.15730218559860354, 0.18492293906763213, 0.15778750006733522, 0.14453222153075107, 0.9762731285663182, 0.988724745787857, 0.9881787765736916, 0.9848764172140977, 0.9740137032583044, 0.9841639067809713, 0.9813545250690087, 0.9891744699619153, 0.986357703152909, 0.7497498741726593, 0.7636662382060857, 0.7612767196336743, 0.7889423020755897, 0.7969662964560589, 0.7772225451612175, 0.7965909269792956, 0.7990621246695441, 0.7970907843219845, 0.9070170434693196, 0.928048193358417, 0.8757721390020734, 0.21406746324822712, 0.890641419719913, 0.3808731240830312, 0.4068985960737884, 0.4043093506497665, 0.9157761815437838, 0.7448449562224748, 0.7967802186755675, 0.7189031056703387, 0.7634416824082083, 0.13404081503404175, 0.7814075683613934, 0.7659328231315514, 0.7298591015959699, 0.7941629252577843, 0.7169737068035437, 0.785057972030874, 0.7730207203043609, 0.8390251024524542, 0.7784877547993143, 0.7406428333060491, 0.7888607383304613, 0.7866992475338221, 0.7828089863260691, 0.6401723454382539, 0.5687732485496375, 0.5130091055713533, 0.5866378776390748, 0.6866123642565278, 0.5793001179993187, 0.7265657232953782, 0.6686739607612084, 0.6780612000306103, 0.5617968955415513, 0.6771926925863054, 0.7609126685964297, 0.8114255510559589, 0.7765450860322901, 0.7316632819688722, 0.8266472859944783, 0.7889565724196262, 0.7660708333233678, 0.5957137480046166, 0.29420322689885003, 0.262573695264543, 0.5777227003706615, 0.4898626916151594, 0.46752703977795396, 0.1750621534838156, 0.2617163629238466, 0.1618817411217497, 0.4530715809954523, 0.3766342412073541, 0.4627054075912186, 0.6342294559950146, 0.6303043579711256, 0.649339121035535, 0.5144320300822687, 0.32507314953035515, 0.6134650059143758, 0.8735703894339168, 0.8322649871465402, 0.8303204899425286, 0.8632958332374865, 0.8580092694122492, 0.829849709514044, 0.8637131909901434, 0.8619427589162983, 0.849338791710233, 0.10973889096062484, 0.11549509978246242, 0.09806098278260866, 0.096894938515801, 0.16031003786541476, 0.11701763600480464, 0.14464621869435468, 0.09107102867025185, 0.09622858126403389, 0.20201909841039156, 0.2212526461998634, 0.15499793552798868, 0.2057976384848874, 0.17068861585057726, 0.16629627192631802, 0.20352636744234887, 0.14404664362172548, 0.2032828043967615, 0.2820578478070809, 0.34335037090840737, 0.2898555619077515, 0.42314332525227927, 0.31188776956306674, 0.3465755275025648, 0.485748476223411, 0.2546118796728627, 0.23041381543965855, 0.28600096969581723, 0.20862907494220628, 0.2051536576845523, 0.21736942492303168, 0.26392358362361734, 0.31954382337743037, 0.2874643067656204, 0.2556843168444871, 0.1437564891453179, 0.7354401790669298, 0.23436868930214705, 0.21464392718312042, 0.2603410992176507, 0.24840417349938337, 0.23245482377174975, 0.2114014709147246, 0.22595143022592856, 0.2058188858018437, 0.18871436568642153, 0.18415858069735191, 0.22500858567733173, 0.18957328548119667, 0.21170108128587195, 0.19580468599003764, 0.2255723691105539, 0.1832889039053398, 0.1881282106892661, 0.9490686344567704, 0.9378834221104869, 0.15355053190521994, 0.18831076992921736, 0.8619417921674919, 0.16582382914924643, 0.1863434608688036, 0.8803276308419274, 0.1421518681727757, 0.9326856774145613, 0.2112019937217141, 0.8837895937384389, 0.2125466396456629, 0.8899471244356805, 0.8815589076766684, 0.21353306181653453, 0.9139205274762408, 0.9077986657658615, 0.18711609259658046, 0.17554255646897476, 0.17711981284424017, 0.16682176875986565, 0.17863313870484487, 0.17350116122771742, 0.19728911676220384, 0.188215705470267, 0.1767600974239324, 0.12720250419354795, 0.10894758447509267, 0.09741547960018615, 0.08078321682340084, 0.07737050889599228, 0.08250916987165002, 0.10324191592432341, 0.09341639133295376, 0.09031843854872279]}, "mutation_prompt": null}
{"id": "6f64a49e-c1fa-44c0-bfb3-93bf920cd577", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.1\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.6, 0.2, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.6, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n        if self.best_fitness < 1e-6:\n            self.adaptive_factor *= 0.95\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedSwarmOptimizer", "description": "An enhanced swarm optimizer using adaptive exploration, memory-guided mutation, and diversity-based reinitialization for robust global search.", "configspace": "", "generation": 56, "fitness": 0.49501436922442527, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.32.", "error": "", "parent_id": "10fd0689-388d-4c8d-93e0-dded075b87ac", "metadata": {"aucs": [0.9387046178558623, 0.9110506739435561, 0.9260535772909955, 0.9198919524457958, 0.9255756902776957, 0.9202358110363618, 0.9253671189028256, 0.9258263688975289, 0.9210126937048699, 0.8257799288964567, 0.8369064066122132, 0.8430181409565023, 0.8421496766716201, 0.8501666857120501, 0.8464769372416354, 0.8343336611623753, 0.812798184860043, 0.7883964507683028, 0.09709154793530506, 0.1100631467003641, 0.14338050152627368, 0.1595841490297507, 0.161521098596638, 0.16344702374134834, 0.15640085965945927, 0.15858604486346506, 0.1436048482249178, 0.12237684947145988, 0.11088601576157575, 0.09351418010894175, 0.11098794486399333, 0.10071334912148266, 0.15730218559860354, 0.18492293906763213, 0.15778750006733522, 0.14453222153075107, 0.9762731285663182, 0.988724745787857, 0.9881787765736916, 0.9848764172140977, 0.9740137032583044, 0.9841639067809713, 0.9813545250690087, 0.9891744699619153, 0.986357703152909, 0.7497498741726593, 0.7636662382060857, 0.7612767196336743, 0.7889423020755897, 0.7969662964560589, 0.7772225451612175, 0.7938772313532543, 0.8239066649752821, 0.8126518646913369, 0.9070170434693196, 0.928048193358417, 0.8757721390020734, 0.21406746324822712, 0.890641419719913, 0.3808731240830312, 0.4068985960737884, 0.4043093506497665, 0.9157761815437838, 0.7448449562224748, 0.7967802186755675, 0.7189031056703387, 0.7850310794248141, 0.13401422212444591, 0.7831004633396752, 0.7659328231315514, 0.7298591015959699, 0.7941629252577843, 0.7169737068035437, 0.785057972030874, 0.7730207203043609, 0.8390251024524542, 0.7784877547993143, 0.7406428333060491, 0.7888607383304613, 0.7866992475338221, 0.7828089863260691, 0.5785802004755591, 0.12106920254832798, 0.5802463175845369, 0.5866378776390748, 0.6866123642565278, 0.5793001179993187, 0.6866930116792012, 0.7144739729487392, 0.7383743161054536, 0.5617968955415513, 0.6771926925863054, 0.7609126685964297, 0.8285443336439917, 0.3270621846339573, 0.7032531720323754, 0.8266472859944783, 0.7889565724196262, 0.7660708333233678, 0.4683811246737637, 0.16455650416232126, 0.22166697111402323, 0.43992039384744064, 0.5377192345071834, 0.42492873580093404, 0.1750621534838156, 0.2617163629238466, 0.1618817411217497, 0.4530715809954523, 0.3766342412073541, 0.4627054075912186, 0.6681912892184085, 0.49201932527571757, 0.6885767884620397, 0.5988200717581109, 0.6473205858980624, 0.4878793387878029, 0.8866988148463084, 0.853556983145432, 0.864663736684735, 0.8235488863496827, 0.8413936892674921, 0.8688099469931364, 0.8637131909901434, 0.8619427589162983, 0.849338791710233, 0.10973889096062484, 0.11549509978246242, 0.09806098278260866, 0.096894938515801, 0.16031003786541476, 0.11701763600480464, 0.15856549396746655, 0.10896936605473961, 0.11715425304047455, 0.20201909841039156, 0.2212526461998634, 0.15499793552798868, 0.18909316050699387, 0.2515767873222138, 0.23856205895228855, 0.20352636744234887, 0.14404664362172548, 0.2032828043967615, 0.6545295659159274, 0.4735089239017165, 0.3855355461589829, 0.42314332525227927, 0.31188776956306674, 0.3465755275025648, 0.485748476223411, 0.2546118796728627, 0.23041381543965855, 0.21494171762940972, 0.22401151436975586, 0.31591182538515417, 0.21736942492303168, 0.26392358362361734, 0.31954382337743037, 0.2874643067656204, 0.2556843168444871, 0.1437564891453179, 0.25882042061173405, 0.26691396384676214, 0.2815229667877791, 0.2603410992176507, 0.24840417349938337, 0.23245482377174975, 0.2114014709147246, 0.22595143022592856, 0.2058188858018437, 0.21195366195779575, 0.22586742934593296, 0.17437981282083148, 0.18957328548119667, 0.21170108128587195, 0.19580468599003764, 0.2255723691105539, 0.1832889039053398, 0.1881282106892661, 0.9490686344567704, 0.9378834221104869, 0.15355053190521994, 0.18831861133142314, 0.8578987377495987, 0.16582382914924643, 0.9189671370706297, 0.1642380216684709, 0.9195580961745079, 0.9339350223689116, 0.21204567134309082, 0.8994066135816423, 0.2125466396456629, 0.8899471244356805, 0.8815589076766684, 0.2135443079802617, 0.897552661503551, 0.9146287802042372, 0.18711609259658046, 0.17554255646897476, 0.17711981284424017, 0.16682176875986565, 0.17863313870484487, 0.17350116122771742, 0.21620724957645487, 0.2486910119441743, 0.2141920576017734, 0.12720250419354795, 0.10894758447509267, 0.09741547960018615, 0.08078321682340084, 0.07737050889599228, 0.08250916987165002, 0.10324191592432341, 0.09341639133295376, 0.09031843854872279]}, "mutation_prompt": null}
{"id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.1\n        self.stagnation_count = 0\n        self.max_stagnation = 10\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.6, 0.2, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.6, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.95\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedSwarmOptimizer", "description": "An enhanced swarm optimizer integrating adaptive reaction to stagnation and strategic exploration to enhance convergence efficiency.", "configspace": "", "generation": 57, "fitness": 0.495415034136322, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.32.", "error": "", "parent_id": "6f64a49e-c1fa-44c0-bfb3-93bf920cd577", "metadata": {"aucs": [0.9387046178558623, 0.9110506739435561, 0.9260535772909955, 0.9198919524457958, 0.9255756902776957, 0.9202358110363618, 0.9253671189028256, 0.9258263688975289, 0.9210126937048699, 0.8257799288964567, 0.8369064066122132, 0.8430181409565023, 0.8421496766716201, 0.8501666857120501, 0.8464769372416354, 0.8343336611623753, 0.812798184860043, 0.7883964507683028, 0.09709154793530506, 0.1100631467003641, 0.14338050152627368, 0.1595841490297507, 0.161521098596638, 0.16344702374134834, 0.15640085965945927, 0.15858604486346506, 0.1436048482249178, 0.12237684947145988, 0.11088601576157575, 0.09351418010894175, 0.11098794486399333, 0.10071334912148266, 0.15730218559860354, 0.18492293906763213, 0.15778750006733522, 0.14453222153075107, 0.9762731285663182, 0.988724745787857, 0.9881787765736916, 0.9848764172140977, 0.9740137032583044, 0.9841639067809713, 0.9813545250690087, 0.9891744699619153, 0.986357703152909, 0.7497498741726593, 0.7636662382060857, 0.7612767196336743, 0.7889423020755897, 0.7969662964560589, 0.7772225451612175, 0.7938772313532543, 0.8239066649752821, 0.8126518646913369, 0.9070170434693196, 0.928048193358417, 0.8757721390020734, 0.21406746324822712, 0.890641419719913, 0.3808731240830312, 0.4068985960737884, 0.4043093506497665, 0.9157761815437838, 0.7448449562224748, 0.7967802186755675, 0.7189031056703387, 0.7850310794248141, 0.13401422212444591, 0.7831004633396752, 0.7659328231315514, 0.7298591015959699, 0.7941629252577843, 0.7169737068035437, 0.785057972030874, 0.7730207203043609, 0.8390251024524542, 0.7784877547993143, 0.7406428333060491, 0.7888607383304613, 0.7866992475338221, 0.7828089863260691, 0.5785802004755591, 0.12106920254832798, 0.5802463175845369, 0.5866378776390748, 0.6866123642565278, 0.5793001179993187, 0.6866930116792012, 0.7144739729487392, 0.7383743161054536, 0.5617968955415513, 0.6771926925863054, 0.7609126685964297, 0.8285443336439917, 0.3270621846339573, 0.7032531720323754, 0.8266472859944783, 0.7889565724196262, 0.7660708333233678, 0.4683811246737637, 0.16455650416232126, 0.22166697111402323, 0.43992039384744064, 0.5377192345071834, 0.42492873580093404, 0.1750621534838156, 0.2617163629238466, 0.1618817411217497, 0.4530715809954523, 0.3766342412073541, 0.4627054075912186, 0.6681912892184085, 0.49201932527571757, 0.6885767884620397, 0.5988200717581109, 0.6473205858980624, 0.4878793387878029, 0.8866988148463084, 0.853556983145432, 0.864663736684735, 0.8235488863496827, 0.8413936892674921, 0.8688099469931364, 0.8637131909901434, 0.8619427589162983, 0.849338791710233, 0.10973889096062484, 0.11549509978246242, 0.09806098278260866, 0.096894938515801, 0.16031003786541476, 0.11701763600480464, 0.15856549396746655, 0.10896936605473961, 0.11715425304047455, 0.20201909841039156, 0.2212526461998634, 0.17579167238414395, 0.18909316050699387, 0.2515767873222138, 0.23856205895228855, 0.20352636744234887, 0.14404664362172548, 0.2032828043967615, 0.6545295659159274, 0.4735089239017165, 0.3855355461589829, 0.42314332525227927, 0.31188776956306674, 0.3465755275025648, 0.485748476223411, 0.2546118796728627, 0.23041381543965855, 0.21494171762940972, 0.22401151436975586, 0.31591182538515417, 0.21736942492303168, 0.26392358362361734, 0.31954382337743037, 0.2874643067656204, 0.2556843168444871, 0.1437564891453179, 0.25882042061173405, 0.26691396384676214, 0.2815229667877791, 0.23109879616947782, 0.2550440103704372, 0.25348393042540973, 0.22739921435196464, 0.21174870942140855, 0.2235631521600756, 0.21195366195779575, 0.22586742934593296, 0.17437981282083148, 0.18957328548119667, 0.21170108128587195, 0.19580468599003764, 0.2255723691105539, 0.1832889039053398, 0.1881282106892661, 0.9490686344567704, 0.9378834221104869, 0.15355053190521994, 0.18831861133142314, 0.8578987377495987, 0.16582382914924643, 0.9189671370706297, 0.1642380216684709, 0.9195580961745079, 0.9339350223689116, 0.21204567134309082, 0.8994066135816423, 0.2125466396456629, 0.8899471244356805, 0.8815589076766684, 0.2135443079802617, 0.897552661503551, 0.9146287802042372, 0.19608721595777967, 0.19440476063766288, 0.18015316078105748, 0.1842444120085608, 0.18003680265601885, 0.17993780101976065, 0.21620724957645487, 0.2486910119441743, 0.2141920576017734, 0.11252374053419223, 0.10894758447509267, 0.09054511664059706, 0.08493074247716959, 0.07805433077120816, 0.09007454245870883, 0.10173034577663398, 0.09662754714893251, 0.0894255915707699]}, "mutation_prompt": null}
{"id": "5c61d2d6-93e7-4218-a1e0-34b4a680fd52", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.1\n        self.stagnation_count = 0\n        self.max_stagnation = 12\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.55, 0.25, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.55, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.45, 0.35, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A dynamic swarm optimizer with probabilistic strategy adaptation and diversity-driven exploration to enhance performance stability.", "configspace": "", "generation": 58, "fitness": 0.4836447602725468, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.32.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9322688588646344, 0.9204919600158301, 0.9279623312465611, 0.928082218308189, 0.9291219121479032, 0.9145437300731815, 0.9199212791360752, 0.927128036480019, 0.9212792546607778, 0.8309565303157208, 0.845071406150985, 0.83462468082718, 0.8629739841843834, 0.8410497290654915, 0.8485657262413187, 0.8411755019588696, 0.8252523476252077, 0.7991809661726466, 0.18774539151826453, 0.11509736933082126, 0.15877663919716256, 0.14513630092544028, 0.12842086724321033, 0.16059566351228005, 0.14305629379531182, 0.11408715316362616, 0.14070168871941247, 0.1305980723261182, 0.11975043561810839, 0.09493449674784138, 0.13364957644572462, 0.11450838755180648, 0.15712559583355634, 0.14489001079590214, 0.09859972361719627, 0.14424051287583128, 0.9762731285663182, 0.9864447736785421, 0.9881787765736916, 0.9786162241882932, 0.982749800353034, 0.9841639067809713, 0.9820797165900884, 0.9891656016078012, 0.9848375625288426, 0.7950832148568953, 0.7927376168802398, 0.7717871841187303, 0.814102877847525, 0.8159793651670021, 0.7982227978547062, 0.8099772747599416, 0.8153656195751493, 0.8342140866016237, 0.9169564110199705, 0.2494810755936312, 0.9264187818486207, 0.92151482063183, 0.3829681651439183, 0.21219014480082432, 0.8364348693150494, 0.9052208118524442, 0.2335696322284705, 0.7512685336104323, 0.772180582830952, 0.7505615485584598, 0.8400846682682214, 0.6802016339851069, 0.7726408338415879, 0.732663264000819, 0.7074413037262173, 0.7722132562002599, 0.7695851945216875, 0.8032632752600207, 0.7899692463589045, 0.8321203454592306, 0.7920133767893203, 0.764015373040204, 0.7950079669766195, 0.7705577241150039, 0.768223337715428, 0.5797853435086107, 0.07094528660421551, 0.7610579497169846, 0.7067672301900023, 0.7138041568676103, 0.6739687690936629, 0.6807560022690816, 0.3900743281622555, 0.7779264490476046, 0.5510817767601214, 0.8076158218357706, 0.7935832015630652, 0.8147596714931682, 0.7640038571949856, 0.7611297316835033, 0.804682283675502, 0.787378377235501, 0.7684019898310932, 0.48214180927274997, 0.09448307127543354, 0.17797170232021198, 0.38992479859897233, 0.42629099594419395, 0.5393092284387537, 0.189468605356225, 0.27620867105248004, 0.17937750894354254, 0.4400534128070467, 0.41759163154812406, 0.49070218568151946, 0.4693275090358915, 0.5413864105683134, 0.5766461074393768, 0.34129513643288556, 0.2582387063863346, 0.3441380794611244, 0.8715178306095018, 0.7885926921253891, 0.6994391174790744, 0.8367461060855417, 0.8195744785854123, 0.8636830106568832, 0.8856946428835651, 0.8692337117792921, 0.8571761133173459, 0.15474388655356397, 0.14259877759222217, 0.11601063310584236, 0.09654975067198268, 0.16111231817963112, 0.15778230826796658, 0.1456223459515068, 0.13057769376943673, 0.14295014512342352, 0.6389129631939952, 0.18543757885912793, 0.21386625282653493, 0.39255815673947936, 0.3494549827399649, 0.1834226682235075, 0.22633089677295248, 0.1411699938240477, 0.31435496346711567, 0.2637919630261246, 0.523205297256665, 0.4828406672966139, 0.333763834277633, 0.3474464807895673, 0.4330373938667771, 0.3541949032872136, 0.4232799280096041, 0.27914913960203025, 0.19003571308499378, 0.3171247344595972, 0.36217843659290727, 0.2330253558372004, 0.31731226626431885, 0.39815229905048566, 0.21358422995780746, 0.3358693601361815, 0.21853928524204558, 0.26256840754371047, 0.24740491589064773, 0.25344736488619557, 0.23792033538715018, 0.23303537959839882, 0.4445279126639553, 0.3220638741519397, 0.23518826526022663, 0.24510065562827654, 0.21715302069347076, 0.19355605271833376, 0.18151945177405215, 0.20008720206197406, 0.19584733721707448, 0.18997661864085325, 0.17503271200482962, 0.19224474888159915, 0.1830937076197715, 0.946633314013725, 0.12306135510308869, 0.18739315543010182, 0.18825686155790766, 0.19788181282168893, 0.16584572353976623, 0.14233480595741532, 0.166954228104096, 0.9132446699809434, 0.9325069806009373, 0.21308524863943323, 0.9132828517310102, 0.21246767369895947, 0.16752339110545456, 0.8772144827263383, 0.21355222203732283, 0.9086238791525726, 0.12809237066170387, 0.19114089668502243, 0.18343445610768627, 0.18249068953268832, 0.19695717514347522, 0.18230549970809584, 0.19472084582150406, 0.23118471568032706, 0.21278337300144246, 0.19479844111302158, 0.11667579564615482, 0.11046960990236021, 0.08800143341556033, 0.07456723163626688, 0.0852250633605075, 0.07742946155551234, 0.08043610655072209, 0.08226211975420195, 0.09042887113743836]}, "mutation_prompt": null}
{"id": "d0432cd2-a9c9-419d-b8fe-508f1c74beb7", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 12\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * 0.5 * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.92\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A novel swarm optimizer with dynamic strategy balancing and adaptive explorations to enhance optimization convergence.", "configspace": "", "generation": 59, "fitness": 0.41595014144602976, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.8183128411085163, 0.810795800435944, 0.8289057854307029, 0.8315896164874789, 0.832022561756597, 0.831119586824819, 0.8779826363001837, 0.8522570214996268, 0.8588958762675801, 0.7483650642382131, 0.7242634142537903, 0.7475968318612398, 0.7105273781206438, 0.7313625167656823, 0.7186341348407301, 0.6754841384235584, 0.7305579906597541, 0.6991724709137026, 0.13626851824108177, 0.18005142431379084, 0.13073032195743783, 0.1585416115628404, 0.16087613626810848, 0.1417954636933758, 0.37375770024965305, 0.16566453877098686, 0.31985045180786587, 0.10491196805492742, 0.15597932114830204, 0.11269810982613293, 0.13887984145023424, 0.1638193196348171, 0.22191801300222158, 0.12796523965048368, 0.14232114197133527, 0.14008496373875312, 0.989414337099, 0.9778181178526894, 0.9849030147556231, 0.9812309343870991, 0.9825777670347311, 0.9882993504936419, 0.9812379747259409, 0.9713114875781843, 0.9873787061832219, 0.5340905114562582, 0.49592359586878043, 0.5585829908311908, 0.5467596768297105, 0.5102650597720683, 0.5469525960964853, 0.6918600408835964, 0.6549110423948876, 0.7113909658613726, 0.8105729401039633, 0.8551763442399583, 0.7860570953102923, 0.873534049029776, 0.8302642319560577, 0.7208231859369698, 0.8221857501856293, 0.8050811859198423, 0.7933215881511805, 0.46536593415281535, 0.4978588711076334, 0.45075782009199006, 0.1293805677946499, 0.5560592041670231, 0.49967841702243376, 0.4606780297905423, 0.3442604398075497, 0.32438968686766234, 0.43185576385452296, 0.3517415194012381, 0.3787196326000011, 0.3667674344437887, 0.4860521848970818, 0.39292643170856967, 0.4538446693787135, 0.4501834819418232, 0.392246260566676, 0.5345723085257839, 0.532712601228398, 0.47466614777093297, 0.3511526124257319, 0.3247535346579612, 0.24751057881949923, 0.6071774914672599, 0.3069195432075952, 0.2581442880415836, 0.4208868695826724, 0.37494249509479627, 0.4380916845847964, 0.5954471194719366, 0.6358371406756026, 0.5536628649630814, 0.4950291055182465, 0.4625549101301545, 0.47412209370913694, 0.17961909366471862, 0.1538081909801382, 0.15549902482261202, 0.26186655304028594, 0.1344630906494635, 0.29479284408410256, 0.16206225199903002, 0.2450857283989808, 0.1311724655153259, 0.2743608255289851, 0.3010359671518551, 0.2982933910655846, 0.30520337878016546, 0.39123558474901643, 0.3310367665246381, 0.41105314718503194, 0.2894227726802736, 0.4333427212179273, 0.7819896465509721, 0.651306641681334, 0.7470165700570479, 0.6631810355768681, 0.6627865813656418, 0.6679372414142468, 0.6807818029068773, 0.6269706953035948, 0.6464666495986453, 0.11861688063928999, 0.2266270648358153, 0.10874900032134593, 0.11713088315630193, 0.1323043000043348, 0.1128534335112521, 0.17601116246432524, 0.13855936028467508, 0.15292998186071816, 0.19997782506332384, 0.14133653327990192, 0.14230372071995812, 0.20885433507888151, 0.3028350039216342, 0.26252832114846403, 0.2104772278459709, 0.16929687110406832, 0.19988693962930848, 0.3788559813041107, 0.4691087322485942, 0.36574516022067693, 0.4489863803032962, 0.446340622268277, 0.4423538300930533, 0.4683600458978533, 0.45538078881795396, 0.46277114750813375, 0.30570414624608644, 0.2719883038109302, 0.4458361218508893, 0.3123202962509861, 0.3559386753698204, 0.26801839003722083, 0.3397011104961405, 0.34440217491695835, 0.36158365894192235, 0.21916890008860068, 0.226856042866022, 0.24577587200929707, 0.1987190471374083, 0.20680421445436348, 0.21252950610259513, 0.23362512559239568, 0.23096195482761617, 0.2514073125204591, 0.19894032843681075, 0.7719563603829331, 0.207589537185642, 0.20341072622483314, 0.23259619091383354, 0.21365913227068611, 0.19479533193422938, 0.20398571500283746, 0.23011373296503468, 0.18268754332414572, 0.15620150928060683, 0.20724908751978066, 0.7490633411173659, 0.19493873533058392, 0.16426043055566153, 0.8716715910772304, 0.16434333757141817, 0.8728358498254437, 0.8746029794772756, 0.20754124605214752, 0.16756018312980503, 0.20127878233653584, 0.16639106523913505, 0.7763981770673075, 0.8020077636228975, 0.8700662053562458, 0.2102251336302433, 0.17431053072408198, 0.17611832944973538, 0.1895281703671463, 0.20670802948784683, 0.1855870008056465, 0.18448408839738262, 0.21581601309589327, 0.22459896798480927, 0.2203181347730846, 0.08056391310402289, 0.08184929632258986, 0.08648953230416645, 0.09609912037527779, 0.07962480972319863, 0.08523297581288913, 0.08196000579693885, 0.10384583553188209, 0.0865786999714333]}, "mutation_prompt": null}
{"id": "0f477a64-a702-433f-9c82-3a5489b5907f", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A swarm optimization algorithm with dynamic strategy adaptation and enhanced diversity control to improve convergence.", "configspace": "", "generation": 60, "fitness": 0.44211626055943004, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.8933311437205714, 0.9030210772905027, 0.9238480970216703, 0.9107498770336311, 0.9114733765598784, 0.9198755566251535, 0.9103506740328293, 0.9087159482345398, 0.9093515619758856, 0.8192948669028494, 0.8271727594253734, 0.8347077789841949, 0.7960330102813771, 0.799928046406438, 0.813003491059132, 0.778569842819878, 0.8387458528119138, 0.792760648648233, 0.14031503477530316, 0.11555672406304696, 0.14230632554191014, 0.11654381988546825, 0.1837949652216766, 0.1381082208976151, 0.12982117405882143, 0.08813967525584887, 0.15580966069287228, 0.11904481456315352, 0.1092580427592853, 0.1424469370775976, 0.1126688730303862, 0.16051970492880285, 0.10710145929061587, 0.15404832776965827, 0.1143567172821136, 0.14257607787503235, 0.9846918742068298, 0.975362197135171, 0.9850515213754955, 0.9819360465298924, 0.9702488253829081, 0.9747241539005065, 0.9751796306486425, 0.9641525572705937, 0.9819274209846678, 0.7234641418336759, 0.7330678913979842, 0.7173907527408346, 0.7430655732651454, 0.7401488481759313, 0.7349042962175754, 0.751168668915255, 0.7731147435997663, 0.7637641758293677, 0.8841270808399601, 0.24262722741687826, 0.20866104914393901, 0.8599026978875359, 0.8538918369054189, 0.21157168178335306, 0.8662317752932243, 0.8631732741975897, 0.17514140842042292, 0.7150394513538862, 0.7864505008582755, 0.6301591386502032, 0.6128988814130982, 0.13197562739248148, 0.665287904783269, 0.13152618702918295, 0.7058158673427635, 0.6421922589748692, 0.6549436710289074, 0.6424662464823165, 0.1363872744939716, 0.7136204983490717, 0.6762958380559809, 0.6463840841384498, 0.6861485083534997, 0.7671773062059073, 0.6701075282846252, 0.5209082977465814, 0.5871324098933395, 0.1959708048403711, 0.3615592599730155, 0.6655087633503007, 0.48518684560293845, 0.7440827526452427, 0.6774094534584255, 0.1420507958011029, 0.6547536286689397, 0.6992222371616585, 0.6540246393886269, 0.7154240218583111, 0.7313662992654839, 0.5929211542023909, 0.7145854949451784, 0.7028447739383912, 0.6581243016885561, 0.1722867274254224, 0.3775987653967039, 0.370114336610059, 0.39198618385211836, 0.5312496925191038, 0.423809079880491, 0.2889662464605097, 0.22341500472495224, 0.23574084971258025, 0.341324619347921, 0.3529146174009484, 0.48592214741416395, 0.47528088913491795, 0.36846207723855895, 0.4129527340166732, 0.25637665246609587, 0.4484921298564627, 0.4633290977934287, 0.793062858032236, 0.7645723934499477, 0.8249681746973477, 0.8007866871749167, 0.7831356072194804, 0.8324592769555561, 0.7881000306543259, 0.8032144785617517, 0.8208435510532427, 0.1866126494664453, 0.13930858123223477, 0.13868861690626166, 0.09052437253339574, 0.12321824449005436, 0.0916105271393719, 0.14100169080297742, 0.11394430574997838, 0.1378276728137573, 0.1995991090758028, 0.23615172142604846, 0.17608748444230238, 0.20703920941054088, 0.20452417005727885, 0.3401430572876306, 0.194007842939796, 0.20580556352062196, 0.19675718807906328, 0.2875589758310416, 0.37419237073548306, 0.299944577205003, 0.5148654807431324, 0.4144097375154284, 0.28903531742109145, 0.3052688677649328, 0.39947596981529865, 0.35763285902211894, 0.3203415415887013, 0.18436366371616109, 0.218726861095894, 0.19159802038043916, 0.2106611785128487, 0.2535604007336174, 0.2434208886223198, 0.2407691023488906, 0.19022672711013378, 0.2714532210278515, 0.24514602869889235, 0.29481151128107763, 0.27429811032230367, 0.2296644549416066, 0.2084307243547161, 0.24725903295098095, 0.28287724548972715, 0.2746848791683526, 0.18711950496590724, 0.17681979941617865, 0.1917715406958882, 0.1840564477076566, 0.20881351822669358, 0.19462899562657432, 0.17753134782174218, 0.22910549952147152, 0.19102840503524898, 0.9257841290748469, 0.18821069094253484, 0.17753540355130626, 0.9139379061414212, 0.19777414936460413, 0.13090190470950547, 0.1754409865695914, 0.16179623468362858, 0.14792870666081503, 0.9098673357197963, 0.21266830121444946, 0.2063208796680598, 0.8631680052440249, 0.21046745849468484, 0.15326602943053202, 0.885180665389434, 0.1660730313969503, 0.2128741627070474, 0.2229637036243366, 0.18465122843868298, 0.1934959183334053, 0.184941986970929, 0.184166480826345, 0.20043194238677842, 0.23501680080461618, 0.20438593333843835, 0.2252307806454683, 0.09959277608315242, 0.08885423316810537, 0.08014419742421341, 0.10977115844044072, 0.11119530689913648, 0.08078397956017214, 0.0837557754684487, 0.1267194151612222, 0.10205073473943616]}, "mutation_prompt": null}
{"id": "44d6dbdd-2e2f-40d7-ae75-6974ec05b316", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.05\n        self.stagnation_count = 0\n        self.max_stagnation = 12\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.5, 0.25]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A Dynamic Swarm Optimizer incorporating flexible mutation strategies and adaptive learning to enhance solution accuracy and convergence.", "configspace": "", "generation": 61, "fitness": 0.4501853084319202, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9021902323402491, 0.9148231564128876, 0.9137005232723338, 0.9112228976895502, 0.912232810851548, 0.9171493536812744, 0.9115707257709467, 0.9171857682980019, 0.9061153908653792, 0.8121263638382903, 0.8406587541186101, 0.8033056590630473, 0.8242331038265478, 0.8232118045210399, 0.8411277757622445, 0.8140729708431367, 0.834270596894693, 0.7775695569944556, 0.18569872897026662, 0.10846647329381542, 0.14051605900737596, 0.1578555413424796, 0.12490177201655484, 0.11053248895837098, 0.12258577205943033, 0.11816599068858591, 0.14602011752618926, 0.08400621312619128, 0.08343405398113879, 0.1619970898127101, 0.11531739355624304, 0.11250447491101245, 0.11388196002804163, 0.10842495911464645, 0.12246643303874483, 0.11007204524300362, 0.985850256484807, 0.9825285451067357, 0.9832406088198599, 0.9676879957282479, 0.9694881989613411, 0.9806258474603634, 0.9861438047743653, 0.9853704880491817, 0.9672100518256226, 0.7613694302672338, 0.7293135613467827, 0.7414304750422609, 0.7226515389739752, 0.7497272369666261, 0.7042303818097101, 0.7815656555359584, 0.7710954305385943, 0.783550305403099, 0.3896629393241513, 0.9047748658048134, 0.8467323823313613, 0.8989434580925209, 0.8211931484041268, 0.19223879629100216, 0.23781564642716602, 0.35581600425170845, 0.9087725639913837, 0.7595366720247309, 0.7348224945889136, 0.6749887043382679, 0.12950635005917543, 0.7033475644508274, 0.616625250712559, 0.6931214917057416, 0.6310030710673856, 0.13014702572648507, 0.7120543873425538, 0.6451570013661445, 0.6667701796136125, 0.7332405774546187, 0.6746743384580842, 0.6707636615304948, 0.7110917282324629, 0.7349841598062516, 0.6464092481530642, 0.14744319115111115, 0.3656867894873169, 0.4560238318888211, 0.35711929362430084, 0.45572915694774496, 0.5164177046394698, 0.14379416949777846, 0.5032666312371186, 0.692211537724394, 0.6645037024808189, 0.660431534139754, 0.71018219888309, 0.6521128956260094, 0.7329039092326513, 0.7118664721907804, 0.7668550514785113, 0.6026221631879765, 0.6731271022342893, 0.35774947539833, 0.11641348539258689, 0.3283915014367803, 0.3607099351471498, 0.3007263561809854, 0.40909279376962293, 0.2042079756859978, 0.19602662823719874, 0.653399584372437, 0.32678979448325784, 0.268022726141272, 0.3067133849452033, 0.353871397737765, 0.38900688375379355, 0.34293531588189785, 0.3937049255219064, 0.3420032515774172, 0.5483425309214691, 0.7742917026238347, 0.7640257611974846, 0.7970637177214307, 0.7221031560095397, 0.6743412747057377, 0.7899912246489581, 0.7986158982475628, 0.81925356025497, 0.7999102144755639, 0.12864354586863302, 0.12575659743879353, 0.10644640795709825, 0.10186511697623168, 0.10892343740168253, 0.09350101950014089, 0.11006692510191185, 0.14080347310136765, 0.1594759964572553, 0.19478115798087514, 0.17279579501475584, 0.14446319771381588, 0.17788730655775964, 0.3485240796376602, 0.19632689047843332, 0.20807385383417754, 0.25677687110877145, 0.2706319418508316, 0.4590225496357059, 0.41988849931208794, 0.37746087224355407, 0.4001037289247924, 0.24467105887315277, 0.5327696767013994, 0.5217769851420795, 0.3043013168954122, 0.22385149416608208, 0.17675074679213665, 0.1742794144056683, 0.37234841782528527, 0.3208329610255498, 0.46477312904343115, 0.3166332399831918, 0.297738204879586, 0.22261553674779722, 0.2346952883474167, 0.24467464415531703, 0.23934457107865192, 0.3248613838945612, 0.22897895293090986, 0.2493956763170445, 0.23402471946751136, 0.2567269674075551, 0.22983510090516335, 0.3124367110016276, 0.1940815128103517, 0.21016829568936668, 0.17877620731498278, 0.19196867639940907, 0.17589765951957448, 0.17869675178203215, 0.19606011069761675, 0.22556258749805524, 0.184998303830322, 0.9374119291088443, 0.18817074284094504, 0.16719187835521954, 0.19901568773434808, 0.19860891625142107, 0.1311694684289847, 0.14264653072731726, 0.1633170780676544, 0.9281334831514232, 0.9019741136902618, 0.21179558244662167, 0.8670620133658431, 0.2083908305282458, 0.8409263952936867, 0.8142311607710992, 0.12784474021465453, 0.9172964173940249, 0.21193704922091128, 0.2229637036243366, 0.1905659976826397, 0.19602369553479349, 0.1795065889772659, 0.1840769278706842, 0.2043006994581107, 0.19676090538458157, 0.2674070705108198, 0.21163582492868427, 0.10917942387416968, 0.08587728170474218, 0.11107111241308609, 0.10902999074670128, 0.11127423204030018, 0.08715390014876212, 0.0780408262401503, 0.09050802530867075, 0.1498905011446806]}, "mutation_prompt": null}
{"id": "28c1eed9-0d29-4c4d-9a7b-a1537af1a064", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]  # Adjusted strategy probabilities\n        self.adaptive_factor = 0.85  # Slightly modified adaptive factor\n        self.crossover_rate = 0.85  # Slightly modified crossover rate\n        self.memory = np.zeros((4, self.dim))  # Increased memory slots\n        self.diversity_threshold = 0.2  # Increased diversity threshold\n        self.stagnation_count = 0\n        self.max_stagnation = 15  # Increased stagnation threshold\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.2, 0.2, 0.6]\n        else:\n            self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9  # Increased adaptation\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A dynamic swarm optimizer that integrates adaptive strategies and diversity management for enhanced global search capabilities.", "configspace": "", "generation": 62, "fitness": 0.43614797641325015, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.31.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9041387318576535, 0.9228737668170359, 0.9174437963748019, 0.9111960771172717, 0.929106502947726, 0.9164835366133475, 0.9092124250333895, 0.9110224860058892, 0.9069022065528697, 0.8196027124891342, 0.827953478353628, 0.8605035989869283, 0.8235715448257352, 0.8390684602125369, 0.8479282696793331, 0.8094618750453572, 0.8355396442700985, 0.8508920286780227, 0.15762515814918043, 0.08735043546341681, 0.11564284884755849, 0.12912767253658042, 0.09112687167738498, 0.15951672310075227, 0.11531651826031397, 0.11863424930783006, 0.11077854179447533, 0.1603066008528896, 0.11643639784384319, 0.1440360664514294, 0.13349062107456122, 0.1147945912196261, 0.10185736924495925, 0.13012097258592326, 0.11120275696419535, 0.10248104816595771, 0.9785032394747905, 0.98265323260933, 0.9667536645278887, 0.9847360721919843, 0.9721013253510916, 0.9754043332538759, 0.9888628868142842, 0.9883618257855326, 0.983781414716959, 0.7234901394527468, 0.7402009499748798, 0.7441225148963463, 0.7749229381674065, 0.7613231623657628, 0.7405306560240432, 0.7834736922643055, 0.7304200502087999, 0.7467151382828773, 0.22244520653941313, 0.16976001849272437, 0.8153966459610595, 0.21205445130654832, 0.9341033177509288, 0.18897426134454698, 0.7850337137377196, 0.8357351119410664, 0.38872738425273634, 0.7297622107234647, 0.6164040043190375, 0.6398786596382682, 0.6454027450516562, 0.6705264207997137, 0.6916190129520907, 0.5929093797688585, 0.6808963484327526, 0.8337139207415223, 0.8090536113875828, 0.1361672104473044, 0.6558687240603818, 0.7204847177601184, 0.13502781635429584, 0.7263321554055998, 0.7497028882217658, 0.7343962102704367, 0.6890363276281182, 0.1965907149159556, 0.20270428830966492, 0.09943718454233186, 0.09281611683297364, 0.46118300877926865, 0.3885676354749298, 0.29118812189156285, 0.622039483524937, 0.21757800733155463, 0.6190338425430009, 0.6491758094758346, 0.3896829564339801, 0.6855234819795997, 0.4207364083904592, 0.7030942539014131, 0.5916672826571489, 0.6041764089491711, 0.7014625417584619, 0.11463106493717623, 0.10267993024740774, 0.13483957472251729, 0.2828046167491768, 0.22248830051013502, 0.45177100145477733, 0.29901549411917994, 0.2445433605600308, 0.5271158338390018, 0.3995107949424014, 0.3052522267963037, 0.22949999571718305, 0.4523810547770195, 0.4046432467675931, 0.47479058087909976, 0.3582191579282985, 0.25885695464535685, 0.4900687341150298, 0.7278292448350995, 0.7888042176342166, 0.7326237520086493, 0.8314436785934003, 0.6993996901109619, 0.6960319751900936, 0.8098141495236344, 0.7890463745580892, 0.8248509422077805, 0.1134504943280441, 0.10607917862015437, 0.10041183380653385, 0.08192429131033152, 0.05671578766536711, 0.11021125853008384, 0.1293766860370501, 0.09323649680940072, 0.11636406137606137, 0.20991358836763208, 0.21395092864027954, 0.15806549601790088, 0.25295568566453974, 0.20429162413979263, 0.1796285243947735, 0.3188706061940859, 0.2214720336951873, 0.2928567007109222, 0.29318289816338294, 0.3220206710794401, 0.27522134249941177, 0.41311120919332067, 0.3285273114230257, 0.4009536036072604, 0.23149318837524524, 0.4883576735894246, 0.4442392889658996, 0.2641387956148745, 0.24514437419287705, 0.2371667163332567, 0.23233610325373688, 0.30499184415087355, 0.28775877022118335, 0.2408194231701799, 0.2931125271672427, 0.14722285581989925, 0.2510956093509118, 0.30099198312140885, 0.3360223794867132, 0.25952943553635865, 0.20985367699557977, 0.2713153910489119, 0.21842695990233219, 0.24461851755576458, 0.22604063440386313, 0.18017879719170504, 0.21208792013013555, 0.22411327045159124, 0.17164945333638948, 0.1971392459884349, 0.2260600289412915, 0.20760450196007074, 0.18242336687826155, 0.19733305280988767, 0.18827033103970703, 0.9317330515647084, 0.1885708509260392, 0.17790727319315647, 0.20065873818346647, 0.19869001184207968, 0.1421248816293219, 0.16438522464142225, 0.9124969202516219, 0.9089637150156791, 0.8861468264361461, 0.8949141913107302, 0.8780090055813579, 0.16766568324271724, 0.12847266285194314, 0.15581242725283606, 0.9240330346654553, 0.9422552598947908, 0.1725519940288428, 0.19357367399027348, 0.17932166886243672, 0.1856391588425197, 0.2129176716550123, 0.1923117071115139, 0.21615762089991664, 0.23304762946152413, 0.2188680292111087, 0.10531662280824983, 0.08691565469059193, 0.0835696548052891, 0.07951811417986487, 0.0888528755532132, 0.07993325071394919, 0.09047682627508524, 0.08560404569638103, 0.07808872561868285]}, "mutation_prompt": null}
{"id": "95c56094-c7f3-41a5-b011-a0c964d6a9d5", "solution": "import numpy as np\n\nclass AdaptiveMemorySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.85\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.92\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemorySwarmOptimizer", "description": "A dynamically adaptive swarm optimizer leveraging memory-based diversity maintenance and adaptive strategy probabilities for robust convergence.", "configspace": "", "generation": 63, "fitness": 0.4221160669219782, "feedback": "The algorithm AdaptiveMemorySwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.8958984614994497, 0.9094835133847682, 0.920257297366059, 0.8999660319767919, 0.9088133674084196, 0.9234283028047883, 0.9048611193693625, 0.9073508503309199, 0.9124790995614382, 0.7938745365912312, 0.8175906955878645, 0.8181274301743293, 0.8059319268730976, 0.8020142449185699, 0.8090720839483725, 0.8267653860257469, 0.8098094264257159, 0.7992227290808089, 0.1416510382599515, 0.18430230674485093, 0.1593714100586503, 0.1812355625631462, 0.1354565722660327, 0.12184653353641228, 0.13041238062400484, 0.1437299213782548, 0.1423689298859121, 0.09193328282119617, 0.11507099552147537, 0.09238031854749573, 0.12799741375657925, 0.11453141868736716, 0.10710123131754812, 0.1193054577407574, 0.0901696775524159, 0.11333127989341374, 0.9794332296710296, 0.9750309144084331, 0.9773375166263896, 0.9888884532158903, 0.9823154786615544, 0.9834982773132768, 0.9852462187111415, 0.9817737312364777, 0.9848199480410785, 0.7133513546388704, 0.7338514202207052, 0.7086275106514908, 0.7042547251228277, 0.7430031337479688, 0.74688070296414, 0.77941688670336, 0.7598756516760272, 0.7649658201150533, 0.8524917400960914, 0.2432054089570559, 0.829041517147745, 0.2790648193391533, 0.9042236592260282, 0.8975088844602093, 0.9085122122330556, 0.23296414268584753, 0.3638864245721555, 0.6184364958460009, 0.6458943327188461, 0.1300475150263345, 0.43663796722402193, 0.7681821490357963, 0.668797008334463, 0.13101544761933714, 0.6502928451348637, 0.1337665921150487, 0.6644441712474967, 0.48362506141848083, 0.6267180874677419, 0.7957868204115958, 0.8150600685866796, 0.6297204247876718, 0.6452802662991222, 0.6207493354447369, 0.5559386176254095, 0.6026518020327285, 0.18265478658839351, 0.09186343876828962, 0.2784471186659847, 0.5381731785192767, 0.3389952657911486, 0.23614683346839815, 0.12558655948741793, 0.08024588753309325, 0.7124463245165786, 0.6648051275852012, 0.579467947474648, 0.6737464326327001, 0.7343971679754173, 0.6873475983312153, 0.6691803926643427, 0.6591661778506305, 0.7025831501330788, 0.40045646074913244, 0.2654174176468461, 0.09036410797732719, 0.4436250846713644, 0.3555757456585249, 0.14087246134607034, 0.3422651368308026, 0.15238427363526863, 0.14541363279373531, 0.3518745896529689, 0.31432109928198126, 0.3059121484971178, 0.2726701559409388, 0.4214531343096535, 0.4311088606201924, 0.39542734865602736, 0.5320429508008384, 0.3075496578735837, 0.8218107991466848, 0.6744233716758559, 0.7376901449091151, 0.8350639217769108, 0.8240710560571909, 0.7850967303103612, 0.7821380019155872, 0.7907911521390485, 0.792603939202188, 0.16029379234383268, 0.10787062061796993, 0.0980254682282693, 0.08363682162721198, 0.12469307345036118, 0.11021192327223417, 0.14030359845305662, 0.11968305791560474, 0.111242716170035, 0.14851895567162132, 0.22282484440891237, 0.21732846543553008, 0.17351116340944395, 0.19573191692928948, 0.21436537208923734, 0.2554457527312446, 0.14606310029512193, 0.29509708313512695, 0.46813689600702424, 0.49513134228599676, 0.46637542106865526, 0.32668183262770134, 0.5507182332878606, 0.2523314817899148, 0.44267536208937, 0.3922566576679313, 0.33380323087942776, 0.21053530715500857, 0.31925439238436104, 0.28986963448433, 0.2160265749462874, 0.22339844418458366, 0.15940209855884424, 0.21178609754779765, 0.2649235400940021, 0.19511035558225942, 0.23571750342823838, 0.2649870517789382, 0.22563152258465002, 0.2040415659054584, 0.2508688148377779, 0.208511208987334, 0.21562397227206398, 0.1976183755037183, 0.21307739861802943, 0.1743060019765711, 0.18072670712604122, 0.19413636579289972, 0.1908926833673532, 0.18065401994175878, 0.20932055788309267, 0.2097823056807573, 0.20818994754946885, 0.17355863856887022, 0.8961786442980854, 0.19551507577196614, 0.18881441562132928, 0.9229513881157363, 0.19902785527298006, 0.19713083389442276, 0.9330154242155193, 0.14227770519561922, 0.11480197615532362, 0.8957389105091654, 0.21245403337651647, 0.1263964546538795, 0.21104028226727656, 0.21125091315043765, 0.15565217468118275, 0.21310492465566477, 0.15333390014216042, 0.12806088523239234, 0.17581123605529936, 0.17645739055450194, 0.23146722589293278, 0.17782518651939294, 0.17986844776603084, 0.18534384799336123, 0.2344362946281493, 0.19682639961842874, 0.20678700789477167, 0.0877805292356757, 0.08290141179342769, 0.09143350930101546, 0.07710372122848053, 0.09079069110578297, 0.07482986505953737, 0.08597707966945944, 0.08823544051040078, 0.0842063051187446]}, "mutation_prompt": null}
{"id": "9b9722f8-d269-4367-9036-832dcb550a2f", "solution": "import numpy as np\n\nclass AdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.55, 0.25, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.55, 0.2]\n            else:\n                self.strategy_probs = [0.2, 0.3, 0.5]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold or self.stagnation_count > self.max_stagnation:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n            self.adaptive_factor *= 0.9\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveSwarmOptimizer", "description": "An adaptive swarm optimizer incorporating dynamic search strategies and diversity maintenance to balance exploration and exploitation.", "configspace": "", "generation": 64, "fitness": 0.46321800456434203, "feedback": "The algorithm AdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.32.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9292999190533107, 0.9361507351385968, 0.924779559874495, 0.9275422113176303, 0.9183879270699213, 0.9338289910737756, 0.9266194828657288, 0.9214738369439709, 0.9276007157829335, 0.8575285575565871, 0.8497452023074821, 0.8248209425899814, 0.8307258039354114, 0.8488021276578084, 0.8524466061125741, 0.82221984872987, 0.8446059492134128, 0.7975654310368177, 0.123540654690653, 0.0801736331021018, 0.14343296682317364, 0.1651434998146284, 0.12330280850329234, 0.16014960943463918, 0.14452473401370802, 0.16065409949589105, 0.12336066198505724, 0.09351043923006708, 0.13208678262398532, 0.08286589379427756, 0.1467843689506657, 0.06958290004341539, 0.13896316086203875, 0.11074629185797857, 0.10763098681489358, 0.14285364646002852, 0.9782899584251458, 0.9830035115218703, 0.9875936461541486, 0.986711898483214, 0.9722382925230634, 0.9798757264843674, 0.9735388506154343, 0.9896322024979866, 0.979835475908981, 0.7826936145778263, 0.8173742849929351, 0.784407654283577, 0.8310746376861958, 0.8048874413017577, 0.8168995744506751, 0.8094440769323763, 0.7948415343449642, 0.7927953678922808, 0.40026020529053286, 0.9259656257503129, 0.9230072953785015, 0.2137021691492924, 0.9423819309275262, 0.21061453421291687, 0.9200298949357493, 0.24856906275400703, 0.17626768658164693, 0.1349903211730219, 0.7494602600555644, 0.7483282296997262, 0.13363305247276858, 0.8315577978630628, 0.7438421949467092, 0.7179147068358755, 0.7503949703731677, 0.8065428053138701, 0.7759074098771532, 0.7926573491590946, 0.7212315562932969, 0.8092647585793235, 0.7197343714463758, 0.13509481503593723, 0.8603516912229348, 0.7767953896898782, 0.7223545761458452, 0.6343497581505023, 0.13289138315579463, 0.7546342834229063, 0.5375420395192609, 0.7169224556151961, 0.5687082693175669, 0.7437031935297195, 0.7549597923650676, 0.771197041685986, 0.3329514591677003, 0.7702601378745165, 0.7607494619967706, 0.7505932154058981, 0.5992614002133616, 0.7062753699074853, 0.76789441094562, 0.6916389823236508, 0.6570277015326745, 0.11253742176502457, 0.14028677075911256, 0.10051787879057883, 0.5885798717668882, 0.42318623784062925, 0.21427874947163117, 0.17812229171222205, 0.1515449516986782, 0.3538899130278673, 0.3500040315611028, 0.5438594991436472, 0.5222379188487736, 0.3834149833019268, 0.5045571421227193, 0.6419245471274826, 0.4627264756140135, 0.43596324984577783, 0.5723057854446103, 0.8650454090033846, 0.8623038505040512, 0.8606768477650381, 0.853760283993384, 0.8655096240222783, 0.7847321746913153, 0.7989230837258624, 0.8604372314011739, 0.8796830877922458, 0.08711892768924012, 0.11411741592209657, 0.1116103496421943, 0.14482529360800467, 0.0697454456947727, 0.18782054619113364, 0.18549862893231528, 0.08038225996831372, 0.08865001192643829, 0.31817241471836255, 0.3196470762312106, 0.6970315081115936, 0.18994951195825183, 0.19767606747257793, 0.1862521699404026, 0.1591384294318925, 0.14076896214711998, 0.17929548749330337, 0.28947668587496433, 0.3717372713488952, 0.37172079028211547, 0.5109625912119165, 0.38738132049494256, 0.3582918172644818, 0.3714964038570413, 0.49157994072584177, 0.6410090191493523, 0.30947143523920917, 0.2530580551487194, 0.24190744424048571, 0.2215439628009882, 0.25160790784646925, 0.3483044299667416, 0.24777132752665587, 0.30143267985455624, 0.22528494961530954, 0.24591236551753026, 0.23480670925054414, 0.25149739670494453, 0.31336687649349915, 0.23640389547173746, 0.23314835530199984, 0.23099981786168644, 0.21871511306691926, 0.2283609005864623, 0.18112104535544227, 0.198545301879283, 0.19047516031595524, 0.2022197998004076, 0.18823058433380324, 0.1845244362453935, 0.19241144483251482, 0.17515647857395633, 0.18868295008455582, 0.9522823161989723, 0.17729510600992393, 0.18765674317763725, 0.18823579386343403, 0.1982022429230036, 0.1662140493878853, 0.14182366744970532, 0.1725389387510342, 0.9072769664569453, 0.9034508286803107, 0.1686769632981846, 0.9022066130300399, 0.21265499742915372, 0.16839326133744925, 0.872693726382789, 0.21292273519727412, 0.21272095931205026, 0.1664708716343135, 0.17402568877091218, 0.18495721878796223, 0.18381061222812023, 0.18201470605271908, 0.17962955815601034, 0.17687029790545095, 0.20130046058375972, 0.18435228576304707, 0.190183928626669, 0.1224845595092735, 0.14067527416251702, 0.08280441486572598, 0.07848626341307374, 0.11993807484271057, 0.0916032035506209, 0.0948525944604589, 0.08167909697462605, 0.08537372964677448]}, "mutation_prompt": null}
{"id": "5323be06-9d87-48de-9ba4-06745e29f2d6", "solution": "import numpy as np\n\nclass HybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for better exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]  # Adjusted strategy probabilities\n        self.adaptive_factor = 0.85  # Increased adaptive factor\n        self.crossover_rate = 0.95  # Higher crossover rate\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))  # Initialized memory differently\n        self.diversity_threshold = 0.15  # Lowered threshold for diversity\n        self.stagnation_count = 0\n        self.max_stagnation = 15  # Increased max stagnation\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]  # Adjusted probabilities\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]  # Adjusted probabilities\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]  # Adjusted probabilities\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]  # Reset probabilities\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9  # Adjust adaptive factor differently\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridSwarmOptimizer", "description": "A hybrid swarm optimizer combining adaptive strategies and historical solutions to accelerate convergence and maintain diversity.", "configspace": "", "generation": 65, "fitness": 0.4544124851238487, "feedback": "The algorithm HybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.32.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.909272875037274, 0.9141805233727364, 0.9244550456348065, 0.931836757331733, 0.9162533032285567, 0.9124761716149294, 0.915560677136541, 0.9226383426872591, 0.921156963269982, 0.8405623095867183, 0.8105771633419332, 0.8179767259264372, 0.8095037273899527, 0.8542433633882416, 0.8259367847028507, 0.8123227817183892, 0.8151244192173721, 0.7694915184913531, 0.11432853112467378, 0.09090913489848085, 0.14055276410867246, 0.12337528351476668, 0.10070717375929072, 0.11132004221545266, 0.09275625910372731, 0.08925979202203294, 0.0895132809524255, 0.12850481719108553, 0.1246039211005816, 0.06623425946124883, 0.14266379978056098, 0.12146597744476317, 0.09190724188228083, 0.09497908337143524, 0.11667267085887212, 0.07163892780367132, 0.9811376490565973, 0.9890068244566232, 0.9828123107149377, 0.9861740696082628, 0.9734992199740438, 0.9693688110941937, 0.9856742419588101, 0.9844939857359164, 0.9855814645554236, 0.7727018756346951, 0.7444987151411893, 0.8034950390087884, 0.7890009962014575, 0.757322053020699, 0.7880821005509311, 0.8261612785533464, 0.802385094658698, 0.8207604871445089, 0.3623516892215821, 0.9129395181474149, 0.22673986830344373, 0.27975999097830817, 0.21166993721874827, 0.2820378981900178, 0.3352669639879369, 0.2329970470976872, 0.23193409419678668, 0.724834080754176, 0.7532775192520988, 0.7584836701986304, 0.7611166407272028, 0.825788123036425, 0.13093276310198032, 0.7228049759420252, 0.6291255970469494, 0.7677554657051626, 0.1272403853183236, 0.7729669974815647, 0.13503991442563534, 0.696935955863246, 0.780460456553504, 0.7462634286488563, 0.7116387228480194, 0.7265347508547608, 0.7608306703140654, 0.6959189777078206, 0.23093824189768597, 0.6861216640831296, 0.6997910716602784, 0.7385145062446803, 0.6376796466699439, 0.2510929209097035, 0.7548577686853482, 0.03325951896096646, 0.8086854165774627, 0.8409650674618208, 0.7800757125083199, 0.81020779421848, 0.7590471780735024, 0.7745267790796293, 0.809963448420322, 0.8562579920454175, 0.8145549806395932, 0.4569980737708622, 0.4271093079307424, 0.6588104608494961, 0.43832019001536937, 0.4434015083013384, 0.15728107708207284, 0.664905432425553, 0.2513480910990299, 0.40345600281320615, 0.43417617908950124, 0.29907336704043197, 0.4525607798697212, 0.23984618787437395, 0.723576864084039, 0.6261547975300094, 0.598477489328979, 0.53930580559815, 0.44828268390946635, 0.8678340134525881, 0.8379374582623127, 0.7782696226779521, 0.8358757065783149, 0.7675858344175346, 0.7135871591216607, 0.8528225596881563, 0.8640906286884404, 0.8442207867926985, 0.11547322322644593, 0.07817867513375898, 0.0664031509590759, 0.09979967584562222, 0.10115761231879683, 0.11812151836287121, 0.10486924260412944, 0.10806214717745621, 0.1535551005663226, 0.1894779194158055, 0.3608882068295838, 0.21846713707407817, 0.19365594037385192, 0.18395483207530683, 0.3987617905716546, 0.15108134631689996, 0.36278659464705054, 0.27612986741361567, 0.5088072631334544, 0.2808121386681315, 0.3510350751484237, 0.29678295597216586, 0.3278627024018921, 0.3095445047273372, 0.3108858915140693, 0.3415981676702169, 0.19845289198351834, 0.2562055252729719, 0.2364745882782876, 0.30747431586469665, 0.25437176278700024, 0.2257276640171455, 0.24252481702436857, 0.19986461726541094, 0.1561766171228106, 0.17250746892476176, 0.22361299530351453, 0.2193590365566883, 0.18644937660606464, 0.20166688443421277, 0.19807151358084052, 0.19638736760447584, 0.2234129214539382, 0.20551698856508993, 0.19154440892818447, 0.19726225363531458, 0.187057247088406, 0.18468255272362633, 0.19232394414316678, 0.20101447168266573, 0.18784934032990064, 0.18153753602234068, 0.1828949922484716, 0.18322025056865243, 0.9337700538178748, 0.8984507814493754, 0.15360003679242673, 0.17129054673702016, 0.19910360912744896, 0.15394969775654355, 0.9507666737434368, 0.8819099821616603, 0.8906873598802627, 0.9144653607512574, 0.2110915580849152, 0.12549494655830407, 0.15534210714520869, 0.1681783709712481, 0.16768871536771546, 0.09457666291322442, 0.8808763196117775, 0.12860270970429155, 0.1834530987707158, 0.1814299798978336, 0.18475013689245734, 0.19728610267909763, 0.18406652389697864, 0.19760722029789002, 0.21022025079298068, 0.22909931397676986, 0.230772867878822, 0.09630943665345715, 0.08291379279144617, 0.08786839241365596, 0.07701889629315883, 0.08706436500986436, 0.09061121974482012, 0.08540113421317252, 0.09541284781777015, 0.0775561737010072]}, "mutation_prompt": null}
{"id": "499c1855-cebe-43ef-a11a-21ec6c0f2f02", "solution": "import numpy as np\n\nclass ChaoticSwarmEnhancer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.6\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n        self.chaotic_sequence = self.init_chaotic_sequence(self.pop_size)\n\n    def init_chaotic_sequence(self, size):\n        return np.random.rand(size)\n\n    def update_chaotic_sequence(self):\n        self.chaotic_sequence = 4.0 * self.chaotic_sequence * (1.0 - self.chaotic_sequence)\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_random_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_random_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            random_target = self.population[np.random.randint(self.pop_size)]\n            mutant = random_target + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_random_1_bin':\n                self.strategy_probs = [0.2, 0.5, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n            self.update_chaotic_sequence()\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "ChaoticSwarmEnhancer", "description": "A hybrid adaptive swarm optimization using chaotic perturbations and memory-guided diversity control for enhanced global search performance.", "configspace": "", "generation": 66, "fitness": 0.4504691051559971, "feedback": "The algorithm ChaoticSwarmEnhancer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.31.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.910552975973395, 0.9094521855077103, 0.9144697029817195, 0.9134260786903071, 0.9067908362329651, 0.9027084179657778, 0.9121801276520413, 0.9110647581635536, 0.9139233727504861, 0.807415099160792, 0.8236090182806346, 0.8035710205685873, 0.8244327045161726, 0.8309074459712645, 0.8388492312520935, 0.8180357062431203, 0.8249516430507542, 0.7955343299308246, 0.16384660289737185, 0.10850632029326357, 0.1553110215063771, 0.1425327358200602, 0.16424717996911964, 0.14630577177881277, 0.13968987395255916, 0.6853619101848925, 0.13747679741900776, 0.07893320738695186, 0.09612541716018219, 0.15642105476211998, 0.14802536670955957, 0.11347976836512275, 0.13843140703191237, 0.10752688586680015, 0.14477816077651828, 0.12957266473096185, 0.9593472606821505, 0.9679229442020272, 0.9683760327847238, 0.9641616530611816, 0.9796977138908568, 0.9821699026477982, 0.9723632822096012, 0.989971745946222, 0.9881168445130009, 0.7643899276266909, 0.7548525370333898, 0.7706147616166947, 0.7415464163498038, 0.7268459373867874, 0.7522877749409626, 0.7650095014375398, 0.6832687420441017, 0.6401634689224559, 0.9272990552239666, 0.25345807759621286, 0.8348045189074402, 0.930053688558069, 0.83364194442052, 0.9209055249735523, 0.8751171453544561, 0.9317636909840492, 0.9102811054998085, 0.7960084115918503, 0.7274055054207866, 0.7590170198913031, 0.17001028068308555, 0.13429592578836202, 0.5602619286845807, 0.6072686120753514, 0.1348719692942998, 0.7768932607198793, 0.6844687559740781, 0.601370737633697, 0.5935057711318377, 0.7381200202959376, 0.6584679747717672, 0.6350951820624209, 0.6756447788315851, 0.6618791084274119, 0.48570218417310185, 0.0818246853962954, 0.17638292987807835, 0.35710799364148016, 0.5230496384529446, 0.643369165021588, 0.2680304171897857, 0.27255229316398344, 0.11543268776792082, 0.20607874694319206, 0.7540808497504753, 0.5432794051644084, 0.7170288337249097, 0.3449732357000016, 0.19270672473738282, 0.24205126645713737, 0.7266236971036295, 0.6981442564256866, 0.7138250675850066, 0.19703054775893325, 0.0989560572138698, 0.2205130431130391, 0.22796352512695717, 0.3467984744856566, 0.15586344135597008, 0.13320344923370742, 0.12633064919613812, 0.13629667682713675, 0.46838247981235326, 0.44927045587689085, 0.48338487160014143, 0.3736680732211324, 0.40948389992392353, 0.2971109145456676, 0.4638274088176312, 0.1709732510161882, 0.3306200259791694, 0.6864135717439239, 0.7418977663706954, 0.598392026542728, 0.8169717843338387, 0.6355375905356682, 0.7021531511501556, 0.8182471939764072, 0.8411102116958242, 0.8130376816695267, 0.15270471957159193, 0.11886836656754363, 0.14976109991890685, 0.14113770021515415, 0.12242039062468468, 0.1330707605855177, 0.1613523932645483, 0.18619621583940604, 0.11562773821640626, 0.21952810230337272, 0.2262523779529153, 0.20897858289466087, 0.23133165919373222, 0.18436339637545884, 0.19383344567953487, 0.33574843943689736, 0.18349141020388238, 0.1878115131163105, 0.2376014220998267, 0.3550217412614156, 0.4685727147969677, 0.41896062557498603, 0.4539837662108419, 0.5107575829941552, 0.4182905551072801, 0.6064742541414418, 0.5778395838144772, 0.16914636168850428, 0.4510940461183509, 0.26586053989184943, 0.36956415371363216, 0.4751738041783323, 0.3443225135448733, 0.25462483605032005, 0.2927570419930281, 0.21721975672713556, 0.23410951550148862, 0.2157930779351983, 0.24867127116202814, 0.2138077425356364, 0.21660478696514962, 0.22636256131156907, 0.2474100143445076, 0.2135123171126162, 0.20915238385030976, 0.22533381002111563, 0.19873921913045056, 0.18164773637031117, 0.22333348339750925, 0.2491050720612542, 0.22216709644840182, 0.2227017088371427, 0.2243969296478353, 0.21984775119877664, 0.1867362322863454, 0.14717432699517907, 0.15348533931689212, 0.9430855422167441, 0.20075561170788547, 0.19978643709246136, 0.14200835710766113, 0.16739035028460092, 0.8984394063002672, 0.9181616684497318, 0.21222578466510356, 0.9179558928293587, 0.9050033782821674, 0.893501807839333, 0.8888769092180853, 0.8541244401238371, 0.7447839494171964, 0.1046530331970078, 0.17484329685560274, 0.18609739354076704, 0.17911233020536688, 0.1956029759042438, 0.1918396620206536, 0.17260391862192626, 0.21781937582486655, 0.2386034578054339, 0.1976440642421161, 0.08833907804260999, 0.0997805926269475, 0.09555585936814659, 0.09433200752738846, 0.08654010640370102, 0.11969699314850146, 0.09029345811558653, 0.13086745399179067, 0.10402058742425346]}, "mutation_prompt": null}
{"id": "21555c55-3ac8-416a-b510-da719b27ad6a", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.45, 0.35, 0.2]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.45, 0.35, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridAdaptiveSwarmOptimizer", "description": "A hybrid adaptive swarm optimizer blending memory-guided exploration with non-linear population dynamics for enhanced robustness and convergence.", "configspace": "", "generation": 67, "fitness": 0.4307549525304546, "feedback": "The algorithm HybridAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9163078529474112, 0.9143364094335135, 0.8950155454242222, 0.9112683005978968, 0.9051901830062876, 0.9076882161289377, 0.9108350773821545, 0.9050653229116588, 0.8974113263556937, 0.8477646059344031, 0.8250442384920567, 0.8189277798858423, 0.8397501924869816, 0.8324924140301054, 0.8298014607900028, 0.8313779657999952, 0.8231771625645444, 0.789018567768088, 0.15958747085505343, 0.13992619742521661, 0.1460931314541718, 0.16955570031719214, 0.15883587571646818, 0.1706616037979809, 0.16301972416178945, 0.7113451311165322, 0.13958316551363625, 0.10882611938553288, 0.10391291691150817, 0.18057366796611773, 0.15910276381198707, 0.12848262606906824, 0.12168271088871274, 0.13036873318996656, 0.1223279268685501, 0.13889276683811713, 0.9869576919650443, 0.99074705524625, 0.9535334795719292, 0.9780374818425646, 0.9691691644282695, 0.9856692121398956, 0.9831843789175743, 0.9810100431133726, 0.9732317745688266, 0.6862238964789182, 0.7483677640888953, 0.7516004254172094, 0.7526068060995287, 0.6910876597040503, 0.7543348661348073, 0.7755362759452985, 0.785661755833842, 0.785225861784351, 0.9118912045130169, 0.3867088772407534, 0.22654086155692332, 0.27992299642869944, 0.8621488580888088, 0.8464663855519312, 0.2326625955039644, 0.8897237213879214, 0.23500230129484356, 0.13199828799844693, 0.6731272596287616, 0.7199670294237976, 0.13508916674904836, 0.13107953305516296, 0.13176677026275974, 0.41886900136121297, 0.6133643913820295, 0.5984011009522654, 0.5746977657737993, 0.6453483052165819, 0.1348914987406672, 0.7618356346071198, 0.6570044261572108, 0.6441132639232106, 0.5946042428640288, 0.647748349726781, 0.7424093935344578, 0.14012075719065797, 0.29205276697051075, 0.1392631943162711, 0.4632354014450073, 0.3112622264382714, 0.37500390151723395, 0.5860505148050081, 0.319966404245156, 0.5421379523924745, 0.6169905032899067, 0.5237504364607939, 0.5393924129607446, 0.536318078475353, 0.3664178919714499, 0.3175115866838689, 0.5593788835724133, 0.5962451855714429, 0.5004845848190805, 0.09114209500796022, 0.07098546128425554, 0.43365924086070273, 0.18165262638856072, 0.12318379606000451, 0.13711716134643281, 0.219441209400016, 0.13809984645962248, 0.11325442424122922, 0.3993721830409148, 0.34326187142590614, 0.38017207077230364, 0.32773030428621064, 0.406948217630124, 0.37306437769863987, 0.3097855674947697, 0.30949980040702363, 0.2855556826470047, 0.7128670737572074, 0.6749735817694535, 0.7159449220479536, 0.6015182179669047, 0.6832386522856086, 0.7415703033275403, 0.7317383337933037, 0.6920620367076442, 0.7412334526697324, 0.10272158895695616, 0.11761386410392494, 0.09968517641933305, 0.10990417745094672, 0.12916924845586486, 0.12572644421878298, 0.15557035424879528, 0.15957639504458854, 0.08741741637731903, 0.2801978344125773, 0.15473669790150812, 0.20058087525712376, 0.2719286328035271, 0.46884082267461147, 0.17460933898350506, 0.4681279364882692, 0.19063860302144564, 0.23561920138685988, 0.4009286237404768, 0.61077792855734, 0.4660341771220622, 0.3036905971882107, 0.3968649658628508, 0.38051217664777215, 0.480942306875655, 0.350612787459484, 0.4627365078956003, 0.3048416563960141, 0.3389014886655557, 0.2080151327953499, 0.2988372063952722, 0.26413465321218643, 0.198090644281678, 0.28434636053883355, 0.2993657257709691, 0.43267078919511337, 0.26826673102766185, 0.25353777216120266, 0.2629996877937144, 0.2060059666821077, 0.21213808560153613, 0.22894387715428266, 0.21947562156787248, 0.22849480053698945, 0.27438312678799026, 0.18684243004907086, 0.19015923344009722, 0.2233956144139475, 0.2528675469067829, 0.19185187187832875, 0.18743949144371108, 0.18971647762792931, 0.1906911549374608, 0.1832308401130035, 0.9362434815153553, 0.12284482431794208, 0.1527272799613606, 0.900108370074965, 0.9220098140499502, 0.1480542823152804, 0.9096137969284118, 0.9003024042182106, 0.8560965796735526, 0.9171111251704683, 0.8897435899540764, 0.20535556355258455, 0.21136437976857703, 0.2109088138177393, 0.16553871152546484, 0.8940904643965385, 0.16632283994721897, 0.15484933728651795, 0.189487931728879, 0.1776140934360796, 0.18378562238048002, 0.17896508141729262, 0.18555928357963802, 0.19264449175228815, 0.2419784385649949, 0.25542958344797795, 0.22049120617313878, 0.08324451832015078, 0.08909799338740954, 0.08364086735304666, 0.0836888162234849, 0.0857971634140029, 0.10701670761155979, 0.10963436003525184, 0.07868229069754873, 0.09014210731579753]}, "mutation_prompt": null}
{"id": "70413bcc-2077-42fd-944a-1cea31066a6f", "solution": "import numpy as np\n\nclass RefinedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 12\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedSwarmOptimizer", "description": "A refined adaptive swarm optimizer using probabilistic strategy selection and enhanced diversity management to improve convergence.", "configspace": "", "generation": 68, "fitness": 0.47520194325926124, "feedback": "The algorithm RefinedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.31.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9310972855681152, 0.9193868713510029, 0.903451111371435, 0.9222856494691404, 0.9217811056658223, 0.9150564314035582, 0.9190990585230727, 0.9303905684396478, 0.9177020860267981, 0.8447290688009462, 0.8555245392281576, 0.8472248751160206, 0.8443421972647112, 0.8391524509685825, 0.8559817877278031, 0.8351018899234204, 0.8341672340638249, 0.7876373236390048, 0.1867848478025268, 0.1151247035553341, 0.18569750253770922, 0.1802951090818491, 0.15513941678891174, 0.13298222074225907, 0.18332581934899983, 0.1420016369673589, 0.15140434311967332, 0.157571057222044, 0.06691651959460865, 0.09080826021337629, 0.1579369497552119, 0.15245510604477386, 0.10655079672052781, 0.11671475076549864, 0.1530731381067204, 0.11650645757315337, 0.9737898116124926, 0.9863882114769044, 0.9881787765736916, 0.9786162241882932, 0.9827633840749485, 0.9841544453067318, 0.9820797165900884, 0.9891469762040689, 0.9823541709089469, 0.7805758322509779, 0.8092656411050986, 0.7811435570117662, 0.8130401517590987, 0.7931188962748553, 0.7818057822930822, 0.7801479457385907, 0.5759248556728773, 0.8247744632273993, 0.8989293889300747, 0.8606904703666987, 0.22886620216810982, 0.940615624726081, 0.3873773356404431, 0.9208315911552394, 0.9217359327216068, 0.4052712730102408, 0.401777256577865, 0.7368095805559429, 0.7974997881731339, 0.6978661299746061, 0.7947571434205417, 0.738162477809293, 0.7390640161322551, 0.729773222937401, 0.7188093972380157, 0.7796828850259162, 0.785098958004064, 0.780506681212009, 0.7491174370820197, 0.8444227042763527, 0.7305975133634295, 0.7676734756882975, 0.7876241933942103, 0.7811214311686117, 0.7618040279862267, 0.2648786856881167, 0.16271936770002526, 0.6982905082489301, 0.6920022956508363, 0.622922683810061, 0.4774264267461821, 0.7756956678134711, 0.14474881880487644, 0.7888422096374819, 0.5643647534074265, 0.7598606024309222, 0.7180093284002708, 0.2930479286828498, 0.20825299632099892, 0.8051346700802751, 0.6518288139305453, 0.747365352071514, 0.8033258218891258, 0.443992684690356, 0.07214487926910496, 0.37458705240137324, 0.4691207612078929, 0.5650944194548397, 0.344932787352629, 0.1786179160811111, 0.23920149980931305, 0.3740282574414948, 0.3685263119272574, 0.41635088660073183, 0.4788041030767807, 0.5208099983745507, 0.5130527487427574, 0.5900101137849498, 0.4610015809622757, 0.49417963502003637, 0.33150990993748863, 0.866141727099005, 0.749850130300953, 0.8478526525912364, 0.7434761211609229, 0.8361802287922313, 0.8802063648918996, 0.8525343351102799, 0.8605034134805418, 0.8468775871544889, 0.10974124254303008, 0.10802980108872184, 0.11642915931306763, 0.15643936835005556, 0.15627951569310317, 0.10536565144087362, 0.11895003982458052, 0.1428359607003078, 0.11324352120249737, 0.7058512158523961, 0.3249293953685146, 0.2660266780024547, 0.18870619348813122, 0.14430173920286105, 0.1541331821313877, 0.18730018330345777, 0.13728565768739887, 0.32199693664310025, 0.3118521441318084, 0.24886424256647466, 0.4676427296208766, 0.5324491667862596, 0.440051032841278, 0.5525854753670196, 0.3542026895242846, 0.42288244326770263, 0.403079082127493, 0.1889490549740187, 0.33271819489429566, 0.2377447245804578, 0.2663179862866477, 0.19966836670312516, 0.2662994067650474, 0.25021809319313726, 0.3420562477738247, 0.20737799468441742, 0.2887268696806342, 0.2780508614540269, 0.29782439314677545, 0.23506700946875903, 0.2742115233935266, 0.2396302008703729, 0.23934417190166823, 0.24791989378153645, 0.23893058808891998, 0.2053818152928607, 0.17956580564112412, 0.18535871126990344, 0.20421859837779788, 0.1808847298441022, 0.19307568219334326, 0.24957520723308446, 0.1990735634006685, 0.19663508131413932, 0.9437785353394629, 0.1230643315379828, 0.18755414727037956, 0.18861160229971985, 0.16761978891566398, 0.16584138927293912, 0.9079475257774708, 0.16440455922919717, 0.14203383582932605, 0.9413306618641767, 0.21300067222316332, 0.9256295711263656, 0.21248629665168395, 0.16736080628929173, 0.886536671448399, 0.21346343405120716, 0.8788860868032295, 0.12809613867126413, 0.1939715592185346, 0.18706548562964065, 0.17955661685227786, 0.17094317885511046, 0.18528578283815045, 0.1872658783093477, 0.24649274182208458, 0.2466847544761961, 0.21183742470123035, 0.09441442011807744, 0.11035097785098147, 0.09320397953966653, 0.09367173295714637, 0.0880079864083213, 0.08393161312954034, 0.09053295757074009, 0.07779401259839869, 0.08122317271610924]}, "mutation_prompt": null}
{"id": "e720fe13-683f-4986-960a-d7b3387911cb", "solution": "import numpy as np\n\nclass DynamicAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = min(10 * dim, budget // 2)\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.1\n        self.diversity_increase_factor = 1.1\n        self.stagnation_count = 0\n        self.max_stagnation = 10\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.6, 0.2, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.6, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        diversity = self.diversity_measure()\n        if diversity < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim)) * self.diversity_increase_factor\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.95\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicAdaptiveSwarmOptimizer", "description": "A dynamic adaptive swarm optimizer leveraging a multi-faceted strategy adjustment and enhanced memory handling to improve convergence speed and robustness.", "configspace": "", "generation": 69, "fitness": 0.48450176070954487, "feedback": "The algorithm DynamicAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.32.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9356846921684595, 0.9218165395524246, 0.9263943653195037, 0.9181400980213549, 0.920050295560468, 0.9200071540138158, 0.9239514675169704, 0.924648704914293, 0.9152547156926618, 0.8331466310580901, 0.8443807695772261, 0.8410008157362197, 0.8513116767666074, 0.8561728820317873, 0.8466192101633843, 0.8230253415809354, 0.8321772448902812, 0.8089686651018756, 0.1314321699205, 0.15669768346922852, 0.13889071693240962, 0.14164594947630815, 0.1594063591721835, 0.15634341582676914, 0.11651337969059716, 0.14169728819977823, 0.1566106532609901, 0.13735928531826136, 0.09630976561602478, 0.08647327631247403, 0.08990066354109694, 0.12206899699542906, 0.11525079302438157, 0.12295099321540004, 0.09623029182763998, 0.10699079329277572, 0.9763062306938927, 0.9883498351585747, 0.9881787765736916, 0.9776280065376934, 0.9738454441536107, 0.9841639067809713, 0.9820797165900884, 0.9891744699619153, 0.986357703152909, 0.771231762122305, 0.7860879506763521, 0.7719716017108733, 0.8126046956153798, 0.8135010449250949, 0.7833147586686587, 0.8123263402719795, 0.8227213982342498, 0.8053670945108274, 0.9091118706686389, 0.2526787736091807, 0.2286293904201867, 0.9187213959562935, 0.22432159090247694, 0.8862306463242244, 0.40674785161748106, 0.9063131244003203, 0.2198604700152469, 0.7660992680313117, 0.7695412662757948, 0.697365015582263, 0.8097135030950784, 0.7724323264561805, 0.7353962378439629, 0.741253469231538, 0.734139425638629, 0.7861558779459772, 0.7493074912879245, 0.7363086307485975, 0.7674359185562063, 0.8412511923439275, 0.7524110131527039, 0.7705243577693996, 0.7945460368666186, 0.7726306228648018, 0.8074717145784764, 0.6784070667860547, 0.6089819988544627, 0.6935486121836196, 0.267586261561759, 0.71222311069592, 0.6425317023982007, 0.7491925551119962, 0.7230407061921084, 0.7647648735585731, 0.4189436984646334, 0.7190465127645342, 0.7964848738623536, 0.8048193480526968, 0.18286359545269992, 0.7855204380519435, 0.7706282204426861, 0.8030731872750521, 0.7186495637924605, 0.4951234024819482, 0.1798667525104496, 0.20317605260881977, 0.6147332098486552, 0.5340508552926834, 0.4366652852514089, 0.19227066699743456, 0.3963244990890973, 0.1986080921799347, 0.4190287224295739, 0.4358910983119284, 0.5614096503628525, 0.7057368408285868, 0.6089220069349198, 0.499462306005498, 0.5819705152277066, 0.4275986502588296, 0.5884047089026805, 0.8571571170494003, 0.8115214457260551, 0.8554617782075298, 0.8779239829276666, 0.8264685046691148, 0.8670535353173969, 0.8872464384920827, 0.8605738171249995, 0.85384984176955, 0.091386106185535, 0.09951724881319512, 0.10349872221041445, 0.1439187516243704, 0.11104909101777083, 0.13317366732623392, 0.14367403230821785, 0.11555851265693706, 0.15627967839677426, 0.19383040684398867, 0.24092142628058133, 0.14366963431862845, 0.2539401330396518, 0.2651556162207973, 0.48821213591810586, 0.2083737453837522, 0.14906653933081326, 0.2475059400866999, 0.2821592445553657, 0.4044303792259022, 0.46133248717763586, 0.2952166237750343, 0.33975767259713985, 0.4682822675885735, 0.38027616197448877, 0.31213669729737237, 0.46006249542321354, 0.17735770596514844, 0.2099739048083481, 0.2313038513969614, 0.25667176834640826, 0.36906551944470967, 0.26486448111807936, 0.48614646047894683, 0.30293170845407835, 0.17679493791666778, 0.28504123824535077, 0.2565293049811358, 0.2318468993695454, 0.21381296736962108, 0.2641237737786024, 0.2377387113509566, 0.22316755534415855, 0.22514683555047088, 0.2397660132421091, 0.20174418154432405, 0.18324903523327496, 0.18933795483519122, 0.20412025916714804, 0.19344962258770182, 0.1929190984291136, 0.17889005260208357, 0.1990075240567306, 0.19663127497387245, 0.9431964999402551, 0.9343355019230689, 0.15360474687228798, 0.18835659173525765, 0.19827839747201348, 0.16584148764987838, 0.17706073819008683, 0.1614274339226095, 0.14195715411379484, 0.9264545709049741, 0.21187031039555282, 0.9135542554728106, 0.21236278012728804, 0.16726569716371598, 0.8802688667586251, 0.21346714271383616, 0.8946863465095877, 0.9101279142898531, 0.17503706075630265, 0.19565480530684765, 0.1867956312232324, 0.2580971896194556, 0.1934574872245295, 0.19617917812934038, 0.19018833550299707, 0.20326836265103143, 0.207834239616982, 0.11341277004471251, 0.10373460720393757, 0.09319224810754023, 0.08568627967426001, 0.09928583440035177, 0.08882790636345295, 0.0891247985669208, 0.09454296599272383, 0.08578705296398026]}, "mutation_prompt": null}
{"id": "9952ff0e-b398-46de-a578-fbf2db07570c", "solution": "import numpy as np\n\nclass MultiStrategySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_2_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_2_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2 + x3 - x)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'target_to_best_2_bin':\n                self.strategy_probs = [0.25, 0.5, 0.25]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "MultiStrategySwarmOptimizer", "description": "A multi-strategy swarm optimizer leveraging adaptive diversity management and memory-guided exploration to improve convergence on complex landscapes.", "configspace": "", "generation": 70, "fitness": 0.4229978068140914, "feedback": "The algorithm MultiStrategySwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9347545064388945, 0.9225539879583791, 0.9208168160672058, 0.9199877132105961, 0.9133111597833914, 0.9280040947389586, 0.9311592993788864, 0.9185161151918744, 0.9199966678136351, 0.8367468974162322, 0.8645043709763841, 0.8355087027687271, 0.8523459669344675, 0.8400722824683429, 0.8597202694388352, 0.820373247820809, 0.8214704428213869, 0.786815385928961, 0.08665758322898198, 0.11890440502278032, 0.1330862125047002, 0.10532089196603156, 0.18429442681397346, 0.11079332036887246, 0.7521343757656926, 0.14688226624125722, 0.12467019332743146, 0.07971118462080218, 0.09963663643572596, 0.0774105131214281, 0.0866391682667087, 0.09444628292881951, 0.07966549957431801, 0.12327208109994625, 0.13267609474728725, 0.09886443115918642, 0.9610412810064005, 0.9894761868193473, 0.9673314977637024, 0.9779264977110906, 0.9587405882641727, 0.9879271624663417, 0.9840559548721881, 0.975099485291374, 0.9760897526701888, 0.7146450967833491, 0.7663480653851839, 0.7453834880756055, 0.7766316096512312, 0.7662275653040771, 0.7861732047168555, 0.5140553570705291, 0.5582785428120197, 0.7599241899480489, 0.8684805970467757, 0.22840457596710662, 0.7141140793271414, 0.2106302923894725, 0.3673357817891342, 0.20815982917507914, 0.22178139690195886, 0.23628816764282645, 0.9078190132534194, 0.6765044853549973, 0.8155550784182086, 0.7291422484252876, 0.12655467096912454, 0.8240266485987213, 0.6760578023085908, 0.7299593006390492, 0.6875744735956748, 0.13343983448507768, 0.716628241315902, 0.6641686840455516, 0.7641906643584335, 0.5358653649019572, 0.7448392701597932, 0.13628907807759083, 0.7096214438663386, 0.7138276245541104, 0.7116949976660402, 0.2061554651698303, 0.11588777029553599, 0.0873779572641391, 0.1024677391170955, 0.26196059521291726, 0.34606281910018544, 0.6204469829108519, 0.15540813428092093, 0.37791770324535723, 0.711719458713225, 0.5465744594314589, 0.6431195411767712, 0.7993857602673119, 0.6222653529040719, 0.3136075838664646, 0.520929616025253, 0.6057079197699498, 0.7789987621841962, 0.08706020871064102, 0.10843961788666912, 0.3260407349881661, 0.23945657974331125, 0.27203624190632447, 0.3471193785420462, 0.3019883320585304, 0.15517864683009996, 0.18552065177807242, 0.15826584431587776, 0.2773660110956043, 0.21697169467114152, 0.36192295371130945, 0.2442382397158649, 0.3555446756574826, 0.3118067022289348, 0.2365788621948054, 0.29735045421365747, 0.7959410528536657, 0.7079288091706277, 0.6371857367929841, 0.598874740281325, 0.6145857540714998, 0.7411432305224687, 0.8261371937548663, 0.8366772970303119, 0.8426828930392423, 0.10208824546259909, 0.10097586860328012, 0.08780528206236327, 0.1434164671164364, 0.14536606508194982, 0.11351232012411361, 0.1248415252201932, 0.16077749529131302, 0.07308696414276405, 0.1755355603030494, 0.44139383315050906, 0.2439928390936722, 0.15729667148285242, 0.16654703677484872, 0.2832771492969156, 0.18505931484204374, 0.17159286497399406, 0.5125497089602755, 0.31321989927204463, 0.37680942472185075, 0.35420902048571257, 0.22637455530490314, 0.4536650182713968, 0.30764046215436325, 0.24420260681873773, 0.4316740757879933, 0.21807916437800212, 0.21463046115223017, 0.23167280811287083, 0.31834920226236785, 0.34779497702075646, 0.3001514618566973, 0.24673053547930945, 0.2744646475362157, 0.31707353664871984, 0.30262207050036494, 0.31777066147603317, 0.24706442834628495, 0.2773005179631983, 0.22737610219685844, 0.20241286675779968, 0.3808743354297227, 0.32149828881468023, 0.1991073294086062, 0.2756772227174449, 0.19754187225178543, 0.19114433081165838, 0.19155585358345395, 0.2087798721031202, 0.1897217453034431, 0.18316396817879088, 0.1748753852678161, 0.17770489186678373, 0.18410218769986308, 0.9340618117036912, 0.18864959662471492, 0.15404982265434353, 0.1628721570704189, 0.19889544292738626, 0.19952512094546515, 0.1428463613275942, 0.19679684470047365, 0.16234879132599866, 0.8846994315351798, 0.16964428674378373, 0.8922166514390852, 0.8990104655312299, 0.8531706380552395, 0.8727145634024827, 0.9179169815536219, 0.15596428039493238, 0.15615501096645146, 0.18731656402443353, 0.18399056378814327, 0.17969750093905534, 0.1934627920139893, 0.18134543848726892, 0.1800190195253093, 0.21805001014551384, 0.21515092605600417, 0.22077558745684156, 0.07936049600726003, 0.12690135110172618, 0.09026492767474137, 0.09800589088572054, 0.10002110118883523, 0.09766017137861638, 0.09613782517015657, 0.08618807061574152, 0.08941995166119521]}, "mutation_prompt": null}
{"id": "ac2940be-372c-4586-90a5-69a8c1960b13", "solution": "import numpy as np\n\nclass DiversifiedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((4, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n        self.phase_shift = 0.1\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.5, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.phase_shift *= 1.1\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DiversifiedSwarmOptimizer", "description": "A diversified swarm optimizer with adaptive phase shifts for improved efficiency in complex landscapes.", "configspace": "", "generation": 71, "fitness": 0.42936926049570273, "feedback": "The algorithm DiversifiedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9055218664899528, 0.8919266874655634, 0.8990407576099598, 0.8974919475568655, 0.9020541563788416, 0.9025540549246303, 0.8989384946136852, 0.891522373729779, 0.8974212413063118, 0.790742823437468, 0.7903440934546667, 0.8008749536979662, 0.8127688143882607, 0.7938242554149457, 0.7883327803813591, 0.8047151406738047, 0.8000230580379462, 0.7895581729817163, 0.15613407664074386, 0.14235324295733442, 0.18615641000666205, 0.140643762196213, 0.6315293758106499, 0.1593885187323676, 0.16998817556374757, 0.14301738816691356, 0.1260428192153289, 0.11447073141087949, 0.13019529915516437, 0.11291679779182673, 0.15549979789546797, 0.1397598833104723, 0.11968373540640098, 0.12700384295473854, 0.11593448027850484, 0.11243981106608736, 0.9820353571885796, 0.9922914760065582, 0.9651907829174438, 0.9856737545872493, 0.9818902140056408, 0.9782341047332228, 0.9851696635748785, 0.9627370720011885, 0.9886250379071883, 0.6815873017562306, 0.6980298266541112, 0.6678181859551575, 0.673059332484808, 0.695517970431559, 0.6994936738497636, 0.7480746150671881, 0.6720942425097068, 0.6723001444475656, 0.7491522690984995, 0.2273231871687612, 0.8767398685542879, 0.2739062941974266, 0.7783462817803102, 0.21049813062829514, 0.23501762639430246, 0.8901001304349367, 0.3621830632535129, 0.6248644614648978, 0.6399282806729163, 0.5374415365829569, 0.1323336467235562, 0.7219440178327617, 0.6057642068042317, 0.13289458718217206, 0.5783939555349256, 0.5777844164075351, 0.6131534250918389, 0.6178860277308716, 0.5200186972190793, 0.5889539508642313, 0.5495442663248974, 0.5560137105249985, 0.6312834624009771, 0.6668970194545338, 0.6600392396176173, 0.14333484828400433, 0.28412281321285804, 0.07339581011242258, 0.4940039357834958, 0.37260418240146187, 0.4040975733782477, 0.17594223493677585, 0.21309644772749303, 0.3017389242077102, 0.49327314122957455, 0.5761481303038284, 0.5936708899408578, 0.6111522248205363, 0.2207178799020456, 0.1631248811572994, 0.6164004135321932, 0.6712528359890584, 0.5793598614765987, 0.34884837520794376, 0.1458812312437895, 0.26349835074391115, 0.2930596188096972, 0.1404194063519968, 0.11005364261651285, 0.20855410420557685, 0.14578944333554122, 0.12823250984786505, 0.27760087195278726, 0.37789375119753776, 0.3760502033413746, 0.38755734587075863, 0.33670736495359777, 0.29757770652929405, 0.26939956314161295, 0.33609805670030557, 0.448987458923388, 0.6696107930551547, 0.5887825385828006, 0.715769490705845, 0.7294662610563228, 0.7809737109347077, 0.7237647564449119, 0.7468193902664688, 0.7445986529799695, 0.7719098104433438, 0.11243696745880183, 0.14292183575945017, 0.13347141345484015, 0.1091582965963318, 0.10517227905998372, 0.12288124007846124, 0.1706423232166806, 0.11891923004113891, 0.13824907183408452, 0.29654398917983305, 0.23327502275635548, 0.16922388787421694, 0.2721108202727315, 0.17062290828276128, 0.22413865552809698, 0.16963294032785747, 0.17396191433378005, 0.1798653045030726, 0.49848367363440127, 0.27904065725050464, 0.4739830662911205, 0.4456055478739638, 0.5052409245932059, 0.32870537828130864, 0.51714635828773, 0.4212816705474598, 0.37722664866520217, 0.23711054878087312, 0.42382799523429227, 0.3481948968978009, 0.18825730007815744, 0.2785603127873212, 0.38241550859397155, 0.3373549283047387, 0.3261751171513799, 0.18594998001003393, 0.27933632687845933, 0.2841743115093097, 0.3286569625145126, 0.23429350428732587, 0.22068971502735624, 0.22077660940550858, 0.21160909311032916, 0.29382124499266604, 0.2566349383475597, 0.18712894170730054, 0.20739587929863534, 0.18003766163756485, 0.7897258705233139, 0.19001878749780932, 0.17924998301313066, 0.20328822668158342, 0.2221137112830519, 0.19624496701806715, 0.17818717373657122, 0.18796280119426112, 0.1864447940353814, 0.9215274952452804, 0.9068951798234401, 0.16495958690956192, 0.9054502404944764, 0.16231614072149347, 0.1580503995183471, 0.9017294544617751, 0.8835309704296834, 0.900626267802242, 0.8527172479367653, 0.8766104774822023, 0.15417015364831554, 0.21245516676099652, 0.21042366275923585, 0.9085612267739704, 0.18785516167964988, 0.18404031799699894, 0.19114517637985673, 0.19335397078014205, 0.17335135169138371, 0.1876407303034926, 0.22952611886273466, 0.2377492869364647, 0.2184373937204951, 0.08827552352821966, 0.08913241748449907, 0.08641140116392798, 0.09299497634558207, 0.08760472232668359, 0.09279240423663049, 0.09401136237794416, 0.09679237958635001, 0.07665800841521575]}, "mutation_prompt": null}
{"id": "09c1af64-f299-41d7-88a4-d634f8f35a1b", "solution": "import numpy as np\n\nclass StochasticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.05\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.2, 0.2, 0.6]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "StochasticSwarmOptimizer", "description": "A stochastic swarm optimizer with dynamic memory-based strategies and mutation adaptation to improve exploration and convergence.", "configspace": "", "generation": 72, "fitness": 0.4367166450299499, "feedback": "The algorithm StochasticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.31.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9284486844637001, 0.9435783318990116, 0.9400345450715766, 0.9325658643245165, 0.931843795266033, 0.941256763788419, 0.9316351420159035, 0.9444740388741579, 0.9409648323087995, 0.8632444257074178, 0.8315206323262001, 0.8640913224060102, 0.8644995140857025, 0.853646235779583, 0.8402002171746797, 0.8569066963492582, 0.8596486344824461, 0.8359497691952209, 0.14417160896926162, 0.14496830892886703, 0.18750944741800046, 0.1011896034746449, 0.1415788993472621, 0.15502245010891424, 0.09955102140132344, 0.14420914401379925, 0.1784601871846918, 0.1340553596013606, 0.1431974200370021, 0.10748010428767107, 0.11042239766112416, 0.09294279608992984, 0.13814194878843788, 0.14450066719158128, 0.13210828554412923, 0.130607121293134, 0.9834521081100037, 0.9839441753776135, 0.9882122888834457, 0.9826526043175031, 0.9805787993828328, 0.9733005573313537, 0.9831887120077584, 0.95701452437181, 0.9916575555831441, 0.8506252670876526, 0.8355037933314274, 0.8024155890740696, 0.8381941169932171, 0.847653792508964, 0.8290213437641952, 0.43967672470790964, 0.679519098130719, 0.7001519368382882, 0.9214449286537582, 0.22874754468944036, 0.22829778168592063, 0.2827152968369523, 0.8825482032008347, 0.9154494122664001, 0.24037174291144225, 0.948154424119055, 0.3472124383813898, 0.13663027092244306, 0.1370203426647586, 0.13491220086238576, 0.650947527298782, 0.6948297434626232, 0.18286893534616988, 0.727256123735127, 0.133763000823786, 0.8270365078818622, 0.7362697165978136, 0.7001176323653939, 0.7929291266578111, 0.7218001993071967, 0.793091902826584, 0.7613443409078678, 0.13640286455467232, 0.7797682554259769, 0.6894043120670867, 0.10440481822334946, 0.13860209309508065, 0.07339728562382553, 0.36694332429849064, 0.6044305135368606, 0.048787082120033354, 0.1656645778688064, 0.20176474978940895, 0.12014037720199244, 0.5294516510138135, 0.7309427661114177, 0.6839536433518635, 0.7873151513439075, 0.7524176863846606, 0.18730486149589132, 0.6942854137771574, 0.8082551174334861, 0.7618995205974828, 0.14585458167064502, 0.3457126793672022, 0.386714940502109, 0.39398786808653863, 0.5124599046130209, 0.45860363861969133, 0.2873618048529565, 0.31533179262255007, 0.18344626504389416, 0.5972430330983587, 0.5171602947108928, 0.4558253599282093, 0.29508308546216044, 0.4580805074101302, 0.5533618927735846, 0.39428186433241785, 0.47179328978396506, 0.5321387301987022, 0.6228679172190945, 0.6541579423503958, 0.7000193221477324, 0.808961008006585, 0.732154004045429, 0.6553119353400085, 0.8700681985639378, 0.8555412439933718, 0.8648558010523495, 0.12416033143997629, 0.11023554145736325, 0.13097769673147308, 0.11216333077759533, 0.08483242887621723, 0.0908130162774109, 0.18906106728228878, 0.14163978206027372, 0.1443409642322271, 0.23514546560624727, 0.16521014017134017, 0.2839089516325948, 0.22283311191672983, 0.19327022226211843, 0.17809747250983687, 0.19229307866445233, 0.2409462276070533, 0.20440441970276002, 0.2671573025560142, 0.4019323553708275, 0.3957040674355764, 0.6215440652087814, 0.5018513157219654, 0.38804870351159393, 0.5028229398653112, 0.6489110864239871, 0.34603812182018057, 0.24453780855148477, 0.28452516101433434, 0.2251571191681896, 0.40204874139344227, 0.22827834955434512, 0.3256317248154694, 0.2659730142827329, 0.27428965647806425, 0.2027992537357035, 0.2649355616015212, 0.24063396884846955, 0.3050560682147304, 0.26405632403450097, 0.2589837133992754, 0.26223464295507104, 0.2567077826113119, 0.2832063802950161, 0.2503076485619944, 0.20485359860651775, 0.19876266160464784, 0.1746033787600234, 0.19811186810531622, 0.23189997389227512, 0.2506297259606717, 0.2087917655190359, 0.20929469617341856, 0.18116057829242282, 0.18856957727591417, 0.18896960023694642, 0.15399353389434833, 0.2108219482820839, 0.9330079279435992, 0.20127199440377952, 0.14214529280292043, 0.16851209357236474, 0.21259461437742444, 0.9329425191583418, 0.21352933986129397, 0.9141324765516433, 0.20895793097402982, 0.16906470260291973, 0.8875545009863494, 0.8683350859440134, 0.1686033544201666, 0.210320133549865, 0.1858076042306872, 0.18937554037058413, 0.17097582401384204, 0.1807431265538133, 0.1899206895770571, 0.20794918437650312, 0.2292810706153292, 0.22296441094541808, 0.207845284301568, 0.08366880853363434, 0.14767333355641277, 0.12643834050472869, 0.117277169379011, 0.09207443740128074, 0.0912992026329652, 0.15881334186792195, 0.09962066589328422, 0.09886277114627251]}, "mutation_prompt": null}
{"id": "4ea7a679-d949-4fb7-ab1d-b57f18d06ba8", "solution": "import numpy as np\n\nclass AdaptiveMemoryEnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # slight increase in population size for better exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.85  # adjust adaptive factor for more exploration\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))  # expanded memory for better diversity\n        self.diversity_threshold = 0.15  # increased diversity threshold\n        self.stagnation_count = 0\n        self.max_stagnation = 12  # increased max stagnation tolerance\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.55, 0.25, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.55, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9  # further reduce the adaptive factor\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemoryEnhancedSwarmOptimizer", "description": "Adaptive Memory Enhanced Swarm Optimizer integrates dynamic memory updates and diversity-driven restart mechanisms for improved exploration and convergence.", "configspace": "", "generation": 73, "fitness": 0.46174858136246233, "feedback": "The algorithm AdaptiveMemoryEnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.31.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.895199577510571, 0.9038965317495683, 0.9028512910120016, 0.8932367121337476, 0.8921037065772344, 0.9121834625413927, 0.9048761814801894, 0.9059649581544212, 0.9062148189622306, 0.8011823711902304, 0.8106053340733881, 0.7700707750453841, 0.8032273298979847, 0.794172459268355, 0.820322137278929, 0.7964193693802614, 0.8073629455123269, 0.7840582462153274, 0.15584321126204814, 0.07760542883745603, 0.14139547615280168, 0.09834036759922293, 0.0850181460036945, 0.1750222531201574, 0.12212020968995452, 0.0984168292294274, 0.1201843935007244, 0.09492562722625475, 0.12242626659370415, 0.13113987376682146, 0.09281924837196676, 0.08871670659946818, 0.09317015533211492, 0.14896671574002174, 0.12180242251548445, 0.10796942094617556, 0.986341567192565, 0.9793308402155952, 0.9792859427615405, 0.9880163825355168, 0.9714865994893689, 0.9790628392971809, 0.9812945045404204, 0.9888903454077496, 0.9881900165597844, 0.7084261234073306, 0.739843125933821, 0.7390251274410564, 0.7355782367233981, 0.7289647378655755, 0.7193457204606344, 0.7696366109514453, 0.7912873760072181, 0.7843949606473101, 0.39453436406272857, 0.22808759824350322, 0.22803730142005008, 0.9230636399818961, 0.8536969738814492, 0.7989400082036688, 0.9085209034012148, 0.23309544173750674, 0.8898132855150279, 0.69312915299923, 0.6201419465105851, 0.6678941580448697, 0.12788973022699623, 0.6970183892321886, 0.6715785666326888, 0.6684438859083615, 0.7103380933685015, 0.7832451467569148, 0.700833408447981, 0.7109703266463385, 0.6792787033200631, 0.6897214124553455, 0.7211386595833347, 0.7302183522890374, 0.7583424163592016, 0.6130830708647594, 0.7704909943896237, 0.686818574514647, 0.6683280269493651, 0.3223797546979017, 0.5318079330698997, 0.6595074484646992, 0.6414588448539018, 0.6522320185262919, 0.7326587888906505, 0.7572023194366608, 0.7005322321357208, 0.7468056321066789, 0.6015789403296095, 0.7842273429216624, 0.6453307281528162, 0.7617927861652392, 0.7560146838460514, 0.744245935499606, 0.752723962417406, 0.09636117647952491, 0.14147408540751327, 0.5214272758667621, 0.42097116463641837, 0.17225689790132204, 0.17410019736634963, 0.4331059110934713, 0.18860852781326864, 0.3191463721315143, 0.40472292161997536, 0.2836704531706339, 0.5219687715507416, 0.5354047638605375, 0.4810253850891847, 0.5372291825560002, 0.4680226550820069, 0.2784568111793385, 0.5647791326586259, 0.8441444934249838, 0.827260021678967, 0.8421506308555909, 0.8443558537795265, 0.721715034964614, 0.7808810563687851, 0.8049213296061959, 0.8234592824550212, 0.8266061140580305, 0.09133915627155442, 0.08011984641876402, 0.11084738516635695, 0.15522045745601065, 0.13591698132158203, 0.13823723084683026, 0.10861105240624691, 0.18235166587877683, 0.15737189289145992, 0.22469688746356387, 0.1424159394656057, 0.15788046501330122, 0.20494801883411795, 0.1572625688350361, 0.24479129014039513, 0.21911231150773114, 0.22214088241685548, 0.24968603018568636, 0.38491469915249577, 0.3371371468756028, 0.5684071668139122, 0.3521984072667731, 0.2998181480593466, 0.3967492601353412, 0.4450889149512681, 0.4240541242696295, 0.2132614401732611, 0.36312611556531904, 0.37154714208046447, 0.255523200041593, 0.3235410800956522, 0.42035107006511885, 0.3065247183413714, 0.231417948348269, 0.3179358734101537, 0.16855131985934602, 0.3006512251727036, 0.23346477165110424, 0.28182476374080423, 0.22940343975034339, 0.20990317010310744, 0.27542613185702836, 0.249896897415394, 0.22567481395176037, 0.26131093792503846, 0.1690886654403737, 0.17411107813313742, 0.18871991539848776, 0.2136430598188146, 0.20113912838700498, 0.21029183376954064, 0.17653896864082708, 0.16524014718581315, 0.20875504354640317, 0.16528926883078743, 0.1869728515248691, 0.16865456992871264, 0.9204278597976824, 0.20006350100304304, 0.19867155117141744, 0.9297973372492545, 0.14170591935137822, 0.17133175993389338, 0.9094076809916045, 0.21049943151524853, 0.9000451724195394, 0.20788288991437853, 0.08258616970694688, 0.1663098404882547, 0.21221164119574054, 0.933959085058652, 0.9231640489118138, 0.1919361583131498, 0.19580680345400236, 0.1798850117232993, 0.18665154746235235, 0.19749271248793532, 0.21152024498485233, 0.1878006541173346, 0.21301715926683196, 0.20640804640689125, 0.08176951550898737, 0.08192759421634654, 0.0732795863881891, 0.08272343537124105, 0.1122764342863517, 0.09088643130420204, 0.08571716262232798, 0.07830464966764361, 0.09947861377890754]}, "mutation_prompt": null}
{"id": "2dab413e-9dc6-4c9d-9237-517b86be5065", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.2\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x) * (np.random.rand(self.dim) - 0.5)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.7, 0.15, 0.15]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.15, 0.7, 0.15]\n            else:\n                self.strategy_probs = [0.2, 0.2, 0.6]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMultiStrategyOptimizer", "description": "An adaptive multi-strategy optimization algorithm that dynamically adjusts its search strategies and convergence behavior based on population diversity and fitness improvement.", "configspace": "", "generation": 74, "fitness": 0.40900991289870264, "feedback": "The algorithm AdaptiveMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.734636179909149, 0.7333657073125385, 0.7233746376159413, 0.7364554944069568, 0.7377670187946914, 0.7365080992609876, 0.8960312482431704, 0.8953052699193561, 0.8696553202406848, 0.7725437598431234, 0.7188668457203766, 0.7495301020598877, 0.7913792671949745, 0.7701654309797139, 0.7510652498034129, 0.7500763527996064, 0.7672844620923526, 0.7729024791979966, 0.15624030111992593, 0.15572908141555786, 0.11593429249741927, 0.14199640309472128, 0.12645936363616161, 0.13904513984425648, 0.35501989637224474, 0.3848532231672923, 0.1495580290655134, 0.08373615740529416, 0.11251554264226382, 0.08673750138426262, 0.2529879281257239, 0.12386125742225051, 0.13626042591174758, 0.1836535031966351, 0.12153357834574219, 0.1118664114844451, 0.9915046864488373, 0.9894708952249941, 0.9877537718127053, 0.9881221465952065, 0.979931278777659, 0.9720722037903851, 0.9824485957086572, 0.9892553275785896, 0.9764858296673927, 0.39168213606692304, 0.3854704874066718, 0.38318977163198364, 0.395633442857071, 0.40141765171783717, 0.38319935661043747, 0.716226294228667, 0.7372358021151002, 0.6429165731337514, 0.7370485200085564, 0.7289953318461069, 0.7143038748812248, 0.6736507895011967, 0.763673624490777, 0.7689021264528032, 0.6542601286674636, 0.7449195275478796, 0.797175514341471, 0.43863364884768175, 0.41267648839463633, 0.4041259314729324, 0.6012546934333889, 0.683948764628065, 0.6720721171387911, 0.12520631495505952, 0.40331594408553084, 0.4661073581108882, 0.4231281605275482, 0.28836488276395034, 0.42299680847423593, 0.3624352484313824, 0.35788447944231916, 0.39227508260475064, 0.39161000824582604, 0.11919158257858742, 0.3611255409684875, 0.649602430615194, 0.6172686273190693, 0.6730341996979355, 0.3362079694099245, 0.3026414265809788, 0.30781165862839877, 0.7065170328093389, 0.7105619473448644, 0.6885037974114975, 0.4528870536195859, 0.39218385414012, 0.4142167724357386, 0.802048256671212, 0.7173771999002065, 0.7956549875346679, 0.44828594817350065, 0.4387554846817616, 0.40309359889031504, 0.1807895018632778, 0.13327809455453443, 0.08950897709464278, 0.14810860772906476, 0.2765634370118183, 0.5717121994672084, 0.10515961412872477, 0.09556952885241277, 0.12091652870000413, 0.25822862076578224, 0.24345253111819742, 0.2301714332991197, 0.40696240900629, 0.30194666151507377, 0.41362670500192944, 0.37654489835837857, 0.3442640973262635, 0.49394644458613735, 0.6743197599127386, 0.850017490995162, 0.7978917913251462, 0.8471720066197272, 0.6567252686096962, 0.8035594839675233, 0.5714115009984415, 0.5663443890169725, 0.5835270660243504, 0.10821091535094673, 0.10789508749885668, 0.12468971198570944, 0.11117709436598966, 0.1263387743612282, 0.10803901813402117, 0.13952388561746465, 0.13799796542705356, 0.11424219627832277, 0.31112403969327673, 0.16779335179351107, 0.24373623302098746, 0.36121150003555746, 0.21582818637311207, 0.17656354512687344, 0.3598420396056524, 0.25408725535998333, 0.1590610912909537, 0.42030307981176285, 0.33274879404347746, 0.379183695007449, 0.34802032026623564, 0.32551418794571707, 0.21096348581897628, 0.35927377180546305, 0.36186957165522604, 0.3410584736164626, 0.30008997405082527, 0.29331309212203105, 0.293115594899765, 0.2864140579095431, 0.28863603681444494, 0.3175614196070181, 0.30777084442462643, 0.3192924535009739, 0.2901368779320632, 0.26086382776223227, 0.2556162645908756, 0.2178667149387743, 0.20926279966037542, 0.2059235459506128, 0.1979830616838799, 0.21111164268746807, 0.19540540573856657, 0.21182508486852125, 0.17852171467512923, 0.18939635424582346, 0.21075741290458083, 0.4289608795108385, 0.21029654579957624, 0.19873638222569157, 0.22359872538816905, 0.4001689387333035, 0.5025997774532445, 0.16915821547187537, 0.17001700905350847, 0.15225301523926105, 0.18744939085295076, 0.1963842878397304, 0.19659218786762345, 0.9220636777446485, 0.1624661391356178, 0.9207375085229694, 0.8974304535495494, 0.2105070682714082, 0.1274829554397804, 0.15243129226898378, 0.7095548430064829, 0.7483299956529903, 0.21127650404471576, 0.9262379071623947, 0.10425802059497091, 0.18769586041084263, 0.17346287681552075, 0.18523158698604336, 0.1850609808503273, 0.18137589936473675, 0.17527573972390542, 0.2807130890515628, 0.21517141321862177, 0.20286230649177162, 0.07767593362368208, 0.08238747997242224, 0.08585214086440263, 0.0815019772552269, 0.08126705709174642, 0.07830697399623188, 0.08530995720916379, 0.08136452125939053, 0.08290121939176409]}, "mutation_prompt": null}
{"id": "4593a99c-9d47-4e08-a81f-8ed8800afbe9", "solution": "import numpy as np\n\nclass SynergisticSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.05\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "SynergisticSwarmOptimizer", "description": "A synergistic swarm optimizer utilizing adaptive learning and hybrid strategies for robust and efficient convergence.", "configspace": "", "generation": 75, "fitness": 0.45042883588959304, "feedback": "The algorithm SynergisticSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9088063844154927, 0.9165353283800332, 0.9131404893135814, 0.9241405043001991, 0.9146902178713581, 0.9037582609350346, 0.9190302402936403, 0.9156450730975406, 0.9047616539430813, 0.8396099041427639, 0.8334104598916099, 0.8369812145382005, 0.8337501459750405, 0.8421167561222795, 0.8512884452222513, 0.8460207176569035, 0.8342741250911001, 0.8100986091861861, 0.1564924933402677, 0.15842939888064433, 0.14447614566470002, 0.15890457296999305, 0.1512429141412902, 0.14278139041247317, 0.1521188869932255, 0.14187279549813703, 0.66540105174649, 0.09163957888198893, 0.14343708481871198, 0.109137484036955, 0.13770417512285005, 0.1437413495934161, 0.10689215346892378, 0.1301413300013834, 0.10772895323203646, 0.09513586248874994, 0.9765468794774027, 0.9852973207786653, 0.9791338100794388, 0.9784894753921922, 0.9837461980738837, 0.9791619276233752, 0.9751544745411439, 0.9878825079031766, 0.9773994186878376, 0.7635014403106191, 0.795620661124435, 0.7779712056047479, 0.7885901250671954, 0.7753546891836589, 0.7995696348405968, 0.7468457804980164, 0.8032870316699975, 0.7763391434199862, 0.22960514716925018, 0.9116794929803049, 0.8500338375951767, 0.28255066364096215, 0.2789130919560836, 0.2796659799523995, 0.8971275762287224, 0.3782941178707724, 0.23670479910766584, 0.6688874204291988, 0.7037027004851154, 0.8031102413597468, 0.6935967115541601, 0.7013201391986282, 0.13187590702376706, 0.7418730509339899, 0.7876657874897227, 0.701275285167982, 0.6195688968974103, 0.6788970271333412, 0.7758100110002016, 0.7420234005474649, 0.13463674100900969, 0.6691642451516899, 0.7478341103983634, 0.7444538827247789, 0.680801185450244, 0.4424689583005915, 0.10742460259739706, 0.33729038916484577, 0.167761330933196, 0.613505484239021, 0.6613591126493066, 0.3836297222859858, 0.268774231093061, 0.4791189985041945, 0.7425029949137425, 0.7125713146620443, 0.693747944873052, 0.7398457876600375, 0.7710037501229006, 0.7253639147044774, 0.7459364803214645, 0.6896988914440654, 0.7196423909431241, 0.09257530561839644, 0.07592197755222496, 0.5027039142472365, 0.5033460080809313, 0.3174316503349043, 0.3966507626509552, 0.2033574115147201, 0.32732734459795476, 0.25400798308925665, 0.43911961068006167, 0.5015757166940291, 0.5079256071660352, 0.32268409576678125, 0.4416089632502427, 0.44407653846182116, 0.4597430710552227, 0.36715243722933877, 0.3787251979413947, 0.8443801324473819, 0.7358862425784005, 0.7240340349073096, 0.7493624424786136, 0.7428582219945714, 0.7149289925983547, 0.8223031195656767, 0.8310479776397084, 0.854658339664856, 0.15509230648698868, 0.11093616670547868, 0.18007646716093473, 0.09123502014387452, 0.11925556347128308, 0.14207728984550527, 0.09252861030487125, 0.13473862335992903, 0.09071651375661605, 0.3324421031091238, 0.19906313766940564, 0.19032383599776426, 0.20243702741476732, 0.16660886169629407, 0.19090209130396585, 0.1683950019119631, 0.6820143127650109, 0.17030389471970175, 0.5446213156781496, 0.5574321781954445, 0.38533828195582986, 0.4622673521593905, 0.3073843194380874, 0.5852560356280694, 0.7593981574778828, 0.4035438175438689, 0.5673728724973263, 0.27416275036131643, 0.3536654785458764, 0.3136133403363659, 0.38229614825352964, 0.3551261882270317, 0.3250877043066329, 0.23268158272900352, 0.3539656863706985, 0.38939764327547555, 0.24516392984527557, 0.23998633077647946, 0.2627363323718066, 0.22605979951552158, 0.21163001146148752, 0.21988824891137881, 0.25011621028835784, 0.21426027561459182, 0.24019862854786844, 0.199352691925076, 0.21668503118285998, 0.1906034029050273, 0.22129067367149302, 0.201741006342124, 0.22345972587147478, 0.1979469854540703, 0.2013513286732046, 0.24981591759623312, 0.18848703852537885, 0.18809785718813898, 0.1859626658830016, 0.1706921082582501, 0.19966449491259286, 0.17834843185087923, 0.14210846359346574, 0.15283368158001065, 0.9420394598896922, 0.9262955288199285, 0.2117735782631912, 0.15590715368077657, 0.16775968183025747, 0.16885345908144667, 0.1566447244924455, 0.2103677143790439, 0.8859075305269678, 0.21292814112047997, 0.18634163570595974, 0.21261653881635179, 0.20799690170674046, 0.18615857049314044, 0.19027985629638078, 0.19159968358569857, 0.23808103705026806, 0.22312659448526484, 0.22377180133961383, 0.08848683073687225, 0.1059689737412427, 0.07498420914895454, 0.11665642645349528, 0.09540622925987097, 0.0853379092704658, 0.08665542899733814, 0.10410221096414041, 0.08300306284661241]}, "mutation_prompt": null}
{"id": "5497ac18-9b2a-41d8-9fc8-a38b605a3b51", "solution": "import numpy as np\n\nclass HybridDirectionalOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((4, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 12\n\n    def select_strategy(self):\n        return np.random.choice(['best_2_bin', 'target_to_best_2_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_2_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2 + x3 - self.best_solution)\n        elif strategy == 'target_to_best_2_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x + x1 - x2 + x3 - x)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_2_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_2_bin':\n                self.strategy_probs = [0.2, 0.5, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridDirectionalOptimizer", "description": "A hybrid optimizer that dynamically adapts mutation strategies with directional guidance from population memory to enhance exploration and exploitation balance.", "configspace": "", "generation": 76, "fitness": 0.3902823333288161, "feedback": "The algorithm HybridDirectionalOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.28.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.8786306144330036, 0.8695566505575238, 0.8815724857228623, 0.8607131889985391, 0.883896194969306, 0.8632889799221425, 0.8370548879038929, 0.902172199839705, 0.9021829985293702, 0.801216834005833, 0.7857744721158084, 0.5205189141933063, 0.777923506773518, 0.2772971448567392, 0.8001612543704573, 0.7945023664655478, 0.7693878700936354, 0.7560662759870093, 0.14403219831111969, 0.15406245738866398, 0.18475108603281853, 0.25040401856044603, 0.20358975001481472, 0.2894477749502907, 0.12144023926527092, 0.1537078281304064, 0.16123395917442462, 0.08964312262317309, 0.11911479000090952, 0.1282969543217971, 0.11579502155274601, 0.1420301282702201, 0.12725115438701995, 0.13032646830693173, 0.09804398348651977, 0.12185916149919618, 0.9621998775992733, 0.9527325846351429, 0.30539054778345354, 0.977833018311872, 0.9775714151556368, 0.9626049176444917, 0.9799282780552547, 0.9776372743317375, 0.9396548422455873, 0.6069770583100822, 0.6124539504093222, 0.6157087888122108, 0.5966977150475166, 0.5925543868097243, 0.5867694591543792, 0.28541505684330004, 0.26528356468064984, 0.28809498758242036, 0.9133888939615427, 0.8842377233489358, 0.8224779128837161, 0.8327415990508615, 0.2777152851349418, 0.27489440037470125, 0.7923223969688497, 0.23134115341531147, 0.8881675776521789, 0.6520852164272997, 0.13437674279513134, 0.12557878465644312, 0.16424449958484033, 0.179436290778776, 0.38015033345807137, 0.37757243914413263, 0.5706382994434887, 0.4477173822218514, 0.6224973310370725, 0.5101482514724591, 0.4590727617534678, 0.5692027380579474, 0.4666007850725301, 0.5235109478344934, 0.5549814934317662, 0.5482825473301252, 0.5430340829024547, 0.15681084780470644, 0.08937583205428423, 0.09037855985330623, 0.38555142054680414, 0.46396825162488553, 0.4493402419173479, 0.09780481702290711, 0.06130094704266542, 0.019834087079366847, 0.6051960897954902, 0.568387556762805, 0.6215039128205584, 0.23906370242707375, 0.5680466002663969, 0.24147689777211312, 0.6894595557388421, 0.6017914967504683, 0.6049839506648003, 0.1092416627450491, 0.06262566829191962, 0.18195121666546255, 0.09446186257526334, 0.11572852924759935, 0.14612945364033003, 0.15685609218397, 0.14077988879702696, 0.22043961662565303, 0.3806666329481312, 0.3803173809860697, 0.32544464726879585, 0.18874078661571558, 0.12816270527641516, 0.15835505240634606, 0.19222166911419236, 0.15687173649637864, 0.09216653220948046, 0.6710753974305272, 0.6235693288033157, 0.8353006329447215, 0.4739821483631317, 0.6082892176828077, 0.5140886301929766, 0.7435926398237738, 0.7754865975588496, 0.7847388394748597, 0.11345941711526053, 0.11292663885413678, 0.12574050855104835, 0.11509297516836792, 0.15041904667264283, 0.14717170768693755, 0.1291447821281808, 0.15259620357473902, 0.1406291565536827, 0.15507042822759087, 0.16948888841966359, 0.16230850160686627, 0.20836881620854442, 0.26030114512076863, 0.23211166255182392, 0.20303196616552888, 0.16356437384565048, 0.17827285027001794, 0.378202435690678, 0.44679125132629816, 0.5608154531250075, 0.43592847720821093, 0.42846826092124235, 0.5126053770160846, 0.5724041384251757, 0.5105816895652179, 0.5582973258210032, 0.33135434989581714, 0.27972070609496924, 0.32666783160327706, 0.3331382684781419, 0.27585752724864987, 0.2947379682796797, 0.2429044180344594, 0.2664188786518752, 0.22880945927799035, 0.23940702564786365, 0.21550487411302544, 0.29981843819856935, 0.22245560502361295, 0.23741141594451898, 0.24478785378731138, 0.24139571270243865, 0.2284924520777326, 0.22245332921866345, 0.17352491325946962, 0.1845156230810534, 0.18726716469371496, 0.19937976403976565, 0.19590288466761752, 0.20517754689208534, 0.5489145046374322, 0.18699714468119544, 0.19590650474497173, 0.8922671001292632, 0.18843759408495786, 0.1866191322819568, 0.913086137048337, 0.1964240549713604, 0.19754151908302298, 0.16778365259703587, 0.16750863030866892, 0.8741656421726702, 0.6913585725930866, 0.6951965239004514, 0.5074179683826535, 0.20944988244181395, 0.8064720486584317, 0.7541256580952319, 0.11246361167026975, 0.9170881171921693, 0.16379391257912235, 0.1914340294003457, 0.18123133337027997, 0.18443795872678137, 0.17979831376850375, 0.1890980606070609, 0.18387652723561765, 0.2243149317291525, 0.19343228314972016, 0.22945237408030994, 0.1015647539106872, 0.0896910857548543, 0.08890536551947303, 0.09709350302510988, 0.08499662091032512, 0.08339021315328976, 0.09114414289997586, 0.08855259480084421, 0.1002226420611736]}, "mutation_prompt": null}
{"id": "11c4afca-ea8c-4fa2-b71f-bb5e1ef338d2", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.1\n        self.stagnation_count = 0\n        self.max_stagnation = 8  # Adjusted\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2) * np.random.rand()  # Random scaling factor\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.5, 0.25]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.45, 0.35, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9  # Adjusted\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A dynamic swarm optimizer with adaptive memory and mutation scaling for improved exploration-exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.4212298560805222, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.33.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9546650260976343, 0.943262622092996, 0.9493535699664024, 0.9467913633833155, 0.947958390155458, 0.9430679799195502, 0.9511954036169568, 0.9539110014727438, 0.9549406836843263, 0.8654689722651655, 0.8868267327032896, 0.8641346746361454, 0.8786106708115542, 0.8833859196498649, 0.8862981822864399, 0.8854333247981953, 0.8635726140839443, 0.8908368268689186, 0.19290713358564904, 0.07325088568142224, 0.12797200703212075, 0.09376077893214607, 0.09840457715101114, 0.10581020541854902, 0.13475972380676304, 0.12010070218984714, 0.14840190757804883, 0.09810290018604972, 0.10073582485162913, 0.07245029993637087, 0.1263255273426095, 0.08628921924655975, 0.11133872305126824, 0.08031929224260859, 0.11154891484803597, 0.057575816941127456, 0.9862940006814302, 0.9900757274720189, 0.9887507882668721, 0.9815900027117135, 0.9841528359594092, 0.9830749575751795, 0.9898882851495139, 0.9640775986673545, 0.9852893145295496, 0.8417635814634845, 0.8411536966859214, 0.8285639063161585, 0.8627403267987208, 0.8520949944734104, 0.8734592823184392, 0.8806658418223644, 0.8680803169800144, 0.8665981008681292, 0.9364389032800954, 0.9279799555494833, 0.21719841205085977, 0.2158370438713586, 0.33904419953903675, 0.19455219202282692, 0.13108121133667316, 0.17882248765566788, 0.22467387236142167, 0.859904454470563, 0.8673837636623749, 0.8515931054032753, 0.5810582316952957, 0.8053324159057983, 0.8195936221470249, 0.7904833222740808, 0.7338474025579091, 0.7749656259494971, 0.7723122993190569, 0.7788501315771867, 0.7993940612528019, 0.8086114884616817, 0.8630774194514325, 0.13824191291117205, 0.13762342913450865, 0.7135659973412503, 0.8116805721737306, 0.11258612275927049, 0.13867989740587527, 0.10081825323043814, 0.09308219307244203, 0.03216487803996493, 0.49169129424307634, 0.13566641858944783, 0.15154962966154706, 0.2549045305871832, 0.20560778854161876, 0.4004850746161144, 0.3781697093356795, 0.6112729360790191, 0.029640746864695755, 0.17429890016868088, 0.08080479766046633, 0.36612481142617426, 0.12113258018442485, 0.5102833519087995, 0.2534402493350909, 0.16336475270355788, 0.39204009069074786, 0.5035673714840989, 0.5148345918705117, 0.420737211124371, 0.31242975259391637, 0.21174041717639003, 0.3007060698642924, 0.16980017573540118, 0.3135832601449331, 0.3767325592988263, 0.3215408488067931, 0.30514951964965886, 0.18305416809414377, 0.4595995009206335, 0.2153176142853409, 0.8735572441705894, 0.7218539141347946, 0.7973397065263386, 0.9175277490718433, 0.6927998527968142, 0.919815723941789, 0.817245862123581, 0.8856466892666789, 0.9138611883759736, 0.1014259045248922, 0.14692778532437312, 0.11370539085405029, 0.12042393546203745, 0.08607028475894418, 0.11253716092417343, 0.11267351379749002, 0.11358384787958387, 0.06705421613101481, 0.14659226577190454, 0.14140234543515728, 0.16388370294823285, 0.21724901435090782, 0.2083341934689793, 0.16635836037531793, 0.25060674713030273, 0.14850665237982852, 0.17395793175288965, 0.3818298248166011, 0.26547627661664985, 0.32977934125073993, 0.2983861869707939, 0.31522837524631064, 0.22287784315083337, 0.3285837812135195, 0.2579834096251158, 0.28076565052632774, 0.22772789884315803, 0.26157022321340995, 0.25225331706070453, 0.23501814662349618, 0.2259599001139584, 0.2752467646964375, 0.1746242982062447, 0.2936399107817421, 0.22250953943553942, 0.23021973863569212, 0.3182762597414579, 0.2362736968013207, 0.29516921201197266, 0.33243753461276626, 0.2717951708147952, 0.2664822372907609, 0.30944340338063026, 0.3023983943414783, 0.18211478920273383, 0.17668404793901193, 0.1873149718444449, 0.21142891301363786, 0.19001946608978826, 0.17386571153702002, 0.17445275676666638, 0.1739875274287288, 0.20055795297418755, 0.958183831601928, 0.1891788059123911, 0.15455262242989753, 0.9689095223917248, 0.20205285868546585, 0.2012451117562638, 0.14329507596662605, 0.1647730135229405, 0.95134897008046, 0.9570537867734081, 0.21331147796602568, 0.15745475079240956, 0.9328104961516317, 0.16866820343561373, 0.1557565220872772, 0.21413125865181515, 0.1550659877472037, 0.8866789045697179, 0.22257259726003098, 0.26009254916451374, 0.2186900065562808, 0.2620659044034951, 0.19775670933422085, 0.2591748147137781, 0.18554321497699056, 0.25934102243896606, 0.222730482568409, 0.0928878087508681, 0.07986151480909487, 0.10338744219630591, 0.10602440820238301, 0.10917116283257622, 0.06660317264649018, 0.10343377848295199, 0.11529122775458223, 0.09539468051680322]}, "mutation_prompt": null}
{"id": "900e8a8d-0f19-492e-b8ce-f42a8484387b", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.2\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.2, 0.3, 0.5]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness.fill(np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.92\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveHybridOptimizer", "description": "An adaptive hybrid optimizer combining memory-based strategies and dynamic adjustment mechanisms to maintain diversity and enhance convergence.", "configspace": "", "generation": 78, "fitness": 0.4308406771117299, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9301983108971422, 0.9168421489851034, 0.9158276606936812, 0.9105586482682071, 0.9122080022024687, 0.9145461080555901, 0.927389670979566, 0.921328835943823, 0.912657323938046, 0.8474485087692272, 0.8521719590505421, 0.8338794044892293, 0.8295979949474334, 0.8524184088294195, 0.8408268777245186, 0.8307209555203844, 0.8419213194721422, 0.795013442776402, 0.11262808686113535, 0.1224770041503449, 0.12359077201808466, 0.13294476749293227, 0.13385511244410753, 0.15910427665035076, 0.11072064125342418, 0.09623527485399752, 0.0717450708839924, 0.11016878734967073, 0.10847952926239046, 0.10627182266933777, 0.1175161671351801, 0.09556274038284807, 0.0805100405414052, 0.14191594993779544, 0.16042174717018665, 0.10129238463555157, 0.9715758744910725, 0.9878682218315533, 0.9869318902970139, 0.987037379445969, 0.9893290163838518, 0.9721138277313454, 0.9751475334665853, 0.9896368751700393, 0.9528281029610502, 0.7344561956968141, 0.7722033200121486, 0.7371666746993987, 0.774919914016883, 0.7874841487985629, 0.7536635131690108, 0.8238997363564169, 0.7224269747751089, 0.6111714174084906, 0.3961085551884501, 0.6738251386866144, 0.2280039891652924, 0.2804196546050961, 0.21332149473188855, 0.17632375018956903, 0.23289219834483255, 0.9488134320527609, 0.17409487781769128, 0.740299332704813, 0.6458954373865405, 0.7697216340508817, 0.7534649321251143, 0.6296896340015898, 0.7380690080253863, 0.6869222322556688, 0.6420103104212795, 0.771766722375054, 0.6632989362161757, 0.7215482333954368, 0.6959079731250746, 0.753073314714633, 0.7331524956378028, 0.6073902458541711, 0.802368976306306, 0.7164923493239251, 0.67822963159792, 0.2558048222004683, 0.16193042560378124, 0.07620769799241611, 0.6138164040415486, 0.5212893038680763, 0.17271297903774774, 0.39822911026877705, 0.23617589082257917, 0.36443358774229173, 0.6670335821569862, 0.7462081611791179, 0.653554391858184, 0.24771163050376765, 0.5826035880037173, 0.7116891204082669, 0.6883242249229369, 0.446607972458282, 0.6015575686814321, 0.0843548026598826, 0.0724270542869262, 0.22788959107483675, 0.4229442846356707, 0.5564005314504744, 0.7253853307799836, 0.2797268374501327, 0.17058577136942965, 0.1931089384945588, 0.44051172373269876, 0.288852276652543, 0.4786543576328516, 0.3743996648307246, 0.27323847077218655, 0.3629844312433276, 0.35033869179149546, 0.4237874920715261, 0.5292718109861523, 0.7322195315219413, 0.7703656651431351, 0.848131414454798, 0.7302163710243914, 0.718346088299233, 0.6958393916311395, 0.7824161525765034, 0.7797154734580265, 0.80941911112693, 0.11873701275715398, 0.11600840140832824, 0.1578037654045824, 0.090008151589829, 0.07504428263198948, 0.08636624291878903, 0.07068604705986958, 0.07023212121156464, 0.0844748982870327, 0.2627392000258031, 0.17285221625330216, 0.2559502977369077, 0.2756827216217089, 0.3280156743925553, 0.3212112129653677, 0.22150647624125297, 0.1954542865619212, 0.24981768958910167, 0.480849186265762, 0.3042981744693428, 0.336553915948002, 0.4296136298958029, 0.2854704184912962, 0.3610001642834034, 0.23964267957905727, 0.330342815438996, 0.21741030132368844, 0.413810621658657, 0.21873476980343498, 0.4317247051664729, 0.1419259277525562, 0.23010269759418422, 0.32089435966230007, 0.25225858049205063, 0.19886384274183933, 0.1814759631702647, 0.28911619910349096, 0.3084706455018348, 0.28832712600925303, 0.364991577487377, 0.22276727317303313, 0.25062396375830176, 0.36089500022619014, 0.19830213192323765, 0.3534282180645473, 0.25145304895883247, 0.18469301577390962, 0.18396452608865377, 0.17979444708713943, 0.22343052408269004, 0.20998367043430421, 0.18635563286705115, 0.20079633161438382, 0.18639286438928326, 0.9431836863059911, 0.17702174742174537, 0.18822544100147565, 0.1621414530318951, 0.19933503959210197, 0.16653354242488494, 0.9445549418891606, 0.9042960199104336, 0.13583130634503138, 0.8630825165101699, 0.16809086235930992, 0.07340209820512811, 0.21330037526129242, 0.8967780869161387, 0.1558917250800932, 0.21304705342232177, 0.21262644077241943, 0.1554827706354983, 0.18284905894746573, 0.17787723421941204, 0.19464666694601274, 0.1952629025564897, 0.19291875059467622, 0.1908572805905252, 0.20629048839917719, 0.20820145107065435, 0.20150156950542586, 0.08921236927758491, 0.07766999342693615, 0.08087501824259125, 0.0813531418806821, 0.08329548978704227, 0.16270208747531856, 0.0871399900127593, 0.07637849980291123, 0.08699692022640215]}, "mutation_prompt": null}
{"id": "92d2cc88-6bcb-4d51-b2b2-18a8d512e5bc", "solution": "import numpy as np\n\nclass AdaptivePopulationRestartSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.1\n        self.stagnation_count = 0\n        self.max_stagnation = 10\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.6, 0.2, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.6, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.95\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptivePopulationRestartSwarmOptimizer", "description": "Adaptive Population Restart Swarm Optimizer with dynamic strategy balancing for enhanced exploration and exploitation.", "configspace": "", "generation": 79, "fitness": 0.495415034136322, "feedback": "The algorithm AdaptivePopulationRestartSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.32.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9387046178558623, 0.9110506739435561, 0.9260535772909955, 0.9198919524457958, 0.9255756902776957, 0.9202358110363618, 0.9253671189028256, 0.9258263688975289, 0.9210126937048699, 0.8257799288964567, 0.8369064066122132, 0.8430181409565023, 0.8421496766716201, 0.8501666857120501, 0.8464769372416354, 0.8343336611623753, 0.812798184860043, 0.7883964507683028, 0.09709154793530506, 0.1100631467003641, 0.14338050152627368, 0.1595841490297507, 0.161521098596638, 0.16344702374134834, 0.15640085965945927, 0.15858604486346506, 0.1436048482249178, 0.12237684947145988, 0.11088601576157575, 0.09351418010894175, 0.11098794486399333, 0.10071334912148266, 0.15730218559860354, 0.18492293906763213, 0.15778750006733522, 0.14453222153075107, 0.9762731285663182, 0.988724745787857, 0.9881787765736916, 0.9848764172140977, 0.9740137032583044, 0.9841639067809713, 0.9813545250690087, 0.9891744699619153, 0.986357703152909, 0.7497498741726593, 0.7636662382060857, 0.7612767196336743, 0.7889423020755897, 0.7969662964560589, 0.7772225451612175, 0.7938772313532543, 0.8239066649752821, 0.8126518646913369, 0.9070170434693196, 0.928048193358417, 0.8757721390020734, 0.21406746324822712, 0.890641419719913, 0.3808731240830312, 0.4068985960737884, 0.4043093506497665, 0.9157761815437838, 0.7448449562224748, 0.7967802186755675, 0.7189031056703387, 0.7850310794248141, 0.13401422212444591, 0.7831004633396752, 0.7659328231315514, 0.7298591015959699, 0.7941629252577843, 0.7169737068035437, 0.785057972030874, 0.7730207203043609, 0.8390251024524542, 0.7784877547993143, 0.7406428333060491, 0.7888607383304613, 0.7866992475338221, 0.7828089863260691, 0.5785802004755591, 0.12106920254832798, 0.5802463175845369, 0.5866378776390748, 0.6866123642565278, 0.5793001179993187, 0.6866930116792012, 0.7144739729487392, 0.7383743161054536, 0.5617968955415513, 0.6771926925863054, 0.7609126685964297, 0.8285443336439917, 0.3270621846339573, 0.7032531720323754, 0.8266472859944783, 0.7889565724196262, 0.7660708333233678, 0.4683811246737637, 0.16455650416232126, 0.22166697111402323, 0.43992039384744064, 0.5377192345071834, 0.42492873580093404, 0.1750621534838156, 0.2617163629238466, 0.1618817411217497, 0.4530715809954523, 0.3766342412073541, 0.4627054075912186, 0.6681912892184085, 0.49201932527571757, 0.6885767884620397, 0.5988200717581109, 0.6473205858980624, 0.4878793387878029, 0.8866988148463084, 0.853556983145432, 0.864663736684735, 0.8235488863496827, 0.8413936892674921, 0.8688099469931364, 0.8637131909901434, 0.8619427589162983, 0.849338791710233, 0.10973889096062484, 0.11549509978246242, 0.09806098278260866, 0.096894938515801, 0.16031003786541476, 0.11701763600480464, 0.15856549396746655, 0.10896936605473961, 0.11715425304047455, 0.20201909841039156, 0.2212526461998634, 0.17579167238414395, 0.18909316050699387, 0.2515767873222138, 0.23856205895228855, 0.20352636744234887, 0.14404664362172548, 0.2032828043967615, 0.6545295659159274, 0.4735089239017165, 0.3855355461589829, 0.42314332525227927, 0.31188776956306674, 0.3465755275025648, 0.485748476223411, 0.2546118796728627, 0.23041381543965855, 0.21494171762940972, 0.22401151436975586, 0.31591182538515417, 0.21736942492303168, 0.26392358362361734, 0.31954382337743037, 0.2874643067656204, 0.2556843168444871, 0.1437564891453179, 0.25882042061173405, 0.26691396384676214, 0.2815229667877791, 0.23109879616947782, 0.2550440103704372, 0.25348393042540973, 0.22739921435196464, 0.21174870942140855, 0.2235631521600756, 0.21195366195779575, 0.22586742934593296, 0.17437981282083148, 0.18957328548119667, 0.21170108128587195, 0.19580468599003764, 0.2255723691105539, 0.1832889039053398, 0.1881282106892661, 0.9490686344567704, 0.9378834221104869, 0.15355053190521994, 0.18831861133142314, 0.8578987377495987, 0.16582382914924643, 0.9189671370706297, 0.1642380216684709, 0.9195580961745079, 0.9339350223689116, 0.21204567134309082, 0.8994066135816423, 0.2125466396456629, 0.8899471244356805, 0.8815589076766684, 0.2135443079802617, 0.897552661503551, 0.9146287802042372, 0.19608721595777967, 0.19440476063766288, 0.18015316078105748, 0.1842444120085608, 0.18003680265601885, 0.17993780101976065, 0.21620724957645487, 0.2486910119441743, 0.2141920576017734, 0.11252374053419223, 0.10894758447509267, 0.09054511664059706, 0.08493074247716959, 0.07805433077120816, 0.09007454245870883, 0.10173034577663398, 0.09662754714893251, 0.0894255915707699]}, "mutation_prompt": null}
{"id": "8d04af1e-432a-478d-9515-e5853856dcb9", "solution": "import numpy as np\n\nclass AdaptiveDEOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.05\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDEOptimizer", "description": "An adaptive differential evolution optimizer utilizing memory-guided mutation and diversity-based restart to enhance performance in varied optimization landscapes.", "configspace": "", "generation": 80, "fitness": 0.4370730930340128, "feedback": "The algorithm AdaptiveDEOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9086465029581632, 0.9252917239854642, 0.9028982511005021, 0.9159522560773954, 0.9137620520092334, 0.9034233304146227, 0.9233648710547513, 0.9167347607069458, 0.9054210153865997, 0.837503407342605, 0.8378144119970723, 0.8224859427845557, 0.838779014436206, 0.827965493308513, 0.8407229071814923, 0.8349369634498365, 0.8314320278952207, 0.7969557890855222, 0.16318589638074632, 0.10864901580700448, 0.10626360166095361, 0.06990989710841822, 0.13277310233974982, 0.15790428120199262, 0.12993352964724958, 0.15638247130091054, 0.1598582663994308, 0.11552028844886952, 0.09422664692723193, 0.10846909149678263, 0.13368990748211473, 0.09176273685119418, 0.10969854965718429, 0.10738161497079945, 0.10536363378326818, 0.14191493906876151, 0.9870026879964132, 0.9907708410693077, 0.9591673374001806, 0.978307696034918, 0.9837524300694287, 0.9856924183500628, 0.9854471245398032, 0.9793112482845685, 0.9734156342780261, 0.7296302972474429, 0.7692790636466328, 0.7316054332688033, 0.7421558008519382, 0.7256779151851922, 0.6412393004491836, 0.7787331896046032, 0.7760961901855032, 0.6635775422428043, 0.37379322811347115, 0.750264389433134, 0.8387906926082617, 0.35492247857812476, 0.9089119780922386, 0.27703854755914226, 0.3868014426255165, 0.40465837006797023, 0.8654887096743309, 0.13041524332405552, 0.6232322926885376, 0.6254238302233406, 0.6737702149487826, 0.6952251517575194, 0.6218288872595266, 0.6021613761475383, 0.608834556361983, 0.6323209648290049, 0.5837467962581606, 0.6357109752021893, 0.6869344712071903, 0.7290671910627367, 0.6703244284792864, 0.13666488297986124, 0.7987507340113238, 0.7004243339897465, 0.7318841540939505, 0.07802501889863611, 0.06386316262330327, 0.4778646031182501, 0.5395596554615363, 0.44533535269754554, 0.12542931035082638, 0.09485125355219881, 0.6149027434071108, 0.27892645396337856, 0.6588783431226255, 0.3673730154236651, 0.635940990507896, 0.18386897345121023, 0.5339476829392605, 0.6762418359428839, 0.4790109739736961, 0.4533500951488365, 0.6789621459980315, 0.18318104917627265, 0.06550486126861799, 0.44983956001545555, 0.27904424871365685, 0.3337346451670946, 0.1620767874260728, 0.21643517606741003, 0.12609286664876307, 0.13580337066444603, 0.3550595219974446, 0.15815941787639154, 0.17713768151858245, 0.4118606313533405, 0.3800638092518257, 0.33487944116685153, 0.2457827710955468, 0.32180411182363455, 0.3110332832050109, 0.7592428362091124, 0.7786649086362529, 0.7837606555075669, 0.7292949995919416, 0.7169301128517385, 0.7083358021891781, 0.6975187735460439, 0.7199267575357363, 0.7586280355757015, 0.10341435333609439, 0.12382330488285775, 0.13644731914884944, 0.11214964877155631, 0.0920473365353448, 0.10077006143362466, 0.1044863089026794, 0.10850483339382422, 0.7822852310261075, 0.17418707089685936, 0.28185748954786893, 0.21855231006966536, 0.1989986829368302, 0.36125199375105876, 0.23247148933665562, 0.17741395066572985, 0.18678348364303698, 0.2783386912959016, 0.2895677586239771, 0.4777228372149718, 0.4535733925927893, 0.30027892431363, 0.3535640450889066, 0.34308977094706383, 0.2738506691786773, 0.31612074923946565, 0.3428592011965794, 0.3588564108064193, 0.28663669395981395, 0.20521713563461141, 0.22899641718418484, 0.21267983931614054, 0.33720747976754906, 0.25383406142783826, 0.2638097189413924, 0.21895417580070475, 0.22303364627142863, 0.3066789900985123, 0.29649823346938686, 0.22087889163250363, 0.3052264949937996, 0.23747340309033038, 0.34871200744158937, 0.20610249344198994, 0.2714819912986327, 0.20013450951275413, 0.20274396217542778, 0.20870190851493087, 0.21113673793851273, 0.1895027361413847, 0.20016761157409246, 0.8097690920697335, 0.1926137092540492, 0.18400703126261053, 0.9307978119034206, 0.18706259300178318, 0.15318420463022908, 0.17170884058226876, 0.9270482469003224, 0.9019891657781357, 0.9280384048904767, 0.9063644063196004, 0.17707643055964495, 0.8988028032831544, 0.21118118436187427, 0.1252889334217392, 0.21261179987399026, 0.8929160254516049, 0.8470114125525205, 0.2132216757772838, 0.8476771117561661, 0.1560018381795677, 0.18380787235842544, 0.21422238482967315, 0.20562355023355894, 0.18847764382598453, 0.1842968652414384, 0.18384553344053534, 0.21580479870430735, 0.20324250582251446, 0.19343430880195533, 0.09039006274219319, 0.08840333410755119, 0.1270606881441858, 0.09274379354765694, 0.10558873563034432, 0.08804787264916158, 0.10273004024310828, 0.07902912347184377, 0.07623141068794126]}, "mutation_prompt": null}
{"id": "d4a26264-3556-4809-9ae5-aa9a4e54063a", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.05\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A dynamic swarm optimizer using adaptive crossover and mutation strategies with gradual convergence control for robust performance.", "configspace": "", "generation": 81, "fitness": 0.4685764126952513, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9122863749974037, 0.9028043477090605, 0.9197803162448992, 0.9156685017912882, 0.9125002609009185, 0.9030984747023986, 0.9085549926994017, 0.9108714637671661, 0.8987253731739553, 0.8396819466867955, 0.8228852536403661, 0.804342523088808, 0.8335561113476433, 0.8382826945494538, 0.8263080800619087, 0.8341248959217519, 0.8218881134694767, 0.796665258408631, 0.1834187664300766, 0.15384428847609433, 0.17695450357593723, 0.11388386290697594, 0.15565612591641798, 0.14165481888461473, 0.7114320495526362, 0.1578077938534478, 0.7012681482008252, 0.1550561276855026, 0.11250292915507054, 0.11808423212079999, 0.15666651487069017, 0.13610374045403917, 0.12062222832159564, 0.11283198007404771, 0.1594286148315972, 0.13756156185062152, 0.976163311043863, 0.9839816141181404, 0.9620219478722359, 0.9749452195784789, 0.9661259901831264, 0.9791414702021242, 0.9782504860157974, 0.9736087367164816, 0.9797969051652538, 0.7243945750158285, 0.7589325341991726, 0.7532529290458883, 0.7449668394917626, 0.7463618760711089, 0.7589755866808656, 0.7704703861844496, 0.7749118247153907, 0.7625860796540578, 0.879520872074037, 0.3905710118517143, 0.8530550872628664, 0.2813710092548799, 0.8981809192207298, 0.8951858888606602, 0.4011687742338633, 0.9185415828419156, 0.8660976036864771, 0.6768378963611255, 0.6207385112882258, 0.7415906020271004, 0.5838901785381412, 0.7477258057156062, 0.7069034171160801, 0.6361877069759417, 0.7587972286995958, 0.6870293055118666, 0.5410820973022189, 0.6696093740190048, 0.6028628929100772, 0.6480879107402605, 0.6046222442820931, 0.6634880601694413, 0.13566134929188245, 0.6751522827889033, 0.676306058359943, 0.3748365294521896, 0.5735356908594927, 0.571699625547688, 0.5591511567811138, 0.4853663368977411, 0.45924774706808247, 0.5853375957694038, 0.5009957125653599, 0.525218226295435, 0.5010712442199623, 0.6792682957561387, 0.6641075207475626, 0.586897208067816, 0.5867982089885311, 0.6474145172617529, 0.7039596120777047, 0.6743166308517533, 0.6158716415136835, 0.4392294514074975, 0.24652993069358764, 0.24105211133620286, 0.32342865120582454, 0.24904157405790361, 0.3812866010688849, 0.15989819975259356, 0.15171969629344118, 0.1227824320706461, 0.43045685332030914, 0.38612820154902827, 0.4402401161062689, 0.47983423005270287, 0.37498006151609975, 0.46911376910784497, 0.3673165813048609, 0.41087277217487184, 0.40708517405648426, 0.8069615400470083, 0.8144893398485096, 0.8226265963434384, 0.7664975046295114, 0.7637440750045146, 0.8134596191267806, 0.806774720641507, 0.8005925108397427, 0.8209156786827367, 0.1387609761687958, 0.14409775836261984, 0.10052821678432133, 0.13776816065345754, 0.12138548807590721, 0.14176046284203425, 0.09405902878866834, 0.11907804932994803, 0.14605819635067385, 0.17686851801881254, 0.24274706553354009, 0.1842475261753499, 0.1540190370106469, 0.26466068727519376, 0.28629419694281355, 0.2626735570901745, 0.25250872816128656, 0.20590013035280175, 0.5350438264367647, 0.5906440311576988, 0.43786742284057745, 0.523163246649411, 0.7145511601484118, 0.5634274387494638, 0.29225309069746974, 0.3618602984267758, 0.6949123577720102, 0.29106751647497087, 0.369612977366392, 0.2850887338763721, 0.46392129255946346, 0.3043457498184734, 0.36667851524405726, 0.43122113200355217, 0.3678914225820249, 0.3698730243564833, 0.21860060767017198, 0.21033134713265966, 0.21939857973735544, 0.23328246127744234, 0.18479354569263517, 0.23733309659622503, 0.24754220600120014, 0.23051048896333015, 0.22530318817252526, 0.22153601949304624, 0.18540663057673978, 0.24379739316468163, 0.2428009762454285, 0.24689248544310272, 0.22326610003814262, 0.20783447298283986, 0.24757658774976365, 0.18963029980491597, 0.18741532485401513, 0.18837163814740687, 0.16989345615361495, 0.15655391322355094, 0.9160611442862968, 0.1785316979689573, 0.1412112551642717, 0.8888039702682573, 0.16645390100888913, 0.8912628909672586, 0.21136471941387247, 0.1527406860595929, 0.8427900812892124, 0.16849026340390805, 0.16751458198125424, 0.16650130289498444, 0.8522713217716399, 0.855855745011765, 0.18094144275298263, 0.22007364504394944, 0.18145447353463018, 0.19102274380076856, 0.19712790369767386, 0.18090056215257933, 0.19421789206211948, 0.1813160600071123, 0.18395222572173864, 0.08646973314237527, 0.09015827489855077, 0.09647708062734217, 0.08559837832808626, 0.09311649238945974, 0.07792308119452374, 0.09477487737079204, 0.0975042412710887, 0.09660388586894786]}, "mutation_prompt": null}
{"id": "00f77c64-dae5-4608-91b0-26a8b7425d54", "solution": "import numpy as np\n\nclass DynamicMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.45, 0.35, 0.2]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.85\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.55, 0.25, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.55, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.45, 0.35, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold or self.stagnation_count > self.max_stagnation:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n            self.adaptive_factor *= 0.9\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.adaptive_restart()\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicMultiStrategyOptimizer", "description": "A dynamic multi-strategy optimizer that adapts mutation strategies based on performance, with enhanced memory-guided exploration and a focus on maintaining population diversity.", "configspace": "", "generation": 82, "fitness": 0.3553877337078188, "feedback": "The algorithm DynamicMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.29.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.8844614902621029, 0.8970267112449287, 0.8877363296176609, 0.8846866533028502, 0.9045848614260658, 0.8962693306126415, 0.8801276329225614, 0.8902156365181089, 0.8891428101787366, 0.781735646840249, 0.753574342429857, 0.7937128629385568, 0.8142303396043805, 0.7616191024632025, 0.7858924762998661, 0.7752541943461515, 0.7900835185809467, 0.7945517063715459, 0.10528416781145755, 0.15097351799186542, 0.1260941602445157, 0.11477493230135916, 0.1535029384433395, 0.7290690668728694, 0.12281112992889953, 0.14271179204483175, 0.1832599267196795, 0.0951801078024328, 0.181065275275615, 0.1288414514146532, 0.09905138699200744, 0.13215067684672555, 0.11886578147721849, 0.1148595961506872, 0.09811254883232634, 0.1537968934652839, 0.9846727695585299, 0.9750168467117516, 0.9773397528708078, 0.9888884532158903, 0.9823154786615544, 0.976979068557933, 0.9852462187111415, 0.9817737312364777, 0.9848199480410785, 0.510340149160361, 0.5693784182983888, 0.6102326923206914, 0.5912927610878507, 0.6812234898575671, 0.5140398665792814, 0.6015325846515536, 0.45192971562925555, 0.641739548814503, 0.22480410820841756, 0.24475875880079456, 0.16994265754449134, 0.8742099693435652, 0.19600398690269827, 0.9235020921623417, 0.8699268861170306, 0.235767623900906, 0.8911849280627717, 0.29140844758740614, 0.1994515232916222, 0.3546739825748809, 0.26671972872147487, 0.5028263147528238, 0.13153813519949453, 0.152920595013477, 0.1860903649000304, 0.1334810490804863, 0.13181713471055467, 0.1245204411456099, 0.15956656575832495, 0.25030468024648034, 0.6987819687783411, 0.193873040790009, 0.22156495672426557, 0.12577200269809985, 0.17396475559321822, 0.1372659129157472, 0.07893470183386175, 0.08934955088809127, 0.06885240657391167, 0.11260515959609729, 0.08564929433433133, 0.04865073149585353, 0.11563297736277689, 0.23027858557802627, 0.6290403998483463, 0.7014079430300807, 0.4627791080692062, 0.6260641377383277, 0.6118446223963259, 0.5958071001519635, 0.6230066557359375, 0.681590245225882, 0.14147238805328055, 0.3714166968990614, 0.2178271826042394, 0.23992033806649837, 0.0858325876810615, 0.2388776659909697, 0.10073681282166635, 0.23015600777604484, 0.11447921577937503, 0.09329086990361479, 0.2756390005842483, 0.08733806870090266, 0.22708973845793834, 0.18943111081161024, 0.10573278946099196, 0.4746145158618178, 0.1785405415104656, 0.15489157473626725, 0.2094912172118979, 0.64304270398078, 0.661047487605999, 0.6014285251433247, 0.6115055500193378, 0.6505786337611976, 0.6706149912780829, 0.5918769436129612, 0.5964656445017724, 0.6384249861546749, 0.08477996274500421, 0.12227103923613847, 0.07701547327758762, 0.09920632039512567, 0.13121029410689067, 0.13210533360531262, 0.11054392874422925, 0.0725071080545937, 0.0820698012060106, 0.2835473516086028, 0.1759156939145181, 0.16373898560961297, 0.13766266535167793, 0.26683324955038923, 0.1553323805398672, 0.19862740997494321, 0.15558809781169258, 0.2666487691524996, 0.5204838038640325, 0.2862323821636512, 0.4141004585827385, 0.3832998090938746, 0.5463714162216626, 0.30440799975070065, 0.27997658689207394, 0.3589433458629021, 0.4440032474978788, 0.20911998633796935, 0.28098145146351794, 0.20012876556295944, 0.20111880409893124, 0.2180523556979288, 0.1595874020177931, 0.24108631006970804, 0.3492311773176122, 0.1666102998967317, 0.22066601653779994, 0.3020114744179817, 0.20590692861930238, 0.20750558107247374, 0.19418629001045462, 0.200713470792389, 0.18398830390790222, 0.2238346615747736, 0.20870995685954108, 0.19364761067974978, 0.1848861803512124, 0.20130834744297144, 0.18629966248444996, 0.17510483372752494, 0.21072677542857554, 0.19821786101251815, 0.22486366838701388, 0.179527868558236, 0.1654275949941144, 0.19521296961773138, 0.8975236843084646, 0.9303281662606812, 0.19731658449131217, 0.15302067458759616, 0.936968013758782, 0.14264121633664506, 0.11484285983651776, 0.1664030153543663, 0.21245904708143848, 0.1266626860178559, 0.16707511217455173, 0.21106732745594659, 0.15603750130745409, 0.2124098373873533, 0.15533707546422737, 0.872961819905612, 0.18582584119714163, 0.18207137833759146, 0.17105562441036037, 0.1978574071383462, 0.21671066173410236, 0.1887546916420445, 0.18123998788634388, 0.18490933255584185, 0.1894261320760222, 0.10318245416047556, 0.0928533867748561, 0.09670573632077883, 0.08533391223439357, 0.0837879433436467, 0.06967806076918037, 0.09190076268963143, 0.09142221499220082, 0.10192229624776739]}, "mutation_prompt": null}
{"id": "ffe58e82-8b3e-47f7-965a-deb4e83701a2", "solution": "import numpy as np\n\nclass AdaptiveMemorySwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population size for better exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]  # Adjusted strategy probabilities\n        self.adaptive_factor = 0.85  # Slightly adjusted adaptive factor\n        self.crossover_rate = 0.85  # Lower crossover rate to maintain diversity\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (3, dim))  # Randomized initial memory\n        self.diversity_threshold = 0.15  # Increased diversity threshold\n        self.stagnation_count = 0\n        self.max_stagnation = 8  # Reduced max stagnation for frequent adaptation\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_vector = self.memory[np.random.randint(len(self.memory))]\n            mutant = x + self.adaptive_factor * (memory_vector - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.25, 0.25, 0.5]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9  # Increase adaptation speed\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMemorySwarmOptimizer", "description": "An adaptive swarm algorithm employing memory-driven diversification and enhanced mutation strategies for robust optimization across diverse problem landscapes.", "configspace": "", "generation": 83, "fitness": 0.4238220601700845, "feedback": "The algorithm AdaptiveMemorySwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.912689451309824, 0.915015616729772, 0.9051188892213863, 0.9230512462841267, 0.9139981720259732, 0.9225956940308286, 0.9208672312507056, 0.8885488059569908, 0.9160638994777486, 0.8082960239003204, 0.8102415870933838, 0.8186995649287502, 0.8205628416482601, 0.7981855278700289, 0.8246874321840183, 0.8163099476104404, 0.8173150450188328, 0.8037847389722452, 0.15497305517904203, 0.15462303670154165, 0.14525392328553555, 0.1399508659393759, 0.14322906320754214, 0.1807654936967139, 0.13204447495115146, 0.15969788151326647, 0.1614945240982193, 0.10500191995766595, 0.10919289642899843, 0.08208322459630057, 0.11929737127476836, 0.10765884809650228, 0.16809011819901776, 0.11082079554890645, 0.116550705807271, 0.17347907424735765, 0.9872259213745053, 0.9855287896538725, 0.98362937304778, 0.9777470652088219, 0.9763120330413103, 0.9810646318685423, 0.9829603776890428, 0.975736737720338, 0.9845806294888638, 0.7118855402678974, 0.7618307225157117, 0.769670863296558, 0.728960675213489, 0.7280637750988528, 0.6774732136202795, 0.7820009605729146, 0.7645272081732044, 0.7960287546098855, 0.2253885330614266, 0.8318996201533069, 0.38339398543929515, 0.21028914472639348, 0.901716406540012, 0.22031412343258183, 0.8813286324961611, 0.9273917031242053, 0.8450051420779287, 0.7445939298714386, 0.665461208603916, 0.1315323250514322, 0.58234910943194, 0.7271498926749996, 0.6134650484042835, 0.6560842233822684, 0.6176589599933381, 0.6623951596841324, 0.1330079687189598, 0.6560099228270861, 0.6480292933585756, 0.6338139997156615, 0.703875686755987, 0.5585867517856677, 0.7977095674263426, 0.13099008714045846, 0.13553170853865126, 0.3504095742437551, 0.09403150012287131, 0.3392188639411209, 0.1267494035133654, 0.5968761176252045, 0.5045481809777835, 0.6839278582459167, 0.6420880042771671, 0.009204375317671487, 0.6928212619977765, 0.6607510953814437, 0.7155077148217583, 0.21622872451681396, 0.7333452837863399, 0.5022853344338478, 0.6245229741599099, 0.5895393500361268, 0.47115226065172466, 0.2194113132136878, 0.3313235875220989, 0.13449410254754224, 0.29230174061484737, 0.3757457107323968, 0.12834036435542018, 0.43746639743730764, 0.1485008498133742, 0.13968479481745766, 0.3435281616558582, 0.42835097999664973, 0.29831936079089716, 0.4254941133741027, 0.4939312474451676, 0.39402169557975864, 0.4644167472388383, 0.26242357703498476, 0.3065348658218393, 0.8330522437273201, 0.7917080643497417, 0.8250710932442683, 0.68720955254354, 0.8225695178572707, 0.8338868396074608, 0.7928197122627603, 0.8163300119457806, 0.8069820863653805, 0.1237496229449756, 0.11706223737145005, 0.09902992910961073, 0.13266540417995565, 0.082185397990166, 0.18747607787263165, 0.12133311787829881, 0.15934752365554572, 0.09149410688037574, 0.3858817969076379, 0.19338101911388772, 0.23669277584508974, 0.26283028506058626, 0.27497163546111314, 0.19646879526354466, 0.2424108936063647, 0.2390690819583986, 0.18866177808822027, 0.5165064394100385, 0.25853736558500184, 0.360840094906675, 0.3471133938302088, 0.3126593310475464, 0.374710753745393, 0.22743834620607728, 0.5650473290791631, 0.26725778074743534, 0.3050874067170378, 0.29272828995473477, 0.3093299589148648, 0.22587273629296645, 0.26321093480128765, 0.15763126257343096, 0.19723349567357806, 0.4862908046584644, 0.15898954520309982, 0.23662069031171717, 0.21051161050429668, 0.2381002946298042, 0.1974587685609429, 0.20988044446027299, 0.20876099205570908, 0.2128365356821309, 0.22801241764576885, 0.18900989214015862, 0.18800211303448078, 0.18324568246911344, 0.24565065345528703, 0.20753329698360834, 0.22433023301426014, 0.22373243494415318, 0.20354764894479682, 0.19045491431603623, 0.19700888118796733, 0.16468373164932415, 0.19622788629255328, 0.18825269891600793, 0.9193419908731023, 0.16633917035646884, 0.1530173933717056, 0.9378615612996761, 0.1647639652611742, 0.11469720341491174, 0.8832882035151933, 0.21244455424283926, 0.12588288136444858, 0.2107931036236198, 0.16714485739682983, 0.15629782111606105, 0.21302697474842547, 0.8757789026817911, 0.12841719458603407, 0.1848225449877292, 0.20691864470108012, 0.18755760709762181, 0.18582116776912305, 0.19186931882628744, 0.181528801205169, 0.18281127621010662, 0.19552469731715028, 0.2736497044768804, 0.10281019076795817, 0.11626605080034191, 0.0904610534491912, 0.08792237470314235, 0.08423641089185951, 0.09060661006335213, 0.08622493254366947, 0.10687230180636886, 0.08794195646820713]}, "mutation_prompt": null}
{"id": "11808581-208f-476e-bf75-d7b5de9e03c4", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((5, self.dim))\n        self.diversity_threshold = 0.2\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-7 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A dynamic swarm optimizer leveraging multi-strategy exploration and adaptive diversity control to improve convergence and solution quality.", "configspace": "", "generation": 84, "fitness": 0.4110569349030635, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.8846270813929423, 0.8869579340984416, 0.8911378122612843, 0.8864009614424984, 0.8726568324472705, 0.8872111777320014, 0.8825490264744121, 0.8967986064492569, 0.8901919444989831, 0.7958193367013399, 0.7880399736803356, 0.8015466332557878, 0.8041394661387942, 0.8169614639442379, 0.8069329766433462, 0.7810400668880325, 0.7856844502511822, 0.7819752151983193, 0.17805821597634253, 0.10266487628721954, 0.12772097196171361, 0.12799711257459678, 0.13038536102528397, 0.13868709296692783, 0.12682101768044451, 0.13945908357253778, 0.15951608604268275, 0.0900271051488919, 0.10665445252668893, 0.13782735568129956, 0.12058009249604751, 0.14321417748101506, 0.07901269841934577, 0.1492627248684878, 0.138116766683957, 0.1303503200720656, 0.9875522532344552, 0.9789925492151538, 0.9855072731089908, 0.9904093196999311, 0.9771078601947777, 0.9881327321597577, 0.9812515329303153, 0.9867833213728188, 0.9881492281363492, 0.6309785695204481, 0.5895526426520201, 0.6308026653309908, 0.6078387901836325, 0.624902183711132, 0.6504045005796992, 0.5739631073816589, 0.7353540195567625, 0.7167996429072261, 0.34029508669785236, 0.8205609839915655, 0.7722603200943613, 0.27549555385209157, 0.2730389469846597, 0.1921495808848438, 0.8405383050552382, 0.7870156188799939, 0.8298659038523146, 0.6536477422968032, 0.705640749800073, 0.544367001127873, 0.1254775515676373, 0.5522115696737007, 0.12721051142332584, 0.5394879353812481, 0.663296519443933, 0.4819828013386873, 0.5538599258632668, 0.43468586492989914, 0.5841301893044786, 0.41731701430698975, 0.5926651817668573, 0.1357030458179952, 0.6422623331579511, 0.5602907089894819, 0.5750504589007286, 0.18557885751205427, 0.09070100596350517, 0.40564781274710526, 0.06132181796295677, 0.3924017912164328, 0.3505077397580767, 0.21741057298140065, 0.2060424860072534, 0.22951933807359515, 0.4604687879087146, 0.5994470607532045, 0.26720640954301955, 0.5081318782143731, 0.5181385087319625, 0.328691930360284, 0.41533716146729394, 0.4288646622327946, 0.27794365834899315, 0.0852181900674861, 0.06186626781127014, 0.19511495692338854, 0.3582102758515995, 0.31309988056293836, 0.14961235994393285, 0.10859790015075055, 0.2953033373728655, 0.10836061504874617, 0.28236729046774534, 0.3435374153561709, 0.34085436755150234, 0.3190559393185547, 0.4622588468068808, 0.3674357565230221, 0.30328984646363266, 0.3388609000947419, 0.3238697763988697, 0.7413741368459491, 0.6234048151695069, 0.6526957205196394, 0.6605539519007173, 0.7883333902040224, 0.7681136745847488, 0.6678171635468155, 0.6991768258442661, 0.6908748871194103, 0.1597708858786726, 0.08592032342274414, 0.09817182683391734, 0.13819051469982535, 0.11530207951942817, 0.14037558583031717, 0.10099003937212114, 0.13782093929074835, 0.15374722063535318, 0.17245189230846159, 0.20168944543750045, 0.2321427527998623, 0.17363843709958549, 0.19088496757422901, 0.2363145867893428, 0.1995232620465377, 0.17186278821832934, 0.29326279970338875, 0.30123627267173947, 0.3416126474294139, 0.474182685621917, 0.4747821797819012, 0.3654188153832926, 0.3704835473094421, 0.45094497267159617, 0.4136349217308728, 0.471434064648904, 0.2732213192130928, 0.2877897500262564, 0.33771026256648473, 0.33430202335438375, 0.30445072438649134, 0.2931123145323711, 0.29246834677236555, 0.2612856299509414, 0.25632717125434734, 0.24985569468026625, 0.22708891532487407, 0.30305898723171965, 0.2644118223504839, 0.24672749576318165, 0.24135403124733856, 0.28988511232929925, 0.3133471551499385, 0.33233457044475634, 0.22051165704420383, 0.2218774620676608, 0.18951676300937026, 0.22300729101866767, 0.22483836644946664, 0.20840431879410493, 0.21090183960014275, 0.19748057148288978, 0.20483697964950331, 0.9083588116728506, 0.18782085072896293, 0.1668171898116192, 0.9060527670038687, 0.19922882815039733, 0.9012111030531486, 0.9204169719097588, 0.14227897612580276, 0.1664701674851352, 0.8656068118969189, 0.21009222234437985, 0.8754550640850903, 0.7979982869405846, 0.20692924190927997, 0.15359222555926866, 0.8682073495349593, 0.1677985669850477, 0.8861896351514754, 0.17935765091264788, 0.1952127650571155, 0.18586655885641545, 0.17926978849270603, 0.17890146590604872, 0.18095026915410994, 0.2193009612151151, 0.21368017620731117, 0.20431804957340138, 0.08561812615232334, 0.09291915797762851, 0.08222928082323233, 0.08502726418824569, 0.06819380819211385, 0.07635087955287523, 0.07282783124187153, 0.08127099926233783, 0.09594476908745797]}, "mutation_prompt": null}
{"id": "a0dffc79-ba23-406b-8ff7-fbc65afccc3e", "solution": "import numpy as np\n\nclass SelfAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = np.array([0.4, 0.3, 0.3])\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.05\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'memory_target', 'adaptive'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_target':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = self.memory[memory_idx] + self.adaptive_factor * (self.best_solution - x)\n        elif strategy == 'adaptive':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = x1 + 0.5 * (x2 - x3)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'memory_target':\n                self.strategy_probs = [0.25, 0.5, 0.25]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "SelfAdaptiveSwarmOptimizer", "description": "A self-adaptive swarm optimizer with dynamic memory-based strategies for handling diverse problem landscapes efficiently.", "configspace": "", "generation": 85, "fitness": 0.42532722444740795, "feedback": "The algorithm SelfAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.8424529841100095, 0.8264690218826947, 0.8317018208551074, 0.8449309693731458, 0.8478965993166846, 0.8471447113766751, 0.905513661370921, 0.9170290180075312, 0.9215972107031141, 0.8366913656945619, 0.8330839063244155, 0.838634529211149, 0.8166192904667566, 0.8182787867922298, 0.06604242036060115, 0.05852326043947975, 0.05812933019713906, 0.05296505584071942, 0.13022646282500627, 0.11526879029441439, 0.153119125136167, 0.1274726944252932, 0.14995461244365937, 0.1476534475188298, 0.12941961789204104, 0.4911564337644726, 0.1452421761187388, 0.14191274275130872, 0.11539507166930674, 0.09454956204030773, 0.12806796977122303, 0.13086888568519894, 0.10516203713640604, 0.12329794553536999, 0.13100403309622233, 0.1305626479273324, 0.9914482249606412, 0.9941593276570224, 0.9870888191326584, 0.9933134881515232, 0.9887058010921005, 0.988500929627583, 0.9942438438217596, 0.9866011487172232, 0.9903515338659259, 0.4661188469127173, 0.4152902397746986, 0.4682685064762122, 0.4584409345350461, 0.44709480670810375, 0.4486898973344313, 0.733802491287213, 0.7726499431153478, 0.8127626139515604, 0.8321777848279177, 0.7883264369403167, 0.840355845589043, 0.1929929746897865, 0.7768080066846405, 0.21181758076420454, 0.8290751051811881, 0.8921809583420595, 0.8305174518619169, 0.6790136412398331, 0.6186910294718764, 0.6282474810984471, 0.13331422173701868, 0.7934553049889727, 0.8068845125994806, 0.1267712563125588, 0.6159688148530855, 0.6492922028529369, 0.57344199994218, 0.5667638874670271, 0.6019232616473491, 0.6937376999058764, 0.6621024677671937, 0.12816398030370857, 0.6565630572726819, 0.5857976433119472, 0.5366914200822288, 0.06920084151827233, 0.6882778063724055, 0.07085557185076197, 0.5444235567974822, 0.49599841552113977, 0.45219598498227753, 0.7752765175526235, 0.5000356401825966, 0.7684006556664511, 0.653891978521671, 0.6993264592389099, 0.5856618197393951, 0.7929843414352276, 0.6305587143674902, 0.777566100232975, 0.7164860850598997, 0.6512908594891069, 0.6502071656012007, 0.04849962172970157, 0.23302809775294064, 0.15281777822296494, 0.3782905175917515, 0.07583258737432241, 0.6929143730610847, 0.09633657855402566, 0.3196626284686883, 0.3244087321011191, 0.39707355536922184, 0.04288200523186847, 0.37483038047792216, 0.48828182854176616, 0.4338123081829359, 0.377593680543613, 0.08268560690055915, 0.049040587682100734, 0.0838451316129758, 0.7094817515312852, 0.796934836831477, 0.8744796288567642, 0.6797451196335316, 0.8777841333537671, 0.8242599704512019, 0.7715771539930737, 0.7613278626988623, 0.7519317655018484, 0.11318749916458515, 0.12414031712173224, 0.1086747368367289, 0.12974481782199165, 0.16809527768715327, 0.11409282694822653, 0.11573945116310969, 0.18467265255184906, 0.1401695824828577, 0.2529907580382933, 0.5492477527856315, 0.2186561365107007, 0.18641592142036256, 0.14290201266661284, 0.15461316160537553, 0.1811463481769815, 0.1940039754663353, 0.19555996263816722, 0.5173484896590959, 0.24288157008423616, 0.3210177383837387, 0.4435144421327515, 0.4501502235755328, 0.4336716715476234, 0.504931184985743, 0.4700705031274134, 0.49612938064835466, 0.23596073418737984, 0.23259814124968914, 0.19234625448283726, 0.3995537412051944, 0.3591438204016836, 0.21074458051461553, 0.27224393510165923, 0.3782728905471239, 0.41387358590707013, 0.277173992706626, 0.20715862320592437, 0.2471780168897273, 0.2581118991961071, 0.20274780341569554, 0.1970273686123042, 0.2013330967540713, 0.21050192826319591, 0.29211763797175916, 0.22875782833083202, 0.2131252731011185, 0.2030573644729965, 0.2161640706658965, 0.22951859603016678, 0.2143029070033825, 0.20249573184217828, 0.23392317044594724, 0.19626831033041525, 0.20648628101442046, 0.852644351852853, 0.11455843794567022, 0.9490934911336983, 0.16844365183409993, 0.13052690479568607, 0.17761649930925627, 0.16376451624648614, 0.20900028129139192, 0.9305420208252104, 0.16796105621543933, 0.2105433969494973, 0.20882248157006056, 0.8585139577657223, 0.8339604642063891, 0.2211030454667492, 0.9213874653805039, 0.9173414890278189, 0.18323431540963997, 0.18103093006610127, 0.18165170106491602, 0.19200592106630676, 0.1859170900538072, 0.18588147095979624, 0.21353920649715297, 0.18525764019516022, 0.19581497611971665, 0.0947162519971142, 0.07449066204707178, 0.08962675752971716, 0.08426248223317145, 0.08384908869003505, 0.10005492483688849, 0.08767570382121814, 0.08354589268764845, 0.08170361487417832]}, "mutation_prompt": null}
{"id": "427ac487-5d92-41ad-b579-18add82dc2f3", "solution": "import numpy as np\n\nclass EnhancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.4, 0.2, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "EnhancedSwarmOptimizer", "description": "A novel swarm optimizer using adaptive mutation and memory-guided exploration to improve convergence stability and solution quality.", "configspace": "", "generation": 86, "fitness": 0.40981099797958415, "feedback": "The algorithm EnhancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9241292055217939, 0.9193367226827627, 0.9293573678783414, 0.9233292312282741, 0.9224315076209505, 0.9222136492925181, 0.9240459629844029, 0.9305199100354906, 0.9297672832783781, 0.8572394597642865, 0.8693366761284627, 0.8119090000891779, 0.8683110089611252, 0.8684527177692238, 0.861504779532587, 0.8475185118362467, 0.8400548153076073, 0.8517031559348912, 0.1600595342939023, 0.11116342354365005, 0.16139730372664984, 0.1607723391765683, 0.11667795818776194, 0.1892737594806585, 0.18691562229946246, 0.18689117820254952, 0.8025678609222918, 0.14579256402069363, 0.08331154164213406, 0.18649232044833997, 0.159945288259565, 0.10569184498895379, 0.09145997259150807, 0.18174588821152526, 0.12415601844429625, 0.13967614323585753, 0.9937984632267256, 0.9876756569431983, 0.9859269927333733, 0.9736720596757042, 0.9838843863235303, 0.9874272999630428, 0.9833950850091333, 0.9825633574934043, 0.9877554195298806, 0.8177883557970853, 0.7352661427065783, 0.7735221248568802, 0.7909356006628255, 0.7173594662338676, 0.7608359541742243, 0.4434951547046343, 0.4678040622546362, 0.6547865743376546, 0.22985032643060554, 0.24813237546660838, 0.17222064591395525, 0.2341808861936523, 0.15586353923147744, 0.17632212474299047, 0.8278896232922132, 0.17893713984913318, 0.23955875048278186, 0.7074010403134927, 0.7181373937843931, 0.6700858670043365, 0.7440977385861162, 0.6311793369649176, 0.6729178129813531, 0.6734061881626435, 0.1330554853320558, 0.6741508948453387, 0.6566229817329703, 0.6320371859956435, 0.5518593292130318, 0.6839873941592257, 0.7166775328337318, 0.6877405458426751, 0.6855446769273632, 0.682438359312443, 0.670232938371865, 0.0734318907179633, 0.08962894269352106, 0.100739041387643, 0.36192681141189953, 0.4631203126418174, 0.439060326031383, 0.20790753501802972, 0.009598685499579318, 0.27888341801450267, 0.6339376647676229, 0.5599676571452283, 0.43722779569730363, 0.25310667007313536, 0.12916513310879996, 0.16518870318459045, 0.35680865746251444, 0.55280634511779, 0.16806950294232081, 0.09933107499901794, 0.08221696017406699, 0.26890779728919056, 0.25296170515296745, 0.3420951161957151, 0.3212145217527368, 0.2001028897556426, 0.331199830834901, 0.1266503321744894, 0.4395395368265599, 0.3028774406207215, 0.44426599521852617, 0.3727102200268029, 0.3834574478028502, 0.388696160845164, 0.4381828830800907, 0.2930013535589905, 0.3016097853979307, 0.7676376305929025, 0.6379387991555413, 0.673806492191213, 0.7006687336078553, 0.6675391374626272, 0.6069440986731409, 0.7974069781004057, 0.7574336128882244, 0.7891023417231093, 0.10443159019824311, 0.144470802452616, 0.08239390562806004, 0.18352193059742505, 0.12498883123295967, 0.14031772990004665, 0.15884928113712682, 0.14274779124869952, 0.132850217950634, 0.21859464093559766, 0.25279271853146357, 0.18624351558771812, 0.23403910129106975, 0.26494751992271115, 0.3073912639573566, 0.17746869972474633, 0.29998100088149315, 0.15254664630957526, 0.38927448790728636, 0.2928065827152846, 0.46885893846112536, 0.3668328608642979, 0.3259990928714932, 0.3710478823870611, 0.396053230418261, 0.34983739577226647, 0.3163656074437802, 0.2503155036354322, 0.28720909737006284, 0.3798345133570701, 0.24542547382251667, 0.19103000429042305, 0.4202765335823311, 0.22842250148265653, 0.2779891551842728, 0.21590415314807354, 0.25968987990387726, 0.29921735799426075, 0.24957596918959923, 0.2189520785337189, 0.2404860974893286, 0.21477272490066324, 0.25745819778386536, 0.25652130180398103, 0.18977893168607773, 0.8721153910378039, 0.19001243849004157, 0.19454396790114292, 0.25196210148427467, 0.17941457580910392, 0.8387450858775916, 0.24930976114880365, 0.18914785479241525, 0.20210707184500054, 0.9325559480788564, 0.18745502672628112, 0.15792667659370507, 0.17348367811547616, 0.19723835192969486, 0.20053074177075292, 0.14230030355018441, 0.16881387356677657, 0.1664865847477175, 0.9333096465527928, 0.8921880649174716, 0.15547531081630384, 0.11283636767956562, 0.16834135042963405, 0.15576221274289148, 0.1041509068382036, 0.16668548540461803, 0.9072400517530885, 0.1760696458409693, 0.18341932257542537, 0.18613888315985272, 0.1960986171444562, 0.1792792025663681, 0.18028245573817003, 0.2452540709101293, 0.22446794008659476, 0.2518185509500419, 0.09021410936931729, 0.09151711474229873, 0.0996931975536518, 0.09816824146957848, 0.111299356246637, 0.07975024326122471, 0.13370409828204632, 0.1006925421433742, 0.08701063232993633]}, "mutation_prompt": null}
{"id": "e9387e86-b769-4b5e-aa71-6ae8615ed8ac", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.2\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.6, 0.2, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.6, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMultiStrategyOptimizer", "description": "An adaptive multi-strategy optimizer leveraging strategic memory and diversity-driven exploration to enhance convergence robustness.", "configspace": "", "generation": 87, "fitness": 0.4782098446692884, "feedback": "The algorithm AdaptiveMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.32.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9387046178558623, 0.9110506739435561, 0.92112258939777, 0.9198806830683565, 0.9244009496773963, 0.9202358110363618, 0.9242168737292781, 0.9281143629879833, 0.9199651561934488, 0.8206037700450803, 0.8447625035733424, 0.8421377022087291, 0.8304732723169652, 0.844203171187249, 0.8465365319808235, 0.8296591336462908, 0.789074302900103, 0.7825513073861298, 0.1322317398795393, 0.12226264637026829, 0.12288643052679926, 0.1595841490297507, 0.16151846567545636, 0.16339950881271847, 0.15640085965945927, 0.15858604486346506, 0.1436048482249178, 0.14353403790150565, 0.10494288232195026, 0.095319351025268, 0.11098794486399333, 0.10071334912148266, 0.15729717154690825, 0.18492293906763213, 0.15778750006733522, 0.14453222153075107, 0.9762731285663182, 0.988724745787857, 0.9881787765736916, 0.9848764172140977, 0.9740137032583044, 0.9841639067809713, 0.9813545250690087, 0.9891744699619153, 0.986357703152909, 0.7497498741726593, 0.7627229734105891, 0.7671888724948746, 0.7966058574350616, 0.8156662072482538, 0.7691661532809589, 0.8131810754071362, 0.7362646753175874, 0.7408257478851404, 0.8751965415397069, 0.928048193358417, 0.8758894046755801, 0.21406746324822712, 0.38095424744728057, 0.38091093290552847, 0.40593048634894857, 0.4043093506497665, 0.9019841301787231, 0.7516155308509485, 0.794783570461499, 0.7189031056703387, 0.773159949641785, 0.13398309681709653, 0.7715146593071802, 0.7425514079688502, 0.7261894805980937, 0.7744992522591443, 0.742192857738396, 0.7848449674366064, 0.7597761485762234, 0.8390251024524542, 0.7784877547993143, 0.7280910192798745, 0.7786070075456417, 0.7763012133195245, 0.7808295626851584, 0.21588561069680368, 0.1867929825042074, 0.6436587431122245, 0.6915332851657805, 0.6866123642565278, 0.6563767952910711, 0.23304746599428094, 0.13908579962435774, 0.7302549583381643, 0.5183195459853229, 0.6878803273167837, 0.7609126685964297, 0.8073400286371585, 0.6342099310791316, 0.6568574054283942, 0.8266472859944783, 0.7825594133000786, 0.7637402815124562, 0.3227016106462598, 0.2249446841399908, 0.17253387642091422, 0.5392286573189544, 0.45254247885774157, 0.369147911542834, 0.22851495372471964, 0.2617163629238466, 0.1618817411217497, 0.49862239621212956, 0.34845613433111067, 0.5001188360082158, 0.48421604223773496, 0.44994652918653, 0.46773044215220183, 0.4545152934007416, 0.4078699590642403, 0.3604763850748339, 0.8737748257842641, 0.8826921943429918, 0.8338851147179611, 0.7640396302503508, 0.7138114738855642, 0.7010673474941091, 0.8691082606263638, 0.8540490530820778, 0.849338791710233, 0.10972879615159103, 0.11549483902190916, 0.09806098278260866, 0.09689426169845028, 0.16031003786541476, 0.11702004068254279, 0.1443367034105666, 0.15989022657881846, 0.08606611522502194, 0.21050599635695222, 0.22078439614048406, 0.19905057401786286, 0.21423516069668225, 0.2115127631562399, 0.24671951778404766, 0.20352636744234887, 0.14404664362172548, 0.2032828043967615, 0.2891835295162474, 0.3268333592830509, 0.38172117537701544, 0.42314332525227927, 0.31234254205277867, 0.39518600376759194, 0.485748476223411, 0.2546118796728627, 0.23041381543965855, 0.23093447018810975, 0.19410427639600325, 0.3145590857427156, 0.2173176260658124, 0.24357394621547224, 0.286694472522525, 0.2912572436890739, 0.2557177883871081, 0.14370941669332282, 0.25434669582155467, 0.2683760638706745, 0.26427678300226176, 0.25589094302194526, 0.2823748805966213, 0.23301094471978978, 0.21795154560078134, 0.23213161112465464, 0.2141122424739852, 0.8702633096329684, 0.21242132096815336, 0.2019330895302407, 0.18957328548119667, 0.2116994084646282, 0.19580468599003764, 0.2255723691105539, 0.18328733902063532, 0.1881282106892661, 0.9469185150153228, 0.9358965328333797, 0.15355053190521994, 0.1883006159882341, 0.8706337091294312, 0.16582382914924643, 0.14217466613856578, 0.16416193240642063, 0.920403651983843, 0.927243321523642, 0.21268951311531237, 0.9259368508472735, 0.2125466396456629, 0.8889388908797615, 0.8781021045298828, 0.2135269888094956, 0.9055867099562962, 0.9176395024939675, 0.18155921039515543, 0.18252373664494526, 0.1773764949132134, 0.16892065336049678, 0.18274902449521924, 0.17540343204407072, 0.20368449828978896, 0.1962857681652651, 0.24795997832754224, 0.10341916354825642, 0.10894304835305268, 0.08073480350880469, 0.0837318279313164, 0.07545072620712456, 0.08992881867723923, 0.09251100977057725, 0.10178756122461363, 0.09662216422974301]}, "mutation_prompt": null}
{"id": "83fdfbe6-e485-412b-bcf5-cee235fbd6d1", "solution": "import numpy as np\n\nclass HybridEvolutionaryOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.85\n        self.crossover_rate = 0.8\n        self.memory = np.random.uniform(self.lower_bound, self.upper_bound, (3, dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 12\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.55, 0.25, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.55, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridEvolutionaryOptimizer", "description": "A hybrid evolutionary algorithm combining adaptive memory and dynamic population strategies to enhance exploration and exploitation balance.", "configspace": "", "generation": 88, "fitness": 0.41242667523982207, "feedback": "The algorithm HybridEvolutionaryOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9140264397174356, 0.9163442237396546, 0.9191160434533944, 0.9228500043360666, 0.9236332677776251, 0.924095417420882, 0.9187133292149597, 0.9263628999699298, 0.9260345638708484, 0.8530266615715707, 0.855874247625857, 0.8773226186706432, 0.8567699898024811, 0.8616797764221242, 0.8341707228859899, 0.8572489980702436, 0.8593574871888388, 0.834930823150976, 0.16111052103674606, 0.11599034208952219, 0.1252325724139498, 0.18451939535357265, 0.15448545442097106, 0.1575042947581018, 0.184744507239621, 0.1175929618779934, 0.1449563088727982, 0.13338811115251903, 0.09970489833830343, 0.13287042512601732, 0.13141472176713176, 0.14432694274863156, 0.13073382979670856, 0.15752791527000898, 0.09583898164141358, 0.09562775487419573, 0.9903684090946396, 0.9882926401018424, 0.9844695233910572, 0.9927090715750018, 0.9713270567640284, 0.9767062271413283, 0.9847543301419425, 0.9879028205156022, 0.982246120254479, 0.7750861372122863, 0.7765121752446698, 0.7244276735506299, 0.74869871694423, 0.7490344905294767, 0.7815796461367508, 0.7418024783523478, 0.8278380020090899, 0.8138993781077107, 0.22847947568717486, 0.9309704683516772, 0.2296672992892249, 0.21278255158942216, 0.8891400071949856, 0.21310812222708286, 0.22407388274680828, 0.8128067812685497, 0.8858406794289275, 0.13373684905062377, 0.7329191044299304, 0.5152493624729511, 0.6031355554433802, 0.734296097205428, 0.13367449353621919, 0.6270389857234715, 0.6292982037689511, 0.573597124799432, 0.6230432699341113, 0.6285461459292738, 0.12986424267730545, 0.6981482667056471, 0.7959201949894252, 0.13310821697902286, 0.5809877858187138, 0.12860250629488168, 0.5429414697025822, 0.15589733128014327, 0.1551057640078427, 0.13547359224212796, 0.19567406824207179, 0.499101706584297, 0.2562611510352911, 0.05797498571514392, 0.3289198646599196, 0.22472166268816185, 0.6602354667727057, 0.42489223296437817, 0.5866987832692001, 0.11950163002729153, 0.12368328792519734, 0.16275517733525324, 0.6236900476219943, 0.5379156848372015, 0.4302875905100435, 0.08027832634476184, 0.09886548280265428, 0.1616466468486859, 0.1171241785313949, 0.4527264606131638, 0.3546258288119968, 0.21865375837669654, 0.3114275014632977, 0.3543635151669511, 0.29122974565303883, 0.264583998909361, 0.38223926780093564, 0.2483937429780224, 0.30511489805443504, 0.35605510224343184, 0.21618552511349254, 0.32432034163050394, 0.21920616235639456, 0.7056522033707417, 0.6160153103069906, 0.602756702834156, 0.7555055296719844, 0.7305467994214137, 0.6883955217452945, 0.7662816207411385, 0.849605868419093, 0.7933048344029126, 0.16382518809916635, 0.07959344825244064, 0.09170400163753367, 0.18769380315174689, 0.12730817609816025, 0.14367529029275283, 0.16127287885501085, 0.12517206735463315, 0.11765909243746375, 0.16386778389401058, 0.6475898293746087, 0.15259322546819365, 0.23402515350831143, 0.2076343624808391, 0.22278052105029222, 0.2646732981197296, 0.15116860577734748, 0.22548176703587985, 0.45612996087369273, 0.30266540204510683, 0.4081047505177249, 0.4815837138234377, 0.2086612483813839, 0.29155740067442404, 0.38309211917676267, 0.4317487594196079, 0.4950883211738336, 0.3196432614683521, 0.31656061255960044, 0.3075066433606014, 0.24474579884985082, 0.3409722189166057, 0.34882488222973806, 0.2818766353974105, 0.3365196343961242, 0.24140236512230773, 0.2336856906309952, 0.20796140735063928, 0.19736651618492973, 0.21917816813404267, 0.1982372564939281, 0.23308521779832958, 0.21378008207566968, 0.26452625280450504, 0.209159206142014, 0.2123292430070408, 0.19956929698197368, 0.19060661370837528, 0.19358178055284792, 0.18772531638107492, 0.2251928803535016, 0.2172268994032459, 0.19739197400783925, 0.17534501724517126, 0.9235638024895885, 0.20017611551303183, 0.17297835437354592, 0.17209114935801206, 0.19984390359179538, 0.93525884152105, 0.9013529569852644, 0.13595702187891345, 0.16761569268287368, 0.925847235390097, 0.9031063943989245, 0.8634940353326178, 0.12747874391184122, 0.16799648298064096, 0.15468869422949683, 0.21422448105495384, 0.21233929453041256, 0.88930084630919, 0.20388430454450923, 0.18206800173104398, 0.1966168500505704, 0.1807372657387828, 0.17939705595821032, 0.17112019669493728, 0.21877911301550967, 0.21723310938806695, 0.19358410520176106, 0.0836542600511373, 0.08902802221135697, 0.11960324916773901, 0.10820825687551316, 0.10022026801763118, 0.10448005269940608, 0.09170947483264702, 0.0861066568286658, 0.08841212541977128]}, "mutation_prompt": null}
{"id": "6e6fe690-424d-4207-91d9-6dd3ec4db78e", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 8 * dim  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]  # Refined probabilities\n        self.adaptive_factor = 0.85  # Adjusted adaptive factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15  # Adjusted diversity threshold\n        self.stagnation_count = 0\n        self.max_stagnation = 8  # Adjusted max stagnation\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicSwarmOptimizer", "description": "A dynamic swarm optimizer with adaptive mutation and memory-driven exploration tailored to maintain diversity and enhance convergence.", "configspace": "", "generation": 89, "fitness": 0.4314065560512202, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.31.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9221692736848963, 0.9277525274422281, 0.9241543363313657, 0.928326993670944, 0.920969154585206, 0.9355274670956993, 0.9143876377825798, 0.9380678325500854, 0.936602680853734, 0.859287878209338, 0.8619384977045612, 0.815808793727087, 0.8691289328278511, 0.8770865525562314, 0.8441806938619617, 0.8177395506666816, 0.8582329006483987, 0.8564083714792107, 0.1103652688075466, 0.1317348788368865, 0.1614737963819174, 0.1228728273860843, 0.17640248062490427, 0.15870645685639506, 0.15913575721078943, 0.16108555307821004, 0.11700781947071459, 0.11597915753449217, 0.09539021792333002, 0.11129716748404628, 0.12283185910882333, 0.12420271554102214, 0.13370321191972978, 0.10939881285639186, 0.1425057888098905, 0.12417969617494418, 0.9937984632267256, 0.9905743178181928, 0.977903608548544, 0.9833699621323414, 0.9831640541221273, 0.9834324194865978, 0.9869975087032834, 0.9829396813144702, 0.9861774799695637, 0.8385096570594701, 0.8095878558090018, 0.8059284696312016, 0.7777836346062663, 0.7820415384056234, 0.8055042789829983, 0.8448139709327123, 0.8046410446322931, 0.8246240047187529, 0.49599563678589764, 0.3860087743019559, 0.17212271431821136, 0.19344554034462091, 0.21301246451480726, 0.2132653179685905, 0.23477670350063018, 0.2274671132441216, 0.920070044624391, 0.7680309731859576, 0.13390914224913542, 0.7170387577454632, 0.6785529346236507, 0.7387823997986547, 0.20165310790724245, 0.7926436525534684, 0.7027352807578044, 0.13372594258164172, 0.698314305223984, 0.7647743780528165, 0.771053797176468, 0.7325561304824841, 0.7739850253815197, 0.77587424031026, 0.7938940371179519, 0.13645457230072022, 0.6794359613945683, 0.07989768951883147, 0.13566335867546442, 0.19049470604567964, 0.14351565567058022, 0.4285514313101143, 0.5292380077439744, 0.26774733704507037, 0.34003518667527155, 0.3222292941535695, 0.5295919045433741, 0.6386672789110859, 0.32998774134126374, 0.402055756030707, 0.19073641547724263, 0.5156940327305204, 0.8092125147579788, 0.7540394943151267, 0.5896861033534235, 0.4002816574040233, 0.12362097685450213, 0.14571396315866658, 0.3306033468539026, 0.5029201266511, 0.3074551743955686, 0.2245807796462036, 0.2958889952728999, 0.14522465469638102, 0.4192800379878511, 0.26675581135164816, 0.3204952778377971, 0.45612107252410805, 0.41861799536633293, 0.2517197905306384, 0.30186008584031365, 0.5206290412274308, 0.32993774547225363, 0.6456685810507976, 0.7318316536887897, 0.6435342708167597, 0.8006651869966978, 0.6846783221430792, 0.7680322968566589, 0.8582484538973255, 0.8369961169590164, 0.792647339233918, 0.16036258633243428, 0.1168100222968591, 0.10988984408063174, 0.13351336126480762, 0.11312173085740285, 0.14373681618226508, 0.12441718849672834, 0.1411443523389473, 0.13291301899449537, 0.14950926581283397, 0.16092966880485526, 0.36339420693927127, 0.15472538512156442, 0.19432278584379814, 0.19401396130573356, 0.2521409516581681, 0.5381940163049781, 0.1678551847684544, 0.31820337992191505, 0.4264969044302901, 0.30300692297921883, 0.3534095730716643, 0.3222891381681495, 0.3148993495325858, 0.39273436507015147, 0.49341505269901054, 0.4248609896681337, 0.32834788288753747, 0.20986448945359282, 0.30618067508826796, 0.23103956324508057, 0.28398679063519583, 0.18701593141594408, 0.28749758480771226, 0.262247912595444, 0.23549130001043395, 0.3025588268078656, 0.3266327757196301, 0.33413359965401646, 0.2239274729020554, 0.2620234494835634, 0.257122443549165, 0.218882355512378, 0.2393477319293702, 0.24969764357548385, 0.20398218056643636, 0.22398825667146083, 0.19328461701659094, 0.19162468383513198, 0.21079681646578674, 0.20815939790436944, 0.2555060446810661, 0.19998046903106237, 0.2025293705212753, 0.18815310692612763, 0.18795028836554206, 0.1538000487971911, 0.1734674493715671, 0.19878610451487155, 0.20057244939030916, 0.9126497967935561, 0.9401818562870513, 0.9319554017494188, 0.7203683657919502, 0.9024187123519702, 0.15570378546588348, 0.11271746252494108, 0.8986868633662225, 0.8770532650369496, 0.16762545446329313, 0.16798196708712643, 0.9339095527525416, 0.2187271994016311, 0.1825411754121099, 0.19684181704368175, 0.20384698652541133, 0.19257290192095144, 0.19812458122412235, 0.2091525500925997, 0.220550092457247, 0.20613559856078167, 0.1232109332196355, 0.12240028863941466, 0.08425627038380479, 0.08575867424485495, 0.10410196075297296, 0.0783689902225635, 0.1026018871725548, 0.08944058244007524, 0.08657429415606144]}, "mutation_prompt": null}
{"id": "dffb326a-b2c9-4cf9-8ba2-3145c8f2002e", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.1\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_exp', 'rand_to_best_1_bin', 'memory_directed'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_exp':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'rand_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_directed':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_exp':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'rand_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.2, 0.3, 0.5]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveMultiStrategyOptimizer", "description": "A multi-strategy swarm optimizer that adapts its mutation strategies based on performance trends to ensure robust exploration and exploitation.", "configspace": "", "generation": 90, "fitness": 0.4649731645667799, "feedback": "The algorithm AdaptiveMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.32.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9231232023909339, 0.9189911420323467, 0.9247626720482288, 0.9253593469388817, 0.9370406366196949, 0.9258988471736405, 0.9263773170930422, 0.9278311468193512, 0.9214094029898592, 0.8641957484750835, 0.8756906998702411, 0.8309306979543526, 0.8425556587364386, 0.8454359202735557, 0.8509493611516616, 0.8243331287571687, 0.8474770679146564, 0.8257759289988515, 0.184936561266567, 0.08232566071107195, 0.15846680570464433, 0.12001222517254717, 0.1411232205761902, 0.15578830649153785, 0.18862877442267723, 0.17501139703183233, 0.14421885830975134, 0.04495320468234476, 0.1153909163076543, 0.09686894011340486, 0.13593953511458712, 0.12095986403725745, 0.17332358108160262, 0.14343605321630948, 0.13168163180939174, 0.09574157457440491, 0.9780156159090606, 0.9859643003838499, 0.9875936461541486, 0.986711898483214, 0.9783997975285069, 0.9814488374191884, 0.9775229812016148, 0.9896322024979866, 0.9798532960452221, 0.7486228621743443, 0.7950684079275935, 0.7728790336502566, 0.7848380256928507, 0.7987471712642038, 0.7834453687308052, 0.836339092921368, 0.8182962995201603, 0.7827205641255612, 0.23063497566415636, 0.9013859651989051, 0.3862236442503164, 0.2809357437413621, 0.9357990369984501, 0.8733451210991227, 0.888562062679178, 0.9303101354933976, 0.9314094473688721, 0.13539879192691273, 0.7880863114826249, 0.6762184679013644, 0.8302545025312567, 0.8456906820931013, 0.7491688566882206, 0.6757389530893072, 0.7847564571755732, 0.7956339674269036, 0.7445505899369733, 0.794394655896372, 0.7259014709652278, 0.8256044988820709, 0.7217616847604693, 0.7203902789099004, 0.8234893402048149, 0.8097897432387439, 0.7278348230537056, 0.4922558775561573, 0.1372650180806848, 0.736651486347389, 0.5437577872061444, 0.7127379294888737, 0.42537880044860454, 0.1401083501767425, 0.7647530903941206, 0.6746333998170906, 0.7997933780918657, 0.7101707538524464, 0.7662562484941999, 0.7773547690241089, 0.17928256010265597, 0.7708604838273097, 0.8065035636895787, 0.7937356834473797, 0.8219500475796604, 0.10487484595760121, 0.08509770882122047, 0.365073652804243, 0.5796862552718561, 0.3484549898792255, 0.19386483597191528, 0.25907210538528325, 0.18651737833057136, 0.3457837330031529, 0.26858143509553956, 0.24798208741940486, 0.5952410586912177, 0.38764277056219987, 0.4949757654952821, 0.5834140684582179, 0.4519996948204583, 0.3249651407277051, 0.32401208391245817, 0.8415718455987418, 0.6900850775384124, 0.851857277543478, 0.7545101767937148, 0.7622535807989627, 0.8359443661857356, 0.8792732059405828, 0.8652972427031523, 0.8662064890825462, 0.082913382933401, 0.1133310341558561, 0.11748747842021456, 0.1335499772093488, 0.15683567323582648, 0.15626859678605887, 0.14132528044162374, 0.12593416784634937, 0.10594288843971766, 0.22563098245182156, 0.17484928560483803, 0.19075699096558607, 0.18869151269480056, 0.33891325107229464, 0.19208989439794932, 0.23581633976262084, 0.45198947583151095, 0.2802353792148813, 0.20892109037015116, 0.39949261312420226, 0.335647229741875, 0.38041296249665435, 0.40924188376226134, 0.47666797092949265, 0.31308848164448777, 0.569967537240868, 0.3044340900428636, 0.17937584337056556, 0.20277473998472317, 0.4864000604638531, 0.2465354824555972, 0.2886872221505752, 0.48445956504972787, 0.2449335402936138, 0.26724312448364385, 0.21148870615140025, 0.27053449107665184, 0.2389752535038936, 0.2092644979695245, 0.2508337092896711, 0.3626337437978715, 0.23778503625653669, 0.25075811308058615, 0.2320015280487674, 0.2324532677563692, 0.17669943620397188, 0.1737574941032788, 0.18152462430007, 0.18613213753858993, 0.16884422458224435, 0.19651591280874536, 0.1808268209568722, 0.18837921902283306, 0.18912503899428634, 0.9474281370136408, 0.1775232771564217, 0.18761261537663776, 0.1884064145411931, 0.1981693419892525, 0.16621321148505286, 0.1765139911058573, 0.16439300190272188, 0.17669758135455338, 0.9269329645651107, 0.16895884995989185, 0.8752666876460874, 0.21224741674800784, 0.16821842453484037, 0.8539002757137918, 0.21259126032219244, 0.21278265209612224, 0.12797795965528835, 0.18218670180754626, 0.19364414557449383, 0.19576094271219535, 0.2001979900924189, 0.1781887470139354, 0.17271255132043628, 0.20327828534307646, 0.21410165588876906, 0.1991066998494584, 0.11334655598476162, 0.10359452152628856, 0.0902692447287411, 0.0735359020248465, 0.0735396964017444, 0.09049528238945337, 0.09796735589932282, 0.07836797264665163, 0.08869419997473282]}, "mutation_prompt": null}
{"id": "f3e48069-c04e-474f-82ba-f515bef8b5bc", "solution": "import numpy as np\n\nclass AdaptiveLearningSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Increased population for better exploration\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]  # Adjusted strategy probabilities\n        self.adaptive_factor = 0.85  # Slightly adjusted for balance\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15  # Adjusted threshold for diversity\n        self.stagnation_count = 0\n        self.max_stagnation = 8  # Reduced max stagnation for faster adaptation\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.5, 0.25]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9  # Increased adaptation rate\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveLearningSwarmOptimizer", "description": "A novel swarm-based optimizer incorporating adaptive learning and dynamic strategy selection for improved robustness and convergence.", "configspace": "", "generation": 91, "fitness": 0.4310145917380777, "feedback": "The algorithm AdaptiveLearningSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9131660103091924, 0.9250126697780556, 0.9153796674854335, 0.9131905430133728, 0.9215158551642758, 0.9198045029434267, 0.9249545883284336, 0.9207221268912984, 0.909785852960102, 0.8321646314414375, 0.8457944875780729, 0.8362361987773244, 0.848742722316238, 0.8130484670803214, 0.8258744891068794, 0.7905714468507349, 0.8319322548158357, 0.7924801562047046, 0.09620278818236638, 0.156211250289087, 0.1420933135972524, 0.1216781836561509, 0.15712950119372704, 0.14237631166318554, 0.18901568177111538, 0.13537132926164208, 0.0803690943668407, 0.10887428564090329, 0.09703965773002143, 0.13212987246595953, 0.10923534844136507, 0.11701108746731426, 0.10491332661012165, 0.12981735540083827, 0.09215342902112567, 0.10267586187394151, 0.9841512958104405, 0.9786386975587875, 0.9759414619134822, 0.985903128019366, 0.9728117465432022, 0.9707300267857764, 0.9759437134124586, 0.9757746446301396, 0.9807362466695323, 0.7608635162594745, 0.7727881413688922, 0.7282756767523249, 0.7700079404594495, 0.7515594650650194, 0.7529665718893973, 0.7921990408024155, 0.7631007587683025, 0.7692896781768398, 0.22792409362304866, 0.8903060919905561, 0.39448329808116933, 0.27749730625443214, 0.9111066765381634, 0.20787844925386412, 0.23644899528910124, 0.17654579153041505, 0.2262030565930725, 0.7230707245523484, 0.7097981982007484, 0.7250233281452498, 0.1320425691448781, 0.8137023554233889, 0.5640949551390402, 0.8296953913468845, 0.5673805872149048, 0.676311481078759, 0.7028691967371777, 0.6948688756021546, 0.6053823180131018, 0.665151800791461, 0.5716112134700453, 0.5374974019109477, 0.7652498662825736, 0.7646561885117176, 0.7048091475213009, 0.11592053830952298, 0.11975912190651472, 0.2333421722879132, 0.4875306639232171, 0.5916431972033678, 0.19043485763762036, 0.5828181808706188, 0.4696471744948707, 0.2962415941331602, 0.535777226757544, 0.6644503403008284, 0.5401090273886737, 0.5434454440774359, 0.3082613730801895, 0.5492800108854463, 0.7152658886990397, 0.5768642272791109, 0.6595314788381978, 0.5857131443456787, 0.09645739449100998, 0.30997564674899136, 0.522933611824264, 0.47350496133881015, 0.3602685308345537, 0.34850450264941857, 0.34761477877294933, 0.1472550137025055, 0.2097730317533527, 0.30268790151097047, 0.38396603540650154, 0.325037727794635, 0.44744771147923734, 0.46543130866702553, 0.3242245514382509, 0.3796887889888877, 0.4317517821126159, 0.7852387043656197, 0.8392495783454564, 0.7655463257605638, 0.7509546044028448, 0.8059380724040374, 0.6740639278872985, 0.8325973275101588, 0.7496904667324149, 0.8176912432546215, 0.1059655444668568, 0.10919958353370107, 0.07047106480669085, 0.18650116534284866, 0.11557152852465569, 0.11900556086746239, 0.14041090321620975, 0.1174423045917774, 0.08306711602904304, 0.1733325065523672, 0.19173575176226654, 0.14200498096684, 0.17236451842443834, 0.21859813546906903, 0.16263770834922475, 0.19855558870439038, 0.20553969042911735, 0.2398006730717136, 0.3842056925408155, 0.5244617892150023, 0.40813842310025006, 0.36679947654493095, 0.32299284236591586, 0.2424841870746437, 0.5048524414713498, 0.29880031723658007, 0.4485285966408845, 0.41087080548295474, 0.28701052479902367, 0.3526457716573682, 0.31465884968076874, 0.24496517344811075, 0.21926844220118025, 0.2681112026233827, 0.304723187894394, 0.20144227936237225, 0.26155657603161464, 0.2998492348638827, 0.34688656079499125, 0.25118688349152185, 0.21523861224236263, 0.2154355770389731, 0.25046125511253226, 0.22370805441295383, 0.3541047164090846, 0.1843071200958194, 0.19278006975125184, 0.18349174088602394, 0.1798244454250305, 0.18660243765721019, 0.19832681257554752, 0.17793990114783487, 0.18034745058979718, 0.1829310102306395, 0.1876087024652966, 0.1875191474059752, 0.16809400868219726, 0.9295707523589598, 0.19987077735042802, 0.11494614280043713, 0.8680205808707147, 0.16922119634566646, 0.9353310500101093, 0.8982358156486638, 0.21243506865378026, 0.20958955673452728, 0.20939519540045515, 0.2104436710508567, 0.15485403877409043, 0.10437207245861169, 0.9178253215306156, 0.21268467463943286, 0.18221871373591225, 0.18437555441348052, 0.17589093830191882, 0.18738238323933232, 0.18347700784011411, 0.17904355510428505, 0.1838472334507596, 0.20749078192483084, 0.23909722346020057, 0.10137868183326337, 0.1068010139961525, 0.06507360937757256, 0.19582883750349478, 0.10207718625059037, 0.15107884642684044, 0.10453387263084302, 0.11145143810757929, 0.08444972604127321]}, "mutation_prompt": null}
{"id": "7fcceede-1041-430f-90dc-62e94014e91a", "solution": "import numpy as np\n\nclass DynamicExplorationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.3, 0.3]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((5, self.dim))\n        self.diversity_threshold = 0.2\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.25, 0.25]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.5, 0.25]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.3, 0.3]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "DynamicExplorationOptimizer", "description": "A dynamic exploration optimizer leveraging adaptive mutation strategies and stochastic parameter tuning for improved convergence across diverse optimization landscapes.", "configspace": "", "generation": 92, "fitness": 0.4560486344380824, "feedback": "The algorithm DynamicExplorationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.31.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9031325224867406, 0.9166192266932299, 0.9184843042013824, 0.9030124050866043, 0.914332265347774, 0.9129736760902534, 0.9139351297273273, 0.9273002339329314, 0.9207633943785971, 0.8276124024768002, 0.8347806596385032, 0.8328501281858239, 0.816427280644369, 0.8176440150001388, 0.8261393593994548, 0.8167839948107436, 0.8339106273757463, 0.8064672623733976, 0.1843982196153341, 0.15854636149911816, 0.18015938030304168, 0.13875035821318293, 0.15480699815829935, 0.179664104835061, 0.10885599910656418, 0.16154876608800173, 0.15865907440960858, 0.10796496461532734, 0.09965596893584938, 0.14153673426691116, 0.1367054421649937, 0.09827299506533071, 0.14339607014086564, 0.1424952367333553, 0.13210027109879718, 0.11556850096545823, 0.9899764067527945, 0.9790663319235301, 0.9776528290848692, 0.9841518627412493, 0.9850501753071347, 0.9754828381673237, 0.9840637151410085, 0.9900957125466381, 0.9718028035986244, 0.7504206133564258, 0.7441305473297795, 0.7565618980645716, 0.75279667238017, 0.7802080317451316, 0.7451509201915141, 0.8065421814011076, 0.6784068842950156, 0.7958337049868709, 0.36183421951944517, 0.8803811251722856, 0.22865480278649675, 0.9092873663610109, 0.8414704023164306, 0.2133535150039415, 0.9067889851025466, 0.9174746173402802, 0.8754233887867615, 0.6066756872097471, 0.1328274160877687, 0.6735686905314913, 0.6641009748729816, 0.1350120590701086, 0.6800068436125168, 0.7806107618703415, 0.6917309571652822, 0.7704626160070747, 0.7518368755012624, 0.67438698195613, 0.7229573306559864, 0.7212876920759645, 0.6773436934737925, 0.13701837786820814, 0.7008319196417476, 0.6737238299623476, 0.7122984516064503, 0.6926566637709015, 0.09895286818387716, 0.21700210329637326, 0.07381701623385672, 0.5530556644271212, 0.6083311334515658, 0.10987717630830851, 0.1948770928624466, 0.23696002800233518, 0.6928110892861952, 0.7126275341846326, 0.7038223201888262, 0.7597251525076314, 0.1471908708069385, 0.38229411260940505, 0.774166202920263, 0.7290507104088987, 0.7878177241449197, 0.2305802396291753, 0.15432795671154276, 0.15053047498417016, 0.41649749939085146, 0.36877505813782785, 0.36825385474774674, 0.23171269233312353, 0.4198014074844274, 0.20230304690392265, 0.52137956008968, 0.35773599752541585, 0.48254130756506197, 0.43558672616201477, 0.26967088360975167, 0.29345700962845056, 0.08959205738690212, 0.33481013479977806, 0.44712374565171364, 0.7206169744111637, 0.7403939159692436, 0.6694336105637597, 0.7697815211042758, 0.6504615697052547, 0.7523550066155084, 0.8089344807437412, 0.8446150738040378, 0.8599410231013405, 0.09848680828285528, 0.1431600226262908, 0.0766490311466701, 0.1306600524313959, 0.14565453115940308, 0.11459152809807749, 0.16304200907480115, 0.15807068824670711, 0.1340068053664658, 0.22502547147549268, 0.3495951745410545, 0.21708909769914808, 0.1894360279257582, 0.2687489480053509, 0.16699439994866694, 0.2291878853572219, 0.30079841259589024, 0.46586394547676246, 0.4880198990529925, 0.3780617168992815, 0.5550661176250886, 0.6051879247924755, 0.47828115891700507, 0.5680687166201355, 0.4996847881928277, 0.4270377684522976, 0.49435412349942354, 0.291521315644125, 0.2647603531736654, 0.31641731480502444, 0.336619285882621, 0.3427640500292456, 0.3987995403033229, 0.2037202591190257, 0.25126966948506346, 0.2818380667712722, 0.25258591292444943, 0.21215582683044154, 0.22718302152898906, 0.2248648436229167, 0.23346042906712738, 0.24643327454036557, 0.41750319283515336, 0.22821072765927797, 0.22167573294709875, 0.19800508596308708, 0.1929599180708378, 0.18514269561699626, 0.20573669729158062, 0.22526228149381144, 0.19660055489191064, 0.18427534309459648, 0.1963808520923469, 0.20764942978462608, 0.21176115192266387, 0.16790789241896453, 0.1877451955888435, 0.1522084194504525, 0.19874094299769585, 0.9374143151913332, 0.9051597612793235, 0.1985706026435834, 0.9435374094815567, 0.9290526433883948, 0.21224769325833215, 0.9081408347630577, 0.20792528672544253, 0.8857653096843546, 0.7792029487697061, 0.10489159587421859, 0.16841076105073138, 0.9385782485418591, 0.17895745734620072, 0.17844716797863946, 0.19306719386783067, 0.17571956609602346, 0.19320915917312853, 0.18848927272442229, 0.22974486321116083, 0.21291477406201953, 0.2068741501846758, 0.09171249864105047, 0.11401717692478819, 0.13298128106562068, 0.11748548468951792, 0.09358305920859933, 0.13783970933108192, 0.08394735291849154, 0.09228655383899442, 0.09210223836307319]}, "mutation_prompt": null}
{"id": "2db8b136-59ed-43d5-aa05-4f9c5bf6708f", "solution": "import numpy as np\n\nclass StrategicExplorationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim  # Adjusted population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.memory = np.zeros((5, self.dim))  # Expanded memory size\n        self.diversity_threshold = 0.15  # Adjusted diversity threshold\n        self.stagnation_count = 0\n        self.max_stagnation = 15  # Adjusted max stagnation\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.2, 0.2, 0.6]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.92\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "StrategicExplorationOptimizer", "description": "A strategic exploration optimizer leveraging adaptive disturbance and memory-guided search to boost convergence efficiency.", "configspace": "", "generation": 93, "fitness": 0.43922783243996716, "feedback": "The algorithm StrategicExplorationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9147651936671622, 0.9071000552491149, 0.9119094593280227, 0.8969789748388478, 0.9040729956994508, 0.9022183016204325, 0.9202550662560401, 0.9014698824671196, 0.9069153684288432, 0.8137981735067465, 0.7982141140497085, 0.7890731954939547, 0.8051926864825907, 0.8236529417384002, 0.8117507585430388, 0.7993681229835007, 0.7796780129413364, 0.7881708789077324, 0.12038250781591797, 0.13936351982863038, 0.1212221316708717, 0.14291736417767786, 0.11485548875395979, 0.1574925949195164, 0.1372159300772231, 0.1442522455562546, 0.10904539136297697, 0.11963346931778118, 0.06962503925810748, 0.10838790341646454, 0.1262007604552231, 0.10645274996259868, 0.1434588674870676, 0.14917222986317535, 0.12488794990847496, 0.08263945791100158, 0.986420649460905, 0.9773723319484598, 0.9733127890205848, 0.9904093196999311, 0.9863174415940275, 0.9695104560323161, 0.9864647798017981, 0.9770127832125878, 0.9832986520943129, 0.6943863112398996, 0.6792058389174029, 0.706198233818665, 0.727486076129372, 0.7233359387245584, 0.7155349027133204, 0.7526754542664287, 0.7600904400841244, 0.7305229153627616, 0.22920998422081607, 0.35980793670702305, 0.1415011495858549, 0.2820593935446677, 0.8987228516147668, 0.214691107184931, 0.3578687834627361, 0.8285664737531282, 0.8374338368077573, 0.7302071864880949, 0.6772768354346792, 0.7032249130202676, 0.6200117213453709, 0.13345152005640015, 0.6498622249444413, 0.4929832307178861, 0.6001552173038112, 0.6357964969665603, 0.6624479740406862, 0.5536441911875591, 0.6752500284239166, 0.6713123463322759, 0.7398411320277932, 0.7131560152008075, 0.7291553310408634, 0.6047175370916703, 0.6544405077004831, 0.628648497318258, 0.44101930230787345, 0.22248601782170108, 0.3709499150404173, 0.5497382037262402, 0.4558945901614918, 0.5842473392299068, 0.14390881282769608, 0.5666067341097228, 0.5622082232769918, 0.6771022847228543, 0.38155699294668144, 0.6695457769027899, 0.6901488207337214, 0.6269133548558068, 0.634720537443588, 0.6072718730823949, 0.5984539696921753, 0.30206757698786846, 0.20078153274510657, 0.1919444185645659, 0.3450455684813397, 0.29508503550023013, 0.14747663807841893, 0.2598379300709477, 0.42119360012200646, 0.35657509627163053, 0.1585105813527542, 0.2922254658275719, 0.26258588556189977, 0.4599440458064279, 0.42922830323585515, 0.3800030728115913, 0.3349573920163931, 0.33546340497168103, 0.3226609567925195, 0.7249030389353894, 0.8090237627874954, 0.7662078172198383, 0.7532823252259202, 0.8022669620079179, 0.8333166085379833, 0.780462830749317, 0.7889121526204924, 0.7580438002175374, 0.12103310615915142, 0.10882488350969766, 0.08772620618140392, 0.10602677880318767, 0.8073952215335031, 0.10983547122561688, 0.12848007988414412, 0.11469741493669972, 0.15482389807871388, 0.15008727931101473, 0.5752242543919652, 0.16979357963600872, 0.2497506424309025, 0.22657161871685594, 0.19404899436373535, 0.2275026474516736, 0.129790247729214, 0.2722210944749399, 0.43573750756244434, 0.28069986719470985, 0.29846007437818556, 0.41963676523754834, 0.33897676111229025, 0.41684218613021096, 0.4283517905373573, 0.29233295456716335, 0.29833752543887515, 0.25219998892473017, 0.39894774300952696, 0.26749463024520814, 0.16710942035745424, 0.3813425969858101, 0.28509176330791675, 0.20132566230408622, 0.45177458511644786, 0.14782433169431297, 0.28290087597319025, 0.2874620227043473, 0.31127519463735254, 0.3080524181928852, 0.2818063508512877, 0.35489499139817604, 0.25317438391774694, 0.2554729794440891, 0.33717864539642317, 0.1844298083797251, 0.22308917452453625, 0.20275528259898778, 0.1956933890372634, 0.19782187842293442, 0.19290437913444214, 0.1666053435887357, 0.20865342854611058, 0.19477532472744574, 0.18596516234290184, 0.18849325153556562, 0.16759415383777032, 0.8827978035208287, 0.19961982965273184, 0.19879836144281327, 0.1413527490889419, 0.21008988703324605, 0.1653639664094868, 0.893744987639168, 0.7669695128339166, 0.8794586353670506, 0.8280794653317911, 0.1667400057866113, 0.1553352330867518, 0.8989212475165635, 0.9020010181253508, 0.16521096611906982, 0.1874485572361677, 0.19201016974147456, 0.17853192740108492, 0.1705915098989932, 0.18239515876773316, 0.17441633630484343, 0.2072385564402699, 0.2075423859597587, 0.20345289175795966, 0.10091269091211341, 0.10826562373054527, 0.09617193609531438, 0.08601564324612354, 0.08425442461886612, 0.06678574274326077, 0.07905833842436716, 0.0906854030980545, 0.09406475561434868]}, "mutation_prompt": null}
{"id": "0b9dbcb8-6e14-4f93-891a-1cf6302ec898", "solution": "import numpy as np\n\nclass AdaptiveDualPhaseSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.7\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.2, 0.5, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-7 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.9\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveDualPhaseSwarmOptimizer", "description": "A dual-phase adaptive swarm optimizer combining global and local search with dynamic learning for enhanced exploration-exploitation balance.", "configspace": "", "generation": 94, "fitness": 0.45006351412784046, "feedback": "The algorithm AdaptiveDualPhaseSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.31.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9256013573601454, 0.9111167975826644, 0.914393796772357, 0.9171304010418947, 0.9142032458733038, 0.910819559487462, 0.9166048718108504, 0.9136148356202362, 0.9212309632373266, 0.8163117396232068, 0.8404839289530464, 0.8266305538902526, 0.8510622985448193, 0.838339721587657, 0.8483113342187811, 0.8433342505767233, 0.806137538701006, 0.7985872823557063, 0.14481126984235848, 0.18345746381270578, 0.14343070395364466, 0.16009126086788583, 0.6092921744761042, 0.1558570583451243, 0.11827954165453447, 0.179878031059718, 0.15125601660980614, 0.04658037200598664, 0.08168857920989303, 0.08222510521220083, 0.11585493902351574, 0.13044858981094243, 0.09759685574967625, 0.18284194965686662, 0.17783715551031165, 0.10582289415229373, 0.9849932545973888, 0.9852973207786653, 0.9774193893308488, 0.9844876973745798, 0.9861944023881052, 0.9694645054947604, 0.9778340297531194, 0.9878396259230792, 0.988783443678814, 0.7490643138627153, 0.7929673224886715, 0.795125845634177, 0.775638999221793, 0.8104935264178845, 0.7723196253728428, 0.8048312327167033, 0.7338333089110187, 0.8266620383241466, 0.8933516759103812, 0.3844380436722057, 0.22693449042902503, 0.2809874434011218, 0.9324621967996392, 0.279718890445915, 0.9105523774391887, 0.9389752671229648, 0.8732320606033713, 0.6418627474880187, 0.7816599557318804, 0.6574896284087621, 0.6698770500242455, 0.8422870144836929, 0.5931562442111891, 0.13466073887528585, 0.7192858750390423, 0.6934006454796557, 0.69749089001256, 0.73957031080785, 0.6859192364963345, 0.707424635320574, 0.6222310431831857, 0.6663592100601531, 0.13541991182252966, 0.7283416950815924, 0.7128675540851408, 0.42564144512919433, 0.10485165891668335, 0.2243081033428007, 0.0728078137677749, 0.6447707146090352, 0.6591943187571867, 0.06130499922598798, 0.1264943306937244, 0.21206987909906216, 0.6756398889980906, 0.7113558308693866, 0.7838176149638179, 0.12512164395781145, 0.6973203951589324, 0.438851581264623, 0.7467594890166851, 0.7635826267096038, 0.7513476653059966, 0.09148891456438013, 0.08837955122899999, 0.07128511496170542, 0.42800139995720143, 0.28925434015785234, 0.3934908878004604, 0.25713905939466697, 0.14982083977801486, 0.21810664187289808, 0.3488803452304956, 0.47922162622351994, 0.5781804707842575, 0.34821482086983, 0.3836177567382416, 0.33946822725785186, 0.3222195760837355, 0.4749959269656562, 0.35044815028994547, 0.6946425766809197, 0.8056646253111025, 0.7365068697911903, 0.7362557504390574, 0.806865481059573, 0.6993768973595347, 0.7991160935909715, 0.8242276376030238, 0.8456469550698047, 0.12062434073950246, 0.11028572419824245, 0.11271956540686678, 0.1428975057641021, 0.1433337724689231, 0.11526028873830096, 0.8052858588607077, 0.09282993354199132, 0.159723168906994, 0.399734993555786, 0.16998640661290554, 0.19066981415708772, 0.1934835956764065, 0.26567586798841025, 0.18720887691723043, 0.19894412753385848, 0.19456497075418788, 0.2310454037556443, 0.4305822653322928, 0.3731624872348801, 0.4708599802846686, 0.587230574055998, 0.4398732517773656, 0.4192430363642704, 0.5442244011952925, 0.6573995582928855, 0.24091981453743883, 0.37130223097516424, 0.3920098179840128, 0.4033721857572934, 0.308760848165047, 0.336393205774837, 0.3737998740100251, 0.5123183728042904, 0.260306177082298, 0.1980056642608039, 0.2678179621776089, 0.22239328188332486, 0.25794493138360786, 0.2432327211589297, 0.21639351932149942, 0.21448953308411167, 0.24119109371633984, 0.2679433087197687, 0.24131197359875245, 0.21502225915113793, 0.21011137519537348, 0.19043507353627287, 0.1970214494940694, 0.219235457753866, 0.22181885184797356, 0.20728215788745208, 0.2095787033482015, 0.19438243430643154, 0.1874286631601919, 0.18679327095699516, 0.17608901683421185, 0.9429245751419222, 0.20071835474662458, 0.1480394057121488, 0.14207488386813494, 0.16053613488923657, 0.9309608885682289, 0.9317330758537976, 0.21193060516658457, 0.9051756713511285, 0.2122354446188518, 0.168312771564759, 0.20887700053266878, 0.21264327661658977, 0.12766510873722114, 0.9109805958972219, 0.20034984193835603, 0.18242341438773668, 0.19280293074397403, 0.2062923230957059, 0.1886151229253673, 0.18711723506247857, 0.19241419650415115, 0.24857355784426016, 0.2061490003200782, 0.0900855260749498, 0.08018980653285579, 0.12363770261779394, 0.09287282958073029, 0.09459769971051302, 0.08164560405101562, 0.09405087839037873, 0.09168241921453213, 0.08332847962429224]}, "mutation_prompt": null}
{"id": "d032467b-79ea-4667-90fe-c5c318217ab4", "solution": "import numpy as np\n\nclass RefinedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.45, 0.35, 0.2]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.85\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.55, 0.25, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.55, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.45, 0.35, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-7 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.92\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "RefinedSwarmOptimizer", "description": "A refined swarm optimizer with dynamic role assignment and enhanced adaptive mechanisms for improved local and global search.", "configspace": "", "generation": 95, "fitness": 0.44454082319082733, "feedback": "The algorithm RefinedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9266037837963246, 0.908847502350612, 0.8801068197843865, 0.9151327789962177, 0.923469516290843, 0.9117795580777889, 0.9089008474844347, 0.9159519474483737, 0.9086705092042713, 0.8374680845747131, 0.8409865795059737, 0.8052751305581208, 0.8616100523856332, 0.8458230486598328, 0.8224320339022142, 0.8271014969850671, 0.8112537130903655, 0.8120706835678486, 0.15962911352587505, 0.11678885670523709, 0.12430777407872551, 0.13279187357877364, 0.11848433392409219, 0.14108245796553476, 0.14209416484494408, 0.1451828853321947, 0.14750626636911346, 0.079845813352724, 0.11678825056861575, 0.12940989169264816, 0.13393055399489895, 0.08084127565722388, 0.10946998211567194, 0.16109754664989995, 0.1599277497551217, 0.096850952101732, 0.9811976968741695, 0.9865702455589658, 0.9740503570022002, 0.9807146801147397, 0.9850568051836293, 0.9762055522384432, 0.9680609207851276, 0.9845349908951289, 0.9828436910762528, 0.6867547134689023, 0.7702830200823384, 0.7253435364118852, 0.7818638110155651, 0.7769786366619209, 0.7325436350480307, 0.8047800941150586, 0.7826213102968713, 0.799904597336525, 0.24508758653442042, 0.8559868968923894, 0.22647562038099744, 0.2761891821921604, 0.27398113665605517, 0.8752266798117788, 0.8272129950042403, 0.23769097233051406, 0.8600653285315386, 0.5995067415318799, 0.670660792157071, 0.739156060507784, 0.7260635126902748, 0.7130403268161949, 0.7496570495193284, 0.6768206264688108, 0.5916952954878427, 0.6789771075615296, 0.6917052937112332, 0.7412719241340767, 0.728677914632046, 0.7830577479296016, 0.7054361342474318, 0.595580616312686, 0.7767809755805057, 0.6816476638700688, 0.7146732891219859, 0.3033417670614954, 0.4750731652145005, 0.06891248722164622, 0.5935463897195461, 0.15193364869876735, 0.4306830541690436, 0.6439401303412262, 0.19203857965271587, 0.2914991044408137, 0.610802085585318, 0.5476140727782751, 0.5458407733274369, 0.1383168884762439, 0.3468350904275894, 0.18641739755781628, 0.702152231665865, 0.6527515033062941, 0.5453683587972851, 0.17807587648244594, 0.07974479528212652, 0.14469590983111535, 0.37024455785998966, 0.4930836257925949, 0.15907403528381658, 0.2957246485078343, 0.15141258001968128, 0.20479984997487632, 0.49797589625384386, 0.22764415755185696, 0.3222104816266066, 0.348008351642635, 0.3826963270259427, 0.41168485258252374, 0.3323891824590923, 0.4239066576093852, 0.33416761150917573, 0.8278126317163236, 0.8604008291407544, 0.6997565951817708, 0.7829457417078363, 0.7808293304740318, 0.756992747522053, 0.7848426360141625, 0.797454126035291, 0.7625273820232807, 0.07079872644013308, 0.10576811282022658, 0.11400190522837617, 0.16193053976408078, 0.11083553459893736, 0.11213819869003006, 0.14672294842845424, 0.08459877135478766, 0.13760298865628573, 0.2048942465840642, 0.26649016817111393, 0.22898517920124306, 0.22585200559436336, 0.4153890283030721, 0.21924385163876903, 0.1774040072437123, 0.2748147335835833, 0.21360111845037855, 0.36897617108689273, 0.3545114477462701, 0.3877408136028917, 0.2414897180169283, 0.28681583919372855, 0.27281789301950543, 0.33028402598568585, 0.48648264292501275, 0.4102568055504894, 0.4254810938747442, 0.23957469744387028, 0.3613777690360166, 0.2438535423828777, 0.2949912293920973, 0.2596046287255678, 0.24485012100657566, 0.5189635174595697, 0.31170295063196873, 0.2304735684538154, 0.2893518014009038, 0.29962077383270136, 0.3938191421652647, 0.24581904668800758, 0.2589396580479738, 0.3530702274832155, 0.2042860458302328, 0.3051899939264545, 0.19172622505909032, 0.1910636383805563, 0.21066234377051085, 0.21033036960815032, 0.1987897979689618, 0.20830763165078436, 0.22469366853689987, 0.17995052801592937, 0.19081129813587527, 0.9283266968329891, 0.18614134827218876, 0.18760288475851516, 0.16894595266659307, 0.19995759884609088, 0.19901001982546263, 0.9288364286105609, 0.915307068570716, 0.8935746574135618, 0.9025413826727235, 0.9001889554983264, 0.12522638394075114, 0.2129407215708945, 0.11232525502294188, 0.8316670760725683, 0.2130139131063129, 0.9164969985670592, 0.15611400645199114, 0.20510311847346197, 0.1870748846724114, 0.19371010272163935, 0.18384458289395422, 0.1700244151157203, 0.18967654289889302, 0.22189279055973543, 0.2106517077342147, 0.2081043802171706, 0.07927202166427216, 0.10133759565112066, 0.0995865372849003, 0.111616060159074, 0.08290652577871693, 0.09980334153230774, 0.08032885427321357, 0.09626728700189147, 0.10333124188894749]}, "mutation_prompt": null}
{"id": "275df0f1-8a2d-486f-92b8-6efc03b5ccfb", "solution": "import numpy as np\n\nclass HybridSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((5, self.dim))\n        self.diversity_threshold = 0.05\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-7 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.93\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridSwarmOptimizer", "description": "A swarm-based optimizer with hybrid adaptation and guided mutation strategies for improved convergence.", "configspace": "", "generation": 96, "fitness": 0.4266828787922125, "feedback": "The algorithm HybridSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.29.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.882093631048985, 0.8793000440996503, 0.8923851212726858, 0.8864009614424984, 0.883708178298743, 0.9021228505368066, 0.8799520180137528, 0.8970352290501149, 0.8872494427883537, 0.78298377921052, 0.7820324953684621, 0.8000267681874964, 0.8043895163108253, 0.8151946624703119, 0.8017787611976179, 0.7651093539234316, 0.7778897758873426, 0.7901403323476895, 0.12730771886886028, 0.1579731388325798, 0.15154285793664402, 0.12799711257459678, 0.13038536102528397, 0.1715707122776201, 0.12682101768044451, 0.13945908357253778, 0.15951699376816408, 0.07880085728775155, 0.11790544642687706, 0.10730146444454203, 0.1205812582393746, 0.1432387458282034, 0.07901269841934577, 0.14929421615660898, 0.1381234274351364, 0.1303503200720656, 0.9875522532344552, 0.9789925492151538, 0.9855072731089908, 0.9904093196999311, 0.9771078601947777, 0.9881327321597577, 0.9812515329303153, 0.9867833213728188, 0.9881492281363492, 0.6475584694820686, 0.6509913442751443, 0.6639126069879869, 0.6247382593240001, 0.6262183128927643, 0.6926745789829285, 0.7441716505883132, 0.7381947974291474, 0.7468549191291495, 0.7939863003355132, 0.7692285180124704, 0.8312591029810863, 0.27549555385209157, 0.2730389469846597, 0.1921495808848438, 0.8441535225433636, 0.8418610809127933, 0.8581415473311593, 0.6762915287736322, 0.6859559108935029, 0.5850873697196786, 0.12306816431617085, 0.5591845025239073, 0.5887027623172953, 0.5966910545249513, 0.6731236347754592, 0.5430848073979573, 0.6546944214341825, 0.5547351867070172, 0.6107107363417528, 0.4822942248080916, 0.6562444816041992, 0.13576997508620647, 0.6366677217293821, 0.5924769367926148, 0.6539915596440702, 0.2561121869458559, 0.20807836055682427, 0.5186790884854509, 0.21109799071497315, 0.41496850871473645, 0.2752198012225555, 0.2448382894287171, 0.2735864025457895, 0.2570863438595151, 0.4779703495261939, 0.6508052067318455, 0.24571106978125812, 0.5177395246348478, 0.6752934212197268, 0.4396193788197952, 0.4026657744387043, 0.5474235849424018, 0.42498057076524787, 0.08134307907538774, 0.07758269750731306, 0.19145527541366825, 0.4055996962829137, 0.40438814021398917, 0.15345534821319284, 0.11712980920230398, 0.2953033373728655, 0.1270366566265122, 0.2792436202400832, 0.35738581799023084, 0.34910833249994133, 0.29786564237615343, 0.3299189654864144, 0.4489949369315428, 0.26532663746750185, 0.41238936421945427, 0.30928399559777175, 0.6994396709658699, 0.769065654915785, 0.7825602635931844, 0.714882348825824, 0.7555382413139893, 0.7235079196170953, 0.6874605639538988, 0.7507805963679564, 0.7486576198063939, 0.15978177656587522, 0.08592038417226577, 0.09817182683391734, 0.1381891479900772, 0.11530265184554422, 0.14038248185292668, 0.1121842243904031, 0.15455249611969935, 0.13917646944941608, 0.18914383317283123, 0.20168944543750045, 0.17233349324455616, 0.20006083051805768, 0.18241651911957713, 0.1560545251570824, 0.2026230629786009, 0.17186278821832934, 0.2596148798511345, 0.5380406626841003, 0.4002077092385896, 0.5211362374249393, 0.456869650633833, 0.3683651401542456, 0.38296934562692875, 0.38406570044783594, 0.5456372977076813, 0.4381788595677797, 0.23555603646221257, 0.3378651031572245, 0.444957048803192, 0.33368116239837464, 0.32837093297081, 0.29964996762944685, 0.3228863003918797, 0.2513243916072404, 0.2533380346592661, 0.2968491091571053, 0.24336371361791542, 0.2740953971003771, 0.2644118223504839, 0.2407440332165255, 0.2678968865685446, 0.2757171604860441, 0.2581902867479865, 0.3153860504103637, 0.2239415864563502, 0.2211914811652539, 0.17937126887134913, 0.22300877741612335, 0.22483836644946664, 0.20840431879410493, 0.21090183960014275, 0.19748799052358557, 0.20483075254479977, 0.9083588116728506, 0.1878213015669873, 0.16681727493580678, 0.9008774751736687, 0.19922505587105077, 0.9028195760209163, 0.9186202042231207, 0.17628563747230197, 0.1664427466631423, 0.8444258401893067, 0.20944465157212822, 0.8719189021087823, 0.7565381581211559, 0.20693078772792373, 0.15359223643283348, 0.2091979396804935, 0.16776813386482115, 0.9043577681444335, 0.18913344678356014, 0.1859364243351609, 0.18467939257565036, 0.21399587347863813, 0.19035916614802517, 0.1762135848626436, 0.2018271628925966, 0.21043688437941377, 0.21146842326598247, 0.08679376686889917, 0.08951419709274577, 0.08245757513419161, 0.08343671664508145, 0.07619075806428643, 0.07270481862053113, 0.08659516150369106, 0.08601567045630532, 0.1002634545231631]}, "mutation_prompt": null}
{"id": "bd7d08da-0c36-4c01-b6de-0e8252598457", "solution": "import numpy as np\n\nclass AdvancedSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.5, 0.3, 0.2]\n        self.adaptive_factor = 0.8\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.15\n        self.stagnation_count = 0\n        self.max_stagnation = 8\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.55, 0.25, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.25, 0.55, 0.2]\n            else:\n                self.strategy_probs = [0.25, 0.25, 0.5]\n        else:\n            self.strategy_probs = [0.5, 0.3, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-7 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.93\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdvancedSwarmOptimizer", "description": "An advanced swarm optimizer with adaptive strategy selection and dynamic stagnation handling for robust optimization performance.", "configspace": "", "generation": 97, "fitness": 0.4592046028207934, "feedback": "The algorithm AdvancedSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.32.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9291105002964959, 0.9256614181511422, 0.9262150338268026, 0.9282304945061204, 0.9187907821242094, 0.9377413248090228, 0.929317344795856, 0.9163964395542931, 0.9294889648138611, 0.8562927354950907, 0.8607822609202126, 0.834182496329754, 0.8281154724617318, 0.8471780128842972, 0.84724925121706, 0.8311211487037291, 0.8297491568939279, 0.8256466275934826, 0.14431673281213153, 0.07943015333760284, 0.11397276677240009, 0.1651789375553655, 0.12329442369964416, 0.13359307206424564, 0.14405643677970115, 0.1870796684895326, 0.18453280164712305, 0.09149413232519987, 0.12159493307570068, 0.08292434137545623, 0.1349315949687867, 0.09655877520270184, 0.13907078168893838, 0.1338210313101036, 0.12196730555362978, 0.13209042875428934, 0.9782899584251458, 0.9830035115218703, 0.9875936461541486, 0.986711898483214, 0.976331717057353, 0.9794807688473024, 0.9735388506154343, 0.9896322024979866, 0.9798410542777707, 0.7895576340021011, 0.7990038322260009, 0.7752965884080982, 0.8088740540406812, 0.7951554752960227, 0.7977623371107818, 0.7954808489097556, 0.8203070451259613, 0.8237107503495726, 0.19665553253344203, 0.9259656257503129, 0.8570039047128026, 0.2137021691492924, 0.9423819309275262, 0.2083946556058972, 0.9253207889704395, 0.24855822560196017, 0.14817540654733052, 0.13514036241198024, 0.7885263699805399, 0.7488958231141124, 0.13380351639067178, 0.8287404320386941, 0.7108872553884582, 0.7125130314724017, 0.7011384994530334, 0.7864441250542467, 0.7792387698659741, 0.7681737219897548, 0.6962448943364088, 0.7865128387516129, 0.6998599122094924, 0.1350723044525819, 0.8580908119724648, 0.782650982372728, 0.7443724974520409, 0.4075636684124655, 0.13428853179481215, 0.5308140450221295, 0.6195762694181332, 0.7150437911837283, 0.4419916497769326, 0.7352477449853887, 0.7573756923289837, 0.7992468466127874, 0.7076700180286007, 0.7787786026973322, 0.7701357691476591, 0.7179049460164542, 0.6363896147307446, 0.21303675961506063, 0.7368453458368063, 0.7920766107423075, 0.793886865484074, 0.16075293565598736, 0.1919806608310628, 0.24184362885699962, 0.4841993634188245, 0.4728984131785875, 0.20738288158163254, 0.2755210341947639, 0.1636586436178431, 0.6056722960602308, 0.30140720167785284, 0.3985441038090829, 0.43981778370997826, 0.6295638818006994, 0.29497913388509367, 0.6437673539987641, 0.6408488025299244, 0.5826635685193561, 0.5722687607734149, 0.8542442503457, 0.8115454883367823, 0.7843390271766478, 0.7460313360823213, 0.8711282403212252, 0.8625313671991894, 0.8621931664384563, 0.8758064241178505, 0.8639361051836777, 0.08711926091507471, 0.11411839251664901, 0.11220652261617103, 0.11611188645313253, 0.08729689805527219, 0.19045442272240976, 0.12152335985826523, 0.11646691280160903, 0.11442205644978909, 0.19099342718080148, 0.2661000452836192, 0.19982262213277457, 0.6397160432800171, 0.1565648266261449, 0.32264197087918545, 0.15929771549948235, 0.14141570168333506, 0.19350531444058527, 0.2310576778907365, 0.48474481917738, 0.33955302555771594, 0.548503241048793, 0.30680529336147366, 0.43209643088085736, 0.5555757316276457, 0.44720012358576, 0.5144262981591329, 0.25402446425936664, 0.25146013642164644, 0.29566717393449815, 0.22154668258419052, 0.25145515407619123, 0.24626174541106505, 0.2405096972510079, 0.30863791820047604, 0.20716654615515062, 0.3537425111758713, 0.24644813890860218, 0.29333613276892434, 0.2490089333648947, 0.21503439271403169, 0.22999734376028558, 0.2412909240699449, 0.20569870597624307, 0.21370894931606332, 0.18648670014512458, 0.1786999098652272, 0.2246381787403131, 0.22363618258143714, 0.19914509522204749, 0.19804156261204153, 0.19275543601460032, 0.17515663935162995, 0.20692995551482163, 0.9515940841804091, 0.17729862241524386, 0.18765758695305923, 0.1882099076728394, 0.19801528855979955, 0.16621393971803722, 0.14249517047974314, 0.16316044075241865, 0.17725736780741153, 0.9097281428968298, 0.1689631582197637, 0.9235182229111262, 0.2126549273075975, 0.1684053407250512, 0.871617288833337, 0.21292214062665293, 0.21285443756951838, 0.16639830543884349, 0.17944924031154985, 0.18307872643094325, 0.221838991010187, 0.16801056505579637, 0.1736280289065164, 0.17825461811763832, 0.2074259463003849, 0.21586593540520238, 0.22398956573838913, 0.11244087077580567, 0.10713369642994708, 0.10184137655195369, 0.08304586923760349, 0.11125327573694666, 0.08316366179674428, 0.0876222340477123, 0.09688394722919857, 0.09346508628026018]}, "mutation_prompt": null}
{"id": "7daf60b3-c895-41b0-b49f-a8522d13f6e0", "solution": "import numpy as np\n\nclass AdaptiveSynergyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]\n        self.adaptive_factor = 0.9\n        self.crossover_rate = 0.8\n        self.memory = np.zeros((3, self.dim))\n        self.diversity_threshold = 0.2\n        self.stagnation_count = 0\n        self.max_stagnation = 15\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'target_to_best_1_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'target_to_best_1_bin':\n            x = self.population[idx]\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = x + self.adaptive_factor * (self.best_solution - x) + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'target_to_best_1_bin':\n                self.strategy_probs = [0.3, 0.5, 0.2]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.93\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "AdaptiveSynergyOptimizer", "description": "Adaptive Synergy Optimizer: An integrative adaptive algorithm combining synergy between exploration-exploitation strategies and dynamic diversity management to ensure robust convergence.", "configspace": "", "generation": 98, "fitness": 0.44022374825068405, "feedback": "The algorithm AdaptiveSynergyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9061278190875355, 0.9116714180146777, 0.9012995954262703, 0.9153489714153288, 0.9090644705490137, 0.9026001940580016, 0.9200581716036834, 0.91283715309826, 0.9018957924574544, 0.8201551118989043, 0.8240004265901224, 0.8233230678750078, 0.8260225466138712, 0.8234868209373991, 0.8165799307421561, 0.8271257691870142, 0.8216531918951838, 0.7940127538544518, 0.16317355851886262, 0.11088236404182639, 0.14293970237069575, 0.06991008244659846, 0.13277023817522127, 0.1578395926148476, 0.12993352964724958, 0.15638247130091054, 0.1596273393705151, 0.14233701588129388, 0.10072116279923593, 0.11814225277255974, 0.1336518600894938, 0.09175948240499743, 0.10969813875820855, 0.1073827353360366, 0.10536363378326818, 0.14191493906876151, 0.9870026879964132, 0.9907708410693077, 0.9591673374001806, 0.978307696034918, 0.9837524300694287, 0.9856924183500628, 0.9854471245398032, 0.9793112482845685, 0.9734156342780261, 0.6477426682783705, 0.7616826349578053, 0.7335353506015314, 0.7189068648000179, 0.7143377391994123, 0.653892507033512, 0.7887850804178359, 0.7467544186129208, 0.77873190994435, 0.36574526179170497, 0.7445725204487206, 0.8356942053670289, 0.33727758881957015, 0.38057330057565897, 0.27703854755914226, 0.8182128420456105, 0.8999026579967802, 0.8595448549019407, 0.13037549265886228, 0.5378390501799291, 0.532587353555654, 0.6641610580700033, 0.6436318634487527, 0.13313590873001535, 0.5823938653109395, 0.5351530029852225, 0.578874886274436, 0.5475290022989774, 0.592078015486736, 0.6199383578579836, 0.7371935783943309, 0.5753748995322119, 0.13658667129819857, 0.8055056259902637, 0.6628756290952263, 0.7496190131884568, 0.08682661183233853, 0.09553119461704296, 0.32480471662066634, 0.4256494980442642, 0.35445790801495347, 0.11980954251276221, 0.48455398609956457, 0.44773183784189163, 0.45168236844449694, 0.6509611485462026, 0.363741569594877, 0.6302960152063846, 0.25540630320566693, 0.49976981289415356, 0.6264954843479109, 0.5083876780504242, 0.4639891935932504, 0.6644300367409487, 0.17909652054907743, 0.06674457681814838, 0.511823474000046, 0.21531437166446699, 0.22216562251486482, 0.16314844084201996, 0.183593008621041, 0.12272981429487628, 0.12782260827621472, 0.3123528298644288, 0.267659899032632, 0.36883141714696066, 0.3918688971375962, 0.3204881869061341, 0.3706060283026953, 0.328758797347917, 0.3639288448522998, 0.3093329005466159, 0.8104012483652484, 0.8210357790362405, 0.8115362461237818, 0.6942461529872239, 0.6870244012357609, 0.7193213466390379, 0.6975187735460439, 0.7307970343828731, 0.7380010036726137, 0.10341435333609439, 0.12379660830942707, 0.1364413049521388, 0.11214964877155631, 0.0920473365353448, 0.10077483285200017, 0.08982730110022208, 0.15453166608506597, 0.15726642818829495, 0.17418707089685936, 0.28185748954786893, 0.21855231006966536, 0.38715984036150397, 0.336861687034286, 0.2527686925599234, 0.17741395066572985, 0.1869641644369996, 0.2783386912959016, 0.42072622029729556, 0.30028809806622936, 0.4950984488836633, 0.2988519227058666, 0.5358297010646644, 0.34248740116814025, 0.2790359578927205, 0.3331431490350969, 0.4013286460253779, 0.30354521803756274, 0.3064084321595242, 0.3046420068311735, 0.2280162257494468, 0.2013642815152542, 0.2993868253995928, 0.3108649436260702, 0.2603890132925639, 0.21872550496466592, 0.24653385604021427, 0.29854199817168614, 0.2690508138134634, 0.21602688319935237, 0.305707609293129, 0.22813086920376868, 0.3487120074302942, 0.22132443403058133, 0.27159019519457284, 0.7856546968676787, 0.2245572728513202, 0.19751017185469777, 0.21113673793851273, 0.1895027361413847, 0.20016761157409246, 0.8097690920697335, 0.19261227285103721, 0.18400703126261053, 0.9307978119034206, 0.187062350635667, 0.15318418003284628, 0.17170884058226876, 0.9279900329220874, 0.8982604676704838, 0.9268351146004299, 0.917889228474587, 0.17771705803472126, 0.8618299045869903, 0.20910257090486573, 0.84062478585761, 0.21261162329027028, 0.8927422831076723, 0.8480929202097205, 0.21322087270406087, 0.8404057683920094, 0.15617788962045687, 0.19710914632831944, 0.21422238482967315, 0.1823338020687325, 0.19601110665600663, 0.17371261328062992, 0.17496471765305088, 0.2220277674763963, 0.23520926162352584, 0.2224072941587072, 0.09032500150847778, 0.0890013502621998, 0.1270569681103334, 0.08590714481987471, 0.10618507450286307, 0.07004590143499678, 0.10272858611061098, 0.08559633842693604, 0.06919171453393413]}, "mutation_prompt": null}
{"id": "ee3805b7-bc6c-4304-8b9f-039d75b267e6", "solution": "import numpy as np\n\nclass HybridAdaptiveSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.pop_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = np.inf\n        self.strategy_probs = [0.4, 0.4, 0.2]  # Updated probabilities\n        self.adaptive_factor = 0.85  # Adjusted adaptive factor\n        self.crossover_rate = 0.9\n        self.memory = np.zeros((5, self.dim))  # Increased memory size\n        self.diversity_threshold = 0.15  # Adjusted diversity threshold\n        self.stagnation_count = 0\n        self.max_stagnation = 15  # Increased stagnation limit\n\n    def select_strategy(self):\n        return np.random.choice(['best_1_bin', 'rand_2_bin', 'memory_guided'], p=self.strategy_probs)\n\n    def evaluate_population(self, func):\n        for i in range(self.pop_size):\n            if self.fitness[i] == np.inf:\n                self.fitness[i] = func(self.population[i])\n                if self.fitness[i] < self.best_fitness:\n                    self.best_fitness = self.fitness[i]\n                    self.best_solution = self.population[i].copy()\n\n    def mutation(self, idx, strategy):\n        if strategy == 'best_1_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 2, replace=False)\n            x1, x2 = self.population[indices]\n            mutant = self.best_solution + self.adaptive_factor * (x1 - x2)\n        elif strategy == 'rand_2_bin':\n            indices = np.random.choice(np.delete(np.arange(self.pop_size), idx), 3, replace=False)\n            x1, x2, x3 = self.population[indices]\n            mutant = x1 + self.adaptive_factor * (x2 - x3)\n        elif strategy == 'memory_guided':\n            x = self.population[idx]\n            memory_idx = np.random.randint(0, len(self.memory))\n            mutant = x + self.adaptive_factor * (self.memory[memory_idx] - x)\n        else:\n            mutant = self.best_solution + np.random.uniform(-1, 1, self.dim)\n        return np.clip(mutant, self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant):\n        crossover_points = np.random.rand(self.dim) < self.crossover_rate\n        if not np.any(crossover_points):\n            crossover_points[np.random.randint(0, self.dim)] = True\n        trial = np.where(crossover_points, mutant, target)\n        return trial\n\n    def update_strategy_probs(self, success, strategy):\n        if success:\n            if strategy == 'best_1_bin':\n                self.strategy_probs = [0.5, 0.3, 0.2]\n            elif strategy == 'rand_2_bin':\n                self.strategy_probs = [0.2, 0.5, 0.3]\n            else:\n                self.strategy_probs = [0.3, 0.3, 0.4]\n        else:\n            self.strategy_probs = [0.4, 0.4, 0.2]\n\n    def diversity_measure(self):\n        mean_position = np.mean(self.population, axis=0)\n        diversity = np.mean(np.linalg.norm(self.population - mean_position, axis=1))\n        return diversity\n\n    def adaptive_restart(self):\n        if self.diversity_measure() < self.diversity_threshold:\n            self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.pop_size, self.dim))\n            self.fitness = np.full(self.pop_size, np.inf)\n            self.stagnation_count = 0\n        if self.best_fitness < 1e-6 or self.stagnation_count > self.max_stagnation:\n            self.adaptive_factor *= 0.90  # More aggressive reduction\n            self.stagnation_count = 0\n\n    def optimize(self, func):\n        evaluations = 0\n        previous_best_fitness = self.best_fitness\n\n        while evaluations < self.budget:\n            self.evaluate_population(func)\n            new_population = np.empty_like(self.population)\n\n            for i in range(self.pop_size):\n                strategy = self.select_strategy()\n                mutant = self.mutation(i, strategy)\n                trial = self.crossover(self.population[i], mutant)\n                trial_fitness = func(trial)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    new_population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < self.best_fitness:\n                        self.best_fitness = trial_fitness\n                        self.best_solution = trial\n                        self.memory = np.roll(self.memory, shift=-1, axis=0)\n                        self.memory[-1] = trial\n                    self.update_strategy_probs(True, strategy)\n                else:\n                    new_population[i] = self.population[i]\n                    self.update_strategy_probs(False, strategy)\n\n                if evaluations >= self.budget:\n                    break\n\n            if self.best_fitness >= previous_best_fitness:\n                self.stagnation_count += 1\n                self.adaptive_restart()\n            else:\n                previous_best_fitness = self.best_fitness\n                self.stagnation_count = 0\n\n            self.population = new_population\n\n    def __call__(self, func):\n        self.optimize(func)\n        return self.best_solution, self.best_fitness", "name": "HybridAdaptiveSwarmOptimizer", "description": "A hybrid adaptive swarm optimizer combining differential evolution with dynamic strategy selection and adaptive restart mechanisms for enhanced exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": 0.44980409036647295, "feedback": "The algorithm HybridAdaptiveSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "9a41db42-fe02-4364-b855-c2fb3c7a5f81", "metadata": {"aucs": [0.9071894982227473, 0.8969458400198931, 0.8957659337227349, 0.9149535183521783, 0.9087323260742672, 0.9059054350709427, 0.9082247291356025, 0.9181245442078436, 0.8986403733767043, 0.8249431633889016, 0.80776064734457, 0.8441614076206805, 0.8232790207792687, 0.8527032424070004, 0.83522917163407, 0.8206602380943958, 0.8088480929366431, 0.8008272522157052, 0.15683808791208098, 0.12288784154793775, 0.14252131651889377, 0.1350028708155201, 0.14192080358092918, 0.09531568164688053, 0.14914338829248208, 0.182943807382011, 0.18541614699622022, 0.10156268914080024, 0.09736554230279271, 0.0728626103393697, 0.15024719777814932, 0.15366972716671934, 0.08622607461437715, 0.1765048031187778, 0.12811589187372752, 0.12436516906916806, 0.9910483215336996, 0.990110771368888, 0.9899983572211927, 0.9901731468378163, 0.935643951242494, 0.9816409439244234, 0.9813092069932124, 0.9885309398973937, 0.9659702092740046, 0.6868055713430805, 0.7155564469017854, 0.6833225509158329, 0.7141840554859676, 0.706430924990259, 0.708074061490839, 0.8082415782252643, 0.5863408705451473, 0.7901252409298273, 0.5898969299994863, 0.8594317877588501, 0.7795798412313029, 0.21211904315101582, 0.911589729684316, 0.8823687398640447, 0.16985489826271116, 0.23482556142038225, 0.9062044750685385, 0.7163534997863991, 0.668377834373157, 0.5663971035729373, 0.6705513648275903, 0.7669806251688656, 0.7215448233079349, 0.1295126522059452, 0.7424733053132703, 0.6547116447499703, 0.6197913072584523, 0.6944561495402619, 0.7763673980101484, 0.6295340820597057, 0.7098048916157307, 0.5800152504780055, 0.7173189952453063, 0.7083674178459929, 0.6286222172604132, 0.07701070810270194, 0.34917574982738087, 0.25189996312276886, 0.4540043581899076, 0.4593484651909747, 0.5819258061766737, 0.17325740273664758, 0.16394950962129273, 0.5754136908569212, 0.7406873701672811, 0.7749809325742999, 0.705304469931574, 0.6035328516599929, 0.7235356095395019, 0.7823239424591613, 0.7476551558960809, 0.7127879581690121, 0.6637642834598965, 0.12068667704400504, 0.11422390179790787, 0.36875214413190993, 0.38145711146494965, 0.5234841021643858, 0.4024644643805684, 0.17490296380635573, 0.21096010030538448, 0.12964094862518993, 0.33438621779530486, 0.5521807636884102, 0.40424194871385033, 0.34705354429128965, 0.453088472858445, 0.274423416205239, 0.3905060911717706, 0.29030518478709477, 0.5381435109308583, 0.712480659434606, 0.737822537531059, 0.7332702457817228, 0.7816223381116673, 0.8425259502106472, 0.7053607224569374, 0.7976093458719804, 0.8237805411102861, 0.8115305114390285, 0.11389095528391713, 0.12285187323114954, 0.07720204565535482, 0.11575805926593852, 0.10704407317101339, 0.14054171304410612, 0.10797102530721059, 0.18645423727638333, 0.11413369420854902, 0.17949340598800334, 0.37988613568964624, 0.17354052723771896, 0.2109745739704495, 0.23320806306549025, 0.3099466374524871, 0.2666270569584306, 0.30358085846709526, 0.19862835061542483, 0.3954366502592196, 0.4207730688569613, 0.3471221244092402, 0.3926006512534752, 0.3230497888483457, 0.26219747006317096, 0.4715546206993423, 0.28025687328830995, 0.4024903238456684, 0.2689076926787076, 0.23258231248042216, 0.3765120354095658, 0.36693781546576054, 0.33094992148904057, 0.2699429959632289, 0.35087903403264475, 0.2426684757611154, 0.25644746234050075, 0.24449682517284232, 0.2933934988036433, 0.26432395774309414, 0.19749086699039753, 0.2483748584252875, 0.22260377753968308, 0.21695780824609, 0.22923096120559439, 0.3571607977728293, 0.18363551870183092, 0.197281167200138, 0.18560874533217242, 0.2501171982485041, 0.18126838154435332, 0.2088039355817244, 0.21389662513582985, 0.18510295119411768, 0.19728053503724075, 0.9095687336225965, 0.15408463805118222, 0.15364354445132666, 0.9012174235507102, 0.19767246201458988, 0.1536730230210238, 0.14135003041632477, 0.16516002466042123, 0.1662535557704703, 0.9106805241867746, 0.21035350641379513, 0.16716356463797621, 0.20997967376251025, 0.8874432552573945, 0.8764207565946663, 0.11229844548993495, 0.9218690005950303, 0.9096034525570118, 0.19250408034134647, 0.185661374944174, 0.18997199955238087, 0.18467108932888454, 0.17822825664272335, 0.20762035795524914, 0.19526166123721467, 0.19056265323260735, 0.20026778032605652, 0.09625906112454863, 0.09150377925214559, 0.09162657131634444, 0.11769152368831726, 0.12355756882111091, 0.10636433774159992, 0.12480455419738978, 0.10321741376860938, 0.08557738104948642]}, "mutation_prompt": null}
