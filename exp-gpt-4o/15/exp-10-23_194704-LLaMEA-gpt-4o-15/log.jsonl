{"id": "3e398b14-b70a-4f49-b017-c9aa634d8ce3", "solution": "import numpy as np\n\nclass HybridDE_NM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.8\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n        \n        # Initialize population\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    expansion = np.clip(centroid + 2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    expansion_fitness = func(expansion)\n                    budget_used += 1\n\n                    if expansion_fitness < reflection_fitness:\n                        population[self.simplex_size-1] = expansion\n                        fitness[self.simplex_size-1] = expansion_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n        \n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDE_NM", "description": "A hybrid metaheuristic combining Differential Evolution with Adaptive Nelder-Mead for efficient exploration and exploitation in high-dimensional black box optimization.", "configspace": "", "generation": 0, "fitness": 0.346514301841744, "feedback": "The algorithm HybridDE_NM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": null, "metadata": {"aucs": [0.7375538825061843, 0.7190401370517454, 0.7096018022672899, 0.7377784873418094, 0.7398546922259295, 0.7416613137309098, 0.7271990721319279, 0.737258059783491, 0.6980813141645426, 0.544387307806018, 0.5154935076133815, 0.5041515874375524, 0.5053791868646391, 0.5341277561288963, 0.523400681589484, 0.5140148479902724, 0.5302183914634933, 0.4613551085889006, 0.11652538266789358, 0.18232179676378313, 0.13257177948036225, 0.1339014045291913, 0.1233755013283715, 0.14063377468783766, 0.12916848852188356, 0.12722158071913636, 0.1482336207313616, 0.12902954307912184, 0.10392936959555521, 0.11792355984851788, 0.10422993720129958, 0.13171860286656734, 0.11451981373469589, 0.12767757831384263, 0.10937888649180727, 0.13076620489708535, 0.9794398022684812, 0.9294047212151284, 0.9649894098879822, 0.9527698485190862, 0.9432733875309708, 0.951207099104151, 0.952783434752256, 0.9219103665725134, 0.9406139597596621, 0.34265686165014153, 0.3038187547915201, 0.36796671469177855, 0.34869424590065967, 0.31943306444338926, 0.33118920600662494, 0.3655662143204007, 0.3194223266363231, 0.32543068460771696, 0.6910388514709676, 0.7034966999210116, 0.7088004254032312, 0.8804060227470301, 0.7814402971795323, 0.7264646181446075, 0.6581433588945723, 0.6609921701382002, 0.7225810676291814, 0.2940412720619433, 0.2768128137071181, 0.35239200655880143, 0.25744974965832457, 0.2559631254328266, 0.2779428807690262, 0.24850373691364724, 0.30109438486848417, 0.27460526850248157, 0.3003326199034677, 0.3635819294971874, 0.1979681363384972, 0.32150742870627014, 0.24264348730515528, 0.3007576345069801, 0.3077121225891766, 0.2551479996238831, 0.24290969465729917, 0.2925985711071326, 0.25005765173725336, 0.2608509262936274, 0.3655149387548706, 0.31864292380149484, 0.2824651375910918, 0.30096786917896146, 0.2808364472467978, 0.25938262834506554, 0.4675988722815466, 0.42417725972632014, 0.41800379406327826, 0.4375633057871833, 0.4092201844569444, 0.4358221716475055, 0.38522138173126463, 0.4821782579619639, 0.5765838066456143, 0.11945461085634068, 0.14955857165501207, 0.14248167943296264, 0.19942886758120937, 0.22295118238305978, 0.12793678095776573, 0.11755215253142648, 0.1308715933236212, 0.1194623928375782, 0.26247463921388725, 0.24771482824809743, 0.24558083970155786, 0.2564180036379634, 0.25292178645235597, 0.24633051581837961, 0.22865603251482935, 0.24909982371517003, 0.23830736470227765, 0.6098469472268924, 0.6087074969285797, 0.5778640692246673, 0.6341587951597645, 0.5784332135676686, 0.6215204061082946, 0.5928837169480123, 0.5899169585192652, 0.6102811196421598, 0.14462540945609603, 0.12731444920893098, 0.12479203839425446, 0.10383166574802039, 0.12707678391426014, 0.10968655155721896, 0.11967777791521128, 0.1163095088752023, 0.11888728908681734, 0.18810152965347948, 0.14658265131977333, 0.16786696318693195, 0.14805358081751596, 0.16252401529459914, 0.16461210703853812, 0.17307807142027976, 0.15768354939964557, 0.15144398516952384, 0.35011774290056463, 0.322760248805936, 0.32979616560483804, 0.34567845769502525, 0.36257834632558217, 0.34403226760790595, 0.39589024398247097, 0.3884117375021069, 0.35126544205839794, 0.2892389611002436, 0.30003542713051756, 0.3094746479213747, 0.2726380718400414, 0.28514770820837343, 0.30047680930158727, 0.2755643851522548, 0.3010876747994756, 0.3210751702375019, 0.1930855961091854, 0.18439327269312866, 0.20408815330266405, 0.20411491432517237, 0.19381291313629156, 0.18270625832098963, 0.19212722063748155, 0.20448172288060518, 0.18111728152842266, 0.1865783168836429, 0.23554675479876053, 0.19062682577754153, 0.1966722501273077, 0.36138195595400513, 0.3259049590514411, 0.2645213413892279, 0.19380888648323913, 0.21767351330613605, 0.8010851804978584, 0.1585337780888243, 0.15143620351077025, 0.6055546369678104, 0.6612879441181354, 0.18957134247252183, 0.6896097782756323, 0.17637064710029315, 0.6921355444205004, 0.5972546971414749, 0.20845778843792961, 0.7174163838590373, 0.6617999921987265, 0.16371753920231458, 0.6499762257020634, 0.20460788064854518, 0.20850248285486073, 0.20745400053273788, 0.1903219250201329, 0.1908429691266299, 0.19081660995013627, 0.2007782804915914, 0.17901172195382353, 0.19555706420398333, 0.18638891309000194, 0.18840021626715242, 0.18389780822159907, 0.09297786084345439, 0.08489483055851976, 0.10623515433305852, 0.09276027677189758, 0.08792892598672464, 0.08517187037302754, 0.08628468815225421, 0.08916223997814543, 0.08334183894959679]}, "mutation_prompt": null}
{"id": "e7ef9821-82a0-42d3-a78a-7fea41b9676a", "solution": "import numpy as np\n\nclass HybridDE_NM_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDE_NM_Refined", "description": "A refined hybrid algorithm combining Adaptive Differential Evolution with Nelder-Mead and dynamic parameter adaptation to enhance convergence in diverse optimization landscapes.", "configspace": "", "generation": 1, "fitness": 0.47419014807900706, "feedback": "The algorithm HybridDE_NM_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "3e398b14-b70a-4f49-b017-c9aa634d8ce3", "metadata": {"aucs": [0.8737324119150948, 0.8647137308899738, 0.878403139587428, 0.8642178839475467, 0.8637684690899428, 0.8800174755053657, 0.864236685772651, 0.8571965684861409, 0.8694649383737654, 0.7520355697516871, 0.7493661646200388, 0.7519417452535808, 0.7626105080210507, 0.7498009889239914, 0.761349383987122, 0.7646495881449644, 0.7700495484142467, 0.7395601301318768, 0.1277689358174091, 0.15420949057966804, 0.13797368562609158, 0.17681693738339221, 0.5592490120249426, 0.15308706248017456, 0.12146946166804229, 0.6047459599770102, 0.1281384635901195, 0.11159203027217246, 0.11304336469196041, 0.14944582679683605, 0.10556165815052776, 0.09848586266608295, 0.13470609834387037, 0.09989394810166108, 0.11144686484782573, 0.13878810357211968, 0.9389845831539816, 0.9306581802437022, 0.9152890577323067, 0.8968536083894645, 0.9090478571677405, 0.9656658990746052, 0.9182017705418611, 0.9344586896743605, 0.9557762148250055, 0.6052888702881661, 0.6548518585702343, 0.6170837357654297, 0.6485111201780105, 0.6521042632381673, 0.6769863659052016, 0.643776728368536, 0.6036003922311817, 0.6514233462028336, 0.8877572538816986, 0.8656027807866901, 0.8683386973583105, 0.8787415711666186, 0.8674163703753304, 0.8752159177041898, 0.9061841121621539, 0.842692871933429, 0.8543734449232376, 0.2745461032646831, 0.47420257475269567, 0.5211673553375689, 0.5096341486135694, 0.27843520361304563, 0.5905739854676616, 0.5128888738427138, 0.4121769169882338, 0.5282240569524823, 0.26773841835059164, 0.3123020416950689, 0.3898208869074289, 0.46773700407467644, 0.24505675332312293, 0.2995474313983796, 0.5241096470327977, 0.39139765141630944, 0.4081423745044406, 0.5339661111235159, 0.4243963136755535, 0.6552317806854682, 0.5814424294900911, 0.6266348081368025, 0.6590872782396919, 0.5530793159293315, 0.5511845831411617, 0.6744846535959341, 0.7186628227789176, 0.7291554308413892, 0.731630802785157, 0.7115111045415163, 0.6935654718578796, 0.7147561147917953, 0.6910056731259662, 0.6995444981304855, 0.7063974674791245, 0.23639707301297908, 0.17202024020268325, 0.1715543486773633, 0.28954635262904427, 0.5312537052194903, 0.2737425823677886, 0.3385285275884157, 0.21418146329281162, 0.3462915084092215, 0.51106864201524, 0.5108397783026546, 0.5626539278695479, 0.5553892319574579, 0.5442129912924212, 0.52544535951291, 0.4930984222703484, 0.5365095979556804, 0.45661037361917356, 0.8251807252189987, 0.8192846812078345, 0.7944818293379557, 0.8110734992380444, 0.7799380205055182, 0.8029447139679255, 0.809322253335299, 0.8229217129272197, 0.8122593458796068, 0.1505530968455303, 0.1532594270754556, 0.155130913756104, 0.1373212962380319, 0.1267662463364484, 0.16802799935782275, 0.16586100697669737, 0.15237261289051462, 0.1389667169176242, 0.25899424976217866, 0.1976160502846983, 0.19398341270564057, 0.18133436469434072, 0.2107947340424109, 0.43557212773029064, 0.1747302082726805, 0.18948454051957475, 0.22576976330824072, 0.5188839086237618, 0.6519245273870661, 0.6351816648072157, 0.6297792677684952, 0.6014097530497206, 0.6866986137286828, 0.6315129375370268, 0.5446105083318127, 0.6506712931160348, 0.502672345294578, 0.5587720057933849, 0.44263387405377375, 0.5628666083884193, 0.5129827257984093, 0.42645857277272003, 0.3558845789656354, 0.5564931502774154, 0.3259990252850985, 0.2158997969414136, 0.21209904622849274, 0.20851913118527343, 0.24154148251666607, 0.2149414022687569, 0.22205110994030008, 0.23242100702049007, 0.21843888150864632, 0.21343792795177097, 0.21600695065653186, 0.21119043053557518, 0.20458979952718004, 0.21899915915213108, 0.2461516973104374, 0.18656159951549856, 0.6898621965849824, 0.19380381010219827, 0.20593394548750976, 0.20490214926896055, 0.17733330181959284, 0.16707555169292987, 0.8820413541092988, 0.1995490505484201, 0.1771137282261076, 0.8773098833985623, 0.18663079345366163, 0.897534054528849, 0.8633118740986903, 0.20975134042185595, 0.8517317598136402, 0.8585137709873489, 0.169163965894779, 0.7711837880063634, 0.21090505774481294, 0.2111792628013871, 0.8058332316211421, 0.19423471646225732, 0.2006783227674599, 0.2085384664686708, 0.22946869706309958, 0.19929064157762177, 0.20946714189600923, 0.19026977946116497, 0.20850163764584773, 0.20281099341890962, 0.08853610844781379, 0.10294815580484906, 0.11192603373765031, 0.08875136537147532, 0.09695001895284316, 0.10080170716285775, 0.09666131197250505, 0.09606589938108223, 0.09507131096190502]}, "mutation_prompt": null}
{"id": "4184b850-4159-4da5-87fa-6972019da556", "solution": "import numpy as np\n\nclass HybridDE_NM_Enhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.85  # Slightly adjusted crossover rate for exploration-exploitation balance\n        self.de_f = 0.6  # Increased mutation factor for enhanced diversity\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with improved diversification\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic selection\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step with enhanced reflection and expansion scaling\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.7 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.7 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "HybridDE_NM_Enhanced", "description": "A hybrid algorithm integrating Adaptive Differential Evolution with Nelder-Mead and dynamic mutation strategies for robust optimization across diverse landscapes.", "configspace": "", "generation": 2, "fitness": 0.42453533942243976, "feedback": "The algorithm HybridDE_NM_Enhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "e7ef9821-82a0-42d3-a78a-7fea41b9676a", "metadata": {"aucs": [0.8182920781981267, 0.8359615106492317, 0.8343376269776044, 0.8434451698647226, 0.8235084176032844, 0.8411084741315349, 0.8312026055216786, 0.8355481150537045, 0.8324875598552751, 0.7071845186478811, 0.7037927089177823, 0.7074445968776679, 0.6977728777803478, 0.6848535787756751, 0.7241032268232952, 0.716046061739422, 0.6807561461690417, 0.6788272357126603, 0.157917054303776, 0.1582271191587451, 0.14653962370861062, 0.16848642814122627, 0.5935131200848756, 0.13797751383192614, 0.16247558814773133, 0.13423341521055465, 0.1747810143809373, 0.13026424517460578, 0.12904723157666376, 0.14154284712288767, 0.12804906954383133, 0.11346631503480731, 0.12467624003010025, 0.11071043252899271, 0.12031496893005222, 0.10381848960419715, 0.9279756875459633, 0.9452913426443416, 0.9541922199605505, 0.935848628045289, 0.9344910304914044, 0.9300748793652012, 0.9710448617566438, 0.9375654397407621, 0.9595956602911273, 0.5563494825070256, 0.5633512487617154, 0.5364479026305691, 0.5222926083087163, 0.5746289112462915, 0.5660671111031301, 0.5808314296105309, 0.5750215931401212, 0.5454640402169892, 0.8195245828228702, 0.8044861531188668, 0.8201201793455377, 0.8176884912070221, 0.8341453778587962, 0.21228818764231905, 0.7850103264184096, 0.8211864541479004, 0.8163114429201626, 0.4521225791127076, 0.26520963529238206, 0.4488691607907699, 0.40868223412448534, 0.4674691278387272, 0.5082011401987734, 0.34330835248152025, 0.397429544542641, 0.4458979057618718, 0.4384804442844844, 0.12258232686115611, 0.47995864527032017, 0.45012099519795234, 0.22749537028118616, 0.3702937708246168, 0.44385721323430793, 0.4309756293545103, 0.5119632153731483, 0.35865936285847966, 0.5162297504495028, 0.4933901450866147, 0.4482109434435567, 0.458810467770811, 0.316089212217054, 0.4157683629276919, 0.5062899502194989, 0.4723391374991154, 0.6029207187196597, 0.6191471055592934, 0.6084733502714905, 0.558575328528762, 0.4925093341989383, 0.56889491691443, 0.5929558168835836, 0.6317988402271661, 0.615469862235164, 0.254371576136737, 0.16713500478810095, 0.2686188056728942, 0.3214425949044891, 0.21113396172309007, 0.31195298381831693, 0.22421449530382298, 0.2383259281281357, 0.1656713041681005, 0.3520568207240975, 0.3733906171898629, 0.38360912202037867, 0.37167047845704204, 0.37342234986281597, 0.3646857449710166, 0.33560118665428884, 0.3729051870261917, 0.37135107658614674, 0.7239872074880992, 0.759508153074739, 0.7325206101879829, 0.7507016788706738, 0.750015642635055, 0.7241196257062179, 0.731352528008042, 0.7437924292726793, 0.758422060414145, 0.10837454023476367, 0.1352188674847703, 0.13782555591133483, 0.34179773550164394, 0.12116908855839648, 0.146358408385172, 0.19236670875972905, 0.14845625873416224, 0.12722449229441735, 0.30532417982147686, 0.17531405020051283, 0.26588051690017855, 0.2703099304177845, 0.17659576502967833, 0.17070777125221215, 0.25240642187424633, 0.19710109608831106, 0.1986294853519064, 0.5217018662786976, 0.5135814580937876, 0.5219940274218086, 0.539479097040175, 0.5455762860990392, 0.5540658881594436, 0.5437005001301607, 0.53717476122799, 0.5516249611931001, 0.4132685398497865, 0.40035574660461404, 0.4307921866734844, 0.4247667467606848, 0.3535413690278557, 0.4205708647338001, 0.21745637447951194, 0.4059585508737862, 0.43745117669456346, 0.21655955615153633, 0.21688640915721358, 0.1996335941118461, 0.22528731979482886, 0.203856006129707, 0.2552063472048599, 0.21423723806521688, 0.19819099167992982, 0.2313180696238064, 0.21298038897203242, 0.24345269019504934, 0.23138798509056013, 0.2086465961430184, 0.22152426923132673, 0.22889422620097966, 0.24000064227967466, 0.19821081764288107, 0.21478332833897018, 0.16070510408289596, 0.16427519683559766, 0.7941733860602898, 0.8693943643971401, 0.1967672773365332, 0.8850115029226558, 0.2217355198077492, 0.1670354471373564, 0.8538787875642679, 0.7928846024648681, 0.21023946982020825, 0.20545209906290385, 0.8034691264717033, 0.16758528296626207, 0.5745712584410831, 0.20861256689976349, 0.20932235499448582, 0.20432086400997773, 0.1890781448480905, 0.19566463592105288, 0.19120575433918308, 0.223696657314158, 0.19630948518207525, 0.20975455206426208, 0.18477254388496345, 0.20796072915185249, 0.18547476482161573, 0.09243286005333917, 0.09892264217607738, 0.08635663414553185, 0.09495531878892738, 0.09372067780758808, 0.09510022187002487, 0.09638574686647516, 0.09215170370093251, 0.1056407115874215]}, "mutation_prompt": null}
{"id": "6408cfcf-392c-4397-9193-138d76eb783c", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover_rate = self.de_cross_over_rate * (1.0 - (budget_used/self.budget))\n                crossover = np.random.rand(self.dim) < crossover_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM", "description": "An enhanced hybrid optimizer combining Adaptive Differential Evolution and Nelder-Mead with improved mutation strategies and dynamic crossover rates for robust performance across diverse optimization landscapes.", "configspace": "", "generation": 3, "fitness": 0.3619654621477353, "feedback": "The algorithm EnhancedHybridDE_NM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "e7ef9821-82a0-42d3-a78a-7fea41b9676a", "metadata": {"aucs": [0.8201620728101994, 0.8148666896625465, 0.8443692962545659, 0.8452327044489929, 0.8273584477103376, 0.8217340440306675, 0.829998395812967, 0.8223473968873253, 0.8198609886664916, 0.6787109354761867, 0.6654270850755517, 0.6819664947280653, 0.6638329535851697, 0.658099613614573, 0.6809356727949758, 0.665720314032451, 0.6799282498139447, 0.6987077257760239, 0.33589262048268553, 0.2789302630205355, 0.1394349087416864, 0.33212012675088576, 0.15950109573777393, 0.17566837965977233, 0.521096944327371, 0.43971005798681817, 0.4101235037111821, 0.14860875658687878, 0.1290695356460534, 0.13928965301972507, 0.16014121208509657, 0.13686757122362903, 0.15963720539315795, 0.16713659489723465, 0.12329564222021927, 0.1497608933756437, 0.9312249704374908, 0.885709029962676, 0.9246702102102414, 0.8951207500946007, 0.9238467625817884, 0.8871980570245571, 0.9169683323256808, 0.9178834995300433, 0.9041246732960206, 0.4368113934422725, 0.40270091979634637, 0.4305973933264484, 0.44531773143164377, 0.3836964308186299, 0.438989593246186, 0.4082397820907189, 0.43056341513241525, 0.4109423516310662, 0.8245287085737351, 0.7181980913619657, 0.7557385780546122, 0.800519845935098, 0.784874460329086, 0.6808622027655413, 0.8605499025321464, 0.6470121285997583, 0.761891898144868, 0.18578912836119088, 0.16587277026627, 0.22572386625524554, 0.18660780837801005, 0.18242148714679718, 0.21349762279237916, 0.20164996103342714, 0.23124077345909166, 0.20404946615404806, 0.16900921604986707, 0.17374807590312047, 0.1877524347512065, 0.18685504211223192, 0.1995517858764031, 0.18295638999138797, 0.2191196099451833, 0.15880260770742194, 0.19424699462783823, 0.22786653256754075, 0.11455835649746482, 0.3100240440899389, 0.07902517502029827, 0.12640649776265678, 0.23781309714315257, 0.019914798552140955, 0.1209471378583532, 0.1495756470166445, 0.21094333326875292, 0.3706167357211191, 0.2238646888510506, 0.3860992765307337, 0.23301591634928487, 0.19936057080254943, 0.276929405723926, 0.28576935280650195, 0.2990710680467855, 0.08778528365347193, 0.05431374289693891, 0.22702466664082244, 0.10888420850861424, 0.09874893691459075, 0.19877051343930463, 0.2052612725577756, 0.22999090092312247, 0.0850503445764409, 0.21936773570139323, 0.2103717668306766, 0.2341425091172351, 0.22984544662376472, 0.22854487249305822, 0.2568217737286226, 0.23975561490794695, 0.1880699155074842, 0.22024832756333212, 0.5965097837358682, 0.5449525692363163, 0.5419244701076451, 0.6123351031037125, 0.5476683902411372, 0.6252172129948469, 0.6057636173844134, 0.5665253712301099, 0.5570195485289593, 0.12535282051984908, 0.1850551331558259, 0.1152315243260622, 0.14123842306961976, 0.13405197392739154, 0.12048552317383676, 0.1332222335711487, 0.12402579745406905, 0.1360456870023492, 0.17533309578556033, 0.16660183249157512, 0.17295912261546142, 0.22468560995251108, 0.1404921180197165, 0.17208170515352084, 0.17876160124646745, 0.13487536960018787, 0.16835462817428815, 0.40489696236902073, 0.42097116281184943, 0.4050727334895873, 0.39335931961093906, 0.3700539673376858, 0.4337534620369644, 0.4752248828793656, 0.4502680736775101, 0.450768279096457, 0.2986606686626031, 0.2585281666924153, 0.3290069136614179, 0.2789467502889854, 0.2271859349999672, 0.34820508935349037, 0.3172507762555725, 0.3054813979578703, 0.29449592159645177, 0.2213999319479879, 0.21648565089638006, 0.22642772394366584, 0.2112794509389172, 0.25154738424001477, 0.21844216909790737, 0.2107785168427364, 0.21600321197395056, 0.20076697055409998, 0.20465001087198487, 0.37761538272548645, 0.43839066374366753, 0.41623613274445503, 0.21250917597330832, 0.34296763720187695, 0.3325655450249695, 0.34549682771306356, 0.20987852913379978, 0.8685816750235491, 0.18182666915101342, 0.152032015547516, 0.8044852031774832, 0.19751392176457372, 0.8374777098113596, 0.3364496408167169, 0.20885813661842834, 0.8394116881430396, 0.7881672822211867, 0.2114932526902238, 0.8066031903475074, 0.5571622109250225, 0.5738150735336398, 0.16763790775706022, 0.20798106273769956, 0.7214409489693557, 0.7003388722136894, 0.18959820808388717, 0.21417733140320294, 0.184728491715487, 0.2064243353654558, 0.18365799224951174, 0.22128673051067949, 0.20158532897104942, 0.22609512896143902, 0.18980285782501305, 0.09468107560092798, 0.0942565417853315, 0.0911582337160991, 0.08717809075017213, 0.09192988178391259, 0.0897855083319864, 0.09402969095426283, 0.09638519928327005, 0.10614142429356]}, "mutation_prompt": null}
{"id": "15b88d89-34e3-453c-b233-bfd9cd958971", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.7\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution with random search strategy\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c) + np.random.normal(0, 0.1, self.dim), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex exploration\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Best improvement\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM", "description": "An innovative hybrid approach combining Adaptive Differential Evolution with Nelder-Mead, incorporating random search strategies and adaptive mutation to enhance exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.2754413402382243, "feedback": "The algorithm EnhancedHybridDE_NM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "e7ef9821-82a0-42d3-a78a-7fea41b9676a", "metadata": {"aucs": [0.5133777609674037, 0.6719786569559781, 0.5882418566811372, 0.5746614827883232, 0.5462959991214925, 0.6381779065652196, 0.4859372552907184, 0.5768449850371155, 0.488876078959227, 0.22597154583486256, 0.14812254633967292, 0.17618377521894568, 0.2124588004984035, 0.15716892346558253, 0.17254720909888221, 0.09062432295877554, 0.25073832031352605, 0.19600945195999608, 0.13927343862727282, 0.13341937898977285, 0.11490128147633893, 0.11313611729473105, 0.12468542739769362, 0.11447320846677289, 0.12785629025979584, 0.12185739953082098, 0.13720436939729264, 0.09655828166856661, 0.12499788950678992, 0.11615822198434012, 0.09866862989638192, 0.0967115772283752, 0.10795920826808669, 0.10167792889371119, 0.10251821517971371, 0.11209269202409067, 0.8961057352583813, 0.9495824977895722, 0.9113288957108343, 0.9406444087063154, 0.9407795622314132, 0.9341100722278427, 0.9486628054713037, 0.9469745000470643, 0.9217983506883152, 0.2750948247133177, 0.28973735162419156, 0.30374537873364793, 0.2778702501872865, 0.29713115652499544, 0.2743016647245179, 0.30541716892299486, 0.30582568107853214, 0.27236802994168896, 0.5052507273782861, 0.3424642519746437, 0.5770627751464245, 0.7285881915832286, 0.67754211667757, 0.3641145041885091, 0.6198904995944152, 0.5245841555841293, 0.7785020741318674, 0.1610563853422029, 0.1609381818606811, 0.16099213483806596, 0.1610885872355189, 0.17143709052478207, 0.17629137464164357, 0.17936470704740948, 0.19780429373643393, 0.17397024381841897, 0.1149828052553179, 0.15053483891023622, 0.1397355169807324, 0.25765529509673435, 0.163878148501581, 0.1876399597546199, 0.16770474033408878, 0.1709651231166487, 0.17315576003809896, 0.12371082505266295, 0.09549534829497153, 0.08280683961946489, 0.12347465458270346, 0.13265470300563853, 0.009534406106918136, 0.09650652626151801, 0.034983464675656384, 0.04947937613057363, 0.145549475525225, 0.2719873890287582, 0.1870253770583853, 0.2516939033603608, 0.11852607519682001, 0.2785365121952251, 0.1748228423413628, 0.22811683022470008, 0.28653785540395627, 0.03308290888303966, 0.08539020750749748, 0.10662579990758736, 0.08697038098262366, 0.08070020139356515, 0.07413300652554788, 0.004523740772953921, 0.04779672956719838, 0.1026372070788446, 0.11226103600619586, 0.1370436299233041, 0.18322105731685812, 0.17672806731866153, 0.2437560825426529, 0.24893328439829254, 0.2084373690057173, 0.23351559961320112, 0.1445530907649536, 0.48036985781200126, 0.45227454503476483, 0.47646074777349157, 0.5082228755258755, 0.5653604287607781, 0.5131095012275777, 0.43190938932376377, 0.48392923712212244, 0.44045903778077133, 0.11738219477147482, 0.12499042482843647, 0.13473604578303944, 0.14688191179572474, 0.10864657360920882, 0.11205283256583753, 0.12283329753112027, 0.11749253678715355, 0.1303738908263926, 0.17743189403725879, 0.15946893170030185, 0.16744554009816526, 0.22425968656462947, 0.17185424827968288, 0.17375169508177568, 0.2019236864174051, 0.14511694134106423, 0.17563953165976176, 0.30276050359781936, 0.3046133889986705, 0.31122691784817047, 0.294935860018641, 0.29639069038060006, 0.3181840865333573, 0.3299031843641079, 0.32016093441666216, 0.3207719691579136, 0.2627801254863408, 0.25968149770767845, 0.23972893797131734, 0.24872866205601585, 0.2391116863197773, 0.22063826369280326, 0.2985995778539293, 0.2715100473895814, 0.26031043801581266, 0.24362781146249446, 0.20619578950561535, 0.21074533873784962, 0.22079000272052896, 0.18604067932914437, 0.1966679888075612, 0.20706819266921517, 0.1899434603645237, 0.18911107541491867, 0.2044961388787777, 0.2290480799468595, 0.20394912123871012, 0.19222934401568204, 0.19838252602359074, 0.20421317273847805, 0.2033421887879836, 0.19140610023285531, 0.20129379295774774, 0.6903907861623058, 0.6464754752092321, 0.5887459524662405, 0.5633994398814692, 0.1956684749940223, 0.4808604353294945, 0.7436007190745741, 0.6921907148504821, 0.1723259858486892, 0.6350948489056153, 0.6160907250215533, 0.530802201436242, 0.20482857842595625, 0.16643263210784243, 0.1890281631538272, 0.5801614745648338, 0.2082299355452183, 0.20238268213564292, 0.18940663445016803, 0.19440423397788575, 0.19377902938470282, 0.18389938206816892, 0.18115532786110367, 0.19832743817503684, 0.20677699774484992, 0.21923118540794617, 0.1839424395123752, 0.08889229610574945, 0.09201147055092096, 0.1015526813870602, 0.0799053675235224, 0.08404645379964182, 0.09833062104364432, 0.09297822898068808, 0.09364866381300196, 0.08457569928151809]}, "mutation_prompt": null}
{"id": "10669ac2-2deb-4012-8670-74681c588796", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 5, "fitness": 0.4771458526587456, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.26.", "error": "", "parent_id": "e7ef9821-82a0-42d3-a78a-7fea41b9676a", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "786f08a5-b1eb-438b-a3a1-91deee2ccb95", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE_NM_DLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.3 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.3 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Dynamic local search refinement\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1 * (1 - (budget_used / self.budget)), self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedAdaptiveDE_NM_DLS", "description": "An adaptive metaheuristic combining Differential Evolution, Nelder-Mead, and dynamic local search with probabilistic perturbations to enhance exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.4638288531088164, "feedback": "The algorithm EnhancedAdaptiveDE_NM_DLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8500754239914963, 0.8527887799432871, 0.8483248833126024, 0.8579951345344167, 0.8567850011992981, 0.8542982605067779, 0.8642171525624267, 0.8658935708876847, 0.8783669047029495, 0.7471162804209381, 0.7279579580995974, 0.7146857380268633, 0.7305449052087007, 0.7444929996315244, 0.7203902734096415, 0.7382689831721339, 0.7260148281739709, 0.7001886161579081, 0.39071403426327667, 0.16986905240967154, 0.5745751627209215, 0.14559358517044363, 0.1577837896539167, 0.4207023895015475, 0.4276350749266937, 0.1507806414060585, 0.17165352173658943, 0.14219248125634276, 0.10413243762357738, 0.14648822807108974, 0.1210735843571461, 0.11048435107258558, 0.13384723508919383, 0.1253778183248867, 0.12329800064986052, 0.11111482775133119, 0.8899762779018309, 0.9294980593069839, 0.9333555789375495, 0.9058247025724776, 0.935513328707904, 0.9210543146896137, 0.939464096395008, 0.950175583487871, 0.9299531715764362, 0.5937866819563797, 0.6409365121071762, 0.5703279613063177, 0.5917757381699028, 0.6354340408611423, 0.6116458726277296, 0.6158497063328101, 0.5842165719898161, 0.6527379094664334, 0.8811220267659075, 0.8626221421476394, 0.8387772916386589, 0.85285683487607, 0.8089097945990769, 0.8788316288328714, 0.8929852653926084, 0.840792655195098, 0.8982443795290613, 0.44554843778117414, 0.21608878335221238, 0.36673511598961295, 0.1337471571547738, 0.31687890301824184, 0.474919869348039, 0.5663673875012707, 0.35656460513739197, 0.6390377865154568, 0.2522124757975869, 0.35172958665396614, 0.3052060713910537, 0.329045533224112, 0.5321218530159006, 0.3273245332727569, 0.5183979634687956, 0.25564545864374666, 0.2874807301097788, 0.593328049505042, 0.5938579169121027, 0.6041533537467789, 0.6097132413117556, 0.5974990334053852, 0.43929333129592985, 0.5660303090687041, 0.575936172909065, 0.3475258143368778, 0.6518701897058867, 0.5435405744960231, 0.6963020462865404, 0.6815105445495175, 0.6269236353880827, 0.7035775081242115, 0.7061184242038239, 0.7036552080759654, 0.7106903005844645, 0.3189719233819841, 0.2921452612980765, 0.09852736183214672, 0.41574799829794384, 0.5001016514446728, 0.23181585545458017, 0.31313322672104527, 0.1520427809568966, 0.1289967119962212, 0.47307332762110277, 0.5382613157563934, 0.46748299276172633, 0.4580026794921519, 0.4737223723711822, 0.489054107176064, 0.3919074257015772, 0.4938987367313813, 0.44184683766930455, 0.8123353689465935, 0.7919529008496662, 0.7806091319738762, 0.803726693473386, 0.7972515075773194, 0.796995830577087, 0.7748434114550495, 0.8030068828531925, 0.811247622789576, 0.15110546521084145, 0.5802261624289831, 0.13172077376503222, 0.1471976418440175, 0.1475197233392357, 0.5551494943025821, 0.1678658083668697, 0.13457091630288565, 0.12637986124986567, 0.20925695672402977, 0.21692730231893842, 0.3695989681164472, 0.24428793850352915, 0.20359553044456802, 0.18867057606633864, 0.20416244283937635, 0.6187318504460833, 0.29998538323116597, 0.5132624048946911, 0.544978646667807, 0.5719230587283282, 0.5552850970143552, 0.5651514288958965, 0.31400611390785305, 0.5886228993715014, 0.6060849268285164, 0.6029682655513995, 0.4568617824620048, 0.40404349865702915, 0.5094624458107129, 0.4290656070664415, 0.3990636426008226, 0.3756637454309165, 0.4698189014849169, 0.47438447937565287, 0.48363154950364673, 0.22058906321747973, 0.21929131141311387, 0.28861704057865833, 0.23938844879399768, 0.26938883750891485, 0.2115453705920891, 0.22661284319513442, 0.22064035382113012, 0.21876555127868946, 0.5223096820364439, 0.18993565928620315, 0.19624960027837646, 0.5596309548027008, 0.2049317743631801, 0.22008354119400386, 0.203295274726363, 0.18204139243932516, 0.6480314179104903, 0.1698314982562391, 0.14111287470946376, 0.8584913684120447, 0.16116885355975197, 0.9043974189505143, 0.8154398052280185, 0.8411721983975177, 0.7157725197843778, 0.827117737191898, 0.20536662764156455, 0.2081861468754279, 0.1678217173429979, 0.21048933190237984, 0.16762591155615814, 0.7282991415457278, 0.2069031817833995, 0.21030797646841104, 0.21285556494400537, 0.19096313326494552, 0.21371353024540052, 0.193807407866201, 0.20426947263847495, 0.19556073872469948, 0.18451125345456054, 0.2227288816615013, 0.21758176989635503, 0.2256921662674768, 0.10335080777784333, 0.09490149097654199, 0.11729801676054863, 0.11316677736031888, 0.09474007271515894, 0.09951060361893471, 0.0946053919864076, 0.09843788936906128, 0.09758372544047234]}, "mutation_prompt": null}
{"id": "b313cf97-8511-46f8-8542-a821adec8f56", "solution": "import numpy as np\n\nclass DynamicHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic parameter adjustment\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                self.de_f = 0.5 + 0.2 * np.random.rand()  # Adjusted dynamically for diversity\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.2, self.dim)  # Increased perturbation for exploration\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "DynamicHybridDE_NM_SLS", "description": "A hybrid metaheuristic blending Adaptive Differential Evolution with Nelder-Mead and stochastic local search, enhanced by dynamic parameter adjustment for robust optimization.", "configspace": "", "generation": 7, "fitness": 0.44063906482617554, "feedback": "The algorithm DynamicHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8402962482730247, 0.8302329499591552, 0.8266926482052991, 0.8381341770058227, 0.8393383142184491, 0.8384324651363266, 0.8255362543509374, 0.8485053286725299, 0.8530164351720535, 0.6954779855566393, 0.6825033404069203, 0.7084039552187416, 0.6955243672435053, 0.6754024616617403, 0.6967316001755091, 0.6893681578721947, 0.7098531889353394, 0.6596779704655138, 0.13364981295127398, 0.1614575292772279, 0.16651585415975356, 0.14446398238213365, 0.17757306786852045, 0.17506183976742196, 0.148479636437839, 0.13250531899992657, 0.1502674928792801, 0.1339938186964057, 0.10657537401101635, 0.12860043461828408, 0.10661947916560799, 0.12052175084825989, 0.1314517817719879, 0.1391650800831521, 0.13218693050615404, 0.12254431147192102, 0.9529269994349708, 0.9411927774492542, 0.9717301154870488, 0.9526028315783409, 0.9189677460040953, 0.9403651651010965, 0.9439101799349501, 0.985675983323288, 0.9329454331456307, 0.5726140301915539, 0.5741858383735027, 0.548439179751366, 0.6110017499363587, 0.5632391613478844, 0.5800175737355515, 0.5798760720739573, 0.5843570914195418, 0.6032060663514478, 0.8236862113231314, 0.8405856117319059, 0.8898217303956122, 0.8452756037971316, 0.8743879808647628, 0.8584237715853905, 0.8570151252692815, 0.8633096658076882, 0.8399544011192, 0.5847757418302375, 0.43330746560465194, 0.23729368142899177, 0.4398964932988155, 0.4807021534924858, 0.5332676535625335, 0.44247553247601357, 0.5954845845658419, 0.3847387371548395, 0.3598267636416239, 0.48398795130320915, 0.4310120540900825, 0.4916003591916681, 0.5335598995814257, 0.45013081578538117, 0.37509082707612873, 0.3779595375789484, 0.39025041096333457, 0.54844706938852, 0.48374704916826516, 0.5448593204805247, 0.5570182453389059, 0.49786778263364495, 0.5762964946442963, 0.5709676048758885, 0.5431310341769287, 0.5306257077838933, 0.6709972329537899, 0.6832923311728073, 0.6624970409898906, 0.6553336789518935, 0.640994028697838, 0.639723002620507, 0.6825304275229129, 0.6648424859132902, 0.6660063468057138, 0.09236630798900247, 0.2524178031872729, 0.2972009930326399, 0.4164158621565027, 0.43493118026625766, 0.3470733867765998, 0.31429648364160967, 0.15539349254964796, 0.18082057808594632, 0.430417646363375, 0.4485600858833222, 0.4161212139379935, 0.43572616696031363, 0.46489865865445956, 0.4578883249028014, 0.48763506325840955, 0.4488504485642574, 0.4318162225539154, 0.7936731107684825, 0.7707362766764058, 0.7639224042747557, 0.7721795158604072, 0.7774717946673033, 0.7430371498522272, 0.7589464134292079, 0.7704961630804175, 0.7948995153812821, 0.14043368907299714, 0.11515454007866521, 0.1357403321168722, 0.13363946567101703, 0.1524334841589503, 0.1424665497537686, 0.16139146952067474, 0.13394968578108601, 0.16974683953609038, 0.19716070597686897, 0.22335403928303044, 0.27690066853144857, 0.30793934126980815, 0.22931914571498613, 0.22336032547883455, 0.1875306262966363, 0.19111959134760803, 0.19380995072130758, 0.5271480400456059, 0.5283030630234442, 0.4849335841334427, 0.5438170247225651, 0.49873532205105797, 0.3730986119522802, 0.5804521153192932, 0.5769988598788136, 0.5369304956001074, 0.4124419644044275, 0.4129046594104292, 0.38662333048584896, 0.3253188374385161, 0.41612639979409227, 0.3654519173550279, 0.4582832704915165, 0.4690433096620522, 0.4641898306758251, 0.20243392113422232, 0.20798031459120303, 0.23461336997229065, 0.2047222452570252, 0.209821632478151, 0.22995422083606698, 0.19921193650514235, 0.24703056908027243, 0.2162245717392277, 0.1939765207681705, 0.2181603674360827, 0.20068660513692804, 0.19726315518130633, 0.2028822393958125, 0.6103668287246338, 0.21259225354497868, 0.21892226337178944, 0.24369694044296852, 0.8738524408659899, 0.8924296883013744, 0.8345190785577085, 0.16472140027027182, 0.1687490375294819, 0.14416597992806524, 0.16531779549608905, 0.16800344416619828, 0.16860382295867726, 0.16850109714135741, 0.16854580154933152, 0.2117133184041491, 0.16757465607168764, 0.16652130510463925, 0.16759704130360642, 0.20615789162806464, 0.8339121268417885, 0.8623234938238912, 0.22486879436149432, 0.18402953990824578, 0.1813597388478555, 0.20084991264021868, 0.20581241739212897, 0.18652173281839468, 0.2138283907457853, 0.20142822738701127, 0.2202485774459586, 0.09001501968126446, 0.10084445372419648, 0.09047648111054896, 0.10532079312992937, 0.08241306943370941, 0.10218513066902357, 0.11287779436948953, 0.10067926713683606, 0.09707294889783391]}, "mutation_prompt": null}
{"id": "b8bf71ca-29e5-4cc9-acc8-326de8ab806a", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 7 * dim  # Slightly reduced population size for efficiency\n        self.de_cross_over_rate = 0.85  # Adjusted crossover rate\n        self.de_f = 0.6  # Fixed DE factor for stability\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n        rng = np.random.default_rng()  # Using new random generator for better randomness\n\n        # Initialize population with uniform spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * rng.uniform(size=(self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[rng.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = rng.random(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)  # Slightly reduced expansion\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.4 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted contraction factor\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = rng.normal(0, 0.05, self.dim)  # Reduced local perturbation variance\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "An improved hybrid algorithm combining adaptive differential evolution, local simplex moves, and stochastic local search with a refined adjustment mechanism for diverse optimization landscapes.", "configspace": "", "generation": 8, "fitness": 0.4590759567845871, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8657085398469508, 0.8800751516446174, 0.8686528942517053, 0.8800947505631849, 0.8549308489581616, 0.8579464449176821, 0.8731119811180403, 0.8658255431126337, 0.8583130932351626, 0.7500821517353935, 0.7199383433534705, 0.7321327496390698, 0.7502005627079794, 0.7358705957736869, 0.7434670095520324, 0.7555118133324532, 0.727381864816975, 0.7427286504088357, 0.18241485195793639, 0.6321799346551202, 0.13334538205045288, 0.1448918186113446, 0.15076903930124919, 0.18543659924930433, 0.17095034974487044, 0.15700763616556557, 0.15454471217883214, 0.1398475942300481, 0.13155054721728432, 0.15576302120935037, 0.12298530229077864, 0.12005164281819236, 0.11828231881631801, 0.13692980391293752, 0.09296532790190815, 0.14380919592966424, 0.88239433093215, 0.9273740075585947, 0.9258239125172674, 0.9349417604515534, 0.9275538738628257, 0.9317949402404277, 0.9864333266673818, 0.9578923267395825, 0.932654846584203, 0.6343988466302897, 0.6362757885829537, 0.6168802474728354, 0.6045440858006239, 0.6388071859520279, 0.6267669864154937, 0.6174195877404339, 0.5812350444020391, 0.5969763203746608, 0.8413958129620249, 0.8323009745403096, 0.8367963106940733, 0.8977718963847966, 0.8502520953148924, 0.8688799723058391, 0.8575815421897477, 0.8835043547596344, 0.6289300354400544, 0.4691383152714046, 0.12991867650595468, 0.4065787560690035, 0.12577631694785107, 0.6167918110682763, 0.6313915531495335, 0.4487152396307531, 0.5243290664148492, 0.3748976907720275, 0.547052959229137, 0.45797384856837675, 0.3514165369609277, 0.5720682227666528, 0.4868984385913341, 0.5233556495433175, 0.4684403183898056, 0.49155009570005936, 0.5473599712275334, 0.5134067091789523, 0.5316165160609675, 0.4840713283632766, 0.5501833032826139, 0.47632674217111126, 0.3869283883389969, 0.5728846312125948, 0.5501119676196213, 0.6304558530470192, 0.5887913071146855, 0.6804128719121578, 0.5602510077295466, 0.5420384081504082, 0.4781231367854799, 0.6284656820057397, 0.6706836360624413, 0.7031714692663966, 0.6727542736637693, 0.10969234054540444, 0.21557503069862627, 0.28561626164719045, 0.4307364973105664, 0.18947722059805083, 0.3751552828866178, 0.15814375979974482, 0.27510626625901224, 0.16599262521572378, 0.423586515938428, 0.3489424299643491, 0.4722747423736692, 0.40961675931483865, 0.46169988654274374, 0.4388686420357387, 0.4381195305746234, 0.4005499772809704, 0.4163889506416515, 0.7741609573547396, 0.7830300438704393, 0.792641292473774, 0.7938682359013274, 0.7607399105834537, 0.7905865971047454, 0.7948198416212251, 0.7966394420094862, 0.8101625506173007, 0.1610392025444276, 0.15578017516559173, 0.17741618791792002, 0.18357903761805006, 0.13261904935389646, 0.12283582760323353, 0.12791989390270242, 0.14566667267277156, 0.14466924926130964, 0.3169689023109321, 0.20111509695249785, 0.5780668525924746, 0.2264167651993486, 0.25230606181773463, 0.6657289604706478, 0.4772952515366773, 0.28829677082244476, 0.2582195528579073, 0.5009592167792067, 0.5156650076687699, 0.4938751965073829, 0.572607491792287, 0.5233810232065788, 0.522816430486838, 0.6331608431520748, 0.5311002063499948, 0.6225091076717453, 0.2607671276143202, 0.316355169324107, 0.4692021292276446, 0.4295422018783077, 0.28297509476648086, 0.4581204244989521, 0.21526696155576897, 0.3910963643231433, 0.46424239896491504, 0.2072025288254865, 0.23719035366290575, 0.22724114953214514, 0.22223506306790541, 0.20409825059888598, 0.2101426418747807, 0.5538700872033175, 0.2154622839266458, 0.2034867752643441, 0.6685200219785139, 0.20755727935227342, 0.24111187183324168, 0.6843187355278313, 0.20652077873150165, 0.21965515796591428, 0.20557103853305425, 0.2319987041096888, 0.21599336885953957, 0.1999205763625389, 0.1874034515048305, 0.8742097811447822, 0.16914396717156888, 0.1674856372017559, 0.17586424394139355, 0.8548656380555384, 0.17651110830573502, 0.16330841287133813, 0.8381124911563682, 0.7864110136522915, 0.8866500023013977, 0.16774591462016764, 0.21203200819234103, 0.1956752969759068, 0.8699680684107824, 0.2090513324404204, 0.8527612256114898, 0.20129515768180184, 0.21210412199999285, 0.19279071242016432, 0.18863583748910007, 0.21711745329782783, 0.20257546325299391, 0.19949805110242436, 0.20941125642198166, 0.192041624003221, 0.10652744771190059, 0.09549310898176067, 0.09521181040783266, 0.10001996795356649, 0.09756654264268017, 0.10002516971169895, 0.0928657121365899, 0.09310361059435313, 0.09544467986028615]}, "mutation_prompt": null}
{"id": "2b5cc956-7c4c-43c6-8dc0-f19b43d6f2af", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increase population for more diversity\n        self.de_cross_over_rate = 0.8  # Slightly reduced crossover rate\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Tuned mutation factor\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a well-spread distribution\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Introduce stochastic perturbations for refinement\n            for i in range(min(6, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation magnitude\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined hybrid algorithm enhancing diversity and exploration, integrating stochastic perturbations with adaptive mutation strategies.", "configspace": "", "generation": 9, "fitness": 0.3395863136351866, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.23.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7488574735670518, 0.7705956140918765, 0.7647925419258823, 0.7884206604220976, 0.7787295806180506, 0.7771812733589775, 0.7892646376607735, 0.7649880770791119, 0.7915274763884104, 0.5954307397293721, 0.5756139997258093, 0.5620667387229986, 0.5688650050305959, 0.568628900373543, 0.5595661272845496, 0.5441426942775784, 0.5365615440556892, 0.5738991208381636, 0.1702894618694658, 0.1446221562659643, 0.23794513828742825, 0.1429964347806505, 0.1367808777361894, 0.1702310966118692, 0.1454298142596876, 0.13087717890371364, 0.1358691057866599, 0.1324895907896907, 0.13070356582072995, 0.13130401526477542, 0.1128760039460398, 0.1208938727509381, 0.11018528339577582, 0.13133356506316685, 0.10474140542259502, 0.11567120761438832, 0.9653643646095341, 0.9424731862967599, 0.8971164471956539, 0.9442035930387421, 0.9528658837412249, 0.9127021430086929, 0.9245895248343153, 0.9586050842242433, 0.9086599338719709, 0.3825298103414211, 0.3668346186193483, 0.37130882627607953, 0.3891925343650565, 0.3807026004859274, 0.36283253716468544, 0.4079867542366946, 0.3790447660410591, 0.41748229509458434, 0.6895278775038438, 0.6044355123885298, 0.7658281320757392, 0.755049121094018, 0.701530418944586, 0.6897086522843482, 0.7293770834034288, 0.6628531970943973, 0.6969801213625707, 0.26002591361853766, 0.19056138511488874, 0.30657727252915623, 0.12382541174392847, 0.3955747840012055, 0.2216447099673916, 0.2024506892459893, 0.24243652934328308, 0.2279934821509363, 0.24522013233684703, 0.27190995167319065, 0.23039886136560195, 0.22752512412443837, 0.2838057820332267, 0.28588577042321284, 0.22718515594134037, 0.2717025838382463, 0.2463061456211577, 0.20601932486245766, 0.20711816369541258, 0.21466132456498477, 0.16185076407559207, 0.1985899817810981, 0.2071286726799635, 0.15796622639563285, 0.1720381302179823, 0.1744258042195579, 0.3032454108880055, 0.3179394823730659, 0.3546733077087072, 0.2895018188936801, 0.3319473518226054, 0.3552568720100946, 0.31644076684994593, 0.35845679225911076, 0.377986525796694, 0.11019275557121055, 0.09708534194438889, 0.06234790468150553, 0.1293843837265427, 0.11798305159561406, 0.08903688993396897, 0.14620026106435435, 0.13604877315530883, 0.06447271276018562, 0.2142881615755211, 0.2190020078156556, 0.22327505095965217, 0.2272857309774059, 0.21476615926753007, 0.23039779474254574, 0.24010853441471236, 0.2069770858270601, 0.2222304234378757, 0.5729728028140825, 0.606987039387562, 0.6220579275409083, 0.5986122191308569, 0.582089487092499, 0.6017061362790586, 0.6269831826117589, 0.6069061769536948, 0.611016670012276, 0.1317589266086887, 0.13220590466785198, 0.12948403735267888, 0.12150691551180315, 0.1462475024340245, 0.10562231063026517, 0.11311515628790514, 0.11723994691750539, 0.1263099303169234, 0.14779364034762488, 0.1701839810379886, 0.271820279159006, 0.18303652655438096, 0.24998306789228264, 0.19748258168925448, 0.1523383631383678, 0.17667516312741116, 0.2068588441771383, 0.3595358147488623, 0.3602520451624919, 0.36501062677859597, 0.4131977984296712, 0.4027082113416065, 0.3972823394637808, 0.3634506479256202, 0.4139797812479057, 0.41882539059055535, 0.2633031732635306, 0.2771280566965625, 0.2870567451594891, 0.28071164568335627, 0.2469689376319032, 0.2958693722751071, 0.2882116068280055, 0.2963292564607768, 0.3502687777843233, 0.19400849213809834, 0.20299581516947973, 0.19445403524872296, 0.19881454761802497, 0.20964389279299178, 0.23241777247676476, 0.24855362413894577, 0.24207116795831496, 0.19258661517635645, 0.3545684270625101, 0.22572037587967142, 0.22738065514050632, 0.2776226185832371, 0.18862913420596383, 0.24317651519549, 0.21362602121295926, 0.21266399638640388, 0.22410473120133634, 0.1986787106504453, 0.18187876874495335, 0.7250175645275703, 0.16217777109951714, 0.1840799900225376, 0.18565673363550872, 0.5994821786638043, 0.7728805184997235, 0.8259436091025646, 0.20853260911678673, 0.16731343056323145, 0.20849267505984703, 0.592666371145714, 0.16935105184496857, 0.1671245820755879, 0.6103783621621601, 0.665838580691659, 0.7651979411412653, 0.20223723165300123, 0.19527157754900404, 0.203545804422123, 0.19294256559416956, 0.18932173848358058, 0.19207519175848065, 0.19486019542945343, 0.19832430755592445, 0.20019069009317814, 0.08967837922616051, 0.11346006985373969, 0.09627887875875585, 0.08677178410485953, 0.09402770940140726, 0.08366151926094667, 0.13195030298503974, 0.09813484585182708, 0.08357969080315475]}, "mutation_prompt": null}
{"id": "590f1804-4931-47bc-bf1e-72b59e5d015f", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Adjusted for more robust exploration\n        self.de_cross_over_rate = 0.85  # Refined for balance\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Refined Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Enhanced stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.08, self.dim)  # Reduced variance for precision\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A novel hybrid algorithm incorporating Adaptive Differential Evolution, a refined Nelder-Mead approach, and enhanced stochastic search for efficient exploration and exploitation in diverse optimization landscapes.", "configspace": "", "generation": 10, "fitness": 0.3926176050950713, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7807600242426875, 0.7928279687451483, 0.7991670902765966, 0.8062735360425755, 0.8267379642043076, 0.8101355044038349, 0.7939256211585736, 0.7988357535016336, 0.8061025626898268, 0.6521576856240923, 0.6273259600990465, 0.6413674350420739, 0.6027870159565442, 0.6149095693439447, 0.6351836594725633, 0.6201652637353036, 0.6280909346131878, 0.6317769975637637, 0.1566940173627983, 0.2475795600408761, 0.16416083744034493, 0.16410331559422686, 0.16366625747874952, 0.14305872806741593, 0.1741175612987672, 0.15393280153877964, 0.1787972039060236, 0.12082675965065048, 0.10389799892241502, 0.13618021722258367, 0.12790811235719246, 0.13513921671835505, 0.11864690298603053, 0.11156616940393704, 0.11554692752560458, 0.1329082682123982, 0.9444454323918318, 0.9549082185237554, 0.9130883342482362, 0.9482523032580568, 0.9416115951714529, 0.9328069775152621, 0.9012195855003328, 0.9527378790189776, 0.9202547741288424, 0.44460687240727936, 0.44396624718021993, 0.41213768658962513, 0.4458463614018292, 0.45270445365687983, 0.4596272780214232, 0.45604288056877684, 0.4476772358287, 0.47234447239998545, 0.7067588842542825, 0.7880282425597465, 0.8523219533642143, 0.7309576011255811, 0.8542466392032545, 0.8027339645786664, 0.7879083683347688, 0.7939929866013026, 0.8442545742835549, 0.3545612029026093, 0.12661168654462363, 0.34355300659673826, 0.300599197945839, 0.27624694145083273, 0.24152097213148105, 0.2599465105632738, 0.3707352336045042, 0.36049002545340436, 0.3266016601940738, 0.2554604653191159, 0.18213051205162967, 0.29197917148775954, 0.3359397124907859, 0.38135767631645257, 0.3853020923459566, 0.3195828493122843, 0.26632086352949713, 0.2895635313204771, 0.3398785777142772, 0.4461650417251247, 0.297834893898027, 0.3510087162899732, 0.32609012612203947, 0.3579611204373885, 0.301426664999238, 0.34891415246882274, 0.4465836621457, 0.45242415833866234, 0.5039790198652816, 0.4636482734727556, 0.47663270441929184, 0.4834205153522122, 0.48564858410734824, 0.5582976568970024, 0.5457877838455674, 0.15508364211571568, 0.10751810934089467, 0.18614078803477085, 0.1521065265302517, 0.2531185255761782, 0.11804239743794964, 0.16017296797976943, 0.24433546205668677, 0.17170953370218178, 0.27578039894992534, 0.2820472256716917, 0.29967220497175506, 0.29007776470125013, 0.32069145581725245, 0.2993685035473349, 0.27490413056378715, 0.3280685273560974, 0.2858006086079351, 0.681490984371943, 0.6908428180894456, 0.6928190781185142, 0.6976272255041387, 0.6838960090405559, 0.6988711784282323, 0.6499515103641853, 0.6970981924584774, 0.6876888840865083, 0.1362742050155461, 0.12768877766232434, 0.13233851585838952, 0.13672073903690218, 0.3258124970238747, 0.11984831153559283, 0.13443213054869518, 0.12226056843092703, 0.11788926819104562, 0.25656771062666284, 0.21524162971191974, 0.17694964902677546, 0.2825805950947945, 0.17677516058526255, 0.2815906817172661, 0.1901612531505652, 0.22664751775684133, 0.2570327910495793, 0.4061991886858757, 0.43977614119425157, 0.414382896340593, 0.4325550071807447, 0.4624841700444621, 0.4529298279674243, 0.40694112667651317, 0.4980570455091746, 0.44411577674951896, 0.33487072643556437, 0.40636417570946237, 0.32740152694976765, 0.31732484092614865, 0.327780627478365, 0.33741041659076054, 0.3404666359741264, 0.39233312212201776, 0.3154430867396696, 0.21455388867819125, 0.2217684654210066, 0.22310519193774003, 0.19753686329218167, 0.22819105473916512, 0.25169466968931553, 0.21726972637116748, 0.2517039925972334, 0.20530470379355648, 0.2731132133968832, 0.20252003060614376, 0.22714957407925007, 0.25981903737603684, 0.24456269501341765, 0.23119174276023757, 0.2010045056469798, 0.44973900687777135, 0.4536655041147817, 0.745264757464009, 0.8485084486523522, 0.7406553874526363, 0.1692282337399782, 0.8194364282042594, 0.1668956906098238, 0.6381332612758286, 0.8004915766979229, 0.16021480521007103, 0.20521911257101766, 0.2074817945000842, 0.20990068005893392, 0.16738091597419769, 0.5491764184599046, 0.16653181684559204, 0.767676987852886, 0.750042512999245, 0.7340429310664532, 0.19524086243375283, 0.20293833259976046, 0.2024188455227035, 0.18828972256448684, 0.18901731045504155, 0.19440127065102375, 0.19625355238371556, 0.18231998129113658, 0.19152914209921457, 0.09481372010914058, 0.08705347026565036, 0.08520900469382464, 0.09996762009870186, 0.08183680468597654, 0.08971350667664135, 0.09808954381430635, 0.09924583214268368, 0.0913673890808182]}, "mutation_prompt": null}
{"id": "9282e010-3dba-4031-a957-23b38c0af50e", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.8 + 0.1 * np.random.rand()\n        self.de_f = 0.6 + 0.2 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a uniform spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Stochastic Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Enhanced Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  \n                        expansion = np.clip(centroid + 2.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Adaptive local search refinement\n            for i in range(min(3, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined multi-strategy approach integrating stochastic Differential Evolution with a dynamic crossover, Nelder-Mead enhancements, and adaptive local search for improved general performance.", "configspace": "", "generation": 11, "fitness": 0.3459913715105624, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7360022218880293, 0.7283497198250409, 0.7839790789203673, 0.7269355783872233, 0.7087686573192704, 0.7752597195510578, 0.7408794018247924, 0.7311422454915177, 0.7817133087593775, 0.5256731135679844, 0.4956259833194804, 0.6032357650329401, 0.5021589780306135, 0.49351984905945256, 0.5989374547162333, 0.5071508719019404, 0.4914174945196177, 0.5894279681802237, 0.1469400982715472, 0.15928491471828932, 0.16264131934588388, 0.1605322686863948, 0.12245108593803034, 0.1576913528459205, 0.29435687658777643, 0.1471435196102273, 0.1462431244050707, 0.1309133039271846, 0.10382255185172784, 0.13374278932905814, 0.14014648943759034, 0.11036246097198421, 0.11074075325141153, 0.12057360021040187, 0.12402127226761217, 0.13155729627397172, 0.9680783444164941, 0.9679132818857384, 0.9638434484452879, 0.9432821894686597, 0.9656302197672877, 0.965457977924094, 0.9715696447367516, 0.9719147996789306, 0.9189170233339136, 0.35766329998445, 0.36422369411534294, 0.4229843599973332, 0.3665085128779788, 0.32836898310439555, 0.4168741217263322, 0.34470258685317057, 0.3473370928565681, 0.4636619262023616, 0.68979642429404, 0.653840948307737, 0.7692941952717609, 0.8483839078228519, 0.7368493637138283, 0.7578148507097957, 0.6876651170691384, 0.623532251681659, 0.7327513585244562, 0.2803320712750962, 0.30896879593196813, 0.2909636983125884, 0.28549210051905827, 0.20131199261721044, 0.3410884060533831, 0.27410499182422443, 0.22547682452264184, 0.31014981922792206, 0.3169568661590023, 0.23741924360236422, 0.22619619083707632, 0.2629252966906557, 0.1764128966561429, 0.30185946421213516, 0.24284822623249103, 0.19551115660344498, 0.23619200661217232, 0.20595263632352967, 0.19867017830566125, 0.27483025748390055, 0.2013263329457431, 0.15447111915906475, 0.30530152902838714, 0.24062800787563643, 0.22830644855117077, 0.2973508104591256, 0.3384990477466572, 0.31906124137640235, 0.4360461833864169, 0.40631314123515283, 0.32362333117630515, 0.398052973641996, 0.39198350499168066, 0.3858504400177408, 0.5343973223104503, 0.041288775391851384, 0.04900449111926464, 0.061857269995372555, 0.10079397724593508, 0.12987012303368906, 0.19972407509922518, 0.1445305898614141, 0.10193003147990587, 0.15783810006945587, 0.22918321991127166, 0.21139051675295106, 0.253503409174217, 0.25113144377348684, 0.22373763825969695, 0.2850345282249589, 0.19111584882713273, 0.19776796614632985, 0.25513128580622346, 0.5844569381834697, 0.550574188270582, 0.6301756065925397, 0.564842765148738, 0.569442718080283, 0.6596706977031604, 0.5808457871498325, 0.5628332183654441, 0.6861943268201239, 0.10791221888869496, 0.10342434572251058, 0.1288829771680845, 0.16022193627406434, 0.16286085974744569, 0.1325795596776268, 0.14293715333955737, 0.10911933547958141, 0.13159507223352052, 0.3079073445657562, 0.18578734475706882, 0.22224041255834837, 0.23685102520703005, 0.17705785371894545, 0.16947624494153046, 0.15940297722063856, 0.18505868648668689, 0.15600549932829877, 0.34766482443883817, 0.3483995424877001, 0.4055281290787066, 0.32342663279181183, 0.3604741307753744, 0.43573709040090847, 0.3984866967877111, 0.3875864953095306, 0.4458605475373344, 0.28641633957307633, 0.28275199568913156, 0.35488139719747636, 0.24248130451981809, 0.2645367097063017, 0.3436729279550207, 0.26554426415263266, 0.27710682137559484, 0.32169072362827755, 0.1972977879730935, 0.20353112787917282, 0.21196388264509847, 0.23099972506410504, 0.19996108276842384, 0.2284278057880138, 0.1997890635718429, 0.20313402354137966, 0.19300262427256087, 0.21453387033804272, 0.18226304528991644, 0.2303865096011587, 0.21754405334101945, 0.20789692935180815, 0.20499966287273885, 0.19092176434185681, 0.20341160774085643, 0.20039398060788183, 0.18009318909114758, 0.18584318887127316, 0.18446949068827667, 0.16267417329114942, 0.18978139342500466, 0.17016680751484292, 0.7939155266459419, 0.5624073948762227, 0.7192822128590048, 0.7324768076304675, 0.21531797914895545, 0.7603148057656904, 0.6331326625479816, 0.20991984409847209, 0.16770473422602517, 0.46866172450816335, 0.8646677812834906, 0.6712861033109612, 0.2028947429508552, 0.1935900569223894, 0.18287913539664646, 0.17343696891434102, 0.2077489434040084, 0.19360361236000367, 0.19596456032971155, 0.18177152768032934, 0.20369840371425907, 0.09637516052194439, 0.09591769506134074, 0.09089658508890663, 0.09250679175053644, 0.09293468107511649, 0.08992676241025743, 0.08797664272506045, 0.09169423799459475, 0.09523144710173492]}, "mutation_prompt": null}
{"id": "da373a4f-1204-4a39-8595-0ec6e2485e75", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLP:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly larger population\n        self.de_cross_over_rate = 0.85 + 0.05 * np.random.rand()  # Dynamic crossover adjustment\n        self.de_f = 0.6 + 0.2 * np.random.rand()  # Dynamic scaling factor\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Dynamic Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Enhanced Nelder-Mead step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.3 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local perturbation\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)  # More refined perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLP", "description": "A refined multi-strategy with Dynamic Differential Evolution, enhanced Nelder-Mead, and stochastic perturbation for robust optimization.", "configspace": "", "generation": 12, "fitness": 0.36351144090383875, "feedback": "The algorithm RefinedHybridDE_NM_SLP got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7853490844516187, 0.7580791078563072, 0.8319487277456599, 0.7640129552885585, 0.7946948705907166, 0.7946765929553585, 0.7629434570511937, 0.7519950226017822, 0.8125042021707527, 0.5378688775305989, 0.5371520335126565, 0.6302755527838009, 0.5299185631799369, 0.5256042410701418, 0.6397071225875911, 0.5501692660889181, 0.5049465462062415, 0.6302376900329618, 0.16463466588950526, 0.2285699640053097, 0.12386730338025631, 0.13416530779375702, 0.15410429274909343, 0.22822626075722985, 0.11946108950904832, 0.13664861773746595, 0.2636914601028406, 0.11724950868283635, 0.11552298915281733, 0.12273461640180794, 0.09939646844197958, 0.10409167849974987, 0.11088650784406107, 0.12862731718357734, 0.11380090527788178, 0.11159413885332503, 0.9351778852874814, 0.9657597599282249, 0.9584179517016316, 0.9520822178021372, 0.9421216071726234, 0.9049622809780228, 0.9252386775962549, 0.9617632077449112, 0.9019499154043094, 0.3937136572030887, 0.40618939692428246, 0.4830031095297217, 0.3459418312584046, 0.36242881889495104, 0.49635567363999544, 0.3637462129927075, 0.3459857483061064, 0.48425052140599933, 0.35629695481659995, 0.756572802549113, 0.7239848033507341, 0.7152270528284415, 0.774716463372513, 0.8573965016695589, 0.8333149620919604, 0.7104787633138123, 0.7727446707154142, 0.26668037860717864, 0.2846915730526842, 0.5107591401491105, 0.3535600608765519, 0.2116396710435472, 0.345601717943156, 0.3229364132227013, 0.2061031570037276, 0.42288778782781655, 0.3165180833587854, 0.27520720215576433, 0.3200628978896545, 0.1928275303153245, 0.2794219117203628, 0.21572193714101218, 0.24862710043980574, 0.23479865792509746, 0.2368709340968682, 0.30718432109207583, 0.23371036703217074, 0.3702319793466783, 0.24914572838672766, 0.3626259305363466, 0.35206752948055386, 0.26065463511994413, 0.24620291339878464, 0.3774333360433153, 0.48298344781541735, 0.39978874572224665, 0.5676917500114871, 0.39397206811929675, 0.3813483183983448, 0.4623752504462507, 0.4094798859098051, 0.43298026384527, 0.5802061812004986, 0.08460926091891852, 0.0673038121877314, 0.13759531262615743, 0.15657415696805344, 0.13223333168163098, 0.2097990498206096, 0.16036491891215976, 0.16037690074298538, 0.20475789329857974, 0.30801691739584425, 0.2729165827189516, 0.3068628566432765, 0.2715843834659588, 0.26994433785815086, 0.33326967181328304, 0.25759312693920455, 0.24466562572250927, 0.3137771304035656, 0.6334923200816122, 0.5992503170536099, 0.7487258862076034, 0.67629484143651, 0.6569374991421357, 0.7678945340217684, 0.6289719424536131, 0.5891040800452518, 0.7272183440705136, 0.14350168252525508, 0.12006756866811918, 0.1659859162947016, 0.11756301520643864, 0.10458721229285661, 0.10649343468309524, 0.09856741361833288, 0.13972496890836117, 0.12105390211345513, 0.18083989396961153, 0.3167515249889772, 0.2457504325290989, 0.23639250999436923, 0.18198265363867938, 0.1598936085357433, 0.1699842302060277, 0.2598981879580249, 0.18923139492710173, 0.3650331773130713, 0.3602380142551326, 0.4653341560320027, 0.34809442530250934, 0.3678087818944087, 0.4491951265715808, 0.3503172238566945, 0.38105199641410614, 0.43989439479276793, 0.27082416671219744, 0.28412214056844265, 0.3335349842850658, 0.27246277062054813, 0.2531628085406554, 0.306822425941895, 0.2707187192984587, 0.29079416208700903, 0.34610724206481847, 0.2127450757562589, 0.20694809357221633, 0.21991260829760217, 0.19477521450333246, 0.20078412776040022, 0.21066401046583882, 0.19783157847591637, 0.21908685501476743, 0.20616721469040478, 0.2039356220470916, 0.19379156128720343, 0.48294440007821426, 0.20529636687717645, 0.19493934623937859, 0.3377816557142138, 0.21282849929757897, 0.2047309246288571, 0.20276588872066137, 0.6468314843920479, 0.8110585883124729, 0.18627197852978883, 0.6668974560073003, 0.18432170948730175, 0.1696288410351019, 0.7302560508712961, 0.835818094681074, 0.7844806547929144, 0.20320528799651882, 0.16269447236640067, 0.20336124269800315, 0.16545866071151727, 0.20508076253197638, 0.16642980176925426, 0.1939808464044509, 0.8293699040392094, 0.2055087356948876, 0.1808608589109193, 0.18694353613804449, 0.1878833616331429, 0.18884504658365897, 0.19363057074626244, 0.19019943249120363, 0.18963571200554685, 0.1854879842228695, 0.182848161959142, 0.08447417821484504, 0.0812496724524443, 0.0893957620436946, 0.0765720742188587, 0.0937995302277701, 0.08124719180682038, 0.09704770943185015, 0.0798446056740606, 0.09182366735890324]}, "mutation_prompt": null}
{"id": "7898c686-e343-423e-b3f7-40d5df0b41f5", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.15 * np.random.rand()  # Slightly increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_Refined", "description": "A refined multi-strategy optimization algorithm blending Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with probabilistic tuning for robust performance across diverse landscapes.", "configspace": "", "generation": 13, "fitness": 0.4438622682747481, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8366611568896094, 0.8382155741051531, 0.8371224990904471, 0.8518044590649307, 0.8452613787957501, 0.8524241248682318, 0.844475889260911, 0.838672378327044, 0.8493326563119863, 0.7190604702895275, 0.6866784798277583, 0.7078469610305271, 0.6884956920211419, 0.6982608748068073, 0.7064628492858995, 0.6833829056693184, 0.7179062315884335, 0.7136463814771933, 0.16374212366200935, 0.16634040882134427, 0.6807020220075213, 0.16177599658170472, 0.13261362407453814, 0.14191578538262495, 0.13908525751802103, 0.1590076083978078, 0.15805113629715395, 0.11325411477469971, 0.11562990515109428, 0.16756565431846826, 0.12878519210788364, 0.1149760665734666, 0.10594992444914753, 0.14353684737269579, 0.13228559910348536, 0.1038875777339785, 0.9451282351817739, 0.9475087458655396, 0.9194939508273858, 0.9180062941165241, 0.923221956037069, 0.9551458352843786, 0.9257894504747274, 0.9357277009027937, 0.9686281659004924, 0.5634668488889389, 0.5635958685992023, 0.5408277687934351, 0.5583716815132608, 0.5791299670005507, 0.5672664607319651, 0.5691523519104533, 0.6264790121497819, 0.5824623846716841, 0.833105232099045, 0.8440360217156837, 0.8231029277284154, 0.8231690357758457, 0.835198687666364, 0.8447988955869199, 0.852607283283694, 0.854426360229114, 0.8809460665615285, 0.38917412113105654, 0.3225357562627159, 0.3232544778172486, 0.4119066285386781, 0.3907560209141414, 0.33822552461844, 0.428160294747167, 0.5372561874058235, 0.39061012538377593, 0.5006634272464262, 0.3060394680185805, 0.28696589751323576, 0.1301826487596296, 0.40762574429355114, 0.3968283117609065, 0.3743884116454288, 0.3391051198024809, 0.13021614320500663, 0.5605182273545253, 0.5125661192220606, 0.5500601125023836, 0.5001130469691637, 0.539682843926103, 0.5830716236619211, 0.5643642874200545, 0.5389570821176103, 0.558321988705365, 0.6430353324955305, 0.6643589893363364, 0.6812515815853127, 0.6648683959644421, 0.677143595425472, 0.6818914866751852, 0.6853053225424066, 0.6813641092076436, 0.6870060726944494, 0.11232429669821453, 0.12377542396862429, 0.1908679311150523, 0.44306989969087873, 0.4654690654933086, 0.2908283983946992, 0.30758141453465393, 0.19723162478198897, 0.18757744476843086, 0.43424803112026, 0.4606986857188382, 0.4391219456438924, 0.43716446354093585, 0.468065732766745, 0.48175084858521344, 0.4249629555128013, 0.4500758386535665, 0.43859401548995325, 0.7454574732485519, 0.7828053944072738, 0.7922179789783015, 0.7550550530604241, 0.7823175982521804, 0.7890404638885349, 0.7618114315272781, 0.8037046851546729, 0.7760294959494689, 0.1776440246779113, 0.1303995829221194, 0.12895190454770256, 0.13665899417932925, 0.1382940408383363, 0.1879381004553864, 0.12056282111799266, 0.12717899655449982, 0.5274666020519523, 0.2450956164078426, 0.23034732221417464, 0.2836097455397514, 0.2126506758739033, 0.2617495679740547, 0.22423834175044155, 0.30015366524403175, 0.28154084421366465, 0.22719210388996858, 0.5590308110000408, 0.5182815170730513, 0.5502897693675857, 0.5247198110152311, 0.5481022737335612, 0.5428273556738531, 0.5388196118475865, 0.5590214104902982, 0.5488596210417548, 0.42254631789915464, 0.4943998355703053, 0.38984701483538853, 0.45049454317671533, 0.2714289807217618, 0.4055874828339513, 0.4260716521678177, 0.45842728647569375, 0.4462077492559182, 0.220540769992575, 0.20844070475157062, 0.22003627219553257, 0.22613847817593324, 0.20873323068144234, 0.20652409112204728, 0.23024659498259248, 0.236312683467782, 0.22750948929235904, 0.2356372332193558, 0.19883566932983376, 0.2200827869880203, 0.23219597247568458, 0.21754368130281543, 0.21445260083584083, 0.21981732692278233, 0.2187618545705804, 0.21171807793187514, 0.1831318830058799, 0.8141522355069815, 0.18535053612805052, 0.1610881934739673, 0.869298983372187, 0.1567678956405707, 0.788360162241064, 0.7232594803541663, 0.16709697141187807, 0.12821959181721354, 0.8624745768157713, 0.21016740459192695, 0.21015409667675777, 0.1675283953458595, 0.16807879574928264, 0.21079305978285334, 0.8576795155295417, 0.7561778403613657, 0.20877141172254854, 0.18893082479113565, 0.22638460502207713, 0.18448094442851093, 0.2271991271294217, 0.18534060114390127, 0.2577811474894167, 0.19481711857032635, 0.19747042526077152, 0.12230771016528963, 0.10128407285757535, 0.0999612742837257, 0.09394919979981331, 0.10890760218756879, 0.12031085398610208, 0.12478225883782212, 0.10476559524059192, 0.11163092940244201]}, "mutation_prompt": null}
{"id": "ccacb9e1-d79d-4aab-a159-85d8ba759bb4", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Adaptive Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with adaptive perturbation\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined adaptive strategy combining differential evolution, adaptive Nelder-Mead, and randomized local searches for robust optimization.", "configspace": "", "generation": 14, "fitness": 0.44683154970520894, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8333159066900753, 0.842668223934753, 0.8383961939821355, 0.8481459575957702, 0.8598086788514315, 0.8487893624682535, 0.8536593731005104, 0.8445402617598318, 0.8545736136394217, 0.6981968476135041, 0.6986139643047521, 0.7194527640924062, 0.7217540082761322, 0.6947665405573589, 0.7371381073759069, 0.7092236675222089, 0.7081396736790246, 0.7219703444501753, 0.1141434057285764, 0.4947132787078019, 0.17651912393065705, 0.17144707792816993, 0.13152043325322715, 0.18818263707165572, 0.3092932823584209, 0.5736038202384759, 0.5595678438862787, 0.11196466013157447, 0.12353261637226332, 0.10860403336826108, 0.13287456994574764, 0.17312613795351606, 0.13027455586547654, 0.11461959580578729, 0.14348481027106352, 0.13386321732691375, 0.9283204512126306, 0.9425448220027363, 0.9343974337570191, 0.9135694294538704, 0.9206342049788296, 0.9018069908550749, 0.9041585736259914, 0.9396154416300987, 0.9269289622212171, 0.6005366946652381, 0.6028727454614302, 0.5540308662853466, 0.5588608166109585, 0.6330978017604459, 0.5689501006916418, 0.584617996247736, 0.6407911356327243, 0.5860319406865979, 0.8612943306605805, 0.8826823954725815, 0.8352290160713272, 0.8947183313577141, 0.8657910577999391, 0.8756784762216869, 0.8900594533394411, 0.8569669828207229, 0.8464210545232237, 0.5622591711472416, 0.44023967386920937, 0.3823604850006713, 0.38957746887016587, 0.5393748466022888, 0.2728326351029219, 0.6261504501328545, 0.5619997976276963, 0.3706777374849629, 0.44525132864647166, 0.3735600249652028, 0.34857257067205427, 0.3623109094756731, 0.37672794227757744, 0.3065479330386728, 0.2798267031388467, 0.2241208921485377, 0.32635128613414544, 0.5921627256233288, 0.5629987726239327, 0.5999403391065707, 0.5086904421059711, 0.5790123615540669, 0.566129808791574, 0.5594660697021718, 0.5524076446149798, 0.6166355099571843, 0.6519401276279626, 0.6883686198068817, 0.7155871926382025, 0.6806703220849928, 0.672184580188579, 0.6487823775696051, 0.6732193773903018, 0.6959865456563885, 0.6910856123755198, 0.30929362771219726, 0.22640916749857787, 0.05633668826330318, 0.4046763193414711, 0.41681265977580284, 0.18160455871289238, 0.16702281840856903, 0.20700496621333941, 0.32283331127111725, 0.43435869060198307, 0.4140899581612, 0.4462644058414891, 0.454133853166936, 0.45431881575964994, 0.48268066861105163, 0.45699877673808253, 0.4803203074977259, 0.43859855365796707, 0.7947410684635109, 0.7970534892662205, 0.7750841960942588, 0.7777598884007627, 0.7873058497923234, 0.7919641606797045, 0.7375469578236294, 0.7686538195966056, 0.8002329838951531, 0.17197256976602415, 0.12974867065283346, 0.12142875954179266, 0.14300735496826633, 0.10916172643543087, 0.15378595161536301, 0.16558492796672597, 0.12973386299683554, 0.11450647910423817, 0.18090094670461698, 0.2366326430300547, 0.29472837990578016, 0.5010773236529076, 0.22785528443456848, 0.43431334627611273, 0.20186168360386603, 0.5835972499870046, 0.3997781426433943, 0.4894863136370514, 0.5629431875321366, 0.48501843627899766, 0.543748519179464, 0.5123548593239586, 0.6294665293824994, 0.48721391850064977, 0.5618139503029278, 0.5998206556737973, 0.2804244044008811, 0.2982712367241105, 0.34324059666448736, 0.4183372298677346, 0.4522758217215833, 0.37611195849190593, 0.46842665875469836, 0.3349007704749092, 0.4085986468759827, 0.2623537302785547, 0.22565951183381772, 0.2094328055330471, 0.21152727563542562, 0.19565961957621958, 0.251428125223067, 0.22722117668124098, 0.20776393582361385, 0.21727315689717974, 0.23741467535477678, 0.20393157384361593, 0.23332855489723814, 0.2237791182860266, 0.2092739273918104, 0.4938375819946429, 0.21377872523871022, 0.6038543873066742, 0.2437910155178039, 0.17180284867886242, 0.19670646523769686, 0.18431070458657484, 0.16098259075526877, 0.8684953764747068, 0.16637379215143755, 0.20604157000147605, 0.1713292075976819, 0.8316426243345022, 0.1276874216165601, 0.20926683921120637, 0.21122774590075233, 0.8225140257029901, 0.1681402372839519, 0.16748891530040533, 0.20909031956897517, 0.2125954919659857, 0.21090631188413422, 0.19557014374994575, 0.1990238701343625, 0.1917551163560266, 0.1969422422920719, 0.2037777535122718, 0.2142572515857466, 0.239161247194002, 0.26081535675491374, 0.19087314262897848, 0.11819984474266854, 0.08818690757980296, 0.08723496167024092, 0.09332275833408077, 0.10227889550197211, 0.08933750019678754, 0.1351760100655991, 0.09556585879155233, 0.09088854951062386]}, "mutation_prompt": null}
{"id": "a1b86365-7260-49a8-bcdf-fe20a5fef394", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.85  # Slightly adjusted crossover rate\n        self.de_f = 0.5 + 0.15 * np.random.rand()  # Slightly larger adjustment range\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with even more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.laplace(size=(self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.4 * (population[j] - population[0])  # Adjusted contraction rate\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation radius\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_V2", "description": "A multi-faceted optimization approach combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with enhanced population dynamics for BBOB test functions.", "configspace": "", "generation": 15, "fitness": 0.41652865973175807, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8192776203003078, 0.8230735524543611, 0.8208834374303956, 0.8321249028454659, 0.8438868406390266, 0.8299322059962119, 0.8198841661529845, 0.8374521192536791, 0.8360251037184889, 0.6949483053465462, 0.6834710464990436, 0.6622132765471962, 0.6802720607417846, 0.6987328163634289, 0.6828900603318391, 0.6865628482209828, 0.6918109419081733, 0.700793012537874, 0.1530943720673862, 0.166698946009049, 0.13275647163342708, 0.15996996808656427, 0.12301913106071738, 0.3895338811707014, 0.42516323378159626, 0.5176592106836144, 0.2687512433473995, 0.1290676447149659, 0.11135363786064845, 0.13875874745140848, 0.13553580425870293, 0.1410990610371997, 0.11194992039492446, 0.12693755510914362, 0.12004533338009771, 0.09962539374112989, 0.9756948855256035, 0.9311280644714061, 0.9670026361540144, 0.989846253107456, 0.9945205564509595, 0.9926064418769572, 0.9911771240467676, 0.9995114638373916, 0.9288471900074017, 0.4821488345591062, 0.5483093331183341, 0.5282126385990269, 0.5673973089116726, 0.5519110897503197, 0.4974058525641091, 0.532140712136304, 0.5522595948658915, 0.5533208775883334, 0.7931454289199811, 0.76134503135645, 0.8053433046160621, 0.8367985602748891, 0.7831321181807533, 0.8497834785798315, 0.8272192759512507, 0.8679519317721245, 0.8232086240252634, 0.25562737372324174, 0.39096817100487236, 0.29403695088236526, 0.37397304762901584, 0.1381092278655497, 0.42167790656504844, 0.45727871639900686, 0.38005354080978493, 0.3858762114029466, 0.21986767124494722, 0.2778805524740734, 0.19203554213164686, 0.3492004340082727, 0.4847892609612042, 0.25152517096493876, 0.2596745190896068, 0.19088265720346753, 0.37712235272903094, 0.22159571116264143, 0.2843355832386263, 0.38034148586178707, 0.41265427443483027, 0.4740216469693538, 0.4266305890422786, 0.43171530870352903, 0.3386391037779153, 0.46962014564276855, 0.5881401069411127, 0.6149481003113056, 0.6033597506547453, 0.5405862388301421, 0.5330355800194363, 0.4194303333081081, 0.5542540244961565, 0.6497765925702472, 0.6060009242160362, 0.1456555062661229, 0.20415569783316367, 0.17429989103851928, 0.3161171918117307, 0.2162908160805851, 0.35112281182736393, 0.19632914318450367, 0.3244609756066862, 0.24373668634001944, 0.3392725877963543, 0.36690229002946073, 0.34400535650526476, 0.3632434986418934, 0.39453219274012885, 0.35768911404198755, 0.33451616687553676, 0.3385226983994025, 0.3803705005580653, 0.7387437159177667, 0.765544450721922, 0.7592807483134657, 0.7057678447183846, 0.7413806982347085, 0.7527403710102862, 0.7450686819654493, 0.7542219541729125, 0.7453306159010475, 0.12571575838426874, 0.14494773690729268, 0.14592723788624828, 0.12273751126682853, 0.14798237035683492, 0.14238136880255847, 0.14987967025769633, 0.11307829212136644, 0.131683418399822, 0.16734323938067375, 0.15404622278333302, 0.23192347344745345, 0.18905168129453964, 0.23079271172296467, 0.25122898601859245, 0.25107729515866284, 0.5007397103073388, 0.19873392172643012, 0.4619784929675269, 0.4611836769256815, 0.4743558327026499, 0.43677344479116054, 0.5039389101981058, 0.37863711133201605, 0.4954426259627098, 0.49235452740905117, 0.5640948114256201, 0.3748072658667915, 0.4016665339034061, 0.2979610779200704, 0.19946979945313792, 0.33427508029537256, 0.20650174190058856, 0.35499362162800985, 0.40681142754633304, 0.4297167460049566, 0.2581002129248323, 0.23770666905618298, 0.18658467710171434, 0.23090587917425753, 0.21508383827897537, 0.19492678730007817, 0.21787662839152155, 0.23017800837116342, 0.2219972948861808, 0.18528832461132405, 0.20320706386537946, 0.1926047646179202, 0.2320733516763911, 0.2034104990595218, 0.20933800652781553, 0.1958994331824413, 0.20371050351475994, 0.6144003537348216, 0.16260402694468157, 0.19525057871955642, 0.855117059021562, 0.1634415816965411, 0.20844800637681804, 0.796183873322708, 0.1692116618840135, 0.20579935497370383, 0.8309911018323061, 0.16633557438998836, 0.7959410647155026, 0.800840482817655, 0.7268030584872125, 0.202119798566897, 0.8003858610589729, 0.20981341765699668, 0.20741391629227124, 0.7451465179234197, 0.17674917484198227, 0.18816803189732845, 0.1781000157325745, 0.1860117980924273, 0.19449681233483207, 0.18225628051768017, 0.17710323286869156, 0.19644590200626244, 0.19494847813013017, 0.08232727606936474, 0.08293921939855442, 0.09298975963142242, 0.08604439820517851, 0.080910776140105, 0.08483982518807043, 0.08746438218711461, 0.0825743629037895, 0.09085871037515358]}, "mutation_prompt": null}
{"id": "4a4c9fde-42b9-413f-824a-bcc5416fb36f", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_SA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly larger population for more diversity\n        self.de_cross_over_rate = 0.85  # Adjusted crossover rate\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # More variation in mutation factor\n        self.simplex_size = dim + 1\n        self.initial_temperature = 100.0  # For simulated annealing\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a wider spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Simulated Annealing for stochastic local search\n            temperature = self.initial_temperature * (1 - budget_used / self.budget)\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i] or np.random.rand() < np.exp((fitness[i] - candidate_fitness) / temperature):\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_SA", "description": "A novel hybrid optimization strategy blending Adaptive Differential Evolution, Nelder-Mead simplex optimization, stochastic local search, and simulated annealing for enhanced global exploration and local exploitation.", "configspace": "", "generation": 16, "fitness": 0.2695083725562189, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_SA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.18.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.4456413222398433, 0.4484156151107862, 0.45713056987198386, 0.4554404600211549, 0.45032922425975674, 0.44726665119411624, 0.4287906213751129, 0.4460370641820097, 0.46749465904185805, 0.5590625378003552, 0.5654318090277863, 0.5580693205505224, 0.5638054227273683, 0.526193686092253, 0.5699469540823162, 0.5473561582218165, 0.5574493744289819, 0.5691486669320359, 0.12047873405401388, 0.12169888096978354, 0.12143985177534611, 0.10971344420688789, 0.11745995471329829, 0.11602050444128986, 0.11251243941451994, 0.13110750710279895, 0.11902092295942057, 0.09798233097335018, 0.10318684904821496, 0.11906547369187392, 0.1010325803616906, 0.10418385595459911, 0.12281240598114895, 0.1103626200435659, 0.10046621081416707, 0.10087654120192024, 0.9211336334466103, 0.9388017256749565, 0.8897304653905946, 0.914405251168974, 0.930481472132936, 0.8907607949489705, 0.842750836199887, 0.9115490901821183, 0.9058945727826004, 0.291090528217005, 0.2769445343383884, 0.2854331376074395, 0.30200745646380167, 0.2816437960916308, 0.2667965782894397, 0.3070569875817982, 0.31626371057129443, 0.32334268191481663, 0.32776913259539775, 0.3151324627993157, 0.5079320715308939, 0.3403878124868569, 0.3273338912136695, 0.32341671906885605, 0.41420117996100647, 0.4212552584587844, 0.4306952824703081, 0.14097149598744485, 0.15161323595179255, 0.15230176587733602, 0.18903697774629102, 0.13814379805289723, 0.16965537217410986, 0.15346732762092452, 0.1707372023308571, 0.14920675431896724, 0.1503679317778822, 0.15358299771412098, 0.1475666210922607, 0.1513147671322227, 0.13775516204978921, 0.15263125959029855, 0.14957595282113711, 0.17331730290704417, 0.14977484534115393, 0.19410484003113126, 0.22052650622972636, 0.2724245387710371, 0.2800918639927956, 0.3077943032433751, 0.2998398665484606, 0.26878627327132554, 0.3028838976524295, 0.30719841149449534, 0.33781928336913447, 0.37460463241398034, 0.3295847713641449, 0.3297014657292452, 0.32840877998891616, 0.3685522316097004, 0.43711112737973534, 0.39792248976995614, 0.42453635418994606, 0.10600933123641787, 0.11424357462982337, 0.17763424874126343, 0.11133731664801128, 0.15822390452177137, 0.16166018144465544, 0.13095788278508058, 0.21756154464211774, 0.0904979353363804, 0.11863983161237579, 0.11123956772100851, 0.10991588394714258, 0.12040335059545537, 0.11982004862365558, 0.11259127535135482, 0.1175566646923909, 0.11399558819095346, 0.1106854262031709, 0.39027685103811127, 0.38145529340577966, 0.3853998940649852, 0.40708421299436637, 0.40658888351522626, 0.39769592589390323, 0.40336302912245114, 0.3960384310773942, 0.3979407620345381, 0.1252396628253165, 0.1270809488702127, 0.13850770529972833, 0.11770006712173942, 0.14260394576149316, 0.1136280635645448, 0.1267852628336832, 0.10115991341543051, 0.1204813938152196, 0.1476515266739663, 0.1417385161792345, 0.19054740651219604, 0.21472502098427582, 0.15895203036533223, 0.16906904185673188, 0.20740849844791043, 0.1757337877517946, 0.22147593741742289, 0.28952313625708126, 0.28549334214443745, 0.29026749720353295, 0.27365736524077466, 0.27940523320287225, 0.2928782364161352, 0.28024804227090794, 0.28803844049694693, 0.3008535609608347, 0.21608269006249514, 0.2309132146607077, 0.22332475646950112, 0.2129500801808636, 0.2245191015123733, 0.2213598724366862, 0.2227638079013935, 0.22148662597495816, 0.22720459642874125, 0.19856522376655383, 0.1993904264686901, 0.22370780777513632, 0.21634041196333798, 0.1827621966655274, 0.2131009910163545, 0.20208573555931275, 0.2418188133449175, 0.20279553078189494, 0.1858814734648282, 0.21272363185672793, 0.18745292320288398, 0.1756264887487634, 0.2120184772020427, 0.1876970972238201, 0.18777301236650457, 0.1750265508783172, 0.1803519074366935, 0.2101638906031148, 0.15486749538237565, 0.5965159206384026, 0.1659314411073194, 0.1951274859716826, 0.6307307570603147, 0.5075231875970881, 0.4481453590248573, 0.16937777879782534, 0.20466475988395627, 0.20492389106848652, 0.20676291704637806, 0.3730283924087452, 0.16938611310177842, 0.16720867128235384, 0.22447402857359866, 0.2651121071313872, 0.20602166955326817, 0.18139752097200568, 0.18766567844159832, 0.1841000202961438, 0.1828536623848439, 0.19402542134815715, 0.18827616617127385, 0.18580303369688966, 0.17943838331593653, 0.18958892503895508, 0.08479924263725858, 0.0991055911523665, 0.08694874481013415, 0.08999030062566415, 0.08432822429562548, 0.09299500072535816, 0.09119118759173284, 0.08935438459240053, 0.08703255251206743]}, "mutation_prompt": null}
{"id": "58486684-10e0-4053-95c2-309161ae32cf", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased diversity\n        self.de_cross_over_rate = 0.95  # Higher crossover rate for exploration\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Slightly more variability\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(7, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with strategic diversity enhancement for optimized performance across diverse landscapes.", "configspace": "", "generation": 17, "fitness": 0.44510142690198606, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7944475096448154, 0.7964355453475667, 0.8118260242302568, 0.7821632313553055, 0.81263237519491, 0.7916452000276082, 0.7959363645061184, 0.8140349822691144, 0.8128296081438211, 0.6193831602049324, 0.6080544021883548, 0.6066547501607851, 0.6304123824814734, 0.6007460992011793, 0.6296806802901009, 0.6179193101676372, 0.6222288105510516, 0.6201495611200163, 0.1412261209476614, 0.22752297545147304, 0.2306790453716504, 0.3324241387346235, 0.12891536037414864, 0.14835088014805353, 0.16724383317828628, 0.23045597821303387, 0.13977438245461904, 0.11499406836925885, 0.11505911967237248, 0.12417177715477323, 0.10144380993580782, 0.10109909334118106, 0.11929319372044078, 0.12750233080815798, 0.1159989042155285, 0.11418973411888078, 0.9059814574837504, 0.9535936019801897, 0.8853582633885037, 0.8865857837940465, 0.922862650589191, 0.9002486967335623, 0.9405830399860695, 0.9292410385298994, 0.8730580046097032, 0.5035423378753092, 0.47092343770455447, 0.5172237459215614, 0.44411023735530075, 0.4551953782553091, 0.47889578433691693, 0.45501153875749933, 0.4812837415712502, 0.5161276177743106, 0.7883702864940467, 0.7933191283247132, 0.8427399822130716, 0.8821711752634365, 0.8114506158670847, 0.8253241320007688, 0.7723574298713717, 0.871128090676325, 0.8474101584380371, 0.5886629540965773, 0.5666330355879473, 0.49519475369706756, 0.34062085473082804, 0.4633086834166269, 0.3717252425998888, 0.3928951442870715, 0.34968012113752744, 0.437087345529939, 0.334017747323204, 0.3062916430520558, 0.4096372587526116, 0.5163773108604142, 0.488100032537626, 0.47465927488488935, 0.38618490950429474, 0.43869451608640764, 0.47828714958954344, 0.5228163592146141, 0.532682233562648, 0.5243330847914301, 0.5409273459632777, 0.5223839302817566, 0.5451548640988465, 0.5508059182899041, 0.5398215171282188, 0.5557976259123126, 0.631780014252872, 0.662832026947602, 0.6871215925260629, 0.6502633679071228, 0.6130068656236023, 0.6499731910455602, 0.6459125773362651, 0.6579074949132053, 0.6462938627163762, 0.08649253442427485, 0.27211557955690324, 0.25905582914631275, 0.345746365718528, 0.4463767724696035, 0.3918103906210506, 0.24212999873207386, 0.27351303565796237, 0.2589563584210035, 0.384032853568991, 0.38647708104761747, 0.4086969837021407, 0.38194929878747463, 0.3966662424049088, 0.4024217799087497, 0.37787754860981815, 0.3786038638034913, 0.3961988009643246, 0.7339724486621241, 0.7351293207033713, 0.7512733348538895, 0.7504314341138979, 0.6992528639212958, 0.7649895239254865, 0.7364533686112696, 0.7275590847135354, 0.7428744248474342, 0.15550485060817443, 0.1145391535014132, 0.14988282743538217, 0.12765779245255848, 0.1247083781224183, 0.1322808365139363, 0.34690267067607405, 0.13154039650674454, 0.14150903995965158, 0.2486298830801269, 0.1809087603266223, 0.45419230547740086, 0.1587802274108715, 0.43955326096184644, 0.4447988890310085, 0.17868258229337242, 0.21120346157134962, 0.44060481294550446, 0.4503282121923987, 0.4663122044918848, 0.5162785123068834, 0.4586861078126322, 0.474959587812956, 0.44064842835085616, 0.4838291008049411, 0.4580279261581599, 0.46833299753057567, 0.38539512599563464, 0.41706373917355266, 0.3937862219341549, 0.3929962951775593, 0.4198118169323971, 0.4444184341514562, 0.4131817225948521, 0.4043634925756091, 0.44079690025337825, 0.24028130571466777, 0.21679992834065687, 0.21466762843301646, 0.23212312438931604, 0.2150158458082163, 0.24016876329455883, 0.20399081083200998, 0.19956539267138385, 0.2118869104741542, 0.21445899681302738, 0.22569332804539055, 0.6393288726736379, 0.4882916219510932, 0.23531343679697492, 0.22536022153200297, 0.21390098775071253, 0.23964737989032814, 0.22533442293807748, 0.2116405786634561, 0.8763627594556678, 0.7725936627694356, 0.7063099625521072, 0.8482561704395, 0.17663395093716483, 0.7839566574072313, 0.8434372831819877, 0.772349042081904, 0.16703196075379534, 0.7781524355423763, 0.20871875023209585, 0.1975292298289364, 0.8329258481286205, 0.604228264226055, 0.21007337262742698, 0.7326382860022618, 0.2124408991832898, 0.19896129996189393, 0.18505367150932073, 0.20254791885932932, 0.19430406090828845, 0.20257328487749293, 0.20471297922883203, 0.19726508976090895, 0.1947255964850675, 0.19338276562463685, 0.08950434855464395, 0.10352782507440483, 0.09674442182910548, 0.09893861345252897, 0.09087114837876831, 0.09973913655383826, 0.09302319949313986, 0.1012400205910613, 0.116036711024326]}, "mutation_prompt": null}
{"id": "ca5ce770-b991-4809-9c16-a1a8b64a85ce", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly larger population\n        self.de_cross_over_rate = 0.85  # Adjusted crossover rate\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Strategic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted expansion factor\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.4 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted contraction factor\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(4, self.population_size)):  # Slightly reduced applications\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Adjusted local perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_Refined", "description": "A refined multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with strategic mutation factors for enhanced convergence.", "configspace": "", "generation": 18, "fitness": 0.3795949377071441, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7782158231626028, 0.7885213246318775, 0.806216286626221, 0.787759221904705, 0.7906448421519554, 0.8033340607015866, 0.7976000769005509, 0.789028654740896, 0.7921627364285149, 0.589460555655759, 0.6130173369541636, 0.6226825744645982, 0.614419821702541, 0.599094946955298, 0.6297583561290243, 0.6091636758260313, 0.5816093503899371, 0.6365251533445526, 0.3053057823898444, 0.13507797639162578, 0.1188125015860716, 0.15768854396101273, 0.1261687086754535, 0.24513380921363548, 0.14440503842145536, 0.14435037809362672, 0.15288512173242597, 0.10844623637926487, 0.130686587490619, 0.12149884567526059, 0.131230157050386, 0.11151191123280535, 0.12160520090858895, 0.11707901291471112, 0.18776440557667606, 0.12818397539100623, 0.9358099605095138, 0.9461344417067983, 0.9394944247777581, 0.9064603607024896, 0.9240493797087093, 0.9696301894421032, 0.9470594555629541, 0.9224398860052525, 0.9362112668428887, 0.4381093812723327, 0.427069892642553, 0.40867559786365404, 0.37951527849960054, 0.41449706086026994, 0.4298746002763847, 0.44206561544791034, 0.4477911610977505, 0.4547638876109742, 0.7578248975272579, 0.8547122138343126, 0.7575811133976849, 0.7195643545527143, 0.8701359383336661, 0.7753075192107486, 0.7424835771827649, 0.7389236869603847, 0.775297101002573, 0.20082000065066585, 0.3128837449520492, 0.3008182855409872, 0.2880934414730121, 0.22568962039188556, 0.23904821853200797, 0.3909422077210588, 0.32220055429264904, 0.30978775885195475, 0.21974983730511355, 0.28827089650734883, 0.31205484205817435, 0.2891719809600798, 0.28209788273728076, 0.23805666919424529, 0.21174200662771914, 0.2906180205592954, 0.29157437862966185, 0.30159449163347196, 0.29662657000258563, 0.3374913275373995, 0.31816656901381135, 0.3207090015729336, 0.32529779902125633, 0.2868946745015355, 0.29390131780750894, 0.3277794941009806, 0.42583044295267813, 0.45576701765360117, 0.43657049882934096, 0.4030224307457575, 0.42427211605144577, 0.4169930797361956, 0.4723507515021854, 0.5081414950945116, 0.4919084967428907, 0.10246703752751818, 0.17888236340618735, 0.07016039825792464, 0.1741089126611418, 0.21045494175009694, 0.1371610818961575, 0.09617776600876693, 0.2543156429277511, 0.12132424330627778, 0.23233213353626325, 0.2716833211302562, 0.2720579759135717, 0.28383396283839424, 0.2958322636891154, 0.3111142246715187, 0.25701704480518406, 0.2657627439559528, 0.2788303587213683, 0.6773974113793949, 0.6793955914433274, 0.6749793605579266, 0.6526060715367992, 0.6835893840238276, 0.6519844593886668, 0.6870092818873148, 0.6779630895402615, 0.6856343249882313, 0.1388118203319807, 0.12725408547372608, 0.3332598588078658, 0.1407477565859181, 0.10045837867299268, 0.12648162062373647, 0.09985781012420558, 0.12547119495100556, 0.10350235926372175, 0.2723769826570033, 0.1540056927352842, 0.1944898672108497, 0.164756746300317, 0.24331287732696494, 0.21105734618253924, 0.21325200655662546, 0.2131368473743619, 0.2059447621644519, 0.3842079781579989, 0.4059427875275654, 0.4081847700260528, 0.4088992985294968, 0.4134118224608547, 0.43415760203459364, 0.4027833457631287, 0.41892081031667805, 0.4364977520668508, 0.2807441378125607, 0.3056319757808871, 0.285047896726506, 0.33578873036254264, 0.28891397940094654, 0.3341424865135777, 0.31484536461602797, 0.3401645390967456, 0.31979501013866884, 0.2029787101404359, 0.19840033049525863, 0.20486955199990453, 0.1973667905176153, 0.2024665801194958, 0.20352734999294442, 0.2123688792305467, 0.2109378930148993, 0.24474502985878877, 0.2233470625589462, 0.20528541445468673, 0.2207258116263271, 0.38460911669814335, 0.20913762524275858, 0.22203294873138057, 0.22016760650194178, 0.22302925972387366, 0.21092408645810568, 0.7334510184281386, 0.6533176857472991, 0.767825491104867, 0.7224519381157186, 0.7497194093705943, 0.1976498008003975, 0.18210722576919447, 0.6628178919244907, 0.8346276481869763, 0.8016593042414919, 0.16559560330642165, 0.2102431632327647, 0.7366286401086615, 0.20469131759103398, 0.16692181507014026, 0.20832625554358541, 0.7165768973316824, 0.6641356132028071, 0.19864827349941894, 0.176993165958088, 0.18730342988194038, 0.20980036779511846, 0.2103660471530473, 0.20291233849962975, 0.1861962275527359, 0.1987085269725416, 0.20268077439182852, 0.09177788393600061, 0.09183835158506648, 0.08627338127768325, 0.0853604760653528, 0.09499090184156012, 0.09875662926223971, 0.10675634040939985, 0.09400698829602228, 0.08766682542612925]}, "mutation_prompt": null}
{"id": "5c714d2a-1368-43ba-a8fa-e67fe442234b", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size for more diversity\n        self.de_cross_over_rate = 0.8  # Adjusted crossover rate\n        self.de_f = 0.4 + 0.2 * np.random.rand()  # Wider range for stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more even spread and random directional biases\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant_vector = a + self.de_f * (b - c)\n                mutant = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                crossover_mask = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover_mask, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.4 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation for exploration\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "A hybrid algorithm combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with enhanced diversity and dynamic strategy adjustment.", "configspace": "", "generation": 19, "fitness": 0.4119022931288152, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8240066384070668, 0.830861536154299, 0.8224659774453134, 0.8314651322512306, 0.8326870616053922, 0.8347257506110101, 0.8305256149466492, 0.8253562933574601, 0.8415961099524478, 0.6884852887195945, 0.6730015564148879, 0.6830910936923844, 0.6638427596342863, 0.6607611638095066, 0.6912350072962586, 0.685071155444021, 0.64630726780373, 0.6795541914036772, 0.42583573839787037, 0.1498459530270202, 0.14801524922620424, 0.3252378137604294, 0.15494910211582724, 0.1767472257114756, 0.4117343786902419, 0.34621710397579075, 0.1498209906750635, 0.15325938671854833, 0.11296233093651664, 0.10249092943139837, 0.11842795569130193, 0.1432746975130913, 0.13775480235095217, 0.13258622984324064, 0.1436829950349673, 0.13416652977748567, 0.9050601585917968, 0.9542848567084988, 0.9273459427374501, 0.927710827952518, 0.9288183928069861, 0.9395577520062183, 0.9599166711048125, 0.9558504478065551, 0.9421357077628272, 0.4923298736673225, 0.5311596787555483, 0.505415649082765, 0.504541411754252, 0.5109109958953943, 0.5350985693358012, 0.4760891617286659, 0.5019597266279406, 0.5069458364452843, 0.7630506161313514, 0.7397647055701018, 0.8135432975120694, 0.8115448338470612, 0.851703466688916, 0.7921986542800128, 0.823106054775771, 0.7373309196928532, 0.7732622935343303, 0.2681461346319708, 0.2490247488274937, 0.36417483479204504, 0.2766209111627559, 0.2971872121361566, 0.16939746126730004, 0.27482405285998146, 0.2264496739052293, 0.21800950027722799, 0.18841418115996023, 0.18047539991254502, 0.1874102132652783, 0.39611065677618873, 0.26086651292210694, 0.3320326912524051, 0.3915520123793733, 0.22771706722793594, 0.3772841094270678, 0.29657845634745494, 0.1957744868191793, 0.31216059546018315, 0.2642875022296486, 0.38949566818506387, 0.348399443172399, 0.28363461504722676, 0.32418802373367583, 0.3463865459553779, 0.4863081320568591, 0.5032852815608522, 0.5289921505819424, 0.44418065851742117, 0.5294035810728723, 0.4385480774309096, 0.48414212177224725, 0.5550646866773215, 0.548996406243924, 0.05620713936612609, 0.22322577619870787, 0.09827442490428007, 0.24460799671917288, 0.19730093490935974, 0.26962207620497924, 0.11446711878331517, 0.22661062285468203, 0.16324609656527578, 0.28134694847064456, 0.31184595299531215, 0.30551732554464783, 0.29603621020914916, 0.3633669936962961, 0.3421747362437745, 0.3042850865802469, 0.2798062350115418, 0.3220967538961027, 0.6843648220025473, 0.7037496941790959, 0.736944759169206, 0.721407301503992, 0.6905651185207093, 0.7291997785204538, 0.7087059306473918, 0.7289254480806764, 0.7017319491512517, 0.14911809131044906, 0.14797611011758327, 0.11049797656685112, 0.4646952986369244, 0.12731865658514196, 0.12135739634155163, 0.12270210499617984, 0.14018638915914527, 0.1406454659457026, 0.29323865387084147, 0.18225594482466534, 0.24773536456787637, 0.2055449164234635, 0.17979976793489882, 0.21927285199743374, 0.20630831612977263, 0.24975574075366969, 0.19882971714223896, 0.47495183398463436, 0.5155009752085026, 0.4724018517976838, 0.4736918937621982, 0.48349121026504904, 0.47063281046719163, 0.5177862721167864, 0.49783240084160896, 0.5126246660556841, 0.33008034347142723, 0.3541000413591925, 0.3373936548238907, 0.347284490044682, 0.2815180598501814, 0.35317139492291594, 0.388230689652731, 0.3142483402631583, 0.4094573071934232, 0.21777896229132743, 0.22823371793742353, 0.20568978219928635, 0.21694893234038248, 0.21454990487362802, 0.2246877029957971, 0.22817921835301147, 0.2296122235567002, 0.21746381305750062, 0.20402487251306556, 0.45376421426910796, 0.23367059044253635, 0.2021276146619525, 0.2121608998362814, 0.4147811206820555, 0.21433907225173177, 0.4170271182150045, 0.21572448988355897, 0.16843612395026264, 0.18199786154598407, 0.8231272773002868, 0.8549408478813478, 0.8348130813324017, 0.8425107047519933, 0.8026857582987552, 0.8860348052527894, 0.8691363295984231, 0.7703175407675493, 0.20953836018315164, 0.21124795357778592, 0.6312837214918858, 0.16950378741036143, 0.7415984833128311, 0.7331546101185877, 0.7194923947123434, 0.20636052505739477, 0.19089445379202574, 0.19525361235358096, 0.19132352097924743, 0.18801693695838828, 0.17969278882914808, 0.21171663848207523, 0.18561286987175563, 0.20156931708002035, 0.19581627129700196, 0.09132453808343377, 0.09860769715713558, 0.09916514138200838, 0.11807331614718208, 0.10171208414252919, 0.09658977137721436, 0.104893331483359, 0.09115858728965576, 0.08705047022223567]}, "mutation_prompt": null}
{"id": "aa7e0430-183b-4ed2-853e-e9d701722e73", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 6 * dim  # Reduced population size for faster convergence\n        self.de_cross_over_rate = 0.8  # Slightly reduced crossover rate for diversity\n        self.de_f = 0.6 + 0.2 * np.random.rand()  # Enhanced stochastic adjustment\n        self.simplex_size = int(dim * 0.5) + 2  # Dynamic simplex size based on dimension\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])  # Adjusted contraction factor\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(4, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined adaptive strategy combining Differential Evolution, Nelder-Mead Simplex, and stochastic perturbations for efficient exploration and exploitation.", "configspace": "", "generation": 20, "fitness": 0.41676709656561167, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8446575876829509, 0.8579672834569598, 0.8697760491129145, 0.843499793660621, 0.8500588020526572, 0.8560024124436763, 0.8576123917263838, 0.8438805561870037, 0.8710456962121913, 0.7107415878338073, 0.7285654255455545, 0.7445327084440899, 0.7061798812855509, 0.7179855502712466, 0.7194160290289623, 0.7125800078653425, 0.7329354712253404, 0.7318387282988172, 0.17597450253867375, 0.28911246198116347, 0.1631803466527968, 0.1594934488730433, 0.21603003062325132, 0.14571809219319398, 0.2589379997754361, 0.1395826815553144, 0.1735082968491808, 0.1343012099602311, 0.3579290205564747, 0.14682665733283629, 0.1332680592279012, 0.1401696976436, 0.13496750691629, 0.13777332470916404, 0.13927449551097182, 0.1409416907152088, 0.9649324292374885, 0.9378906948864116, 0.9466727898122637, 0.9610990128743039, 0.9370667105454045, 0.9587166005165376, 0.9410989303090264, 0.9772823017138231, 0.9320968269167399, 0.5090397014808974, 0.5761305214909032, 0.5420087614029412, 0.4736131354239739, 0.5612349694768547, 0.5426507022839859, 0.5124221128225487, 0.5556206147001759, 0.5459307717368493, 0.664010339721092, 0.7192401982935698, 0.8455586946018848, 0.7887526013101064, 0.8369328825996087, 0.8011049006638974, 0.720957794367588, 0.7538903461951094, 0.8149469086262042, 0.4252462306219591, 0.41643216941263395, 0.3425259376869769, 0.5019563918541257, 0.429022948019938, 0.3732141085236228, 0.38461590244363275, 0.34808953813728405, 0.3762819909389119, 0.40867097420212284, 0.37548030172271174, 0.27588323823302063, 0.4285549036896539, 0.4644674039188449, 0.3566211909879339, 0.3772958477152747, 0.4343342336869641, 0.39221227239137957, 0.25742372172558314, 0.2007467870855646, 0.33815447876291294, 0.30013190181735205, 0.309069860838345, 0.2058824245966342, 0.35602529901688396, 0.35686787885809834, 0.3087244657036332, 0.4570560852803285, 0.46679136920001296, 0.41516822752848725, 0.40775532793375013, 0.41570519282392593, 0.4423100763567569, 0.41928364209978997, 0.5026221115020377, 0.5151613801810644, 0.06123454722096722, 0.2550002525754207, 0.11432438156680147, 0.22427621439440326, 0.14606526412984444, 0.21592035331508908, 0.18739692494684168, 0.18058782147180774, 0.2309674432662433, 0.2991653691385361, 0.29372587775395487, 0.30418852785746286, 0.293844253347869, 0.3395129148603674, 0.33037187149810265, 0.28747678678500765, 0.33840839104565323, 0.3089965298872882, 0.74096676146068, 0.7449224089723325, 0.7701515205689586, 0.7006691807357512, 0.6959584218642345, 0.6870085167214044, 0.7601568576684135, 0.692737136696292, 0.7209658779713397, 0.10110098047369409, 0.13437443762171808, 0.12024106477348762, 0.13107276988120753, 0.14627554514237306, 0.5269271075997688, 0.12656698926065146, 0.19162692928680036, 0.11453613228378257, 0.18808713447986725, 0.1561747800758838, 0.2837464167128816, 0.20718452072918747, 0.39345270009221367, 0.3065151882377145, 0.18043490314512856, 0.19669397498215602, 0.18214093544748433, 0.42546070998153995, 0.4428212206710792, 0.46256778503111406, 0.45136684448804887, 0.4377250769161566, 0.463957453753319, 0.4828380730766808, 0.5284100821747634, 0.5228680027839159, 0.33023784941535683, 0.3395503515603987, 0.29663060465416713, 0.3487116308040421, 0.3947988816382666, 0.2962370960703743, 0.3807635512660673, 0.35430023808210087, 0.4301271132080805, 0.212655326214358, 0.2466162768744492, 0.20430750176077217, 0.20938216997955839, 0.20812748239501255, 0.2177132341319853, 0.19648719649581725, 0.2197692763451623, 0.21891274769165936, 0.5786344324727689, 0.21021151606904787, 0.5669323818174058, 0.4468319451930943, 0.24015957746517402, 0.23815292976573443, 0.20906027018342488, 0.1885130356056015, 0.5666976071311828, 0.6863852776330959, 0.8519343796524882, 0.7962422195505062, 0.1744211644823601, 0.8488323463524836, 0.15904327359225534, 0.8378528000136088, 0.8226420737147084, 0.18814263065527226, 0.20995762749221902, 0.16588453396818426, 0.7638889318776398, 0.20948593575186125, 0.20417437486444856, 0.1677981275270315, 0.1694751553552314, 0.8051949082801289, 0.8306189365735055, 0.19054024736327224, 0.1796813112435275, 0.19559710191237556, 0.18780670747345962, 0.18407027166295564, 0.18559809091399837, 0.18303111724854348, 0.19757634486015585, 0.18538497728375547, 0.08800416816867762, 0.09315532283447103, 0.087018876332839, 0.08017369703707644, 0.0833208825094951, 0.08681230335413914, 0.08335029218097556, 0.08003276535213355, 0.08491973653134977]}, "mutation_prompt": null}
{"id": "ada952e4-b1df-4763-b953-2c5782f5e775", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                # Select three distinct individuals\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                # Create mutant vector\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                # Perform crossover\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                # Evaluate trial vector\n                trial_fitness = func(trial)\n                budget_used += 1\n                # Select the better individual\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_Refined", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with refined mutation and crossover adaptations for diverse optimization landscapes.", "configspace": "", "generation": 21, "fitness": 0.4771458526587456, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "eb72d05b-b67f-4253-a657-c689e4d9a9ac", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with Gaussian sampling for initial diversity\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.randn(self.population_size, self.dim)\n        population = np.clip(population, self.lower_bound, self.upper_bound)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic F adjustment\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                self.de_f = 0.5 + 0.3 * np.random.rand()  # Dynamic adjustment of F\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows with selective applicability\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with selective neighbor approach\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedAdaptiveDE_NM_SLS", "description": "A robust adaptive algorithm combining Differential Evolution, Nelder-Mead, and stochastic local search with dynamic parameter tuning and selective neighborhood search.", "configspace": "", "generation": 22, "fitness": 0.428435704398326, "feedback": "The algorithm EnhancedAdaptiveDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8295770100768, 0.81271124812542, 0.8114960759556644, 0.8399121417505215, 0.8267800422737501, 0.8267157250022386, 0.8228901384807734, 0.8214488271908341, 0.8322273042747386, 0.6449575309070599, 0.6786699730503265, 0.6370905870418384, 0.6767415359290421, 0.6526045945809219, 0.6619408603224868, 0.6793247333768346, 0.6559688885861867, 0.6630379472361656, 0.1669040674554595, 0.14052012985054352, 0.17687717416101512, 0.14883395759301454, 0.4745477477998833, 0.17034484814874162, 0.13738545748328956, 0.11678210119482335, 0.16024392447505742, 0.13418112661200832, 0.11927602539042403, 0.11235203748237743, 0.11823741034033464, 0.1280334081136667, 0.14217747455875251, 0.11381744954831352, 0.13810696517295273, 0.13839560456065825, 0.9527520886964821, 0.9365722390558948, 0.9831030353786641, 0.9785617489571324, 0.993526599340719, 0.9914853223199364, 0.9992111836208555, 0.9764543611099381, 1.0, 0.5655758930248406, 0.5317092753935068, 0.5320168771124549, 0.5494880892789402, 0.5699790938222784, 0.5533340683335435, 0.5665293503327662, 0.5559351284134348, 0.5683963214923462, 0.7996185429294411, 0.8125443823520144, 0.7943778029886023, 0.8506707013420968, 0.8574016696666088, 0.8571075821777139, 0.8334000871297221, 0.8581745111600037, 0.8151562671664537, 0.4528868556687293, 0.5542009978855071, 0.43692432736202635, 0.1289777036197396, 0.4333774974743897, 0.2839248226823001, 0.47850251063421234, 0.2908774404367652, 0.3012862577842895, 0.38942607150738906, 0.12634447989278574, 0.37051760931392974, 0.4683042919392999, 0.5555523940146565, 0.4924890895640637, 0.4869426090854041, 0.39343994420943074, 0.39498708987374953, 0.45625779819129597, 0.5378108346250557, 0.4293900075166853, 0.5555205075039749, 0.5697205425817244, 0.4591777460378187, 0.5238627662278901, 0.5438276928839443, 0.5375757034171913, 0.5692355248856089, 0.6237240157530922, 0.6340123553071422, 0.6686737724054812, 0.6175907337975653, 0.5533200050423405, 0.6731414167799092, 0.6205764870771754, 0.5860745801533563, 0.09210324963650596, 0.10301938638310026, 0.3098603570172338, 0.24034829954598935, 0.3996066651513286, 0.19535284604790237, 0.20439133045403868, 0.17928460570382232, 0.3030979315131741, 0.3994375471509918, 0.36940997132761855, 0.3723051207530522, 0.4135031728060361, 0.4185540652143692, 0.4056258112304064, 0.38419056324799084, 0.4192846411204326, 0.37826977345453405, 0.7538218281831623, 0.7487403811955776, 0.747155510982996, 0.7552552897816229, 0.76146753771753, 0.7353635948179289, 0.7731299475464568, 0.7453666147128604, 0.7398237906229947, 0.14733612890512304, 0.11949539207015436, 0.15717230743631427, 0.16317561462940378, 0.16364629035163358, 0.1413809665817216, 0.11977499871453434, 0.11572310710445022, 0.21243064062738282, 0.15113978662205885, 0.300304885184025, 0.6981795421685277, 0.18267287193372483, 0.26430198862156085, 0.1733884951859227, 0.1861620444175608, 0.21514888514098351, 0.1933657364709771, 0.5376981348468302, 0.5096779698923787, 0.46187217950523085, 0.5135139960916529, 0.5154303663862689, 0.4319063167107885, 0.55561517276483, 0.49428663645917026, 0.55049663111381, 0.4698638918388224, 0.34247076791843956, 0.3095433748490487, 0.3850834362440825, 0.3785160234448094, 0.292441045312672, 0.46938467883613866, 0.39450117463359546, 0.36713630571163003, 0.21310022137101436, 0.24667726498178066, 0.22574850662670065, 0.177619655159041, 0.19014687537041064, 0.21459519522403503, 0.21453178270022488, 0.2045055268031437, 0.21707795263121255, 0.23452467272107602, 0.2228051115731442, 0.21149574890241962, 0.19282790047824028, 0.24350923061896024, 0.18410586337594037, 0.18242339579638278, 0.23259616534061756, 0.20674334558414398, 0.1524412015701413, 0.8639899103783782, 0.8473341084718747, 0.2082403917979434, 0.16642884487828724, 0.20268169731467467, 0.18442271252649356, 0.19917307604335677, 0.8615507107489156, 0.16791848423827427, 0.21093828982098217, 0.2095072550630327, 0.8402853443387628, 0.20934455032992172, 0.8244117497813526, 0.2007979099809839, 0.20820879220424993, 0.7866556560784491, 0.21380616896889348, 0.19846569155393168, 0.23736431236084432, 0.20252629076654594, 0.2151466804675759, 0.20231668427050442, 0.1898947667415659, 0.19415816593872703, 0.1992334755527515, 0.08747058979817846, 0.09032438321142122, 0.08646967727578392, 0.090523237683102, 0.09783840249077025, 0.08484142075127843, 0.08602935735125339, 0.08638357694686305, 0.09529776920272182]}, "mutation_prompt": null}
{"id": "615b2b37-d30c-44b1-9ef1-08f9639c4584", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly larger population for diversity\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])  # Increased contraction factor\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(6, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined hybrid algorithm combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with adaptive mutation for diverse optimization landscapes.", "configspace": "", "generation": 23, "fitness": 0.4069644563424755, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8001064397606988, 0.7870624998779434, 0.797754816971972, 0.7956158453194387, 0.8074639064820295, 0.8131074315169088, 0.7810183989559382, 0.7901497960541823, 0.8026924424250768, 0.6078304027086161, 0.6210935782044524, 0.6103083289836033, 0.6216914450469966, 0.6202916110422547, 0.626092319566024, 0.6125179505629612, 0.618180871286398, 0.6107138969979992, 0.16885883921572498, 0.15975285422729135, 0.1439884922449426, 0.12802449587926656, 0.13283746294015275, 0.1445310558547298, 0.14614293173982174, 0.1882494696662541, 0.14059652743713336, 0.11954295866956166, 0.1019349423399244, 0.13371035375341, 0.11800462908414067, 0.12040707785283833, 0.10032173086169027, 0.11572898890123562, 0.12311692891853054, 0.12535900682940904, 0.888007400496837, 0.9274926134299994, 0.9361309520532018, 0.9090621418651181, 0.9498272882180284, 0.9062068607024488, 0.9279346400792731, 0.9573233561732588, 0.957281715896656, 0.43649727926287685, 0.47388211712613704, 0.4559711449230488, 0.4401901258456804, 0.46511212436531346, 0.47080714870605056, 0.455182089014053, 0.4666937540710605, 0.4440684004752057, 0.8154800126062487, 0.7641735123681892, 0.7833733402775268, 0.8426992271276883, 0.7917561767940181, 0.8169331543229787, 0.8272579684659783, 0.8119501443001744, 0.82371580748837, 0.2620749720705823, 0.31424809841644297, 0.34589281128473637, 0.3290439048170529, 0.5020931516717202, 0.27416365575662116, 0.34523901254865064, 0.4112104507702401, 0.3478974451588074, 0.4631725963761152, 0.28508048875847447, 0.5420383505908636, 0.30613600398633267, 0.31522338938333394, 0.33790810176502173, 0.30904444115167895, 0.26898893602189367, 0.36484590983759135, 0.44982316800893063, 0.38476091835451476, 0.4445333360609973, 0.3652728868088775, 0.4423991862835265, 0.427187213051592, 0.3779878351078808, 0.4179933132169128, 0.44842679250232353, 0.5810435125092167, 0.5544608761087755, 0.5520479864331356, 0.5793211502364505, 0.5247036346577625, 0.5755024796503002, 0.5870694895922028, 0.5832392864112516, 0.572691445316182, 0.07346113660823594, 0.15121204349934092, 0.11308113742416992, 0.26461028928397556, 0.34210522851586866, 0.3248500567981528, 0.088839309407032, 0.20013687740012076, 0.235786262542921, 0.34487674054409856, 0.31818897232596366, 0.3326169454017118, 0.3165670200279995, 0.33601703352134216, 0.3595099505721663, 0.3374381100791982, 0.34866778847693747, 0.314312701084311, 0.7123911860062319, 0.7161143509129105, 0.7272018966936287, 0.7143245192419756, 0.7142087527434497, 0.7271658268729351, 0.7120620652899124, 0.7131197558198225, 0.7345468471170171, 0.1447282767316963, 0.11193142170689663, 0.1290437029579754, 0.1360798352883621, 0.10383537504090568, 0.12718202463932426, 0.1351147388427144, 0.12350692506949579, 0.14354888507669916, 0.2856075325815475, 0.18027120298248833, 0.36992100954864904, 0.22241591236370828, 0.15208228246487765, 0.2736627102084227, 0.22475604583369413, 0.22421899617820606, 0.22536343388205948, 0.4501626595518686, 0.4528091990424272, 0.4736201646712076, 0.4423136516470245, 0.4785343963243698, 0.44513360553557535, 0.473929771594661, 0.4977183444530555, 0.47019557386533395, 0.3790612111784699, 0.33005823196364237, 0.3789112925162895, 0.3363327561575924, 0.3376328144005841, 0.3756736864580993, 0.3950045673089351, 0.36996108876089184, 0.3818178512185568, 0.2522385519345738, 0.2175134685405712, 0.22889271579497494, 0.19899489241437363, 0.2183620556322713, 0.23196863790318534, 0.22387878804477412, 0.25028683362730886, 0.22404795271647304, 0.33678035117888816, 0.1997780057867471, 0.22410540619175034, 0.40754922821453343, 0.2039791316303715, 0.22676118282538993, 0.20386574453648865, 0.4319347079272273, 0.2188553111666125, 0.1961970335107085, 0.851162493832557, 0.744693252166769, 0.1640701280766722, 0.8339942010251894, 0.7306147783706882, 0.856647627561379, 0.8730717512030877, 0.17771474286494338, 0.5695286840670576, 0.8070323120811139, 0.21078711931053318, 0.2069512751762177, 0.16783689021527204, 0.16729653163076508, 0.20943738658494981, 0.8478085950289297, 0.20397869007683533, 0.17338295497273815, 0.19718777855131409, 0.19162001392002181, 0.18104746135432437, 0.19474888545397495, 0.1886571051961431, 0.19349394144391652, 0.1918866325351598, 0.17904468390668793, 0.08892399386556205, 0.08436742395777674, 0.08847801052087634, 0.07849724995904672, 0.07896442735240072, 0.09197286878322719, 0.08019053764080819, 0.09718492563838133, 0.07792577850246274]}, "mutation_prompt": null}
{"id": "f24d71e9-95bf-47de-a15a-1bd0775921b9", "solution": "import numpy as np\n\nclass RefinedEnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedEnhancedHybridDE_NM_SLS", "description": "A versatile optimization framework incorporating adaptive differential evolution, Nelder-Mead, and strategic local search with probabilistic line refinement.", "configspace": "", "generation": 24, "fitness": 0.4454674731311851, "feedback": "The algorithm RefinedEnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7086005671574427, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.3596401992720061, 0.13595796673339733, 0.36946404056962234, 0.1498232656550199, 0.1331266951979342, 0.17436835326737132, 0.16485043949431966, 0.18095494275766644, 0.17619056152799695, 0.13613044195865098, 0.12633358883362944, 0.1251684605339093, 0.12545454096660502, 0.11169498733952654, 0.1408141635472372, 0.14139980277838748, 0.14511480651138353, 0.13171757626891956, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.904735122491464, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5889407582819899, 0.6208911064898792, 0.5824672579339423, 0.6049834784205104, 0.6149609229403354, 0.6372070148791626, 0.5897693276130394, 0.5987678721139256, 0.5987884031320838, 0.8238971608528822, 0.8369538673082748, 0.840999904910548, 0.8350765566605662, 0.838560964845127, 0.8674044939288663, 0.8605313466720277, 0.8714421621180937, 0.8403874057173522, 0.37399969513713927, 0.2454204590480562, 0.25086812242520984, 0.4114171005934554, 0.29490636723448815, 0.29503321687285633, 0.3530796018512301, 0.537987508274491, 0.4156774988833426, 0.41543560711415295, 0.18823393076929318, 0.1302968872562411, 0.3846022444976367, 0.4578762336866171, 0.5266570910489912, 0.3361545202358782, 0.366536229481781, 0.6364988139329089, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6130289947163817, 0.5589718735882322, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.12652929506417254, 0.3009459886750965, 0.14076954980181267, 0.41532246384442306, 0.442381040691898, 0.2675429988311371, 0.29472437429142595, 0.31302369623730264, 0.2391573150717753, 0.41502725749066305, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7857085051924386, 0.1223312415407205, 0.1299549741596593, 0.1821114953217262, 0.14627924041249185, 0.12664285439192247, 0.13247712589675975, 0.13047521157950248, 0.1547377584118742, 0.1113355193921558, 0.21809814527373428, 0.3348110669501525, 0.2231310022530827, 0.4363719424785757, 0.31465920006314607, 0.24377319052492807, 0.5004346070564756, 0.2354491376336656, 0.19330861858940196, 0.5009617950580424, 0.6100628533044262, 0.5885882867337914, 0.5090014904186784, 0.5572630483783829, 0.5663073685278542, 0.5611725716174312, 0.6237546196658427, 0.5591678891497545, 0.3156226298614394, 0.3666376526760863, 0.40909210869299606, 0.38513198698186657, 0.4653778898609856, 0.472878611311184, 0.4797841111635449, 0.44630110308165516, 0.4526446721401962, 0.21878019970274676, 0.2273127885320121, 0.22424600004809125, 0.20301741889393654, 0.21197702546709574, 0.2224596160892215, 0.21503366589050144, 0.22490647970131217, 0.21374388960974078, 0.5064745670632402, 0.21231403137322358, 0.24006385548127496, 0.20556253909891065, 0.5088944345242519, 0.2109137303909303, 0.43835257570718744, 0.21228771442209182, 0.21929349267497178, 0.18394841570013187, 0.19586776364482517, 0.1870475837919262, 0.8155157018530259, 0.854284932370525, 0.16577893526442566, 0.17881154318245662, 0.8321299452061444, 0.8605359090986491, 0.16281080996520692, 0.1637195863560149, 0.21027475742923962, 0.2098526450818965, 0.21009610447371285, 0.1682279462730285, 0.21078098344361773, 0.21134720072390667, 0.21279735031786773, 0.17418480535991054, 0.2041746841555957, 0.2050760883311632, 0.187472519707374, 0.1856825176571424, 0.18270336548315458, 0.19292064117401775, 0.17609387693898948, 0.19634713442204366, 0.0926502015554348, 0.09646098151932347, 0.16042331473618543, 0.0838130041869739, 0.08595235799341006, 0.07933820475924003, 0.09586379519617716, 0.09971316593302504, 0.09401127525391528]}, "mutation_prompt": null}
{"id": "79a353da-2b8c-4d48-be3f-f57bd7e621bd", "solution": "import numpy as np\n\nclass RefinedEnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly larger population for diversity\n        self.de_cross_over_rate = 0.85  # Modified crossover rate for better adaptation\n        self.de_f = 0.4 + 0.2 * np.random.rand()  # Broader stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(6, self.population_size)):  # Apply to slightly more solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.08, self.dim)  # Reduced perturbation variance\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedEnhancedHybridDE_NM_SLS", "description": "A refined hybrid algorithm blending Adaptive Differential Evolution, Nelder-Mead simplex, and stochastic exploration for improved optimization efficiency.", "configspace": "", "generation": 25, "fitness": 0.41776928421883275, "feedback": "The algorithm RefinedEnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8204959020170369, 0.8055630432903925, 0.8182635240161228, 0.8247584147108343, 0.828783745003536, 0.826212063040004, 0.821066595899411, 0.8286456927114157, 0.8366510464065624, 0.6495719077433013, 0.7020639974547765, 0.6439240470670866, 0.6722615074841157, 0.6638088663224497, 0.6781279719065092, 0.661616347809129, 0.6615882427110906, 0.6645304906172653, 0.26059505985436104, 0.5275912139521105, 0.3177848622433054, 0.13953580544561806, 0.15728138619280418, 0.43424640853446417, 0.3093583069766255, 0.16564202092522862, 0.17909471232654417, 0.14797313503812415, 0.12009230324265152, 0.13726197722701072, 0.1389289852140595, 0.13712313635640772, 0.10473958848164222, 0.11233717690087708, 0.13542838808240665, 0.13918165896681234, 0.958392543748727, 0.9077129917268604, 0.8826791684265384, 0.8925551126589164, 0.9341598658462968, 0.9142481508609077, 0.9382376236832123, 0.9116455575087821, 0.9101630630144728, 0.5127993492694343, 0.46641533142849134, 0.5359794782807821, 0.5225323979821768, 0.507096424695789, 0.498610568873466, 0.5201309235085307, 0.5121223293349406, 0.5351361107547591, 0.8320388992229746, 0.8039064888226735, 0.8387887953539859, 0.848038488157224, 0.8862164854573896, 0.8371762837104867, 0.8485805726713687, 0.8489469449968017, 0.8178543123293276, 0.21721687629135744, 0.4653504548416557, 0.23703535909437135, 0.25236456194116186, 0.22035558421134172, 0.2662986468627029, 0.22931523686361044, 0.2993237258143241, 0.30168007677224673, 0.19237836976670664, 0.1785498837688999, 0.2313302950309606, 0.2631075964046953, 0.3350604514755047, 0.364389733090288, 0.3581781557219831, 0.39143234323693854, 0.31988967412997327, 0.38649100214080734, 0.43704107734176023, 0.35745906785120163, 0.3869347786454438, 0.4469203471035553, 0.3814151907796647, 0.4503008226351891, 0.41519369563420827, 0.3981725370310222, 0.5870072457803936, 0.56503293501237, 0.5728160077879967, 0.5657996548599202, 0.5267351842977612, 0.5442455820783576, 0.5653854676679504, 0.5806021413780201, 0.6205596359191742, 0.0630644607285703, 0.09116744024221646, 0.21727810586790697, 0.2725492500317438, 0.1922726866290061, 0.28924417668212776, 0.19405220144738666, 0.11056299786709933, 0.2653589454376404, 0.34076470933371605, 0.3232079055577407, 0.3397842636705931, 0.33077562892207013, 0.38014575155741803, 0.38876414235816925, 0.3314007705830109, 0.36943129575896794, 0.35314591374764104, 0.7434562352939313, 0.7294623045793418, 0.7197698751183703, 0.737682096891368, 0.7165573209513934, 0.746458240675863, 0.7137575222082557, 0.7117944538910512, 0.735958768007003, 0.10966710923236511, 0.13527024557288825, 0.16667939449321734, 0.13786218144805462, 0.13711468159949947, 0.1485390651602092, 0.46661075766273397, 0.17298488075629936, 0.10889149192478376, 0.18772789369860887, 0.18159426601811424, 0.21146918315335195, 0.23632668948637525, 0.2575695950298382, 0.14777570236230053, 0.2152460522587718, 0.20000640009097703, 0.17463232238837123, 0.5002005026132437, 0.44074989334045933, 0.5015770971071827, 0.4953610481905206, 0.4998094992214237, 0.5341316778990648, 0.5441260147475835, 0.5607851152423078, 0.5413382450101983, 0.3654891717221185, 0.33108452667677224, 0.32452554131640154, 0.37817118754618895, 0.3098308014046296, 0.35061009549137157, 0.39882194049164277, 0.3959534267758159, 0.44467015979130886, 0.24436518710344457, 0.23960351564557647, 0.23427118746990228, 0.23640771413354345, 0.2037820143231438, 0.21595667604141366, 0.2092385050213722, 0.2173067627547678, 0.24604175031742004, 0.5892266720576189, 0.3226252673887253, 0.22586334538925756, 0.21315021261822853, 0.2290516740313706, 0.1874711410374288, 0.21005372209754924, 0.1996464008128792, 0.22090680833006704, 0.18171646117596618, 0.8500979035235706, 0.17112757772635323, 0.7099898965006399, 0.8397933685587345, 0.1651794991507931, 0.8206348115777027, 0.16681147709431698, 0.8540182753786616, 0.20210098075630922, 0.16727568694016604, 0.21076709223543866, 0.603472434841352, 0.169455732214278, 0.6877860610963221, 0.7865686094448535, 0.7483878158885824, 0.6777197630582917, 0.1896401642121286, 0.1949689854546428, 0.2018044084644519, 0.1827861939218679, 0.18776699074382464, 0.19623098507112913, 0.19374718498780974, 0.22327839396381088, 0.21095529365339227, 0.09586816905621653, 0.1081581768401062, 0.08792864964009062, 0.09252042949293027, 0.09065275561524033, 0.0976655414337061, 0.11263678065710625, 0.09727313938024384, 0.08967663021759431]}, "mutation_prompt": null}
{"id": "9e9bac38-6298-4c8b-81e3-d0c705988694", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Slightly increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(6, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)  # Increased search precision\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with dynamic parameter adaptation for enhanced optimization performance.", "configspace": "", "generation": 26, "fitness": 0.4476371836249548, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8315562061013062, 0.8404602338750269, 0.8429432240574446, 0.8226660776179314, 0.8490246703389501, 0.8205491163398076, 0.820816596629235, 0.8245012803321808, 0.8502711010769299, 0.6806286040818301, 0.698536482497937, 0.7002934609151321, 0.7005013351196647, 0.6897577308562204, 0.6971326384217469, 0.7004181974875845, 0.715519196832306, 0.7209189157422589, 0.16394550918080808, 0.13633754672696885, 0.17059309727072014, 0.5141759008846718, 0.18019575329387172, 0.1767755832091148, 0.1513269087943232, 0.1828935959511674, 0.17047680116386377, 0.13405755395882113, 0.11479283795221795, 0.14169308436794292, 0.12457605260910276, 0.12204044102670031, 0.13030086620540438, 0.12529958905161243, 0.12387441183134074, 0.10607163736758596, 0.9316539926610825, 0.8772190127366086, 0.91065645220323, 0.9334709569752935, 0.950628242519359, 0.9284857986355917, 0.9056815799826087, 0.9222770680508693, 0.9456595924518395, 0.5382565580247104, 0.5639496403957559, 0.5674723987529873, 0.5542734463111199, 0.5785083515740671, 0.5994697724572704, 0.5523740337120078, 0.5650496396082509, 0.57771435495654, 0.864680276645552, 0.8452581005650108, 0.8442309475232543, 0.8337699610261337, 0.8823938863248579, 0.8610513366488801, 0.8619327722917004, 0.8981445586519339, 0.8313771721806706, 0.33484970795467583, 0.3284827348562459, 0.1275686309252858, 0.1310332784330912, 0.5634768663778094, 0.28381455773250097, 0.6095680755164119, 0.4571963156497102, 0.4433899095870686, 0.3477306694717478, 0.30124303613777936, 0.6027622278021219, 0.29312072677580236, 0.4694491491864766, 0.4715124074105317, 0.4766180513300311, 0.3775004293230996, 0.47710450342142496, 0.48120395989648235, 0.602720631790465, 0.5283768893513268, 0.5195776046346876, 0.5467987786492385, 0.5221640422979572, 0.5593700203575631, 0.5229024618059472, 0.5144784742959618, 0.6271965670510387, 0.652994575413671, 0.6674427174729587, 0.63288338471042, 0.6101943348910356, 0.6740986894388477, 0.6733103133102698, 0.6650440217469367, 0.6738833781074602, 0.2833742143935678, 0.11524618898452588, 0.12767981906542625, 0.2586249390952371, 0.4581704409388546, 0.40039272401522463, 0.339521201820118, 0.17867378541989054, 0.1781898586744881, 0.37965384797536883, 0.4148745520916962, 0.4518812692631087, 0.43662286608944656, 0.42289629709726173, 0.4027014735869793, 0.38223481795787906, 0.44595660873488874, 0.40693699275390716, 0.7734739146146471, 0.7523121892849456, 0.7639216236502137, 0.7455307241437534, 0.777190588036472, 0.7662591483488416, 0.7521871438244281, 0.7899623005322571, 0.7864791503619492, 0.12191761114372934, 0.18167642935181527, 0.13674454974020933, 0.13452537992141334, 0.10596902577289424, 0.17637555363818957, 0.15921991326428175, 0.14038651705977157, 0.15557111255161582, 0.16899458451126415, 0.1704236245675238, 0.2712357783707535, 0.24576406986596588, 0.21889081842042246, 0.1748849748315996, 0.22197549176744213, 0.2979569503741899, 0.2316187759183188, 0.5200057367913683, 0.5268740368846931, 0.5415417198937775, 0.5024614828760113, 0.57298333238416, 0.4945366598843408, 0.5593054050333983, 0.5955835698276746, 0.4944553258091189, 0.4075016113195896, 0.38545701558232326, 0.3345100655187965, 0.391984160507979, 0.43688202288373257, 0.4361408375790288, 0.3911002438526424, 0.4243001578259621, 0.4361319711432501, 0.20929675653825974, 0.22163190174176006, 0.21773201997715497, 0.24730772940270895, 0.22455114057738013, 0.22625526717525768, 0.21309336490831998, 0.23394272772669156, 0.2313579252836946, 0.19512655179698946, 0.675145040149275, 0.21386751835451778, 0.21081792637788466, 0.20568542136391965, 0.22459023055025362, 0.434682883504929, 0.615277038356219, 0.21418122228562275, 0.1850315492239606, 0.8671170985372977, 0.25049393582615553, 0.8330172411562096, 0.19421067938852055, 0.8063107523428437, 0.1622659575558515, 0.8229936102888971, 0.8563853399433698, 0.20582902430556205, 0.1687879510847894, 0.327491257936142, 0.209528329718224, 0.8077314235940766, 0.7952818126290548, 0.1561702923086974, 0.7365339039241532, 0.21129316764101647, 0.1922673955504164, 0.17798567823546962, 0.19193408055746808, 0.19409280787143002, 0.20576053766286162, 0.2056357682363138, 0.1886225635904537, 0.2218042444315963, 0.19482300919532214, 0.10237853113633444, 0.10355591078060611, 0.09384776965048347, 0.08621925907131767, 0.08994150668264278, 0.10188168116809793, 0.10727635306249284, 0.09218690403930763, 0.09894220501633721]}, "mutation_prompt": null}
{"id": "513b7db1-1a2d-4368-a813-1b1d36e79d8d", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_ASLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly larger population for diversity\n        self.de_cross_over_rate = 0.85  # Adjusted crossover rate\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Enhanced stochastic adjustment\n        self.simplex_size = dim + 2  # Larger simplex to increase exploration\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse and wider spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Enhanced Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Adaptive Stochastic Local Search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_ASLS", "description": "A hybrid algorithm using adaptive differential evolution, enhanced Nelder-Mead simplex, and adaptive local search for robust optimization.", "configspace": "", "generation": 27, "fitness": 0.359697084862288, "feedback": "The algorithm RefinedHybridDE_NM_ASLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7492658842653774, 0.747758739865866, 0.7582554423718051, 0.7709084424403846, 0.7663956876440231, 0.7702050123089904, 0.7653729948013147, 0.7518652397702406, 0.7744176048988312, 0.5495684120723094, 0.5652059350077632, 0.5583351920718013, 0.538673669818428, 0.5790569949277453, 0.5690654895517906, 0.5430588771962093, 0.5654791777878951, 0.5495417989203535, 0.39199705526560435, 0.2391167154701077, 0.16357644147418982, 0.2863505070435002, 0.1568182956766352, 0.134271090902489, 0.1348613967045501, 0.14533611191580398, 0.13394954412289206, 0.11207630437088789, 0.11609332971539932, 0.1370564942196355, 0.10727170531364971, 0.10889461043263837, 0.11267815169533824, 0.12203371804793228, 0.1253055256650858, 0.12520899604831304, 0.9501794622159931, 0.9519775856219497, 0.9384061338872518, 0.9577038386412818, 0.9359746932925467, 0.8901520062242944, 0.9216822438848286, 0.9506530853625822, 0.951535547369268, 0.36853516780391227, 0.3690631039951331, 0.37884591585034055, 0.3996244896351594, 0.4033970782664662, 0.39841074484334205, 0.4042155494461306, 0.39593543645823304, 0.3961749011189173, 0.8135493085184622, 0.7318267010376598, 0.7932002712298698, 0.6964979518991485, 0.7580426989488143, 0.829271235640838, 0.7668644119607386, 0.7111017677362786, 0.7144916176455204, 0.22104948029810434, 0.4216749552241006, 0.3249084770221543, 0.24982164615110947, 0.2491858999034644, 0.29865911948610724, 0.3073647211937971, 0.22447802396380911, 0.3324878973761892, 0.1804508021644433, 0.2536019634288631, 0.2634746095820518, 0.28561366611002015, 0.275870374094782, 0.3006283456054766, 0.2840966514788351, 0.24078689965249622, 0.2629574332731056, 0.2730777988261469, 0.2842108624248332, 0.2529406875251068, 0.2888401824544745, 0.29855165448175125, 0.25014435632790377, 0.21724713590510614, 0.34048816513284785, 0.2655919892682499, 0.38516395719845986, 0.44627460376300043, 0.407234902019767, 0.3774146639848708, 0.40767410547455707, 0.3848211212748439, 0.4383629625926848, 0.4388257136245992, 0.444959265239967, 0.07102997365158459, 0.08295862647294183, 0.1099876853878099, 0.12636439376812614, 0.11056079442562172, 0.18304816628634746, 0.14195449671570481, 0.14738698138951933, 0.11118841369025634, 0.24633638150190584, 0.2404995521476747, 0.253865928984485, 0.24749677261795444, 0.26283159632926767, 0.24235806527067405, 0.24858093015504124, 0.25509644240904294, 0.25816712915750417, 0.6394303236812307, 0.6355437145189807, 0.6245157107756456, 0.6110567772795131, 0.6357651686829473, 0.6164273778476814, 0.5988009083496494, 0.6337569267684182, 0.6511997192533667, 0.1439836685515714, 0.10754907515713619, 0.12992550922742252, 0.11965500369888282, 0.11514116545889297, 0.14939898401920837, 0.11978647549565724, 0.13321000706502784, 0.10885040590991435, 0.2243550404842244, 0.14410465950069284, 0.1554210237245236, 0.1832514416536979, 0.23752338830506003, 0.22572685255142444, 0.18655339514358515, 0.2510507315671986, 0.21745329126802904, 0.3974100780803905, 0.37359809888775, 0.3950067086903929, 0.39445804136972484, 0.4115524174163274, 0.4188759665029008, 0.41031201725347377, 0.4385246673194825, 0.4474040485900319, 0.2874354247331823, 0.3425306722381881, 0.3166060653311574, 0.3125671303446619, 0.3450674941028342, 0.2897697169628045, 0.3123488586575768, 0.31302681113093045, 0.36138245150462656, 0.21399831907529998, 0.22307551105204448, 0.20768206173108383, 0.2295538760981889, 0.20129305457968427, 0.21434993910201006, 0.225105795817385, 0.20601360487151155, 0.22447527313370197, 0.2035128014218318, 0.1951925415429372, 0.22840184624931947, 0.4703098142561103, 0.18730230283667093, 0.21605840976820279, 0.22492547454310374, 0.20523642240683537, 0.21780485275309647, 0.6751470767681937, 0.15053547695989056, 0.721694442221871, 0.1813780318071554, 0.19602351053588396, 0.1912411951246915, 0.1578827118762396, 0.8032898479032704, 0.16796900437171625, 0.2005343105915507, 0.7723814296190463, 0.2085308807354822, 0.7606972174979911, 0.16840560533063686, 0.20909951362571333, 0.8254965053195074, 0.6866951467412552, 0.7545030910864028, 0.1904362319842039, 0.1855198981872005, 0.18743578660849503, 0.184236550809597, 0.20504193172393714, 0.18986544757812318, 0.19384466965261515, 0.19190705350836412, 0.20749630031397537, 0.0978092655785231, 0.09527670993409687, 0.09283795661010485, 0.08267466694863668, 0.09033262956313515, 0.08779065041178913, 0.12187334685222972, 0.091115355249486, 0.08467860209788836]}, "mutation_prompt": null}
{"id": "16ee1b3b-152b-4390-b6cd-f5179cc5eb7f", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_PLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with tuned parameters\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Probabilistic local search with fine perturbations\n            top_indices = np.random.choice(self.population_size, 5, replace=False)\n            for i in top_indices:  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_PLS", "description": "A refined multi-strategy algorithm using Adaptively Tuned Differential Evolution, Nelder-Mead, and probabilistic local search for versatile optimization.", "configspace": "", "generation": 28, "fitness": 0.44600790062121926, "feedback": "The algorithm RefinedHybridDE_NM_PLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8440958443136793, 0.8556138853457578, 0.848107177951083, 0.8257656249462975, 0.8367136744517254, 0.8497730165057533, 0.8513805100010572, 0.838115579938336, 0.8421930719263152, 0.701672789783476, 0.7266921615541333, 0.7154764135105653, 0.7016996744229179, 0.7153882769851387, 0.7202334109309081, 0.7345441894268873, 0.725221990465631, 0.7306433236102461, 0.1732538786375064, 0.12475554258933241, 0.16082086923984584, 0.1674326553114044, 0.1523634771896777, 0.44846380062847535, 0.1759657855144836, 0.15118340404309527, 0.5204338342090779, 0.12059287297221943, 0.12115650258080657, 0.13280372331869894, 0.1443395419228527, 0.12846155174259077, 0.13152882440587632, 0.12418351854694576, 0.11921781815319332, 0.12971896467070076, 0.9452760901670438, 0.9179503128464912, 0.9092659877957808, 0.9446517637389826, 0.881649170699002, 0.9660465927774162, 0.9296487269540569, 0.9094132156313457, 0.8903261182722045, 0.5945407152980269, 0.5543157166703472, 0.568917929410116, 0.5538998869029088, 0.5884076331732191, 0.6211999022989247, 0.6200135031930994, 0.5980461040756588, 0.6167875769025899, 0.8491465953717727, 0.8466812565451948, 0.8347833674317462, 0.8508985923720058, 0.8646362828723698, 0.274742065214028, 0.84861769089675, 0.8683657137692258, 0.8580131201656653, 0.3047064821198825, 0.36806829938929286, 0.4229094929938737, 0.42368068683251103, 0.5702936601179348, 0.13072745559350407, 0.5050735444515588, 0.24429428620080806, 0.48109544074320454, 0.3919786619905433, 0.24730300918207726, 0.2684265560375694, 0.35191453977144926, 0.42644564510579896, 0.6768323638379345, 0.2517802489550751, 0.35742550888997515, 0.2737245402313093, 0.5000785840451438, 0.6381335062047597, 0.5573375929875289, 0.6007060725695779, 0.6130536275486841, 0.46400121868514055, 0.5988307685135084, 0.569002434990102, 0.5613533802528745, 0.6760198729912846, 0.6883421662815525, 0.6731366767360805, 0.6689652279924638, 0.6732853120253004, 0.6988136817328676, 0.6913715941140332, 0.711250658753874, 0.6918750932963058, 0.09625449511838269, 0.36325725409530873, 0.1337032255874403, 0.18823270556211347, 0.45487650510103605, 0.47708111017907096, 0.32963013722427026, 0.25157120756670925, 0.33632766017145543, 0.4777910722821145, 0.45634180820209835, 0.45816594314600656, 0.45438540710519637, 0.4916558720152302, 0.4822734049192994, 0.4554197535276062, 0.45804072760112147, 0.4485408949554197, 0.7670184235874513, 0.8039165384876343, 0.7808510151368537, 0.7797641935292633, 0.7828951099922559, 0.7820332953898355, 0.7847164186783763, 0.793177151837206, 0.7844655753819858, 0.1565521050325629, 0.14056495184278373, 0.1643029540487705, 0.16614112000735715, 0.1516233434198051, 0.13780257492406522, 0.1663864390624421, 0.1844522550282397, 0.13349561625815387, 0.27870368133072143, 0.2334045394772567, 0.4598422912669753, 0.30053331961064955, 0.4116922392741801, 0.23266703143278356, 0.1847005669146351, 0.22260347767071798, 0.23270703363427658, 0.5720744162600642, 0.4839579199608228, 0.5223772407518326, 0.5818295111693441, 0.5470268801506915, 0.5733919506409406, 0.5815140422892675, 0.6196847013035149, 0.6206005217173625, 0.2501743724263198, 0.33864155377943195, 0.4179936493908405, 0.44423886550447156, 0.2873350195404699, 0.4251024731954657, 0.39905316322740936, 0.49430403148179614, 0.4376056012154794, 0.19669523981838444, 0.20724597566383696, 0.22417519126105923, 0.22178515567166157, 0.21862069837025078, 0.23811908540130722, 0.21752628974944377, 0.24654167417067918, 0.19863811431649592, 0.22479437064655972, 0.1999383306319602, 0.21213852009300227, 0.21978438559395785, 0.22906440790632832, 0.23645344909230315, 0.20525561851887597, 0.5504265369039043, 0.5912521333852725, 0.18504711216695902, 0.19694086933295984, 0.18486584147971752, 0.1977204502219554, 0.8875029551674996, 0.1451175923948087, 0.19191275509589412, 0.8473634501908078, 0.8626706348971774, 0.12807727492176857, 0.7887400843644845, 0.20920378055188704, 0.21172217159184248, 0.16730760694839208, 0.16853915127533514, 0.8482752642818688, 0.21115439295004956, 0.21225381950088018, 0.19335365869596277, 0.20132845074539418, 0.19930961282446935, 0.19171540318043057, 0.20317933923495712, 0.20260442864213546, 0.2093800640312391, 0.2105224896788379, 0.20623397735051385, 0.10252777094742871, 0.09194041083127491, 0.08920977524588725, 0.08671591630585096, 0.0921993222766676, 0.09844111660570776, 0.09805481308237007, 0.09350383181007782, 0.08866070218389199]}, "mutation_prompt": null}
{"id": "4a90e95c-0ed0-4a50-b03a-88b82244ca51", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.95  # Increased crossover rate for better exploration\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Enhanced stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted contraction\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation scale\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_V2", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes with improved crossover and mutation dynamics.", "configspace": "", "generation": 29, "fitness": 0.456283417709793, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.814707057606214, 0.8358398099131095, 0.8095735093758292, 0.8178898471505366, 0.8351504973859031, 0.8262617022930422, 0.8165969473280315, 0.828509847419133, 0.8419326072530373, 0.6647940222827251, 0.6925797345026685, 0.6704628082857217, 0.65850876101865, 0.6877615182151902, 0.6841805871400702, 0.6511126918803105, 0.6899003253672189, 0.6755838380760095, 0.1543559171685268, 0.11679933036029178, 0.1233893719214515, 0.14526607518077073, 0.12643837222553644, 0.4810677466860861, 0.13050614724950815, 0.13941655199678904, 0.14724638095275167, 0.15059785439190732, 0.1361719929900822, 0.12249687769263151, 0.12065739525421681, 0.1027654410389206, 0.10199756504838586, 0.10977060207152478, 0.11186490623589251, 0.10369289447893604, 0.9597362792327637, 0.9239487038946508, 0.9410541709659408, 0.9495359137253886, 0.9231238557830778, 0.9139398323375949, 0.9199184501378758, 0.9698459616392336, 0.950687217577646, 0.5756102214871255, 0.5854328360365555, 0.5531903664123861, 0.5690837659466239, 0.5673553469989849, 0.5633770704156299, 0.549923448040239, 0.5841275740975855, 0.5713067705647767, 0.8035860004882824, 0.8087878492840271, 0.8628767498636105, 0.8229885061397259, 0.8910417902690522, 0.8804027247989078, 0.8726051439016547, 0.8250925581011533, 0.8993101324239249, 0.5731163038245932, 0.2910770397018657, 0.5304240865478619, 0.11909518595965274, 0.46628214998791906, 0.42905774433847566, 0.6043924174414776, 0.13158370870986524, 0.3320682341492014, 0.2671315719226629, 0.2750801360515621, 0.39347341998621166, 0.5155208284253201, 0.5655527902132351, 0.3978207682302346, 0.4621447336301253, 0.5185741728910742, 0.5172986975119848, 0.570807907237608, 0.6175969291080918, 0.5915936266568537, 0.5526267830985614, 0.608989359193175, 0.5857376397782501, 0.5663963882282288, 0.5954234680611301, 0.6060966354857442, 0.6889249989831727, 0.6883196678404218, 0.6898962858946993, 0.6554093601924705, 0.6616803367813323, 0.6960914772629723, 0.6809040018012782, 0.7158359317123065, 0.677651532674278, 0.08911541286340585, 0.34138397942179743, 0.11206138447125613, 0.2656837659886758, 0.15385591539627153, 0.4585890851840244, 0.29039215933763884, 0.2949508022895865, 0.20829289690088082, 0.43962685353396413, 0.47050682476837, 0.4486484836657971, 0.47653500245246005, 0.5047308336355789, 0.45854852834153226, 0.4319912714998708, 0.4994349125290316, 0.4559729694752723, 0.7976628502704914, 0.7852739853567549, 0.7852642066744295, 0.7552204130792207, 0.768618894650221, 0.757177757110864, 0.7506499250860417, 0.7914198440995848, 0.7984129523336165, 0.152160362578726, 0.12152938653107925, 0.15051641627503176, 0.6281066226493828, 0.14011724319976548, 0.6015439743394082, 0.10510201512492312, 0.146022946055558, 0.4686283884704018, 0.16502280151999915, 0.5525102498291412, 0.3818425855255384, 0.2864999185545931, 0.31200942579962243, 0.31417349111729587, 0.33352308813425424, 0.2642311644821721, 0.1924715780567039, 0.524080595569348, 0.5658116675438061, 0.5884321438665752, 0.5205106727977016, 0.5587428887154824, 0.5590553141416669, 0.5629369991499718, 0.5962250446145858, 0.5906376502595997, 0.49495955552236637, 0.3751593397143307, 0.4947698684805606, 0.4277809590997621, 0.3572016552749132, 0.4707168606472445, 0.4815089631493552, 0.5059676448304375, 0.46494094659419016, 0.24662605165851903, 0.23591025623077944, 0.24689736909369353, 0.2140175984308036, 0.23652778432276267, 0.20449725077301095, 0.21938152661097798, 0.20706601184285434, 0.22308067678039312, 0.20676086779444192, 0.23164552082731693, 0.6223687573571013, 0.5862491895827229, 0.2015975891634969, 0.4962543689474579, 0.19837180476311012, 0.5963106189823744, 0.23423472578986637, 0.18744547746321527, 0.8574175568566943, 0.18510337712543434, 0.8468802737081603, 0.16719771872491784, 0.15060187685535298, 0.16152730943017268, 0.7903569395122976, 0.1672910978837726, 0.7858563674916859, 0.2083852899005113, 0.15583748459472757, 0.21040464427473649, 0.1672071665293131, 0.1672225897879669, 0.7885439657307474, 0.21021025771199497, 0.21232551027568147, 0.19474836743722512, 0.19600485533716028, 0.19195389534762586, 0.1952620378308224, 0.21552627234941035, 0.2096797333070306, 0.1915187418999269, 0.20920771000847893, 0.19369021955208232, 0.09730051576216903, 0.09561899014899045, 0.09726206142728455, 0.08988761159599667, 0.0932523240469656, 0.10065847611129886, 0.11660208147722328, 0.09746630449461502, 0.0950797202238588]}, "mutation_prompt": null}
{"id": "cbe821fd-6ecc-4c27-8f22-5bbd6907de60", "solution": "import numpy as np\n\nclass AdaptiveHybridDE_NM_OLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic scaling\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                scaling_factor = 0.5 + (0.5 * budget_used / self.budget)  # Dynamic scaling factor\n                mutant = np.clip(a + scaling_factor * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Opportunistic local search refinement\n            for i in range(min(3, self.population_size)):  # Apply to top solutions with less frequency\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveHybridDE_NM_OLS", "description": "An adaptive hybrid algorithm combining Differential Evolution, Nelder-Mead, and opportunistic local search with adaptive scaling for robust exploration and exploitation.", "configspace": "", "generation": 30, "fitness": 0.44003936986354725, "feedback": "The algorithm AdaptiveHybridDE_NM_OLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8389914850177207, 0.8466072788861663, 0.8459209578682183, 0.8456126414968471, 0.8722055823828104, 0.846237842793655, 0.8500959630563227, 0.8416850646076992, 0.8567717626743018, 0.6887658255229606, 0.6852348555723926, 0.7019943834895018, 0.7105856862615728, 0.7038367621743618, 0.7013085387963155, 0.7052819165614408, 0.6995184067132596, 0.6916728756644537, 0.1646950688654295, 0.14439902661937498, 0.1361891806748361, 0.16848894130612568, 0.1495490178972677, 0.3051094389706611, 0.17271647055979233, 0.14769454167260831, 0.1363188052089589, 0.1347634276100691, 0.11794730165490908, 0.13725193596981766, 0.1263590596111095, 0.14506458460482663, 0.14419948169579877, 0.11621186877253642, 0.13850213530957867, 0.10772065492932348, 0.9279967687020212, 0.9011485195064819, 0.9029593476738653, 0.921584769469563, 0.9303076417747341, 0.9273137290949404, 0.9512392482921402, 0.9106164803557345, 0.8831862527885941, 0.5048148040552504, 0.510028315556347, 0.5240756786099543, 0.54559501040948, 0.5133123961717319, 0.5437872663826562, 0.5103142931949107, 0.6024494874468229, 0.49068090965633426, 0.8795020950225121, 0.8548487150939648, 0.8557103607364788, 0.8730678620563391, 0.8586920844573529, 0.8423948511124874, 0.8204083485403668, 0.8960231646164815, 0.8878850723981364, 0.3506949306390791, 0.5380912561978113, 0.45306679557050733, 0.35090825835369555, 0.351735127103493, 0.30738442665933385, 0.13175567233611674, 0.5284872620423533, 0.6149284970941302, 0.5062476514652006, 0.46614126081186946, 0.4557618337733629, 0.4438817140763818, 0.4721766874091625, 0.5317440819578412, 0.6101168508608712, 0.35551045896168043, 0.45631189059626964, 0.4957235379766841, 0.5311130402779312, 0.5440236535605327, 0.50976069615543, 0.5666591310773894, 0.4779489138728962, 0.5105603072662543, 0.5858341784358552, 0.5222910575869824, 0.6956508971201625, 0.6720773525759451, 0.6556924906521291, 0.6631124180361851, 0.6503901125106757, 0.5768355711869604, 0.6576483784385247, 0.6674988604126707, 0.6521023880375343, 0.0991071072099059, 0.12003088140421514, 0.2953336506466866, 0.3734419031776849, 0.3679794288049768, 0.3464078987124444, 0.2700823276441511, 0.1991958448744061, 0.1511057383823563, 0.3615954132239455, 0.388517895739, 0.40104567863844864, 0.39040671438685903, 0.40165339905929986, 0.3951659065114175, 0.3925664307912091, 0.43245321436146456, 0.4202371352833256, 0.78647549974573, 0.7844775508288019, 0.7661397819452986, 0.7621408819113796, 0.7925290894898626, 0.7618628566062353, 0.7676404448206118, 0.7675034367481428, 0.7857499479537029, 0.15663883236734566, 0.09481697615009577, 0.16470786240643687, 0.11475192984896732, 0.15368376635472691, 0.11042677114245325, 0.144990424258147, 0.13938266035804936, 0.139181100767932, 0.1806881853838198, 0.45994971237750526, 0.2126048910761419, 0.3978837485128446, 0.20591272923367687, 0.2522962896605302, 0.2177827556464641, 0.2640501847904202, 0.2212751679679068, 0.45271407335391056, 0.548029375608504, 0.5155088146754412, 0.4793882845281582, 0.5113552212148879, 0.5163568528429614, 0.5286828515975872, 0.5259138254507452, 0.5222577164707893, 0.37736435923322187, 0.3693399202794527, 0.36985547749787107, 0.37843792693733125, 0.39726189096056286, 0.4158275518447685, 0.3830281583599743, 0.35956111336382124, 0.42021723990338733, 0.18789335751248348, 0.20156311214780875, 0.2141401268807116, 0.19466497886215173, 0.19124642241078105, 0.2069267416237338, 0.23161919603860337, 0.21154519109376646, 0.20572621096688248, 0.5438353116868473, 0.19768775612346257, 0.18237216988241012, 0.24471460676494294, 0.2222763250648916, 0.5390376377388109, 0.5681951566769243, 0.18749952241042245, 0.207302765469914, 0.18685009487530235, 0.803230689116951, 0.18255413372310403, 0.17532249645047593, 0.876217002972553, 0.19742941235871814, 0.16143669679338035, 0.16824165994463947, 0.8625952090201674, 0.8145481647250495, 0.2074975174997885, 0.21099156856228707, 0.21093887471748296, 0.7595572849420398, 0.16852674120797184, 0.8425290840744868, 0.21192587866188062, 0.21322493351794025, 0.2039226828456433, 0.18829434746079465, 0.176644742983333, 0.181903015552898, 0.21904791499395082, 0.19043818614977648, 0.18824004380119008, 0.18377815552443955, 0.22745010724451709, 0.08805913298234513, 0.08843401016838348, 0.10316616812825818, 0.09558434670106075, 0.09413787365100523, 0.10137503614070342, 0.09560516948300268, 0.09675384693390676, 0.09551449019421265]}, "mutation_prompt": null}
{"id": "4e286f30-5abd-4286-930c-06f1ea33ac1e", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "06682091-a2a6-4d4d-a2eb-723c79c10e5b", "solution": "import numpy as np\n\nclass ImprovedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly increased population\n        self.de_cross_over_rate = 0.85  # Adjusted crossover rate\n        self.de_f = 0.6 + 0.2 * np.random.rand()  # Increased stochastic range\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with uniform random distribution\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with enhanced mutation\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c) + 0.1 * np.random.randn(self.dim), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.4 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with controlled variance\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "ImprovedHybridDE_NM_SLS", "description": "A robust metaheuristic blending Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with enhanced mutation diversity.", "configspace": "", "generation": 32, "fitness": 0.3017240304339546, "feedback": "The algorithm ImprovedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.22.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.6007361103222169, 0.6687093886088575, 0.6133794652299492, 0.5731359832243805, 0.6322453489564801, 0.6141203583081832, 0.623581606864645, 0.6688062763156227, 0.673169573667163, 0.20537003868998893, 0.15790913753645364, 0.3275172056529079, 0.2104416710609026, 0.15894127478734976, 0.20527146199208235, 0.2991694083322807, 0.1752305973479923, 0.3866828455346958, 0.15097481337414642, 0.11726253490036365, 0.136722654979601, 0.17434726346072316, 0.13368580195229884, 0.12232133931490863, 0.12224461701544276, 0.11625221256832008, 0.13419010790108155, 0.11054697883562481, 0.10792410162691646, 0.10210917768092476, 0.1134707023103474, 0.11852417317156994, 0.10351677873392984, 0.1095030664870128, 0.1282307238367193, 0.12759461862833155, 0.9729858133716455, 0.9398061145902477, 0.9333604517221065, 0.942005908204421, 0.9847682692184763, 0.9719189871635611, 0.9482494256164319, 0.961375744689499, 0.9471768042150362, 0.31709944498067877, 0.3249774546386517, 0.34610298666479333, 0.3116858876060693, 0.29966930900834277, 0.3106240811777946, 0.30429165830336946, 0.40584915510314545, 0.32826831434421433, 0.7178752833139215, 0.7451500096674162, 0.5920096981398593, 0.37062376388721796, 0.540972406592394, 0.6720768225171069, 0.49536731692956926, 0.3648926523758975, 0.6988895795307914, 0.16300913158674102, 0.1681256723852692, 0.1547830547248995, 0.1835704023798923, 0.3082044930905564, 0.15540347725553405, 0.2035659810875089, 0.16429623389964165, 0.21254930037349018, 0.24037139193966506, 0.2874746039937076, 0.16520283329813867, 0.18923240389531315, 0.16376697830931009, 0.1859332603736712, 0.18778667362712909, 0.1929459400418062, 0.18111639503058108, 0.057428837534469146, 0.14227234018666712, 0.12937472094638602, 0.08097866935637799, 0.2735618382747319, 0.031409704033089514, 0.1427089570378104, 0.22919736220577414, 0.26191282458739273, 0.22315484472588698, 0.19607002261896, 0.24733466316900798, 0.3101980889940489, 0.2905699210725754, 0.3197028208897177, 0.5064254084513293, 0.3009452595771611, 0.4846960158676067, 0.09745532914751331, 9.999999999998899e-05, 0.14603319961263272, 0.09416841842441903, 0.09039977323468573, 0.1281020907091226, 0.02071287859009885, 0.1804291519692579, 0.2034936122759179, 0.2045926801946263, 0.2121693695958924, 0.20614319050913987, 0.2031127215471632, 0.1468825652850373, 0.2171890751957556, 0.2042691074222328, 0.18370412104500367, 0.27206762745368374, 0.5860553268187914, 0.5103911316135556, 0.503280348643514, 0.47827434583547535, 0.5553489761911332, 0.4710598604421852, 0.5073711422294156, 0.5475663100187647, 0.5786462280684477, 0.1403354130414004, 0.13908315736790733, 0.11793934962063235, 0.14059131404523473, 0.1002855314125054, 0.1504465602290267, 0.17287423185345574, 0.1408636741344832, 0.1021757336667144, 0.17737466033294003, 0.3620290779707356, 0.26799083401929247, 0.15888161031459713, 0.16730724378296058, 0.3829183395112059, 0.2896800591253468, 0.2402663349816918, 0.2017304811077678, 0.296176282990259, 0.30474195651251823, 0.33254015985398633, 0.33909568659950173, 0.32353798103189535, 0.34591564802511776, 0.3161098717026417, 0.323166872193105, 0.31206364284907717, 0.2421948370435888, 0.3070552669268788, 0.24950878243167485, 0.25715980135064787, 0.23105205347396918, 0.24858742372776776, 0.2472594833675522, 0.259178779572538, 0.2555693085925337, 0.21409063719765953, 0.21321734436571715, 0.21080811887215611, 0.2135609457873433, 0.20669799272334421, 0.21723606293818665, 0.22475879115169128, 0.2104549944685825, 0.2156372884976887, 0.226462152786428, 0.1979084969124968, 0.1984036522837429, 0.1893887567036131, 0.20245751289311809, 0.2164454597283222, 0.17808005107421687, 0.20192963122460839, 0.2410455485059898, 0.18004363892970765, 0.8312506798266794, 0.6316891914192062, 0.7813528858762626, 0.8036626321508578, 0.17636913940997856, 0.20457721649288085, 0.7556790682184287, 0.16457057250153428, 0.18988450192573136, 0.16691780548644497, 0.16648313300488948, 0.7384518607351541, 0.1995786219391963, 0.16803935736577225, 0.6332065180786586, 0.7000687776056076, 0.6225689640588009, 0.17626559488003346, 0.18286555223514278, 0.1728529716471232, 0.18910416024312904, 0.2068575562819639, 0.1783563523777919, 0.18513220859728807, 0.2014216834841479, 0.1901882066309145, 0.0930074430399278, 0.09766186567289237, 0.1446879184524048, 0.0878325160492277, 0.08562043650687678, 0.0825794129212174, 0.11444720192670721, 0.0821112986797411, 0.10852087452545023]}, "mutation_prompt": null}
{"id": "b6071bf9-6f4d-4b1e-91ae-d77b67cccd2b", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "9b994de0-5a44-436b-a195-62e26d91dd79", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "dd450574-b050-44c2-a2eb-82f1ba0aee29", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Enhanced Nelder-Mead Simplex step\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Intensified local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "A refined multi-strategy algorithm that leverages adaptive DE, enhanced simplex transformations, and intensified local search for robust optimization.", "configspace": "", "generation": 35, "fitness": 0.4771458526587456, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "90fc2c3a-97eb-42cb-8cfb-c74a134364d3", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_Improved", "description": "A probabilistically-enhanced multi-strategy optimization algorithm combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with added exploration.", "configspace": "", "generation": 36, "fitness": 0.4771458526587456, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "452db4a2-58e9-4bf7-805a-60b3c7513663", "solution": "import numpy as np\n\nclass AdvancedHybridDE_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.4 + 0.2 * np.random.rand()  # Increased stochastic factor adjustment\n        self.simplex_size = dim + 2  # Adjusted simplex size for diversity\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with varied range\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Refined Stochastic Local Search\n            for i in range(min(6, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.12, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdvancedHybridDE_SLS", "description": "An advanced strategy combining Adaptive Differential Evolution, stochastic perturbation, and local search with dynamic exploration adjustments for enhanced optimization.", "configspace": "", "generation": 37, "fitness": 0.35987288875931295, "feedback": "The algorithm AdvancedHybridDE_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7800603279832521, 0.7932729184878288, 0.7812899877848575, 0.7944135245906441, 0.7929163954688846, 0.7962493771098307, 0.7862032149229298, 0.7919327104412611, 0.8062150828932808, 0.6157044849524078, 0.5995121843295067, 0.599402417652392, 0.6200630861884695, 0.6123718602817607, 0.6167921026218544, 0.6178958523521132, 0.6257953410422934, 0.5961059334761099, 0.12842494997255594, 0.1290560581456639, 0.13767290141334454, 0.1329050464679491, 0.11541858875729849, 0.11574756575188805, 0.12436599957042727, 0.12237808388628624, 0.12563363840128117, 0.10525348329088269, 0.10207028166300969, 0.11992203904436971, 0.10908981541762952, 0.11240086420177264, 0.12131296403379943, 0.11614722367597874, 0.10699246696443643, 0.1152916549261308, 0.9116778856170125, 0.9051907486222085, 0.917343601520499, 0.9389438079977339, 0.9046180635772664, 0.9432244631003541, 0.9027218808664041, 0.95105424805217, 0.9206573520640249, 0.4507616701500635, 0.4407693646277465, 0.4451492568510188, 0.44865105955150797, 0.4236065921695866, 0.43293409314492015, 0.4678972416438031, 0.417142018180657, 0.44036437685686136, 0.6817836422181214, 0.7041363244377834, 0.7588991062732366, 0.7766233210354513, 0.7340933535525144, 0.7539942536624502, 0.7022108699546786, 0.8015103479113866, 0.7308506148588527, 0.2720548339172273, 0.21613674391140936, 0.2046377188886257, 0.22098072107847033, 0.2789156009464684, 0.18940542323597265, 0.20247847941097574, 0.21982858428788887, 0.2689679998475155, 0.19871607128919344, 0.16711674605539395, 0.25831441886533724, 0.2352176918105291, 0.24737417958980734, 0.22302588924710176, 0.2147437036701606, 0.35590136861298927, 0.26350141639538815, 0.21913916609831463, 0.30034192113926117, 0.2625483937074521, 0.2876769940671452, 0.20633752347764978, 0.24066623799640086, 0.2651416471802891, 0.20905596643104696, 0.2791455352886094, 0.40184181249947837, 0.42302162464189597, 0.42418170523734455, 0.35330660441188566, 0.33477406021774536, 0.4000872847829249, 0.3680397615460883, 0.42182966862039084, 0.42544191756459904, 0.0955530633084305, 0.05604646985252926, 0.09753868784615038, 0.16143662087455157, 0.1703628230778117, 0.18300979645648863, 0.0930089119218912, 0.10216991615813098, 0.1445076528716136, 0.25307683568614636, 0.25036115251712754, 0.2650142054235125, 0.25098247114715033, 0.24583374577169181, 0.2589199306068751, 0.2173888770436807, 0.25589641123741835, 0.24794440191670597, 0.6428429638075563, 0.6327421909726514, 0.6430413920975735, 0.6380479993068106, 0.6350059153971392, 0.6550434609876833, 0.6130382474543975, 0.6427492833838799, 0.6582718110457556, 0.12117934446642753, 0.12605561805728516, 0.10622885270668425, 0.11970028299026858, 0.12051918492987246, 0.09997238970593847, 0.10592624226295833, 0.10536283704415617, 0.11417888592955683, 0.17232224961876252, 0.17492501872393262, 0.1856432852448061, 0.23628371325248998, 0.18045027448387663, 0.2597034149461276, 0.2059403757136442, 0.2612505608637753, 0.22181142264532805, 0.3507239052537928, 0.4012257294886412, 0.3831686970491943, 0.3796310819306403, 0.35970328749340663, 0.3681093363207195, 0.4207385923080933, 0.4257141419443482, 0.4246376485362132, 0.27389329175590094, 0.2783232718224574, 0.2968365258394946, 0.28710611403994835, 0.28714203771830404, 0.32030945452001214, 0.2971734669169236, 0.30519186579411306, 0.3170600613267255, 0.18644170782808833, 0.22432431304304468, 0.21374107593317881, 0.19965105946784778, 0.2160332801929471, 0.20689683512559154, 0.18157451670368951, 0.186162043931571, 0.21240631087349326, 0.23944032152510675, 0.21680677384172908, 0.21979614810294812, 0.2229155794303852, 0.21664913082079673, 0.23560396135274864, 0.21961134193959408, 0.24126759314752477, 0.20489022306966675, 0.7103137320706916, 0.7370080849277334, 0.6876499939545089, 0.5902656640022117, 0.16108382067145355, 0.6794120984514194, 0.6144922978577327, 0.7096870890171427, 0.6548575920145305, 0.6816554097899745, 0.16696655394094395, 0.20730003185201618, 0.6709918280929283, 0.6262007875039657, 0.20218928652740342, 0.6612798084047364, 0.2077262667212768, 0.5706687966787797, 0.18927368094265418, 0.17678388076073692, 0.1836307286286324, 0.18778277127292298, 0.18504597769579745, 0.17532044444138317, 0.18856568786157535, 0.19393187126656597, 0.1991282327309719, 0.0863735728873849, 0.0822334978653867, 0.08253942679400939, 0.07939619520802532, 0.07942505660700572, 0.09016260695122602, 0.07696874577448565, 0.07370762874631132, 0.08134950231927562]}, "mutation_prompt": null}
{"id": "07a01ad0-a115-42d1-be4e-e7ad2931a7d1", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n        self.random_perturbation_strength = 0.1 + 0.05 * np.random.rand()  # Tweaked for variance\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                # Ensure distinct selection\n                candidates = np.random.choice(self.population_size, size=3, replace=False)\n                a, b, c = population[candidates]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, self.random_perturbation_strength, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "A sophisticated multi-strategy optimization algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search, adjusted with probabilistic enhancement for improved adaptability and exploitation.", "configspace": "", "generation": 38, "fitness": 0.46111429226516515, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8369475909800186, 0.8428605063165164, 0.8481518751958098, 0.839597137090581, 0.8319415603913032, 0.8562275756921673, 0.8404616249628927, 0.8536451006265396, 0.8489511683683495, 0.7022395915206205, 0.710262853673556, 0.7074536451164913, 0.7112987953151957, 0.7138159395437216, 0.7039355437895114, 0.7082642553212857, 0.672702083317062, 0.7141135979747337, 0.13569331005147556, 0.13618714443925328, 0.18040896773047765, 0.19806582129724426, 0.15195875451621965, 0.31212278283333883, 0.4214937675437924, 0.5311607335563042, 0.5883788105803358, 0.14123506642266015, 0.10956661410948143, 0.12064456699025083, 0.12294684909869735, 0.11556999230170617, 0.1404499385325827, 0.12463105653989692, 0.16024221348098366, 0.1144662406578878, 0.9713215163220991, 0.9646209980269542, 0.9340062562162059, 0.9465802721970065, 0.9281340347177224, 0.9541336279230822, 0.912523450445743, 0.9443960435675965, 0.8956577056540638, 0.5876342888442754, 0.6268670226107449, 0.6045232363575959, 0.5781867223032704, 0.6078797214710955, 0.5994744485758012, 0.5708647840110099, 0.6146281166576222, 0.559317896582127, 0.8451261662997119, 0.8562084870239877, 0.8461435803341097, 0.8622379173110094, 0.8827000285652032, 0.8695730823490531, 0.8683776031434953, 0.8310686651752328, 0.8483816042865812, 0.49510459785419614, 0.41804126379656414, 0.26228041123494994, 0.6318913216818942, 0.3191601531727134, 0.2843659681606533, 0.44954942189342584, 0.22393708537424384, 0.31954211300557367, 0.37758517643489065, 0.5181560283267632, 0.24038630375602765, 0.5713188024866023, 0.4118022436138348, 0.49554447572610294, 0.32006110120339104, 0.42059605744033246, 0.2956092896868372, 0.5864890291043074, 0.5844612638264326, 0.550786271888386, 0.5748445064366174, 0.6337171636483997, 0.5707087236560779, 0.5748604063632358, 0.5854572749560533, 0.5822916244726413, 0.6396374327112124, 0.625549896037193, 0.6949870427207239, 0.6509788694743471, 0.7087534357137006, 0.626307144537803, 0.6938742867198411, 0.7202007157997852, 0.7063702213218472, 0.19273378412793485, 0.18711980843591158, 0.11910023664661162, 0.4740284352328602, 0.367850332659018, 0.45509271282201325, 0.3068483824496534, 0.28129000477514254, 0.25065602925250996, 0.4459711982949016, 0.4586019162586763, 0.4703024644561582, 0.47192137829623904, 0.48281204544886114, 0.4838615406380934, 0.43801919708514647, 0.45984198579250524, 0.4596428971600036, 0.7824978853533158, 0.8017694462018432, 0.790966055450294, 0.7702264645022956, 0.7873250400073499, 0.79443361686511, 0.7841546139086952, 0.7864424766124077, 0.7791163213581759, 0.4326717057124808, 0.1075305879216445, 0.13754092276239516, 0.15431164527377605, 0.10465646249249405, 0.113527826679091, 0.12456667753519601, 0.09633210186438668, 0.16861931772042194, 0.25784985190823806, 0.1807006331480976, 0.6596754432535341, 0.22175807121342972, 0.4928974926023527, 0.14908038653655697, 0.2224657020277686, 0.2161100787789001, 0.5777571240066688, 0.5328757625875642, 0.5288653104065288, 0.5358622823043813, 0.5805393320909058, 0.5717977978515093, 0.5800565370226973, 0.5170831744761744, 0.5816154627731553, 0.5356980772242379, 0.4478381391041093, 0.3918521055734825, 0.47962914098958775, 0.3548941260930163, 0.5162775858275535, 0.45181166850024257, 0.4125324296558378, 0.4491557343013779, 0.45051454196242124, 0.2547797542965783, 0.19897575917747157, 0.216381937077754, 0.2398126823953044, 0.21841505905434355, 0.1947443624030648, 0.25565780999939725, 0.19173529228929043, 0.2470506925496576, 0.24424905126760654, 0.21068598188781784, 0.5622530400963512, 0.2264609685225336, 0.21041697469040177, 0.21349727989386802, 0.23766120645807964, 0.20597486066412107, 0.18856538943063228, 0.19281403843672473, 0.18842438403096984, 0.8199031975335072, 0.1971644415909849, 0.20741758421476397, 0.8643336190885004, 0.16332446167308512, 0.8454312908880022, 0.16752294916643895, 0.852994887061695, 0.20685908630925665, 0.7732329646299919, 0.8043410400138483, 0.16918748250494742, 0.16922916362227913, 0.20914501541169506, 0.21096007060120914, 0.7440877449484911, 0.2102144622624461, 0.19705376157525312, 0.2175626691934015, 0.17838168233106133, 0.1911771006924955, 0.19385147566660677, 0.19384745583068408, 0.20690416096173625, 0.18629904742073833, 0.08843835454379223, 0.0909790869881899, 0.09914978899739613, 0.09753374520994151, 0.1027511399858142, 0.10197067109826508, 0.10394395728195827, 0.0952499862273185, 0.09824207176501354]}, "mutation_prompt": null}
{"id": "b229de45-d8a3-4534-bc3b-290096d85396", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "7f63759d-d133-49e8-b299-02917f03dacf", "solution": "import numpy as np\n\nclass AdvancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Adjusted population size\n        self.de_cross_over_rate = 0.85  # Adjusted crossover rate\n        self.de_f = 0.6 + 0.2 * np.random.rand()  # Wider stochastic adjustment\n        self.simplex_size = dim + 2\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a diversified spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(7, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)  # Smaller perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdvancedHybridDE_NM_SLS", "description": "An advanced multi-strategy optimization algorithm combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with fine-tuned adaptive parameters for robust performance across diverse optimization problems.", "configspace": "", "generation": 40, "fitness": 0.35748392825016984, "feedback": "The algorithm AdvancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7429770439624335, 0.729176300185511, 0.7501900731595371, 0.7585019823109165, 0.7572872420349791, 0.7545567949221141, 0.7731340903348163, 0.7636673450449777, 0.7646242106260925, 0.5708486318755801, 0.5513478271175057, 0.5517278836473489, 0.5329920443605172, 0.5246747302311012, 0.5815144674726015, 0.5547427198862083, 0.5308852681585339, 0.5683287160466897, 0.15038241514696693, 0.2381382176862129, 0.14786720734418324, 0.18371243374572133, 0.1484308317533981, 0.12045354815784504, 0.14100600608442926, 0.14901513154394874, 0.14861719604554946, 0.13153108594648688, 0.13369928145479337, 0.12396800648979789, 0.10936920190137567, 0.1436407409782372, 0.1302036898875475, 0.14070652502644976, 0.11652722074849875, 0.11658690898845925, 0.9127019827038462, 0.9238985289694484, 0.9113210590424483, 0.9292482096571028, 0.9714685279243894, 0.9564509189668681, 0.894119507840727, 0.9812702041914458, 0.9136426407226846, 0.3518043419923762, 0.39476179440319814, 0.40206523169066444, 0.3913293737115284, 0.36887624671019426, 0.37388289528899077, 0.3872194324974486, 0.36235251641500754, 0.4052683417295998, 0.6788582387161677, 0.6546678093062748, 0.7150424924428223, 0.7777000240874169, 0.7461260691521523, 0.7751968452561174, 0.7199263241451411, 0.7852939150374356, 0.8037949278880124, 0.2761691992828227, 0.33584049431377194, 0.25172859662448366, 0.26731253915019315, 0.24938046678195802, 0.23041036073844867, 0.280379217140328, 0.28647384029607703, 0.25411798256079365, 0.3266426692585418, 0.12331928778901424, 0.22698783767188846, 0.26912711235311415, 0.3424686860657996, 0.2644033051592819, 0.2543768591362756, 0.22176661943623266, 0.23403140618788487, 0.24990768414179343, 0.2941272503277169, 0.27194047528409004, 0.2913297801286122, 0.26021630099405646, 0.27802806086046317, 0.2733436347310947, 0.2362984847317562, 0.28045719276162717, 0.40001404706884436, 0.3894806029568979, 0.4277079711981656, 0.4090643401088824, 0.42904280091713176, 0.41966361641637584, 0.448210076151332, 0.3677203473830275, 0.4376574489507371, 0.06167294320060568, 0.21684238298348435, 0.0664383349844373, 0.14328121298292695, 0.15756869903112658, 0.1698218254534819, 0.1308830724849226, 0.10584642921327159, 0.12292291265553013, 0.21300077668852113, 0.2749416578995796, 0.25264407384741405, 0.24398277631447496, 0.2831607719780783, 0.24542592904589133, 0.24173897482792206, 0.2454031473927013, 0.2510093851391958, 0.6341151916507753, 0.5899381906644838, 0.6370190280927758, 0.61934834084776, 0.5980436845534536, 0.6482437886640069, 0.6144239259653625, 0.6316859400282617, 0.6319221610033122, 0.13194853930883788, 0.1461407634081483, 0.1346666591899457, 0.15093947721139778, 0.1073860095990582, 0.11715476153606263, 0.12537198300462749, 0.1419571268798221, 0.13731217958495268, 0.18738323582668304, 0.17136219982699508, 0.22870478017997098, 0.16032845461027245, 0.19061542219205696, 0.15970697802190903, 0.18238350908850431, 0.22280594125592768, 0.32980457796572127, 0.38893706595536437, 0.3770835397517056, 0.3739852907525264, 0.3393908223258323, 0.3844655890701598, 0.41375031344513624, 0.42262662894538794, 0.41682359791011314, 0.40376303271175296, 0.2860377958622936, 0.288967630459114, 0.3206745572963956, 0.26362739387223744, 0.25859280393336104, 0.29826915011194144, 0.30106232082922324, 0.31458546124866804, 0.2782511745402316, 0.22157502732838963, 0.22211038728584231, 0.21911782074401798, 0.21532158195171436, 0.2817569785904226, 0.21316174255603715, 0.19436189051648323, 0.25402368645599716, 0.24381705101048257, 0.21423336990109754, 0.2254211098102733, 0.31758931509429644, 0.19575410731742549, 0.30421259615076524, 0.2086108961602079, 0.22122858680382473, 0.21192126313756077, 0.35804291477286043, 0.1846039961302004, 0.7633576679969791, 0.17001752395476255, 0.7187093154227273, 0.83351595557069, 0.6946498238708506, 0.1609734796998984, 0.8274985816327174, 0.8423551720721373, 0.6935117173029274, 0.20012995125175392, 0.20846980581431995, 0.2087264211085419, 0.5241579229625966, 0.2099153991222974, 0.2067285510928939, 0.7746413296441055, 0.20933293471685432, 0.20435723691185081, 0.17928593635234868, 0.18574264897211024, 0.19031531650942157, 0.1953490799805352, 0.20377123488175786, 0.18779183098534757, 0.19276684144444967, 0.18098065364967386, 0.09926452121502627, 0.0923706794422553, 0.09218772807897624, 0.11059973189718697, 0.0843358319898283, 0.09802738815545986, 0.10595030946855877, 0.09278713098208624, 0.09642818500237904]}, "mutation_prompt": null}
{"id": "b4190e51-8b68-421f-ab4d-319381950acd", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_Refined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Adjusted DE scaling factor\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.4 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(3, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_Refined", "description": "A refined multi-strategy algorithm enhancing Differential Evolution with adaptive parameter tuning, Nelder-Mead, and stochastic local optimization for diverse landscapes.", "configspace": "", "generation": 41, "fitness": 0.3879942864900942, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_Refined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7617700836721064, 0.7755733783997087, 0.7724229891455997, 0.7626664364272125, 0.7852533331433634, 0.7516325855158019, 0.7722190560566484, 0.7775341584534569, 0.7862905744448856, 0.5869299120685514, 0.5973973628581418, 0.5615784596982418, 0.5623414343869102, 0.5571527690875056, 0.5612287136955014, 0.600951290811368, 0.5791666149101313, 0.5844211326774598, 0.12080946970780293, 0.1540169939713809, 0.14857220441579544, 0.14847866511556784, 0.1227265031648378, 0.14263937197625798, 0.14018172257021977, 0.24800579020943592, 0.1227756790517891, 0.1467858310297574, 0.11300408093566272, 0.12650737808193757, 0.11146417502682993, 0.1035676729471896, 0.12181548659289765, 0.14740838114619204, 0.1280007966389083, 0.120931599980869, 0.9290004342132983, 0.9762503826203764, 0.9497065869581703, 0.9182568119178369, 0.9718907825639211, 0.9083716866242194, 0.9551378061263526, 0.9695178200842199, 0.9021202816822015, 0.44940920924558303, 0.43366498942099063, 0.43932544037864063, 0.4101829930990595, 0.4270458026859093, 0.3836951705087981, 0.4174601307804583, 0.4112325761603295, 0.44613837419508384, 0.7782608659312328, 0.7337632957839427, 0.7212733319954405, 0.7764089927452996, 0.773819145932517, 0.8397557490231595, 0.7757304552697261, 0.7722988044813242, 0.7866850382101538, 0.46891706020746315, 0.12393121366290416, 0.3749049001885475, 0.33890412055903396, 0.2883359150109436, 0.42797798292898337, 0.410951684307749, 0.32725650019095565, 0.3543036019572564, 0.39546884275607597, 0.3152081657671063, 0.2476006126639836, 0.335371272246916, 0.3656388910973186, 0.4557006712661337, 0.407893710745711, 0.32235257312417853, 0.3159988604068299, 0.37624713401530574, 0.4147964282590869, 0.412697633575589, 0.3678874910670241, 0.35021377334886494, 0.3251061047666072, 0.3631701582496981, 0.4000929496230796, 0.4303141614324604, 0.5014213784262552, 0.48282386381796183, 0.5325028481420446, 0.5293028172793981, 0.4704602928245919, 0.4821126808467495, 0.510882908076157, 0.5257477348242448, 0.5204062693836281, 0.13431413244672474, 0.12939854077983437, 0.12181615229652454, 0.2415264344716832, 0.2227135829814525, 0.16577971930923086, 0.20439045348704987, 0.17134635368977924, 0.2081713037131001, 0.30037444712550054, 0.2951765186071681, 0.2920247822982319, 0.3264193355010748, 0.3208191248766976, 0.330933626567936, 0.2979507595255576, 0.30084338015918766, 0.32031318832608824, 0.6728009112636639, 0.6582894566181953, 0.6929047518405216, 0.6780543701348645, 0.6599785284298723, 0.6753104605961808, 0.6714902609728822, 0.6755912076243258, 0.6790734613196967, 0.10926038593366771, 0.12942801865187226, 0.09361732634312137, 0.4629965281117402, 0.12851594137601186, 0.1229868330104773, 0.1470453528856398, 0.14885286524540497, 0.13975795044712847, 0.15664319295754925, 0.28174765292048, 0.2309096483296722, 0.16206558024906503, 0.2065543199000861, 0.17870931064620343, 0.2312128785475568, 0.14060680211072885, 0.18560536186555388, 0.42984895530638967, 0.4308532877167214, 0.43242611621577076, 0.4176010749060515, 0.4398204420032602, 0.47610774883152474, 0.4672458461756369, 0.4349857364039258, 0.44869363675877394, 0.33331245104940466, 0.3189304518699694, 0.33587668711121366, 0.30818708378710846, 0.31312769948011787, 0.3708511929431062, 0.36527476130921, 0.3592211048860606, 0.3887385650822487, 0.21689629678694333, 0.18639065143497546, 0.20386947900560914, 0.19535207164825386, 0.21475678000852394, 0.2202737909743261, 0.1884682360886034, 0.2420887954306914, 0.22535382052888508, 0.24222776193241047, 0.21473018493944984, 0.44658732957404523, 0.2252224884682369, 0.2044775366086724, 0.468086119826031, 0.21509940715865128, 0.21808183248602686, 0.1956131705421511, 0.1947709590221407, 0.8312696866857552, 0.16153697775643083, 0.17928133483848963, 0.8419603954026832, 0.901113228836556, 0.1759631784062452, 0.1774043833246416, 0.8620646200689683, 0.5749095274707791, 0.2098413332129272, 0.20710016648354068, 0.20395440381762486, 0.20674499371480248, 0.6846857610162758, 0.2203637552321963, 0.6353499186571578, 0.7453252222513673, 0.2347257109859252, 0.218704431090054, 0.19396078748133871, 0.19147173991425803, 0.18483445515192398, 0.1915573093031222, 0.19459061058839455, 0.18375096548694925, 0.18400349806860417, 0.10282540386846939, 0.11495565063940483, 0.07596049784904413, 0.08190542237371135, 0.07677737695961118, 0.07900733757040723, 0.0832964131054772, 0.08824765953810998, 0.0800227222119807]}, "mutation_prompt": null}
{"id": "17576ed9-12a5-49f7-8996-1b5b3d4b0e3f", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_ProbTuned:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n        self.local_search_prob = 0.15\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                if np.random.rand() < self.local_search_prob:\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                    crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                    trial = np.where(crossover, mutant, population[i])\n                    \n                    trial_fitness = func(trial)\n                    budget_used += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                if np.random.rand() < self.local_search_prob:\n                    local_perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    budget_used += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_ProbTuned", "description": "An enhanced and adaptive multi-strategy algorithm blending Differential Evolution, Nelder-Mead, and stochastic local search with probabilistic tuning for diverse optimization landscapes.", "configspace": "", "generation": 42, "fitness": 0.46436841552943425, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_ProbTuned got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.9329952511008498, 0.8751581260456964, 0.8764939057430755, 0.8513031827823756, 0.8547092738879272, 0.8946732616992251, 0.8873913894646954, 0.9144777363761185, 0.9094355140617613, 0.7962990320927614, 0.7248255394698823, 0.721687693652766, 0.7461582222355997, 0.7477794842852377, 0.7217583874702727, 0.7266726732500763, 0.7132714649664789, 0.7424249266287705, 0.1534662930987899, 0.15849561094822473, 0.14271833454218397, 0.1599076314784892, 0.5879351100961243, 0.15313342763876825, 0.17701703244202094, 0.6476296674739648, 0.6988287978725025, 0.0962713469853983, 0.11024201273024159, 0.11267403830885325, 0.12171954470969537, 0.10104132916419972, 0.10903223100118886, 0.1229254017565079, 0.1492544183520197, 0.09675925948951136, 0.9678523790021896, 0.9551069246655506, 0.9489930532116073, 0.9720938652864752, 0.949777540004356, 0.9654177267735641, 0.9705638450605714, 0.9759477953243153, 0.9531652518195967, 0.5720025514149639, 0.6167664360990321, 0.6506505721591681, 0.6514441921348095, 0.6276604912927537, 0.6320017591360757, 0.6159078585241353, 0.594922604338493, 0.5795537412239484, 0.8219733541263636, 0.7717858971598566, 0.2562642469273472, 0.86958837901203, 0.7969437250882164, 0.27696546780982667, 0.7840515476704724, 0.7891056343913999, 0.7785494112008243, 0.13357855535015928, 0.13578623397632217, 0.6895419806544258, 0.1355994358732876, 0.6804916967881705, 0.6915991501499557, 0.6580828114889016, 0.5634548751833051, 0.13507689720144722, 0.6562232268199104, 0.5840726027108802, 0.65429275926062, 0.6687120732235632, 0.5886910212006857, 0.7211098805682127, 0.6204997503027179, 0.7077679658949676, 0.13647712044752647, 0.5838206679649205, 0.5368828052664931, 0.5489897011360918, 0.5765566774971926, 0.6679726751195922, 0.47142364561519734, 0.5973495586188802, 0.5869788856795576, 0.6209422886152425, 0.701472030229413, 0.739765329882455, 0.6891561288672476, 0.7255015280997705, 0.6384991733064731, 0.7286830471763156, 0.7112723780771735, 0.6901562759518886, 0.7423447553470099, 0.11214394883574241, 0.22208525478152896, 0.17304402888736026, 0.4879586201010987, 0.34698016669728304, 0.2676811095756181, 0.454875351639056, 0.3971125192615822, 0.14514576259404255, 0.5094496680329363, 0.48382271008512867, 0.4444202143860364, 0.42308742100561425, 0.5121921348987837, 0.5098033175789738, 0.43683121788825596, 0.4580982162161207, 0.45732501899219113, 0.7919301862348307, 0.8102619093283536, 0.8043744724368393, 0.7944388682140487, 0.8034940133349964, 0.7927125967113289, 0.7880901937291456, 0.8291132408144236, 0.810385568704119, 0.11266705628316609, 0.14419385017084274, 0.1144442922991471, 0.118784006919332, 0.14797051523188942, 0.1394527944539845, 0.11973320388145225, 0.12565351706055805, 0.1558845948764287, 0.6510480006875368, 0.4612784600166787, 0.19942820668503636, 0.32531910308989054, 0.5672431140491219, 0.5518202408039694, 0.16649137238880085, 0.18821816610030784, 0.3730488133858402, 0.28249679923660687, 0.4826364742856759, 0.5118497967475779, 0.49840426097610957, 0.5736008361128375, 0.5358549612293182, 0.5759969496904327, 0.5262928267371696, 0.5787301736334818, 0.22440807457960177, 0.2943356937469581, 0.37940334258940345, 0.457634799691335, 0.35907318054846094, 0.39977302742425735, 0.2934189972437915, 0.29562035003479237, 0.36077121072534357, 0.21060152838179025, 0.20192023911993662, 0.19425142241443594, 0.21129709277926345, 0.2615984000389453, 0.22874173576738588, 0.1975833417217604, 0.28172770058366214, 0.2908910465509884, 0.20800023530776413, 0.21049577645021678, 0.19172799324255096, 0.20647593601515957, 0.18171018780715642, 0.2369868726336506, 0.21013209419290513, 0.22058008206449298, 0.1971576197800068, 0.20480091513616494, 0.9320303470193659, 0.15968411029977347, 0.1486308006648296, 0.9142014174860789, 0.1229876584738715, 0.18905966173073918, 0.8930462454901401, 0.1695563224181913, 0.12898170552599242, 0.16948455404463025, 0.213526718525758, 0.1698617395961477, 0.8669105381449275, 0.1691748417449127, 0.21007869904053622, 0.8673564223329976, 0.8955813327805995, 0.29575988549693155, 0.2204643169013707, 0.1930972282380291, 0.219269643893498, 0.2162424121423815, 0.2074086939352071, 0.2241032296449219, 0.24765060430096641, 0.22231599282150183, 0.10212599750088591, 0.09377618629453865, 0.08821025360107759, 0.1273695894949809, 0.10463543221458638, 0.09537562472579497, 0.1213842007163527, 0.10040823445944547, 0.0968597043788606]}, "mutation_prompt": null}
{"id": "951fbec6-c0e8-424a-a78e-cddee0a12432", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a wider spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic mutation adjustment\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                dynamic_f = self.de_f * (1 - budget_used / self.budget)  # Gradually reduce mutation\n                mutant = np.clip(a + dynamic_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with focused perturbation\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)  # Reduced variance for precision\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedAdaptiveDE_NM_SLS", "description": "An adaptive metaheuristic combining Differential Evolution with dynamic mutation, Nelder-Mead Simplex, and localized stochastic refinement for robust black box optimization.", "configspace": "", "generation": 43, "fitness": 0.4128726437950225, "feedback": "The algorithm EnhancedAdaptiveDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8506213762000656, 0.8585465427450953, 0.8616582184684745, 0.8524747889886855, 0.8515151760670971, 0.8491452649814415, 0.8454965747917553, 0.8639314179164944, 0.8682849022149872, 0.7262614698647566, 0.728040256097017, 0.7430177666217015, 0.7329566421525, 0.7342635583855011, 0.733488606447479, 0.7248876618244213, 0.7376144750870126, 0.7296727146749936, 0.14979245614721548, 0.14698886625083163, 0.16614291021167704, 0.13997728387242347, 0.14812711913967014, 0.15424015417938353, 0.17669039108196372, 0.1541296207906353, 0.17361486557071015, 0.1618027495754084, 0.09677768586568514, 0.12530870524263205, 0.11271028080310264, 0.1502647202162689, 0.12680482161502638, 0.10000059410011364, 0.10707034354336353, 0.13929502530721438, 0.9072495406284169, 0.924599102991739, 0.919468065603045, 0.9211797356175639, 0.9229626452763722, 0.9208881391305385, 0.9267766026825713, 0.9207259076454781, 0.9667506482516812, 0.5715937861217957, 0.47986915522883733, 0.5648414269792577, 0.5873192121045047, 0.5162255080259077, 0.45697182973000117, 0.48469938178094674, 0.45483196189649067, 0.5416847854006073, 0.8595714848104229, 0.8643853931614103, 0.8610367229838719, 0.8552026095793692, 0.9101103130957959, 0.8413424305857414, 0.8582858497638419, 0.8359789495863339, 0.8754992611982128, 0.33805721406911626, 0.18771514487572727, 0.18512622588019523, 0.2047248938223203, 0.48754245653529815, 0.1295155470179099, 0.6443358431975125, 0.1996257327808637, 0.18917735062779262, 0.18020315497677786, 0.17486870366601948, 0.17074733005566378, 0.19095138529159816, 0.2717912272504517, 0.17617382609279608, 0.1758986297438767, 0.22577513615198685, 0.1611712442862292, 0.5967629848566905, 0.5217014800408493, 0.6655170510787068, 0.5076244735190449, 0.2810222205637919, 0.4505882240239877, 0.4428805241112911, 0.66544629142021, 0.6403089291132429, 0.6681875842023854, 0.5061024291872389, 0.6002860774986045, 0.6670379432241877, 0.7016244602092794, 0.4623455826021653, 0.6427928703503035, 0.6821879491402449, 0.7157774725781609, 0.1278419410852597, 0.12116311388794254, 0.16022802116351398, 0.2965835861372168, 0.1886116228069885, 0.1565371908685652, 0.2518543034777635, 0.19640426961508606, 0.1241320345823157, 0.4366515992404745, 0.416830896419942, 0.31707255916095123, 0.4074984410740632, 0.43700320115432856, 0.46216197508877244, 0.25957031790239893, 0.3278850409355435, 0.37954624365428224, 0.8005717448640791, 0.8029531933145613, 0.7363426968137539, 0.7425780845548369, 0.8147703132829212, 0.8065394854327925, 0.8171789197471327, 0.6737419317131408, 0.7892723851930905, 0.13988113748232267, 0.15889091630415075, 0.11998210012989652, 0.13797307016516092, 0.12947702844800857, 0.15421939938903084, 0.17858087967873237, 0.15331598873189456, 0.09579478889121329, 0.29445478793614255, 0.17048704401913872, 0.6318975840897997, 0.2776655805901026, 0.3062278954993518, 0.27878665465564134, 0.2035795328484773, 0.18580849282119982, 0.20155554637784612, 0.5500005564984342, 0.2800789051795589, 0.439627325149642, 0.5642208972044933, 0.5647745032018474, 0.6427080217428965, 0.5686937691394061, 0.6163413769431074, 0.6470723010676929, 0.2883796381969026, 0.40438621253611895, 0.31307344795292547, 0.4643189592600625, 0.35156937350930406, 0.3548300478376797, 0.45114671638041814, 0.37760744617469677, 0.5022532819053025, 0.2153411852468069, 0.24950120652697416, 0.2865482311464258, 0.20808743362764304, 0.23508785793715048, 0.22128727131724257, 0.2103902043517859, 0.3255604109131105, 0.20903640910079946, 0.21977564428156338, 0.19836370158320038, 0.219639343866333, 0.21567110543125956, 0.1818011665822119, 0.23459395646182224, 0.24184443562939573, 0.21792409893924736, 0.2013973789385196, 0.1688574698678893, 0.16673297372637041, 0.1587035211416432, 0.19966951927464172, 0.16856783429975164, 0.8416716842392685, 0.1625662733211164, 0.7982604794419912, 0.7803903927413993, 0.8006736467052357, 0.16727861349810558, 0.16861097872536213, 0.21013499683067705, 0.16815910868161466, 0.16770274154760978, 0.15352929525329784, 0.21048946248803668, 0.212505437901643, 0.20008918779879836, 0.19938491865428631, 0.20161526509569205, 0.19744559640805537, 0.20819922618439235, 0.23934184324709717, 0.21316537152989867, 0.20973737321489694, 0.21997258225915173, 0.0928625005034659, 0.10409676382353372, 0.12517650808764103, 0.09202185989059453, 0.10594101779167231, 0.09954901470885147, 0.13720374077354613, 0.10099328493708659, 0.10289116119266051]}, "mutation_prompt": null}
{"id": "ff535ff8-b698-4ba7-b344-55bc940c3433", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Adjusted population size\n        self.de_cross_over_rate = 0.85 + 0.05 * np.random.rand()  # Dynamically adjust crossover rate\n        self.de_f = 0.4 + 0.3 * np.random.rand()  # Broader range for DE factor\n        self.simplex_size = dim + 2  # Modified simplex size\n        self.local_search_probability = 0.7  # Probability for local search\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Modified contraction rate\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.45 * (population[j] - population[0])  # Slightly more conservative shrinkage\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(7, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                if np.random.rand() < self.local_search_probability:\n                    local_perturbation = np.random.normal(0, 0.08, self.dim)  # Reduced standard deviation for perturbation\n                    candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    budget_used += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_V2", "description": "A novel hybrid strategy combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with dynamic parameter adjustments for wide-ranging optimization tasks.", "configspace": "", "generation": 44, "fitness": 0.4132100349543788, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7536155958132202, 0.7736823067331533, 0.8371078547955748, 0.7805843050578627, 0.7677393340896139, 0.8365586667184528, 0.7702988937232803, 0.7726294847050893, 0.8253349101183687, 0.5759402929811601, 0.5903879249787772, 0.6971180120087366, 0.5864584409807545, 0.5872740114740447, 0.7182133612235133, 0.5744586160227021, 0.5503352034112823, 0.7052512475882844, 0.137856863962464, 0.26372143313740626, 0.17255095383675711, 0.12052699238451692, 0.17328372687134797, 0.14531883325631967, 0.15126884805838148, 0.3159149805631205, 0.4264653246121982, 0.11913161004892714, 0.12065045444153544, 0.13332488157842015, 0.13435817616738222, 0.15592620902876242, 0.12224400948300718, 0.13453589693545598, 0.1208694914928774, 0.09118275315363078, 0.9404718403881903, 0.9336466970697366, 0.9203458935836984, 0.9647594645031647, 0.949734593836576, 0.9023476531801304, 0.9374273202349946, 0.9564489502879883, 0.9158304701914202, 0.41643634804302365, 0.4158297693244438, 0.5810675169928721, 0.4504762678892048, 0.40157054735878095, 0.47183134297387663, 0.4415310002859508, 0.45200598863083963, 0.5682546700299119, 0.783717572832816, 0.7319148658711119, 0.8868501693835504, 0.7970692498067831, 0.8287860177203331, 0.8576293863774765, 0.8505613908775325, 0.775273311621383, 0.8344149553193078, 0.3054493922549072, 0.22796270980105582, 0.12609755054947724, 0.3249283482705666, 0.315843278873187, 0.37827792701318774, 0.2883658964515571, 0.4319345676077003, 0.20178968611728132, 0.2915290792055284, 0.4234584043815983, 0.20365970972326386, 0.20604601212311124, 0.28114259292370547, 0.3350074567598499, 0.29186908669431444, 0.26724702861611027, 0.16208802059829064, 0.32804034281455596, 0.3321973961453919, 0.542964811531311, 0.4162051887446131, 0.3157540022398516, 0.48497230360187826, 0.35857661256614815, 0.3333691066927056, 0.4988018970767748, 0.47338191206848856, 0.4435385806780877, 0.6335036987651633, 0.47108148232917946, 0.4275030433478777, 0.6016451126034459, 0.5151150664879935, 0.5129996521356546, 0.639932052785967, 0.09110518115369892, 0.08553174830971144, 0.08574644948694365, 0.2507665357685963, 0.18036751230827708, 0.39870258812198944, 0.19423670618820477, 0.11285184545425253, 0.23197575795504288, 0.30128067524895663, 0.2865033336667102, 0.4045000492590747, 0.32777282194546264, 0.3042936691702396, 0.3600783839417694, 0.27799338927767514, 0.28119083013978097, 0.3607540012368504, 0.6565817946897048, 0.6811883454797253, 0.7509362635814623, 0.657767856086608, 0.6635716881957614, 0.7587497079330073, 0.6629633268385315, 0.6594344735792979, 0.7696769800855225, 0.11403588629135575, 0.1434367436704015, 0.14944307861461947, 0.1391585832364195, 0.20010422460989918, 0.15020910771191232, 0.1678774004172956, 0.5304905598420184, 0.12197067413440776, 0.23657640343871922, 0.1881913145611841, 0.1582471074004077, 0.3582044025417538, 0.25632558281714746, 0.2000053925659745, 0.39744972313124505, 0.16712016860477485, 0.5923040396891444, 0.4558216851798157, 0.45839742240639403, 0.6540244602449112, 0.4373562126626165, 0.43564330983775523, 0.5127191714886791, 0.4836296256909466, 0.4995943609951735, 0.6397726516393942, 0.38317594929814147, 0.35008098173608637, 0.3084047916352728, 0.3058055404345531, 0.3353277815814557, 0.4236730597502839, 0.3588529396575333, 0.3404800013101219, 0.46721494491987947, 0.21271926762484594, 0.2133698931753112, 0.22882504441443785, 0.2262021014832386, 0.2318540272492997, 0.2609774438387804, 0.2223206482139325, 0.24011596827716142, 0.26130501068849277, 0.20721738898265862, 0.20812458473249085, 0.21902439489675918, 0.19598403674152864, 0.5179408873508108, 0.6251720741527427, 0.4018934387665474, 0.2439200863161859, 0.6826870752888006, 0.15083283984621798, 0.8348920572366179, 0.18601179813969182, 0.668687102685873, 0.18630839479140515, 0.7981214079348911, 0.8193661678187242, 0.17377897310412793, 0.8730530160920881, 0.8128060184876634, 0.20799357871707114, 0.7817018554728541, 0.1936518012183721, 0.6662965789056328, 0.803683803152969, 0.1683598160800851, 0.8193796250410562, 0.16381129668314387, 0.18547336900546374, 0.1812305985091318, 0.18731056051802253, 0.18039427525730367, 0.17454715643589258, 0.21055727053217432, 0.18006088453263713, 0.18042342557673297, 0.20177549196948963, 0.09037339773693698, 0.09099654478441477, 0.08994097818965896, 0.0784440026833545, 0.08690316973469447, 0.13395691425157652, 0.0829582618466197, 0.09359616287782557, 0.09775621661956757]}, "mutation_prompt": null}
{"id": "607d537a-a288-4ef3-9c94-83d55588324f", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.85  # Reduced crossover rate for more exploration\n        self.de_f = 0.6 + 0.2 * np.random.rand()  # Slightly increased adjustment range\n        self.simplex_size = dim + 2  # Increased simplex size for more diverse search\n        self.local_perturbation_std = 0.15  # Increased perturbation for local search\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Enhanced Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Modified Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted reflection factor\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 3.0 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted expansion factor\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])  # Adjusted shrink factor\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Amplified Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, self.local_perturbation_std, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_v2", "description": "A novel multi-layered metaheuristic combining an enhanced Adaptive Differential Evolution, modified Nelder-Mead, and amplified stochastic local search for robust optimization across complex landscapes.", "configspace": "", "generation": 45, "fitness": 0.38512867916483046, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7885204589010006, 0.8061996560722134, 0.8067425301341437, 0.810552577607935, 0.7991443101633157, 0.7968926132778571, 0.7996409101711519, 0.7939167751226021, 0.8130609670252872, 0.6319505799912457, 0.644737332246547, 0.6334734601091185, 0.6240892696987013, 0.6298016123563779, 0.626672208636305, 0.6055009430524598, 0.6324362741762406, 0.6347794152988879, 0.1372731646678298, 0.17866808351866925, 0.15909176131947766, 0.13483786423892874, 0.38252644175249506, 0.1670162838022985, 0.17219477111253578, 0.5062716583192731, 0.14658130568052252, 0.134526479247156, 0.10617721540746405, 0.12526549802524756, 0.12559605292154974, 0.1174784333071226, 0.12087465524753882, 0.14342988703837922, 0.11432414440930294, 0.14695413658690304, 0.9736799208131289, 0.9608148463157291, 0.9432054880774888, 0.9690996114508544, 0.9298240463931388, 0.9663833317261497, 0.951271198458575, 0.9581532346337994, 0.9662071120707338, 0.42634051308075993, 0.4853919786102132, 0.46226414665146554, 0.4513054219343505, 0.4785825739389127, 0.4197853596382535, 0.42079652122139655, 0.4820024468599994, 0.4756328856876588, 0.728309170675153, 0.8151709695501558, 0.780043385902107, 0.7673034076656058, 0.78695407893137, 0.7866132127649144, 0.818910459741842, 0.7746157052663203, 0.8396377476209917, 0.3348139848460441, 0.28637063185769407, 0.28651681330128154, 0.347494013840276, 0.389219096357288, 0.28729472668175227, 0.3307360579613462, 0.36510604912353006, 0.4028734162824047, 0.37523347772369975, 0.2951453485859876, 0.1828466788749884, 0.4478594186823446, 0.3707492476088061, 0.5148174304667027, 0.2783341705134601, 0.3466505869272498, 0.26975444161012485, 0.34013062443839537, 0.3683910257628017, 0.3723782786050841, 0.3641507882373941, 0.34835838977838773, 0.332874654345258, 0.30474152342516647, 0.30661947571260095, 0.33790338897595185, 0.473831235929555, 0.5146823187378351, 0.5119365689392151, 0.43620500605504375, 0.44930398873209554, 0.4941743123834743, 0.4550102583020331, 0.5595189709235193, 0.50593227297366, 0.06815395787072209, 0.10934319598747588, 0.17499416319655847, 0.16842537764753374, 0.14258118168938927, 0.231601687327334, 0.23111834270137055, 0.12661063492604585, 0.17515313376541675, 0.28230032928859405, 0.3148941786510604, 0.2825048697759367, 0.3194571721122671, 0.3193318690442224, 0.34412198213373435, 0.26453436016166576, 0.3209515081312797, 0.29804738548783094, 0.6837657047241896, 0.7209992967733032, 0.7097201651774208, 0.674439358625152, 0.7094221483272292, 0.7124257852422673, 0.6694926028310053, 0.7104190061632978, 0.7197503948840979, 0.1587453652023989, 0.10120880161166845, 0.12851753616846162, 0.1423551798024113, 0.13858162936016982, 0.16145739035964757, 0.13060465810345945, 0.1121475904964917, 0.14080612151096616, 0.21238548980667837, 0.18926034562530414, 0.2784863618715714, 0.21226761217226198, 0.15607988592486455, 0.5098575257186202, 0.16624673490418718, 0.18419045631050568, 0.16977799433170893, 0.4762284887375028, 0.4325407419731355, 0.4181563117669894, 0.4342418464418478, 0.5166358251078054, 0.48789391200745225, 0.4500820224785763, 0.5030277521762647, 0.4863132992464724, 0.3004448254724067, 0.363876022315464, 0.3481631567816109, 0.3361346426538532, 0.33710049286704, 0.3375962727750077, 0.3373207661729749, 0.36906231990403415, 0.3927301576986877, 0.2064750421496665, 0.2511601754070635, 0.2103358124915412, 0.1818074430422406, 0.22274748928458787, 0.19822921831749185, 0.21837246114654385, 0.19655988696658833, 0.24908228607828675, 0.2261936743074986, 0.19196191314111788, 0.23293560586588846, 0.3483698868332227, 0.5763405006946687, 0.22412093978167213, 0.47093306793584866, 0.22030540703833756, 0.18600167111592414, 0.1533275279446218, 0.14116704980986505, 0.2096087102424613, 0.18584814206272027, 0.21078867958132963, 0.169092345947624, 0.15067870840776454, 0.1764192258524292, 0.7846492481575416, 0.12736455383504597, 0.78274655033584, 0.2101737372188801, 0.20683425475788053, 0.7791162923817514, 0.16749659622974, 0.20974597069908063, 0.6801780689642054, 0.21361683379510554, 0.18080313798051917, 0.18011505998717603, 0.19538314314308636, 0.17497744421454609, 0.19076439556105418, 0.18314497036744404, 0.20288135187261125, 0.19069084698598726, 0.1886531666647977, 0.09997660663251684, 0.0899296207743302, 0.07403757201101346, 0.09825463623609176, 0.07876995590066649, 0.10164740162547492, 0.10834122639901322, 0.09170315570117926, 0.07839352139127531]}, "mutation_prompt": null}
{"id": "9694e8c4-71b4-47c3-83c8-0d9d64fca8fd", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size for diversity\n        self.de_cross_over_rate = 0.8 + 0.2 * np.random.rand()  # More stochastic variability\n        self.de_f = 0.4 + 0.2 * np.random.rand()  # Adjusted DE F parameter\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic F adjustment\n            self.de_f = 0.4 + 0.3 * np.random.rand()  # Dynamic adaptation of F\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Slightly adjusted reflection\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted expansion\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted contraction\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.55 * (population[j] - population[0])  # Altered shrinkage\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(7, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Wider perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_Improved", "description": "A multi-strategy algorithm fusing adaptive Differential Evolution, Nelder-Mead, and stochastic local search, with dynamic adaptation of parameters for diverse optimization landscapes.", "configspace": "", "generation": 46, "fitness": 0.4032124673054908, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.787838297229962, 0.788153634902441, 0.8020794919855346, 0.7882190391820358, 0.8042969381076108, 0.8017008713874187, 0.8005278478232296, 0.7917918944453906, 0.8037890393234419, 0.6454378729350183, 0.5980996338332054, 0.6408770721917043, 0.6212328898726208, 0.6166765009881673, 0.6311848587087352, 0.6281420661689787, 0.5816940693924897, 0.6274248910645392, 0.14022807867401166, 0.15349989904058836, 0.16486053201697481, 0.14765990692027187, 0.12569805239339782, 0.13082273653731358, 0.3373392725460438, 0.13256540505891257, 0.2168478170293694, 0.14749818184788166, 0.10159083496267196, 0.11560748428014178, 0.13126287436647022, 0.11817648177941775, 0.15668264164872958, 0.1299641776603272, 0.17465670936900546, 0.10235627454792773, 0.9259770222436539, 0.9562114256444835, 0.8874556097780432, 0.9105139875491113, 0.9408522763122227, 0.9328024127936811, 0.8994680477998651, 0.9020504341052602, 0.9048280877457713, 0.4845594320128904, 0.4560902478792491, 0.5209297503482792, 0.4783598569571642, 0.42926950994537694, 0.4739558748267688, 0.4979052256622606, 0.44681316538716653, 0.50268394593533, 0.8104240492519845, 0.763613300413998, 0.8249816398825468, 0.2085295797232256, 0.8329968175928727, 0.8060361814244789, 0.8101992796093729, 0.8300182133151317, 0.7957263329390984, 0.29050742684229913, 0.12359908013577858, 0.2556046626067203, 0.19524590460364166, 0.25837806343834957, 0.3045502156684139, 0.24657929223431674, 0.4219481637194188, 0.26277509753206507, 0.27500675506311467, 0.3253822360372275, 0.368320022474544, 0.3074547455256754, 0.2749827322856354, 0.4741851743858604, 0.42301754006484726, 0.24370692382823456, 0.2255052367653736, 0.4830598353056663, 0.3692294016355139, 0.42897344435644646, 0.40124765726532785, 0.4008621571768223, 0.39693285461958117, 0.49322346264931405, 0.3682171460547967, 0.4698231427280267, 0.6140466013285741, 0.5169229179648533, 0.5803704579167827, 0.6040156671764849, 0.5326678985809687, 0.5700296666597937, 0.619736135983727, 0.5807553893284492, 0.5731744695348082, 0.2882459712424078, 0.0788029046495845, 0.11043597545548822, 0.3046822117118634, 0.23472101244678545, 0.2581846316855676, 0.12604170936155146, 0.2282874737746099, 0.2003474116040076, 0.37086299650244003, 0.3122856524422226, 0.320400378367118, 0.36403991727594565, 0.3267669563449356, 0.3516698965163211, 0.3542252803004109, 0.3209926398316979, 0.34322896582723916, 0.6868902686534397, 0.7005417226025117, 0.7156993127957223, 0.7150818001380379, 0.6856653165537362, 0.7214460112990637, 0.7095389438170999, 0.6983267428953437, 0.690219778707766, 0.17341921425517703, 0.11918114251708978, 0.14160387885736092, 0.14290748637251638, 0.13131073862128784, 0.16243330697342062, 0.11480780770875931, 0.12940870724931153, 0.13658054323410962, 0.28335937097925, 0.2195846483962951, 0.41419028362652266, 0.584438409434853, 0.2842709426988562, 0.23213742976423435, 0.16137472345236203, 0.1894466232967299, 0.3923093394873953, 0.46466230747227, 0.4825305791584056, 0.4492509726779196, 0.5179349491270395, 0.4553758902396884, 0.478979224867224, 0.5085663012879715, 0.47367271419765977, 0.5219144143662572, 0.40975605986653285, 0.38894571033773373, 0.3352125681865733, 0.40450927027935135, 0.3940045290934958, 0.3872002498295426, 0.39137377527460504, 0.33856263602353365, 0.38925530622451165, 0.1944880709051532, 0.24156856659173587, 0.2049518435141029, 0.22212628669424017, 0.2015613154720346, 0.20021288811117743, 0.219951301902656, 0.24615283281618106, 0.19639807691356714, 0.20277294692196368, 0.38407835290358805, 0.20679565987740567, 0.20823847268177498, 0.2027991754831754, 0.21730486012433037, 0.2087816386793725, 0.2157326003036345, 0.22152727207876588, 0.1995875558724195, 0.795036892569471, 0.18455086967170675, 0.16489487458128915, 0.7939471602147644, 0.16990321538907538, 0.19611677769577396, 0.5941421223231148, 0.799478536028115, 0.20835609364087548, 0.7907340576741637, 0.8308629332116946, 0.2076555850924814, 0.20905023434164316, 0.6367628555137328, 0.7319396776197784, 0.838489903072776, 0.1968115173123972, 0.18691200189532187, 0.1965745139378915, 0.211951651478123, 0.19813188224887757, 0.1835117134711831, 0.1786149986022605, 0.17574613869279643, 0.17390663794872785, 0.18473220928006528, 0.0920936218511701, 0.09420573728314863, 0.09157837896090515, 0.10079676257193737, 0.09459068635351653, 0.10575468295912982, 0.0858406912765689, 0.08596797358250041, 0.08734213677427394]}, "mutation_prompt": null}
{"id": "078ce01f-92e6-49b9-9e6c-fe8946ad0672", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slight increase for better exploration\n        self.de_cross_over_rate = 0.85 + 0.1 * np.random.rand()  # More variability\n        self.de_f = 0.8 + 0.2 * np.random.rand()  # More aggressive scaling\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Enhanced Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted reflection coefficient\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted expansion coefficient\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.55 * (centroid - worst), self.lower_bound, self.upper_bound)  # Slightly increased contraction\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.55 * (population[j] - population[0])  # Adjustments for shrink step\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Selective local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_v2", "description": "A multi-strategy optimizer with adaptive differential evolution, an enhanced Nelder-Mead approach, and selective local search for robust black box optimization.", "configspace": "", "generation": 47, "fitness": 0.31282455629646183, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.6053577162805466, 0.6057458141132804, 0.7050485878993344, 0.6605580976059442, 0.5854581681506532, 0.6963945989378855, 0.6300113006251353, 0.6115732353893542, 0.6999492548335821, 0.36234005658297197, 0.3775107679443377, 0.4228155480024617, 0.3287888003889058, 0.43457464100971, 0.42628568740652195, 0.32639437206869126, 0.31956988883790394, 0.4275191901348724, 0.1316302252803474, 0.1793946652290741, 0.13848608945790186, 0.16870930591550914, 0.10964778581067314, 0.1275987820472314, 0.13038237453618606, 0.12595946562427995, 0.10758463643431793, 0.1134728397615632, 0.09995162104678601, 0.09108004049124496, 0.11161529468561271, 0.11732593497788968, 0.11351899051261849, 0.08533380333933183, 0.09933154366182084, 0.10107877795641185, 0.9787249102219819, 0.9448699045276042, 0.9565311674920727, 0.9415671967725292, 0.984336867906546, 0.950054894941931, 0.9454658092491973, 0.9711325287695776, 0.8950715616882942, 0.32241603957887965, 0.3221939625287987, 0.32916571678188145, 0.30814926815127874, 0.2870672006612289, 0.3444781930547549, 0.2995484954883737, 0.31477400963853397, 0.31315616001038915, 0.6755477544467068, 0.5313716865396848, 0.6061976142705275, 0.8162017591118491, 0.6027373037835662, 0.7113127972172291, 0.63148718051975, 0.7465459970112747, 0.7132206047204005, 0.3456654629867906, 0.19074119177698035, 0.2298407938171434, 0.17333820161807434, 0.1656774757330466, 0.20588660443911322, 0.202622635506858, 0.2558821521044481, 0.29257416554068527, 0.11079436992423819, 0.2714578611054993, 0.19264277723364043, 0.211707823717189, 0.23820510854931665, 0.22785571256594006, 0.21585211031244722, 0.23185888089511486, 0.3164861242638807, 0.17104031257579155, 0.17762012100582725, 0.21342024029905793, 0.1600775614738048, 0.16794256357024073, 0.2405420870540924, 0.15965004542585082, 0.19357601087724874, 0.23720584477165452, 0.41411279192386397, 0.30894489349371923, 0.3141785403122762, 0.342272643889461, 0.3631431877077169, 0.33871801749218233, 0.29024470214249454, 0.3434154280800513, 0.3797144172624155, 0.12770938715716618, 0.02162461742398669, 0.0671360360162393, 0.13804884980171284, 0.08315116740273809, 0.11263587921922757, 0.08220609409225366, 0.10731754612444944, 0.12211167976338733, 0.17925107221945213, 0.15330254823699452, 0.22311760205437892, 0.22280665817454615, 0.20730014853278533, 0.21196302735023875, 0.18244707593334997, 0.1823036566084768, 0.1908351808144615, 0.5374541755564299, 0.5069134146589003, 0.5434910767381789, 0.5744668193003681, 0.5551060949287621, 0.5842434828133594, 0.5785146519510218, 0.512779272562637, 0.5612391566763117, 0.10887618013684319, 0.13186608474332606, 0.11342695660368063, 0.1074562677979708, 0.11673234628153473, 0.11975440765387446, 0.10409397487185035, 0.11526707373340273, 0.14259165494768933, 0.1501757459566636, 0.18214179044016887, 0.26408087943837955, 0.4570689385954634, 0.19660521582219892, 0.20569550066947306, 0.17455491250363087, 0.1738415967779613, 0.16977986971413084, 0.27964977434236526, 0.3212192136220139, 0.2877691945398495, 0.2607940224142318, 0.3443364117306208, 0.3423851696070722, 0.33546433425763467, 0.33511135076422927, 0.36772313470178297, 0.27359217726050167, 0.26199304183915895, 0.26888846446931525, 0.1900084799952676, 0.2564311834686299, 0.2652783233954805, 0.2312914329953797, 0.2257662774689393, 0.2746147478921396, 0.22454406041679076, 0.20123614713905869, 0.19203817509781285, 0.2294245986727953, 0.21380185234206206, 0.2036575744557787, 0.1798964310225587, 0.192317251654068, 0.20072222854059063, 0.18979256554313728, 0.20714648074797104, 0.1905163331523314, 0.19987148278345634, 0.1872628433269381, 0.20038387276298786, 0.19978258488902967, 0.20449874743909424, 0.18604491437285187, 0.7122335141552715, 0.1858977652813646, 0.16069236694903832, 0.7241826278807585, 0.3243198531640331, 0.6444019744790968, 0.7186938249701547, 0.5836500323940184, 0.18062066805629662, 0.19621341861421826, 0.7023349588050791, 0.1644636862921932, 0.1949068422391188, 0.2103859647355797, 0.7514989476186122, 0.20391045462768842, 0.7406868792919034, 0.6917489654678217, 0.18243425859940166, 0.18468294888056958, 0.18079304243468208, 0.1789436906667483, 0.18318068472285776, 0.19309364357845848, 0.1795359130219869, 0.18794099223216532, 0.1736064524310279, 0.08074017718364757, 0.10431655077792235, 0.09740551410890019, 0.07469484272927474, 0.09259933228117256, 0.11117142060859608, 0.08229635773064603, 0.06771351650365565, 0.07913807908390613]}, "mutation_prompt": null}
{"id": "6f5cd609-7661-43f3-9dde-9dffc3cd2f22", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "26c4789d-a322-4604-964d-c9ad2f1377fa", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.7 + 0.2 * np.random.rand()  # Slightly increased diversity in mutation factor\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Stochastic Nelder-Mead Simplex step\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.2, self.dim)  # Increased exploration with larger perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined algorithm that integrates Adaptive Differential Evolution, stochastic Nelder-Mead, and local search with an emphasis on mutation diversity for robust optimization.", "configspace": "", "generation": 49, "fitness": 0.3698996832579254, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7697745621624985, 0.7658046583670872, 0.758672729577289, 0.7721402142010988, 0.7857084211313166, 0.7865278446736982, 0.764114408335044, 0.7865817535213642, 0.7887902173079891, 0.5505540995937489, 0.5661861656350946, 0.5743774365386795, 0.5344721705595453, 0.5847508540418667, 0.5816308641288058, 0.578511380275428, 0.5791385910874949, 0.5818321480071365, 0.3089750088114721, 0.18239630321331024, 0.1620122501098109, 0.1663613623136806, 0.12268514888253734, 0.18494312710453908, 0.14056893822884065, 0.43328754904624134, 0.14805222429120946, 0.1075557736817242, 0.13261884107958688, 0.09618663533918348, 0.10611793403653469, 0.11935681767160855, 0.12906386512479073, 0.11640364217726384, 0.12279888155837071, 0.14157458113158772, 0.9689275655546716, 0.9534873994495014, 0.9566639793389775, 0.9560965089847538, 0.9383853094619687, 0.9449644731038123, 0.952061377069737, 0.9819317654390475, 0.9543505376444594, 0.37080640740880955, 0.4056031114874097, 0.39897223772432333, 0.37391974088499413, 0.44322761244679354, 0.4366738746630836, 0.389393510417091, 0.39823340014610265, 0.40702886368719204, 0.7909483913272497, 0.7356747340459275, 0.7559209097437198, 0.7102557384494244, 0.8760357718176259, 0.7235362538829473, 0.7375650237570157, 0.7514173670861488, 0.7880774768522304, 0.21473455530990138, 0.3925466905677373, 0.3822898234824049, 0.2513461330921194, 0.36445390277334777, 0.37022155298184667, 0.25018393176385256, 0.308380035330043, 0.3686243606358679, 0.40839742073300533, 0.4422931471710343, 0.37382741211494586, 0.31913006423703005, 0.36325039883064525, 0.3215392287389319, 0.28908037429448263, 0.2750555067590015, 0.1924518034412679, 0.26497870561248005, 0.3955642552743882, 0.3422439624135064, 0.3125353925146923, 0.3379527951316448, 0.34860249449182734, 0.320576823750481, 0.4221474612107511, 0.34786103480445485, 0.524345295756236, 0.42414813705529175, 0.46849378633814875, 0.4831855908495709, 0.46869007897148196, 0.42657079625547367, 0.46925542540098153, 0.4906551704478215, 0.46071698984059817, 0.11353287233895937, 0.11823025085827943, 0.15900036236670023, 0.14409835030410578, 0.22103231395480338, 0.24382511319082312, 0.1502664895796617, 0.21176858463027193, 0.11424885923647232, 0.2554333071509435, 0.28022813329223417, 0.2807961135297351, 0.28877669640162307, 0.2843479873853578, 0.2972857347330713, 0.25843036362531924, 0.29417954760967746, 0.28931130943646444, 0.6705421760339538, 0.6674530659678193, 0.6764524424838116, 0.6798637668013303, 0.641336126305065, 0.6453919862504774, 0.6359163105065506, 0.6820933073107063, 0.6680376372359718, 0.12554853044225878, 0.1334465163002484, 0.12839040134152657, 0.1417124555971011, 0.15185875476327693, 0.11587488988086392, 0.09138157065089947, 0.1318449577091586, 0.12839738715572258, 0.17759308887059355, 0.37997675090011485, 0.18700433899735858, 0.2455411905295083, 0.2284304004247545, 0.306744895282707, 0.19559917745655064, 0.19107470955988148, 0.16762345273132528, 0.3844587240622245, 0.3893402034525235, 0.41781604117538085, 0.3653325807340432, 0.36838072658822374, 0.34194315800350505, 0.4098119207456019, 0.46101449704474895, 0.4227072712655997, 0.31408442821924, 0.3331773294343121, 0.3244431773784867, 0.2669157160453707, 0.3808197449716142, 0.32836196402926676, 0.3259421053064705, 0.3406099610237464, 0.3428564188958607, 0.19738507232449554, 0.22184624867250557, 0.2078631214858746, 0.1930017896298799, 0.23649073558018796, 0.21090946239613084, 0.2128165533416243, 0.1974451027320936, 0.20764864869273847, 0.22026039169848288, 0.20450210613274544, 0.33920402147687423, 0.19751834020684822, 0.5067533466478785, 0.33485300652095773, 0.20795028923494274, 0.2026664197374859, 0.23713710975173186, 0.1969164668024822, 0.18465174042075405, 0.1685666564611027, 0.18213284630214832, 0.17645808583208067, 0.2005716567385034, 0.8486202892920895, 0.1771360854222379, 0.16700490412690905, 0.20662193335874413, 0.8029884166661116, 0.8269289401772614, 0.21008049885804114, 0.16729095455284493, 0.16837985788788778, 0.2094617447524071, 0.8028683798593237, 0.21298589929978884, 0.18051076147692025, 0.21782371474680462, 0.18469869065038724, 0.18812419093247246, 0.19465089927654666, 0.20772241704100147, 0.18628177210167163, 0.18934402090316027, 0.18966712428580068, 0.0940476149108912, 0.08650880274128081, 0.08654293488803655, 0.1097786062162398, 0.09522483507366142, 0.09214128386978715, 0.11621319276375475, 0.09012139967401822, 0.09805627039519493]}, "mutation_prompt": null}
{"id": "92566029-5b10-436a-b922-8c7801f67f47", "solution": "import numpy as np\n\nclass AdaptiveHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Adjusted population size\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.15 * np.random.rand()  # Adjusted stochastic factor\n        self.simplex_size = dim + 2  # Adjusted simplex size\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with uniform spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.4 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(6, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Adjusted perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveHybridDE_NM_SLS", "description": "An adaptive metaheuristic combining Differential Evolution, Nelder-Mead, and stochastic refinement with probabilistic component adjustments.", "configspace": "", "generation": 50, "fitness": 0.41137105065828616, "feedback": "The algorithm AdaptiveHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7975514983168277, 0.7976343698226971, 0.7905562075916835, 0.8119052379567644, 0.8073720256997242, 0.80091787327413, 0.8049979291056348, 0.8031310172356294, 0.8084435645559948, 0.6276896415133943, 0.6190062561723384, 0.6447292987503912, 0.6207695837353451, 0.6298078118843105, 0.6304867373009031, 0.6152963946826082, 0.6426307103892271, 0.6343862736895338, 0.14884048024176977, 0.20072551191162447, 0.1566532989637106, 0.155630804500826, 0.13177191710517377, 0.17517698904368795, 0.19361330770528462, 0.14590089581068222, 0.13779886262262375, 0.13639197445329687, 0.13816959628353598, 0.12224005440394525, 0.10274452392898525, 0.11635530716140896, 0.14631283518245786, 0.10758061723703372, 0.13534070896708705, 0.12871468852600976, 0.9415718611766545, 0.9321200928275382, 0.9227805624067821, 0.9069968930259504, 0.9252301012585858, 0.93220608363046, 0.9084690838023765, 0.9305080214841913, 0.9205541360142255, 0.45035796223459856, 0.47373154659483785, 0.4590256453080426, 0.4836932483458709, 0.5244772855386404, 0.48964436462087424, 0.4624826983543401, 0.48443501262798905, 0.5057622358445586, 0.7955894971803925, 0.7893803555741862, 0.805198170642526, 0.8678988604058182, 0.7922930012173034, 0.8506215550507178, 0.8126895774078874, 0.7866084550980235, 0.7994547237120553, 0.37067696404640005, 0.4585505818983766, 0.22688379248983104, 0.37380183721061067, 0.33068019877361277, 0.35898721998660266, 0.3842343923458297, 0.12641103985537594, 0.34801884523726423, 0.24075246654124882, 0.4896796021881421, 0.3332464266507166, 0.39733981681838615, 0.311071839400337, 0.3389525229131305, 0.36489191006972255, 0.4402383774766878, 0.3124255218878492, 0.4189012453928369, 0.4560297632782445, 0.4877400049621894, 0.46220931390389497, 0.4750824101625324, 0.4066498037252272, 0.4400820785497924, 0.44875919625793437, 0.4824697359347131, 0.6220059777271019, 0.5959803821128138, 0.5704717045958219, 0.5545716731783763, 0.5333663280778541, 0.5964964794069592, 0.5670327430816142, 0.5834164658159562, 0.6067350183799975, 0.07906962929046435, 0.07401212073091223, 0.13455946866877344, 0.2961645550137092, 0.22103783566195356, 0.26057548364851235, 0.20529083160273598, 0.17265122503194508, 0.22418451010204254, 0.34728044971638283, 0.33620330614732974, 0.32765487916211034, 0.3686895872875575, 0.374818279590841, 0.34937827488911555, 0.3155518162300599, 0.3705863842393825, 0.3566272175971664, 0.716371080239314, 0.7109687553353476, 0.715845515789706, 0.724066040227851, 0.7299173830579414, 0.7423488448055544, 0.730734869216831, 0.727450778440383, 0.7248593747621375, 0.12839973555770956, 0.14437852721031463, 0.14991426124734986, 0.13184811010799535, 0.1298004797490805, 0.13668669043095083, 0.13415750024669038, 0.11858382492217712, 0.14698786806630326, 0.153904378746059, 0.14633232555684828, 0.4933258795496622, 0.170944845846846, 0.2616409393063769, 0.16013816399264647, 0.2415936527653214, 0.23295488949760124, 0.32633137849824856, 0.47985188181412974, 0.4822152410756857, 0.48116384617127683, 0.48156833464809057, 0.446772992065265, 0.49594566626993053, 0.41896511784193735, 0.4671850021413704, 0.5215042739671987, 0.386221717520182, 0.35860184780542936, 0.380111792001567, 0.20741310813875258, 0.4177283727409087, 0.3355622114739606, 0.383281550700329, 0.4060640608275027, 0.41402771086504975, 0.21086504872472933, 0.21834954605540613, 0.21582419496851468, 0.21716336101618638, 0.2189374856851961, 0.22344608162815083, 0.20161698283125729, 0.20163133807939593, 0.24050694268679662, 0.20598427521793927, 0.20179060014318828, 0.24005546668066147, 0.22104015026623935, 0.19386583407124158, 0.21515249594841912, 0.2091052065267165, 0.22240947329022231, 0.4632012218574846, 0.18716779998421385, 0.8618935531554953, 0.8834866855366842, 0.7014020814020185, 0.1635003325664084, 0.16430494368337933, 0.7715705557906765, 0.809640684637121, 0.7899346048606051, 0.20464414286515087, 0.20569011920996438, 0.20999448980219526, 0.8466932320266778, 0.16949447893515823, 0.7237102518363974, 0.20858118851262852, 0.7677513272719652, 0.20758607217176084, 0.1879928567975827, 0.1859248877158366, 0.20971949258043665, 0.1851645929871646, 0.21061231900059862, 0.20339269312869912, 0.20038414683695083, 0.17686985454480686, 0.19570699181297113, 0.09916362606969853, 0.09973181143613041, 0.09720849320674785, 0.09654729714834942, 0.09074660427078762, 0.09788411997381752, 0.08495753519379468, 0.09191881996500706, 0.09932235629567454]}, "mutation_prompt": null}
{"id": "c74cb008-3add-40fa-a907-ffe3f356f334", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "6c3521ed-67ae-42d1-975e-db40e2adba79", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly increased population size for diversity\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.4 + 0.2 * np.random.rand()  # Wider range for stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with randomized parameter F for each individual\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                F = 0.5 + np.random.rand() * 0.3  # Randomize F more aggressively\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search, with randomized control parameters for diverse optimization landscapes.", "configspace": "", "generation": 52, "fitness": 0.3929039270993002, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7665337358782862, 0.7604880518568693, 0.7729751527269703, 0.7942118406203572, 0.766154539022529, 0.7732349562985287, 0.7775032454451245, 0.7816622900538139, 0.7967665285270036, 0.5923434353886651, 0.5883519425918444, 0.5786612856087305, 0.5696903673685125, 0.5763963536777346, 0.6040984644418136, 0.5905820353205251, 0.5814931077959081, 0.579462495477906, 0.18106342299552758, 0.1819254100804254, 0.11681898310634187, 0.13933298701923325, 0.15329771861102437, 0.13395622758515313, 0.16666439255711063, 0.154772586914255, 0.177417218280168, 0.1152919313099674, 0.11670632923535362, 0.1429610261909, 0.1159244079509204, 0.1481067085987765, 0.12440213538918254, 0.10728186272949258, 0.12399917623918078, 0.12549237419703152, 0.9509267417863363, 0.9481692349750113, 0.9619004333488306, 0.9367052001142302, 0.9193081433404442, 0.9078246796593518, 0.863723827229038, 0.9177076500454997, 0.9349014573584439, 0.41393981665375745, 0.425786938848455, 0.4113889170201682, 0.43149786955936176, 0.39306235134877143, 0.43097593520490085, 0.4397100594325277, 0.4344458665097709, 0.4479548239202159, 0.8337293032786357, 0.7998570973418102, 0.7557258175636976, 0.7968784727984655, 0.8269277732334983, 0.858824312671327, 0.7803164179135296, 0.8033056173994954, 0.8151873060057251, 0.288103493372623, 0.4256122518295844, 0.34371586650109953, 0.13226033625200562, 0.35122570523769325, 0.3211281214141446, 0.3214205699128646, 0.40899641242082296, 0.264151744241107, 0.26325542343090624, 0.25276811991075254, 0.2655231682816218, 0.4735432583346394, 0.15550089739244954, 0.4089116620872931, 0.2896830266783652, 0.35352984225678796, 0.3513055877227592, 0.3597755513969131, 0.39624926220570655, 0.4071886846308168, 0.3485266216209689, 0.3796428040687869, 0.3813387181988446, 0.38658171159025256, 0.40495521816732705, 0.36530212925688055, 0.5319512147723215, 0.5454831938106242, 0.5578368862937749, 0.52293772544821, 0.5177633212382944, 0.5083714688607568, 0.5635158746580402, 0.5605216913772548, 0.576140470445317, 0.19235175604076338, 0.0912242308197021, 0.1233941667203855, 0.23657104425284559, 0.25564405024744463, 0.1519376280432172, 0.17496776707324047, 0.1282157707326489, 0.19078021428784453, 0.28562407598041906, 0.2886007265267514, 0.29608149487855895, 0.31052745137347515, 0.3183624715565364, 0.3408116359299511, 0.28432006425006207, 0.3341798587648025, 0.30908884474484843, 0.6858844596599727, 0.6892045489212086, 0.707655528339392, 0.6754088890761175, 0.6721246555320471, 0.6556880559045972, 0.682549258942207, 0.6628233372404148, 0.6650371297768842, 0.11556457962940425, 0.13404069136736907, 0.12076526095803142, 0.12244476620107902, 0.16181834898153225, 0.15123500533571732, 0.1396140647836953, 0.13385171248521566, 0.11256664901104163, 0.3203510672927359, 0.1722395714873004, 0.14695964515464455, 0.2416023844334293, 0.1678528641352326, 0.2327585251519273, 0.19060920774652523, 0.26538283367701165, 0.20971630964610144, 0.4051786727222818, 0.4233929492131857, 0.3965864958365052, 0.4461104081650388, 0.4134741225813663, 0.4203891470209724, 0.4272354681906293, 0.43069833351772024, 0.4393889162332867, 0.3125702729676797, 0.3204363475357134, 0.3009558741447117, 0.2956650701200215, 0.3725907098634327, 0.28815290182940867, 0.35783260069932354, 0.33505783732287264, 0.30010764952391544, 0.22408525692159686, 0.2253296099978822, 0.23369169356509578, 0.24601762199553823, 0.22712497323960823, 0.2212178757800214, 0.23278746805805273, 0.19654391433355345, 0.22019071300304893, 0.3368937481762341, 0.21042739470573757, 0.19105907481089623, 0.3590613396879415, 0.4113358290825747, 0.20810412818452773, 0.21248974305072965, 0.19005299473512594, 0.2829591045829096, 0.1640156470297197, 0.8684416976048586, 0.18723361758007973, 0.1967569567960803, 0.8143046273629391, 0.8068449456476274, 0.8017417882508643, 0.8628597733308414, 0.8050743725856022, 0.12704407692823771, 0.16730258083242555, 0.20806825761799108, 0.819875960224631, 0.7903306283422843, 0.1688396909167419, 0.20583825474904682, 0.6767199611306249, 0.7071319103180753, 0.1999059797152103, 0.20081918639448904, 0.1930914499248385, 0.1799272360833407, 0.1962683332017937, 0.1917080556191526, 0.18533467582012353, 0.19191221910533196, 0.19250275376903625, 0.10583016911562604, 0.08897141337525827, 0.08750044233787302, 0.09903386566407513, 0.10231593433020558, 0.0931142103657594, 0.09325445867881588, 0.10940310503127149, 0.1128763262034227]}, "mutation_prompt": null}
{"id": "e3d25a3a-4193-43d0-a2e3-811735274ae6", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population for better diversity\n        self.de_cross_over_rate = 0.85  # Adjusted for balance between exploration and exploitation\n        self.de_f = 0.6 + 0.2 * np.random.rand()  # Broadened range for adaptive DE factor\n        self.simplex_size = dim + 2  # Enhanced robustness with a larger simplex\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Dynamic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Slightly increased perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_V2", "description": "A novel adaptive hybrid algorithm that blends Differential Evolution, Nelder-Mead, and dynamic local search for robust optimization performance.", "configspace": "", "generation": 53, "fitness": 0.36645372443242824, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7591891502615636, 0.7647919416060633, 0.7685135484715541, 0.765501413735752, 0.7564638675196936, 0.7556442092576837, 0.7524759839531805, 0.7649906855542077, 0.7584234861757735, 0.5586796541680077, 0.5561571526401725, 0.56717211493681, 0.5375398452383271, 0.5572027800174175, 0.5290420791107265, 0.5290422117848359, 0.5531227214739438, 0.54783576137488, 0.13044154951057318, 0.12635045085287844, 0.16213626992814767, 0.1425877439207941, 0.14270727929346683, 0.1279577295076415, 0.32156631291839943, 0.3527940613637154, 0.15593849170180896, 0.12349624287996686, 0.11383650607445939, 0.10855745923200921, 0.12544962816438743, 0.11839891385614842, 0.1076041871927571, 0.12363046135430722, 0.126752615892197, 0.1263684130933449, 0.9330247146873566, 0.9671553373906717, 0.9363442919596292, 0.9220182948340716, 0.9564959652470225, 0.9224919880693414, 0.894788925807525, 0.9686204371363623, 0.9286868003724293, 0.38512816386611426, 0.3759979454977862, 0.38597123649484666, 0.3862843307401196, 0.3912673494729675, 0.39346068469831885, 0.43073924619290394, 0.38316217765141314, 0.3344605346835112, 0.6800003132815383, 0.6539012549277152, 0.7087451867975392, 0.6834140733793588, 0.7644755675245093, 0.7024042344931798, 0.7097194662770867, 0.8239297476215088, 0.8361761404692483, 0.342755195635573, 0.29238863776173474, 0.23488156189389997, 0.2684553166628393, 0.3706856485366202, 0.29556276445899243, 0.2798683489009345, 0.26439519903461883, 0.29086138521291394, 0.1555036475631527, 0.1870456191709985, 0.263881453557696, 0.20711768783293438, 0.2704825395764273, 0.21274913776842108, 0.12677919988077668, 0.3533581412056268, 0.2772972384647554, 0.2656462110445498, 0.23611197113098525, 0.2167139917910852, 0.24765461511778997, 0.2974914938564769, 0.3028120956594734, 0.3014777649079773, 0.25376509805230585, 0.2624475589637085, 0.37265709644381706, 0.4260767168303152, 0.41535778966936, 0.39367131843966585, 0.38771467032453377, 0.39719323355761804, 0.41373967651404353, 0.42453445576333304, 0.4283863821191425, 0.09379746902512998, 0.10549131935441525, 0.1258553492913801, 0.12260569757450634, 0.1905644057221767, 0.20499118244384185, 0.19094302850927192, 0.14869466236296214, 0.11868667586529213, 0.24355585432458526, 0.250251126322925, 0.23997528616936292, 0.2678640052358202, 0.2544313807176388, 0.26027744157381316, 0.23277212474759112, 0.25109713204009154, 0.2430928467176926, 0.6317321732794087, 0.6558763303447278, 0.6409103973804093, 0.6306278022625929, 0.6288383920252465, 0.6360350810016124, 0.6106570160840583, 0.6555669461647409, 0.6071281199586761, 0.1509933426017267, 0.426082669649114, 0.10589319116003948, 0.1396528363499112, 0.11743711141153967, 0.11861479267989361, 0.12278320340851256, 0.1308517534796767, 0.11426513482953682, 0.3024247247642947, 0.19605511386084473, 0.37642726525128245, 0.15303537819399737, 0.20020915875853396, 0.28109574447654284, 0.30335701942394333, 0.23726364660010957, 0.2456007651175497, 0.36117516531983684, 0.3738325289049156, 0.38169843590612473, 0.3892329336111975, 0.388840289641163, 0.37767848323112707, 0.40853860985810697, 0.4053122146123177, 0.4255773414093498, 0.3242341705505609, 0.2883860718900232, 0.32901553383633964, 0.25598555110217935, 0.30533210926128673, 0.3162696546388337, 0.30343196781519577, 0.3046715695274783, 0.35196306986358195, 0.20493699528117548, 0.21356299156127, 0.22972771431898653, 0.2062448622912353, 0.21267164808124683, 0.2184646232089944, 0.18791090546485234, 0.2198081781137009, 0.19279380799492796, 0.23398715910297518, 0.2289621472450123, 0.41655243975281353, 0.2580318962735041, 0.2262805753377537, 0.19261858695808287, 0.3275898630943641, 0.29522235653333795, 0.22232671233429613, 0.17633184033147664, 0.19874777972187896, 0.7367111621739233, 0.8098836319421479, 0.7707839083629288, 0.7760462991182271, 0.15493832279919628, 0.7812241805883513, 0.8253093785710405, 0.6867704480139871, 0.16489928687075828, 0.20939830125732095, 0.606221984433386, 0.5929691919741209, 0.21052608312030474, 0.20781951888888706, 0.6667868928510501, 0.6791462468486187, 0.20325031917968683, 0.20701760833636773, 0.18006765298896676, 0.20719967259525385, 0.19229371728031985, 0.199841025902612, 0.18862757290221366, 0.20117331714986308, 0.2094648042328009, 0.09960989071403126, 0.09223853602345622, 0.09739828089722358, 0.09249345061303771, 0.08537846963610429, 0.09564291359562027, 0.10751093747169871, 0.09402353735686608, 0.08827885331885099]}, "mutation_prompt": null}
{"id": "62560b5f-20cb-44f4-a475-8308ce8f9c06", "solution": "import numpy as np\n\nclass AMES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.6  # Adjusted for diversity\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(6, self.population_size)):  # Increased focus on local refinement\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)  # Adjusted for finer tuning\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AMES", "description": "Adaptive Multimodal Exploration with Differential Evolution and Stochastic Optimizations (AMES).", "configspace": "", "generation": 54, "fitness": 0.4410508559960707, "feedback": "The algorithm AMES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8335745789690615, 0.8295075762106144, 0.8306549068128504, 0.8390275208098974, 0.821528343550116, 0.8334596329526464, 0.8329136191161447, 0.8184946928217656, 0.8258064956392128, 0.6715882521322789, 0.6776321010160056, 0.686463051768742, 0.6701524448932097, 0.6871163418423165, 0.688679268253018, 0.6835697338653851, 0.6907638156618865, 0.6791348660218317, 0.13467582613042595, 0.1542350797750649, 0.4032844098293987, 0.5365447103738613, 0.14751858060732703, 0.4397800283064114, 0.1133835581100675, 0.17472689897022187, 0.14217219313348728, 0.13034433836525827, 0.09400392718931216, 0.1118872105314076, 0.10971390220738464, 0.13792132148397596, 0.12500459540521247, 0.12260704976166492, 0.11604675742215897, 0.1374956161253693, 0.9157355340567712, 0.9052646450316648, 0.9424001707257235, 0.9394068508208034, 0.9302096299337077, 0.9371444354222883, 0.9292849483233748, 0.9538714579490464, 0.9857818551724663, 0.5203492899144374, 0.5725817423063828, 0.5357301590660337, 0.5343325307130853, 0.5608457007686405, 0.560616742186685, 0.5277327983295316, 0.520389071019379, 0.5592760277293317, 0.8336850293723468, 0.8676282704859246, 0.8376229185391155, 0.7813012171606128, 0.8520680788960121, 0.8607321005333559, 0.48229097091780293, 0.8518801082835507, 0.8512831643131447, 0.6347999078538702, 0.418167418987755, 0.554947993909914, 0.4633530630210426, 0.47099699006439755, 0.5209157779212501, 0.21156539091343218, 0.5090870470102544, 0.44548528360601647, 0.4649382352068906, 0.5108042434963087, 0.5493514847685836, 0.3710306497659741, 0.4630813083926263, 0.5766680029929607, 0.12570569928835507, 0.41118038579491567, 0.5813351324719211, 0.5368160651947842, 0.5209694912767493, 0.5326874421035025, 0.5272244026896253, 0.5686200468559022, 0.5460899800468868, 0.5205848275437568, 0.5381617552751312, 0.5304395303102072, 0.6666774902514282, 0.649613595427408, 0.673925093131648, 0.5962069427139955, 0.6161284941163327, 0.6354496269311519, 0.6409508383381294, 0.7058288242550204, 0.6448351939664833, 0.18059465895078852, 0.2585449608442253, 0.10115838916603459, 0.310552571739084, 0.20499556155425802, 0.3802717564798781, 0.18531509216628994, 0.18620268292874198, 0.2924406387305313, 0.41131057778937263, 0.42179289174856327, 0.419076412411296, 0.4069927314028853, 0.42267314157965197, 0.4224339964661422, 0.39168790384082697, 0.42357619144024816, 0.4312943340648212, 0.7467869768360157, 0.7824688785654837, 0.7684018114602003, 0.754807456590051, 0.7727886199569103, 0.7431618005883254, 0.7473778087645395, 0.758863624053218, 0.7875327928130453, 0.15305011424378223, 0.17958448458164422, 0.14034962050121325, 0.14691058313906702, 0.5891020412242967, 0.11253773338945683, 0.1165237656129331, 0.13019744397544875, 0.14664679899404942, 0.19512046582314602, 0.24192872771390517, 0.15956954362636844, 0.1889740030347865, 0.19608286337049485, 0.20329148427827481, 0.2097284135435885, 0.5544616803986685, 0.19563433021794496, 0.4786635686873164, 0.5291509322505838, 0.4609792808189227, 0.49314108005124435, 0.5305842088790997, 0.5013368608079642, 0.5334704912448585, 0.5144208938766834, 0.5321051125866579, 0.30152564606110455, 0.4225819882498406, 0.4781912689929214, 0.35413446526393944, 0.4429741097642921, 0.42384473824342817, 0.42240868075415006, 0.4327620651215889, 0.44729837605095757, 0.21840551940512998, 0.1998206276616884, 0.22124587491441383, 0.24616936228749575, 0.2262553030341069, 0.2132718064064396, 0.22275410244403004, 0.22263708093262002, 0.23428186680188845, 0.19953638216121727, 0.23402804690661505, 0.19486123792043042, 0.22892897392696787, 0.2325469792064886, 0.19013748942065367, 0.1880348409739595, 0.21823664366900963, 0.20343875667642675, 0.1904762131402511, 0.88635401128563, 0.16607319336062232, 0.18665615480661013, 0.20067722031883795, 0.8810847257273727, 0.20021846991471537, 0.18535900125716775, 0.8719462102836224, 0.8354125345468977, 0.15617262001178367, 0.8168530137954894, 0.8290485946257735, 0.16810310087201363, 0.20630833876320176, 0.16790943059889107, 0.20976121813370274, 0.21026992432744807, 0.20240901015044344, 0.25114241126163095, 0.1936386584100902, 0.20271801805960088, 0.19656563077039713, 0.1867873461580738, 0.1965430931816866, 0.2029165121763249, 0.20091972919542422, 0.10171374392966992, 0.10122301808840128, 0.10505695711125429, 0.09867440929007776, 0.08477062171664129, 0.1013671523403773, 0.09565841375956097, 0.1057118110657832, 0.0880390097293362]}, "mutation_prompt": null}
{"id": "cd1388fa-ae13-41ab-b7ad-1f13e7f2c144", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "789b2f88-416d-4720-87e6-2d822bbb1860", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SA_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n        self.initial_temperature = 1.0\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Simulated Annealing inspired stochastic local search refinement\n            temperature = self.initial_temperature * (1 - budget_used / self.budget)\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i] or np.exp((fitness[i] - candidate_fitness) / temperature) > np.random.rand():\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SA_SLS", "description": "A novel multi-strategy optimizer merging Adaptive Differential Evolution, Nelder-Mead, simulated annealing, and stochastic local search for versatile optimization.", "configspace": "", "generation": 56, "fitness": 0.4005592774040873, "feedback": "The algorithm EnhancedHybridDE_NM_SA_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.23.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.5100407308348045, 0.49401455582807574, 0.5180862952328331, 0.5140390996195718, 0.5022972645324713, 0.5239498470311093, 0.49724323670701875, 0.4971609307402669, 0.5400682722851964, 0.7094625099861864, 0.7226897878430159, 0.7329198093680268, 0.7049716958792815, 0.7291075265037255, 0.7329572614006701, 0.7100170583204537, 0.7366819694945506, 0.7088857556507975, 0.14658262631707908, 0.15896375300874677, 0.16197922823256738, 0.18020270639068092, 0.14190772461667545, 0.1481727988296263, 0.5438349823468406, 0.1635917999584996, 0.1321235943489053, 0.1317647775499261, 0.13103820566761293, 0.1231344508267268, 0.10222038519396681, 0.10207313484922287, 0.16621444281662368, 0.1325912208697837, 0.11077556812308376, 0.12392026361134789, 0.9597501596499738, 0.9358332683769572, 0.8975481286722038, 0.8928464703414976, 0.856055688478708, 0.8957329865722707, 0.884468729376694, 0.8977932327568853, 0.9410671941128281, 0.5807261454116579, 0.5621398375868997, 0.5766926535727368, 0.5492760367803765, 0.5734773367634657, 0.5606306887826895, 0.5702983821886366, 0.519524153455076, 0.5815953142705743, 0.8034847746021418, 0.821577702105574, 0.844791972887647, 0.7845498880765532, 0.8576617960723637, 0.8143545205590894, 0.8034847455310745, 0.7818443339637835, 0.8246260911858596, 0.41681241499921184, 0.42998791817384663, 0.12783529217304002, 0.31243230103609354, 0.6035608760625781, 0.40269346827024033, 0.48596316525728167, 0.27944628698802443, 0.5960396730144664, 0.22084642423629808, 0.1945574559343295, 0.35914279673718474, 0.5932221966356512, 0.5427481854480758, 0.630993264636261, 0.511070209741282, 0.45099647254583874, 0.486676920364281, 0.5737819287844967, 0.5227201633013688, 0.5834069740281802, 0.414859048048313, 0.5847265911190966, 0.6021270545782749, 0.5834295362916333, 0.5843180697814689, 0.6131809331241, 0.6608203730533798, 0.6966020026346633, 0.7165728697298145, 0.6728180447727199, 0.6469750996284629, 0.6749038890013279, 0.673527296960129, 0.7002154222189346, 0.7283955039056871, 0.3742605825526042, 0.12848024053917906, 0.18936722984720122, 0.16506474379489378, 0.23961387475930096, 0.37622196493213, 0.28352616852284374, 0.17335193501372304, 0.17551639603920444, 0.42725375901091034, 0.4861633434146223, 0.4544892817769485, 0.4479401342482837, 0.49756284977328846, 0.5091801199037362, 0.43846630783077334, 0.4949219412083796, 0.49165340020667003, 0.4231840706684248, 0.4622232021377406, 0.4387383560540067, 0.44254522396520946, 0.4288748534370692, 0.45172775561088196, 0.4353543654244749, 0.4605815276981805, 0.44897801508980806, 0.11894384197050656, 0.1537250460371179, 0.13783203060776994, 0.1285310165039173, 0.1431401084121975, 0.16428042871965898, 0.14677005769995832, 0.12146027103336199, 0.1360482320917774, 0.21718815377948664, 0.15925460483994625, 0.21362657842104527, 0.36617966857592044, 0.21349086474718082, 0.43008229298588085, 0.19978935346710558, 0.1862546372946695, 0.18993795441817518, 0.36163403234793545, 0.37521338913031, 0.386717496069205, 0.3520436583278487, 0.37018210196739987, 0.359014908268504, 0.368301726117615, 0.38031448689023983, 0.391599983689527, 0.3727774547217517, 0.43100452026629577, 0.386037351171847, 0.41207754884789416, 0.453468893595277, 0.44783509507418107, 0.40558505018228175, 0.42812491465124014, 0.4128204392382189, 0.19841259079934903, 0.21533098285771923, 0.25162535256774365, 0.2411945308001493, 0.22180652400685275, 0.2728554965303067, 0.21243327801894052, 0.21534771760379512, 0.23763367294346371, 0.21087684236176862, 0.20608796630143011, 0.20776416837370248, 0.4755774705858169, 0.1952569472191391, 0.20767649766931018, 0.21738963921367527, 0.18966406660151547, 0.22423169564131828, 0.1833843180644863, 0.19598541641319378, 0.15797771988447473, 0.15729296138649151, 0.7224188189523383, 0.16873237630871207, 0.16202517130908634, 0.6890088160842711, 0.6843696351714477, 0.2102359041079903, 0.20885353016577624, 0.16736234410652395, 0.2085630649594875, 0.6174569791496962, 0.16808390374879267, 0.20899369762398812, 0.2100381229359316, 0.21205552005003592, 0.22139789785918362, 0.18498399769841967, 0.1947008412086525, 0.20727506828525266, 0.19396075600254203, 0.19953563760874515, 0.19743071020789726, 0.22526244327969636, 0.2004954888070719, 0.08084309966061431, 0.09215451311368839, 0.09665068615784911, 0.0823120846379406, 0.09819524931560264, 0.08825344904728116, 0.1306837572329943, 0.09772532561755598, 0.0924857112331956]}, "mutation_prompt": null}
{"id": "831d6c92-c027-4bf5-ad51-819c884cfb4c", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.15 * np.random.rand()  # Slightly increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a diverse spread using Sobol sequence for quasi-random distribution\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic crossover rate adjustment\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < (self.de_cross_over_rate + 0.1 * (1 - (fitness[i] / fitness[0])))\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step with scaled movement for poor solutions\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.7 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with enhanced perturbation based on fitness\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05 * (fitness[i] / fitness[0]), self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_V2", "description": "A robust hybrid algorithm combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with enhanced parameter adaptation and diversity mechanisms.", "configspace": "", "generation": 57, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {}, "mutation_prompt": null}
{"id": "9bda9bc7-c33c-4a4d-a0ab-e454cd114e70", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 6 * dim  # Slight reduction for efficiency\n        self.de_cross_over_rate = 0.85  # Slight adjustment for exploration\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Adjusted for diversity\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Enhanced reflection\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.8 * (centroid - worst), self.lower_bound, self.upper_bound)  # Enhanced expansion\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Enhanced contraction\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(7, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Enhanced local search\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_V2", "description": "A hybrid optimization algorithm combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search with enhanced parameter tuning and convergence strategies.", "configspace": "", "generation": 58, "fitness": 0.4437282480879485, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8523433397454607, 0.8419537495512167, 0.8575838858253777, 0.8368367014910607, 0.8523708280040343, 0.8384599648766425, 0.8432135644486843, 0.8479276902777166, 0.8579333724904684, 0.7327774881209377, 0.7231743404319825, 0.7379292901091055, 0.7159631422370765, 0.7082573642596939, 0.7348747829749591, 0.7113407207374794, 0.6871637602143075, 0.6958211141071329, 0.1637042842041454, 0.1669871379588742, 0.13809417114414246, 0.18609891562408043, 0.14583135358960664, 0.18231778935741338, 0.48991267439509767, 0.14650677974448667, 0.17002313822251303, 0.11860620425297907, 0.11972574273900649, 0.11212952997135273, 0.14299354304194423, 0.15012341712297916, 0.13971450190700685, 0.14192431670234906, 0.12527260411988295, 0.11257720238591296, 0.9612186976848623, 0.9611065625160672, 0.9353549466975747, 0.9557954241039923, 0.9169955207308903, 0.9278158200937685, 0.9503773181837135, 0.9626352893998578, 0.9509742823577308, 0.5975257879597764, 0.5734377957623404, 0.5901095180616446, 0.5789149236593494, 0.6059923422245335, 0.6177425815073676, 0.5939306957625751, 0.5633069258643006, 0.6177616753595799, 0.8378225915680028, 0.8777516338180952, 0.8574610686033555, 0.836078938366131, 0.7948236922376657, 0.8773369664039877, 0.863185422809189, 0.8674718782090565, 0.8589134014663027, 0.4496768837890842, 0.5151730190512577, 0.3821969923193428, 0.3422383462638534, 0.5189691743013733, 0.4750083714584352, 0.4285553987279782, 0.6574592172357947, 0.33298115587905, 0.5417568026906261, 0.27528000367423233, 0.4268314786197349, 0.5410827918500283, 0.42910970814273597, 0.5180196027967559, 0.31191415353144025, 0.6225457305454168, 0.13031435417219273, 0.5343363301516888, 0.5316840190336846, 0.5433778503324291, 0.46743160342032974, 0.5384368146309849, 0.5431457350565929, 0.5046820384959032, 0.5479386753125045, 0.5001492967435164, 0.6586412005201709, 0.6481564916756668, 0.6150349543422765, 0.6140015385580935, 0.6144429494212589, 0.6401393750904303, 0.6671038115036854, 0.6442989851347722, 0.6795448914185823, 0.08211332614801226, 0.30454812789293095, 0.10938071475699596, 0.35887927331123903, 0.27658169401247246, 0.2703857718211252, 0.15803816133553716, 0.3240667779596397, 0.2336148397864275, 0.3657977940769668, 0.41289576125964844, 0.42270353079722045, 0.44914569681837235, 0.44051347660145135, 0.4126928100345265, 0.4116565432885154, 0.41141727820131113, 0.3770890546368406, 0.7765477169732639, 0.7401371248328017, 0.7883417272462356, 0.7497449369165101, 0.7747737014381866, 0.7758965557127417, 0.7620587355822549, 0.7704480971840069, 0.7718540637506628, 0.1191443904812679, 0.14947780032215563, 0.13037835892730232, 0.14211882586950508, 0.13625951591265262, 0.15715135250479884, 0.14009722322525398, 0.15314625187869202, 0.15146730158074773, 0.22656586306434923, 0.20054097814432925, 0.5102518675462553, 0.37511727251804816, 0.18191235059444966, 0.3032926044171509, 0.1949431374861097, 0.20116989297543908, 0.22285502472657848, 0.3881564055022375, 0.6384977166592183, 0.568787069527138, 0.6030626078552981, 0.4666937847633932, 0.5813040894961428, 0.46544257025205216, 0.5298334647571077, 0.5219814350994962, 0.3813978735019137, 0.27447185950512976, 0.29791470397324293, 0.4907197080740393, 0.40580426078109266, 0.2663194796568443, 0.5127632932831833, 0.3806460685040096, 0.4512170480541726, 0.21928862360959744, 0.19895385404233878, 0.21247634778647695, 0.19819238615697454, 0.21956403646112488, 0.21634607802413586, 0.2404049760855722, 0.2617334789921255, 0.20918211780071028, 0.21937765289966993, 0.2053865559902439, 0.2200680351018267, 0.6160601429328187, 0.18960702080140146, 0.6838735378690436, 0.2109320609221783, 0.2141364732346256, 0.16963612725480326, 0.8795369821963572, 0.18718358868249063, 0.18722706610331719, 0.1708055560853996, 0.21139589754672705, 0.15327486669448975, 0.17444235159970356, 0.17533674016390488, 0.8772351399053376, 0.15397362021399863, 0.20911564391749382, 0.21240293251320985, 0.1680150672210846, 0.168376287261789, 0.8826045461100143, 0.21273162965530545, 0.859715481632726, 0.8617805237015302, 0.20147821219020723, 0.19381456668733255, 0.20011402303684223, 0.2376084802104097, 0.22773244339187715, 0.19166407091272142, 0.21069337477640993, 0.20999369997181272, 0.19289621968934534, 0.10277074846621603, 0.10167761003909492, 0.08570414533109016, 0.10762708770732721, 0.10833355877506223, 0.09051505368568125, 0.10714951301820108, 0.12708223148798858, 0.09387652296127347]}, "mutation_prompt": null}
{"id": "b6666589-22ce-4bfe-b26c-5d2991f1a0a4", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly increased population size for diversity\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive DE with dynamic F adjustment\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                self.de_f = 0.5 + (0.2 * (fitness[i] - fitness[0]) / (fitness[-1] - fitness[0] + 1e-9))\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Enhanced Nelder-Mead Simplex step\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search with adaptive perturbation\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05 + 0.05 * (fitness[i] - fitness[0]) / (fitness[-1] - fitness[0] + 1e-9), self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_V2", "description": "A hybrid metaheuristic integrating dynamic parameter tuning in adaptive DE, enhanced Nelder-Mead, and stochastic local search for improved exploration and exploitation.", "configspace": "", "generation": 59, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {}, "mutation_prompt": null}
{"id": "4c02948c-3ae7-480e-9ae8-3e5503e4b63d", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.6 + 0.05 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with uniform distribution for better coverage\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.uniform(size=(self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic mutation factor\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step with adaptive reflection\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.3 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.4 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search with varied perturbation\n            for i in range(min(6, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined hybrid algorithm leveraging Adaptive Differential Evolution, dynamic Nelder-Mead, and variable stochastic local search for enhanced global and local exploration.", "configspace": "", "generation": 60, "fitness": 0.381316613380456, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8041814006077418, 0.8028919311962849, 0.7824896930400831, 0.8133202920427054, 0.8007887001544396, 0.7930027223144076, 0.7968714696404647, 0.7940237035080977, 0.805765369985393, 0.5968696055766107, 0.6066803966296046, 0.598734561696723, 0.5948282941575807, 0.5842801504322248, 0.6286753388477202, 0.6077658583461292, 0.6134238387617024, 0.6071143272530859, 0.17025564697476292, 0.12743965891452558, 0.1789624541112269, 0.19496986173311903, 0.12909471349696267, 0.15075713527325008, 0.11652625064964417, 0.18727669014173776, 0.19342312176490062, 0.10266559285312271, 0.10554135342853965, 0.13948822089446788, 0.11958423997055267, 0.13900768684241716, 0.12005917102956865, 0.117893113794449, 0.13412905476664183, 0.11815725055453763, 0.9498186352695538, 0.9192770515562685, 0.9242857533811967, 0.9635791045750012, 0.9311890245751367, 0.9348436995540911, 0.9025466119500714, 0.9526045891744538, 0.936879536127297, 0.3850527799784782, 0.41729951525941655, 0.41730960094235636, 0.4346811621504325, 0.41001298831292166, 0.4619822987747454, 0.43889512714515744, 0.4094946120733365, 0.4064411724165212, 0.762976480219849, 0.7286792388491583, 0.7418280744640342, 0.7490272427713747, 0.8861412085194325, 0.7577375111657307, 0.7475804206998964, 0.7649016345340554, 0.7590500788056708, 0.3581858642713881, 0.23963283143160707, 0.443653664396087, 0.29210116279729925, 0.20433444652807597, 0.22052652322833932, 0.352761561851079, 0.2757014650805981, 0.26679533254900567, 0.3818263856873395, 0.3124330318709343, 0.30289761294654793, 0.23352928685462215, 0.2835079353711071, 0.25592163500897547, 0.3000297755690675, 0.3046874258995764, 0.2533729013812084, 0.34819829538311686, 0.2721229744693535, 0.2932281756733892, 0.30136701407565125, 0.3036584216920265, 0.330245945990007, 0.31232345682458285, 0.27528588228438444, 0.3947604683183299, 0.3898822219345838, 0.4530638056758688, 0.47210067480779494, 0.39791905359020496, 0.40846354266842133, 0.46752817590191, 0.4165618735258627, 0.4466661092400548, 0.5275265668824616, 0.10344932732652157, 0.1264958166993032, 0.1366453997905961, 0.1941598865491152, 0.20188801207332419, 0.20629532690758512, 0.1486495328145545, 0.17929702933874814, 0.20831438148333214, 0.2916878289771814, 0.2541275915910154, 0.24231002829222759, 0.2874253748563439, 0.283171448933488, 0.27647640508351656, 0.26739133539226745, 0.27933155111548424, 0.2950479304387317, 0.6747382440790956, 0.6548591244930086, 0.6839008384968901, 0.6593844978243383, 0.6458396820448146, 0.6924178516378596, 0.6917900235863561, 0.6946115038797415, 0.682933095132005, 0.13168878284172825, 0.16137166252498958, 0.14417714602589404, 0.13880502533044514, 0.11430063162587689, 0.14819024216912058, 0.1438775634527132, 0.11705499953834209, 0.14999938989642236, 0.1887757128737445, 0.17975490518074855, 0.5750298932810984, 0.1442161727200013, 0.21791767101109127, 0.2528383118658576, 0.14730316293474788, 0.1682945176443662, 0.16105615142468743, 0.3821804244480662, 0.4119825305063992, 0.3989987530700744, 0.3894111620847721, 0.3964094994778211, 0.40946005022225407, 0.4453531676897835, 0.4282675102764797, 0.3964847288600133, 0.29582394206959217, 0.3205369698866163, 0.29100425038702027, 0.29157463130576045, 0.2861872133766675, 0.277607400746979, 0.3467166367736656, 0.31286286584431433, 0.31703510280569236, 0.24781510678482965, 0.20857779647659114, 0.21122808735944798, 0.2349253234491807, 0.1915773612934869, 0.20062561299483983, 0.22920012677122314, 0.2300786338215569, 0.2367045768179853, 0.20825024150412597, 0.20871382096649882, 0.3561881532538087, 0.2175901921840333, 0.41589390321423925, 0.22341932460263259, 0.29067885844186925, 0.30293642218495775, 0.2192702518379821, 0.8399440595965415, 0.1996417161823607, 0.7964735620587127, 0.18592609355513146, 0.8345816801003316, 0.7866205548588061, 0.16492701446135927, 0.5744067250920389, 0.8534378144237623, 0.8831075848855474, 0.2094500091713336, 0.21008142205353264, 0.16572095600320647, 0.16950048764786496, 0.16838802354424953, 0.7675022017946371, 0.6899194401237461, 0.7448023958068983, 0.2053821438035568, 0.20378562733588834, 0.1966837475423524, 0.19913732709639598, 0.19242302071933415, 0.18863502186859638, 0.2031204409196401, 0.19290951194896622, 0.18004952163915078, 0.09636334749193609, 0.09977649639006358, 0.0796753780932955, 0.08769773067154385, 0.09799404561754077, 0.08276404969267992, 0.0921650796100485, 0.08944425559900315, 0.08923283151593076]}, "mutation_prompt": null}
{"id": "666a775a-188d-40a5-b37c-d443076a2c9b", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly larger population for diversity\n        self.de_cross_over_rate = 0.85  # Slightly lower rate for diversity\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Adjusted stochastic factor\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.7 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted reflection coefficient\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.7 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted expansion coefficient\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted contraction coefficient\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.45 * (population[j] - population[0])  # Adjusted shrinkage coefficient\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(7, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Adjusted perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An adaptive multi-strategy algorithm incorporating a synergy of Differential Evolution, Nelder-Mead simplex, and stochastic local search with guided diversity.", "configspace": "", "generation": 61, "fitness": 0.35106665960373673, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7568266728053759, 0.7364464952328744, 0.755240939245067, 0.7591918017599429, 0.7780493620735394, 0.7595223880485287, 0.7674469895506576, 0.7491622622179923, 0.7742239259313433, 0.5388651062657247, 0.5519397175399823, 0.5750458936755871, 0.5638535713912882, 0.5529221536676031, 0.5699869843516623, 0.5593961728779635, 0.5558902964519292, 0.5237652747585599, 0.17757552566423151, 0.1330164819827676, 0.15880768104819798, 0.18415097738117026, 0.1569573109827176, 0.3270617362133633, 0.137920558650509, 0.14090899812865976, 0.14744131983952902, 0.1331893562898323, 0.10448865241622951, 0.10813757490992315, 0.1399407478132365, 0.1263436138025681, 0.11450191953374089, 0.1221337415327518, 0.11191142089848438, 0.13790929560283216, 0.9180157041998745, 0.9348550018403596, 0.9528242809780915, 0.9465467932306035, 0.947588950192545, 0.9486761910408134, 0.9458214346219822, 0.9466168960182266, 0.9294145724705762, 0.38948686942809996, 0.3797333598513055, 0.39107833426439864, 0.3957745039646492, 0.3871778983031643, 0.3949284387751545, 0.40196825855407436, 0.38498632528613885, 0.4101098198910331, 0.7178789290129683, 0.7592974915900654, 0.7150862231763193, 0.7432243994488013, 0.6777942808612065, 0.8253861750243937, 0.7013837538076151, 0.7975954614944039, 0.7544556026792476, 0.20772035447987047, 0.2158470443741788, 0.29775843277450753, 0.2896350191699144, 0.2059156759406484, 0.2597838772825589, 0.29323122927768486, 0.2640968206534855, 0.4209315816137601, 0.18684366895913807, 0.24651666585173748, 0.20732889340499328, 0.3230920428731039, 0.23043020141072246, 0.3714087618867311, 0.18639505588803584, 0.15649905884691329, 0.3458412695670732, 0.2467601646793015, 0.24960458497702653, 0.2467966226833027, 0.2835877760725459, 0.23832828433592435, 0.2788743203172478, 0.2621603759469028, 0.2625575577741134, 0.27825103009112606, 0.37867320157308204, 0.39735475043806157, 0.4342493334081552, 0.353702755134357, 0.345339442714213, 0.44802778029297896, 0.4380174729686924, 0.4047383511177549, 0.46167340520143874, 0.09915931944561196, 0.051131808293385816, 0.11581444408440766, 0.11354358816253585, 0.1073098716755223, 0.13802897275903492, 0.15390221551554983, 0.10913659540215226, 0.17538592905984696, 0.24419248700368412, 0.23054389429098288, 0.2535058032075721, 0.25454304382127835, 0.26474919759855287, 0.26498564617291376, 0.21983762857859912, 0.2500387206722329, 0.24908322879989686, 0.633851690149485, 0.6054792848908936, 0.618656086360718, 0.610018620322164, 0.6231245036906439, 0.6534112436431567, 0.6479798834443078, 0.6316000255444671, 0.6246942250697115, 0.12659693075737322, 0.12398141462626244, 0.14691897106237406, 0.10731262804043695, 0.12269535758576189, 0.1418761993255021, 0.13543870561719717, 0.11736902057235077, 0.10093167693641536, 0.2597582448389507, 0.18340019367186833, 0.20735333598104122, 0.1643043328151731, 0.2464984888445113, 0.2580079943455169, 0.25287697826028577, 0.19858772353421128, 0.22200209416128314, 0.3522546795075002, 0.41052427935611624, 0.4049087558072715, 0.3724454927793568, 0.3946325243441604, 0.4151377254585106, 0.4164882513034486, 0.40666487764464554, 0.42686710501575, 0.3128169794235527, 0.27138824716675036, 0.29120047041666175, 0.29637309596043837, 0.31001701928957204, 0.36683494289268437, 0.31034191578566805, 0.29152122339344044, 0.3430372938191111, 0.21032314438080335, 0.2227346448966242, 0.22661890121303863, 0.19066549745668948, 0.21852333768704724, 0.19995915450317348, 0.20512526349851146, 0.2244067105458425, 0.21907999644096132, 0.19105980818821455, 0.2181868287423977, 0.2150662080401049, 0.2303368000737276, 0.20619385777456645, 0.23220194127258242, 0.4504629752834687, 0.20028029684626125, 0.4266526039584506, 0.19757249127656074, 0.7991497797381875, 0.18656620912454713, 0.17397279157719803, 0.8032044447171679, 0.17170907053591544, 0.6894032033001715, 0.1959612952741504, 0.8205395573548041, 0.19870425279845583, 0.16598630514762136, 0.2091039405829107, 0.2051797074261491, 0.6291637226071565, 0.16741725901957294, 0.20944230977924805, 0.6621031014088523, 0.20648453206764372, 0.17741324418769944, 0.18341304797492164, 0.1821792976148684, 0.18809996312668786, 0.19553193588861606, 0.1829359587912952, 0.1949742072292031, 0.19136847378927635, 0.1880895017789581, 0.08548352620653277, 0.09903650953227949, 0.07978479491273793, 0.08533264730015233, 0.09613399217893004, 0.088219700038066, 0.10260320468461015, 0.08792629203004454, 0.08340537007925819]}, "mutation_prompt": null}
{"id": "62282677-2cbf-4a8e-b638-bd84613ae8c9", "solution": "import numpy as np\n\nclass EnhancedProbabilisticDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                if np.random.rand() < 0.15:  # Change probability of performing mutation\n                    a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                    mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                    crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                    trial = np.where(crossover, mutant, population[i])\n                    \n                    trial_fitness = func(trial)\n                    budget_used += 1\n                    if trial_fitness < fitness[i]:\n                        population[i] = trial\n                        fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step with probabilistic reflection or contraction\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with probabilistic adjustment\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                if np.random.rand() < 0.15:  # Probability of local search\n                    local_perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                    candidate_fitness = func(candidate)\n                    budget_used += 1\n                    if candidate_fitness < fitness[i]:\n                        population[i] = candidate\n                        fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedProbabilisticDE_NM_SLS", "description": "A probabilistic multi-faceted optimization leveraging Adaptive Differential Evolution, Nelder-Mead, and stochastic search with dynamic parameter adjustments.", "configspace": "", "generation": 62, "fitness": 0.46436841552943425, "feedback": "The algorithm EnhancedProbabilisticDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.9329952511008498, 0.8751581260456964, 0.8764939057430755, 0.8513031827823756, 0.8547092738879272, 0.8946732616992251, 0.8873913894646954, 0.9144777363761185, 0.9094355140617613, 0.7962990320927614, 0.7248255394698823, 0.721687693652766, 0.7461582222355997, 0.7477794842852377, 0.7217583874702727, 0.7266726732500763, 0.7132714649664789, 0.7424249266287705, 0.1534662930987899, 0.15849561094822473, 0.14271833454218397, 0.1599076314784892, 0.5879351100961243, 0.15313342763876825, 0.17701703244202094, 0.6476296674739648, 0.6988287978725025, 0.0962713469853983, 0.11024201273024159, 0.11267403830885325, 0.12171954470969537, 0.10104132916419972, 0.10903223100118886, 0.1229254017565079, 0.1492544183520197, 0.09675925948951136, 0.9678523790021896, 0.9551069246655506, 0.9489930532116073, 0.9720938652864752, 0.949777540004356, 0.9654177267735641, 0.9705638450605714, 0.9759477953243153, 0.9531652518195967, 0.5720025514149639, 0.6167664360990321, 0.6506505721591681, 0.6514441921348095, 0.6276604912927537, 0.6320017591360757, 0.6159078585241353, 0.594922604338493, 0.5795537412239484, 0.8219733541263636, 0.7717858971598566, 0.2562642469273472, 0.86958837901203, 0.7969437250882164, 0.27696546780982667, 0.7840515476704724, 0.7891056343913999, 0.7785494112008243, 0.13357855535015928, 0.13578623397632217, 0.6895419806544258, 0.1355994358732876, 0.6804916967881705, 0.6915991501499557, 0.6580828114889016, 0.5634548751833051, 0.13507689720144722, 0.6562232268199104, 0.5840726027108802, 0.65429275926062, 0.6687120732235632, 0.5886910212006857, 0.7211098805682127, 0.6204997503027179, 0.7077679658949676, 0.13647712044752647, 0.5838206679649205, 0.5368828052664931, 0.5489897011360918, 0.5765566774971926, 0.6679726751195922, 0.47142364561519734, 0.5973495586188802, 0.5869788856795576, 0.6209422886152425, 0.701472030229413, 0.739765329882455, 0.6891561288672476, 0.7255015280997705, 0.6384991733064731, 0.7286830471763156, 0.7112723780771735, 0.6901562759518886, 0.7423447553470099, 0.11214394883574241, 0.22208525478152896, 0.17304402888736026, 0.4879586201010987, 0.34698016669728304, 0.2676811095756181, 0.454875351639056, 0.3971125192615822, 0.14514576259404255, 0.5094496680329363, 0.48382271008512867, 0.4444202143860364, 0.42308742100561425, 0.5121921348987837, 0.5098033175789738, 0.43683121788825596, 0.4580982162161207, 0.45732501899219113, 0.7919301862348307, 0.8102619093283536, 0.8043744724368393, 0.7944388682140487, 0.8034940133349964, 0.7927125967113289, 0.7880901937291456, 0.8291132408144236, 0.810385568704119, 0.11266705628316609, 0.14419385017084274, 0.1144442922991471, 0.118784006919332, 0.14797051523188942, 0.1394527944539845, 0.11973320388145225, 0.12565351706055805, 0.1558845948764287, 0.6510480006875368, 0.4612784600166787, 0.19942820668503636, 0.32531910308989054, 0.5672431140491219, 0.5518202408039694, 0.16649137238880085, 0.18821816610030784, 0.3730488133858402, 0.28249679923660687, 0.4826364742856759, 0.5118497967475779, 0.49840426097610957, 0.5736008361128375, 0.5358549612293182, 0.5759969496904327, 0.5262928267371696, 0.5787301736334818, 0.22440807457960177, 0.2943356937469581, 0.37940334258940345, 0.457634799691335, 0.35907318054846094, 0.39977302742425735, 0.2934189972437915, 0.29562035003479237, 0.36077121072534357, 0.21060152838179025, 0.20192023911993662, 0.19425142241443594, 0.21129709277926345, 0.2615984000389453, 0.22874173576738588, 0.1975833417217604, 0.28172770058366214, 0.2908910465509884, 0.20800023530776413, 0.21049577645021678, 0.19172799324255096, 0.20647593601515957, 0.18171018780715642, 0.2369868726336506, 0.21013209419290513, 0.22058008206449298, 0.1971576197800068, 0.20480091513616494, 0.9320303470193659, 0.15968411029977347, 0.1486308006648296, 0.9142014174860789, 0.1229876584738715, 0.18905966173073918, 0.8930462454901401, 0.1695563224181913, 0.12898170552599242, 0.16948455404463025, 0.213526718525758, 0.1698617395961477, 0.8669105381449275, 0.1691748417449127, 0.21007869904053622, 0.8673564223329976, 0.8955813327805995, 0.29575988549693155, 0.2204643169013707, 0.1930972282380291, 0.219269643893498, 0.2162424121423815, 0.2074086939352071, 0.2241032296449219, 0.24765060430096641, 0.22231599282150183, 0.10212599750088591, 0.09377618629453865, 0.08821025360107759, 0.1273695894949809, 0.10463543221458638, 0.09537562472579497, 0.1213842007163527, 0.10040823445944547, 0.0968597043788606]}, "mutation_prompt": null}
{"id": "0ac4f867-4c37-428e-bbf6-6d4e15e2f379", "solution": "import numpy as np\n\nclass EnhancedMultiPhaseOpt:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n        self.local_search_rate = 0.05  # New parameter for proximity-based learning\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population more uniformly\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(int(self.population_size * 0.85)):  # Adjusted crossover pool\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Proximity-based local search refinement\n            for i in range(int(self.population_size * self.local_search_rate)):  # Reduced frequency\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedMultiPhaseOpt", "description": "Multi-phase optimization integrating adaptive strategies and proximity-based learning for enhanced performance across varied landscapes.", "configspace": "", "generation": 63, "fitness": 0.39376716525085315, "feedback": "The algorithm EnhancedMultiPhaseOpt got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8313273854720183, 0.8468561798370826, 0.8301345062789058, 0.7977905111807201, 0.8226099045815463, 0.8448560407301107, 0.8186557499763383, 0.8328362903639775, 0.843809304148097, 0.6535210783180201, 0.6525140319062621, 0.6679743410906371, 0.6639340577493352, 0.6491587104557379, 0.6673562139535896, 0.6576043685874545, 0.6347385303706976, 0.6462097627260791, 0.15654713217365912, 0.15175361704933243, 0.15802362210814536, 0.14114889898189953, 0.14949522025563544, 0.16291581422422918, 0.15247368988032517, 0.5441194747448783, 0.14788084715862293, 0.1410356294391515, 0.10869171487931872, 0.1380686344249591, 0.10089710584786116, 0.10832758506836815, 0.1075645997518232, 0.11447059373532897, 0.1413953725706164, 0.12865530223960653, 0.9393334313942305, 0.956438168879989, 0.9585724758834332, 0.9608721853665848, 0.9780626786671894, 0.9519937368631678, 0.9705601613269453, 0.9695139954672501, 0.9585572175711784, 0.5316814527733231, 0.595415686315694, 0.5148859955311977, 0.5218911005464859, 0.5576520995423795, 0.503654018584884, 0.5688593260920709, 0.5079519938853005, 0.5768431510119116, 0.7895596698115999, 0.230374153052054, 0.21649861963045902, 0.8297602183506926, 0.26736956375346266, 0.39465433405870975, 0.7846119691641695, 0.8072931215162586, 0.3932607632712578, 0.3670483335138123, 0.2175821362928867, 0.12744803830400597, 0.22077212379008304, 0.24563902895577194, 0.12661464251718624, 0.21652383470649306, 0.2379085794455097, 0.22901380853159037, 0.12101352268028787, 0.26975534350917985, 0.34717500875194596, 0.4471782029150444, 0.36643744192014593, 0.3255277317492682, 0.12774560401012425, 0.3206387988377356, 0.2378194935778456, 0.4851129624959216, 0.4632564350647652, 0.46582883600563674, 0.44066152287008786, 0.29950541078730153, 0.4867932066283259, 0.48315938250842905, 0.5855330126765217, 0.47986532160089934, 0.6396119216367195, 0.6698194602249484, 0.6463571292739975, 0.6674049223256302, 0.6617045741779137, 0.6241484947576963, 0.6461110411917059, 0.5865135941275257, 0.5969611456691502, 0.08346798437797665, 0.24104459949450097, 0.1699093302035255, 0.10331209783684137, 0.1480303489371425, 0.36743756742317757, 0.22231055852560966, 0.18582729822752864, 0.12626106405578108, 0.34149228029480383, 0.3404443118707632, 0.3996801728601431, 0.3679415209387875, 0.4276714225038014, 0.42852891322705733, 0.3507540660139111, 0.44084632449734573, 0.3169698104089731, 0.7183452086121679, 0.7425308067106824, 0.7369250911423764, 0.7191938731504737, 0.7347833076862128, 0.7817859063704301, 0.7001068654378053, 0.7346665751237398, 0.7658508333507266, 0.11668513042626838, 0.1677534137456581, 0.1384898770142836, 0.13794198129057278, 0.15383877667975854, 0.12613094467389585, 0.1141815929454959, 0.17989605592661995, 0.5194693556668257, 0.21735828859265516, 0.2156463490895979, 0.24611686529353627, 0.18262767037791094, 0.2166227169560987, 0.1820509357125053, 0.21420921686119432, 0.2690551368024272, 0.2628840740734075, 0.3942647710589202, 0.4646204546881688, 0.4923050724974689, 0.39975739893197926, 0.4507142637163566, 0.39896775087505754, 0.5065750441353436, 0.40931922370095697, 0.492709879150116, 0.27962150301350297, 0.3482304489546687, 0.3994206321542989, 0.32637658251438306, 0.2789291957297496, 0.33172965933857934, 0.3972183993581935, 0.3566236071354456, 0.3630048492033332, 0.18428281132907087, 0.23997929982341537, 0.19676458484633852, 0.2219676949379178, 0.26353018071631595, 0.21149976617400157, 0.19548178136408056, 0.22785906830285507, 0.21791670364456683, 0.2051919262330748, 0.19979899088199093, 0.20485098964960247, 0.1798190142221009, 0.24372197680048158, 0.21777120287383955, 0.1896668104396394, 0.2049024481728693, 0.508866531941143, 0.16643136469602837, 0.2099803217954056, 0.18471215581612188, 0.19637375104604482, 0.8958528720680082, 0.15777976572729113, 0.17714080177058766, 0.16697201113057802, 0.1694386988922728, 0.746762938516337, 0.7790369408407202, 0.2112717640929661, 0.2109839608842926, 0.16656536936909472, 0.6381425158531147, 0.808578923575983, 0.8188676872943701, 0.16685701289845534, 0.2093705232797155, 0.20732819341134712, 0.19282515978619097, 0.2001070654771271, 0.19506398091417065, 0.1935089039289306, 0.21475834859875675, 0.19045875540801793, 0.20652377674239364, 0.0877896888095101, 0.10058997791957702, 0.11109182211703283, 0.0883653048471813, 0.09677041733692637, 0.10313252132099204, 0.10539128144237142, 0.0970543627992494, 0.08882855525194078]}, "mutation_prompt": null}
{"id": "0041660b-4d21-48b0-b923-ae8abd3eb8e4", "solution": "import numpy as np\n\nclass AdaptiveHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.4 + 0.2 * np.random.rand()  # Adjusted stochastic range\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with high diversity\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Enhanced Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Enhanced Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation for exploration\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveHybridDE_NM_SLS", "description": "An adaptive multi-strategy algorithm combining Differential Evolution with randomized parameter variations, Nelder-Mead, and stochastic local search for robust optimization.", "configspace": "", "generation": 64, "fitness": 0.4642277307360236, "feedback": "The algorithm AdaptiveHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8649549100740397, 0.8657366822188985, 0.8594411239774759, 0.853276744433421, 0.853505640679412, 0.8670998093498312, 0.8566749372515068, 0.8566350997033205, 0.8566395178496508, 0.7378114732570076, 0.7403876999066439, 0.7545738975630358, 0.7321731948531001, 0.7451345600925217, 0.7493123058516254, 0.7253086229982595, 0.7439223055100883, 0.7365300711702362, 0.11131113983699692, 0.571394420409989, 0.13024774817798535, 0.17530586423689765, 0.17756037848949113, 0.15623547645145042, 0.15208363931624314, 0.594711504461231, 0.17229754651550633, 0.12497550309162653, 0.10823613199944271, 0.10812980088073221, 0.10107154903563675, 0.09599874735967151, 0.10324853169420767, 0.11778110886652482, 0.12452473235101313, 0.13048213093657324, 0.9301143658301213, 0.9348224396905223, 0.9295607828252102, 0.9071934928296154, 0.8879845625999259, 0.9329025847469768, 0.9170040284140953, 0.9519473468060008, 0.943665510501959, 0.6005575147220885, 0.6298070049183109, 0.6431204449272641, 0.5756885858018133, 0.6305213020742946, 0.6110970138063722, 0.6272462587478138, 0.6266189135559774, 0.6453360996478207, 0.832203588189103, 0.8776519958852443, 0.8647551095398527, 0.8777337359182245, 0.8570727423395577, 0.8687224558336601, 0.8485256228449528, 0.8957337152701565, 0.8812548573325825, 0.4051703113894619, 0.5528708891488434, 0.2840387065828477, 0.486082217157617, 0.20244879530257154, 0.49010705863023796, 0.6293673673897263, 0.4456134335278783, 0.4856087351685021, 0.2622072416219896, 0.2824980570877613, 0.582132256688438, 0.5062083885742956, 0.2781169175741416, 0.23986683883277726, 0.28657427244824063, 0.35252119751358035, 0.17823785389565838, 0.48517765628139153, 0.4070213201776912, 0.6066841776404164, 0.6356750250526131, 0.6529177276741255, 0.6074805516314854, 0.5982797148793239, 0.5940076392343355, 0.6226378306658271, 0.7056136868803137, 0.646626487276628, 0.7221715211027716, 0.7138310744411483, 0.6731387068415907, 0.7102392347591453, 0.6693519004750128, 0.7120462955376752, 0.6800798943802937, 0.09924587845459099, 0.2415990159389444, 0.19554734226660653, 0.46611688525541817, 0.37925021400144154, 0.4841379035638843, 0.28474104952400126, 0.3439822311055022, 0.32711185327070114, 0.472781009288586, 0.4918880963849547, 0.4977808624375113, 0.5229477468756976, 0.5259191601450026, 0.5421692923515455, 0.49810716979637915, 0.5493384774169195, 0.4631785920595276, 0.8011008837857256, 0.764302512629794, 0.7987260101990048, 0.8068432411223375, 0.7979134361155793, 0.8187363849026194, 0.8003952148636152, 0.7023516514762738, 0.8199731780270274, 0.14078462972002492, 0.13047377990086373, 0.1507997935560801, 0.14888834583068278, 0.1715037261271416, 0.14501648099998277, 0.17241561832806307, 0.1404930577847806, 0.4028382875806378, 0.42330724850796764, 0.6442796153867634, 0.20108998775460418, 0.5643280255561496, 0.2653464643193548, 0.19289463189911527, 0.39995324099614504, 0.36074945764146016, 0.323679836101727, 0.5878528607626605, 0.6498939252715452, 0.5962645425514049, 0.5865007266969167, 0.676969634718499, 0.4699317805873183, 0.5888107809386941, 0.621936379674225, 0.5771885901576779, 0.4557717698001771, 0.3638252420652145, 0.3355875747279017, 0.3692568691069953, 0.4169510707140569, 0.37580972021751746, 0.39524209795700727, 0.5848975180249921, 0.49540874517957445, 0.21278266055479678, 0.1998570153496707, 0.23547362644022007, 0.22233770830804556, 0.2379275076319266, 0.18707397902084633, 0.24010046116557004, 0.23434243384636033, 0.21209158210076684, 0.2264784954495197, 0.18599561552524457, 0.2051698062733145, 0.23894083387252962, 0.21943106888795816, 0.23604652809868254, 0.19427755959132575, 0.20521680549438948, 0.2190084112345868, 0.1226971456188034, 0.1981919660680408, 0.18580330521579813, 0.7625542842844665, 0.8779624953244738, 0.15300714087439504, 0.8384825267871997, 0.1773312011517999, 0.8594243189018527, 0.2057959993025542, 0.7948959890594159, 0.21041435714631618, 0.21134359031520866, 0.16791705441754334, 0.16786708828370134, 0.8393598380427075, 0.2106913375477849, 0.21186561892598987, 0.19944414362262508, 0.222488856615632, 0.216706150374103, 0.20926472507786686, 0.21707365427009995, 0.19412681717881197, 0.20647860914579808, 0.1982230321300399, 0.2041873643167501, 0.1052294414712589, 0.09368070822211194, 0.09344564948443235, 0.09306172538136503, 0.1016711365747962, 0.10753261867187558, 0.10906916273048806, 0.0972171804401365, 0.09679654683880345]}, "mutation_prompt": null}
{"id": "f3a16720-63fe-4bc2-bf59-c5acacb9fadd", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                # Randomly select distinct individuals\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Dynamic Nelder-Mead Simplex step\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Local search with adaptive perturbations\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                perturbation_std = 0.1 * (1 - budget_used / self.budget)  # Adaptive perturbation\n                local_perturbation = np.random.normal(0, perturbation_std, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined hybrid algorithm incorporating Adaptive Differential Evolution, dynamic Nelder-Mead, and local search with adaptive stochastic perturbations for robust optimization.", "configspace": "", "generation": 65, "fitness": 0.44774965298799313, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.854276769052203, 0.8415527405595419, 0.8422842452339232, 0.8484087151479623, 0.8482087467359646, 0.8464816770606088, 0.8456864023104085, 0.8376330474167545, 0.8584772683232448, 0.7247864308108823, 0.718577979877414, 0.6894678017852813, 0.7109747293179003, 0.7172445816507098, 0.7227388006445099, 0.7068967045108747, 0.716387946465634, 0.7139523734824408, 0.4407720611332153, 0.1445960961982644, 0.1489469666336274, 0.1709076090644387, 0.14439050957457533, 0.1549718197575779, 0.1554149365629679, 0.15766729194379225, 0.16767782801335562, 0.1275744891863706, 0.1497591806657903, 0.14426184134176145, 0.13413524932182097, 0.13348857268682135, 0.1491695898207427, 0.14320860531327473, 0.138719319906784, 0.10382473034220074, 0.9474649974674665, 0.947907558025853, 0.9456771892197661, 0.950920114612235, 0.9197549473211264, 0.9261612953274728, 0.9298239649068887, 0.9218411527979787, 0.9179206264008517, 0.56593012486584, 0.5838912939100653, 0.5873900345370234, 0.5938663515803576, 0.5987125278286173, 0.5937078604185495, 0.6309311816282899, 0.5653706389484849, 0.5814623400616167, 0.785933121800032, 0.8357985912380104, 0.8663518798168129, 0.8616411597699943, 0.895263473931037, 0.8408074222724031, 0.8450963478590996, 0.3881337856116308, 0.8666269117313542, 0.2898991622038737, 0.3357226424751357, 0.38798188502696795, 0.48612985313899937, 0.44664247736881535, 0.13036454541088993, 0.45070173419558335, 0.4917303931354604, 0.4641709300875143, 0.2684534614610953, 0.2757725212837695, 0.37954869271695035, 0.5696811840641525, 0.3944998059141379, 0.4506703970593702, 0.3984930651745763, 0.24760012740487047, 0.12982080491598424, 0.4598161785728918, 0.589100328900835, 0.6151241086773588, 0.5617536866974926, 0.5907115495986097, 0.5806840483605527, 0.5658874784197867, 0.5904793749429864, 0.6127190355583625, 0.6594893025162707, 0.7034358248938096, 0.7028266134757706, 0.67989032779941, 0.6427770415173004, 0.6710890921859761, 0.5953011394929124, 0.6800615178861249, 0.7183687964611472, 0.10016638996553684, 0.33517090428760976, 0.3107060469314602, 0.40501758050308434, 0.4706363968467553, 0.4805880808693731, 0.21913663680347129, 0.3181267732115439, 0.24894017375980748, 0.44391421913429807, 0.4606975749761588, 0.46178063790419077, 0.4819204267424301, 0.5097004525063225, 0.47438455708578486, 0.44703680547134605, 0.4708134835700025, 0.44525124642785796, 0.786966896548119, 0.7807890493978767, 0.7875588263129951, 0.7984549691675351, 0.7934050307370005, 0.7979140615245082, 0.765583918485047, 0.7988245499316315, 0.7904636244901713, 0.1138408184529004, 0.1044460905651522, 0.13961547359495685, 0.14091171317237916, 0.15031310372641526, 0.14087689275905446, 0.10841101256189833, 0.137427132733968, 0.18151876535243006, 0.21562002019872883, 0.3720648885788952, 0.1527426677385163, 0.22392496248678895, 0.5102632846780989, 0.20639975636304764, 0.3281480855784088, 0.3902922942109688, 0.2430870141981849, 0.463725115810818, 0.5382817630753672, 0.5269539006979505, 0.5563248505982931, 0.5447671588510065, 0.5600270453544633, 0.6125790613916322, 0.6308694803089763, 0.6130072398881127, 0.4494348661303682, 0.3084716660712833, 0.3593977600925484, 0.4657117397831383, 0.45627307669614514, 0.45447209782162423, 0.4732053376998768, 0.3858496242461311, 0.4656420689379399, 0.20193059446019346, 0.23958778510079404, 0.2307411552009605, 0.22533504027541462, 0.22057785981134725, 0.2152685371415629, 0.2142058307316953, 0.2028473673093234, 0.218285901354633, 0.3994737834440627, 0.21501708292826271, 0.21607547310090014, 0.2474366167258084, 0.19973627006681938, 0.19955588303220517, 0.20290507606065444, 0.18797367486570637, 0.23259286899565945, 0.18461374946782017, 0.1988600201875339, 0.8742802647926199, 0.18390942018023637, 0.8643940890303015, 0.1628791647518023, 0.8432734437404155, 0.16802047575583323, 0.8548237009000939, 0.20113353517961285, 0.8611995727497203, 0.16747233692451724, 0.8433463414380745, 0.16756325836202157, 0.16793921398377498, 0.2084968338462324, 0.2104092429683282, 0.2124810812837865, 0.2169630221273966, 0.1940680640100283, 0.20089500199311494, 0.19925234509732326, 0.18418385102344526, 0.1962635158294579, 0.19263934794223514, 0.20750619823018057, 0.21159529111195774, 0.0945423758147137, 0.104984421165919, 0.0958007634630339, 0.09904940888868186, 0.10191385762657845, 0.10637288415990365, 0.11058806175128133, 0.08985156167542463, 0.08865570261048483]}, "mutation_prompt": null}
{"id": "17979013-c489-4b59-a69b-b60dacb77b8e", "solution": "import numpy as np\n\nclass EnhancedRobustHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedRobustHybridDE_NM_SLS", "description": "An enhanced strategy integrating Adaptive Differential Evolution, Nelder-Mead, and noise-handling stochastic local search for diverse and robust optimization landscapes.", "configspace": "", "generation": 66, "fitness": 0.4771458526587456, "feedback": "The algorithm EnhancedRobustHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "d24b145c-9ade-43d0-bb34-c657b0c5deba", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = np.clip(0.8 + 0.2 * np.random.rand(), 0.7, 1.0)  # Adaptive to enhance exploration\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Slightly increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Slightly increased local search range\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_V2", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, stochastic local search, and adaptive crossover strategies for diverse optimization landscapes.", "configspace": "", "generation": 67, "fitness": 0.4406320152186054, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.810654780128991, 0.8108867704039497, 0.8514487322740606, 0.8266891496736803, 0.8303262337753217, 0.8610650234408265, 0.8165817424380358, 0.8143051959343401, 0.8553472219617398, 0.6525017878435805, 0.6521188388608254, 0.735495246504858, 0.6703295002588745, 0.6412625088628847, 0.7482512884778222, 0.6848350784234432, 0.6595472462137173, 0.7413411352534452, 0.15375730423156786, 0.3823943223425137, 0.16097538992862737, 0.13800563902945284, 0.12427722510624695, 0.1632187725209977, 0.16149846306206472, 0.16505593273735797, 0.13651216678223577, 0.12060948124147941, 0.1442405503712535, 0.17083361391555263, 0.10777532259687561, 0.13268431666196046, 0.11101602768366847, 0.11162501233120126, 0.12536055757954767, 0.13150832857860772, 0.9593276999567254, 0.9579416037246246, 0.9454666035470123, 0.9127196778935301, 0.9735203185805339, 0.9529617217016261, 0.9184132527381013, 0.9486697747603285, 0.9674508617375854, 0.5711635979209286, 0.5018827678577765, 0.6181076076906648, 0.5389480628230141, 0.5201403678523348, 0.6265644078796165, 0.4846513843858362, 0.5476212601895636, 0.6173828800713447, 0.7816821966200269, 0.8100598747104104, 0.2240784747857194, 0.8439597705602092, 0.8274068726178659, 0.8703403296458185, 0.7948252565705274, 0.8284789037710951, 0.8834646323356855, 0.5506097242228701, 0.47627165730138266, 0.3020911113441407, 0.3506754711690211, 0.4426076035397647, 0.41883682786878895, 0.5691711256957945, 0.4086834640303164, 0.39795165628035445, 0.4616718539386585, 0.23463869248922187, 0.2993421292857502, 0.45272022653817834, 0.36763652256469515, 0.28393376591605024, 0.42573537841081965, 0.34168957961842084, 0.20621768614533942, 0.5026246480320076, 0.45881448361185273, 0.5800349986352823, 0.5161446683341722, 0.48852131301012347, 0.5925653297718043, 0.5534631366026935, 0.4792992036951308, 0.5711869873021614, 0.6240497661619177, 0.6321603762977928, 0.7069859403639902, 0.6231074465732647, 0.6023252286647385, 0.6431588740739176, 0.6096180527029804, 0.6613650554900896, 0.702824908300514, 0.2675792732157827, 0.16820174623207163, 0.1241250463900484, 0.26323141252036175, 0.2974614067337187, 0.3591276147584833, 0.14842939173660175, 0.23412181522339282, 0.2640766617500585, 0.38316137543702866, 0.3558140527530851, 0.4961494283600465, 0.3833683662291574, 0.34781720020546614, 0.48023423962733247, 0.3747797484265505, 0.37684796581947433, 0.45037963722453533, 0.7256467740745991, 0.7637643571978547, 0.7685759265942081, 0.7584096372428031, 0.7247780715342287, 0.8007234428268436, 0.7280038356228726, 0.7431832674061281, 0.8003146542666022, 0.14444390929802797, 0.13202509974682253, 0.12857476436256943, 0.13621554034021888, 0.1263171342503394, 0.12013356801436004, 0.12339270201797936, 0.1468234037813707, 0.31156452320266537, 0.30744455238351087, 0.2596880101762695, 0.4088507797122306, 0.17194413443736756, 0.17871812121629305, 0.17365526098255102, 0.19834838370470143, 0.2294119311967331, 0.4273384621378785, 0.4532113220717007, 0.40475769629061975, 0.5649197540386532, 0.5022467643020422, 0.4729866200231895, 0.6116337440250224, 0.529305970791697, 0.5033905642655676, 0.6183284733250132, 0.43606938422386343, 0.37933443287447, 0.390905946459832, 0.38151178179532774, 0.3455098977073553, 0.4916697306236363, 0.36087005490940594, 0.36784790393486677, 0.3602570847761374, 0.22266924350344763, 0.22383328731001373, 0.24753821303400847, 0.1965568734524159, 0.19300799156035342, 0.23364633275115076, 0.20605042579868627, 0.21018800629599454, 0.2279588798768759, 0.19827452919372957, 0.20304391709227376, 0.23463689913972408, 0.2311076692778029, 0.20893121079089405, 0.199342634557386, 0.22094668268487894, 0.2284145580967042, 0.24853349247871848, 0.165112762110037, 0.7868738602601169, 0.8455208451393907, 0.19767617738442655, 0.16516983282685815, 0.1780285027020222, 0.8602218245721487, 0.7488349667104746, 0.768488158892521, 0.8039806493839446, 0.20720012720356762, 0.8244038975222794, 0.16953838204532623, 0.21033235424204522, 0.8417183721522551, 0.20926513801212843, 0.8568642266158014, 0.8730828495170403, 0.21951783914263534, 0.19903797195310713, 0.18680747874887915, 0.18934871590741398, 0.19012640601271225, 0.18445710131451032, 0.20059738574083308, 0.20258270062514416, 0.19952488508586197, 0.10125831661799789, 0.08219158074509503, 0.10133447529799289, 0.09720653968152493, 0.08973124093954177, 0.1361901136209973, 0.09720623675649986, 0.09352436210979809, 0.10062344157704306]}, "mutation_prompt": null}
{"id": "d96ffcdc-c1a7-482a-ba14-79029a016bdb", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly increased population size for more diversity\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Increased variability in DE factor\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with enhanced diversity\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic scaling factor\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step with adaptive reflection coefficients\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection_coef = 1.3 + 0.2 * np.random.rand()  # Slightly stochastic reflection coefficient\n                reflection = np.clip(centroid + reflection_coef * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with improved perturbations\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.2, self.dim)  # Enhanced perturbation magnitude\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_Improved", "description": "An improved multi-strategy optimizer using Adaptive Differential Evolution, Nelder-Mead, and stochastic local search, incorporating dynamic adaptation for better convergence across diverse landscapes.", "configspace": "", "generation": 68, "fitness": 0.41452110463741365, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7919190449013976, 0.7969023930758801, 0.7955939435847896, 0.795694814762414, 0.798102968266535, 0.7964099418421587, 0.7869782160686738, 0.8040417760697953, 0.8025435919107159, 0.6291120933308564, 0.6134252431704645, 0.6101506980121052, 0.606666309923771, 0.6059193982325987, 0.6283930160586484, 0.6296494646237445, 0.6309896192554519, 0.6324606152408805, 0.48133166408083106, 0.1373665850402731, 0.16319633760813523, 0.13106969884504127, 0.23856291792392126, 0.321087881099808, 0.12173662338116187, 0.1286206551788005, 0.14495964963852426, 0.12892618667310385, 0.10648428968882906, 0.12097284006873599, 0.10644781127260028, 0.12857844397821627, 0.10903778133613162, 0.14113853972850088, 0.1222303549850079, 0.11987859579880111, 0.8947554568812766, 0.9537020743512514, 0.916856563527597, 0.877968597964702, 0.9063148163640944, 0.9152389669091213, 0.9633743621516155, 0.9731687978937076, 0.9106731500061082, 0.4740088400864143, 0.5058920112948642, 0.45924798451372517, 0.45705009123318185, 0.5056982430885625, 0.4742044185082205, 0.4707805303176146, 0.512157727624473, 0.505062035870437, 0.8115604688197593, 0.7773983395623134, 0.8320898204069058, 0.7819343076303704, 0.778150372077387, 0.8005965986161548, 0.7963081399254011, 0.7653746294130692, 0.8070743024715532, 0.2417476582627428, 0.16605206402780026, 0.33310843251724886, 0.2901087584259574, 0.4448587796541461, 0.1256647371035169, 0.29102143645904355, 0.37562261033951094, 0.2511060891161164, 0.6081004128157823, 0.32505485581638927, 0.4444535636889405, 0.31568083050981555, 0.3040730595978345, 0.5572759882818646, 0.3215474551599552, 0.341952031307005, 0.3407841663225205, 0.449547756076876, 0.43901931358564095, 0.373481517236933, 0.3332664595657199, 0.45134585441645314, 0.3913438624318476, 0.4598390863126135, 0.4530718957980925, 0.46376538251313293, 0.5291997285954859, 0.6001587124735628, 0.555123867101191, 0.5139558840358206, 0.5522440941858471, 0.5855577329865351, 0.5547504091951969, 0.6178509478977334, 0.5680748642960407, 0.09367469371328319, 0.21074313354221608, 0.17926785053328753, 0.25970281540671625, 0.2298811857982035, 0.22670925718419266, 0.2225859744101163, 0.2686118060577558, 0.2042822310068093, 0.327788106989367, 0.34192646728438736, 0.32181754698537546, 0.33753642103051473, 0.3598992387264751, 0.3484673557964605, 0.3234557023328736, 0.36693551281675485, 0.37053582699923104, 0.7200094411476825, 0.7203573028896842, 0.7139986299779544, 0.7099673426696604, 0.7256292991950397, 0.7453120283518374, 0.7134216338733164, 0.7140078962765712, 0.7126502998017192, 0.14556470411464129, 0.13190264026038945, 0.13611938349984398, 0.1273252311163624, 0.15174342834098864, 0.10732029599302151, 0.1634602151059351, 0.11549545221920887, 0.12003255458062123, 0.29523043908131175, 0.2350621303550473, 0.36114500750628875, 0.2508212013700195, 0.2859875311789273, 0.16442635056235066, 0.21014814120633452, 0.17138386157074725, 0.20734114652252011, 0.45335497883969145, 0.46108375701166215, 0.4651118316656121, 0.447231914896315, 0.46528563792328836, 0.45524175937413025, 0.45878543211603673, 0.4228314437263415, 0.464610123381449, 0.3728575181354751, 0.3753080678347065, 0.33059814669513, 0.3525782736572377, 0.37256682381305306, 0.3868791304097524, 0.3265550985980892, 0.3833461475351704, 0.406166929361512, 0.21567418197755106, 0.22093825011582358, 0.2076944176344604, 0.24438298771739164, 0.22888465737577224, 0.2392781889684127, 0.2287745410683537, 0.2003491441470664, 0.2376698516176523, 0.22762413579453755, 0.2301516659942191, 0.39264186556436875, 0.41536499709359176, 0.261443168565737, 0.34431154402961006, 0.21966937842368006, 0.20790200488367716, 0.49869798624360706, 0.8403283059545759, 0.8537860204933204, 0.18389069857393447, 0.7370399781970387, 0.8424360304039219, 0.7918395026793578, 0.17560125210885513, 0.8540554893339023, 0.17057423817791872, 0.19638183977905688, 0.20510293681996195, 0.671071430405972, 0.19892877589964686, 0.16944592090268196, 0.16585576714063555, 0.7201256486595695, 0.7667074213010502, 0.7786540815137255, 0.1937324652382746, 0.2060924685179144, 0.19523940559352593, 0.19801664260461804, 0.18751903610527543, 0.19558289330199707, 0.21616740712427762, 0.1840435388913223, 0.20287437725728696, 0.10032552603944389, 0.08977157005896863, 0.1059243933947508, 0.0880595365893192, 0.09262805577598487, 0.09657066031010841, 0.09917531314495864, 0.09651791499087192, 0.09192941054702242]}, "mutation_prompt": null}
{"id": "5edb87a7-092b-42c4-b265-742643c0eb4f", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_DM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n        self.dynamic_mutation_rate = 0.1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with dynamic mutation\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, self.dynamic_mutation_rate, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            # Adjust dynamic mutation rate adaptively\n            self.dynamic_mutation_rate = 0.1 * np.exp(-0.1 * (budget_used / self.budget))\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_DM", "description": "A novel hybrid algorithm integrating Adaptive Differential Evolution, Nelder-Mead, stochastic local search, and dynamic mutation for robust optimization across varied landscapes.", "configspace": "", "generation": 69, "fitness": 0.4491140692773717, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_DM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8383997564314127, 0.8540973679154216, 0.8461207501466893, 0.8525598562025689, 0.8378125434020879, 0.8452436860367986, 0.834530448747234, 0.8595406774137191, 0.8654092095948762, 0.7039186379301097, 0.7270320956238436, 0.7294797450879416, 0.7115719669514644, 0.6963092398932844, 0.7152461693242258, 0.7133771806548577, 0.6888413439343876, 0.7071492040251278, 0.17345707493056128, 0.1584009095609512, 0.6261473405737346, 0.15557909373585932, 0.1617309666613912, 0.15754112313202406, 0.15238569813331015, 0.16250564591967853, 0.17201636792503983, 0.13173999739949083, 0.09377483151317123, 0.13659770389003645, 0.13610933180291418, 0.1385312211474875, 0.11577756908683001, 0.15434979148118855, 0.13764841203108558, 0.11024867332498323, 0.9489389326109858, 0.9517350969769792, 0.9456793425026018, 0.9508565518267236, 0.9051468391968999, 0.9308254524904214, 0.9456284749857067, 0.9322335602907994, 0.88717522821667, 0.5851257275549256, 0.6188273029075184, 0.5815509757690547, 0.5641587282302626, 0.5824173642561705, 0.6205158148152343, 0.5928489219690523, 0.6134053800287018, 0.5852632531924646, 0.7998962046766176, 0.8534513176757217, 0.812933632191155, 0.8890258891695609, 0.8337193314145266, 0.8923180725024478, 0.89243713149337, 0.8377273145569518, 0.851764181978854, 0.38454914756434366, 0.33491992075025, 0.4747502067212709, 0.4559333896605071, 0.601555240852947, 0.33229064054847623, 0.25541603051830974, 0.5225181427815043, 0.4217121119373948, 0.5497899442671879, 0.18991356905914736, 0.19427881545617087, 0.4100671731722597, 0.27671807266149673, 0.3034864511992308, 0.6085289446400335, 0.27504819617542875, 0.6211467770144755, 0.570799758636269, 0.6111987213179035, 0.4990517537704863, 0.5470318974486936, 0.592257712903451, 0.6013737804310909, 0.5760158351335491, 0.6012239546894416, 0.6014291047835981, 0.6954627504250228, 0.6776762206214741, 0.691722927367767, 0.6987782917176855, 0.6547370716463612, 0.663566754657926, 0.6363719435196844, 0.6635820226346657, 0.7060959934558282, 0.11273135830358427, 0.20836466935341713, 0.1455124526314634, 0.19747148932074032, 0.4888711145124205, 0.32209779168128216, 0.14027493736699237, 0.24224509330879374, 0.14639669898017604, 0.4056689306236412, 0.4836453891763166, 0.48050845225984407, 0.45526982158906126, 0.494312290117098, 0.4641780123915058, 0.44255550946428035, 0.46879303016881024, 0.4589939451802483, 0.7707519764981403, 0.7809068086672761, 0.7843561418217064, 0.7801622419635439, 0.7758380210220637, 0.809073408068623, 0.779020731938336, 0.7610391753811729, 0.7632733752352974, 0.13436871740331247, 0.12670386365490027, 0.1694197662310073, 0.15038460810272813, 0.17754201803244085, 0.14922944515388537, 0.13778123180311264, 0.11521545202979866, 0.15620384264271703, 0.14654733233220596, 0.26299985405304405, 0.235659064983873, 0.23919253483632774, 0.6119873886984277, 0.1990220009591427, 0.37345332108594087, 0.27744355577106516, 0.23907878485156875, 0.5522893043053723, 0.5438973165201507, 0.48739837567436783, 0.5516309539604154, 0.49021469272778706, 0.6007271807371736, 0.6351049191748392, 0.6219694349180285, 0.6165599913242139, 0.45426127979335773, 0.46024059134237083, 0.2885417945929559, 0.4032702896520315, 0.25845191429597125, 0.493618268780714, 0.42968306337513673, 0.29747715517035866, 0.4333037934007944, 0.19647248832060216, 0.2212135318952636, 0.2222894088536973, 0.20849179823648567, 0.23824232920959898, 0.22250262043497293, 0.22145717557147004, 0.22904074351951453, 0.27585343323673717, 0.21902547729903776, 0.2126392595758556, 0.2411642308245815, 0.20036528666846476, 0.41382112763715695, 0.23209906669104585, 0.2408123696924297, 0.20374233744217762, 0.24201380015209706, 0.1599425499025514, 0.19860768489121106, 0.8788314778799949, 0.18487128194321845, 0.8641261778100333, 0.16412360463839437, 0.20917616660049654, 0.16801725430750936, 0.8563646509148943, 0.2037927900246579, 0.8458786004624319, 0.20830810220730211, 0.8273606416600101, 0.16757088470651993, 0.787854394383895, 0.2085657506124885, 0.21047810657340826, 0.21243278909653607, 0.1861255977045866, 0.18657301013994187, 0.200111055570384, 0.1998690815609273, 0.19830744687443647, 0.213759525449302, 0.19612468814924844, 0.21342505986393656, 0.19817688017028456, 0.09677521071327266, 0.12450252814925966, 0.10047739830529956, 0.10183898427411864, 0.09586125019068747, 0.09388797658351378, 0.12218743891245143, 0.09905509966348014, 0.09305844317554035]}, "mutation_prompt": null}
{"id": "74427320-2da2-454b-aa4c-3069fa54e26f", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size for diversity\n        self.de_cross_over_rate = 0.85  # Slightly reduced crossover rate\n        self.de_f = 0.6 + 0.2 * np.random.rand()  # Increased stochastic adjustment range\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Stochastic Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Extended Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.4 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Adaptive local search refinement\n            for i in range(min(6, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation range\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "Iterative optimization integrating Stochastic Differential Evolution, Extended Nelder-Mead, and adaptive local search for enhanced solution space exploration.", "configspace": "", "generation": 70, "fitness": 0.34691232303815817, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7245710194507282, 0.7218057431275746, 0.7250194718230585, 0.74113973880442, 0.7389034247083769, 0.7427892546030481, 0.7611815109321878, 0.7537158055275481, 0.7478628382485459, 0.4935489779911284, 0.5285183386791739, 0.5009124766423073, 0.4859536599414708, 0.5273293162545987, 0.5145548373025277, 0.5227930017150181, 0.5284888144711499, 0.5159778295183233, 0.17703483219852845, 0.11818564403783804, 0.1127440956655591, 0.15676809767677224, 0.13370468397593394, 0.15384618950418394, 0.2511834278922068, 0.15216705449101187, 0.12809501563225145, 0.12737114724356957, 0.12383124100389309, 0.11239830128679673, 0.10049967316425412, 0.11364536712444429, 0.10617021343382571, 0.1228129461914752, 0.1196848909878574, 0.12533266877016835, 0.9134634339648677, 0.9829973997278163, 0.9299329478496543, 0.9486737255131517, 0.969461153357645, 0.9220724315945966, 0.9357386384425024, 0.9716024443732459, 0.9340691881905187, 0.3360210286262125, 0.3543734071714062, 0.35773800875456896, 0.37651570693229386, 0.3587139519434952, 0.3647450895974621, 0.36325124327169755, 0.386599623086606, 0.34916397089336515, 0.6548737267550344, 0.7100011715648656, 0.811975703445015, 0.7638990817801155, 0.7448123674789595, 0.7170313734878613, 0.6852541304427967, 0.673667855225263, 0.6538503574356683, 0.22083280944526373, 0.2480390957743226, 0.25297371663062984, 0.27350729696543685, 0.377095168712424, 0.23950503080197394, 0.23152813857242782, 0.2673367694557717, 0.20451634070167624, 0.26081558973723673, 0.31137031043321695, 0.23275515384799939, 0.2676103622272612, 0.3078047700137423, 0.2550304104380047, 0.20783172049752408, 0.22481382169840358, 0.25644841773527727, 0.1853426796280957, 0.1971536057312815, 0.22034009429521273, 0.21492014426581585, 0.16853982898957054, 0.2499337475158755, 0.22071822198755853, 0.22512262096447078, 0.26527363976338014, 0.3857155937574518, 0.37790443610964697, 0.4000316508536751, 0.3187178039719847, 0.30154884588850306, 0.35598046787914783, 0.3677291868952224, 0.43292607196602617, 0.4646017493593978, 0.06575303524133758, 0.08232797392420976, 0.09119357134966688, 0.09008575218867032, 0.13264801211922095, 0.11401968314543554, 0.1092125885963785, 0.12082180741864468, 0.08070261183093552, 0.22873229175992416, 0.24884126822275066, 0.22976842811378206, 0.2328607412214243, 0.23781625466135659, 0.2407546132235261, 0.22241633519894766, 0.23695044015929456, 0.2241161293902072, 0.5871392706014518, 0.5946005962304045, 0.5930842237763843, 0.5645328886624001, 0.5922775939935483, 0.5957489635209017, 0.6015444738125734, 0.5656300249578661, 0.5890387263762521, 0.12617402185358828, 0.13350003492212603, 0.15270190130589467, 0.1422541490489153, 0.10199540799543205, 0.12003840733844573, 0.10865755406407662, 0.11512428880682635, 0.11340300191131103, 0.19783223959932572, 0.2550649610632443, 0.16872553239452026, 0.2437310993348658, 0.1672335765933527, 0.16454589583414636, 0.19731316752058736, 0.17312060998329581, 0.17921786647174887, 0.3669797644399512, 0.37083956919889194, 0.3798061440811621, 0.3781940927378752, 0.3698915674012776, 0.37034767924128886, 0.3658403379151486, 0.40869567953165775, 0.34911281253661086, 0.2679545531364559, 0.3101898443391641, 0.29276684172833856, 0.2595902030111221, 0.30964511767091685, 0.3317723986929443, 0.2609874567920615, 0.30182919869610036, 0.280021120349051, 0.19991690399383366, 0.21489285632271093, 0.2333920318460302, 0.21708428948142477, 0.2286136038378238, 0.19848003658623825, 0.23756221475121642, 0.21009454528504523, 0.20392134168848297, 0.2163872132541873, 0.21127825273456313, 0.308903466491376, 0.20843325521364964, 0.36080565638823114, 0.21555861501520301, 0.20224623467451497, 0.23922286457051423, 0.226371820294066, 0.18466750494887318, 0.8052483517284683, 0.7915383482727374, 0.15828715902979495, 0.7491465179185579, 0.6567140916574012, 0.6792339718871976, 0.17178844627781875, 0.7477234815227326, 0.20668292807151545, 0.16727037510437626, 0.2106153720142262, 0.6724362325368957, 0.6126245853932313, 0.2104187520099391, 0.7726063874948274, 0.7564760059281257, 0.6613387856152733, 0.20645469167367814, 0.21347399661323074, 0.20333807138572502, 0.20413690965537512, 0.205864632853769, 0.18948879846767364, 0.19586973079208048, 0.18541116560873228, 0.18190738415601682, 0.0848326012970898, 0.07774385429366215, 0.09578420627090023, 0.0947305846084, 0.09696598563827719, 0.08667828316587545, 0.10346914561281662, 0.09581835528510363, 0.08203845734409843]}, "mutation_prompt": null}
{"id": "572c9581-b6ba-4fff-9a00-1444a417091f", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < (self.de_cross_over_rate - 0.1 * (i / self.population_size))\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step with perturbed expansion\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst) + np.random.normal(0, 0.05, self.dim), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1 * (fitness[i] / fitness[0]), self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined multi-strategy algorithm incorporating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search, now with adaptive techniques for crossover probability and perturbed expansion for enhanced exploration.", "configspace": "", "generation": 71, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('scale < 0').", "error": "ValueError('scale < 0')", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {}, "mutation_prompt": null}
{"id": "20c05db3-77c1-41e5-9291-5c5071a73bf9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.15 * np.random.rand()  # Increased stochastic adjustment for better exploration\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows with dynamic centroid adjustment\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size//2], axis=0)  # Dynamic adjustment\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with enhanced exploration\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.2, self.dim)  # Increased perturbation for better exploration\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedAdaptiveDE_NM_SLS", "description": "An enhanced adaptive multi-strategy algorithm incorporating Differential Evolution, Nelder-Mead, and stochastic local search, with dynamic adjustments for efficient exploration and exploitation.", "configspace": "", "generation": 72, "fitness": 0.4521019716274967, "feedback": "The algorithm EnhancedAdaptiveDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8358521249097277, 0.841075477227689, 0.8443794242357288, 0.8595514996565901, 0.8447838604644823, 0.8421063559955331, 0.828489981793493, 0.853738898952117, 0.8439165741957072, 0.6984535702202228, 0.7078012481788005, 0.7147183009711577, 0.6797616677213882, 0.6964635347245305, 0.7195175112959189, 0.6983716933471216, 0.701453792730923, 0.7076360124280705, 0.13094477524331616, 0.3827174556212707, 0.4370684977654926, 0.1472120354532961, 0.1711886033308505, 0.16479047725407292, 0.234380870180261, 0.5774930757576191, 0.17114485396887724, 0.14102497673217218, 0.13293189536493033, 0.11499313260228083, 0.1403353529091682, 0.15872450023649254, 0.13108387651026387, 0.13238481735544816, 0.11784140136925159, 0.1373644254962454, 0.9503435930701238, 0.970529125613196, 0.9427801695816841, 0.9217224870550599, 0.952471816774044, 0.9333130571674938, 0.9152742569432498, 0.9399504645913632, 0.9620937079150427, 0.577393567513744, 0.6092725592274163, 0.5719763833674294, 0.5294285890306387, 0.5660032170524225, 0.6122423253632227, 0.5744423000817818, 0.582289137105986, 0.5896467217488364, 0.8458686776996011, 0.8132277760414612, 0.816994378175764, 0.8504366836140425, 0.8474800537273111, 0.8219129956791045, 0.7972431959600778, 0.8450048478092418, 0.8621108341235655, 0.5095532183236926, 0.48796268901448236, 0.5507278218707603, 0.465812190136226, 0.5527226401413476, 0.4340531135871827, 0.4979892674053612, 0.6118989631238457, 0.44104670923223677, 0.2647265119899572, 0.3674908230021413, 0.2393291429658725, 0.13114115697774997, 0.5483488825169957, 0.5161923245298082, 0.4022896337449423, 0.3501832668874466, 0.35843208216490496, 0.5654710495232482, 0.5385784817143374, 0.5566620615181566, 0.5078708508665533, 0.5741858060149247, 0.6121033764770084, 0.5676066760881373, 0.5786804997948948, 0.5589749615553778, 0.6109081051617046, 0.6816177194354355, 0.6256473208825962, 0.6447655460484529, 0.6491925170006043, 0.6617418416190746, 0.671443145134033, 0.6764836657454, 0.6798450170314052, 0.29685771381763615, 0.2844680669592782, 0.33877904474073484, 0.4273367649793205, 0.48514047536082683, 0.4708827180753703, 0.2965788553222064, 0.2812638278198307, 0.18622699626078032, 0.419429992275999, 0.4678648617904302, 0.42086548861964723, 0.4350478107733806, 0.44160600480566037, 0.43046931307727176, 0.4080383651611954, 0.447778714815678, 0.4721215784617182, 0.768512566579722, 0.7846231433103115, 0.7865592975812088, 0.7728993256679175, 0.7840845129617595, 0.7689350183110795, 0.7577443911136068, 0.7812088920989175, 0.7830566227492131, 0.1344475217638159, 0.13885904429635287, 0.46596459324584616, 0.13273090637343032, 0.1374928848556468, 0.12213413690195962, 0.12460779980018355, 0.148172732651359, 0.13313546305070234, 0.16992195974098545, 0.4324281040662634, 0.45169332675950813, 0.1768878951145476, 0.5998897586202486, 0.16471313772902907, 0.3110414380494446, 0.2851736438405589, 0.33294459550102495, 0.5359635474059071, 0.4977485664886976, 0.5383029705651736, 0.53295960635273, 0.5307609968641355, 0.5399888164523574, 0.49843091363193703, 0.5449050033192916, 0.5457435559332466, 0.45095049141397914, 0.3901959607836698, 0.3125346564761351, 0.3348662384390132, 0.3626036802327346, 0.40739577710754615, 0.437889795781921, 0.48006804800254255, 0.4842291587394377, 0.21784945418602186, 0.1966948881877003, 0.21670762375020947, 0.1996426506612694, 0.22739415396737628, 0.2536382783374528, 0.2166032328580474, 0.21645563160273695, 0.2144775335491952, 0.21685442537486954, 0.2022964128621204, 0.1941918212181325, 0.1966346865788512, 0.20019267608708569, 0.4805120720133673, 0.6547798874729892, 0.2030440129317279, 0.5859733497024802, 0.17208234050860882, 0.17239264559553324, 0.18113428687083433, 0.8575714946696028, 0.1857234715271212, 0.1634264834584963, 0.16052533397118185, 0.8488830149553392, 0.20306793943515622, 0.16702569818479185, 0.665244120281678, 0.17946794296870616, 0.21070345559624415, 0.16769702405425302, 0.1689552534819746, 0.21006920320629674, 0.8476898576680875, 0.2128357783564132, 0.20794058371314217, 0.227848075210215, 0.18488469503056237, 0.1888858599783868, 0.212832403568881, 0.18545316784109678, 0.19320422477761612, 0.21332494302216853, 0.1969117584406661, 0.09492120000848048, 0.08749425485541984, 0.09793634955276742, 0.09186877937665616, 0.09884177774997294, 0.0885212567323107, 0.1124810848846377, 0.09253188301629867, 0.0887197943462823]}, "mutation_prompt": null}
{"id": "a7035764-4b33-4f30-87b9-929eaa2dabf8", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a more comprehensive spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic adjustment\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Enhanced Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with increased perturbation\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_Improved", "description": "A hybrid metaheuristic algorithm combining adaptive Differential Evolution, enhanced Nelder-Mead optimization, and stochastic local search to efficiently explore and exploit diverse optimization landscapes.", "configspace": "", "generation": 73, "fitness": 0.46497114105175513, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8482322452116202, 0.8468308944578045, 0.8386619452353791, 0.8413742328495926, 0.8273552477656596, 0.8410417717973813, 0.8415340772531484, 0.8516450309342005, 0.8530112738773182, 0.7105917830919173, 0.715889274407273, 0.6868148917111314, 0.7108306157734756, 0.718397158106358, 0.7175424498640568, 0.7067046220572692, 0.7150052610389541, 0.7172445183792658, 0.48362294296240993, 0.16960163535592565, 0.5022222570159381, 0.15928085503438028, 0.1473487903184112, 0.1168700953021653, 0.17961469152474097, 0.47629496977831653, 0.16388112048957004, 0.1388539427716896, 0.12080621123132662, 0.11191788006316705, 0.11997400890575971, 0.11077657985878175, 0.12138362730096919, 0.11218677928390475, 0.10736588330951868, 0.13862064403268703, 0.9703804547262228, 0.9514248829383316, 0.932781722762963, 0.9508333306698761, 0.8820714510327143, 0.9288173897508594, 0.9452954483144493, 0.9364054994901666, 0.9021373193597024, 0.5581590772415246, 0.6090784014248161, 0.6149856436537466, 0.5745125845091567, 0.6334425040409551, 0.632866757946867, 0.600573297648446, 0.6377902225933654, 0.6206616378065872, 0.7927993009203629, 0.858303628362903, 0.8036268836460749, 0.8532147613858154, 0.8495351993265924, 0.8559554395618878, 0.8441241638156882, 0.8655258408386649, 0.8442221233423715, 0.35498698278241325, 0.12982517046744646, 0.4260075660659449, 0.48269741465372107, 0.13222996787648367, 0.44325545365358054, 0.6101068325296717, 0.5001867249684061, 0.4176925121742906, 0.1543771616606262, 0.16995977899005787, 0.416544534545926, 0.5938455108362104, 0.41133228348261797, 0.7141831438648083, 0.4357077879019291, 0.212699855033609, 0.333565882742611, 0.5749553551521589, 0.590063850623913, 0.602350035818962, 0.5506824729563744, 0.5855744127273583, 0.5842830443505707, 0.5673337143408134, 0.6192550708732987, 0.6179905634646885, 0.6657531956201693, 0.6801688897820356, 0.6934401460496369, 0.6262018029304682, 0.6917319780155684, 0.6909201562834438, 0.6622124291731093, 0.6838902188352909, 0.6906463240064032, 0.3179372676048712, 0.173528877171927, 0.2624951703095394, 0.4188830221017683, 0.4475902222343783, 0.4403256724387693, 0.19181144409989714, 0.29983343245302807, 0.24115854562023875, 0.4115751085108079, 0.47485059608394664, 0.45083700102221214, 0.463213277729285, 0.46284044575105665, 0.4228804881614887, 0.4458611229801065, 0.46592726279803887, 0.4437878476049629, 0.7960823321367502, 0.8033995083051576, 0.7803061561145763, 0.7851345850812192, 0.775975038028849, 0.791805903980739, 0.7857148477768874, 0.7961890998530118, 0.80731518403514, 0.13739799798142227, 0.14002716846341812, 0.14431302759930476, 0.39082674346065593, 0.12649422439898972, 0.1622964344312502, 0.13082459223110765, 0.6266238704818664, 0.63407174744922, 0.1613444524200499, 0.20715958107183785, 0.28383354107747794, 0.1951017921977638, 0.19513420438974294, 0.2529411122818169, 0.21622887584504147, 0.2920933162903583, 0.5977150239343755, 0.5396371785349792, 0.5592647497246137, 0.5758868627037907, 0.552641743467283, 0.5381159772820866, 0.541206317250925, 0.5796554644145978, 0.5943855370245477, 0.5865512989396608, 0.42196819783236106, 0.4280626530410534, 0.4637331611085147, 0.41713837228279926, 0.3492636604810311, 0.443418916714559, 0.2589442763782702, 0.47687809742523946, 0.4199871847260347, 0.22588358810052422, 0.19967996320545733, 0.23702013045362214, 0.22094550730344853, 0.2162989285867033, 0.21318905100531504, 0.2301875281416238, 0.21092316106881803, 0.2119484822845995, 0.20900821020879112, 0.23811073174473996, 0.7140538114448121, 0.6460833720287464, 0.23191319686153034, 0.693585688181168, 0.19821516780645998, 0.5191316514249781, 0.23692968551926674, 0.18395955911397355, 0.19909716289473622, 0.1695255485922158, 0.16238029943447985, 0.8916733151853795, 0.7907461362695866, 0.20751669221223712, 0.7368042984415721, 0.818806701636441, 0.16424466286686334, 0.8533484577499302, 0.20952248592459677, 0.8666864833638454, 0.1663418615214396, 0.1683420811704116, 0.21029100661313982, 0.2115572271984829, 0.2117645260641482, 0.2321118318915485, 0.1924400016857457, 0.18689766648741002, 0.19123800084592024, 0.19673882294965916, 0.2096796904485827, 0.1895849177570783, 0.19374867335430368, 0.21007915532630617, 0.10254342282118523, 0.09864502995541191, 0.09994692454233356, 0.08917004564404596, 0.10008082394105478, 0.08778544968241098, 0.1427806341173653, 0.11421945009196333, 0.08641934798880357]}, "mutation_prompt": null}
{"id": "b76b6a0d-c886-43e0-a0be-ccf588ad53e0", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_QuasiAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.5 + 0.15 * np.random.rand()\n        self.simplex_size = dim + 2\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with uniform randomness across bounds\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with quasi-random sampling\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                candidates = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = population[candidates]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                \n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step with adaptive reflection\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.3 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with broader exploration\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.2, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_QuasiAdaptive", "description": "A novel quasi-adaptive multi-strategy hybrid algorithm integrating Differential Evolution, Nelder-Mead, stochastic local search, and dynamic parameter adjustments for robust optimization.", "configspace": "", "generation": 74, "fitness": 0.3902814899446163, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_QuasiAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7928185933494752, 0.7969348102298777, 0.802187682736998, 0.7998240466568267, 0.8114601945476232, 0.7992420265150237, 0.8014165276254739, 0.8105466440448862, 0.8038301857826254, 0.6378465293358818, 0.6323176330052359, 0.6406277406605102, 0.6120716783658959, 0.6313656228012536, 0.6326065192709657, 0.6402744896593162, 0.6285110971875039, 0.6347156861172567, 0.3098421677681439, 0.16029359726691494, 0.22185089500408506, 0.156332006910059, 0.2810194895329786, 0.14523255012668979, 0.1425885067143674, 0.14042055807980125, 0.16091598665801687, 0.11372978885902452, 0.11767364158365123, 0.11761321260168822, 0.10743457209697282, 0.12469132257252769, 0.13793769261366873, 0.1392119947449031, 0.14121241777979698, 0.12670780264959103, 0.9405519347960707, 0.924315419396444, 0.8992765172744686, 0.9217300435601157, 0.9243219404285214, 0.9328943046329317, 0.9281340358258459, 0.9335348821023641, 0.9550277236427669, 0.45140407296099383, 0.4440340381744031, 0.47572668015789277, 0.4804385708674581, 0.4523678907087747, 0.46451571398537406, 0.4873608272485783, 0.4745594772614812, 0.4511326447636749, 0.7790747089279699, 0.8178771689638399, 0.8498578116149046, 0.8363414369193456, 0.779144587221169, 0.8403200642329719, 0.8282913612996505, 0.7843405521918706, 0.8058569791359442, 0.29990788588052897, 0.4022716241095613, 0.2670759577179427, 0.18260354944011203, 0.2299276998303842, 0.22203894300814386, 0.3539619133871942, 0.2220135173636152, 0.3193743344680422, 0.18511422289694002, 0.3353387612002431, 0.289081671668477, 0.21230739037551638, 0.3291221885417076, 0.22841763265376014, 0.31121971330589804, 0.29900481935191214, 0.12325320072234958, 0.34517211825981864, 0.3415560820268726, 0.3743204756829832, 0.3432939071399582, 0.4005261905979872, 0.39577185754687116, 0.3546242196112712, 0.3944000025529978, 0.3559717687329276, 0.4964039754240477, 0.5223394359540336, 0.5206330198458504, 0.5321116803874932, 0.542605432449449, 0.49135461579756234, 0.5498946277560726, 0.49454155425692214, 0.5678770155159529, 0.07951750030739935, 0.220043776247702, 0.1290334282886606, 0.20081378372388148, 0.2442513272803728, 0.21450593023912745, 0.1291462739585515, 0.22915725583495195, 0.24562825697773027, 0.31581802883662713, 0.3335579411391981, 0.31208734412506633, 0.32245720528707766, 0.31618526144529524, 0.3318700497531879, 0.2908556455963597, 0.30922763944961373, 0.3021037779828897, 0.7004936633454294, 0.7005684783312858, 0.7109524148129595, 0.726278360604336, 0.7061962244922835, 0.6987114567422574, 0.7099520516007548, 0.7052416430710999, 0.7055438625841162, 0.12709294033823082, 0.11794953438618139, 0.12126647906083432, 0.13870158531026722, 0.1498203169883644, 0.16860606680735413, 0.1257541632978142, 0.15389033497555027, 0.1182156883376887, 0.21169184641629712, 0.18264751820732306, 0.20176083658149002, 0.2514374992921571, 0.17144186593433974, 0.18461378729488642, 0.16907352872799142, 0.28492989737309027, 0.23751516340425038, 0.4303432810735509, 0.4891644598461019, 0.44427520073661286, 0.4357868585909389, 0.47998491025224865, 0.47411667620337816, 0.490539005293538, 0.48935477997451726, 0.49901480242726415, 0.34758988651044076, 0.35039304163553286, 0.3428176974488004, 0.32838204010110517, 0.36935960965973125, 0.3594446545727481, 0.41649227482848905, 0.37469827618962515, 0.3640599052831429, 0.20310852367982102, 0.23033686978151635, 0.2228349259364304, 0.20422380710156374, 0.19469002537058333, 0.2194952883654142, 0.261036473081271, 0.2122094914095065, 0.20947025431127386, 0.20337953195871739, 0.20332974153010053, 0.21458895869867967, 0.1760896046274858, 0.4395092859998635, 0.23546473503079945, 0.2302378290575109, 0.2331942673816365, 0.1930635847084199, 0.18524537348695025, 0.8523527621980789, 0.1963505124947117, 0.16255679734996753, 0.8336084235296195, 0.13961911662262627, 0.1641661036583082, 0.8406035604911637, 0.8193541899956042, 0.16463307549787154, 0.7797058273930183, 0.21094391567558213, 0.2035321867125438, 0.1695348212427431, 0.16763143561117866, 0.20119123070243117, 0.7873891700826874, 0.7547073592280947, 0.1929404937841097, 0.1980473257084554, 0.1860991780469159, 0.20058667730204516, 0.19238016789600343, 0.2021178393966896, 0.18712391006375084, 0.19667774525996917, 0.19825215814500274, 0.09188006741691335, 0.10111335147155753, 0.09990953070888486, 0.089571748841616, 0.10898523516757175, 0.10153735493747351, 0.08918846884374565, 0.09881363070298432, 0.10259258370682112]}, "mutation_prompt": null}
{"id": "a3b430b7-b7fe-4426-9acc-65be5bc676de", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 6 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.6 + 0.2 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Refined Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.4 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.55 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Adaptive local search refinement\n            for i in range(min(4, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.12, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedAdaptiveHybridDE_NM_SLS", "description": "A novel adaptive multi-phase optimizer integrating enhanced Differential Evolution, a refined Nelder-Mead approach, and adaptive local search for robust optimization.", "configspace": "", "generation": 75, "fitness": 0.4456414253121442, "feedback": "The algorithm EnhancedAdaptiveHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8699160854682988, 0.8569589484598604, 0.8578124218544797, 0.8687158294165382, 0.8681392659472031, 0.8635429639746104, 0.8767119665299148, 0.8651733662134904, 0.8646805274026839, 0.7228790486429718, 0.7543155771255072, 0.7010722990147391, 0.7349448574894168, 0.7554987699426149, 0.7666874469690313, 0.7494201072861408, 0.7527346707774116, 0.7331084510677867, 0.5094339842030036, 0.15258652850117138, 0.17189576017202557, 0.15056864269950543, 0.1170603404339512, 0.1621761642184707, 0.16175489862770898, 0.14667984970912407, 0.1807987947009846, 0.13590598973084456, 0.12594478484348126, 0.10839208069482209, 0.12964615522037315, 0.1269366942168919, 0.11962966683586362, 0.1476927233053913, 0.12462066826573259, 0.12159354706829928, 0.9713325046865782, 0.9386313285902688, 0.9536862546631857, 0.9326495150426246, 0.95992194078402, 0.9470594651719697, 0.9667768419655819, 0.9400302193320793, 0.966682839886355, 0.5577949506389097, 0.6585309052157149, 0.6133416394783787, 0.5834486456008714, 0.626090050701336, 0.6211249797062854, 0.5848606707139652, 0.6249459231083119, 0.6354894916851094, 0.8896162866501821, 0.9011864820282884, 0.3805052423660975, 0.8470396546419396, 0.88483166907505, 0.8796735146131325, 0.8470974111898187, 0.8635770383603087, 0.844542421469479, 0.4330989424028391, 0.4820293012202126, 0.5606732592504116, 0.44486568510438096, 0.540154357958737, 0.5225328634950706, 0.4759042166265435, 0.6140859647395187, 0.49967879620063493, 0.5107376312269574, 0.5458365604640472, 0.42775173962437285, 0.6585386757019893, 0.5431881782471082, 0.5195589593093505, 0.3987959794284368, 0.5868450185844862, 0.4788121919568906, 0.49199989596155047, 0.5625454395029809, 0.4947507074963936, 0.47195988833238234, 0.570563617944241, 0.4020476633061252, 0.4843726682551598, 0.5682679893746647, 0.47412286317770336, 0.6225075917452215, 0.6530147111830122, 0.6667545941653095, 0.5996440281328701, 0.552661750210045, 0.595385617172184, 0.6614123281417741, 0.6402224701540906, 0.6657986932147324, 0.08621566875654008, 0.2982014309821551, 0.1045570853774519, 0.36308064087999303, 0.24060744304007464, 0.3105570483758041, 0.26435911274867163, 0.18878636798967385, 0.3126969223707552, 0.3610967078102405, 0.44417560818435176, 0.39874226165037174, 0.43857456503321857, 0.46680139382526553, 0.4528195826174739, 0.44249748887689455, 0.40261278178815985, 0.35964813029937337, 0.799360123117673, 0.8014066573925963, 0.798039608848978, 0.7764319433748963, 0.746651428356522, 0.8049441257624133, 0.7766347647921394, 0.793979995699424, 0.7761446619185655, 0.13048153748492664, 0.10974020345529711, 0.14175697838911872, 0.1454148040992964, 0.11662127977794334, 0.14231208843847454, 0.11638353441985005, 0.14012247455330584, 0.16618244919987957, 0.38151964233785496, 0.21946902703463134, 0.18709666889199794, 0.15139032360408333, 0.21963197901616072, 0.24128554164925553, 0.27172351669147843, 0.25156820919521916, 0.22411880668435902, 0.3445512735988756, 0.5523332763645922, 0.5573513531319654, 0.5028388064506002, 0.5951507053158002, 0.5522795850145564, 0.6339006325176357, 0.6179228230430727, 0.6308082798320717, 0.41075199181518907, 0.3819183541061648, 0.3784226803526449, 0.28063047776314654, 0.4441228698370637, 0.46020318806408855, 0.4458911170076667, 0.23022126027010004, 0.377516118920068, 0.2137742014861087, 0.21131906072631923, 0.2295398392547624, 0.21618638078034003, 0.21392547040222154, 0.2194484476008287, 0.2119380267033144, 0.2275212483286858, 0.21481517526629879, 0.20505704855336715, 0.21377916062202806, 0.6666004620178452, 0.2048741159739902, 0.7272017234561067, 0.24672853095891745, 0.19629487777952281, 0.19339948391360817, 0.20147174448933425, 0.1862135223770569, 0.186803704214497, 0.18752366020899158, 0.19396001482083658, 0.8905307012568059, 0.1971431713464714, 0.135381810716665, 0.16873388048815163, 0.16745693750964907, 0.20417124284676336, 0.8551807953743487, 0.8937906402674127, 0.16791382139880584, 0.16808913581582252, 0.16895117420991668, 0.21298762772650903, 0.8493142232090477, 0.10481970000876895, 0.20451069294255197, 0.1849183825005637, 0.16757835716866543, 0.1772651244323602, 0.19579145557853606, 0.18069887273156304, 0.19544910920338587, 0.18236696945223207, 0.19296728533482832, 0.07772252793968859, 0.1085134763070913, 0.08861215712603898, 0.08051371121993633, 0.1013729712692224, 0.08556770025944993, 0.15289892939942706, 0.07965127407856232, 0.08883209676219361]}, "mutation_prompt": null}
{"id": "aa0cb680-d663-483e-bf06-13f7473f5565", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_v2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Slight increase in DE step size\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step with adaptive control\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.3 * (centroid - worst), self.lower_bound, self.upper_bound)  # Adjusted reflection\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.3 * (centroid - worst), self.lower_bound, self.upper_bound)  # Enhanced contraction\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with perturbation\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Increased perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_v2", "description": "An advanced integrated algorithm combining Adaptive Differential Evolution, Nelder-Mead, and stochastic local search, enhanced with random perturbation and adaptive simplex updates for improved convergence.", "configspace": "", "generation": 76, "fitness": 0.4349797810323705, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_v2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8206895615789503, 0.8424135661638921, 0.8358411723882762, 0.8480461207401433, 0.8322729384486783, 0.8360510494447878, 0.8315480760008932, 0.8223548212948371, 0.8322488421645652, 0.6812631883513602, 0.6810157816327841, 0.6950945124516874, 0.6803262734817602, 0.6754774843326126, 0.7072159727306584, 0.6889509985076119, 0.666653773838134, 0.6892184455107189, 0.15798995394840165, 0.152900460874694, 0.5982912946347718, 0.1287305755855136, 0.15965214552509677, 0.49632963225907156, 0.21659459397811776, 0.1755050038068091, 0.15863404277280757, 0.11930543057755638, 0.1142366291162149, 0.13354945289932152, 0.12928441208051722, 0.11124763716750441, 0.1370538562561806, 0.12387271689669321, 0.12183131827359939, 0.13004772755083627, 0.9503876486166736, 0.9264555978900361, 0.9719436231073582, 0.9483565115793527, 0.9298322114552292, 0.9662819543722853, 0.9494762855238896, 0.9302436121821908, 0.8990135044417754, 0.5004740224579722, 0.528125327989649, 0.49465108746896336, 0.45849018011910947, 0.5209568130665406, 0.4965250777696226, 0.5336811159748811, 0.5246504982430147, 0.5380710326318375, 0.80409231358707, 0.7724275436301528, 0.8277130175632947, 0.9018623559533636, 0.8276735237422982, 0.8302981930377251, 0.8538029428893105, 0.8130138891870989, 0.8429561678014948, 0.3335040158488285, 0.44835186446939146, 0.3745405031073985, 0.5393790224208133, 0.5306340007306914, 0.30292966759886353, 0.4312196975275113, 0.3972606495322377, 0.5891247864265172, 0.6179153715012531, 0.12770923686176938, 0.40566830521030395, 0.48755584033417876, 0.5226947766031986, 0.40137695053901323, 0.3793835634649918, 0.3986089669164651, 0.3998923304124544, 0.5246967563023156, 0.5646738487603669, 0.49084644633610974, 0.4601516663606289, 0.5515722462338127, 0.4826501900730321, 0.4805128975064047, 0.580897698402435, 0.5293726117789713, 0.6103648696283592, 0.6454985039331722, 0.6180091511702587, 0.5660474200440442, 0.591535308245543, 0.6030394046404288, 0.6472745137976567, 0.6232800278382726, 0.6122070024284197, 0.17230162881080668, 0.26896168208124316, 0.08057756244674563, 0.35134143582970856, 0.2540435374994042, 0.41884935989256067, 0.14870558125357092, 0.19526762823482546, 0.12363858511524017, 0.3997592383685896, 0.3843697660919796, 0.4283752546798413, 0.39908366576007426, 0.42080412952086865, 0.3887169928993367, 0.37895592146227375, 0.40444561316048855, 0.36704727492683986, 0.7462378561932794, 0.7714308282365017, 0.7817685132017296, 0.7649217424019336, 0.775349597357946, 0.7487183376641766, 0.7535735732707014, 0.7676031060497515, 0.764975738537411, 0.12297420690304584, 0.11652727190566625, 0.10590265256427556, 0.13521334687940612, 0.1776691146954621, 0.10960142446601873, 0.15800620038673063, 0.16866681751241064, 0.12072481943587976, 0.229745576545216, 0.30899217359804676, 0.4708235154388508, 0.25948581469057097, 0.465617614255723, 0.6001244442329883, 0.23416891795518302, 0.2253153675064904, 0.1838551414279357, 0.43258009971075273, 0.45227793815271633, 0.4601049091818534, 0.4563196172384837, 0.4798430339014953, 0.49069753829557883, 0.45136077542175856, 0.5110957744628755, 0.5385107372188827, 0.3556778967650084, 0.43584019117866213, 0.3484749604930506, 0.398398283187842, 0.39357641702856605, 0.381196851673695, 0.3690077680165086, 0.3476961883403674, 0.39696329241578665, 0.22766637615665308, 0.20113594033034998, 0.2137652516551949, 0.19282742717034507, 0.20371875425154362, 0.21174829819546248, 0.20557404383862943, 0.21029335603187427, 0.20999010023321418, 0.20702361560751892, 0.22555162756032932, 0.21564532518849344, 0.35276681223980244, 0.21495102977542724, 0.20636783323227392, 0.22877601026474947, 0.21463074606388, 0.2302096489800296, 0.7199004372563507, 0.8681730006404093, 0.16992810606501918, 0.16813800567336878, 0.20848035541332277, 0.16139621615180966, 0.8503912327008081, 0.17687900238900733, 0.7884944491736287, 0.12804080983720556, 0.8566208091974319, 0.20864564211804904, 0.20921430459735102, 0.1671408429743173, 0.1675056853863971, 0.7834199824027315, 0.7352703273759653, 0.21313272338325828, 0.17349308044426093, 0.20399485227803893, 0.1860275508346253, 0.18100894976484483, 0.18615084657247338, 0.20568424310652667, 0.20401127249807982, 0.19253674278568, 0.21022419980109797, 0.09541582594052311, 0.0838494787321784, 0.09703226885775817, 0.10463832867531841, 0.09366452018506666, 0.08471944460310188, 0.10882439975786362, 0.09982605304842596, 0.09468004302799726]}, "mutation_prompt": null}
{"id": "e4474767-5ec8-483f-b103-0b4f5a8c82ca", "solution": "import numpy as np\n\nclass AdvancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand() \n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  \n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            for i in range(min(5, self.population_size)):  \n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdvancedHybridOptimizer", "description": "An advanced hybrid algorithm combining stochastic evolutionary techniques with adaptive local search strategies for robust exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.4771458526587456, "feedback": "The algorithm AdvancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "c6695c4c-a4f9-41f5-b919-98d7bca3dfe3", "solution": "import numpy as np\n\nclass MultiLayeredStochasticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 2\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Adaptive Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.3 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.4 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Targeted local search refinement\n            for i in range(min(4, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "MultiLayeredStochasticOptimizer", "description": "Multi-layered stochastic metaheuristic combining evolutionary strategies, adaptive simplex, and targeted local search for robust optimization performance across diverse landscapes.", "configspace": "", "generation": 78, "fitness": 0.3800865906150166, "feedback": "The algorithm MultiLayeredStochasticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7986491085316325, 0.7918306238783641, 0.7896679579004751, 0.7898828051384362, 0.80673359941138, 0.772804753274473, 0.7970072951188228, 0.7952186943194157, 0.8005955551681372, 0.6227113121354558, 0.633143599826621, 0.6126192006499782, 0.5999940444611239, 0.6010970085372002, 0.6204892717200634, 0.630481175236593, 0.6110376629791883, 0.6195324794490633, 0.13598748841323338, 0.1497908646886129, 0.13870500927293083, 0.13807124981124275, 0.16767111551475122, 0.15486970824640156, 0.13181323245982202, 0.16805011527601332, 0.2188119452430739, 0.1556760683500985, 0.10818637803771602, 0.12897153286422602, 0.11844358664830756, 0.14179545653352665, 0.12332040478021988, 0.11602335004759567, 0.12010454249864944, 0.1346512279286457, 0.9271612080789958, 0.9103751519253979, 0.9467840954173067, 0.9342934346997529, 0.93821855240989, 0.9340511912808263, 0.9687423513300318, 0.9473924534119011, 0.9059556532008942, 0.431941466966542, 0.4426763297588453, 0.45061109354891027, 0.437186608846707, 0.45031195031119065, 0.431238849655726, 0.4318344082748077, 0.47537190686276865, 0.4593045963773785, 0.7345069249440981, 0.7052416399728554, 0.7247340362886401, 0.7139053325834647, 0.8053998731476266, 0.7741928757680865, 0.7310589848430828, 0.7862756665913418, 0.7859629204461838, 0.42203992608103325, 0.28743640799924564, 0.38453691773404675, 0.28518229482348234, 0.48250489159229015, 0.24586016402708988, 0.4314900173768067, 0.2611764771281798, 0.20827977778443063, 0.42554257547211904, 0.29688512046664284, 0.27033406200183985, 0.25148806711458316, 0.28542331266065835, 0.31345639748505505, 0.2511046784899086, 0.3326036645381404, 0.320387628482918, 0.31191131809006145, 0.3640488591768066, 0.3068484827251238, 0.32631005153282766, 0.4037643608387106, 0.34099246009950634, 0.30143559254884567, 0.3335689623436565, 0.2749904084827176, 0.452801985035037, 0.5098590437991928, 0.4980575880780832, 0.42530496904439163, 0.4905472730633189, 0.49383438532350943, 0.521368880041024, 0.5027062770244315, 0.49445258756483457, 0.12227478923018442, 0.2249696886096757, 0.097827002488861, 0.21288293821791338, 0.19788292202023816, 0.16076898700285291, 0.1617129659100488, 0.1560919209834567, 0.22982587695165557, 0.28391493922709454, 0.3076197636655854, 0.28458865932198074, 0.3144483094647106, 0.3426872996828262, 0.3150069365852489, 0.2708293672417815, 0.27609324099177956, 0.2970842716681763, 0.6709572687179927, 0.6716196748904804, 0.6597097281751391, 0.6708589443345147, 0.6573197336524532, 0.6932509137718332, 0.6792988786553462, 0.6745113349655762, 0.6856677847891166, 0.1614423969015204, 0.12809829877974266, 0.18113028077607607, 0.10021200364526883, 0.10769888761681246, 0.11841796184348241, 0.1363761141697143, 0.10496131383954055, 0.15000106619461873, 0.17265426119665372, 0.15848505860783402, 0.3289210958825093, 0.34646258626808346, 0.3182034294275615, 0.2700634979954373, 0.20349912215003552, 0.19010648119425677, 0.21930751844912688, 0.40158574557212434, 0.3937608892705542, 0.41601418526147704, 0.4371954723683218, 0.4726629347183009, 0.4484107633939346, 0.43960716746147743, 0.44030414296618314, 0.4379051501695156, 0.31113596637793484, 0.32605704208311603, 0.325555419228043, 0.2895196055302456, 0.3247807456108549, 0.3378138495278603, 0.3529477560566726, 0.3317475578196579, 0.3424680979441368, 0.20477588043153994, 0.1979918705359176, 0.21035951111013584, 0.212336272694163, 0.2298768883521639, 0.20500134331773456, 0.22143615836335007, 0.2041804101847332, 0.19069043522203732, 0.22496727206304845, 0.5293773757172896, 0.22095887490005128, 0.2194838204579438, 0.191118036794365, 0.2283266441540852, 0.2129719267491973, 0.21564389331423417, 0.22874251166264803, 0.1963887380248216, 0.15329160786668727, 0.18286455798994727, 0.16634672428750508, 0.7937115078636713, 0.8025388044956032, 0.7146843327005403, 0.8688164840996788, 0.16731008416364423, 0.20569242123355858, 0.1634613861319596, 0.209162525049012, 0.6695233743747194, 0.7472355328785365, 0.2085440744894682, 0.20905327497649806, 0.7556878535200975, 0.20906722427119462, 0.18280536471139286, 0.1748153756993297, 0.1754425861394524, 0.1848416045717397, 0.1791050879262719, 0.1941071991117962, 0.18784723599539022, 0.186933590662407, 0.20338930401419786, 0.08485635304675743, 0.0824197930812074, 0.09108002532427928, 0.07703327266358118, 0.08486019778564735, 0.09154204855313453, 0.09786038391943097, 0.08392101531667018, 0.08130064499862089]}, "mutation_prompt": null}
{"id": "11dc21fd-b718-453a-af47-399275d7c082", "solution": "import numpy as np\n\nclass ProbabilisticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size\n        self.de_cross_over_rate = 0.85  # Adjusted cross over rate\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with dynamic selection\n            for i in range(min(8, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.2, self.dim)  # Increased disturbance\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "ProbabilisticHybridOptimizer", "description": "A probabilistic hybrid optimizer combining adaptive DE, Nelder-Mead simplex, and stochastic perturbations with a dynamic budget allocation for enhanced exploration-exploitation balance.", "configspace": "", "generation": 79, "fitness": 0.3497107305907353, "feedback": "The algorithm ProbabilisticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.23.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7733053863334951, 0.7757153997413024, 0.7511251426916288, 0.757938566337265, 0.7695624470701095, 0.7654790543120442, 0.7819534349187665, 0.7735183217170598, 0.7826545301676424, 0.5639361212249121, 0.5585198525934125, 0.5622417957175483, 0.550534391790757, 0.5639156219067565, 0.5703592763103701, 0.5493855960883067, 0.5849030637656054, 0.5672328632732628, 0.137880365880108, 0.20388781493978225, 0.16581770985205457, 0.14603517132956534, 0.13675776897492853, 0.14224364003559054, 0.1377736458514489, 0.1331918066802824, 0.13551992050589057, 0.13604562798445607, 0.09835915387495353, 0.12141225423866275, 0.1254642234413219, 0.11019454340847423, 0.10826019097809458, 0.1184708473902163, 0.12322664714382914, 0.14664116817903872, 0.9216418802658604, 0.9518354122314555, 0.9194389041140852, 0.9587069935526651, 0.9217267705629918, 0.9557924976916631, 0.9796137540681685, 0.9573428769725973, 0.9069135412220544, 0.38813444245015594, 0.38394361409470423, 0.39893689257111475, 0.40298983344987427, 0.39577161237800285, 0.3801532898269977, 0.4230644786066984, 0.3833882673254617, 0.38787903721340466, 0.6807048825083851, 0.665852789124123, 0.7813690232039248, 0.7253787435243363, 0.7623185939340641, 0.7213847511117888, 0.7331095904524095, 0.7495605562940093, 0.7071912951745547, 0.22199495127414492, 0.2839021706072997, 0.3090767533283, 0.212643324312344, 0.2213031693152815, 0.12446155948117754, 0.28803106038855875, 0.3111890382860222, 0.3196851679155033, 0.24919742035597792, 0.22246117451579295, 0.2451308919984041, 0.29535601352884233, 0.2178144295856459, 0.35837972223630654, 0.20831433190571613, 0.32887593031370843, 0.23672000837650686, 0.23169554449168783, 0.22962969584447457, 0.26098518059894626, 0.22528299992358247, 0.26540204548855784, 0.2502823667461731, 0.28985829358005477, 0.24667668130516063, 0.31414082206680705, 0.4277854175109995, 0.4446312834760612, 0.429382473659107, 0.4198749788959856, 0.38623896192235785, 0.4067586326668816, 0.43049023071254844, 0.45247375663149125, 0.4699796568329683, 0.11757519723620846, 0.11352471949857879, 0.170195047406001, 0.13427452084527614, 0.2106885068149027, 0.15845818682822865, 0.09766165320619968, 0.1111267303859984, 0.14879090266711592, 0.2446974720532511, 0.21536086196963655, 0.230458688026137, 0.24964792475445907, 0.24254642632952095, 0.28192545787989143, 0.23352676813715756, 0.25594427489883487, 0.23895704815867735, 0.6353961143864633, 0.6414780833556565, 0.6334540691991406, 0.643098989532449, 0.645264314107381, 0.6280619212752053, 0.6341353608797349, 0.651710027972868, 0.6559676088305721, 0.13188887989570353, 0.12552059551606198, 0.1204868618024959, 0.12077940766068618, 0.12912763603324218, 0.13258382679915026, 0.1131925797613198, 0.1254211335198957, 0.12615396459828776, 0.2406872304305473, 0.1923011575944391, 0.41661658999935647, 0.23115011202683966, 0.21383257720185334, 0.19900723601533665, 0.19475768895465861, 0.20464777266928103, 0.19045222884121715, 0.39226875515571014, 0.39359535118291744, 0.38697510862407103, 0.39721943067311527, 0.40575809096571336, 0.3773219625367036, 0.4028681899798072, 0.41610537557450966, 0.4469108410695888, 0.2796345597776375, 0.3094229981453295, 0.30607547028881565, 0.29813154845053536, 0.2787312067711343, 0.30784889256728976, 0.28853498874610894, 0.27216918718019134, 0.30632047974266685, 0.20641078076452946, 0.2502029868579463, 0.23227592590224522, 0.2166640752993617, 0.21511282751970462, 0.19735957395502868, 0.20425593213140303, 0.21344804833368147, 0.2424469645214834, 0.21063453981285385, 0.3850067780255485, 0.23415856306855864, 0.2159067275942046, 0.21416086122771139, 0.22056056866878448, 0.4176864042282017, 0.22806006234890053, 0.20769970218265776, 0.19728376293184002, 0.1606342300869723, 0.1845169638687243, 0.5107761947502623, 0.7769945492907747, 0.1837850421170979, 0.16539243522308444, 0.16769656713391146, 0.16727613609415637, 0.20681240635430354, 0.1669067310080241, 0.2109368054995382, 0.6651612039326662, 0.6210968420773049, 0.1675013202740645, 0.209601397343532, 0.69498091452828, 0.6597926210797003, 0.19285915169857804, 0.18601889503109226, 0.17617033981318486, 0.19186447220543867, 0.18624606188237747, 0.20471199072060797, 0.19249027875903935, 0.21586085112888542, 0.2024456014884598, 0.09948050712922463, 0.09237959612184332, 0.08740571090809512, 0.09094984486907653, 0.09297642304532805, 0.10006508724596874, 0.10833715995681836, 0.08978898118872092, 0.09012878432741922]}, "mutation_prompt": null}
{"id": "456f078c-9b6f-46b9-971b-41f2a9929dea", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 6 * dim  # Adjusted population size for potentially faster convergence\n        self.de_cross_over_rate = 0.8 + 0.2 * np.random.rand()  # Adaptive crossover rate\n        self.de_f = 0.6 + 0.3 * np.random.rand()  # More dynamic adjustment for diversity\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                # Increased expansion factor\n                reflection = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        # Adjusted expansion for exploring beyond\n                        expansion = np.clip(centroid + 3.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.75 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(4, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "A novel adaptive hybrid algorithm blending multi-strategy mechanisms, including Differential Evolution with adaptive crossover, Nelder-Mead expansions, and local search perturbations, for optimizing challenging landscapes.", "configspace": "", "generation": 80, "fitness": 0.4172790447958801, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7821146924085276, 0.7900580256304615, 0.8600471780176564, 0.7897056019963064, 0.7917454892320316, 0.8518904124988024, 0.7903469707393188, 0.7998721596617683, 0.8543447540835406, 0.6111018610357335, 0.6059645352915825, 0.7262924012500216, 0.618398125113844, 0.6220495000722108, 0.7300909062252326, 0.6175145339034291, 0.6132007406682012, 0.7355104230847233, 0.17831530985255217, 0.149762126331471, 0.6722194336584262, 0.14623117154384524, 0.16872115154820455, 0.13033082528603535, 0.12264722151031471, 0.13848351452931107, 0.15807382837062955, 0.15371897018316072, 0.13831466157344074, 0.13041753581127613, 0.1464922456539196, 0.11702642347290204, 0.12784121919786506, 0.12884383586809767, 0.14875103792090705, 0.12768551414663765, 0.9378518740522703, 0.973192669661386, 0.9243163934834986, 0.9319888282843665, 0.9255710738782512, 0.9162292256515335, 0.941975812766343, 0.976261454706735, 0.9238751917606978, 0.47823838261582774, 0.4671807960670653, 0.6034656804152181, 0.42640096487524415, 0.46226410848665656, 0.5866559081571981, 0.4471399304846627, 0.47050211794995056, 0.6081703322574592, 0.8388540682678579, 0.8043049971396827, 0.8932419941097979, 0.8396115973978561, 0.8126954364837533, 0.27599633551126823, 0.7726839473976718, 0.848494613144251, 0.8694373104617928, 0.46507111629381603, 0.4461224269929541, 0.13095692619802213, 0.5362325394992169, 0.4091049105764054, 0.49556935164368354, 0.13011562591655146, 0.525650378763979, 0.5118314548690635, 0.1329771099587842, 0.5435617241784076, 0.483006884742576, 0.5485666179654403, 0.45624878411660885, 0.43085406590679265, 0.5199125479687934, 0.35401282791150757, 0.5451214054202704, 0.42526003413632474, 0.40400972360808496, 0.5512353026951352, 0.4455719072825566, 0.38862805542498324, 0.5957666387403324, 0.3996864949931326, 0.398053915127871, 0.5623841167089683, 0.5798790814806709, 0.5609622332543824, 0.6620597013132241, 0.5193756151253998, 0.45883408921291524, 0.6499240465892591, 0.5881098113063865, 0.5681811083713317, 0.6801502561302126, 0.0970848501257966, 0.19517810759821463, 0.09057992169771112, 0.1592719128249631, 0.2475817381266867, 0.4415029944138017, 0.20232253864416194, 0.21146145256869342, 0.2526873351644856, 0.31324735480168786, 0.292376465290092, 0.46304097757225293, 0.33655342442397584, 0.3328657448539053, 0.4441643287407335, 0.3389183388137387, 0.3173207119103585, 0.4104203385704204, 0.6769836972242095, 0.6968709643862765, 0.7804319984920118, 0.700450239060456, 0.6952183069353195, 0.781331228707068, 0.7100473371227423, 0.6938978169679293, 0.7855424841213507, 0.12216853534669536, 0.09356185928467808, 0.1372555655118023, 0.13018452859937957, 0.14449243877355433, 0.15605887482196923, 0.1321700267309749, 0.12418000961741271, 0.1082255986404893, 0.26152104270523735, 0.15051946180730646, 0.2965363315711751, 0.2202467425050454, 0.24010944866886086, 0.7212629150026882, 0.36747946294732226, 0.36558255126488326, 0.15514271712550998, 0.518467043093485, 0.5292863373470305, 0.663498327127392, 0.5474032446949693, 0.45720397556654035, 0.4732865187091113, 0.5719696000421348, 0.5513232551565901, 0.5986339813353592, 0.4043642221472341, 0.3056395137885609, 0.4109850521155375, 0.3510394196940869, 0.43384676167372305, 0.3061908448899726, 0.21195629958910078, 0.40281206808401115, 0.4451195598342417, 0.20385934184127819, 0.19035752888565027, 0.20817426379285742, 0.20718792744171155, 0.19884578046870915, 0.20703281647879368, 0.20107636602598555, 0.20234765560474288, 0.1988281739629929, 0.21906828199756323, 0.2059181456010568, 0.18974663710043305, 0.2034750171145968, 0.22297261931368806, 0.22108723383049234, 0.1840821156222927, 0.2153078648685961, 0.20668977722622384, 0.19509503854640275, 0.8612194329596368, 0.15308197438468285, 0.18445485686454355, 0.1935745608174595, 0.17060241733289672, 0.17779492031588184, 0.16170399250169576, 0.870182419700731, 0.20916223457877714, 0.1668503960613541, 0.8637951755037886, 0.15395130913812904, 0.20942317023516066, 0.8632224372030681, 0.2064656302457366, 0.8417982812517877, 0.16657312558817972, 0.19396286309036692, 0.19072743173743723, 0.21963575184816742, 0.19839397803720515, 0.1917793327307411, 0.1992501169525538, 0.20635437558740544, 0.19440741344303236, 0.213270203778274, 0.08948674803891099, 0.10402352579397689, 0.10622455541733777, 0.0928742869907937, 0.08975184770862454, 0.10518381435295432, 0.09267599010768734, 0.10763283920028022, 0.09083872244895497]}, "mutation_prompt": null}
{"id": "974b5dc0-e8df-4ec2-8342-845c22237e42", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined multi-strategy optimizer combining Adaptive Differential Evolution, Nelder-Mead simplex, and strategic local search to enhance solution precision across diverse landscapes.", "configspace": "", "generation": 81, "fitness": 0.4360758260401163, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8071323980063336, 0.8109788287032155, 0.8063322303719306, 0.8162309425310289, 0.8285549678435172, 0.8179694627900993, 0.800943928789188, 0.8244090984310795, 0.830050103248363, 0.6488383369717252, 0.6627698175366092, 0.6719085037428207, 0.6502789457571648, 0.6852638585050286, 0.6755481932652807, 0.6537795284459451, 0.6741479738707198, 0.6794491876209042, 0.1746011208729813, 0.14363916459493542, 0.5144920384975797, 0.17882144038787118, 0.5651566533235939, 0.15215974033201995, 0.14178311148413525, 0.15554607256338782, 0.15029054430493738, 0.12427723011726388, 0.12755306271524658, 0.1258607661232829, 0.13700801989524192, 0.11522580890088996, 0.1402105050613407, 0.13075693858110393, 0.14129769750608845, 0.14560746347472886, 0.9178489638379463, 0.9489098972474679, 0.9531002832331634, 0.9202564278777053, 0.9156517997477526, 0.8932272903839993, 0.8979374868487022, 0.9245965449021865, 0.948041245291921, 0.564162779096089, 0.5779792339409886, 0.48812384675104026, 0.5416546417861723, 0.5587420351369676, 0.5336400454356434, 0.5505448514003684, 0.5545840604266634, 0.5352662815162683, 0.8521902189463194, 0.854757556697157, 0.8520860790515978, 0.8790209818483088, 0.8922006712217816, 0.8546612638405048, 0.8311906329513228, 0.8479707262035681, 0.8608078835461904, 0.4439998512914938, 0.3974798658001948, 0.4593013149862367, 0.4597104765269877, 0.24303042304951028, 0.2631836465887877, 0.43082693523032645, 0.3278810750821233, 0.33870396886194265, 0.13281482069844097, 0.5695018958068759, 0.23234990810535572, 0.4684950093801631, 0.3561398874651971, 0.4025392022786204, 0.39706548421090404, 0.38270841486355434, 0.4990467654218125, 0.46592151943055793, 0.4581132204169235, 0.496857764399966, 0.44560514111718075, 0.5221064091598857, 0.5074989206543081, 0.4641880821335278, 0.49576648919585564, 0.4767656116938719, 0.5796451715080357, 0.5978683406589251, 0.5880045508535809, 0.5862617177564328, 0.5717419915397457, 0.5760406709378281, 0.5745420180910532, 0.6108480176950222, 0.6409756792455559, 0.04988335621004969, 0.15633556368671597, 0.2500254110740281, 0.3221959612936206, 0.3490597793363356, 0.3830652013054834, 0.2189360479940614, 0.2661154495246838, 0.18045932080072236, 0.39484821636835477, 0.3839749515390878, 0.3784854779662218, 0.3717025073561776, 0.3764664956766868, 0.4126048375419745, 0.37950723446143486, 0.36084641087060343, 0.3740001319224784, 0.7314193742222621, 0.7316988293906315, 0.7487858416774498, 0.7313543442611972, 0.7610101601120857, 0.7246869584284351, 0.7137956319435846, 0.7378123961434232, 0.7487400787455714, 0.11809094333275372, 0.13840102350233952, 0.15434377853311632, 0.11743619168230035, 0.17747287645098753, 0.15576274700113768, 0.13687030361688557, 0.15186675698366947, 0.16698571723346212, 0.16983937498791146, 0.2674195836258606, 0.20078888005376117, 0.1849723170554588, 0.5036981729935202, 0.18112755357291555, 0.17666507806711707, 0.16118304124704186, 0.33577535454512186, 0.5180208545989304, 0.5858409933446177, 0.5697374357766524, 0.5546118223297787, 0.573006359769799, 0.603255395488909, 0.5812488356902028, 0.5931466170439519, 0.5512126467702418, 0.4140637880938901, 0.44031254867838, 0.41538989796758874, 0.44699117266384025, 0.44323869122141824, 0.4968796647522641, 0.474235944772159, 0.4220046966922977, 0.45038437395425013, 0.214384348552641, 0.20824210707476654, 0.2194463774356945, 0.22801938618410167, 0.2294814384608369, 0.20100624220935948, 0.2208384403021032, 0.2082100594817905, 0.2878558778832613, 0.2291113877973312, 0.21180329451590174, 0.19171785567073307, 0.19820700264379854, 0.5924530557309036, 0.5488869968532215, 0.2170486078919176, 0.21659123759069976, 0.6093147701843578, 0.18524576419971384, 0.8282386507062574, 0.15781247148980293, 0.818043495091038, 0.16738859961233832, 0.1884626662388479, 0.7736196157784768, 0.17502925978632533, 0.826202810069346, 0.16561270991921195, 0.8001389372481726, 0.21143470742204395, 0.20783824447409927, 0.20845541985590066, 0.16690423269498356, 0.7177798696291806, 0.21007461957553542, 0.8134602465955113, 0.18033706698692153, 0.18915069256779693, 0.18528983294438173, 0.18450318912814945, 0.18993444656955294, 0.185611058460891, 0.19924526704856005, 0.18661447583800872, 0.18625381956447973, 0.10225376265280306, 0.09769345545615393, 0.09165438027417316, 0.09013622936883714, 0.09174963361185473, 0.08810161436674857, 0.10594540625758542, 0.1040338604707104, 0.08785434582724061]}, "mutation_prompt": null}
{"id": "d90aea7f-f108-4f99-a9ba-3d6d67bdec2d", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.6 + 0.1 * np.random.rand()  # Adjusted stochastic factor\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with varied density\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + 1.2 * self.de_f * (b - c), self.lower_bound, self.upper_bound)  # Amplified mutation\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(6, self.population_size)):  # Broaden the top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)  # Enhanced perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "A robust hybrid optimizer leveraging stochastic mutation strategies and dynamic local adjustments for diverse optimization tasks.", "configspace": "", "generation": 82, "fitness": 0.37849876680576106, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7519907632188682, 0.7734245610036571, 0.7683396600219314, 0.7552564522024536, 0.7947445508727073, 0.7744540997403428, 0.7737602436173201, 0.7723160117116187, 0.7925321718167775, 0.5579961641631839, 0.5996698459914966, 0.5913565731748724, 0.5704546978988607, 0.6085779319897162, 0.6022216030660015, 0.5722382341944956, 0.5483302794048761, 0.5855337186245699, 0.12142523065747224, 0.15676241046306927, 0.17172232361548045, 0.15800504383303982, 0.1350444635583381, 0.13939456264659544, 0.1976548028344527, 0.1697694400477121, 0.15888587192790804, 0.09875495548025304, 0.12344917314683301, 0.11844401394728488, 0.12995637874814725, 0.11783395755280313, 0.14145179761918514, 0.1054811146541128, 0.11986381086878206, 0.13551783803274375, 0.9534048247013308, 0.9285623052957878, 0.9828860673383871, 0.9463392233920658, 0.9332798559767617, 0.9301704164842824, 0.9745922452327801, 0.9673226331151388, 0.9355230175754585, 0.407931832867811, 0.44542881401233847, 0.4525021732369471, 0.3578757378036005, 0.4352420269741507, 0.4092787016064433, 0.3829750021731375, 0.4142049276270079, 0.411896015007303, 0.7654093298100256, 0.7476386423073534, 0.6885018976189605, 0.7612197290974365, 0.7346573305388192, 0.8515783199425644, 0.7303954213890519, 0.8579105118441094, 0.6915403450228896, 0.33509499200290016, 0.40209259679795095, 0.20902485704113682, 0.27722806141773026, 0.2626028925555315, 0.27501994833393106, 0.303555539790887, 0.39438837493602064, 0.2867986105521867, 0.3833027923397365, 0.2761960696902468, 0.38146823382191586, 0.3117436475831128, 0.33032868628970713, 0.34493523979989626, 0.29872578398236327, 0.30046398981540046, 0.2290070627350741, 0.3255737490645447, 0.3838645485218777, 0.3668382610786799, 0.3471363831820208, 0.39171449317652407, 0.3244861453750747, 0.4278862994976653, 0.3448052994107317, 0.326371089643956, 0.5049598422398088, 0.48177592410747394, 0.5540538738923287, 0.4182580145222218, 0.48632848211609103, 0.4839165377291149, 0.46083338990449496, 0.5373920380501715, 0.55863628296528, 0.14978393184155026, 0.07649806286461003, 0.06766590533531203, 0.22590560315864416, 0.2805983637659343, 0.1354402034902219, 0.22737907923455947, 0.11400664504671609, 0.11457884505273364, 0.2917022635167793, 0.2831671526089031, 0.291406240036725, 0.2774679481869098, 0.31827891485242776, 0.30685006708138896, 0.26172571533169475, 0.29896252328460937, 0.31190990871735325, 0.6682680114872803, 0.699208457619922, 0.6529327447882152, 0.6497430275906626, 0.6569007552445345, 0.688211921087549, 0.6516531070792609, 0.7049184840586784, 0.6824841576407998, 0.13548762851127305, 0.13220630469582428, 0.13699057620582045, 0.12544662540515727, 0.1152513668940619, 0.13676628545156522, 0.16093104630346444, 0.13401113761353423, 0.11050413068947706, 0.24333694311925702, 0.2627431069888114, 0.20271389473324475, 0.22919088981385427, 0.21690304881283917, 0.1765551941711181, 0.2035026471636242, 0.2551283481038027, 0.21236744453866685, 0.37919125214548954, 0.3957131317626834, 0.3762001810100585, 0.36917142775531697, 0.3700584802336352, 0.4137737920297112, 0.4029584995914154, 0.43070739720843043, 0.4379996085066076, 0.2925859858210257, 0.34640916249075127, 0.3356200504469907, 0.2980534803300037, 0.29653684392624813, 0.3085467506232026, 0.31283104553874297, 0.3073293180934168, 0.35459663749047043, 0.20652748132152232, 0.20976224363251095, 0.2141271989505622, 0.1894100185412272, 0.20443060587215656, 0.19764053787046842, 0.2154722467343314, 0.21763164648055788, 0.227095138491043, 0.212646532565281, 0.19692093866661076, 0.46194091899988754, 0.44088126376766745, 0.20732707684937035, 0.23539253817228678, 0.24926638722216998, 0.2036220907550077, 0.21134873091030082, 0.7495293989221892, 0.19872507273073348, 0.1688856605877307, 0.7583173302659669, 0.8499975331132679, 0.7770651490113579, 0.7840418658200816, 0.7065374897862015, 0.19320322937711232, 0.20438382335028238, 0.20651383268755374, 0.20540151516805816, 0.20786467750857107, 0.7207928813457705, 0.16846036714199308, 0.20763898793364055, 0.7123768666635264, 0.21363622503656698, 0.19850862268815128, 0.18746185107956448, 0.17817471729434875, 0.18115963133818225, 0.196386723544536, 0.20273837871751332, 0.20226678041533697, 0.19972300879613436, 0.2035152154413623, 0.09322791458448743, 0.08968476927618318, 0.0844034902929589, 0.09719184308072892, 0.08933172848779702, 0.09442665968248587, 0.10033877989938023, 0.09682491752066125, 0.10189525712374348]}, "mutation_prompt": null}
{"id": "2cbc4316-3967-4da0-9cfc-6336cb1d827c", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "b38b777e-7a25-4a0a-8614-ab2b954535f7", "solution": "import numpy as np\n\nclass AdaptiveHybridDE_NM_GS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size for diversity\n        self.de_cross_over_rate = 0.95  # Increased crossover rate for exploration\n        self.de_f = 0.7 + 0.1 * np.random.rand()  # More stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Dynamic Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Gaussian local search refinement\n            for i in range(min(7, self.population_size)):  # Apply to more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)  # Reduced perturbation\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveHybridDE_NM_GS", "description": "An adaptive multi-strategy optimizer combining Dynamic Differential Evolution, Nelder-Mead, and Gaussian local search to efficiently explore complex landscapes.", "configspace": "", "generation": 84, "fitness": 0.3667619683135753, "feedback": "The algorithm AdaptiveHybridDE_NM_GS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.23.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7368935811691785, 0.722919117777536, 0.7227538924031364, 0.752951898962265, 0.7458486044407031, 0.7342301956491585, 0.735240529553789, 0.7270507301887545, 0.7603824944030093, 0.4844593951927262, 0.4791128989754556, 0.5010672740271803, 0.49626194289620384, 0.5121348658035481, 0.5125380616267463, 0.472767435019241, 0.4852830715242634, 0.49021755701418657, 0.14337227102205474, 0.16352110138950715, 0.16715959299565497, 0.14783901338790006, 0.1198380465971648, 0.13069967798108573, 0.13753121164441617, 0.11558091445173901, 0.12532379716565023, 0.10929916520431593, 0.13240935833070744, 0.10952878711413194, 0.09420828614474208, 0.1193285407049911, 0.10718354690322085, 0.10861023072568898, 0.12482331011633374, 0.11331807399010363, 0.8893193585397579, 0.9420937327955033, 0.9157907640125835, 0.8501387132691633, 0.9826514400349536, 0.8998883738510226, 0.918150120041321, 0.9018603491340264, 0.9517333093180084, 0.37103762982651867, 0.3714249880913847, 0.36553708603679336, 0.37776198386743165, 0.3580347471773785, 0.37356079025699995, 0.3808882389677446, 0.3783906120685707, 0.36680027966051887, 0.7331026544680688, 0.7222762463722361, 0.840327009648774, 0.7917984347149319, 0.7750757242125853, 0.8601355578094603, 0.7580203801495304, 0.6662216068325927, 0.7495861315565402, 0.34842190472523527, 0.2795585141352891, 0.3237922042953073, 0.3731861521964255, 0.2520606906555133, 0.2847030937282551, 0.3262246500890341, 0.3332295558160828, 0.333691388886612, 0.26326924422631126, 0.33805980246893375, 0.35011122919442494, 0.3284752162935758, 0.27173257456976796, 0.29906825513295143, 0.2673584017493996, 0.40474576677716745, 0.41076681502494605, 0.39730118512958135, 0.35141843150001795, 0.37762616576112396, 0.41695992437134055, 0.3785767734969653, 0.3742213304633387, 0.3298802387698323, 0.37156481784717765, 0.3524665674955004, 0.5245220144268748, 0.48309803721396416, 0.5097861169882574, 0.5112459755662092, 0.43785802167085974, 0.45809702452773327, 0.5157677403585507, 0.5071210843494454, 0.5732116449886606, 0.08488837592834841, 0.14083028848920254, 0.08893822704082144, 0.20441096418101534, 0.19217081281678072, 0.2522787288191163, 0.1898934011109863, 0.22938565260758925, 0.18517681580569578, 0.299514038512674, 0.27897213446799995, 0.30068177153376496, 0.26428651585552787, 0.311417566115489, 0.30014539010257846, 0.28473634132324255, 0.31199966580473526, 0.2730732607164513, 0.6604462269773261, 0.6591574258751123, 0.6240868735849074, 0.6683097137829589, 0.6221563193963191, 0.6582589241377466, 0.6304868132855186, 0.6562548969637678, 0.6574569499633063, 0.12353070389383225, 0.11997756206007759, 0.15406387507232866, 0.10418466693943251, 0.11345046914253742, 0.12034192278099376, 0.12227911100328781, 0.12287856632212557, 0.12098930973378896, 0.2828359514898231, 0.22296805200651892, 0.2777870105119379, 0.37492302796734345, 0.17235641936491197, 0.17284546315715144, 0.30749836118463036, 0.16071772615797253, 0.19733063976715304, 0.4238349589423438, 0.3861992984914885, 0.3780883673577089, 0.3596890832753604, 0.39975713686450154, 0.3914392741842493, 0.37252065547543545, 0.38700953160157203, 0.36556837504143647, 0.3095857354204833, 0.3346750203257606, 0.2865921463716302, 0.3564388750986812, 0.2858186801236936, 0.271300588968458, 0.28746000448246556, 0.3053522433645307, 0.2997839101743812, 0.1861356946589917, 0.199971634215811, 0.1994458797527322, 0.2034623488974463, 0.20870895245348497, 0.19863541430367793, 0.209411079763958, 0.2289623443868274, 0.21262753544083568, 0.22208178194919215, 0.1857146618637997, 0.19613356283213412, 0.24060672079033496, 0.33030349136713744, 0.19597436703504278, 0.19192678114938955, 0.20745075117424772, 0.20748311751643, 0.1702315762494594, 0.7996728802620842, 0.7113293428092585, 0.18440509161392293, 0.8998714728977859, 0.1942541926633432, 0.2010064927430011, 0.8491925051111987, 0.8531559633098769, 0.1632058864967787, 0.7256912178438005, 0.20936151875252862, 0.6931263675431456, 0.16946251081316077, 0.20878506976998878, 0.21180873512245568, 0.21035770875967996, 0.2097588387345135, 0.17812343325226665, 0.20577622340056134, 0.20003626379109063, 0.1734067082362628, 0.21012972526641338, 0.20257604620309344, 0.22753646713683007, 0.22220901748905109, 0.21970795036448276, 0.0946601388698427, 0.09159190205710088, 0.09753867349448797, 0.10673491747636321, 0.09327574630791091, 0.08735628342817503, 0.12026116387687036, 0.09951772755569932, 0.1064731670577308]}, "mutation_prompt": null}
{"id": "a29713fb-a125-42fb-b000-9b0c1aa5a73a", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "61fe24b1-dae7-4823-9fa2-a724c435c2c1", "solution": "import numpy as np\n\nclass EnhancedHybridSwarm_LocalAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 6 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.4 + 0.2 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a more focused spread within search boundaries\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort and rank population by fitness for selection\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Swarm-inspired Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Adaptive Simplex Local Search step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.3 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.0 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Local adaptive search refinement\n            for i in range(min(4, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.08, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridSwarm_LocalAdaptive", "description": "A novel hybrid algorithm combining stochastic decentralized swarm intelligence with adaptive local refinement techniques for robust optimization across diverse landscapes.", "configspace": "", "generation": 86, "fitness": 0.4675095499572496, "feedback": "The algorithm EnhancedHybridSwarm_LocalAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8810341267360015, 0.8870578875653095, 0.8861891504749674, 0.8808374740193651, 0.8931737590142393, 0.8853101567497575, 0.8819164169072475, 0.892277647916741, 0.8903878223758905, 0.784509917435342, 0.7841908545609311, 0.7933389926157417, 0.7910684175892292, 0.803138260759118, 0.7873304356641188, 0.7846218359229551, 0.8131648248202616, 0.7965872038369036, 0.1764791341267884, 0.11436198490078808, 0.11391425326163118, 0.1820628099939453, 0.1814456466877743, 0.1776922799857904, 0.15849952167883252, 0.17997660315432418, 0.16019574208257004, 0.13078318033822411, 0.09823221429299278, 0.10557978281984925, 0.09391029378416171, 0.10750088977258565, 0.1293278919972881, 0.1400015513494154, 0.12824909765172743, 0.13489277759370377, 0.9397024843702717, 0.9384685308490921, 0.9230891184551431, 0.8958846745738412, 0.9402479437281238, 0.9537646457403887, 0.9270225233456824, 0.9806717823120957, 0.9362092014896434, 0.6782329801405077, 0.700231618565156, 0.7218174273605783, 0.67907349090478, 0.7294199545505833, 0.6852860078847319, 0.6777667845041027, 0.7160430791719782, 0.6660750150901162, 0.3709448279953452, 0.9138019238642255, 0.38583164269407166, 0.8712675893646858, 0.8955062270627153, 0.3058223057785123, 0.8940453923021954, 0.9172803110637976, 0.8781958165754622, 0.12928034948722344, 0.44460154057176093, 0.19429680133481297, 0.5009068552811858, 0.22269486786597292, 0.2287838192054512, 0.6461007686027868, 0.7601711646451321, 0.4538932408942221, 0.737448688135117, 0.23528236262145397, 0.20546931971300708, 0.49823545100317423, 0.4980866899956736, 0.4973419346258797, 0.20260244856743115, 0.43921488100848327, 0.7224412518926977, 0.5837401203708841, 0.5288293635284907, 0.6376561480045122, 0.5226761389139087, 0.6759159703402262, 0.6470150968106994, 0.6040019967412864, 0.19214335065648147, 0.6419189172547893, 0.7362175811363314, 0.7327976605884352, 0.7404680623920912, 0.6503789247049663, 0.5942903175055507, 0.7488438277352748, 0.7162293948408414, 0.7270937957591758, 0.5030529216546419, 0.10108132549670246, 0.11988778190443117, 0.13529455338775764, 0.1738369895614067, 0.5933900874864604, 0.20069462651191794, 0.199924456677134, 0.18908448805744815, 0.17323707931366283, 0.5125347776699173, 0.5231579154790736, 0.4624586795801693, 0.4368274416819048, 0.4949881762009051, 0.5590625869905184, 0.5035672136874256, 0.5367792867807962, 0.5199253226965912, 0.8316058067474037, 0.8307912145575771, 0.7744478159235797, 0.8379777338418041, 0.8043505388575122, 0.8462100971750014, 0.8101004596260636, 0.7734743920235059, 0.7475248263489871, 0.14306339355461262, 0.12007316487923891, 0.11585883819323406, 0.14332907272251083, 0.1592686989078378, 0.14533051429522748, 0.14302305295021833, 0.1425724267480979, 0.15240710273717484, 0.3313874223843696, 0.24399024577709083, 0.4890738356678158, 0.6368007796995226, 0.4845020058573124, 0.6722013065178176, 0.2876028873376236, 0.18436849987330228, 0.20884711353030438, 0.30092766362694356, 0.3304907080507634, 0.6721598888444205, 0.5359363798088453, 0.6308213525300848, 0.5583875079810107, 0.6771827200660406, 0.4309346644152593, 0.5961135301548575, 0.3786999979347293, 0.5130559602809288, 0.42631744151292683, 0.26902978085057117, 0.42319160230523667, 0.2880902233217968, 0.40139844512449774, 0.2135738464153064, 0.34359436560507306, 0.21496420602217725, 0.22131673148833142, 0.2550218507217834, 0.21043983341570827, 0.20610860306868062, 0.22088168026895216, 0.28756437488680453, 0.23576836696431902, 0.21509356986093775, 0.20046394376183108, 0.19849154489344634, 0.20920996516379853, 0.19361330952590072, 0.19987925438688348, 0.19860344803587227, 0.2108943325024285, 0.22104988980808848, 0.20752000530415415, 0.20812238997451615, 0.9170668405922525, 0.9293658781783336, 0.8422861413959, 0.919366349296971, 0.8807705149996546, 0.1643578238230553, 0.8844182094632829, 0.16894001583082696, 0.12605492787583605, 0.8220328265605175, 0.16742009334985597, 0.1680034814540311, 0.8137282366928331, 0.8568317658925557, 0.21192891126668212, 0.9023937773887781, 0.20788156310260242, 0.200275860722391, 0.2366419997525392, 0.20482609840391441, 0.2154304212126199, 0.19295139515312465, 0.2347898284858525, 0.21679828737761564, 0.2343537982925622, 0.1987532822930057, 0.0992390725747293, 0.08602961539331844, 0.10502360812733591, 0.0883626863996767, 0.12865513444845678, 0.0979208737786934, 0.134696484935101, 0.08539551895239272, 0.08717588795134601]}, "mutation_prompt": null}
{"id": "3a851d01-e405-43f0-b29c-0fc767d0ba40", "solution": "import numpy as np\n\nclass AdvancedHybridDE_NM_ALS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.7 + 0.1 * np.random.rand()  # Slightly increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Novelty-Enhanced Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = (np.random.rand(self.dim) < self.de_cross_over_rate) | (np.random.rand(self.dim) < 0.05)\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Refined Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Adaptive Local Search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdvancedHybridDE_NM_ALS", "description": "An advanced hybrid optimization algorithm combining Novelty-Enhanced Differential Evolution, Refined Nelder-Mead Simplex, and Adaptive Local Search for versatile problem landscapes.", "configspace": "", "generation": 87, "fitness": 0.3719426216727819, "feedback": "The algorithm AdvancedHybridDE_NM_ALS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7624458681370083, 0.7782887397506346, 0.7837116137433418, 0.7741308462085444, 0.7801827404163334, 0.7787552368189194, 0.785225920705938, 0.781780600788371, 0.7933107046098846, 0.5625783564007422, 0.5858491776817992, 0.6100975158140927, 0.6120815753994584, 0.5848314017243296, 0.5910577434340127, 0.5688296350983932, 0.5793052161463452, 0.5892501201671174, 0.13746902189535648, 0.21839862253488895, 0.15020337716045817, 0.10804895176847862, 0.1336785149913683, 0.14163441231770335, 0.1383965732712752, 0.16071366861488479, 0.13101048943142546, 0.13222216163615053, 0.11347495684113129, 0.14745987000781424, 0.12993949508806568, 0.110888807972927, 0.11922338315733338, 0.1393483873580832, 0.10732475026921584, 0.10239776341570284, 0.9560277860920915, 0.9417784723378356, 0.9540059025811904, 0.9723466726520859, 0.9707869049039499, 0.9602061887084095, 0.9644867250260544, 0.9405841718215203, 0.9575575980947308, 0.3928594482138599, 0.39450359123002476, 0.4233103315700588, 0.4274518780909181, 0.4048106656276613, 0.4063500259836409, 0.428274728626045, 0.4609698694474661, 0.4144067789791245, 0.7607213866921863, 0.7730077205791706, 0.6873356710811749, 0.7464269647924953, 0.812227813368854, 0.7750806935058812, 0.7246324605679872, 0.784316557841298, 0.7509252757854408, 0.19082217436139204, 0.2854434617533057, 0.2569277829489347, 0.2620605248029604, 0.2503156227084271, 0.34173992276654663, 0.32504234766519513, 0.2944195497316944, 0.4722558159184107, 0.27298966241447986, 0.3385056848511513, 0.34640044243243806, 0.4319448516890968, 0.4443180650594609, 0.30371109856944734, 0.325655298745937, 0.26633112061905206, 0.276042062617997, 0.32308567235187147, 0.2831443285759613, 0.30634840267902586, 0.32300384112575053, 0.3262084267053599, 0.34029406951730323, 0.36713044421651153, 0.3134175982839942, 0.36484449971084243, 0.4430085988229413, 0.4261789915702717, 0.5061043455321825, 0.4390019139761242, 0.3904474717883403, 0.44365560898969447, 0.48329057230134254, 0.4347265637837311, 0.4708259282416317, 0.168543613960221, 0.0907152589998792, 0.20027408759008491, 0.19716066230317109, 0.1829409774138243, 0.09053093972602311, 0.09681035679874417, 0.15360829801479225, 0.18323004045685898, 0.2898288249918236, 0.2705070181892142, 0.2808042444815082, 0.28650113328087046, 0.2530066474378967, 0.2873453930778286, 0.27264646834006767, 0.26857850077425116, 0.2970671357569492, 0.6538538771407576, 0.6652617169241432, 0.6572567896389436, 0.6385340260828787, 0.6190832312668874, 0.6488054553482905, 0.6600457324112616, 0.6502075376670451, 0.6965840181738789, 0.12719076681931618, 0.11213609462519747, 0.16884921091667804, 0.10800474363251833, 0.11817117101382935, 0.11248870617100748, 0.11352163984784025, 0.1163831726219049, 0.10418821713893833, 0.18199578409955652, 0.3254268755040063, 0.4382587967697549, 0.22965725726435726, 0.23602171882979284, 0.5101892754751852, 0.17261158840125868, 0.14848316676824924, 0.17968009971133947, 0.3709831952478033, 0.4229592168211236, 0.4022114093679393, 0.3642869343769837, 0.35349231417327087, 0.47628785205533364, 0.395086535181708, 0.4420431254050361, 0.5274084410733351, 0.32599345023850745, 0.31125340210872565, 0.2996264612026204, 0.3618701320210167, 0.273532010806679, 0.31541536487582944, 0.34256824647090234, 0.29522826389315215, 0.30119848864223664, 0.215287451409225, 0.20501846680558233, 0.19852609855244507, 0.19732808021207715, 0.21170941199590532, 0.21721984140778938, 0.19873493495380945, 0.219208214683297, 0.215720226673627, 0.21711771504459987, 0.19877137393823363, 0.21405875530719354, 0.22278785104739973, 0.3178976919349229, 0.5258825273570358, 0.19341540862830575, 0.20762440680560823, 0.2044122718135586, 0.17819605881609746, 0.17525326090614313, 0.80665428400518, 0.19598737411120637, 0.8333935830024222, 0.16631740866705624, 0.16116616961828478, 0.7313528389826486, 0.169828818841127, 0.615426141962645, 0.7725847042305783, 0.20888456517575127, 0.20395517482225312, 0.15367688897793252, 0.1680878610524278, 0.8009243013887072, 0.6831046495027616, 0.20663036934548096, 0.19259267035038496, 0.18646186619518457, 0.20185209470457233, 0.20186251100408759, 0.186257616166965, 0.20896342329625972, 0.1806156831422442, 0.1715650260486562, 0.17946828879535692, 0.0907106498991721, 0.07502603100818384, 0.08201825764546156, 0.10446694099506382, 0.10664458626970807, 0.08399829867260267, 0.08349264768249864, 0.08367030948519927, 0.08477780935145351]}, "mutation_prompt": null}
{"id": "ce86238a-3d63-4d54-824c-f7b31cf1ddd0", "solution": "import numpy as np\n\nclass AdaptiveHybridDE_NM_PLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim   # Adjusted for better exploration\n        self.de_cross_over_rate = 0.85    # Slightly reduced for diversity\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Increased range for perturbation\n        self.simplex_size = dim + 2       # Expanded simplex for better exploration\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        best_solution = population[np.argmin(fitness)]\n        best_fitness = np.min(fitness)\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_solution = trial\n                        best_fitness = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Refined Nelder-Mead Simplex step\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    population[self.simplex_size-1] = reflection\n                    fitness[self.simplex_size-1] = reflection_fitness\n                    if reflection_fitness < best_fitness:\n                        best_solution = reflection\n                        best_fitness = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n\n            # Probabilistic local search refinement\n            for i in range(max(3, self.population_size // 5)):  # More focus on top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n                    if candidate_fitness < best_fitness:\n                        best_solution = candidate\n                        best_fitness = candidate_fitness\n\n        # Return the best found solution\n        return best_solution, best_fitness", "name": "AdaptiveHybridDE_NM_PLS", "description": "An adaptive hybrid algorithm combining dynamic Differential Evolution, refined Nelder-Mead, and probabilistic local search to effectively tackle diverse optimization challenges.", "configspace": "", "generation": 88, "fitness": 0.3590279144834074, "feedback": "The algorithm AdaptiveHybridDE_NM_PLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.23.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.757198332537921, 0.7721923833613826, 0.7579153797120819, 0.7748435321320359, 0.7849556147371206, 0.7502958281390129, 0.7522467658377817, 0.7782855834702417, 0.7821733161421527, 0.5497687736126404, 0.5634834880808274, 0.5666657997071414, 0.508683445006572, 0.571744752437998, 0.5744279046906459, 0.5518940765290943, 0.5858119298503818, 0.5748692032244205, 0.15592050568201143, 0.1330178959244337, 0.15104385352145744, 0.13396247546578266, 0.13100222324765276, 0.13264036131951817, 0.1498418873236902, 0.1203218166063279, 0.13662349048361067, 0.11340915459142287, 0.12061752714673624, 0.1264736995878406, 0.11883764823777931, 0.11551120024380179, 0.11360353104758103, 0.12102184229266555, 0.11896532209406874, 0.09707271727833922, 0.9362960016490887, 0.9209502020079059, 0.8639749386799248, 0.972033565912957, 0.9622315863468697, 0.916226642185525, 0.9472734859735755, 0.9773764911562903, 0.923716229162887, 0.3829350286801716, 0.38702191354061066, 0.419036730964533, 0.39934983281586167, 0.4172808845984953, 0.39808673481340195, 0.4057963859626291, 0.42303695500185867, 0.4340487352468009, 0.6725264141024458, 0.7223923854010041, 0.7605811680586849, 0.6933976036261889, 0.750605532755803, 0.7402275073552345, 0.7317619964821208, 0.7091035049739155, 0.7162569027617858, 0.21364053327882015, 0.25734875579123684, 0.2083203011871375, 0.24953589073354432, 0.270791389003193, 0.2783246065787761, 0.2880163771797071, 0.2585972635678552, 0.3153178915138286, 0.21357223013843096, 0.28830703083891385, 0.316246632693972, 0.24713622555083736, 0.388943711476914, 0.24304503660483068, 0.3188035104229757, 0.2613609995757642, 0.21918958135643607, 0.28120929429480135, 0.28873573832255417, 0.30871920677883113, 0.27388698297532266, 0.3021896919740611, 0.23850212083081257, 0.2739742390316624, 0.33934600414565175, 0.30778069269065633, 0.4534912510922019, 0.456523886593557, 0.4891944835498704, 0.36637321840140535, 0.4018717781768808, 0.4046763593817069, 0.45159337161770285, 0.4441453353269271, 0.5103981455979361, 0.05446767420938081, 0.08589193320973898, 0.14388057248200348, 0.15730661185079065, 0.21398167904712473, 0.14122722690213774, 0.10414707754981789, 0.15181074383014515, 0.15718886687460887, 0.274226492329408, 0.27758495915836656, 0.2718708763455485, 0.27043945214913834, 0.30962534833813193, 0.2799974655208848, 0.247512854780098, 0.28359786667958176, 0.27851239919427173, 0.6354108201069194, 0.6325612646441217, 0.6476634585766485, 0.6426999500560235, 0.6599765992511407, 0.6313400039836692, 0.6573911986260681, 0.6199994779092552, 0.6408454877908996, 0.1318503229337985, 0.13244037386014096, 0.14254760357771834, 0.12066534782482541, 0.11951940754390011, 0.13098835982179646, 0.12054122992214511, 0.11590178195715073, 0.11332305621822047, 0.21210617084547234, 0.23973317798529903, 0.17338585549427388, 0.20948914276712172, 0.20581695948567746, 0.2398211452042157, 0.21407809726206284, 0.17998302576104763, 0.20118312300996233, 0.36968177306808536, 0.35984466077475175, 0.35508728539914836, 0.3729736681439183, 0.3558357522227956, 0.3503879785353875, 0.36601799614951225, 0.37257047072723337, 0.3716709424948408, 0.2499194457370053, 0.2803719142248541, 0.29485663963734543, 0.2576785300369425, 0.277442346040069, 0.2793614273237507, 0.26627776297250916, 0.2784395682162044, 0.28795579196057997, 0.19232635328221093, 0.23344788941683425, 0.19773202573191795, 0.19930616365474807, 0.1950699634123998, 0.20974270668939843, 0.19838392987392328, 0.18248661813605405, 0.2090957946622659, 0.22172875413965276, 0.20659805567076306, 0.2311418326298864, 0.193407862916689, 0.20292561016428312, 0.2020650713843143, 0.20695187572513607, 0.21920579423490294, 0.22037244405289913, 0.5925987452635015, 0.6457281058755497, 0.6823488822784674, 0.7376055885518746, 0.7586744910155694, 0.5638146160151039, 0.4354812726067607, 0.6408970961004717, 0.6107200821891943, 0.20529728415653825, 0.1977414188057094, 0.5113059516420946, 0.4991800880551289, 0.5464927297475857, 0.20561726960309024, 0.20613759786410502, 0.5748134686144356, 0.20731525486758806, 0.19687070534843865, 0.18731563753128144, 0.20515535187500322, 0.19305229047129846, 0.21223061404234533, 0.18030032058538958, 0.19930396623861624, 0.18193642032533186, 0.18861691873667574, 0.09807382362067185, 0.08104841877713953, 0.08948967639671213, 0.09735739330615711, 0.0773904165582493, 0.07704803691794715, 0.08970111433123928, 0.09131242612185064, 0.07918242186845115]}, "mutation_prompt": null}
{"id": "aac205bf-52fb-47a9-bc2f-04172cbb418a", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_V2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            for i in range(min(5, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_V2", "description": "A modified multi-strategy optimizer combining adaptive Differential Evolution, Nelder-Mead, and stochastic local search with enhanced diversity mechanisms for robust optimization across various landscapes.", "configspace": "", "generation": 89, "fitness": 0.4771458526587456, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_V2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "10fe9615-f605-4e5e-ad9d-3d3863cf2b19", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 7 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.6 + 0.15 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Modified Nelder-Mead Simplex step\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.8 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.4 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(4, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined hybrid strategy integrating Adaptive Differential Evolution, modified Nelder-Mead, and stochastic local search for efficient optimization.", "configspace": "", "generation": 90, "fitness": 0.42568045880903604, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8348716749678491, 0.830867952449669, 0.8416051437256572, 0.8420059941311525, 0.8359789308682717, 0.8490402798664292, 0.8359028402227993, 0.8274236454517415, 0.8383850625862981, 0.708807490911221, 0.6938888174089607, 0.7046573885449199, 0.6826998094202139, 0.7081677575592948, 0.7084025437605764, 0.6882674646165514, 0.7230232807470314, 0.7010849391282193, 0.5207374958490573, 0.1782331089711675, 0.6043948682746828, 0.17481150413832025, 0.17860126852900593, 0.15338541637323866, 0.1428615825599101, 0.16173785087984038, 0.18039648350550275, 0.1354737725009727, 0.14075583454579632, 0.13461999884250486, 0.10952172105106506, 0.10955693579976866, 0.12945591470421636, 0.1368283192418558, 0.11528181975051643, 0.11551290141770443, 0.9637671431630851, 0.9569836750248208, 0.9439308832517377, 0.9592730417677344, 0.9508276876927628, 0.9307036005178672, 0.9615309296925243, 0.945279295792218, 0.9504198023916227, 0.561979616777952, 0.5553964492228628, 0.5549795700288095, 0.5335094263578094, 0.5666996417993846, 0.5533899422000347, 0.5167690933205178, 0.5502993089917064, 0.5843841830966497, 0.8535517681441614, 0.8158700677488364, 0.7695103991455419, 0.801630337998328, 0.8356226328870364, 0.8143366709475337, 0.8217944952590035, 0.8353124149415119, 0.8397437404346908, 0.41248352318919945, 0.4870727604856996, 0.5061703087521576, 0.4274746175310681, 0.4630411754999625, 0.1324894281963761, 0.4620924261882182, 0.4101950670890434, 0.5161641251399631, 0.2024027744721677, 0.23980773950337253, 0.5632771387851725, 0.355475777328354, 0.5043975023974718, 0.47556202212689946, 0.6108198733272217, 0.3496698604576751, 0.4514836891866526, 0.45523602508148786, 0.4432410313530981, 0.4581776143358841, 0.35502731688478095, 0.473745841968368, 0.49955321967630073, 0.5177402654538683, 0.44390279686183387, 0.41672907664505243, 0.5747992357987417, 0.610860462212055, 0.5663971412774793, 0.6006139322920439, 0.5288430545447755, 0.5838340000774331, 0.6046079092797574, 0.633490808502528, 0.6424873551204668, 0.15816794512149923, 0.22471863833218275, 0.2653327851782147, 0.28947334786856804, 0.32154516736985284, 0.3283952154379933, 0.2611359001029475, 0.18983453611902668, 0.2720835645989992, 0.3766206656555302, 0.35942915056728375, 0.3777665283460028, 0.38831772419801835, 0.39730422349355266, 0.33271118953562895, 0.33202037105343574, 0.3789017204975267, 0.38288020151933266, 0.7866431875194386, 0.747833007093183, 0.7650546745605395, 0.7290563450024291, 0.7563521740096882, 0.7485983337953062, 0.7526598228444432, 0.7375335659552603, 0.7732514970090151, 0.12825969339917442, 0.16823010612976708, 0.13306179953233677, 0.11221571622242121, 0.1568731188759508, 0.14915756115821333, 0.13782504346981173, 0.15808290051468832, 0.10927787167912106, 0.5935598351077334, 0.30306426351972915, 0.5250318853710195, 0.20181122727719414, 0.13042021354306, 0.18038178583978204, 0.2205832838328673, 0.24020059702359864, 0.3314594311233079, 0.5209533108100892, 0.4809423203581802, 0.4824532979989764, 0.4683783064079504, 0.4663262444374171, 0.5169474765453859, 0.471700963779099, 0.5289511733936503, 0.4071794229224127, 0.3744868164750532, 0.2196170654216144, 0.34668446690399324, 0.3321947929557243, 0.384728281611849, 0.37017723875600095, 0.377258287100786, 0.3922056126375456, 0.3007186588864149, 0.1955249217531847, 0.22328243221864263, 0.20145074071635882, 0.23577396176489251, 0.18837426062391083, 0.22701464632493418, 0.19612419174953943, 0.22840060055092137, 0.24913104816207943, 0.1861890299248915, 0.23199480416800666, 0.2070804122329607, 0.22363253490358392, 0.24400978572435184, 0.20771300170992457, 0.21989379671872922, 0.6960960623464182, 0.24175075878191488, 0.18449540585440105, 0.8780643996248287, 0.14782836670608668, 0.16904680945156447, 0.8045401960322425, 0.16578377685399304, 0.8435576301513932, 0.17596123033594158, 0.16896853238423004, 0.20624883418180595, 0.16833539726564817, 0.20863507504537182, 0.20565287771666796, 0.16840194426795774, 0.16677974380960348, 0.20903912900060573, 0.21050372648942406, 0.8070819596670852, 0.19209033033105538, 0.22014526774176424, 0.18308949795767693, 0.1735387464977739, 0.19678913188429759, 0.19701719591333533, 0.22235046669105019, 0.18991496665671392, 0.18160528466046932, 0.09217282732979859, 0.09157427312845579, 0.08737671577182626, 0.09257227099595478, 0.1069609420775145, 0.09245017606128969, 0.0979256018632646, 0.10503632602328239, 0.09287497322397553]}, "mutation_prompt": null}
{"id": "85352157-1ca4-4adc-81cd-b3f030c16ce3", "solution": "import numpy as np\n\nclass AdaptiveHybridDE_NM_SLS_ER:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.5 + 0.15 * np.random.rand()\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            for i in range(min(6, self.population_size)):\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n            # Elite Recombination\n            if budget_used < self.budget:\n                elite_indices = indices[:3]\n                elite_population = population[elite_indices]\n                recombination_center = np.mean(elite_population, axis=0)\n                for i in range(3):\n                    recombination_individual = np.clip(recombination_center + 0.1 * np.random.randn(self.dim), self.lower_bound, self.upper_bound)\n                    recombination_fitness = func(recombination_individual)\n                    budget_used += 1\n                    if recombination_fitness < fitness[elite_indices[i]]:\n                        population[elite_indices[i]] = recombination_individual\n                        fitness[elite_indices[i]] = recombination_fitness\n\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "AdaptiveHybridDE_NM_SLS_ER", "description": "A novel adaptive hybrid algorithm combining Differential Evolution, Nelder-Mead, Stochastic Local Search, and Elite Recombination for enhanced exploration and exploitation in optimization problems.", "configspace": "", "generation": 91, "fitness": 0.3848527759369123, "feedback": "The algorithm AdaptiveHybridDE_NM_SLS_ER got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7893152492080621, 0.818989575550319, 0.7898367666928169, 0.7879442522089771, 0.8038987006299487, 0.8028160929019452, 0.7900787353390848, 0.7988136615769005, 0.815926110843662, 0.6113878127349825, 0.6108718735019312, 0.6053565187752656, 0.5931297509873181, 0.6050468770928592, 0.6230518035661883, 0.6278198137771374, 0.6096356150794808, 0.6213486120213932, 0.284880854094515, 0.14496001222139565, 0.1843397567576306, 0.14298642043574217, 0.1467728212546795, 0.4489768261340039, 0.1453323557812468, 0.12507367577328243, 0.161468086147455, 0.13349762398712917, 0.10120309695001106, 0.10586175151625798, 0.12906046844965136, 0.11125466010002583, 0.13163613135660035, 0.12262817342660659, 0.10946053133953793, 0.12424842721664686, 0.8858842924302485, 0.9273989700932872, 0.9454702870415258, 0.9052868844373736, 0.9187648129322662, 0.9281707050640131, 0.939317858815005, 0.9085278788623306, 0.9536617783757353, 0.45195267599725, 0.4690885572825433, 0.46942009484669844, 0.47352091175862987, 0.44700395168800466, 0.4591470079374068, 0.4710163053792671, 0.4354480941344082, 0.4937018519666436, 0.7250985399884984, 0.8178769726928639, 0.796215662487233, 0.7879691797855942, 0.822909617374393, 0.7934660065052046, 0.8003698852969504, 0.8655033594539612, 0.7941451285725643, 0.2131476341473526, 0.22895843765927448, 0.234947450698333, 0.3417293171079835, 0.23451502049894912, 0.22520150462746802, 0.35082259117963277, 0.287271705366846, 0.26033705195159673, 0.21739806879103063, 0.23237026752223788, 0.3135910020450239, 0.26081839596196343, 0.3680474080952054, 0.27911712445058934, 0.32597623820178656, 0.2018605761833271, 0.30617597937788266, 0.31763550350423364, 0.32827518461947025, 0.3867739472708822, 0.30795442100409276, 0.30055522466530205, 0.32641069881990314, 0.2941963658305212, 0.37002115712127825, 0.31596534918801145, 0.43881030185813263, 0.5031105375558824, 0.43416111747670516, 0.4673045704634228, 0.5027292588803074, 0.4811177384706451, 0.5061853735455061, 0.5017946171840844, 0.5204996190225785, 0.08170669618335435, 0.25089827964697897, 0.1330947938660738, 0.20969012086326988, 0.23910979656602227, 0.11810256890023552, 0.12507302996254277, 0.11718663759505055, 0.19107546241672502, 0.284248860872632, 0.29736270471297443, 0.32300358640482163, 0.3004090025123398, 0.29491183419002853, 0.2905800410202706, 0.30882254464356607, 0.3122904766626744, 0.29225684609036406, 0.7140720368155904, 0.6987665655685639, 0.6747274155143176, 0.6686702343850298, 0.7053865634981715, 0.7159093688235051, 0.6810851230150443, 0.6848664282039139, 0.6890679768692569, 0.14039868147241885, 0.12931078329897716, 0.11098279992754867, 0.14328374502827668, 0.11220447901070418, 0.13134573255146753, 0.13382154781687716, 0.13946918571638178, 0.1172161185754117, 0.21002529526717673, 0.21809609019154286, 0.16439398837183727, 0.16958870587345865, 0.19384346115509365, 0.21510589994089646, 0.27371919684989776, 0.21681255737259897, 0.22373751124893282, 0.43678291019253945, 0.4684367370075134, 0.4567389101354802, 0.45177169213073143, 0.4855268188857891, 0.4284385894926037, 0.44828109499513613, 0.45233941933304, 0.4837646882837988, 0.3377476420511626, 0.33339959096135596, 0.33157380377255186, 0.3325132407021567, 0.317581401122796, 0.3226040607347731, 0.3224166455405729, 0.3516792094987965, 0.3494258622457933, 0.21873994898260207, 0.20493261017497477, 0.22357878847057355, 0.20897831709108017, 0.2236281322533782, 0.21985605463289926, 0.2145470740250176, 0.23100188135421384, 0.2338368169186218, 0.1876638877757234, 0.23186795509806157, 0.2274348284289761, 0.3846722769199764, 0.21621735680468612, 0.30127366640318465, 0.22474103382219057, 0.20764667325786734, 0.20141483238688485, 0.8409351547524669, 0.18668760273034002, 0.20226415382253815, 0.17918479802831022, 0.8372195983306614, 0.8006647004013344, 0.16735571764808788, 0.8669909107688916, 0.8057967443308149, 0.7127238719847704, 0.16834147805541289, 0.21112711301166287, 0.20706473404951686, 0.16963069901594208, 0.1692761884329741, 0.2042286536209723, 0.757580534512607, 0.7508366754701215, 0.1921697795753916, 0.18869805474233303, 0.21186705916376758, 0.2285905215619849, 0.2012372822744063, 0.19619504983656266, 0.20050003987722498, 0.1911057274514707, 0.19066462958501007, 0.15149312591947295, 0.09721242992011225, 0.09924725202518714, 0.09441298470988535, 0.08900208449968128, 0.10475988070017606, 0.10637007995226666, 0.09759766970814598, 0.099347867564194]}, "mutation_prompt": null}
{"id": "9bf21e6c-92a3-4403-a4d8-f6afbee8bc81", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "1dbdb4c9-ddcf-4080-82fa-f2a66f9c866d", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.de_cross_over_rate = 0.85\n        self.de_f = 0.5 + 0.15 * np.random.rand()  # Slightly increased stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Enhanced Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.6 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(6, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.15, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_SLS", "description": "A refined hybrid algorithm combining Adaptive Differential Evolution, enhanced Nelder-Mead, and stochastic local search with probabilistic tuning for efficient optimization over diverse landscapes.", "configspace": "", "generation": 93, "fitness": 0.3868125538776411, "feedback": "The algorithm RefinedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.7832566653481672, 0.7833487223319676, 0.7828350272415852, 0.7998185937518645, 0.7989572553450911, 0.7853379367457723, 0.7956762785853677, 0.7817247900433236, 0.8041692054378484, 0.5951033863057962, 0.6016612340657925, 0.5952279423434934, 0.5876674642138032, 0.6254648064156199, 0.6234329416269873, 0.5952149858279403, 0.6268711979054535, 0.626900122804033, 0.33960668429921004, 0.1256348032394735, 0.133040832700693, 0.2390282427740179, 0.14411168075646996, 0.13928915460134772, 0.15764553712973772, 0.13758455047861495, 0.11511150687294425, 0.11459101802950011, 0.11213101588319863, 0.13754891670307712, 0.11961267704057499, 0.12423688802270094, 0.12140339610988993, 0.11617109012239746, 0.12276376735442629, 0.12066772958776195, 0.9659357028230825, 0.9547580308375367, 0.8996644936962905, 0.9237713505459672, 0.930205662390132, 0.887169435384159, 0.8988977184602946, 0.905495118717711, 0.909121427493635, 0.4415576084498356, 0.44418623765797105, 0.4100587826405858, 0.42421790745832066, 0.43757660605794935, 0.4480740804868555, 0.4556707688700965, 0.4497838845657257, 0.4546287215213469, 0.7811592157485189, 0.7863874974578094, 0.8274412891049784, 0.7831419934645938, 0.797402120454051, 0.80217519108972, 0.8431576013596874, 0.7492124405115481, 0.7557220032697327, 0.2775321774037832, 0.2770417338940494, 0.33490373849906185, 0.3686970334037115, 0.27503220344396895, 0.3592799765470782, 0.2482636064121192, 0.36735892489836475, 0.37420495886890226, 0.26087677395974473, 0.2444897865647785, 0.22526386287532807, 0.4083760565297073, 0.2891814473540544, 0.20920460327491897, 0.1985423672460812, 0.32332942090068184, 0.2835621972209723, 0.3502761295322623, 0.2971587371114379, 0.3396594464650219, 0.3618272787276666, 0.331160093639143, 0.3303519383511404, 0.30363021458702477, 0.310171416656863, 0.3584545561685163, 0.4952710712045598, 0.484677030739043, 0.5225861138110819, 0.4433359195108262, 0.4386402294200671, 0.4449730226399148, 0.4447577432203157, 0.484907297603838, 0.5456019415838965, 0.061393981522408825, 0.12279161048331566, 0.1752275615930684, 0.19449230866451506, 0.23395054883736432, 0.14184103381001145, 0.09675834206003764, 0.15077985364707402, 0.23001143835142845, 0.26147919132871666, 0.27370339850426895, 0.269636770728354, 0.27316537766535476, 0.28678488779801004, 0.2740120844522981, 0.27755501354806034, 0.29337359736976276, 0.2810557712478444, 0.6752694999978001, 0.6701550965237488, 0.6949438755960078, 0.6655594825524231, 0.6542562726514913, 0.6671391382534342, 0.6400746775023209, 0.6663382831622027, 0.6682875777020153, 0.12427589832303532, 0.12154974509150651, 0.1267177020745347, 0.10705616090622838, 0.1351300659384298, 0.158804566587189, 0.1323266781030905, 0.11805374202478747, 0.16138983751873548, 0.1833572393915882, 0.23290104722612837, 0.2312029278599541, 0.19065768399270733, 0.219826038316967, 0.2137590082813814, 0.23240283109129045, 0.21272132827207402, 0.16611326354898814, 0.3884568484776386, 0.4215153747729775, 0.4486286805069575, 0.4533385048758414, 0.435633346202449, 0.49164570229351523, 0.483000892073849, 0.4304526334141344, 0.4873662768233944, 0.3340292705722966, 0.3549130878566267, 0.3150771624698182, 0.3321262822690454, 0.3190871227801454, 0.3145822819028925, 0.34663275192335863, 0.3435411981342923, 0.3860111023264653, 0.23235542991015823, 0.2117595100062355, 0.2126765535713735, 0.21654629753594945, 0.2425198765061073, 0.20051194704632735, 0.21891705124619998, 0.20677867349520973, 0.21755594545446666, 0.30576067720079514, 0.4372095720504173, 0.43151373543320026, 0.22236305048842897, 0.3477891469518649, 0.2322278414939346, 0.22284574540940005, 0.23162178751479578, 0.4930802788743297, 0.18580023012196945, 0.8278171838935553, 0.18588021927292697, 0.665158032121761, 0.811429463222121, 0.8040286189699196, 0.6498035454386935, 0.7513978809003585, 0.19662583929840682, 0.7269185105176075, 0.20880889444292228, 0.2105910449659798, 0.16511570817930155, 0.16904538242663436, 0.1802630637897732, 0.7468269975482777, 0.7231786928605792, 0.6702750567277811, 0.1849445879666095, 0.19638247749080162, 0.19524544934327437, 0.19445128324968997, 0.18190857118556558, 0.19371533330737012, 0.18844565451103468, 0.20073443284377723, 0.19405115423859864, 0.09191153312798994, 0.08212881120322546, 0.09300190979559353, 0.08876900831707535, 0.07994629931043595, 0.08652651680548984, 0.09980163998007607, 0.09264714398800256, 0.0975793974064445]}, "mutation_prompt": null}
{"id": "507bae58-dd72-4c40-b70a-2cc7dff4ce26", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDE_NM:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Slightly increased population size\n        self.de_cross_over_rate = 0.85  # Slightly reduced crossover rate for diversity\n        self.de_f = 0.4 + 0.2 * np.random.rand()  # More dynamic differential weight\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with a broad exploration focus\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with learning\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Intensified Nelder-Mead Simplex step to explore promising regions\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.3 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for best improvement\n                        expansion = np.clip(centroid + 2.2 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.4 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Dynamic local search refinement with random shifts\n            for i in range(min(7, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedAdaptiveDE_NM", "description": "A novel adaptive optimization algorithm mixing Differential Evolution with an intensified Nelder-Mead strategy and dynamic local search adjustments.", "configspace": "", "generation": 94, "fitness": 0.4251770671988692, "feedback": "The algorithm EnhancedAdaptiveDE_NM got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8356885519211861, 0.8330006483415784, 0.8216125217622814, 0.8357334023693295, 0.8295262249001004, 0.8106960152641933, 0.8369553633341924, 0.836363315519451, 0.830776866091577, 0.6863489434299206, 0.6833463698524544, 0.6968220165634837, 0.6926160977756703, 0.6715230619051549, 0.6758652694266376, 0.7019888244049354, 0.6792332326662466, 0.6671587513223833, 0.16452929371193992, 0.16523350493093125, 0.5209876613984133, 0.1496039554870917, 0.16542769526412304, 0.19898109977752942, 0.13816176075174447, 0.16623360142095156, 0.1727863229308001, 0.17112918055864268, 0.13491982184952156, 0.10443051784201884, 0.12739103178934352, 0.12775171456429868, 0.10878513848041871, 0.1316094062982427, 0.2136672898702674, 0.13482519280517757, 0.9277154324014397, 0.9334326616286317, 0.8935344394263798, 0.8921378717430195, 0.945370492073197, 0.860888069013158, 0.865950373570429, 0.9811773034683262, 0.9110585021381927, 0.4900548752438313, 0.5362167244332157, 0.5504914281588427, 0.5713858874072554, 0.5317167052467375, 0.5584820403743158, 0.5185801020310993, 0.5476103814797475, 0.566918613415065, 0.8769284973466123, 0.8349327177683111, 0.8479435473962946, 0.869007689771518, 0.7990410764737064, 0.8495052287064115, 0.8108167017128391, 0.8040698303042116, 0.7660934635935847, 0.5068781683864705, 0.31959549148004096, 0.2003147008399444, 0.28122055369124743, 0.3035744532035183, 0.19405843125619915, 0.27298317232404457, 0.18218427164001694, 0.3824849034732676, 0.2514830868704917, 0.22736052321625944, 0.13136878340052172, 0.4518062514443203, 0.3029110866353566, 0.21362082883568123, 0.3190280709582629, 0.49382746866610294, 0.3010570036597803, 0.4497723614178517, 0.3914105891835079, 0.46366762252606075, 0.42005935246089077, 0.3861008592073826, 0.4665213373743765, 0.4210312932573951, 0.45209879034568834, 0.4469945802659012, 0.5796210192694862, 0.5693710086594497, 0.6183789685586782, 0.5914045810545411, 0.4915364798221129, 0.5807705913859484, 0.5926706869945882, 0.5767371190865291, 0.6194621686696828, 0.13961069937631598, 0.11786354691905399, 0.17533593216332188, 0.34747064717187226, 0.22376216362498713, 0.31207667526199523, 0.131329375747695, 0.26841081336239736, 0.20844500921109088, 0.36926813005069925, 0.38489259911232354, 0.3688248278436771, 0.37158475974576743, 0.36378835923790664, 0.36105545201591815, 0.3369597508080443, 0.3120826280201592, 0.3778791366440303, 0.7625481350981992, 0.6921761267230071, 0.7360928835488548, 0.7234034084282078, 0.7342042218038127, 0.7179654936816234, 0.7426648481367087, 0.7196784103416035, 0.7718339195148944, 0.1786767664177773, 0.1507747117309458, 0.181264926985216, 0.12499104715133325, 0.13926841084919706, 0.5404939281529417, 0.10863482389455748, 0.15477247606431033, 0.16113041257006044, 0.3838436326298813, 0.20181577645761695, 0.19784189101447236, 0.16262826261887475, 0.2447646919638149, 0.19134629653946467, 0.22323871004177287, 0.24266639158237058, 0.19556472484987852, 0.4514050937292815, 0.5199716125466278, 0.4288445042877371, 0.5029219073020462, 0.4931191707324005, 0.48792818706459107, 0.48850624808285326, 0.5321078307620439, 0.529719518662803, 0.3441130931969689, 0.35555939697793104, 0.3227637806185297, 0.39328218668960035, 0.3160880970227402, 0.43419169146991754, 0.43365934187108346, 0.4133903282139191, 0.36316685706725194, 0.22770400548125536, 0.22020755597329245, 0.21781711335154497, 0.23964506385370277, 0.21068144263059208, 0.20524348534759107, 0.28965621270495034, 0.21198804869149923, 0.2429287755684697, 0.21133287766964526, 0.2237712763541716, 0.2076000012285958, 0.21088990162437704, 0.22382393407130374, 0.21403261513093497, 0.21556894196533305, 0.5197197664297926, 0.21743498242709525, 0.18542020974632556, 0.8661940747784999, 0.1825798913520239, 0.19922889552509204, 0.8425723530508186, 0.770296245715665, 0.8251107391763975, 0.8924466940062823, 0.8695795696684192, 0.8718531984865694, 0.20622951931341527, 0.2092457431838337, 0.16601493954307223, 0.16937938070675007, 0.16748206359492268, 0.7957483980488497, 0.7618488403366102, 0.7604766046807708, 0.21647497559953732, 0.18568817547737104, 0.18757096598250544, 0.18817542472222948, 0.22016715031598355, 0.202705425951607, 0.1895828262884499, 0.1912191082455078, 0.2187587806845066, 0.09851604793783353, 0.0981352061136207, 0.09284863764995877, 0.09673695292088291, 0.10392704861449997, 0.09326857091339302, 0.1256871587345335, 0.09844017571289698, 0.0967888578347954]}, "mutation_prompt": null}
{"id": "a9f12b18-bb6e-4df3-9892-2f496d3db473", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "A multi-phased optimizer merging adaptive parameters, population diversity, and local refinements with a probabilistic twist to improve convergence on varied landscapes.", "configspace": "", "generation": 95, "fitness": 0.4771458526587456, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "451d19d6-52b6-431a-b28b-29e92b1f1bb5", "solution": "import numpy as np\n\nclass RefinedHybridDE_NM_TLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.2 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                reflection = np.clip(centroid + 1.5 * (centroid - population[self.simplex_size-1]), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - population[self.simplex_size-1]), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - population[self.simplex_size-1]), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Targeted local search refinement\n            top_fraction = max(1, int(0.1 * self.population_size))\n            for i in range(top_fraction):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "RefinedHybridDE_NM_TLS", "description": "A refined multi-strategy algorithm enhancing Adaptive Differential Evolution with dynamic mutation, Nelder-Mead adaptation, and targeted local search for robust optimization.", "configspace": "", "generation": 96, "fitness": 0.44295150071545364, "feedback": "The algorithm RefinedHybridDE_NM_TLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.26.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8089599431598661, 0.8374969125082642, 0.8441664159406916, 0.8301657342515574, 0.8410808627145817, 0.8507202765343235, 0.8345187033438954, 0.826913269478145, 0.8645000961454761, 0.7048335817892092, 0.697085292739577, 0.7058209195586164, 0.6988298781782505, 0.7036436770267892, 0.7059982508512328, 0.6792002390470898, 0.6896267669486644, 0.689914784290825, 0.16411491910623244, 0.13613035863440148, 0.14192316092488633, 0.13718176401611015, 0.1787630638798935, 0.15689823608488518, 0.338993932990856, 0.14975324439192084, 0.5550695254197824, 0.11029365700044147, 0.10835768753295327, 0.11422515184166626, 0.11269199556625076, 0.11046266835769858, 0.11291927883508779, 0.11476137849653056, 0.1231978959443999, 0.12125681188345261, 0.9412833191013654, 0.938618461302978, 0.920043219686582, 0.9740367471649855, 0.9331284275182744, 0.9280580726777052, 0.9191479897733383, 0.9017307860816548, 0.9089405058135427, 0.5390188593667564, 0.6053877870579099, 0.5817253530684656, 0.568784057273996, 0.5916038782453692, 0.5686333806280535, 0.5667487813048138, 0.5846782484828514, 0.6001791222357743, 0.8492090737159981, 0.8573727374818608, 0.8401223861721471, 0.8736575651616216, 0.8523748043824128, 0.8499005558011585, 0.9018879177404502, 0.854964601888361, 0.8360238462043513, 0.4934287339034108, 0.5184428263054974, 0.13129536414297704, 0.5097343527652035, 0.40374583920774076, 0.13220384773913652, 0.5560584908826073, 0.6330360987981285, 0.3805708245850551, 0.4510217126326451, 0.13042682094229607, 0.542043571246967, 0.562517576356584, 0.466714315589316, 0.36384367278056295, 0.4967725878302188, 0.4283783641402531, 0.4344948881913504, 0.5445134626909777, 0.4269796716449873, 0.5684285051954439, 0.555020874394148, 0.5624799802173697, 0.5541199665968706, 0.5422573194701756, 0.5081253311606693, 0.5561801775783588, 0.6679486343310765, 0.6983176113255946, 0.7067752919121648, 0.6385767491412616, 0.6524822856848049, 0.6674909163260945, 0.6425915336119552, 0.6609871252085437, 0.6840772633311434, 0.08604833201228812, 0.2898703123986943, 0.12671778179385706, 0.34697363115841673, 0.19553441697689966, 0.47811025950275243, 0.2014672114796252, 0.17699901190162504, 0.3015605532781749, 0.4206643773097427, 0.45144596829743655, 0.42522485503910934, 0.4583589110321412, 0.4814512459388781, 0.47523043990946545, 0.40178322250824194, 0.4544800632936802, 0.4293494848746894, 0.7760373704168583, 0.7834226553290132, 0.7601590845934387, 0.7760428416266787, 0.7753159285770891, 0.792115440482333, 0.749183653050006, 0.7859750058565442, 0.7733385917333162, 0.15378059437750613, 0.15436821229367415, 0.1250578550151027, 0.1323755295420146, 0.13487453892021972, 0.13242369168560908, 0.16003633285922791, 0.11847811427132415, 0.14275640154835367, 0.5028465725860434, 0.27441095346105016, 0.19640866074757346, 0.21926710390550574, 0.2241079752070797, 0.3678674354182999, 0.1595432121613236, 0.22007306545424155, 0.32299158250811977, 0.448902983469015, 0.5238017428451116, 0.5972329647954814, 0.4335435790681499, 0.5158943586863105, 0.5605336283907068, 0.5136740821650466, 0.5999053487478245, 0.5596728142789751, 0.41076477702548975, 0.4645477820619822, 0.37749940216085776, 0.4131833193011891, 0.4362810336097718, 0.38411760987145493, 0.38056192708897707, 0.41781229232637085, 0.45619499768748006, 0.24590499718797987, 0.22826638952227285, 0.22136643661578848, 0.2101165204935157, 0.21218935519661009, 0.2021596274170845, 0.2088285047012589, 0.21984871993708932, 0.2120707303945345, 0.24128846334705978, 0.2028808745756685, 0.2015521800742175, 0.24940748754042064, 0.23417317638655977, 0.20759796462929725, 0.2112850144299856, 0.22687747665253433, 0.23089920759270932, 0.8489544005488014, 0.19369309896634201, 0.862671156376785, 0.16284098218808463, 0.8660679041275, 0.17745356984508653, 0.6447666018778558, 0.16949054431975996, 0.18374396088440814, 0.20762718538911318, 0.7137649522373843, 0.21107700006666397, 0.20671958734014173, 0.16652067064117526, 0.16817927940575061, 0.8061675672624473, 0.2097209105723642, 0.21226147518118976, 0.2241245380036585, 0.2030088456728696, 0.1866923667196818, 0.2104867360385675, 0.1798692965618668, 0.20442519909162626, 0.23993322966580788, 0.19759158513080188, 0.2000946101863874, 0.09960353887755957, 0.1109506060579164, 0.08972105280497222, 0.09571240627124766, 0.10173435856606139, 0.08958372212042409, 0.11847614413762408, 0.08791394538389141, 0.09070146479924501]}, "mutation_prompt": null}
{"id": "ff7c6679-633b-44a2-bf7d-e80306148403", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS_Improved:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim  # Increased population size for diversity\n        self.de_cross_over_rate = 0.85  # Adjusted crossover rate\n        self.de_f = 0.6 + 0.15 * np.random.rand()  # Adjusted stochastic adjustment\n        self.simplex_size = dim + 2  # Increase simplex size\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with enhanced diversity\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step with dynamic parameter adjustment\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n\n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n\n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step with dynamic expansion and contraction\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:\n                        expansion = np.clip(centroid + 2.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.6 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.4 * (population[j] - population[0])  # Adjusted reduction factor\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement with variable perturbation\n            for i in range(min(6, self.population_size)):  # Slightly more top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)  # Reduced variance\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS_Improved", "description": "A multi-strategy optimizer combining stochastic Adaptive Differential Evolution, dynamic Nelder-Mead adjustments, and variable-intensity local search for improved convergence.", "configspace": "", "generation": 97, "fitness": 0.35274776149282555, "feedback": "The algorithm EnhancedHybridDE_NM_SLS_Improved got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.736370854208791, 0.7356228131907568, 0.7443605381701104, 0.749658755420938, 0.7585755514457575, 0.7454958830808562, 0.7444033272660522, 0.7480322707608345, 0.7510762107493312, 0.5622280697118012, 0.5770872308577926, 0.5411331058818378, 0.542028076469083, 0.5530027732373233, 0.5274429013776695, 0.5357181840996745, 0.5529550391447913, 0.5574187546680406, 0.1439588179284167, 0.16929842878550916, 0.14192409667587402, 0.30631529108271194, 0.14380586590008337, 0.19157545809381915, 0.2213619631518613, 0.1451882973505204, 0.1432032772837567, 0.12807077248729126, 0.12762851147399545, 0.09747241394235262, 0.11405854215282907, 0.1263090197727701, 0.12353036187839239, 0.12713087205132634, 0.11609121997847449, 0.14635748696252537, 0.9524443647392332, 0.9641663927947399, 0.8958081050708997, 0.9767745502277903, 0.9796231920345657, 0.9227495166316074, 0.8967501316508862, 0.9709934699738118, 0.9376236014980571, 0.3916678034381925, 0.3625875500167637, 0.3692946551395563, 0.3728215205151725, 0.3593925995997963, 0.41498276834816117, 0.41062421015872186, 0.39219213989047386, 0.3785996962792809, 0.7221346067860068, 0.6794399529160112, 0.772613415278796, 0.7692323619983628, 0.8506696300143292, 0.6996363453568466, 0.7683988782106761, 0.6305917630674858, 0.7570302445753695, 0.21469206362835935, 0.1620414065039919, 0.2456975894846969, 0.12546939425877301, 0.2469375620467561, 0.24688931664496727, 0.3263443580872727, 0.33119849455391737, 0.22330651000286073, 0.1994245902908799, 0.2509507043133048, 0.28496915067986417, 0.32354961131612137, 0.2218315729942586, 0.20583757364604827, 0.3599811112516843, 0.3232232676285972, 0.3282896207869056, 0.23131579893605414, 0.251714463156947, 0.291183184660756, 0.24367191634380425, 0.23320370084245767, 0.23791875873050639, 0.2462179245727918, 0.2688829308231129, 0.2984057049424583, 0.33801885429535783, 0.40531631761803644, 0.44201544318968, 0.3845564594661408, 0.3414195343555422, 0.3407260885117227, 0.3796202148777498, 0.4018681150352711, 0.43330611130885377, 0.13240284655467927, 0.0829756559712922, 0.12949525399696904, 0.10433049595096089, 0.12837345307209458, 0.11384787224604165, 0.14875901472663466, 0.09755214821885383, 0.1577883153869436, 0.21570025649156022, 0.2386641426755055, 0.22887462674593684, 0.2546803054707074, 0.24609445108882655, 0.22926706678057784, 0.2276677576086763, 0.24930807607101124, 0.2362838729977358, 0.597371706238051, 0.5877625410433909, 0.6127171715939542, 0.6044452024931103, 0.6257847734816547, 0.6137182082394868, 0.62167167205896, 0.5959798348567336, 0.6235610687091628, 0.12594314114477279, 0.12491814185543049, 0.15791365875829544, 0.12687586808650342, 0.1524387397078315, 0.14533954729656307, 0.12849195259506907, 0.11488911861833762, 0.14212395590068194, 0.16558690212185323, 0.25353917896712275, 0.17591390027513554, 0.15036895916312665, 0.1990851584366603, 0.15039680600235628, 0.2442445278082339, 0.25690875470369223, 0.1907221168605101, 0.35967120673973973, 0.3430865441087996, 0.4077862346222485, 0.3715608847142784, 0.39475286134595167, 0.4242746815594093, 0.4130283384814887, 0.4404771807514817, 0.42026702233840985, 0.2784086678679404, 0.26876964083999155, 0.3113015086840609, 0.2993605085572646, 0.27236206451630596, 0.28780051628020287, 0.3020375763607178, 0.3294854634509864, 0.3699518788997166, 0.1968305352358598, 0.19641303402788868, 0.21301884369954227, 0.21185500159751758, 0.22787002938442336, 0.2112352842083539, 0.2080983271402166, 0.20565799153881337, 0.22832110861353117, 0.21481922771194573, 0.2925964384353291, 0.23273968465622707, 0.21186076466654336, 0.22655553094672076, 0.2205175705842607, 0.20964391436668117, 0.21334676717397394, 0.2146123609272408, 0.16283142248769056, 0.790985322661433, 0.17720878467154055, 0.7906142664430786, 0.7838562116842573, 0.16783190714806184, 0.16363889397883558, 0.8188510860486822, 0.7734710848231946, 0.19521770812342265, 0.7614405444952396, 0.5598620173440287, 0.2068313171576701, 0.16960523287587326, 0.20972144329124442, 0.7120851673760009, 0.6622482144574593, 0.20988044216099755, 0.20301445154957942, 0.17389441361038094, 0.19212675111466138, 0.17905972290935457, 0.19495735362724176, 0.18749239536081397, 0.18164345662613612, 0.1976523760809209, 0.19243128791873865, 0.08545230045834507, 0.08271249179360385, 0.12147675495574917, 0.08390218356090684, 0.08550583285371283, 0.10040337463724902, 0.11977475278285599, 0.0877373052854411, 0.10221487329812262]}, "mutation_prompt": null}
{"id": "0f5fc3f5-1aba-4241-aff0-9d5e9d990f6e", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.5 + 0.1 * np.random.rand()  # Minor stochastic adjustment\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.1, self.dim)\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "An enhanced multi-strategy algorithm integrating Adaptive Differential Evolution, Nelder-Mead, and stochastic local search for diverse optimization landscapes.", "configspace": "", "generation": 6, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8475229871300606, 0.8437727341366739, 0.8421881507959633, 0.8530760077804848, 0.851848260400236, 0.8576373671247833, 0.8456022341325248, 0.8515488061365355, 0.8487823575411209, 0.7094874154014696, 0.7226289021239707, 0.7219700492573167, 0.7036301675860943, 0.6875140745259783, 0.7226467824735476, 0.7070516241049334, 0.7163306535517973, 0.7060199037913844, 0.14841711698517224, 0.17053032563691795, 0.5562943445252168, 0.40066509881194123, 0.12521962136910147, 0.6197701320137912, 0.15472081726180276, 0.5194781106637227, 0.15945004313955502, 0.12393387077691109, 0.1315658898832447, 0.10908877094715086, 0.1498855453633121, 0.1355888858475388, 0.11424227794350206, 0.1403535252969652, 0.10279345279291408, 0.11294890514724898, 0.9489377453892931, 0.9517367937133286, 0.9456803907464505, 0.95085471297677, 0.9052776429806468, 0.9308297992165874, 0.9456332005013008, 0.932302802734025, 0.8920115141396747, 0.5892693329909138, 0.6214174546422395, 0.596981996627671, 0.6079951980249904, 0.6035721098559786, 0.6228199501957913, 0.5897693276130394, 0.5987678721139256, 0.6397283835453593, 0.8404302069632894, 0.3830331124422597, 0.8437528340112047, 0.8856561397265955, 0.8711576397746374, 0.8689776913088711, 0.8744468140496537, 0.8816291795323992, 0.8556985725495442, 0.5037710238515121, 0.44781915821505514, 0.47456957718932313, 0.43766456215853766, 0.47559440818732235, 0.2754228126726588, 0.36094343216833846, 0.620752589049622, 0.37504814660682606, 0.4496672144575842, 0.1865209670264255, 0.44763951493631804, 0.47593317802903123, 0.3977290156160461, 0.43922289253047464, 0.6488804688762901, 0.26090731675230816, 0.48491322252954305, 0.5817309112512626, 0.5549664538229337, 0.5743342689787537, 0.577314762797946, 0.5860280450948365, 0.5761202362425653, 0.564176059721143, 0.6066655115762944, 0.5673909856234408, 0.696798794781653, 0.6473530940547947, 0.7046538169618948, 0.683773815438959, 0.6511352926693346, 0.7015403562520235, 0.6109829992254255, 0.6741194009625612, 0.692283983254583, 0.09589569903096995, 0.24216160274329357, 0.1373638731950616, 0.415259663797403, 0.4560306677858784, 0.5139536067027943, 0.3319776990019313, 0.31695336385272643, 0.24431278003996237, 0.4322332936041434, 0.4640467325099824, 0.43816497228676743, 0.4819295209311395, 0.4934153963590532, 0.4642510810054562, 0.4461393278135358, 0.4670216500872182, 0.4393454733241511, 0.7762963953075976, 0.7767852825401483, 0.7819786752865574, 0.7600856260554387, 0.7882501159535847, 0.8077052192713248, 0.7781718819510939, 0.7764544288452393, 0.7849765423514394, 0.15132431269166968, 0.15848613454193805, 0.4182824248879844, 0.1483857579839385, 0.15239253507336448, 0.11527424069074454, 0.13487873659428606, 0.1816089641765577, 0.15489014792413514, 0.23047794203199656, 0.21982887466673207, 0.4497335100155204, 0.3558363050273562, 0.22879912968759142, 0.20565882538808644, 0.5054384898350749, 0.6222020896449014, 0.20746240808425198, 0.554293147945192, 0.5362834520867721, 0.5508705177570069, 0.5162892823484908, 0.5596819933330288, 0.4971996263196128, 0.5696747355521395, 0.6228648655243056, 0.6288687752789237, 0.4344997508621058, 0.3913133737019212, 0.31176266424173804, 0.45694327971760496, 0.4407892848139314, 0.46241169646906066, 0.44219274817424603, 0.477781966907435, 0.4445787917562446, 0.23181107285511315, 0.22977047383349603, 0.22311613315290924, 0.21968194439593147, 0.20516070500710626, 0.25442951493557175, 0.2562895424724284, 0.21501367591070042, 0.22936078548545524, 0.23832705247624364, 0.19337341955295073, 0.21976998189168906, 0.20409886306721658, 0.6438462403071981, 0.21498663829736087, 0.2175325888337295, 0.6224560893334281, 0.2382623968525689, 0.7960159873300139, 0.7897606437792082, 0.8638460457645113, 0.1849044186229729, 0.875257446709038, 0.1638355243561408, 0.7764025604280014, 0.7732585461540316, 0.8516143815487263, 0.20380670680426816, 0.8506178799135433, 0.20809262989021837, 0.8426038553290911, 0.16757103744145752, 0.8195360771115064, 0.2085652058466333, 0.21049683050978074, 0.21244652271836606, 0.20235848581479998, 0.194501502909749, 0.1828015681238343, 0.2093571282111255, 0.21461977706025448, 0.2051986246408769, 0.21877743281767703, 0.18574772454941768, 0.20148583271727694, 0.11302585347579353, 0.12231747017408034, 0.09550691554731039, 0.09050941908994536, 0.0910450682658086, 0.09268992711781632, 0.12717441857321776, 0.10441052936042616, 0.0986938032202952]}, "mutation_prompt": null}
{"id": "39577efe-b642-465b-ad6a-f28b1e5cdb68", "solution": "import numpy as np\n\nclass EnhancedHybridDE_NM_SLS:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.de_cross_over_rate = 0.9\n        self.de_f = 0.7 + 0.1 * np.random.rand()  # Adjusted with higher base for more aggressive exploration\n        self.simplex_size = dim + 1\n\n    def __call__(self, func):\n        budget_used = 0\n\n        # Initialize population with more diverse spread\n        population = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        fitness = np.array([func(ind) for ind in population])\n        budget_used += self.population_size\n\n        while budget_used < self.budget:\n            # Sort population by fitness\n            indices = np.argsort(fitness)\n            population = population[indices]\n            fitness = fitness[indices]\n\n            # Adaptive Differential Evolution step\n            for i in range(self.population_size):\n                if budget_used >= self.budget:\n                    break\n                \n                a, b, c = population[np.random.choice(self.population_size, 3, replace=False)]\n                mutant = np.clip(a + self.de_f * (b - c), self.lower_bound, self.upper_bound)\n                crossover = np.random.rand(self.dim) < self.de_cross_over_rate\n                trial = np.where(crossover, mutant, population[i])\n                \n                trial_fitness = func(trial)\n                budget_used += 1\n                if trial_fitness < fitness[i]:\n                    population[i] = trial\n                    fitness[i] = trial_fitness\n\n            if budget_used >= self.budget:\n                break\n\n            # Nelder-Mead Simplex step if budget allows\n            if budget_used + self.simplex_size <= self.budget:\n                centroid = np.mean(population[:self.simplex_size-1], axis=0)\n                worst = population[self.simplex_size-1]\n                reflection = np.clip(centroid + 1.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                reflection_fitness = func(reflection)\n                budget_used += 1\n\n                if reflection_fitness < fitness[self.simplex_size-2]:\n                    if reflection_fitness < fitness[0]:  # Check for the best position\n                        expansion = np.clip(centroid + 2.5 * (centroid - worst), self.lower_bound, self.upper_bound)\n                        expansion_fitness = func(expansion)\n                        budget_used += 1\n\n                        if expansion_fitness < reflection_fitness:\n                            population[self.simplex_size-1] = expansion\n                            fitness[self.simplex_size-1] = expansion_fitness\n                        else:\n                            population[self.simplex_size-1] = reflection\n                            fitness[self.simplex_size-1] = reflection_fitness\n                    else:\n                        population[self.simplex_size-1] = reflection\n                        fitness[self.simplex_size-1] = reflection_fitness\n                else:\n                    contraction = np.clip(centroid - 0.3 * (centroid - worst), self.lower_bound, self.upper_bound)  # More robust contraction strategy\n                    contraction_fitness = func(contraction)\n                    budget_used += 1\n\n                    if contraction_fitness < fitness[self.simplex_size-1]:\n                        population[self.simplex_size-1] = contraction\n                        fitness[self.simplex_size-1] = contraction_fitness\n                    else:\n                        for j in range(1, self.simplex_size):\n                            population[j] = population[0] + 0.5 * (population[j] - population[0])\n                            fitness[j] = func(population[j])\n                            budget_used += 1\n                            if budget_used >= self.budget:\n                                break\n\n            # Stochastic local search refinement\n            for i in range(min(5, self.population_size)):  # Apply to top solutions\n                if budget_used >= self.budget:\n                    break\n                local_perturbation = np.random.normal(0, 0.05, self.dim)  # Smaller perturbation for fine-tuning\n                candidate = np.clip(population[i] + local_perturbation, self.lower_bound, self.upper_bound)\n                candidate_fitness = func(candidate)\n                budget_used += 1\n                if candidate_fitness < fitness[i]:\n                    population[i] = candidate\n                    fitness[i] = candidate_fitness\n\n        # Return the best found solution\n        best_index = np.argmin(fitness)\n        return population[best_index], fitness[best_index]", "name": "EnhancedHybridDE_NM_SLS", "description": "A novel hybrid algorithm combining adaptive strategies from Differential Evolution, Nelder-Mead, and stochastic local perturbations for robust performance across diverse optimization landscapes.", "configspace": "", "generation": 99, "fitness": 0.3950157536944192, "feedback": "The algorithm EnhancedHybridDE_NM_SLS got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "10669ac2-2deb-4012-8670-74681c588796", "metadata": {"aucs": [0.8083778414432781, 0.7938741047819259, 0.7945109653463474, 0.8013941344786031, 0.8067832078637631, 0.8178317425122699, 0.7926500628978924, 0.8121403028146493, 0.8256126743586026, 0.6116908183366242, 0.6249323185706854, 0.6446118698101604, 0.5922238719565535, 0.6186450632981706, 0.6374340331663636, 0.597980206144159, 0.6386673324367178, 0.6169931263823325, 0.13924311306874004, 0.1461060339445185, 0.17153363255299814, 0.16448319406178435, 0.17327377201419114, 0.15283100809649663, 0.1674380218412025, 0.158503123249927, 0.17230165411744236, 0.10528516539679023, 0.11987471147184403, 0.12425103934311332, 0.09977952196123352, 0.12576519612810155, 0.1372142180766568, 0.12281108221781001, 0.15812139750179377, 0.1223318424524743, 0.922744086822266, 0.9781306340057685, 0.9374894172497648, 0.9239526450814153, 0.9388097772934136, 0.9439158435040506, 0.915066808741948, 0.9382341575533005, 0.944557510635543, 0.4164013938273323, 0.4362924612843907, 0.4505651195730256, 0.38359253054642795, 0.4767558245436262, 0.41959234041795024, 0.44171621706492314, 0.4991101950554959, 0.44993637242301443, 0.7471333197572467, 0.8109193595865694, 0.7771561013707047, 0.7933401095169819, 0.7954185640339552, 0.8021621254111393, 0.7450931052876483, 0.7522915363319052, 0.7863288727611113, 0.2733534688490442, 0.3928868449864683, 0.40300317634297844, 0.26798734446589056, 0.40144906720438245, 0.24691377123019276, 0.4153513395999059, 0.33860684559834786, 0.3562468447913315, 0.4330034652359225, 0.12794070142379987, 0.4268800994462, 0.3846906623761144, 0.36904188389668113, 0.4430519067815777, 0.12856852682090925, 0.35308805474950167, 0.4059249250261824, 0.34863777307345933, 0.4234077926911376, 0.3448353767148825, 0.31572682216092796, 0.3882923076335595, 0.3910672493987688, 0.3882908840363952, 0.4090588978502223, 0.4247163660439114, 0.5117416420694073, 0.543986664705307, 0.5360218608952134, 0.48020517265105134, 0.5076077511511414, 0.5239340918101818, 0.5647852214989441, 0.5613515122454864, 0.5560309445306435, 0.05950782929052878, 0.11897504559470085, 0.17637358860579333, 0.17182778033920132, 0.31215714290296215, 0.29143590822194365, 0.2420425030450606, 0.13814473420229445, 0.2252249287065361, 0.26239663824130444, 0.35338634321766005, 0.3048922111292157, 0.291346568217589, 0.3597879466209156, 0.3498068441554937, 0.2865833323213256, 0.3430166885567629, 0.31107826805564986, 0.724834945443199, 0.6998932247358747, 0.71494107946686, 0.6861193755976355, 0.7303889894219786, 0.7090922460225894, 0.6999178844734414, 0.7237780006008939, 0.6927206044934507, 0.12976179348204298, 0.1250098478121363, 0.13992257968649302, 0.1401537781062281, 0.1826450168306306, 0.14132342676333043, 0.14006639054304526, 0.11173790974475217, 0.1407024970544446, 0.18262342325700887, 0.328983066942937, 0.3213301702702561, 0.23102943703108225, 0.2725033004709164, 0.22088533384845932, 0.19183187485020758, 0.21495071169352908, 0.3668176779809712, 0.41705427473096224, 0.3983429340665786, 0.4085695565331122, 0.40277325790693874, 0.41175730400514854, 0.4291528434766019, 0.448647967679939, 0.4479426044648802, 0.4638752315505833, 0.3137708876894595, 0.30724787478657467, 0.3242754241404836, 0.312722507333398, 0.3651158509392627, 0.2997082843859651, 0.3046836065567863, 0.39762577183575887, 0.3329849277000301, 0.21597708966125206, 0.21528296840412664, 0.19831083482181033, 0.20634099537943607, 0.2390512778422148, 0.20733351356614804, 0.2047737891165381, 0.20861763868970784, 0.2108011207994075, 0.2187882631019541, 0.21412993348468556, 0.1949042800557571, 0.22697855827768088, 0.31967628766702016, 0.43405731268154135, 0.20278114429961414, 0.2005976104588486, 0.2452396298389422, 0.17465347326558023, 0.1954999136226856, 0.1981025065534725, 0.19821549254064696, 0.8131972137486255, 0.7411805296367273, 0.7683999267593884, 0.8497131115304206, 0.1699530194874722, 0.6799903388082132, 0.20628721655480886, 0.769514610053222, 0.20643792983525322, 0.16669672384393164, 0.16548471777401208, 0.745958949152735, 0.7118234809395705, 0.2131706957392684, 0.21034856596751328, 0.19110514992891758, 0.18997604445100313, 0.20127460684824472, 0.1811456916017784, 0.19058153033250613, 0.2056982128049173, 0.18747903694797774, 0.19762757928121966, 0.09188727851355594, 0.09038120201590338, 0.09816050304926272, 0.10902625433403268, 0.0933060311841396, 0.09353444206270656, 0.11042315894307753, 0.09465461524850782, 0.08877570489155806]}, "mutation_prompt": null}
