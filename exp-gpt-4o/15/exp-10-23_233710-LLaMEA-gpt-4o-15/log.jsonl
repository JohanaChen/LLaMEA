{"id": "7d022685-45b0-4670-85f9-4b0be08ca253", "solution": "import numpy as np\n\nclass AdaptiveEnsembleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveEnsembleDifferentialEvolution", "description": "Adaptive Ensemble Differential Evolution that dynamically combines multiple mutation strategies based on their historical performance.", "configspace": "", "generation": 0, "fitness": 0.4788506783204885, "feedback": "The algorithm AdaptiveEnsembleDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8689576907848577, 0.8738155574014049, 0.8638751290500233, 0.8816317724140159, 0.8635250386763064, 0.8875305542291987, 0.8813000721925099, 0.8799254294906722, 0.8743537149440052, 0.7704923783358815, 0.7127624144031453, 0.6721239625418455, 0.7200657201030731, 0.7099201214272934, 0.7507804881082027, 0.7794757690574006, 0.7199115558509099, 0.7477778209123641, 0.16746951417076938, 0.12443857410150283, 0.11975661255390146, 0.12566424749007876, 0.48848891223400726, 0.16831249634853507, 0.11420447940885547, 0.16328813927536134, 0.17190161533412573, 0.13787422887134948, 0.10575347645210964, 0.10820501301640872, 0.12921424685559724, 0.1106061248406871, 0.16754268204840572, 0.12488240355076996, 0.1475404386806527, 0.1240859887960678, 0.9845887586248041, 0.9669381774292465, 0.9843382817139231, 0.9777355262132833, 0.963828889013173, 0.9801582760379075, 0.9857082974897451, 0.9843416982425786, 0.9865774448965784, 0.6662379298640131, 0.7248834052651003, 0.719591970823511, 0.6889209998672634, 0.6795737178940302, 0.6457112968326661, 0.6686432290558608, 0.6842695382670718, 0.6855223492766633, 0.8677551591783329, 0.8265360175094132, 0.8259443330363679, 0.9169726579847636, 0.8487816590473135, 0.8890091068555974, 0.8388986335970198, 0.8695357156749578, 0.8651409875516397, 0.6900549016633788, 0.6784545063424872, 0.12107738558572345, 0.774495748436655, 0.5811359688767733, 0.7106562459317258, 0.6976585013741219, 0.5967664201798699, 0.6329630258677456, 0.6246453995479433, 0.11397201830837644, 0.6615139687011976, 0.6939900616775874, 0.6103312356083395, 0.13183470222948235, 0.6736521846657374, 0.6608644301337379, 0.5550091681421079, 0.3082361411591964, 0.6510630143755685, 0.6530655772521743, 0.6782776281081007, 0.6032842415344293, 0.5245443577246292, 0.5856319014646199, 0.6586569287024975, 0.6629710028131225, 0.7722849630887157, 0.6662034458486281, 0.6057329999517653, 0.6104058096292702, 0.7174083936220291, 0.7337490137874862, 0.7403301933703905, 0.7486409537073686, 0.7603755325973528, 0.5463922185857566, 0.19457028102487384, 0.45277184178481533, 0.16260095175544287, 0.15029922096724202, 0.3935433699925778, 0.144442542394152, 0.19693052284935908, 0.11879361553222223, 0.5814227535737306, 0.5706920289912415, 0.5517882447877762, 0.5990521976542711, 0.6048666821384734, 0.5803086685014731, 0.5964233836101549, 0.562696408805585, 0.5883509806491127, 0.8412115929409635, 0.8122965468991924, 0.8196097986049604, 0.8366021763343963, 0.8059856760647891, 0.8365652225927609, 0.825980320333985, 0.8362066281013998, 0.819372389482872, 0.13452924598008997, 0.1137956107935052, 0.09237583622608658, 0.10670626130270644, 0.11073282913799087, 0.1357973751946696, 0.10310734653519682, 0.13986474473010635, 0.1651557131462945, 0.14332055938013222, 0.13112806153754697, 0.14754170808556577, 0.15167971180746775, 0.1814159281515888, 0.15729659542776897, 0.11959215400282686, 0.15071050801744879, 0.14780348991461212, 0.4701411835770698, 0.530369172576711, 0.5874077980045842, 0.49667052929233646, 0.513044386992195, 0.6098244188328992, 0.5949083019401639, 0.5328197166543783, 0.5255150470664316, 0.5400588105651924, 0.46534496860309416, 0.4514155979951211, 0.4517350193891062, 0.5271887153492429, 0.21503128655746284, 0.5585235584817785, 0.2916427679627509, 0.2823020294827273, 0.2316449898040781, 0.20174115583642416, 0.21715989785785128, 0.1846380753574839, 0.19556583504059277, 0.1930287634604655, 0.25155624881135963, 0.20716020117942102, 0.19310373603154962, 0.2082485941662785, 0.23783848799417617, 0.18018865231633685, 0.20670105003548112, 0.239105064260275, 0.20039482669193642, 0.22159289230274148, 0.21592615933857418, 0.21844401977533656, 0.14656095716264972, 0.16149977847449282, 0.16326780201566748, 0.8976570467871222, 0.19423700905711616, 0.6186554936603096, 0.16901195535844094, 0.16199793939580465, 0.9092261602851747, 0.8603326798834308, 0.8040986591084852, 0.1251278493486534, 0.8799263972172848, 0.8664852651210624, 0.8570324542901494, 0.21079482635296476, 0.21010397186216656, 0.8789889559843154, 0.20328687372327658, 0.1975514554167339, 0.18247994593090466, 0.1831314422952931, 0.18702697243890565, 0.18437593797919227, 0.18207341523987108, 0.19564880323007905, 0.1957914749809333, 0.09201445686246312, 0.10672320323576501, 0.09262548646325408, 0.09118272574527853, 0.08590836820824221, 0.08751031958984112, 0.09408923873980457, 0.08250357907214334, 0.08896929959399769]}, "mutation_prompt": null}
{"id": "91fd16ca-52dd-4cf6-ba38-a7dc7e1524ee", "solution": "import numpy as np\n\nclass AdaptiveEnsembleDifferentialEvolutionEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = np.random.uniform(0.4, 1.0, self.population_size)  # Adaptive scaling\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                \n                # Update scaling factors to enhance diversity\n                self.scaling_factors[i] = 0.5 * self.scaling_factors[i] + 0.5 * np.random.rand()\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + self.scaling_factors[idx] * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + self.scaling_factors[idx] * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + self.scaling_factors[idx] * (best - population[idx]) + \\\n                 self.scaling_factors[idx] * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveEnsembleDifferentialEvolutionEnhanced", "description": "Adaptive Ensemble Differential Evolution enhanced by stochastic adaptive scaling factors and diversity preservation to improve convergence and robustness.", "configspace": "", "generation": 1, "fitness": 0.4502529871094509, "feedback": "The algorithm AdaptiveEnsembleDifferentialEvolutionEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.31.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8992865646763037, 0.8936810996057447, 0.8934980455982816, 0.926686176213653, 0.8834075972272415, 0.8950279756538603, 0.923875852289492, 0.9052419924547248, 0.9127360552784751, 0.841854906409589, 0.8034135578734518, 0.7842848406228554, 0.8075509431702946, 0.802414502357307, 0.7847164376706695, 0.14294732802927834, 0.776932484573561, 0.8120763939196048, 0.14851756016461481, 0.13816616695161354, 0.14983546226129307, 0.1433604580761001, 0.13563472336093296, 0.15611415021865738, 0.11595336953189583, 0.16191315922161975, 0.26187598944101287, 0.12878697634678393, 0.11162521657884683, 0.1391659869855646, 0.12267670639183692, 0.10949894868648224, 0.09887835071786266, 0.13908509201138552, 0.10424230494250897, 0.11031069108299929, 0.9675878829667152, 0.974073399773935, 0.981633604286917, 0.9846350883612071, 0.9823896916669714, 0.976447463045048, 0.9857625057521407, 0.9679178292067482, 0.9516286823435439, 0.8094699411040494, 0.7683514578201596, 0.7314496337340497, 0.7787075108006477, 0.7752975125931183, 0.7634325928799607, 0.783884577340247, 0.771258836093546, 0.780482912026967, 0.39544857008882084, 0.9132738577818289, 0.9338038519685542, 0.2810849892853152, 0.21133155521183533, 0.27859267640528207, 0.8954137658734265, 0.885870554431831, 0.9014080990788663, 0.13134952997458038, 0.5069152891254423, 0.12770638425125358, 0.13070980678967548, 0.13209714395638406, 0.530000945605917, 0.13652010736849785, 0.46177886112200084, 0.17578948230730862, 0.4928382083238593, 0.1961588347688662, 0.132189865588081, 0.5774655603198793, 0.13126236176543493, 0.2899646105487733, 0.21484382131171798, 0.6946577508899016, 0.13374556367641632, 0.7502628123508925, 0.6400075606209039, 0.6672194925032809, 0.8056197838566427, 0.6598556841586662, 0.7352331759782811, 0.011759339844833239, 0.6913349245409562, 0.500991464749275, 0.8301833577277428, 0.7452541995736105, 0.8150305373755893, 0.7377811346468892, 0.7781365106367363, 0.7802114684575552, 0.8143550155882621, 0.7633579555388539, 0.7893723420708318, 0.27448956719522355, 0.25953581436556183, 0.14867618704316643, 0.22764699053612114, 0.19344651195652196, 0.3183086769796981, 0.15643797905448897, 0.3761965797223654, 0.38080940236128247, 0.5780420348006164, 0.6364624635758229, 0.5468899892755901, 0.3875986667384347, 0.6279635375286219, 0.6774982418860427, 0.4497177054681233, 0.6448922745987142, 0.546432919876898, 0.7005221376845043, 0.8505032710542105, 0.8523410841855927, 0.8462224805064537, 0.844015738145912, 0.8278778637780534, 0.863202907162838, 0.851858175067184, 0.86124973705705, 0.07234822100719396, 0.1322588863355224, 0.1208124550877655, 0.14449249511111595, 0.15643209137818903, 0.12950130926202397, 0.12318507302452564, 0.14564121099216443, 0.14095688976942988, 0.13862110613624756, 0.2540024002254694, 0.2165634254815011, 0.2489668928077654, 0.2163772399565269, 0.14422565510214624, 0.2556580701050468, 0.16510527426273747, 0.32924223940791075, 0.33597894149646346, 0.6986491289286647, 0.5031344689983605, 0.5427115391579636, 0.6695914310548279, 0.3727419293563853, 0.5505371567209925, 0.5408194145837361, 0.5776059329166878, 0.236155122865912, 0.370608917384032, 0.559293355151392, 0.2279431814195948, 0.5364878942769512, 0.27855816483683027, 0.5560534427800878, 0.31723276421910873, 0.4781092220874933, 0.20880165220925917, 0.22266132367357339, 0.20679722702756675, 0.21052795711954608, 0.20540698152737058, 0.2392193520990913, 0.22409125931412532, 0.22622553291531644, 0.21986592616435763, 0.8280036420933169, 0.18520056763094395, 0.20468424036773192, 0.20291843085604233, 0.2014147056620379, 0.20269437116528743, 0.22333446067640939, 0.24669866975521537, 0.2090829560029499, 0.9320755830748951, 0.9157866016952358, 0.19813035381932464, 0.2002027736759313, 0.20842204777029338, 0.19672960496598857, 0.14241590772272616, 0.17720227330007943, 0.8238000933209826, 0.8969162376489028, 0.21101668190053635, 0.8634062334176915, 0.2104475922380088, 0.16617145648609255, 0.15457316744505, 0.20409219386291377, 0.1554765574595658, 0.8962885953433333, 0.1981013053614411, 0.1848880162736356, 0.18787287300896505, 0.20308912764336795, 0.188932446889582, 0.1846354004879559, 0.18424131675681032, 0.19036029858053938, 0.19184791782066746, 0.09516768958559874, 0.08923880554951069, 0.08171727935861961, 0.08405770048900452, 0.0938116855087463, 0.09265618585977775, 0.08190409446655067, 0.09220563757789602, 0.08581834528923937]}, "mutation_prompt": null}
{"id": "47e72c13-70d6-4945-97a3-f9813ed58106", "solution": "import numpy as np\n\nclass AdaptiveSelfAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = np.random.uniform(0.5, 1.0, self.population_size)\n        self.crossover_rates = np.random.uniform(0.7, 1.0, self.population_size)\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best, self.scaling_factors[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                    # Self-adaptive parameter adjustment\n                    self.scaling_factors[i] = np.minimum(1.0, self.scaling_factors[i] + 0.1)\n                    self.crossover_rates[i] = np.minimum(1.0, self.crossover_rates[i] + 0.05)\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    # Self-adaptive parameter adjustment\n                    self.scaling_factors[i] = np.maximum(0.5, self.scaling_factors[i] - 0.1)\n                    self.crossover_rates[i] = np.maximum(0.7, self.crossover_rates[i] - 0.05)\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best, scale_factor):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + scale_factor * (b - c)\n        return self.binomial_crossover(population[idx], mutant, self.crossover_rates[idx])\n\n    def de_best_1_bin(self, population, idx, best, scale_factor):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + scale_factor * (a - b)\n        return self.binomial_crossover(population[idx], mutant, self.crossover_rates[idx])\n\n    def de_rand_to_best_1_bin(self, population, idx, best, scale_factor):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + scale_factor * (best - population[idx]) + scale_factor * (a - b)\n        return self.binomial_crossover(population[idx], mutant, self.crossover_rates[idx])\n\n    def binomial_crossover(self, target, mutant, crossover_rate):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveSelfAdaptiveDE", "description": "Adaptive Strategy with Self-adaptive Parameters Differential Evolution, which dynamically adjusts mutation and crossover parameters and strategy selection based on evolutionary performance.", "configspace": "", "generation": 2, "fitness": 0.4441963817838371, "feedback": "The algorithm AdaptiveSelfAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.846190137840779, 0.8497163296899505, 0.8558284829851027, 0.8554065490014149, 0.857527423142863, 0.8629833858982089, 0.8461562564320473, 0.8552060148135631, 0.8670595663341444, 0.7431721212517657, 0.7262500947739936, 0.7262029908383447, 0.704516573941312, 0.7222236001731274, 0.7378672726710254, 0.7100045343583137, 0.7156931534016782, 0.7432054083903304, 0.1648736545894155, 0.1689758810420937, 0.3985341814027036, 0.5512736581690307, 0.5164891787741754, 0.11527006211640878, 0.1465744468630481, 0.17405899394003022, 0.5756926784683891, 0.15095084284468685, 0.14452419429557917, 0.14773269525625188, 0.15192552919290025, 0.12665397127590117, 0.13828289456414622, 0.11840444019289498, 0.49775194024285063, 0.117828641517703, 0.977773886478081, 0.9871229366935901, 0.9749481691889701, 0.9800885884678525, 0.9704389748334709, 0.9821513055316929, 0.9906919090733954, 0.9854994274710678, 0.9898535438438248, 0.6786605598465307, 0.6864215607967987, 0.6526843252943526, 0.6762592580103979, 0.7134973848522439, 0.7066927160176167, 0.687054145973587, 0.6845533595505902, 0.6855047545257751, 0.877257610355719, 0.8517274207602538, 0.8472420786160306, 0.8701849418882448, 0.8553949729332091, 0.8789899274023825, 0.8510363452803946, 0.8349487045931975, 0.8483278389270628, 0.6389500779028969, 0.5366861043053772, 0.6093532648623834, 0.12285053361210108, 0.12966172045778535, 0.12800459541068, 0.13039215186170316, 0.12401556959128734, 0.5692741563647417, 0.5622206444734579, 0.4450679304225932, 0.5735182982563173, 0.5186306781329515, 0.49608790280992565, 0.12806253554262637, 0.1266472458198572, 0.39341479597749596, 0.5781125115311809, 0.46494863913980866, 0.4590892607688566, 0.4649572703726551, 0.4120538221123715, 0.4154807619299805, 0.23093628462101357, 0.08134711577868892, 0.49697839752366113, 0.4391835220812512, 0.6093143531398515, 0.6115825849282193, 0.6082652406776148, 0.6072488420715565, 0.5268529289766737, 0.6228255802113658, 0.5962444840955987, 0.5564714759177696, 0.6511210164626777, 0.0739446135582853, 0.057461980883797725, 0.0802798768387738, 0.3724052913158, 0.24009037966999847, 0.28585071421117514, 0.11530069519425667, 0.11749597333115103, 0.2979836171348217, 0.38070703075257895, 0.4021420025156769, 0.4792965186449095, 0.456546741083408, 0.4128282824096403, 0.47455110801696654, 0.35600930443177237, 0.3575669853801352, 0.4344826925465882, 0.7566575916478965, 0.7673341181812636, 0.7940257242484999, 0.7454497158189631, 0.7456310626958029, 0.7720284232619756, 0.7820374725114654, 0.7124414038877951, 0.7647211663411234, 0.11302759100324833, 0.128376410342527, 0.13388386376613548, 0.11595391241824582, 0.13828282406107262, 0.14678627941855082, 0.11809607542622358, 0.11676729770980854, 0.16360702047733977, 0.2406508979863694, 0.14621477803941596, 0.28037689107996466, 0.2057347743471616, 0.22558657204213928, 0.15639878156247522, 0.12555901724301088, 0.15264094600075984, 0.6647173591330591, 0.5642358602840358, 0.4715180813051718, 0.45177359977454556, 0.6339003884683807, 0.5343449401614622, 0.533103452222127, 0.6040205934425624, 0.5545045210490631, 0.5776796193330049, 0.43307304447674766, 0.42028019150256324, 0.36428302460187134, 0.39806294611343784, 0.25742739767881817, 0.44816287953589373, 0.37574309704177045, 0.47879970433338603, 0.207387428780888, 0.2138732662467887, 0.21778669616990987, 0.21042088190419517, 0.19480802133969954, 0.2426652279536704, 0.19019770414640158, 0.20511596016118605, 0.21526339309621578, 0.21060871325613972, 0.21695646174850425, 0.4730892931122098, 0.21157661383544724, 0.23288787011816914, 0.23943120313272825, 0.19575665017090427, 0.20417085443695815, 0.24182416033844512, 0.24272617641722072, 0.13048578296935265, 0.1871061399986057, 0.18562970546935664, 0.8506239944976768, 0.20918295991581104, 0.166189844129499, 0.1416028816946544, 0.16146437665049163, 0.8776579496205359, 0.8678200322192404, 0.20886551755425897, 0.8773693837393896, 0.167469372280738, 0.16541500578495305, 0.8384100195326177, 0.7534671019670434, 0.6749189663240291, 0.8845154859067205, 0.19003578547699918, 0.19694931390603188, 0.1946750742651404, 0.17815492399414434, 0.19074444705122928, 0.18590714230887861, 0.18208680272683953, 0.1856113209580561, 0.19237548059559706, 0.08955262088771065, 0.08956335086246758, 0.08469184573001931, 0.10077358868665431, 0.09173352408013158, 0.08909000815291634, 0.08434352543214407, 0.0882589347762609, 0.08641783286258009]}, "mutation_prompt": null}
{"id": "0f5b0942-a38c-4d19-af10-ec259c4e6d49", "solution": "import numpy as np\n\nclass HybridEnsembleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)  # Slightly increased population size for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.base_scaling_factor = 0.8\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Added more variability in scaling factors\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_current_to_best_1_bin  # Added new strategy for hybrid approach\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + self.base_scaling_factor * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "HybridEnsembleDifferentialEvolution", "description": "Hybrid Ensemble Differential Evolution with Dynamic Adaptation of Strategy and Step Sizes to Enhance Convergence.", "configspace": "", "generation": 3, "fitness": 0.4759917907148252, "feedback": "The algorithm HybridEnsembleDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8973908269371825, 0.8971693981673086, 0.8834514145824739, 0.8902262029056515, 0.8906780197815076, 0.8973717710795913, 0.8853325510841661, 0.8885401790723684, 0.8824817224589023, 0.7972734919821025, 0.7904861188998282, 0.7009651495238571, 0.786348680784871, 0.7807336975518344, 0.7479319911625002, 0.7921800228908542, 0.7835373302947105, 0.7591622127227731, 0.1043489227733495, 0.14192795964469074, 0.13699829302305278, 0.11534141461935632, 0.1127251555062534, 0.5116557176836063, 0.15924166962258535, 0.6487737883514384, 0.1479751744845711, 0.137770143047674, 0.1275575371508043, 0.11013726580081074, 0.15246876569541457, 0.11068508459546833, 0.13411094223188935, 0.10886147262623158, 0.11877098163465727, 0.09727462655719332, 0.9606743831757993, 0.9542002255374955, 0.9808967056049251, 0.977030095504347, 0.9650518831707168, 0.9587330944820516, 0.9803395181360146, 0.9616146492081098, 0.9592971594694865, 0.7415921192008044, 0.7469543246545524, 0.741592136024194, 0.7354220892867271, 0.7529828322782895, 0.7679153259274227, 0.7623367567420751, 0.748301691668086, 0.7422175624510546, 0.8913014692934456, 0.88999878903851, 0.8665597326106046, 0.8943433751577113, 0.8863567912958178, 0.8809596047490511, 0.22067608361560265, 0.8953576358034002, 0.8620829535493404, 0.7328000387290047, 0.1245498261077751, 0.40049082416789994, 0.6058888781494476, 0.6460878188594059, 0.1290689082575962, 0.5726776867876806, 0.4646344690788409, 0.13298500534340674, 0.5905530115332391, 0.1303454059984146, 0.6726844808150618, 0.49922317828342844, 0.13180935447567044, 0.44477554267554364, 0.357385715933795, 0.502373802639063, 0.5208619589734067, 0.439367821663217, 0.4269291020719934, 0.6362127781349236, 0.3938825345883873, 0.6887912582313962, 0.5993483451916048, 0.6712557427159425, 0.6360907543960501, 0.6809116664713262, 0.7290250090949641, 0.6878790808981077, 0.7390127766476167, 0.7229285213147489, 0.6801160829478433, 0.6952721107804773, 0.7647822682592262, 0.7518217245348358, 0.7176057803932154, 0.415500749050874, 0.06912907330363449, 0.21358969569510122, 0.498238883651526, 0.49263461574355627, 0.4441590847279865, 0.24028926980192877, 0.15775243055003962, 0.13768532841759784, 0.588740096191913, 0.6101443563780793, 0.5509585624827743, 0.5897627385311428, 0.5571353334634632, 0.508907171537984, 0.5462987215375708, 0.6047963504127614, 0.5696962664763654, 0.835491358210178, 0.8402164752797632, 0.8628454664958995, 0.8468156435385308, 0.8325094507196664, 0.8161031807256739, 0.8197285880660506, 0.8462936467057394, 0.820345373466709, 0.1193357622313368, 0.11134043239599323, 0.12524498516953086, 0.1104105508447889, 0.09887833621348985, 0.11926423036188794, 0.12903375358850533, 0.13264944506820553, 0.10137912886873146, 0.19191515597565034, 0.1539838119254795, 0.4899944477276166, 0.16267608234237774, 0.1374341442436675, 0.1549867552223415, 0.24241839976837376, 0.14136791822411832, 0.2247621550561033, 0.6793821349009699, 0.3470154699128277, 0.6454039212705858, 0.5369814843448534, 0.6551522977401867, 0.5727046243733651, 0.6060149916628251, 0.5409619694108003, 0.6770381644966132, 0.3319100146123859, 0.5965398197153607, 0.6058823447882891, 0.5690775938460841, 0.3368012554379579, 0.45091672743829303, 0.4227089894485866, 0.4229005623379055, 0.21370973915270974, 0.19644360970351282, 0.21866406096608437, 0.2161284859329683, 0.21866738263044172, 0.20052244147352505, 0.21834691519510074, 0.22026303457677032, 0.21747638380575285, 0.22757160908824492, 0.219052996870571, 0.19748372423374927, 0.20471897581799559, 0.19872994164100788, 0.20728806632851948, 0.22001753832768922, 0.22254775460930876, 0.2460659624967858, 0.23977200722925696, 0.2099325024923201, 0.21168254284595167, 0.8652650733165899, 0.8757901364731445, 0.8936465129808541, 0.19264570934966052, 0.8930691625245438, 0.9041232645394041, 0.9208159500530928, 0.8970242081487787, 0.8381482854940685, 0.20948782530222443, 0.10457218890354325, 0.15378307524206936, 0.15503510616421756, 0.21128237500257396, 0.10450480590691935, 0.16525655639639192, 0.17670409709219836, 0.18266148651742475, 0.18812153795618058, 0.18089940985294206, 0.18879922836665897, 0.18896557234494538, 0.19566146328709277, 0.17957721341451272, 0.1748520838289227, 0.08506722688428259, 0.08535871010623086, 0.08021857087088591, 0.08825359713160974, 0.0857053542185715, 0.08562235153597753, 0.12188920283938864, 0.08510679921343367, 0.09788725588431846]}, "mutation_prompt": null}
{"id": "807349eb-5d86-4679-89fb-830aa47b6ddc", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.qde_rand_1_bin,\n            self.qde_best_1_bin,\n            self.qde_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def qde_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.quantum_binomial_crossover(population[idx], mutant)\n\n    def qde_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.quantum_binomial_crossover(population[idx], mutant)\n\n    def qde_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.quantum_binomial_crossover(population[idx], mutant)\n\n    def quantum_binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j] if np.random.rand() < 0.5 else -mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution utilizes quantum superposition principles to enhance mutation diversity and exploration in optimization.", "configspace": "", "generation": 4, "fitness": 0.16228007833506763, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.17.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.3250361807262382, 0.31161663925632865, 0.3375219292481412, 0.22870776158275707, 0.23831869271756734, 0.21738984812680962, 0.28504136854522877, 0.30551062744179625, 0.2978475311137819, 0.08345860285252094, 0.08149872734305552, 0.0913945305439493, 0.13483657931286486, 0.13832365529601942, 0.1506446191138926, 0.07311119951666256, 0.04524312135991637, 0.07752099528439593, 0.060929764439073164, 0.06860905471512757, 0.061949457302246436, 0.0746069194417256, 0.0757898024914706, 0.06708361234749316, 0.10016517844532813, 0.08558412572997187, 0.06481905880293637, 0.06293564281400976, 0.05952343878419741, 0.06819133286083412, 0.07112909676703727, 0.0575245219286451, 0.061695070508850924, 0.0719205537610973, 0.08390003753968123, 0.05078184627077176, 0.9003395498828013, 0.8621962710154941, 0.8528997778459048, 0.8652193691360078, 0.7999010163352234, 0.8332226895344279, 0.8965959557318551, 0.9180050868616361, 0.9649785059413105, 0.10996894781928601, 0.11512193736212284, 0.1224407023908054, 0.1505429285077724, 0.1561355235228038, 0.18384882698012173, 0.09932645871296186, 0.13041842750240562, 0.10470947206107006, 0.23411207998548123, 0.23692382414570512, 0.21899866724792216, 0.19226944686109404, 0.1719241315193658, 0.18045847414921068, 0.2188676532939079, 0.15985586865521784, 0.16284432141546334, 0.07047242581636604, 0.1212372348548264, 0.08462339549335351, 0.08958294852739712, 0.0708820277125276, 0.08419108188633873, 0.0765838202687753, 0.0710678935144613, 0.03496203866056535, 0.15563069597288182, 0.1495292253020194, 0.1847526959773742, 0.17397925347128163, 0.17535855403423406, 0.16418482207685503, 0.15127988663666714, 0.20628795631617836, 0.2114943540960036, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017833029099876274, 0.03210224824151087, 0.0011063942378366498, 0.04465983261249895, 0.057001999583555674, 0.06415054217332072, 0.04760813965086308, 0.048678678743269255, 0.06830461135275401, 0.09963507878435285, 0.09638551540660178, 0.07079295437803435, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0243860779740267, 0.026643952394419856, 0.02725619405126467, 0.010160791605694053, 0.033349341770253504, 0.01010673748894697, 0.014330232972793566, 0.027397779755909513, 0.035269917350411184, 0.26847203860376945, 0.2757539668649426, 0.26087325830835306, 0.2955885904655541, 0.27155081969052963, 0.3006268386630093, 0.2865341336889409, 0.29603150207538875, 0.2853560896788726, 0.04908816352584511, 0.0515195358037156, 0.06515851906254266, 0.06864240605160199, 0.058711990063569974, 0.06959892016929259, 0.06529918046073546, 0.0692860175217409, 0.06762623832448988, 0.12708356473790083, 0.1582442886168297, 0.1572724504033347, 0.11763710497937319, 0.15329016336574874, 0.1331847492120809, 0.13661778279266634, 0.14941707017609807, 0.13224005674093608, 0.2012464887785823, 0.19895166077708493, 0.18975677765071564, 0.22958205783901808, 0.22771566424657874, 0.22525824157029295, 0.1917324503954475, 0.20456163662628546, 0.17732801837958612, 0.12813353511960668, 0.1364632907801251, 0.12669331687526086, 0.1641025531215642, 0.17333061440861075, 0.14894411570013621, 0.1582223165379757, 0.15544534309474833, 0.13734599034347283, 0.19080471697851265, 0.22402437951462228, 0.19416984205340382, 0.19787228985047622, 0.18069644608043633, 0.20569299441536437, 0.19218582816777185, 0.2195517617313768, 0.20736963625420946, 0.16299518881528352, 0.1762098980038529, 0.1547968829594467, 0.16863108417721595, 0.16168462118728488, 0.16219850057859753, 0.16445679713333006, 0.16042717534370354, 0.164237639427674, 0.15950997006531065, 0.19055802900934327, 0.16565871839664104, 0.193230286994993, 0.20935536497557072, 0.17417305944024553, 0.15481864341382845, 0.22317720004048747, 0.1608749589453642, 0.17419543268638604, 0.21183993753163277, 0.1491253107824596, 0.21163925524257599, 0.1565331594756566, 0.13760634180328357, 0.16512932602179242, 0.17788801267858, 0.2285481744578688, 0.18864768386698738, 0.19313042848483986, 0.19499493784705546, 0.19159664607594618, 0.19373612662669026, 0.18575072186378683, 0.19158830835891327, 0.20326183411056886, 0.18077563332107693, 0.06809236250548567, 0.058957886345666566, 0.06264887130519381, 0.06999633702778829, 0.06081778649773073, 0.07463246828249726, 0.06244141647986856, 0.0824417342977315, 0.08060168734302531]}, "mutation_prompt": null}
{"id": "aa560366-8677-4d2d-b690-d5367c5aa8d8", "solution": "import numpy as np\n\nclass AdaptiveEnsembleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveEnsembleDifferentialEvolution", "description": "Adaptive Ensemble Differential Evolution that dynamically combines multiple mutation strategies based on their historical performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8689576907848577, 0.8738155574014049, 0.8638751290500233, 0.8816317724140159, 0.8635250386763064, 0.8875305542291987, 0.8813000721925099, 0.8799254294906722, 0.8743537149440052, 0.7704923783358815, 0.7127624144031453, 0.6721239625418455, 0.7200657201030731, 0.7099201214272934, 0.7507804881082027, 0.7794757690574006, 0.7199115558509099, 0.7477778209123641, 0.16746951417076938, 0.12443857410150283, 0.11975661255390146, 0.12566424749007876, 0.48848891223400726, 0.16831249634853507, 0.11420447940885547, 0.16328813927536134, 0.17190161533412573, 0.13787422887134948, 0.10575347645210964, 0.10820501301640872, 0.12921424685559724, 0.1106061248406871, 0.16754268204840572, 0.12488240355076996, 0.1475404386806527, 0.1240859887960678, 0.9845887586248041, 0.9669381774292465, 0.9843382817139231, 0.9777355262132833, 0.963828889013173, 0.9801582760379075, 0.9857082974897451, 0.9843416982425786, 0.9865774448965784, 0.6662379298640131, 0.7248834052651003, 0.719591970823511, 0.6889209998672634, 0.6795737178940302, 0.6457112968326661, 0.6686432290558608, 0.6842695382670718, 0.6855223492766633, 0.8677551591783329, 0.8265360175094132, 0.8259443330363679, 0.9169726579847636, 0.8487816590473135, 0.8890091068555974, 0.8388986335970198, 0.8695357156749578, 0.8651409875516397, 0.6900549016633788, 0.6784545063424872, 0.12107738558572345, 0.774495748436655, 0.5811359688767733, 0.7106562459317258, 0.6976585013741219, 0.5967664201798699, 0.6329630258677456, 0.6246453995479433, 0.11397201830837644, 0.6615139687011976, 0.6939900616775874, 0.6103312356083395, 0.13183470222948235, 0.6736521846657374, 0.6608644301337379, 0.5550091681421079, 0.3082361411591964, 0.6510630143755685, 0.6530655772521743, 0.6782776281081007, 0.6032842415344293, 0.5245443577246292, 0.5856319014646199, 0.6586569287024975, 0.6629710028131225, 0.7722849630887157, 0.6662034458486281, 0.6057329999517653, 0.6104058096292702, 0.7174083936220291, 0.7337490137874862, 0.7403301933703905, 0.7486409537073686, 0.7603755325973528, 0.5463922185857566, 0.19457028102487384, 0.45277184178481533, 0.16260095175544287, 0.15029922096724202, 0.3935433699925778, 0.144442542394152, 0.19693052284935908, 0.11879361553222223, 0.5814227535737306, 0.5706920289912415, 0.5517882447877762, 0.5990521976542711, 0.6048666821384734, 0.5803086685014731, 0.5964233836101549, 0.562696408805585, 0.5883509806491127, 0.8412115929409635, 0.8122965468991924, 0.8196097986049604, 0.8366021763343963, 0.8059856760647891, 0.8365652225927609, 0.825980320333985, 0.8362066281013998, 0.819372389482872, 0.13452924598008997, 0.1137956107935052, 0.09237583622608658, 0.10670626130270644, 0.11073282913799087, 0.1357973751946696, 0.10310734653519682, 0.13986474473010635, 0.1651557131462945, 0.14332055938013222, 0.13112806153754697, 0.14754170808556577, 0.15167971180746775, 0.1814159281515888, 0.15729659542776897, 0.11959215400282686, 0.15071050801744879, 0.14780348991461212, 0.4701411835770698, 0.530369172576711, 0.5874077980045842, 0.49667052929233646, 0.513044386992195, 0.6098244188328992, 0.5949083019401639, 0.5328197166543783, 0.5255150470664316, 0.5400588105651924, 0.46534496860309416, 0.4514155979951211, 0.4517350193891062, 0.5271887153492429, 0.21503128655746284, 0.5585235584817785, 0.2916427679627509, 0.2823020294827273, 0.2316449898040781, 0.20174115583642416, 0.21715989785785128, 0.1846380753574839, 0.19556583504059277, 0.1930287634604655, 0.25155624881135963, 0.20716020117942102, 0.19310373603154962, 0.2082485941662785, 0.23783848799417617, 0.18018865231633685, 0.20670105003548112, 0.239105064260275, 0.20039482669193642, 0.22159289230274148, 0.21592615933857418, 0.21844401977533656, 0.14656095716264972, 0.16149977847449282, 0.16326780201566748, 0.8976570467871222, 0.19423700905711616, 0.6186554936603096, 0.16901195535844094, 0.16199793939580465, 0.9092261602851747, 0.8603326798834308, 0.8040986591084852, 0.1251278493486534, 0.8799263972172848, 0.8664852651210624, 0.8570324542901494, 0.21079482635296476, 0.21010397186216656, 0.8789889559843154, 0.20328687372327658, 0.1975514554167339, 0.18247994593090466, 0.1831314422952931, 0.18702697243890565, 0.18437593797919227, 0.18207341523987108, 0.19564880323007905, 0.1957914749809333, 0.09201445686246312, 0.10672320323576501, 0.09262548646325408, 0.09118272574527853, 0.08590836820824221, 0.08751031958984112, 0.09408923873980457, 0.08250357907214334, 0.08896929959399769]}, "mutation_prompt": null}
{"id": "fd2ab56e-953b-4da5-aca1-a4bf3ec93a98", "solution": "import numpy as np\n\nclass AdaptiveEnsembleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveEnsembleDifferentialEvolution", "description": "Adaptive Ensemble Differential Evolution that dynamically combines multiple mutation strategies based on their historical performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8689576907848577, 0.8738155574014049, 0.8638751290500233, 0.8816317724140159, 0.8635250386763064, 0.8875305542291987, 0.8813000721925099, 0.8799254294906722, 0.8743537149440052, 0.7704923783358815, 0.7127624144031453, 0.6721239625418455, 0.7200657201030731, 0.7099201214272934, 0.7507804881082027, 0.7794757690574006, 0.7199115558509099, 0.7477778209123641, 0.16746951417076938, 0.12443857410150283, 0.11975661255390146, 0.12566424749007876, 0.48848891223400726, 0.16831249634853507, 0.11420447940885547, 0.16328813927536134, 0.17190161533412573, 0.13787422887134948, 0.10575347645210964, 0.10820501301640872, 0.12921424685559724, 0.1106061248406871, 0.16754268204840572, 0.12488240355076996, 0.1475404386806527, 0.1240859887960678, 0.9845887586248041, 0.9669381774292465, 0.9843382817139231, 0.9777355262132833, 0.963828889013173, 0.9801582760379075, 0.9857082974897451, 0.9843416982425786, 0.9865774448965784, 0.6662379298640131, 0.7248834052651003, 0.719591970823511, 0.6889209998672634, 0.6795737178940302, 0.6457112968326661, 0.6686432290558608, 0.6842695382670718, 0.6855223492766633, 0.8677551591783329, 0.8265360175094132, 0.8259443330363679, 0.9169726579847636, 0.8487816590473135, 0.8890091068555974, 0.8388986335970198, 0.8695357156749578, 0.8651409875516397, 0.6900549016633788, 0.6784545063424872, 0.12107738558572345, 0.774495748436655, 0.5811359688767733, 0.7106562459317258, 0.6976585013741219, 0.5967664201798699, 0.6329630258677456, 0.6246453995479433, 0.11397201830837644, 0.6615139687011976, 0.6939900616775874, 0.6103312356083395, 0.13183470222948235, 0.6736521846657374, 0.6608644301337379, 0.5550091681421079, 0.3082361411591964, 0.6510630143755685, 0.6530655772521743, 0.6782776281081007, 0.6032842415344293, 0.5245443577246292, 0.5856319014646199, 0.6586569287024975, 0.6629710028131225, 0.7722849630887157, 0.6662034458486281, 0.6057329999517653, 0.6104058096292702, 0.7174083936220291, 0.7337490137874862, 0.7403301933703905, 0.7486409537073686, 0.7603755325973528, 0.5463922185857566, 0.19457028102487384, 0.45277184178481533, 0.16260095175544287, 0.15029922096724202, 0.3935433699925778, 0.144442542394152, 0.19693052284935908, 0.11879361553222223, 0.5814227535737306, 0.5706920289912415, 0.5517882447877762, 0.5990521976542711, 0.6048666821384734, 0.5803086685014731, 0.5964233836101549, 0.562696408805585, 0.5883509806491127, 0.8412115929409635, 0.8122965468991924, 0.8196097986049604, 0.8366021763343963, 0.8059856760647891, 0.8365652225927609, 0.825980320333985, 0.8362066281013998, 0.819372389482872, 0.13452924598008997, 0.1137956107935052, 0.09237583622608658, 0.10670626130270644, 0.11073282913799087, 0.1357973751946696, 0.10310734653519682, 0.13986474473010635, 0.1651557131462945, 0.14332055938013222, 0.13112806153754697, 0.14754170808556577, 0.15167971180746775, 0.1814159281515888, 0.15729659542776897, 0.11959215400282686, 0.15071050801744879, 0.14780348991461212, 0.4701411835770698, 0.530369172576711, 0.5874077980045842, 0.49667052929233646, 0.513044386992195, 0.6098244188328992, 0.5949083019401639, 0.5328197166543783, 0.5255150470664316, 0.5400588105651924, 0.46534496860309416, 0.4514155979951211, 0.4517350193891062, 0.5271887153492429, 0.21503128655746284, 0.5585235584817785, 0.2916427679627509, 0.2823020294827273, 0.2316449898040781, 0.20174115583642416, 0.21715989785785128, 0.1846380753574839, 0.19556583504059277, 0.1930287634604655, 0.25155624881135963, 0.20716020117942102, 0.19310373603154962, 0.2082485941662785, 0.23783848799417617, 0.18018865231633685, 0.20670105003548112, 0.239105064260275, 0.20039482669193642, 0.22159289230274148, 0.21592615933857418, 0.21844401977533656, 0.14656095716264972, 0.16149977847449282, 0.16326780201566748, 0.8976570467871222, 0.19423700905711616, 0.6186554936603096, 0.16901195535844094, 0.16199793939580465, 0.9092261602851747, 0.8603326798834308, 0.8040986591084852, 0.1251278493486534, 0.8799263972172848, 0.8664852651210624, 0.8570324542901494, 0.21079482635296476, 0.21010397186216656, 0.8789889559843154, 0.20328687372327658, 0.1975514554167339, 0.18247994593090466, 0.1831314422952931, 0.18702697243890565, 0.18437593797919227, 0.18207341523987108, 0.19564880323007905, 0.1957914749809333, 0.09201445686246312, 0.10672320323576501, 0.09262548646325408, 0.09118272574527853, 0.08590836820824221, 0.08751031958984112, 0.09408923873980457, 0.08250357907214334, 0.08896929959399769]}, "mutation_prompt": null}
{"id": "94c479ae-485a-4257-b8ad-7392e0460333", "solution": "import numpy as np\n\nclass AdaptiveEnsembleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveEnsembleDifferentialEvolution", "description": "Adaptive Ensemble Differential Evolution that dynamically combines multiple mutation strategies based on their historical performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8689576907848577, 0.8738155574014049, 0.8638751290500233, 0.8816317724140159, 0.8635250386763064, 0.8875305542291987, 0.8813000721925099, 0.8799254294906722, 0.8743537149440052, 0.7704923783358815, 0.7127624144031453, 0.6721239625418455, 0.7200657201030731, 0.7099201214272934, 0.7507804881082027, 0.7794757690574006, 0.7199115558509099, 0.7477778209123641, 0.16746951417076938, 0.12443857410150283, 0.11975661255390146, 0.12566424749007876, 0.48848891223400726, 0.16831249634853507, 0.11420447940885547, 0.16328813927536134, 0.17190161533412573, 0.13787422887134948, 0.10575347645210964, 0.10820501301640872, 0.12921424685559724, 0.1106061248406871, 0.16754268204840572, 0.12488240355076996, 0.1475404386806527, 0.1240859887960678, 0.9845887586248041, 0.9669381774292465, 0.9843382817139231, 0.9777355262132833, 0.963828889013173, 0.9801582760379075, 0.9857082974897451, 0.9843416982425786, 0.9865774448965784, 0.6662379298640131, 0.7248834052651003, 0.719591970823511, 0.6889209998672634, 0.6795737178940302, 0.6457112968326661, 0.6686432290558608, 0.6842695382670718, 0.6855223492766633, 0.8677551591783329, 0.8265360175094132, 0.8259443330363679, 0.9169726579847636, 0.8487816590473135, 0.8890091068555974, 0.8388986335970198, 0.8695357156749578, 0.8651409875516397, 0.6900549016633788, 0.6784545063424872, 0.12107738558572345, 0.774495748436655, 0.5811359688767733, 0.7106562459317258, 0.6976585013741219, 0.5967664201798699, 0.6329630258677456, 0.6246453995479433, 0.11397201830837644, 0.6615139687011976, 0.6939900616775874, 0.6103312356083395, 0.13183470222948235, 0.6736521846657374, 0.6608644301337379, 0.5550091681421079, 0.3082361411591964, 0.6510630143755685, 0.6530655772521743, 0.6782776281081007, 0.6032842415344293, 0.5245443577246292, 0.5856319014646199, 0.6586569287024975, 0.6629710028131225, 0.7722849630887157, 0.6662034458486281, 0.6057329999517653, 0.6104058096292702, 0.7174083936220291, 0.7337490137874862, 0.7403301933703905, 0.7486409537073686, 0.7603755325973528, 0.5463922185857566, 0.19457028102487384, 0.45277184178481533, 0.16260095175544287, 0.15029922096724202, 0.3935433699925778, 0.144442542394152, 0.19693052284935908, 0.11879361553222223, 0.5814227535737306, 0.5706920289912415, 0.5517882447877762, 0.5990521976542711, 0.6048666821384734, 0.5803086685014731, 0.5964233836101549, 0.562696408805585, 0.5883509806491127, 0.8412115929409635, 0.8122965468991924, 0.8196097986049604, 0.8366021763343963, 0.8059856760647891, 0.8365652225927609, 0.825980320333985, 0.8362066281013998, 0.819372389482872, 0.13452924598008997, 0.1137956107935052, 0.09237583622608658, 0.10670626130270644, 0.11073282913799087, 0.1357973751946696, 0.10310734653519682, 0.13986474473010635, 0.1651557131462945, 0.14332055938013222, 0.13112806153754697, 0.14754170808556577, 0.15167971180746775, 0.1814159281515888, 0.15729659542776897, 0.11959215400282686, 0.15071050801744879, 0.14780348991461212, 0.4701411835770698, 0.530369172576711, 0.5874077980045842, 0.49667052929233646, 0.513044386992195, 0.6098244188328992, 0.5949083019401639, 0.5328197166543783, 0.5255150470664316, 0.5400588105651924, 0.46534496860309416, 0.4514155979951211, 0.4517350193891062, 0.5271887153492429, 0.21503128655746284, 0.5585235584817785, 0.2916427679627509, 0.2823020294827273, 0.2316449898040781, 0.20174115583642416, 0.21715989785785128, 0.1846380753574839, 0.19556583504059277, 0.1930287634604655, 0.25155624881135963, 0.20716020117942102, 0.19310373603154962, 0.2082485941662785, 0.23783848799417617, 0.18018865231633685, 0.20670105003548112, 0.239105064260275, 0.20039482669193642, 0.22159289230274148, 0.21592615933857418, 0.21844401977533656, 0.14656095716264972, 0.16149977847449282, 0.16326780201566748, 0.8976570467871222, 0.19423700905711616, 0.6186554936603096, 0.16901195535844094, 0.16199793939580465, 0.9092261602851747, 0.8603326798834308, 0.8040986591084852, 0.1251278493486534, 0.8799263972172848, 0.8664852651210624, 0.8570324542901494, 0.21079482635296476, 0.21010397186216656, 0.8789889559843154, 0.20328687372327658, 0.1975514554167339, 0.18247994593090466, 0.1831314422952931, 0.18702697243890565, 0.18437593797919227, 0.18207341523987108, 0.19564880323007905, 0.1957914749809333, 0.09201445686246312, 0.10672320323576501, 0.09262548646325408, 0.09118272574527853, 0.08590836820824221, 0.08751031958984112, 0.09408923873980457, 0.08250357907214334, 0.08896929959399769]}, "mutation_prompt": null}
{"id": "d5fffb83-ecbb-48d4-94f0-7fefc13882ad", "solution": "import numpy as np\n\nclass AdaptiveEnsembleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveEnsembleDifferentialEvolution", "description": "Adaptive Ensemble Differential Evolution that dynamically combines multiple mutation strategies based on their historical performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8689576907848577, 0.8738155574014049, 0.8638751290500233, 0.8816317724140159, 0.8635250386763064, 0.8875305542291987, 0.8813000721925099, 0.8799254294906722, 0.8743537149440052, 0.7704923783358815, 0.7127624144031453, 0.6721239625418455, 0.7200657201030731, 0.7099201214272934, 0.7507804881082027, 0.7794757690574006, 0.7199115558509099, 0.7477778209123641, 0.16746951417076938, 0.12443857410150283, 0.11975661255390146, 0.12566424749007876, 0.48848891223400726, 0.16831249634853507, 0.11420447940885547, 0.16328813927536134, 0.17190161533412573, 0.13787422887134948, 0.10575347645210964, 0.10820501301640872, 0.12921424685559724, 0.1106061248406871, 0.16754268204840572, 0.12488240355076996, 0.1475404386806527, 0.1240859887960678, 0.9845887586248041, 0.9669381774292465, 0.9843382817139231, 0.9777355262132833, 0.963828889013173, 0.9801582760379075, 0.9857082974897451, 0.9843416982425786, 0.9865774448965784, 0.6662379298640131, 0.7248834052651003, 0.719591970823511, 0.6889209998672634, 0.6795737178940302, 0.6457112968326661, 0.6686432290558608, 0.6842695382670718, 0.6855223492766633, 0.8677551591783329, 0.8265360175094132, 0.8259443330363679, 0.9169726579847636, 0.8487816590473135, 0.8890091068555974, 0.8388986335970198, 0.8695357156749578, 0.8651409875516397, 0.6900549016633788, 0.6784545063424872, 0.12107738558572345, 0.774495748436655, 0.5811359688767733, 0.7106562459317258, 0.6976585013741219, 0.5967664201798699, 0.6329630258677456, 0.6246453995479433, 0.11397201830837644, 0.6615139687011976, 0.6939900616775874, 0.6103312356083395, 0.13183470222948235, 0.6736521846657374, 0.6608644301337379, 0.5550091681421079, 0.3082361411591964, 0.6510630143755685, 0.6530655772521743, 0.6782776281081007, 0.6032842415344293, 0.5245443577246292, 0.5856319014646199, 0.6586569287024975, 0.6629710028131225, 0.7722849630887157, 0.6662034458486281, 0.6057329999517653, 0.6104058096292702, 0.7174083936220291, 0.7337490137874862, 0.7403301933703905, 0.7486409537073686, 0.7603755325973528, 0.5463922185857566, 0.19457028102487384, 0.45277184178481533, 0.16260095175544287, 0.15029922096724202, 0.3935433699925778, 0.144442542394152, 0.19693052284935908, 0.11879361553222223, 0.5814227535737306, 0.5706920289912415, 0.5517882447877762, 0.5990521976542711, 0.6048666821384734, 0.5803086685014731, 0.5964233836101549, 0.562696408805585, 0.5883509806491127, 0.8412115929409635, 0.8122965468991924, 0.8196097986049604, 0.8366021763343963, 0.8059856760647891, 0.8365652225927609, 0.825980320333985, 0.8362066281013998, 0.819372389482872, 0.13452924598008997, 0.1137956107935052, 0.09237583622608658, 0.10670626130270644, 0.11073282913799087, 0.1357973751946696, 0.10310734653519682, 0.13986474473010635, 0.1651557131462945, 0.14332055938013222, 0.13112806153754697, 0.14754170808556577, 0.15167971180746775, 0.1814159281515888, 0.15729659542776897, 0.11959215400282686, 0.15071050801744879, 0.14780348991461212, 0.4701411835770698, 0.530369172576711, 0.5874077980045842, 0.49667052929233646, 0.513044386992195, 0.6098244188328992, 0.5949083019401639, 0.5328197166543783, 0.5255150470664316, 0.5400588105651924, 0.46534496860309416, 0.4514155979951211, 0.4517350193891062, 0.5271887153492429, 0.21503128655746284, 0.5585235584817785, 0.2916427679627509, 0.2823020294827273, 0.2316449898040781, 0.20174115583642416, 0.21715989785785128, 0.1846380753574839, 0.19556583504059277, 0.1930287634604655, 0.25155624881135963, 0.20716020117942102, 0.19310373603154962, 0.2082485941662785, 0.23783848799417617, 0.18018865231633685, 0.20670105003548112, 0.239105064260275, 0.20039482669193642, 0.22159289230274148, 0.21592615933857418, 0.21844401977533656, 0.14656095716264972, 0.16149977847449282, 0.16326780201566748, 0.8976570467871222, 0.19423700905711616, 0.6186554936603096, 0.16901195535844094, 0.16199793939580465, 0.9092261602851747, 0.8603326798834308, 0.8040986591084852, 0.1251278493486534, 0.8799263972172848, 0.8664852651210624, 0.8570324542901494, 0.21079482635296476, 0.21010397186216656, 0.8789889559843154, 0.20328687372327658, 0.1975514554167339, 0.18247994593090466, 0.1831314422952931, 0.18702697243890565, 0.18437593797919227, 0.18207341523987108, 0.19564880323007905, 0.1957914749809333, 0.09201445686246312, 0.10672320323576501, 0.09262548646325408, 0.09118272574527853, 0.08590836820824221, 0.08751031958984112, 0.09408923873980457, 0.08250357907214334, 0.08896929959399769]}, "mutation_prompt": null}
{"id": "569b7968-ab9f-4bea-ad1f-911e57801b0d", "solution": "import numpy as np\n\nclass DynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.8\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.exploration_factor = 0.3\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n            self.adjust_exploration_exploitation()\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial\n\n    def adjust_exploration_exploitation(self):\n        # Adjust exploration-exploitation balance based on diversity\n        diversity = np.std(self.strategy_weights)\n        if diversity < self.exploration_factor:\n            self.crossover_rate = min(1.0, self.crossover_rate + 0.05)\n        else:\n            self.crossover_rate = max(0.6, self.crossover_rate - 0.05)", "name": "DynamicAdaptiveDifferentialEvolution", "description": "Dynamic Adaptive Differential Evolution with self-tuning strategies and enhanced exploration-exploitation balance.", "configspace": "", "generation": 9, "fitness": 0.3990452576385113, "feedback": "The algorithm DynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.26.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8453006259622764, 0.858291304406521, 0.8461974196932418, 0.8814526690944261, 0.8538513981318471, 0.8426305186977128, 0.8586307175981043, 0.8598821717827253, 0.8592390772993249, 0.7664718783783727, 0.6972494512737242, 0.7144144331423343, 0.749571248336489, 0.7267752853423757, 0.6261625031176948, 0.7359754412945616, 0.7532386137613644, 0.7283288190666644, 0.17153097228412828, 0.3880683514210941, 0.47419964240083434, 0.3984325040538734, 0.45252885700123835, 0.15598228120885338, 0.41409825334760586, 0.5509841283057175, 0.487306912634747, 0.1666491988215556, 0.1481795714281383, 0.2962974115491879, 0.15536511072407988, 0.21569726054532912, 0.4162618634844123, 0.1731472307775319, 0.34937590999182966, 0.16581056895548862, 0.9771696749984567, 0.9793210926709629, 0.9732324047335682, 0.9679391319550544, 0.9765191469355989, 0.9822541306926414, 0.9799531187331957, 0.9772889366615902, 0.9713656465783785, 0.5803890784561012, 0.5233915533399696, 0.49309486108876466, 0.6037170159748964, 0.5646105160090126, 0.5405506909248551, 0.5213762767587893, 0.5015106527276562, 0.5215350448677567, 0.7876422321394791, 0.6985975583721733, 0.7402672313339402, 0.7854986596387157, 0.7394919946896742, 0.8576253312972785, 0.7023105621434054, 0.6559372281274604, 0.7898305017686378, 0.34018438393222994, 0.33063980910867763, 0.28095747670372206, 0.36415609393477555, 0.29335865077904466, 0.39404575006131604, 0.4057575283275988, 0.3191180749012271, 0.35836064749058527, 0.26521048900841615, 0.39435613942457626, 0.24501002155832707, 0.39381740710829494, 0.30994791701045044, 0.4249796071421855, 0.285827579612116, 0.24148433428350224, 0.33281366788708944, 0.06559841153161872, 0.07688520455742731, 0.12923946199900294, 0.14834526256044378, 0.1054811346832688, 0.09080508120523556, 0.09274139922951286, 0.13490486913749633, 0.09145021923086238, 0.2820779416617515, 0.24025652112468787, 0.20305212710579912, 0.24265114154661171, 0.2384137789730889, 0.2585634909381731, 0.261681024475791, 0.29043597193011284, 0.37023785026082445, 0.08401380186709395, 0.06544394962746392, 0.12620855290369581, 0.1192600184593946, 0.10071529672130708, 0.12467372158103296, 0.12888495745411588, 0.23427415215889658, 0.09043768409007846, 0.25223819045232354, 0.20325164172918686, 0.27099804598822386, 0.23824456107302772, 0.2510397656805553, 0.2474372582750649, 0.2481433462769843, 0.25710153527283097, 0.2107188665700328, 0.6432409422926557, 0.600769199675584, 0.6358443492770878, 0.633664084610562, 0.6364138216810914, 0.6480428079394975, 0.6582708562737674, 0.6255613901586046, 0.6096758729479493, 0.11647532242193448, 0.10502031869015283, 0.09652229821240166, 0.10714255592421973, 0.11419813996535266, 0.1086400038805665, 0.13363331876699813, 0.12409872099374353, 0.12042836382017996, 0.16182238667901183, 0.17351886593838028, 0.14017396687913009, 0.12307317090821124, 0.1343346173353468, 0.14609490301944694, 0.1753382087516413, 0.13244122476574394, 0.1460890303618282, 0.47351765108744437, 0.4526659616671843, 0.49847058972294, 0.5351623082678245, 0.4446346786188091, 0.41533806899205206, 0.5723897482502317, 0.5453674766708032, 0.5427170301638677, 0.276038207922361, 0.36690659823549576, 0.33877475190122963, 0.30557898999393485, 0.3077441322675458, 0.32083757072698305, 0.3577180722938199, 0.3864040413481096, 0.3140855189877849, 0.22848729620018038, 0.2130641729183923, 0.1815766120246266, 0.2199561805784871, 0.20621742552638012, 0.19661373702641272, 0.19560364603837643, 0.21895527497468315, 0.20441463739003407, 0.23863875127403922, 0.487082058526475, 0.5184617774037914, 0.6390216551850354, 0.6443757672398543, 0.5055229922822828, 0.20303209623528906, 0.4988262958152523, 0.4018811196751153, 0.7840640539319056, 0.19340579765525046, 0.23556528809048483, 0.8596579894427563, 0.19556232700548293, 0.7171487305728325, 0.825265160360817, 0.6474070143638321, 0.8605099283943277, 0.7472632369761024, 0.20799723827504124, 0.666603844032657, 0.7518428743835093, 0.16575433378021898, 0.6913541862881161, 0.2071460979178854, 0.20975016299767346, 0.5584212505990498, 0.19042301612427615, 0.18107957675499609, 0.18788199244593629, 0.2020448446505615, 0.1748325976663766, 0.19049486116855496, 0.2100489044245012, 0.17815458156011665, 0.18818780236036614, 0.07918666541173514, 0.07540581289913084, 0.09464307107925851, 0.0815069446383081, 0.08368760888046711, 0.07108997873053235, 0.07381625304814221, 0.08501379353811367, 0.0830144983243275]}, "mutation_prompt": null}
{"id": "e2167ade-a1a4-43bc-b6c1-66863f7b31f3", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.strategy_weights = np.ones(3)  # DE, PSO, Hybrid\n        self.velocities = np.random.uniform(-1.0, 1.0, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        personal_best = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    3, p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                if strategy_idx == 0:\n                    # Differential Evolution strategy\n                    trial = self.de_rand_1_bin(population, i, global_best)\n                elif strategy_idx == 1:\n                    # Particle Swarm Optimization strategy\n                    trial = self.pso_update(population[i], i, personal_best[i], global_best)\n                else:\n                    # Hybrid strategy\n                    trial = self.hybrid_update(population[i], i, personal_best[i], global_best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    personal_best[i] = trial\n                    personal_best_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            global_best_idx = np.argmin(fitness)\n            global_best = population[global_best_idx]\n        \n        return global_best\n\n    def de_rand_1_bin(self, population, idx, global_best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def pso_update(self, particle, idx, personal_best, global_best):\n        velocity = (\n            self.inertia_weight * self.velocities[idx]\n            + self.cognitive_component * np.random.rand(self.dim) * (personal_best - particle)\n            + self.social_component * np.random.rand(self.dim) * (global_best - particle)\n        )\n        self.velocities[idx] = velocity\n        return particle + velocity\n\n    def hybrid_update(self, particle, idx, personal_best, global_best):\n        velocity = (\n            self.inertia_weight * self.velocities[idx]\n            + self.cognitive_component * np.random.rand(self.dim) * (personal_best - particle)\n            + self.social_component * np.random.rand(self.dim) * (global_best - particle)\n        )\n        self.velocities[idx] = velocity\n        mutant = personal_best + np.random.choice(self.scaling_factors) * (global_best - particle)\n        de_candidate = self.binomial_crossover(particle, mutant)\n        return (velocity + de_candidate) / 2\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "HybridDEPSO", "description": "Hybrid Differential Evolution and Particle Swarm Optimization that dynamically adjusts strategy based on performance feedback.", "configspace": "", "generation": 10, "fitness": 0.30379161067524013, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8992559997644916, 0.8533528401951946, 0.9048907664264505, 0.9085531346888909, 0.8820957751126839, 0.19025165152736112, 0.8996009024171308, 0.8993966303041414, 0.9127959836064168, 0.6728075414371136, 0.7826072399557078, 0.8044691949972752, 0.7399668677553203, 0.707648803679978, 0.7823041629800074, 0.05352875954609004, 0.006256301158862887, 0.7904512506784673, 0.09892434541655981, 0.07256929985036109, 0.09955527717120871, 0.09288696827283549, 0.11084685511152714, 0.09941464006848078, 0.14122576896212136, 0.7538235811888181, 0.13154363317060214, 0.13234026242286256, 0.07806305961181992, 0.08369222752395167, 0.07704917844694503, 0.05240031839036274, 0.16728471467987727, 0.1535477142071764, 0.09722007022888957, 0.11926530796291646, 0.9809170375599672, 0.9845260514979537, 0.9555619025878964, 0.9770408626508079, 0.9638557133241675, 0.9727078627760992, 0.9852617128618809, 0.9722944893396344, 0.9716578096548009, 0.32782985543206955, 0.3704863649885719, 0.3217688451595574, 0.43868556980469386, 0.3053305652501802, 0.3521960411726677, 0.3856633117178696, 0.29302546590029155, 0.35546525769976045, 0.38484200203685415, 0.2205777610027181, 0.17216488199840574, 0.19317456480780926, 0.15609864887586933, 0.19468918513733657, 0.1517057371795818, 0.7132684563526148, 0.23191941521270942, 0.22054604544650724, 0.33103367985901755, 0.40580950777831937, 0.2749871843849604, 0.20728088228171604, 0.3043654481585344, 0.27589638672878014, 0.2632085631807549, 0.2971800637495249, 0.25930457217193115, 0.12969151355725916, 0.256589692566497, 0.33427926578817124, 0.32686713433803793, 0.3969707117591753, 0.3411695388405718, 0.13235948389000218, 0.31285131186003534, 0.08646741193147844, 9.999999999998899e-05, 0.15964859111267615, 9.999999999998899e-05, 0.010789278815874437, 0.023886732717921966, 0.1546347377561884, 0.07435003382350569, 0.16213106348642936, 0.2222491918247752, 0.30343312380906207, 0.1127234998597969, 0.2262702833499125, 0.2701449356641329, 0.2028248290520841, 0.10740415108024859, 0.046086087955147015, 0.27163867517760487, 0.11985511211240696, 0.15371571179589516, 0.10461423955949467, 0.09634306883497468, 0.09767193495634385, 0.10620915333020786, 0.10074865212194306, 0.15707038835571507, 0.24568816138959426, 0.15778485393607866, 0.01138357780926924, 0.01170868414088777, 0.18084308252517478, 0.17070397578659935, 0.1737991606665773, 0.08227341616048778, 0.08105199827012821, 0.2870621191369239, 0.6366285979232286, 0.5918008974083215, 0.602908649109112, 0.5951704111928067, 0.5781427305377012, 0.6461684213092135, 0.6312874231653838, 0.5815423080848059, 0.6383844799515681, 0.05524391351404667, 0.1299431799420694, 0.17813520074757638, 0.12309161585479345, 0.048248372924899696, 0.12642925512208314, 0.09478428525965954, 0.1062038981366572, 0.12719625856928507, 0.17109268011483236, 0.2220072885148454, 0.33359126073165835, 0.31718940182038124, 0.16386499716328473, 0.20240441289907263, 0.22564629193083652, 0.19473428641572665, 0.1541679117633986, 0.29075528355547153, 0.3092369229952868, 0.33602449989026206, 0.3768236659161033, 0.22943726686321575, 0.424666676276235, 0.4241610378250692, 0.4813905724268882, 0.24686791360528682, 0.1873827103700958, 0.12164368360532918, 0.23109782331833806, 0.25794573300796886, 0.1604769655603432, 0.3067426590614334, 0.1972109320623986, 0.23521951499463045, 0.2143443085345209, 0.27020953546587734, 0.24026238746605455, 0.2167190017664944, 0.23115429564147982, 0.2504474150320427, 0.230503092571419, 0.24797065521988926, 0.26584057393434735, 0.21675892482954007, 0.20738290842879603, 0.19818271341779903, 0.2234429734890876, 0.20977446756680884, 0.1780399172892645, 0.21956339656582413, 0.19249825571816004, 0.18424644281228664, 0.18068714316233858, 0.1316582783812903, 0.1882999589306813, 0.9138724650930061, 0.11951644715322562, 0.1266601056468829, 0.1527571878610543, 0.12336088755988117, 0.1765857761850208, 0.8010947416262102, 0.16894033622194493, 0.16889451685639867, 0.8456867977642135, 0.8119694918717697, 0.12694200561690927, 0.1695516130490008, 0.1674535544519189, 0.10516797208054318, 0.8867294743170057, 0.20671802971163855, 0.20886653616538364, 0.18140401290163788, 0.20901152398312695, 0.19857208262210613, 0.18422144125024142, 0.19442826422465265, 0.1934558105012526, 0.20765194576488388, 0.10568834211550637, 0.07528618359073902, 0.08127139245555759, 0.08487793680344824, 0.06596306556390064, 0.0715016133958748, 0.11445878720908897, 0.06461452725422645, 0.08633079377100128]}, "mutation_prompt": null}
{"id": "f420d1d8-e62c-4b82-ab43-78740fc68bc2", "solution": "import numpy as np\n\nclass AdaptiveEnsembleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveEnsembleDifferentialEvolution", "description": "Adaptive Ensemble Differential Evolution that dynamically combines multiple mutation strategies based on their historical performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8689576907848577, 0.8738155574014049, 0.8638751290500233, 0.8816317724140159, 0.8635250386763064, 0.8875305542291987, 0.8813000721925099, 0.8799254294906722, 0.8743537149440052, 0.7704923783358815, 0.7127624144031453, 0.6721239625418455, 0.7200657201030731, 0.7099201214272934, 0.7507804881082027, 0.7794757690574006, 0.7199115558509099, 0.7477778209123641, 0.16746951417076938, 0.12443857410150283, 0.11975661255390146, 0.12566424749007876, 0.48848891223400726, 0.16831249634853507, 0.11420447940885547, 0.16328813927536134, 0.17190161533412573, 0.13787422887134948, 0.10575347645210964, 0.10820501301640872, 0.12921424685559724, 0.1106061248406871, 0.16754268204840572, 0.12488240355076996, 0.1475404386806527, 0.1240859887960678, 0.9845887586248041, 0.9669381774292465, 0.9843382817139231, 0.9777355262132833, 0.963828889013173, 0.9801582760379075, 0.9857082974897451, 0.9843416982425786, 0.9865774448965784, 0.6662379298640131, 0.7248834052651003, 0.719591970823511, 0.6889209998672634, 0.6795737178940302, 0.6457112968326661, 0.6686432290558608, 0.6842695382670718, 0.6855223492766633, 0.8677551591783329, 0.8265360175094132, 0.8259443330363679, 0.9169726579847636, 0.8487816590473135, 0.8890091068555974, 0.8388986335970198, 0.8695357156749578, 0.8651409875516397, 0.6900549016633788, 0.6784545063424872, 0.12107738558572345, 0.774495748436655, 0.5811359688767733, 0.7106562459317258, 0.6976585013741219, 0.5967664201798699, 0.6329630258677456, 0.6246453995479433, 0.11397201830837644, 0.6615139687011976, 0.6939900616775874, 0.6103312356083395, 0.13183470222948235, 0.6736521846657374, 0.6608644301337379, 0.5550091681421079, 0.3082361411591964, 0.6510630143755685, 0.6530655772521743, 0.6782776281081007, 0.6032842415344293, 0.5245443577246292, 0.5856319014646199, 0.6586569287024975, 0.6629710028131225, 0.7722849630887157, 0.6662034458486281, 0.6057329999517653, 0.6104058096292702, 0.7174083936220291, 0.7337490137874862, 0.7403301933703905, 0.7486409537073686, 0.7603755325973528, 0.5463922185857566, 0.19457028102487384, 0.45277184178481533, 0.16260095175544287, 0.15029922096724202, 0.3935433699925778, 0.144442542394152, 0.19693052284935908, 0.11879361553222223, 0.5814227535737306, 0.5706920289912415, 0.5517882447877762, 0.5990521976542711, 0.6048666821384734, 0.5803086685014731, 0.5964233836101549, 0.562696408805585, 0.5883509806491127, 0.8412115929409635, 0.8122965468991924, 0.8196097986049604, 0.8366021763343963, 0.8059856760647891, 0.8365652225927609, 0.825980320333985, 0.8362066281013998, 0.819372389482872, 0.13452924598008997, 0.1137956107935052, 0.09237583622608658, 0.10670626130270644, 0.11073282913799087, 0.1357973751946696, 0.10310734653519682, 0.13986474473010635, 0.1651557131462945, 0.14332055938013222, 0.13112806153754697, 0.14754170808556577, 0.15167971180746775, 0.1814159281515888, 0.15729659542776897, 0.11959215400282686, 0.15071050801744879, 0.14780348991461212, 0.4701411835770698, 0.530369172576711, 0.5874077980045842, 0.49667052929233646, 0.513044386992195, 0.6098244188328992, 0.5949083019401639, 0.5328197166543783, 0.5255150470664316, 0.5400588105651924, 0.46534496860309416, 0.4514155979951211, 0.4517350193891062, 0.5271887153492429, 0.21503128655746284, 0.5585235584817785, 0.2916427679627509, 0.2823020294827273, 0.2316449898040781, 0.20174115583642416, 0.21715989785785128, 0.1846380753574839, 0.19556583504059277, 0.1930287634604655, 0.25155624881135963, 0.20716020117942102, 0.19310373603154962, 0.2082485941662785, 0.23783848799417617, 0.18018865231633685, 0.20670105003548112, 0.239105064260275, 0.20039482669193642, 0.22159289230274148, 0.21592615933857418, 0.21844401977533656, 0.14656095716264972, 0.16149977847449282, 0.16326780201566748, 0.8976570467871222, 0.19423700905711616, 0.6186554936603096, 0.16901195535844094, 0.16199793939580465, 0.9092261602851747, 0.8603326798834308, 0.8040986591084852, 0.1251278493486534, 0.8799263972172848, 0.8664852651210624, 0.8570324542901494, 0.21079482635296476, 0.21010397186216656, 0.8789889559843154, 0.20328687372327658, 0.1975514554167339, 0.18247994593090466, 0.1831314422952931, 0.18702697243890565, 0.18437593797919227, 0.18207341523987108, 0.19564880323007905, 0.1957914749809333, 0.09201445686246312, 0.10672320323576501, 0.09262548646325408, 0.09118272574527853, 0.08590836820824221, 0.08751031958984112, 0.09408923873980457, 0.08250357907214334, 0.08896929959399769]}, "mutation_prompt": null}
{"id": "64a23eeb-31a8-4bbb-8f0b-c1562eff71a1", "solution": "import numpy as np\n\nclass AdaptiveEnsembleDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveEnsembleDifferentialEvolution", "description": "Adaptive Ensemble Differential Evolution that dynamically combines multiple mutation strategies based on their historical performance.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8689576907848577, 0.8738155574014049, 0.8638751290500233, 0.8816317724140159, 0.8635250386763064, 0.8875305542291987, 0.8813000721925099, 0.8799254294906722, 0.8743537149440052, 0.7704923783358815, 0.7127624144031453, 0.6721239625418455, 0.7200657201030731, 0.7099201214272934, 0.7507804881082027, 0.7794757690574006, 0.7199115558509099, 0.7477778209123641, 0.16746951417076938, 0.12443857410150283, 0.11975661255390146, 0.12566424749007876, 0.48848891223400726, 0.16831249634853507, 0.11420447940885547, 0.16328813927536134, 0.17190161533412573, 0.13787422887134948, 0.10575347645210964, 0.10820501301640872, 0.12921424685559724, 0.1106061248406871, 0.16754268204840572, 0.12488240355076996, 0.1475404386806527, 0.1240859887960678, 0.9845887586248041, 0.9669381774292465, 0.9843382817139231, 0.9777355262132833, 0.963828889013173, 0.9801582760379075, 0.9857082974897451, 0.9843416982425786, 0.9865774448965784, 0.6662379298640131, 0.7248834052651003, 0.719591970823511, 0.6889209998672634, 0.6795737178940302, 0.6457112968326661, 0.6686432290558608, 0.6842695382670718, 0.6855223492766633, 0.8677551591783329, 0.8265360175094132, 0.8259443330363679, 0.9169726579847636, 0.8487816590473135, 0.8890091068555974, 0.8388986335970198, 0.8695357156749578, 0.8651409875516397, 0.6900549016633788, 0.6784545063424872, 0.12107738558572345, 0.774495748436655, 0.5811359688767733, 0.7106562459317258, 0.6976585013741219, 0.5967664201798699, 0.6329630258677456, 0.6246453995479433, 0.11397201830837644, 0.6615139687011976, 0.6939900616775874, 0.6103312356083395, 0.13183470222948235, 0.6736521846657374, 0.6608644301337379, 0.5550091681421079, 0.3082361411591964, 0.6510630143755685, 0.6530655772521743, 0.6782776281081007, 0.6032842415344293, 0.5245443577246292, 0.5856319014646199, 0.6586569287024975, 0.6629710028131225, 0.7722849630887157, 0.6662034458486281, 0.6057329999517653, 0.6104058096292702, 0.7174083936220291, 0.7337490137874862, 0.7403301933703905, 0.7486409537073686, 0.7603755325973528, 0.5463922185857566, 0.19457028102487384, 0.45277184178481533, 0.16260095175544287, 0.15029922096724202, 0.3935433699925778, 0.144442542394152, 0.19693052284935908, 0.11879361553222223, 0.5814227535737306, 0.5706920289912415, 0.5517882447877762, 0.5990521976542711, 0.6048666821384734, 0.5803086685014731, 0.5964233836101549, 0.562696408805585, 0.5883509806491127, 0.8412115929409635, 0.8122965468991924, 0.8196097986049604, 0.8366021763343963, 0.8059856760647891, 0.8365652225927609, 0.825980320333985, 0.8362066281013998, 0.819372389482872, 0.13452924598008997, 0.1137956107935052, 0.09237583622608658, 0.10670626130270644, 0.11073282913799087, 0.1357973751946696, 0.10310734653519682, 0.13986474473010635, 0.1651557131462945, 0.14332055938013222, 0.13112806153754697, 0.14754170808556577, 0.15167971180746775, 0.1814159281515888, 0.15729659542776897, 0.11959215400282686, 0.15071050801744879, 0.14780348991461212, 0.4701411835770698, 0.530369172576711, 0.5874077980045842, 0.49667052929233646, 0.513044386992195, 0.6098244188328992, 0.5949083019401639, 0.5328197166543783, 0.5255150470664316, 0.5400588105651924, 0.46534496860309416, 0.4514155979951211, 0.4517350193891062, 0.5271887153492429, 0.21503128655746284, 0.5585235584817785, 0.2916427679627509, 0.2823020294827273, 0.2316449898040781, 0.20174115583642416, 0.21715989785785128, 0.1846380753574839, 0.19556583504059277, 0.1930287634604655, 0.25155624881135963, 0.20716020117942102, 0.19310373603154962, 0.2082485941662785, 0.23783848799417617, 0.18018865231633685, 0.20670105003548112, 0.239105064260275, 0.20039482669193642, 0.22159289230274148, 0.21592615933857418, 0.21844401977533656, 0.14656095716264972, 0.16149977847449282, 0.16326780201566748, 0.8976570467871222, 0.19423700905711616, 0.6186554936603096, 0.16901195535844094, 0.16199793939580465, 0.9092261602851747, 0.8603326798834308, 0.8040986591084852, 0.1251278493486534, 0.8799263972172848, 0.8664852651210624, 0.8570324542901494, 0.21079482635296476, 0.21010397186216656, 0.8789889559843154, 0.20328687372327658, 0.1975514554167339, 0.18247994593090466, 0.1831314422952931, 0.18702697243890565, 0.18437593797919227, 0.18207341523987108, 0.19564880323007905, 0.1957914749809333, 0.09201445686246312, 0.10672320323576501, 0.09262548646325408, 0.09118272574527853, 0.08590836820824221, 0.08751031958984112, 0.09408923873980457, 0.08250357907214334, 0.08896929959399769]}, "mutation_prompt": null}
{"id": "91e273e7-7778-4db2-9513-00630d0895d9", "solution": "import numpy as np\n\nclass DynamicAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8]  # Adjust scaling factors\n        self.crossover_rate = 0.85  # Tweak crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n            # Dynamic population size adjustment\n            if eval_count / self.budget > 0.3 and self.population_size > 5:\n                self.population_size = max(5, int(self.dim * 5))\n\n            if eval_count / self.budget > 0.7 and self.population_size > 10:\n                self.population_size = max(5, int(self.dim * 3))\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "DynamicAdaptiveDifferentialEvolution", "description": "Dynamic Adaptive Differential Evolution which incorporates historical performance and dynamic population sizing for enhanced exploration and exploitation.", "configspace": "", "generation": 13, "fitness": 0.4774986593943095, "feedback": "The algorithm DynamicAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.31.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.9018373286671769, 0.8970626378284821, 0.9075931269683035, 0.9138056064962616, 0.8917752359732711, 0.9088548033950754, 0.9073393010626888, 0.8979709691878963, 0.9014331954901222, 0.817868642309542, 0.7595808257895003, 0.7162640524887578, 0.7993417673823404, 0.7928590596149647, 0.8001118419263329, 0.8185643253242099, 0.8225971609797176, 0.8183175747219329, 0.10115197027402023, 0.12492933417532515, 0.14708219427522817, 0.11403261840618639, 0.6748687670063154, 0.14554034197806798, 0.09244413909648774, 0.5058813091448968, 0.12595877695093316, 0.11598673211170951, 0.14539223703668214, 0.14580029476061718, 0.12561767045776073, 0.1412906122194041, 0.10630432881820284, 0.14804102209388492, 0.12679377172903883, 0.1312076396738625, 0.9815737515424876, 0.965788029419206, 0.9836733691346574, 0.9703905255059343, 0.9604350085834665, 0.9714616521636052, 0.9270510897507387, 0.9790014831965936, 0.9754910876883756, 0.7464570981407025, 0.78035134542232, 0.7584356261457206, 0.7652061241784683, 0.7590516611312557, 0.755048733181926, 0.7724903498154991, 0.7669522351016933, 0.7734973753058217, 0.911365540694204, 0.8678646662201608, 0.9025065428980829, 0.9019424123643186, 0.8843656120341717, 0.8681848526221952, 0.855024191696245, 0.883392583284157, 0.8891239910442318, 0.7392219196802114, 0.6370275522274527, 0.13316713145660253, 0.6325761949466071, 0.6373496011558231, 0.5961643506506746, 0.13305421075449353, 0.6918155414831635, 0.13471413768570673, 0.17195363389084273, 0.6341271845448118, 0.5397227384334428, 0.8378932228134095, 0.6579552311118082, 0.6698399738452936, 0.13174355136285631, 0.12868552355127794, 0.5561851184234154, 0.677307129738786, 0.7141718781719293, 0.07307277066571372, 0.04097097557389118, 0.5591790032050156, 0.23574082507169236, 0.6380610474884748, 0.6639825818687457, 0.6884895988480826, 0.7859359197225884, 0.7308493649973673, 0.6598527940893217, 0.7373354541851785, 0.7547888304635686, 0.7532221331325836, 0.7647412362659537, 0.6744474185688165, 0.7945585297009606, 0.3381920741414599, 0.13073021114621808, 0.3030716496757727, 0.1774183851195006, 0.6661578083930361, 0.5552607930971883, 0.12536672511155134, 0.17755386374835047, 0.14258433184917918, 0.6104718410863101, 0.4571603409850179, 0.6378129798769943, 0.4996622409382141, 0.6001279899667601, 0.5514596156120433, 0.39473411710696504, 0.48358542120451753, 0.5472864363239958, 0.8688862538964759, 0.8342731374201898, 0.8113829528375631, 0.8514497085063407, 0.8560072712126908, 0.8643925260025567, 0.8663523235490582, 0.8540547677626679, 0.8127427160160128, 0.12060250444215093, 0.11930967864737974, 0.0976831195260558, 0.1037200930180372, 0.14972349529207674, 0.11743864719795305, 0.1384568822051817, 0.09973647655915885, 0.09683444835148969, 0.5259640484467196, 0.17706000344455097, 0.19939141612342526, 0.16907028537173574, 0.6645094180198752, 0.692506384333969, 0.35545062360436086, 0.18972819613803837, 0.17820646520464378, 0.40735568961342183, 0.5213574009630877, 0.574840701324371, 0.5162645322845976, 0.6838274175524847, 0.6133248076888607, 0.5166110139767555, 0.605225326992368, 0.41566486171239814, 0.3936100128495421, 0.2680323903388011, 0.44778295460700035, 0.5317308503475999, 0.6124030026500019, 0.3916392873332235, 0.4657963343035967, 0.3139842367162827, 0.47269549158001933, 0.23970951271392127, 0.2044378696972009, 0.19598696622378997, 0.21813461431460135, 0.21830536066145945, 0.21948109689318507, 0.31724011382231243, 0.20714086556129296, 0.22684789683782525, 0.22328204614832925, 0.7435837093738531, 0.6919933255127608, 0.25223311480458377, 0.23834015047592338, 0.21629020579187608, 0.21983401006889702, 0.20481127546780598, 0.21911312543246342, 0.854442304347425, 0.17703980746654657, 0.19397450528339044, 0.16400149831288946, 0.19902060254817766, 0.866903842246014, 0.1767541115921285, 0.1626819011379601, 0.15159292472081765, 0.8931926707815669, 0.20819357163864693, 0.12633678613941424, 0.11246404173311875, 0.8769482354890352, 0.16770010564626703, 0.20919514537422457, 0.2113543002104663, 0.16885486123658178, 0.18918330330959587, 0.18124578804804548, 0.1834758252403048, 0.18554130844617567, 0.1944692050089859, 0.1862311979717135, 0.18785302324878894, 0.20767999842628082, 0.1990601468077915, 0.10066727841671819, 0.08332117168078279, 0.09413172516006596, 0.09933123080802775, 0.09601903239082876, 0.09241908837002633, 0.09401252613189204, 0.08982076846379294, 0.07458189032845186]}, "mutation_prompt": null}
{"id": "2a78830b-19ff-4d1d-a2f7-46725a1a5f5f", "solution": "import numpy as np\n\nclass HybridParticleSwarmDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.inertia_weight = 0.7\n        self.cognitive_coefficient = 1.5\n        self.social_coefficient = 1.5\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        velocity = np.zeros((self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        personal_best_positions = np.copy(population)\n        personal_best_fitness = np.copy(fitness)\n        global_best_idx = np.argmin(fitness)\n        global_best = population[global_best_idx]\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                velocity[i] = (self.inertia_weight * velocity[i] +\n                               self.cognitive_coefficient * np.random.rand(self.dim) *\n                               (personal_best_positions[i] - population[i]) +\n                               self.social_coefficient * np.random.rand(self.dim) *\n                               (global_best - population[i]))\n                population[i] += velocity[i]\n                population[i] = np.clip(population[i], self.lower_bound, self.upper_bound)\n\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, global_best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < personal_best_fitness[i]:\n                    personal_best_positions[i] = trial\n                    personal_best_fitness[i] = trial_fitness\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n\n            population = new_population\n            fitness = new_fitness\n            current_global_best_idx = np.argmin(fitness)\n            current_global_best = population[current_global_best_idx]\n\n            if fitness[current_global_best_idx] < fitness[global_best_idx]:\n                global_best_idx = current_global_best_idx\n                global_best = current_global_best\n\n        return global_best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "HybridParticleSwarmDifferentialEvolution", "description": "Hybrid Particle Swarm Differential Evolution that adaptively blends swarm intelligence with differential mutation strategies for improved global search.", "configspace": "", "generation": 14, "fitness": 0.16195643450986072, "feedback": "The algorithm HybridParticleSwarmDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.19.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.3790268826256864, 0.28718882736143536, 0.2543755905642605, 0.3239670884028667, 0.3411708591395285, 0.37776832691234585, 0.33412052782455026, 0.18055238889774083, 0.35492391389071043, 0.018956188498546744, 0.06802166935887144, 9.999999999998899e-05, 0.00167192988248821, 0.0032210424109245794, 9.999999999998899e-05, 0.12357965962060313, 9.999999999998899e-05, 0.06786958996098114, 0.06927328455972315, 0.09643537867118124, 0.09231894066768453, 0.08631772577325247, 0.06741594534265516, 0.061492469222824586, 0.10863375996844138, 0.09759524317043178, 0.07092414333684116, 0.07207438662264953, 0.06453161744717928, 0.07219608170657954, 0.07140289185978599, 0.06185535566689526, 0.04707350911651975, 0.0722259256891854, 0.05900579193160793, 0.08584981241944256, 0.985833444092341, 0.9814670304401661, 0.9856454116157074, 0.9797262626765031, 0.9692650299012583, 0.963186571327965, 0.9905030646127263, 0.9755352568158835, 0.9854837834377652, 0.1827077627585012, 0.11576851471813765, 0.03801605740452685, 0.17097078668219712, 0.1393509354779342, 0.14434426851662463, 0.1924842356301013, 0.08092324043405463, 0.08290673113182023, 0.1828853375643924, 0.13708910970291976, 0.2027162105430642, 0.19035624328369993, 0.19234291420321847, 0.18508381513198013, 0.11992642270710951, 0.1823777968765472, 0.2588644922113401, 0.0587250863448322, 0.03956753447601369, 0.07193428777487987, 0.021265593669198446, 0.08981026642265133, 0.11502509297441899, 0.12913128020289655, 0.10536183752681139, 0.08981379995882144, 0.11003727678397957, 0.04145448881847291, 0.11637832983586593, 0.09501346595336058, 0.05881660338732364, 0.11534835218977935, 0.09232350484012808, 9.999999999998899e-05, 0.05015294126519787, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022015792747796525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09592820408902625, 0.019879333935722943, 0.06856818622851135, 0.12774858740368233, 0.01979298127612006, 0.004561669274177449, 0.06000490251650359, 0.00943735612071217, 0.013606157722623746, 9.999999999998899e-05, 0.011102832404854546, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0012950775522491131, 9.999999999998899e-05, 0.020889038836598095, 9.999999999998899e-05, 0.059021563207177, 0.0018875353912677362, 0.043114960617162024, 0.03368043303274115, 0.06270578009511829, 9.999999999998899e-05, 0.07029528048296074, 0.2972258748856792, 0.2980138136610574, 0.30321754931547207, 0.3091102818039776, 0.28492055442760855, 0.3087349521416719, 0.2628790714710362, 0.2854038157877997, 0.3178920952396074, 0.0644357268689022, 0.0845952949702179, 0.061464374782878806, 0.06786403216002768, 0.05508530631050346, 0.07011795102700469, 0.08380102491372965, 0.07296586193326182, 0.07625759139662147, 0.13452167022871742, 0.1541623401033947, 0.16111622815423765, 0.1898318819507222, 0.19131279817929303, 0.1422259090826068, 0.14193488837565327, 0.13219071619038436, 0.17141831300348565, 0.1890265261631362, 0.20403593078810478, 0.20367518579811128, 0.22437468964185903, 0.23084389818280626, 0.16920831240144452, 0.1976789170847092, 0.19274253684961584, 0.23193765698786561, 0.16132908356283038, 0.1621064644354665, 0.1725267375527414, 0.12185499427463797, 0.15074033870646364, 0.16408976758971971, 0.18923337627712467, 0.18981299099728788, 0.18260814137044157, 0.17945770453563015, 0.12859375450353294, 0.19130389933073888, 0.18929914020351757, 0.1992404231552951, 0.1880185135435083, 0.1952081019549512, 0.18370432225871702, 0.1933238682724483, 0.17982368926488612, 0.17041105973660975, 0.17146022881392908, 0.15668836137632225, 0.16144144445995168, 0.1774532191923639, 0.15989958514864244, 0.17090797033369787, 0.19131322596196654, 0.16069371937211674, 0.1564467986682897, 0.1520684477907689, 0.31211430968542797, 0.19244162512674035, 0.16478401485751526, 0.1356952838624178, 0.18139178463912564, 0.35028553568432763, 0.2264566610682326, 0.2041350471929142, 0.12151876105354864, 0.19986500945173558, 0.16576869600863287, 0.12809340915731193, 0.10408583175700992, 0.10260072088664729, 0.18590092643780332, 0.18853139550738085, 0.18622593760037753, 0.17881703917697833, 0.17130710473641098, 0.17307182645529795, 0.20893768138018365, 0.1832600805578155, 0.17973723935464692, 0.1872750282734612, 0.06669733495109398, 0.06658802883761383, 0.049348660828563706, 0.08202192855175094, 0.07451000559970689, 0.06587756601121475, 0.0689572862728719, 0.059653554750123794, 0.06275869972468173]}, "mutation_prompt": null}
{"id": "ecc60e0f-110c-4c58-b2e2-d0c8df5fb30c", "solution": "import numpy as np\n\nclass DiversityDrivenAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            diversity = np.mean(np.std(population, axis=0))\n            self.strategy_weights = self.strategy_weights * (1 + 0.1 * diversity)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "DiversityDrivenAdaptiveDifferentialEvolution", "description": "Diversity-Driven Adaptive Differential Evolution that adjusts strategy weights based on both historical performance and population diversity.", "configspace": "", "generation": 15, "fitness": 0.4765437479056897, "feedback": "The algorithm DiversityDrivenAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8685421443614902, 0.855573623160913, 0.871653452195602, 0.8881313363944036, 0.8713267918031153, 0.88739906328577, 0.8769195860508757, 0.8739859900427829, 0.8711704292170263, 0.7147419014624258, 0.6984838898903635, 0.6185662155946812, 0.7191946576512214, 0.690391983963013, 0.7496824185663685, 0.7814296830785091, 0.7535268643793401, 0.7314061163373959, 0.16900635428229638, 0.14893347655753275, 0.13404799282453228, 0.1366628654837756, 0.144086524090982, 0.14819760188438935, 0.09330526409154505, 0.15209868634531853, 0.14366213029988628, 0.11571162022742665, 0.13989430953316806, 0.12495302712305689, 0.1251674663155723, 0.12233305156282859, 0.12773356532940283, 0.13974892785503967, 0.14291020499890805, 0.1019011179109015, 0.9800815719865732, 0.9622162312932894, 0.9843382817139231, 0.9776871420585268, 0.963828889013173, 0.9772310214373852, 0.9857082974897451, 0.9843416982425786, 0.9865774448965784, 0.5860783289351998, 0.6784490381798485, 0.6715145216008531, 0.6535437803938839, 0.6853851430508355, 0.6530201886046667, 0.6721462852069914, 0.6898845786023325, 0.6873222478783533, 0.8406855600465816, 0.8163500630874349, 0.8087549762686476, 0.8424819367953316, 0.20814239013657054, 0.8739502374976829, 0.8606187380861203, 0.8554733609691525, 0.8551580980924113, 0.7049376728378113, 0.12949973468637876, 0.6314256458687975, 0.13086183586919142, 0.5258169732829648, 0.6922369627821918, 0.7199235221834975, 0.12686425128353696, 0.7324640886556788, 0.7133841364845429, 0.518719606190647, 0.6465895667761936, 0.7478532887388059, 0.6762707958416527, 0.6642679553510584, 0.7034666053563187, 0.6568514774193948, 0.6778378789005226, 0.5785264388604165, 0.5966552793841604, 0.6194616896949166, 0.6920347071087944, 0.6662341423941894, 0.6236016540352555, 0.6343626299675507, 0.6701025753309676, 0.6253777774936673, 0.7509289985451842, 0.667492169746134, 0.5597692478565284, 0.6333429504319007, 0.729350813223822, 0.7173350403435503, 0.7386063637716356, 0.7336795469178761, 0.7605248146499953, 0.15269309457995295, 0.2510528960289192, 0.2876981560248121, 0.6164244584101224, 0.5893452129505414, 0.5654047639532798, 0.28798245876937867, 0.13680702329733208, 0.19597496606523057, 0.5331483156741261, 0.5440625865581779, 0.5208740498320084, 0.6121743289017145, 0.5343165045545677, 0.584946361900936, 0.6064571694588536, 0.6008187680886461, 0.5576826576949311, 0.842005838765659, 0.8112543990373718, 0.8155507025159497, 0.825976980543069, 0.8406000965883804, 0.8408682780726171, 0.8409922722552166, 0.8278834136933634, 0.8026144942033352, 0.10947444521154248, 0.13140176475754906, 0.08511623032743243, 0.14932694164892912, 0.13448012588197966, 0.1418998848645655, 0.13689195553519407, 0.12710089619685372, 0.14106801076802877, 0.2043633555408504, 0.12892169128741093, 0.29682834939587166, 0.13803451139789302, 0.18252727725902784, 0.16725296271625434, 0.19524216355158786, 0.20254267272543025, 0.15026417428177752, 0.47913030858844496, 0.5666659108636931, 0.5754202831595799, 0.41539671874839, 0.45936827280583525, 0.5528571412885859, 0.6225949242541636, 0.5809705169269522, 0.4960739029809851, 0.4960691090010607, 0.4039281746127513, 0.44031991920277436, 0.3967754555806354, 0.45330894722071124, 0.2128296126685838, 0.43640331205803096, 0.5106989059826385, 0.27930998178776834, 0.19105801318083537, 0.22275776819729387, 0.19303089571833387, 0.1867048224170641, 0.19109364186437983, 0.18691132573945346, 0.23374600957117175, 0.22386815912995417, 0.23745003381964402, 0.24820068517727045, 0.48666812681220806, 0.22455928228979638, 0.24785130115573983, 0.22999447346060575, 0.2039452826414968, 0.19798878161492683, 0.1940131525051102, 0.19658413243672002, 0.15125602423949092, 0.16234476146149768, 0.1946644441148192, 0.1644264387175406, 0.8552977081291949, 0.17652142220935763, 0.8315911371352951, 0.16234071391340021, 0.8876369000275383, 0.8684327127452367, 0.8026786697051738, 0.2060937237391819, 0.20409344905179327, 0.8193933245312247, 0.8356934593828321, 0.21069521577437633, 0.21000112562870743, 0.8694309897640327, 0.18765919276825593, 0.18187166849295067, 0.19702479249057292, 0.18180351065363043, 0.19142843699264256, 0.18102922878997296, 0.22083471390533327, 0.19054166514524695, 0.1869845131049881, 0.0893992868996798, 0.08461373497900915, 0.1073813877658858, 0.08719147632878443, 0.08692673627629288, 0.08871098354159457, 0.08219926050134874, 0.09334278839138532, 0.08890977911819331]}, "mutation_prompt": null}
{"id": "463d8caf-0036-4cb1-9e5c-aaff43e40dda", "solution": "import numpy as np\n\nclass StochasticHierarchicalAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_weights_sum = self.strategy_weights.sum()\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / strategy_weights_sum\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        indices = np.random.choice(range(self.population_size), 3, replace=False)\n        a, b, c = population[indices]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):\n        indices = np.random.choice(range(self.population_size), 4, replace=False)\n        a, b, c, d = population[indices]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b + c - d)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        indices = np.random.choice(range(self.population_size), 2, replace=False)\n        a, b = population[indices]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "StochasticHierarchicalAdaptiveDifferentialEvolution", "description": "Stochastic Hierarchical Adaptive Differential Evolution using a hierarchical structure for mutation strategy selection and dynamic parameter adaptation.", "configspace": "", "generation": 16, "fitness": 0.4492233571372584, "feedback": "The algorithm StochasticHierarchicalAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8649227807272132, 0.843467336059772, 0.8502651442661724, 0.8409648985443229, 0.8644273744353437, 0.8549886515559141, 0.8615559642271883, 0.8348610317965977, 0.8325774433232884, 0.7177365437826504, 0.6871429243596394, 0.7109635425031122, 0.7480163900407699, 0.7372961960550355, 0.654093657082842, 0.7553340608156451, 0.6938376109208854, 0.6975466504621055, 0.12136628049513876, 0.11753079455227833, 0.12507421456881362, 0.14617282600528092, 0.1130533929383255, 0.12739311168517964, 0.13022593973037455, 0.1153597282243487, 0.12775567424102063, 0.1276455240254516, 0.10986585299081653, 0.12363930467225126, 0.12459986157173886, 0.1038135753020939, 0.11327652151036727, 0.11828436636675665, 0.09786152174288287, 0.12885339314033095, 0.9852991202299016, 0.9852509132766991, 0.9729766679819376, 0.9629581906255611, 0.9720649979199679, 0.980363152990914, 0.9831392346510758, 0.9811571173282653, 0.979764431158757, 0.6659762253084635, 0.5941547662818987, 0.6365207565373537, 0.6315367097819938, 0.6860550647258445, 0.6381272027147541, 0.6908557621309435, 0.6523482932014881, 0.5518180854921821, 0.8677852500294978, 0.8290810288351257, 0.8852097666408473, 0.8342781437392743, 0.8046046344713886, 0.8487681993734637, 0.8606887872998344, 0.8365976839150245, 0.8340352206806869, 0.6365914158664829, 0.5458083624026593, 0.5615716303449192, 0.12578855706784198, 0.5895836982700284, 0.5847347811676171, 0.5267240066932185, 0.6167482209847959, 0.6019503872897269, 0.5102694170903974, 0.5081868463005192, 0.1305146530639586, 0.6402129434983246, 0.5403226777710188, 0.626777417618612, 0.6525813267322413, 0.5326887299694945, 0.5793374778419715, 0.49134075466520566, 0.4698522652913817, 0.4936848213923356, 0.47578858697820525, 0.4455543871624642, 0.584000608204242, 0.6012122712687559, 0.4644984030408087, 0.44652837455952554, 0.6981779159672261, 0.6553339198735342, 0.6014963057276317, 0.6578829310166192, 0.5439143554658823, 0.6792793109176757, 0.7129225054333598, 0.6151645948104922, 0.6920463872929412, 0.27687656537277083, 0.17331590425160737, 0.20227849329127634, 0.3781223007313439, 0.3144337448537329, 0.380533283316252, 0.12968781026223386, 0.13707717369978523, 0.15006939003741626, 0.41188331145097923, 0.45316373780119534, 0.39776448377663587, 0.339443955437436, 0.457814652783713, 0.49745298696045215, 0.4084741173544598, 0.4676239650068422, 0.4091283853347727, 0.7694465617251081, 0.7458337936014017, 0.7740422647472706, 0.804398555405852, 0.7604289108151158, 0.7875754505797428, 0.806196055054101, 0.8118451849881606, 0.7655405077514515, 0.09495361218550769, 0.08838526880390563, 0.0927044603690036, 0.09724594016980426, 0.10149959604278824, 0.10846447846347151, 0.10186406299833817, 0.09965080581208152, 0.09752804377607716, 0.399944873988773, 0.1564819159877019, 0.15385608574672738, 0.1468951340570973, 0.14435864173532953, 0.15695183127254042, 0.1426483233824949, 0.16551437377553335, 0.338058637223148, 0.5703564366284826, 0.43196658950157685, 0.56465053205466, 0.3893122183075548, 0.4736002801953312, 0.533472168645589, 0.5935491439774474, 0.45443453456317207, 0.5350179519641878, 0.41354038200648324, 0.33009065328370024, 0.43882345985136073, 0.44511030704867893, 0.35677798428315577, 0.40341562028346956, 0.39175751012381266, 0.2922709062587685, 0.45710547201002016, 0.20511716945508984, 0.18296551468035738, 0.17739207430917248, 0.20675772267463755, 0.19261060636087113, 0.18718534994154268, 0.20559410410741452, 0.2022572494889293, 0.19500653801772883, 0.205611686713003, 0.43622053823258644, 0.45398813102205826, 0.548966231169687, 0.2302557448210899, 0.5368087849113214, 0.2367062371360601, 0.20492454517651615, 0.21594358582452966, 0.1665594427134791, 0.16281784660820664, 0.18883100604285286, 0.810650126567274, 0.19448138455099373, 0.6929651804427666, 0.17085442789408334, 0.6051846094178919, 0.8375534587615131, 0.1671610895243688, 0.2109655078299233, 0.6271679121917124, 0.7967617429228384, 0.16704263387136142, 0.7742604435276405, 0.211479643457409, 0.2097541361938886, 0.7876584529360047, 0.18854334069581824, 0.19064185513355358, 0.18530081004572474, 0.19299832022956376, 0.17514969158292226, 0.18220985629876518, 0.18646674889864423, 0.19451314660304542, 0.18276562382769512, 0.08974204053196333, 0.07322264000612122, 0.08602625254517149, 0.08665871639224443, 0.07795406083467293, 0.08733486765021115, 0.09925478541390909, 0.07576498695367995, 0.0862700142512145]}, "mutation_prompt": null}
{"id": "dc8fbc68-c1bf-4396-b87f-9c35f0d3cab2", "solution": "import numpy as np\n\nclass DynamicMultiStrategyDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.6, 0.8]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b + c - best)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "DynamicMultiStrategyDifferentialEvolution", "description": "Dynamic Multi-Strategy Differential Evolution using Adaptive Mutation Strategy Selection and Enrichment Mechanism.", "configspace": "", "generation": 17, "fitness": 0.4723392780186836, "feedback": "The algorithm DynamicMultiStrategyDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8463776971708968, 0.8681500336777039, 0.8660764673757656, 0.8476557881666202, 0.8682474834262637, 0.8563526563321802, 0.858240684196447, 0.852825494635858, 0.8481201787895309, 0.733737694235421, 0.7286675828662915, 0.6997107057597964, 0.7342369420752808, 0.7116422973422543, 0.7363758978263302, 0.7388780469640498, 0.7354263013086599, 0.7224482859554333, 0.3169354157295633, 0.13723454082661135, 0.15015602607798595, 0.1286854409812881, 0.20649018964333343, 0.13270192293858962, 0.14511590340547298, 0.14145188357831628, 0.13740161039190812, 0.10893243053058144, 0.14596618819031904, 0.12004333029976078, 0.12391691675468042, 0.1430303890892426, 0.13749301336457576, 0.13938197091787063, 0.11295846564667411, 0.119969093227842, 0.981656873277218, 0.894528937206824, 0.9213009308061704, 0.9440334963984635, 0.9688087471127049, 0.9443693928412836, 0.9505741883338692, 0.9754944710000392, 0.9019864728225552, 0.7301302737837854, 0.7306833952158014, 0.6891541155881997, 0.6901752979596067, 0.7094292862561487, 0.6454864578972701, 0.6818820357413665, 0.7282145286606103, 0.6764410110600931, 0.8694697915630356, 0.8411466383525827, 0.80515479107671, 0.8617476983596992, 0.7957098327699905, 0.8558222762640936, 0.8451651468463071, 0.8648957533345053, 0.8464858713085204, 0.5336400770337786, 0.441507259304158, 0.49075605188745053, 0.4539041090208801, 0.5425783859632998, 0.6943120192438217, 0.561363059450763, 0.6014492524320819, 0.5810284485300898, 0.5134096365522671, 0.5957919793841431, 0.6622919521066183, 0.43854286088940786, 0.5821825701087586, 0.13089678893778112, 0.134126218935947, 0.6205893040959749, 0.6868456330111449, 0.5582376062580678, 0.6101593946859994, 0.5040714878616712, 0.622854290201515, 0.5851507971022368, 0.5509400135999152, 0.6059993761899024, 0.5772618020393514, 0.5097015532654366, 0.6309366320373672, 0.6520165504130184, 0.6100374264083703, 0.6328209154696656, 0.689119793041888, 0.684119757317248, 0.6692282435178949, 0.7020411573254179, 0.6841583565690801, 0.14512421487317928, 0.24421390365979423, 0.1810143618173038, 0.5561264785752353, 0.5590711038066112, 0.2301999494981991, 0.18721448882057534, 0.20280599033614666, 0.30085115852900657, 0.41041809650297967, 0.5208320154714356, 0.43063451937670827, 0.44417492982097817, 0.5216197763029569, 0.4802323850309549, 0.47039497150309517, 0.5144508845930478, 0.4555644944900987, 0.783407839250451, 0.7885521196857396, 0.8196502207202652, 0.789017260029691, 0.7843532232884057, 0.7828469977315367, 0.7661929288271608, 0.8085446791624816, 0.7436729150794132, 0.12069288136062428, 0.12638509371975093, 0.10170315410987951, 0.1243346519138615, 0.10288268427882685, 0.11594957645879855, 0.12601960403968826, 0.13771673935060003, 0.13358222257215036, 0.12974671092320078, 0.14457065607548525, 0.15133259910631258, 0.12707696170147265, 0.1622603188391718, 0.13076533318679007, 0.158005928987082, 0.31852256527949707, 0.15778323893487578, 0.5646850165557239, 0.548939682219717, 0.47110588229468564, 0.5466839494677965, 0.5661885016691728, 0.5315926808371831, 0.6013948060122933, 0.6154183395525189, 0.5855348699469585, 0.38635250493249074, 0.4335692686360555, 0.3412369271195689, 0.4020138886592064, 0.4239024941887728, 0.3982904377260441, 0.49223446409097416, 0.4912232291211731, 0.43071890085533837, 0.2106363998973244, 0.2189969438538375, 0.19364749723967967, 0.2190721337163526, 0.22773607348038127, 0.191585911843703, 0.21444530768142744, 0.21588262525295365, 0.2423075673450279, 0.2146217598471667, 0.26523860845448166, 0.23086854767393172, 0.22730436361342643, 0.5376639656691009, 0.22507165039072985, 0.21474397515810806, 0.18465443503420143, 0.23769475047306243, 0.1842529575852262, 0.18452060343291254, 0.15174487423524263, 0.8704200643123577, 0.19273563748566536, 0.7708705023649035, 0.6150905478993565, 0.754712570246962, 0.8584247084168593, 0.8522754753377321, 0.6621189708439331, 0.6842711242905501, 0.20614484651754317, 0.7707768239714486, 0.8159052640600214, 0.11185387542238845, 0.8494171592594827, 0.8274732230564442, 0.19078232616868618, 0.18735269053965553, 0.19314993853327866, 0.1797102916203296, 0.17022941209395126, 0.1820515624029454, 0.19264982945774578, 0.20047120922470818, 0.20064963110514356, 0.08627530560130214, 0.08568145098578583, 0.08921044755347007, 0.09088980903293153, 0.08796388491627494, 0.08475012495056422, 0.08332222450051507, 0.08567319041102905, 0.08263686433694328]}, "mutation_prompt": null}
{"id": "47089a8c-b362-40af-b19b-59e1e2eca09b", "solution": "import numpy as np\n\nclass HybridRandomizedEvolutionaryOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.8, 1.0]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1.1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):\n        a, b, c, d = population[np.random.choice(range(self.population_size), 4, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b + c - d)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "HybridRandomizedEvolutionaryOptimization", "description": "Hybrid Randomized Evolutionary Optimization that integrates adaptive mutation strategies with ensemble improvements for enhanced exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.40678077017367464, "feedback": "The algorithm HybridRandomizedEvolutionaryOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8215682668862695, 0.7876767027585899, 0.7432028251497922, 0.8406029751688997, 0.8201078015179216, 0.8297658899696112, 0.7914271911965601, 0.7941534014189249, 0.7563360028118116, 0.6765385534361599, 0.602463133368466, 0.5177524514907226, 0.6277754456672159, 0.5800995114919587, 0.5783586757814371, 0.6505578083878891, 0.630818178378575, 0.5197749737855443, 0.1279597380311125, 0.12392578475749472, 0.11665722422855362, 0.12803319085333953, 0.14889752040464133, 0.14220438319041384, 0.2046884651289288, 0.13051926931094882, 0.11542831650314789, 0.15433401919802414, 0.14671665623205576, 0.0961644778754911, 0.11627458503525245, 0.10049336022494304, 0.12118571779011111, 0.12063939425834214, 0.10335667952243077, 0.10622884685943246, 0.9765261274705137, 0.9708102447692983, 0.9816415395414617, 0.9823884777934986, 0.9828545603253502, 0.9782729952360489, 0.9923066253967127, 0.9840857849895136, 0.9782638944943365, 0.5762419980199729, 0.49375766960247913, 0.47751932501852357, 0.47189651586528003, 0.5288367604078721, 0.48479539519213755, 0.5478615751747643, 0.4899520107367421, 0.4138191273742031, 0.7894473777512758, 0.7668133385158111, 0.7085252477468282, 0.8152875805945261, 0.8024986423531562, 0.700876217548084, 0.793518510324178, 0.8315164453109787, 0.7420426787757715, 0.5501232718256455, 0.47693505463175345, 0.4669248372332643, 0.36284236894011823, 0.5231026247654342, 0.1090347467118723, 0.5130962216149432, 0.5023997907572997, 0.48567914506384646, 0.38513709785232686, 0.363627596008255, 0.26317969495262217, 0.5146797956583922, 0.4270596421417031, 0.5814298667923253, 0.5126969187101476, 0.5504645707168744, 0.3822471067094789, 0.42393956218575113, 0.34868732130032376, 0.3189585110250286, 0.33363135397353993, 0.36022886160097434, 0.33729661260708377, 0.39090637139569107, 0.32536392966950456, 0.17897245291838704, 0.5883965157201048, 0.5193758544253665, 0.2952313474719819, 0.38759426364159255, 0.46015587625169485, 0.44885368908831424, 0.5886737779942965, 0.556998867092199, 0.5118469487437471, 0.23893254721227608, 0.058064292548994256, 0.11807004320107406, 0.26227310437871043, 0.30042920162862996, 0.09644429921798003, 0.3005387281130717, 0.1402425262768029, 0.18780850131974325, 0.3489882656523907, 0.31712096948482027, 0.34486021073977957, 0.39074247058868283, 0.3167733594573525, 0.31512890730907694, 0.3456099517942638, 0.32564210038292396, 0.323790391821721, 0.7254751816307075, 0.6878744597204756, 0.729528470759049, 0.7134283296872939, 0.7133813702474274, 0.6821435001805508, 0.6724715889095895, 0.7188272206339358, 0.6830502880335867, 0.1070599642382829, 0.10536392853463616, 0.08931787911487876, 0.10127056908422383, 0.10387296337380814, 0.10526854898524907, 0.09732816302028002, 0.11443756763493751, 0.12605561873962257, 0.5463359210940884, 0.20197400468876214, 0.2034600784343159, 0.21942891315211532, 0.14896993055775987, 0.16324284044538417, 0.2022776065791171, 0.2048814611484524, 0.14578540231237525, 0.3655114257288591, 0.43542245473504004, 0.3451537155060378, 0.436550897656538, 0.37636945359526897, 0.33490110570224474, 0.4572643898286467, 0.4275787647176653, 0.42745586846542827, 0.2734565449034886, 0.3609328987470344, 0.3614704804149732, 0.32583886587474675, 0.36042125863363506, 0.232404404168578, 0.4010514337077743, 0.37969475734968605, 0.2593296664673729, 0.1967191961144309, 0.19192867211011522, 0.20094888567117486, 0.1935782163329801, 0.19453343680930912, 0.19264872237882547, 0.22859200171725091, 0.181000666849658, 0.1962732551567189, 0.19259299161146004, 0.22646247786756135, 0.2024942598135938, 0.3471965346593423, 0.4858318493535261, 0.23961095449565495, 0.23089546539203687, 0.2011173964734051, 0.4765580699351115, 0.7843678756166876, 0.7937680815134863, 0.831864346553732, 0.7544713145423394, 0.19156546416539766, 0.19144578197878726, 0.7950011078771648, 0.18222672332775824, 0.1845412384059293, 0.702610121073835, 0.2055195493744053, 0.476176552150004, 0.7944179381629204, 0.608660941856807, 0.6740362737799792, 0.20790261043243408, 0.7747197529439973, 0.7594775785622586, 0.196239364070266, 0.19301864117883938, 0.19551891626889806, 0.1880065236473405, 0.18108978224575334, 0.19546346695508998, 0.17905898510025586, 0.20533578312059741, 0.18980127160316307, 0.08594254958241476, 0.09334585293342046, 0.08032262010000557, 0.07938502596513408, 0.08097824073427673, 0.08999489858290632, 0.08404803050699616, 0.07268091634309781, 0.09706260265074729]}, "mutation_prompt": null}
{"id": "dd5fb5a1-888d-4dcf-ad82-a089f8b72a24", "solution": "import numpy as np\n\nclass SelfAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factor = 0.8\n        self.crossover_rate = 0.8\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + self.scaling_factor * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):\n        a, b, c, d = population[np.random.choice(range(self.population_size), 4, replace=False)]\n        mutant = best + self.scaling_factor * (a - b + c - d)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + self.scaling_factor * (best - population[idx]) + \\\n                 self.scaling_factor * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "SelfAdaptiveDifferentialEvolution", "description": "Self-Adaptive Differential Evolution with Dynamic Strategy and Parameter Tuning to improve convergence efficiency.", "configspace": "", "generation": 19, "fitness": 0.3147515593479125, "feedback": "The algorithm SelfAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.7751937221289534, 0.7623903337883761, 0.7865860439078344, 0.711294413941288, 0.7705891053064909, 0.8175139911741613, 0.7439279928728817, 0.7770190123166011, 0.7519654211497843, 0.4941093229231964, 0.5886182001496384, 0.2637176116799065, 0.5724406830792617, 0.5631193531120318, 0.5701396169480011, 0.6232376901765329, 0.5502780299845565, 0.5249181801363347, 0.11542156924942115, 0.12543781416703492, 0.12067749922389281, 0.10521957257672288, 0.101814766333584, 0.11142932521968762, 0.11392344059321569, 0.11716278206492936, 0.12067466396727122, 0.10642939772356363, 0.10025023341136252, 0.07265408847874044, 0.11408868971862796, 0.10179402977349106, 0.08642607230538857, 0.09896135329733913, 0.15219386858620076, 0.08659199028047493, 0.9880074409140538, 0.9869117809686945, 0.9860399236610048, 0.9740376427697199, 0.9851650312065496, 0.9595591903917207, 0.9881542882043617, 0.9818851134593242, 0.9864123174547395, 0.3035203631645289, 0.4090741067712189, 0.499924130325726, 0.3541355359020014, 0.4237404338519165, 0.3120347080227357, 0.3106327895445653, 0.47427662474792454, 0.4506980725875227, 0.48117573772338207, 0.5548861334438846, 0.44969556747635964, 0.6971469391986165, 0.6332439162439084, 0.7570784329985473, 0.6093864934144864, 0.6494659848074815, 0.7222112225340038, 0.2923783825265276, 0.34107514689385754, 0.4187997552709328, 0.23689010613033146, 0.3995915118355092, 0.2653772968794217, 0.26533739107805077, 0.3686249550708508, 0.2874484870431333, 0.31831246384843503, 0.37895898372005543, 0.2730823671365651, 0.2479604496411989, 0.40166683619505883, 0.28575821210869756, 0.28524744306109073, 0.2983819422755115, 0.34116276606247486, 0.06307998785934521, 0.2657327002838822, 0.12157184333726034, 0.15690960392329767, 0.22386439509405054, 0.2054966188068671, 0.12479913313400992, 0.08694373870158012, 0.05270279388716459, 0.13211888289469265, 0.333872498443355, 0.2981094743423379, 0.16062639119949795, 0.353622764841407, 0.39112309225001596, 0.30685273488137244, 0.3772081412599342, 0.41832698701984594, 0.04246709688542083, 0.12651473217567366, 0.05751708139297984, 0.1448380632629851, 0.12341957241491908, 0.17910153264382112, 0.017780002899256964, 0.07173517574486632, 0.11370628581153919, 0.1859312827153613, 0.21201367625028456, 0.21673498965949023, 0.13915081990227196, 0.23013904409409047, 0.09898107173700299, 0.13147941949360853, 0.2480432572372514, 0.24186248959046852, 0.4989899106232001, 0.5737713840997734, 0.5725013339988556, 0.5909350398724924, 0.5927847751219345, 0.5930866133313211, 0.5063407744939237, 0.5938040331756577, 0.5079262603748893, 0.09920117363601078, 0.08803834403126654, 0.09090654898799488, 0.08353348578514275, 0.08998943289676886, 0.07976905268279844, 0.08282205705105794, 0.10068902023028059, 0.0905159631846365, 0.13656786122466835, 0.18235929893254044, 0.1437623583087161, 0.13816181713357178, 0.16484139322363267, 0.14123591864014795, 0.13764091463321126, 0.1446996279205357, 0.15972463636282552, 0.3277520227056344, 0.3377477423344222, 0.4059393409780687, 0.2778675526323182, 0.3167327297121636, 0.41590076847970525, 0.3194065957493054, 0.3839703026506791, 0.38802850332152083, 0.23180053479566065, 0.24776344740393363, 0.24007683160683757, 0.18533792255499415, 0.25680085928868734, 0.2678810610486767, 0.26224079307133064, 0.2994988506595516, 0.25637499720486445, 0.17674733463020964, 0.18867898277499562, 0.18543056030547322, 0.1924752349066704, 0.2125214173510701, 0.17692549183607864, 0.20188078995333925, 0.197849965407342, 0.19699020238958975, 0.23220866699276965, 0.19423619465280972, 0.1753888632483882, 0.41058434855981407, 0.21204474429325726, 0.20972124744891152, 0.17641481964904016, 0.18534635934858357, 0.18248087805260815, 0.19777886191498828, 0.1656907698111989, 0.15111184104665354, 0.579342072006507, 0.5920254382427006, 0.18442130993050032, 0.18032951949833986, 0.18020658373520348, 0.5443769382722431, 0.18250807773290667, 0.3196746330931677, 0.4388603222956481, 0.19534577607349046, 0.19074419517695795, 0.30744607092066445, 0.21048565784638995, 0.7111002420771938, 0.15307360950773619, 0.17980620518445978, 0.1833155034039582, 0.17027439805225753, 0.19082015363269111, 0.17276344074430017, 0.17652110802974552, 0.1772045819352186, 0.1909366092576863, 0.17565122512535924, 0.08303303794035033, 0.06795205451043496, 0.07616110141392618, 0.07164125296086477, 0.07426560072416144, 0.08206728685750364, 0.0670380827794852, 0.07666665319590338, 0.0849089398764854]}, "mutation_prompt": null}
{"id": "a680be36-19c2-486e-a572-2d7524949906", "solution": "import numpy as np\n\nclass HybridAdaptiveLearningDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8]\n        self.crossover_rate = 0.85\n        self.learning_rate = 0.1\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        learning_scaling = np.random.normal(loc=1.0, scale=self.learning_rate, size=self.population_size)\n        \n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best, learning_scaling[i])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best, learning_scaling):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + learning_scaling * np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best, learning_scaling):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + learning_scaling * np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best, learning_scaling):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + learning_scaling * (best - population[idx]) + \\\n                 learning_scaling * np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "HybridAdaptiveLearningDE", "description": "A hybrid metaheuristic combining dynamic differential evolution and self-adaptive learning rates for robust optimization.", "configspace": "", "generation": 20, "fitness": 0.47695775318537165, "feedback": "The algorithm HybridAdaptiveLearningDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.30.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8977619420003674, 0.8984191725945315, 0.8928655189186874, 0.9004349409345462, 0.9107918362301122, 0.890410073178579, 0.9049620886731474, 0.8997431427807602, 0.9011468644126068, 0.796282483733305, 0.8006782185281212, 0.5952149824173089, 0.7785531596435995, 0.7787439743290214, 0.7548065265142501, 0.773324043328784, 0.8113186961407741, 0.7655317772659151, 0.14017981329028006, 0.17484018848006033, 0.15286090859376744, 0.12082488427143034, 0.1381066592050031, 0.30046675158220304, 0.1692193818098836, 0.1512916492110442, 0.15275062040459175, 0.10273860827553383, 0.10835764845309315, 0.11181899733559297, 0.11894410824037716, 0.11261749019485667, 0.12368531966744545, 0.12525709395379658, 0.10828417831298442, 0.12003924583829029, 0.9848857867417411, 0.9772198242456319, 0.9854451209311952, 0.9663098779601973, 0.9563520857995605, 0.9662609800203938, 0.973725928921881, 0.9837563897497955, 0.968348689404313, 0.705692605301482, 0.6909927259963324, 0.7279968120597308, 0.7272293935335827, 0.7224791738584831, 0.7016914599494681, 0.7389126567412911, 0.6851170377363579, 0.6902906679720767, 0.9007561014311842, 0.8381921984499607, 0.8782686274828292, 0.9079808309585745, 0.21437832439033078, 0.8808390260712339, 0.9088778835648698, 0.8738552114770203, 0.8829484224871521, 0.5386685873423314, 0.6526817528746098, 0.5661292893065439, 0.12993713032538112, 0.13416765060513958, 0.4370217716361271, 0.6434284644636558, 0.13071275772351398, 0.7301259108429152, 0.5734070246634713, 0.7425021464527929, 0.13121282280519575, 0.690224756789017, 0.6288614200804358, 0.5807414874642169, 0.6555213054882345, 0.1144332659518037, 0.4886271037211818, 0.5932736642097066, 0.5510001676656299, 0.5444468846984054, 0.6410593694950101, 0.19715045609455506, 0.6064828545325001, 0.6828243185638498, 0.6383841116531286, 0.6355870410036911, 0.744353432649147, 0.7573676372523197, 0.0857295616455922, 0.7285874924332648, 0.6771978720848353, 0.6823548031161633, 0.7185804525523011, 0.7687582091783794, 0.6192052450581931, 0.460977567614136, 0.5011522964454059, 0.2585051203255131, 0.42532724898757346, 0.42432450089475915, 0.17780496404949986, 0.21446968702285962, 0.10492779023329624, 0.11546485136215201, 0.6247449781279687, 0.6015018544642408, 0.5707615205174794, 0.5947870594796723, 0.6046180719436287, 0.5972532447003089, 0.5680600533269557, 0.6035971958468107, 0.08277943435960355, 0.8540449626734472, 0.82271414516697, 0.8465905944839871, 0.8591964183584131, 0.83164223843595, 0.8236437590539715, 0.8550449311376582, 0.8558507881417341, 0.8362043983944027, 0.10851002319563174, 0.12334438160087835, 0.07917230433625078, 0.14613121838416376, 0.13939075971615367, 0.11787611439918277, 0.1371868472820924, 0.09282500357690238, 0.11724637051120568, 0.25017331854369873, 0.26847392896590794, 0.5199247660850144, 0.7211011986715827, 0.2766384852434872, 0.29317751660307056, 0.343602048682626, 0.23773603948963762, 0.17894523336964108, 0.5347692187055996, 0.6100392755849886, 0.6357540923301332, 0.6974661446414792, 0.6086361966904557, 0.5485877926287941, 0.36804738316351326, 0.741746649556132, 0.4948477300653076, 0.42848940031934535, 0.2598899944371005, 0.3401103530267421, 0.5443243315528776, 0.24105513211860696, 0.2752989405073295, 0.4455607722510492, 0.4181387182908437, 0.21882883531438724, 0.19662937715708462, 0.21083109867080785, 0.2176370219518703, 0.22291641167383658, 0.20113973744737668, 0.2113307256222966, 0.2073815366809063, 0.21791975435245226, 0.278980687540054, 0.22184223586395424, 0.19038094499507896, 0.2219493854943928, 0.18676189697806045, 0.22436862448682982, 0.21745596624937502, 0.24385446114379117, 0.2230593002262412, 0.4026613768030808, 0.9236962043645502, 0.16727024506851307, 0.18714516098352896, 0.9207328141726445, 0.19985312153700163, 0.16308044295083168, 0.1423283475048034, 0.16322569176982393, 0.6662365852828483, 0.9222105044905835, 0.21161048325927678, 0.85383308027027, 0.8912665900388859, 0.8769304955725535, 0.86843543988829, 0.20922829199115356, 0.8644061840211557, 0.1653414426612262, 0.19772738169370463, 0.18487891229856612, 0.17276513294504947, 0.18282266443810424, 0.18156470085533383, 0.2151900829354204, 0.17924222960266123, 0.1935223456325934, 0.19901854670610886, 0.09065615902834578, 0.08540702245503073, 0.08538235222636226, 0.08450810884359161, 0.09006507364671379, 0.07951522049558912, 0.09465555184953067, 0.08321758100945131, 0.08694270241790636]}, "mutation_prompt": null}
{"id": "abc90c42-6da6-4b92-90cd-aef252395341", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEnsembleEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveEnsembleEvolution", "description": "Quantum-Inspired Adaptive Ensemble Evolution integrates quantum superposition principles to enhance mutation strategies using historical performance.", "configspace": "", "generation": 21, "fitness": 0.4904089433482804, "feedback": "The algorithm QuantumInspiredAdaptiveEnsembleEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "7d022685-45b0-4670-85f9-4b0be08ca253", "metadata": {"aucs": [0.8648592592834818, 0.8508048394866384, 0.8709068458013013, 0.876566902791248, 0.8717539668705648, 0.8704276880536199, 0.8603351706160125, 0.8689817813276226, 0.8568803579127634, 0.7442844642327662, 0.7663036494020166, 0.7201116860952688, 0.7422911800028242, 0.7295107345510672, 0.7527930878464473, 0.751381407419492, 0.7228511997103013, 0.719174834845209, 0.13600127167465614, 0.1430154623721237, 0.45299224527874926, 0.42235506116552957, 0.15655363621978235, 0.4338241421683101, 0.14105428958395116, 0.4493465927616257, 0.14980325377769677, 0.16618465209661148, 0.13165914233478493, 0.11314434574956744, 0.12200214217287508, 0.1142791501622119, 0.10891074941767198, 0.1309993343248509, 0.11527607702436904, 0.13035154936204163, 0.9854861256979982, 0.9731917555733575, 0.9839372199826757, 0.9777403895360776, 0.9730935367036666, 0.9767197543426536, 0.9866358701487625, 0.9882845173439609, 0.9865774448965784, 0.6744214961444142, 0.6687192952420864, 0.6684251385648413, 0.6987852376214795, 0.678848668917822, 0.6780574893778237, 0.6548312941039944, 0.6617489419068743, 0.6781082584249314, 0.8725530767647338, 0.8568890150203697, 0.7894835578532711, 0.8524089626294391, 0.8930519943749284, 0.2107561074362797, 0.8194339583387036, 0.8629870996262061, 0.8531680901982861, 0.12995082140920822, 0.7108482508314495, 0.42706446747175764, 0.615543703525943, 0.6831260857729273, 0.6759491272541212, 0.6355790385075983, 0.6206560494027062, 0.6812646658539643, 0.6574355115104478, 0.689889511607348, 0.5926265461310201, 0.6288801938940528, 0.6705899618600892, 0.66988222796063, 0.7178760581981073, 0.536033228385686, 0.6718510490077312, 0.618887162457552, 0.6646543799239805, 0.5276255532698924, 0.6716051527926867, 0.6235643975816256, 0.6359634413105594, 0.6508705620656445, 0.6787070879182656, 0.6802156810080874, 0.736056234954113, 0.696784155779144, 0.7157913386555275, 0.7086846477345872, 0.7555001625746189, 0.7180811471350825, 0.7431272436032101, 0.7272181648009562, 0.7379250288254195, 0.14221642042466998, 0.0877189170646181, 0.09895584425314341, 0.5347782203758711, 0.34175889742848264, 0.5052975186686128, 0.47233437050990146, 0.15563432731464633, 0.168604868095086, 0.5609630485592199, 0.5526705919695449, 0.5437811446956421, 0.5216985442359547, 0.5433243083513026, 0.5581236425539211, 0.5523679371664912, 0.5705707634062236, 0.5574074622330483, 0.8239818847031385, 0.8283322200835769, 0.8210665947742247, 0.8156571835826841, 0.820615719431953, 0.8012702681680686, 0.8122015410743877, 0.8115910854013328, 0.8100606486147107, 0.22917402513882112, 0.12081604989940065, 0.12112920223244472, 0.12558028690991507, 0.1607322176276702, 0.11002970454373551, 0.11858715154526112, 0.14844461347143512, 0.11045203674396398, 0.1819283097360287, 0.17510985121313827, 0.13780277284949227, 0.3719361176740055, 0.14452183648108408, 0.15426407327826308, 0.1880061371886551, 0.21792384928850705, 0.1815757852872617, 0.5715952140014403, 0.5831207173493571, 0.4736439433359355, 0.5604422769425237, 0.5757387476013793, 0.5090540953888236, 0.5860125230943343, 0.5843113402451738, 0.6089682241843648, 0.5331706596266383, 0.46419778236723996, 0.4530032448353143, 0.4934253501156599, 0.5277157867923032, 0.47104358819232717, 0.5554489688924278, 0.5395199454766763, 0.4418246029393982, 0.20574262668279963, 0.2046332028168263, 0.1991111346192006, 0.2051071287037305, 0.19338278956106192, 0.1979498924102382, 0.20973013185869382, 0.2135729170250602, 0.22087981957403902, 0.1969589976145817, 0.20600927216317877, 0.21888684004428682, 0.2192250882606418, 0.2130697958263652, 0.23376973562725234, 0.604947708801757, 0.6546955778222642, 0.235174717899734, 0.18272352616402843, 0.1835248608371427, 0.15287068932313996, 0.8946770982868334, 0.19814891809786084, 0.8777033590705493, 0.8855203155279023, 0.8303803832154149, 0.858171875091993, 0.8646976426153794, 0.20995618602066557, 0.1669981995288624, 0.20731507763863588, 0.8414964615381917, 0.16496329345166538, 0.21253098538459303, 0.2050919716240106, 0.20940977924435433, 0.18217858127519992, 0.1997265937300261, 0.18021903523916427, 0.17968762958702922, 0.1901353034642218, 0.19316590444297355, 0.1908773815686543, 0.19316600229408254, 0.19986572823087556, 0.08478727089215732, 0.07976308488499761, 0.0832786775131995, 0.09307389100893104, 0.09466871556973966, 0.0911002821335305, 0.13216069483283555, 0.08878916555478578, 0.08080032375835977]}, "mutation_prompt": null}
{"id": "4d70fb1c-db0b-4474-9d7d-8aaf27a2f5f7", "solution": "import numpy as np\n\nclass AdaptiveQuantumEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.3  # Adjusted strategy update\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.95  # Adjusted decay rate\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumEvolutionaryStrategy", "description": "Adaptive Quantum Evolutionary Strategy leverages adaptive parameter tuning and quantum mutation strategies for enhanced exploration and exploitation.", "configspace": "", "generation": 22, "fitness": 0.48167438864256945, "feedback": "The algorithm AdaptiveQuantumEvolutionaryStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "abc90c42-6da6-4b92-90cd-aef252395341", "metadata": {"aucs": [0.8615690325704085, 0.8607349582974229, 0.8729252644920414, 0.8744558826931241, 0.857982051288475, 0.8700555107918658, 0.8693366173145451, 0.8718350323633139, 0.861390771931997, 0.7103542615375216, 0.760994205824477, 0.7238063938017738, 0.7294439015035409, 0.7425498137866686, 0.7321344362947376, 0.7420768426909599, 0.7501731884785259, 0.746249248516833, 0.13706692640943785, 0.15990535282808593, 0.16348550936009287, 0.15797464015534257, 0.14198507039101882, 0.1278663962942972, 0.12734532099859475, 0.13252515876526938, 0.38196570821003706, 0.10351664480373235, 0.12594327282041595, 0.14826861376836675, 0.13632364548210063, 0.12898384538844787, 0.12630982988603923, 0.1567144483355345, 0.1480623106880261, 0.1527709195107394, 0.9882186908123766, 0.9786564514154305, 0.9784231548720537, 0.9777020607645227, 0.9621673093442867, 0.9801691134103638, 0.9852516306063505, 0.9855443359942931, 0.9865774448965784, 0.6566996717913418, 0.6560512313902125, 0.6429830569402726, 0.6531859289483115, 0.6659285629085262, 0.6355713755196761, 0.6774020532289663, 0.6530010893826506, 0.6720358040044216, 0.8624390767256009, 0.8614757534008347, 0.8671431176543118, 0.8627161648213333, 0.8602144346148991, 0.8952871265726414, 0.8375471232353391, 0.8447802168924174, 0.883619382220359, 0.6598989547789944, 0.6456429279463891, 0.718327604930511, 0.6206387294331932, 0.13207432854513956, 0.5608704774397341, 0.6007524793423922, 0.6620953701409442, 0.577702762312561, 0.7023344290085152, 0.5752533029941187, 0.5944970475193898, 0.6420267462443872, 0.6131389693242647, 0.6945071653968775, 0.12950321251727603, 0.687739558795896, 0.6110984843870593, 0.6129339024750774, 0.6577361544988172, 0.6515046554226724, 0.5806658397423474, 0.6713608418096478, 0.5615322941195985, 0.6496929921980203, 0.5740516884895317, 0.6385216658277909, 0.7377835654671718, 0.7441871244984376, 0.7339698753030371, 0.7204503469403696, 0.7038306434780353, 0.7158116033236874, 0.7251598841093957, 0.715752107524927, 0.7471553557214246, 0.17850437710959577, 0.4846776318400783, 0.45734277260537914, 0.493988429464033, 0.1441450377401977, 0.1826368936299484, 0.2830189335079245, 0.14824212597314512, 0.27182938813230184, 0.5714448917425694, 0.5386728793626986, 0.5384863907349984, 0.5648774186545469, 0.5406019212245028, 0.557912634690708, 0.5631041242297814, 0.5570630468794784, 0.5324842955835599, 0.8006886699915432, 0.8049596767034425, 0.8264000455876191, 0.805645172781424, 0.8039545768597472, 0.8090531755386018, 0.7994242704835783, 0.8103274796109032, 0.8222303623092417, 0.13085168200724695, 0.5038596875169822, 0.1026815910870782, 0.13148519974533845, 0.1284980109487306, 0.09874399178987736, 0.10559856495433173, 0.1573951238321466, 0.1278291068329942, 0.3105028697830844, 0.13097885817602106, 0.23875975815993322, 0.23404116285773457, 0.17143968242320917, 0.5526945919853156, 0.19383046236647328, 0.4083009400452825, 0.22131233757317537, 0.5674099192780249, 0.5329563648919349, 0.5392859824843568, 0.6002741156217595, 0.563886410729872, 0.5502353163954432, 0.6225999772444517, 0.6113959778756902, 0.5541108464643936, 0.48583394517015, 0.4270085812329, 0.46166301332148874, 0.4858663775791081, 0.4153388709144108, 0.2123816509122498, 0.49365280820529944, 0.4611227991494897, 0.459679626947596, 0.20318128766911037, 0.1969347796565829, 0.21978712909625442, 0.21192105102004, 0.2126951981359433, 0.20999622329418854, 0.17380995062957194, 0.19023532325232073, 0.20980977816718427, 0.2038827608906938, 0.20619241846538905, 0.23715434866627227, 0.5175343945048747, 0.6723024076930169, 0.4960116348475667, 0.2304990418481312, 0.19254655882557237, 0.24120946860299297, 0.15999257804208633, 0.16338766187243925, 0.15204671633986633, 0.13030704061477227, 0.19545033637424636, 0.846428427723197, 0.8453038892131739, 0.1602627179939733, 0.2080914201786862, 0.8689849610370164, 0.21062585581996496, 0.15288997047044972, 0.20483289844946273, 0.7872196902529608, 0.16685108268083604, 0.21235026217302877, 0.21132973525824061, 0.8863968183355438, 0.20824713858347632, 0.19543803939011828, 0.20721210588683425, 0.1940395279102346, 0.2004188099692602, 0.18153268488312402, 0.19194965601745428, 0.1850872314160804, 0.1799280885382395, 0.08963200152640416, 0.08313620660490362, 0.0916423788836731, 0.08533560308986288, 0.08723861480870743, 0.0748676263845155, 0.07722818860853353, 0.0823827859627334, 0.07659712811027242]}, "mutation_prompt": null}
{"id": "603ff46f-9bb3-4fbb-8c3d-dc9bff7db1ab", "solution": "import numpy as np\n\nclass QuantumEntropyDrivenDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.6, 0.8]\n        self.crossover_rate = 0.8\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.3\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.95\n            \n            entropy = -np.sum((self.strategy_weights / np.sum(self.strategy_weights)) * \n                              np.log(self.strategy_weights / np.sum(self.strategy_weights) + 1e-9))\n            self.strategy_weights += 0.1 * entropy\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEntropyDrivenDifferentialEvolution", "description": "Quantum Entropy-Driven Differential Evolution utilizes entropy to dynamically adjust strategy selection and mutation strength for adaptive optimization.", "configspace": "", "generation": 23, "fitness": 0.4507529861328948, "feedback": "The algorithm QuantumEntropyDrivenDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "abc90c42-6da6-4b92-90cd-aef252395341", "metadata": {"aucs": [0.8665508509787424, 0.8657965049585057, 0.8695907389372795, 0.8746763438613353, 0.8802915679634074, 0.8788245978627962, 0.8685641148949896, 0.8678579961343129, 0.8747315269871305, 0.7569190817139646, 0.7662994277436633, 0.7548433389749784, 0.7648012022489836, 0.7544444072797258, 0.754103482404805, 0.7723522110346269, 0.7586839510835977, 0.7211234571428962, 0.14530494635019164, 0.4013001620139993, 0.3384435830012048, 0.15561418735701482, 0.41327579734155806, 0.14193638247508533, 0.14788210358212928, 0.15124806289300619, 0.15176861097350014, 0.15201386337241363, 0.15263682700375558, 0.12685476480909708, 0.16155905807545312, 0.16538370176091433, 0.15491170496438955, 0.16674856484657796, 0.11710792948999538, 0.1429369966647308, 0.984839205890029, 0.9842906008999205, 0.9725408134150989, 0.9639346166729563, 0.9604504564224874, 0.9773681623468603, 0.9767938177763481, 0.9769095885384497, 0.9726983498841172, 0.6557856780933145, 0.6706547668602616, 0.6485040326251947, 0.6535089822765447, 0.6704124000570704, 0.6645375523231978, 0.6340810045087184, 0.6651951938966144, 0.6783143026649363, 0.8223509348263145, 0.22642546947013853, 0.8577090390880414, 0.8845964678243289, 0.8319635877394719, 0.8339234082073197, 0.8472443496178498, 0.8304658890008416, 0.8579463111989432, 0.1311749372327542, 0.6580607308728919, 0.5942307915320025, 0.6892424105578088, 0.651114773740884, 0.6607944354789349, 0.6447013962684506, 0.5435660614103561, 0.5502569859301967, 0.1312114135902932, 0.1324592200467296, 0.12881072486791623, 0.5444883505822995, 0.6167139116805986, 0.580408164398169, 0.5031575153954612, 0.615654258965184, 0.57162188839994, 0.5312895205003327, 0.562571418183551, 0.5262304548971246, 0.5565612805926481, 0.5411896625459489, 0.3710967077320866, 0.5624404092920811, 0.5348070280018263, 0.5694065870730733, 0.6434403850155167, 0.6242089056966669, 0.6222836538317369, 0.6240419983712728, 0.6280784767875309, 0.5995353502405915, 0.6611430348523915, 0.6807065849650452, 0.6450574647250686, 0.22725880768597173, 0.28236777584051154, 0.18893287817726878, 0.33776072640790866, 0.4389888073094418, 0.3549081030544785, 0.25869088841650045, 0.24612204931398962, 0.17922537870943578, 0.4306133173679799, 0.45459880550053045, 0.4264717798300327, 0.45728775431129365, 0.4122212799737326, 0.44062345691789395, 0.44171953744078685, 0.43877044758914985, 0.39783658618442685, 0.7853765823778336, 0.7936586149099687, 0.7773461213631463, 0.7938737548528659, 0.8010391652040776, 0.7883504205067873, 0.777518307520152, 0.7814829572631767, 0.7823687156430841, 0.12053126524134439, 0.13713779894096934, 0.12473028390778929, 0.1270610371900428, 0.1434915764255087, 0.14103146887387707, 0.10511884918396897, 0.11661959300783875, 0.11647424192374312, 0.23393081704672647, 0.13822760240169318, 0.14270074683738643, 0.15184541569874366, 0.4306402288120412, 0.13599206381247675, 0.2438007432117678, 0.15388714399632886, 0.15548611865569473, 0.5538438609879, 0.5708177756245114, 0.5743643175725619, 0.6003361320789635, 0.4918412619878201, 0.5598255263966985, 0.6042168632076048, 0.5596599349010407, 0.6170349317778614, 0.4010173313945775, 0.35641716331554263, 0.42906407747610964, 0.41153546794399676, 0.30890821607526575, 0.41824483023906556, 0.4655599538929408, 0.467444861897515, 0.4474355078700524, 0.2121912525345273, 0.20354711765096944, 0.20610905653515366, 0.1936328998595963, 0.20486422254862113, 0.19589078501803936, 0.2102108721920085, 0.2097223908040443, 0.22889851006666118, 0.23738745013020057, 0.21428378987655583, 0.23507621005265344, 0.5474488872695431, 0.1988121428714813, 0.5817291174272885, 0.22201160994589808, 0.2293510519602352, 0.20660556338738112, 0.17258316281476782, 0.164009039255831, 0.1520225903809318, 0.1750514199854084, 0.19846820875931637, 0.8747963600067642, 0.14109500772996675, 0.8250589555462807, 0.20681576587940598, 0.8620420117443618, 0.1687828865508907, 0.2041937831044679, 0.16379771034752955, 0.8259900321252553, 0.15297183452682295, 0.2125456234130293, 0.2101471833938776, 0.2112025125106206, 0.1975760796299315, 0.19961009049205702, 0.18281375839126945, 0.19478572374688552, 0.18343150385426799, 0.18864646970563448, 0.1758480370765324, 0.17668801068597728, 0.19771101720611717, 0.08133934147269828, 0.08234573416893365, 0.09767122812391427, 0.08656314358940831, 0.08720631561868808, 0.08120391730727405, 0.09145138261827501, 0.09071673253258106, 0.08341754523656131]}, "mutation_prompt": null}
{"id": "a1077d6e-8200-41f7-a05d-14f448cd9c51", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEnsembleEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveEnsembleEvolution", "description": "Quantum-Inspired Adaptive Ensemble Evolution integrates quantum superposition principles to enhance mutation strategies using historical performance.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "abc90c42-6da6-4b92-90cd-aef252395341", "metadata": {"aucs": [0.8648592592834818, 0.8508048394866384, 0.8709068458013013, 0.876566902791248, 0.8717539668705648, 0.8704276880536199, 0.8603351706160125, 0.8689817813276226, 0.8568803579127634, 0.7442844642327662, 0.7663036494020166, 0.7201116860952688, 0.7422911800028242, 0.7295107345510672, 0.7527930878464473, 0.751381407419492, 0.7228511997103013, 0.719174834845209, 0.13600127167465614, 0.1430154623721237, 0.45299224527874926, 0.42235506116552957, 0.15655363621978235, 0.4338241421683101, 0.14105428958395116, 0.4493465927616257, 0.14980325377769677, 0.16618465209661148, 0.13165914233478493, 0.11314434574956744, 0.12200214217287508, 0.1142791501622119, 0.10891074941767198, 0.1309993343248509, 0.11527607702436904, 0.13035154936204163, 0.9854861256979982, 0.9731917555733575, 0.9839372199826757, 0.9777403895360776, 0.9730935367036666, 0.9767197543426536, 0.9866358701487625, 0.9882845173439609, 0.9865774448965784, 0.6744214961444142, 0.6687192952420864, 0.6684251385648413, 0.6987852376214795, 0.678848668917822, 0.6780574893778237, 0.6548312941039944, 0.6617489419068743, 0.6781082584249314, 0.8725530767647338, 0.8568890150203697, 0.7894835578532711, 0.8524089626294391, 0.8930519943749284, 0.2107561074362797, 0.8194339583387036, 0.8629870996262061, 0.8531680901982861, 0.12995082140920822, 0.7108482508314495, 0.42706446747175764, 0.615543703525943, 0.6831260857729273, 0.6759491272541212, 0.6355790385075983, 0.6206560494027062, 0.6812646658539643, 0.6574355115104478, 0.689889511607348, 0.5926265461310201, 0.6288801938940528, 0.6705899618600892, 0.66988222796063, 0.7178760581981073, 0.536033228385686, 0.6718510490077312, 0.618887162457552, 0.6646543799239805, 0.5276255532698924, 0.6716051527926867, 0.6235643975816256, 0.6359634413105594, 0.6508705620656445, 0.6787070879182656, 0.6802156810080874, 0.736056234954113, 0.696784155779144, 0.7157913386555275, 0.7086846477345872, 0.7555001625746189, 0.7180811471350825, 0.7431272436032101, 0.7272181648009562, 0.7379250288254195, 0.14221642042466998, 0.0877189170646181, 0.09895584425314341, 0.5347782203758711, 0.34175889742848264, 0.5052975186686128, 0.47233437050990146, 0.15563432731464633, 0.168604868095086, 0.5609630485592199, 0.5526705919695449, 0.5437811446956421, 0.5216985442359547, 0.5433243083513026, 0.5581236425539211, 0.5523679371664912, 0.5705707634062236, 0.5574074622330483, 0.8239818847031385, 0.8283322200835769, 0.8210665947742247, 0.8156571835826841, 0.820615719431953, 0.8012702681680686, 0.8122015410743877, 0.8115910854013328, 0.8100606486147107, 0.22917402513882112, 0.12081604989940065, 0.12112920223244472, 0.12558028690991507, 0.1607322176276702, 0.11002970454373551, 0.11858715154526112, 0.14844461347143512, 0.11045203674396398, 0.1819283097360287, 0.17510985121313827, 0.13780277284949227, 0.3719361176740055, 0.14452183648108408, 0.15426407327826308, 0.1880061371886551, 0.21792384928850705, 0.1815757852872617, 0.5715952140014403, 0.5831207173493571, 0.4736439433359355, 0.5604422769425237, 0.5757387476013793, 0.5090540953888236, 0.5860125230943343, 0.5843113402451738, 0.6089682241843648, 0.5331706596266383, 0.46419778236723996, 0.4530032448353143, 0.4934253501156599, 0.5277157867923032, 0.47104358819232717, 0.5554489688924278, 0.5395199454766763, 0.4418246029393982, 0.20574262668279963, 0.2046332028168263, 0.1991111346192006, 0.2051071287037305, 0.19338278956106192, 0.1979498924102382, 0.20973013185869382, 0.2135729170250602, 0.22087981957403902, 0.1969589976145817, 0.20600927216317877, 0.21888684004428682, 0.2192250882606418, 0.2130697958263652, 0.23376973562725234, 0.604947708801757, 0.6546955778222642, 0.235174717899734, 0.18272352616402843, 0.1835248608371427, 0.15287068932313996, 0.8946770982868334, 0.19814891809786084, 0.8777033590705493, 0.8855203155279023, 0.8303803832154149, 0.858171875091993, 0.8646976426153794, 0.20995618602066557, 0.1669981995288624, 0.20731507763863588, 0.8414964615381917, 0.16496329345166538, 0.21253098538459303, 0.2050919716240106, 0.20940977924435433, 0.18217858127519992, 0.1997265937300261, 0.18021903523916427, 0.17968762958702922, 0.1901353034642218, 0.19316590444297355, 0.1908773815686543, 0.19316600229408254, 0.19986572823087556, 0.08478727089215732, 0.07976308488499761, 0.0832786775131995, 0.09307389100893104, 0.09466871556973966, 0.0911002821335305, 0.13216069483283555, 0.08878916555478578, 0.08080032375835977]}, "mutation_prompt": null}
{"id": "87dc39c1-051b-4be5-9be8-fe169c5b7abc", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEnsembleEvolutionV2:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8]  # Slight adjustment for more diverse exploration\n        self.crossover_rate = 0.85  # More conservative crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.diversity_factor = 0.1  # New parameter to adaptively inject diversity\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9\n\n            # Diversity maintenance: inject random individuals when stagnation is detected\n            if np.std(new_fitness) < self.diversity_factor:\n                num_random_individuals = max(1, self.population_size // 10)\n                random_indices = np.random.choice(self.population_size, num_random_individuals, replace=False)\n                for idx in random_indices:\n                    new_population[idx] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    new_fitness[idx] = func(new_population[idx])\n                    eval_count += 1\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveEnsembleEvolutionV2", "description": "Quantum-Inspired Adaptive Ensemble Evolution V2 utilizes quantum superposition with adaptive diversity maintenance for enhanced exploration and convergence balance.", "configspace": "", "generation": 25, "fitness": 0.48570678597282757, "feedback": "The algorithm QuantumInspiredAdaptiveEnsembleEvolutionV2 got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "abc90c42-6da6-4b92-90cd-aef252395341", "metadata": {"aucs": [0.8794500980101424, 0.8785116606302779, 0.8708137448274471, 0.8916540213205034, 0.8816180900925934, 0.8859842811640115, 0.8810199028840205, 0.8873494016965926, 0.8850872581127561, 0.7727443011195241, 0.7253939254851854, 0.7393104809570894, 0.7814483754855619, 0.7866597165442419, 0.7825440011440346, 0.7535610230018521, 0.7805663299906895, 0.7893226995321003, 0.15911862903548102, 0.14102530424803394, 0.15389014272363144, 0.15844355170591784, 0.1758589327507709, 0.17059703241178126, 0.18683456216161753, 0.18064624203226176, 0.16387655521333622, 0.15251843553293742, 0.14440995786611022, 0.14373360060768958, 0.13422075099070063, 0.17053072675986547, 0.11635541258069748, 0.12698006920097638, 0.13943804186834186, 0.13400768493174942, 0.981922446912465, 0.9643921382725469, 0.9765308569583196, 0.9765529830360787, 0.9649715226225288, 0.9759551106190917, 0.9819639316933187, 0.9789299547744721, 0.9778594189316342, 0.6991527363409915, 0.6908495888941892, 0.6760262855901824, 0.68850590315954, 0.7220205807293336, 0.6991151350171128, 0.682397607403177, 0.697587078079679, 0.7181710072010032, 0.8756560563908463, 0.9010407073176234, 0.9007552313397431, 0.27985842710444764, 0.9118957187373002, 0.873751565213446, 0.8450413824405527, 0.9097388495111154, 0.8856698471497386, 0.14785577684770668, 0.7437092252027108, 0.6873202119826415, 0.1338861319018455, 0.4809478632207742, 0.6247658121609845, 0.6617659889651389, 0.6784803678570837, 0.7122559489911915, 0.6730713397503596, 0.5836070917038416, 0.576431522898856, 0.5484099565566494, 0.7577211580500646, 0.6072660547696546, 0.6569273587863722, 0.13283727948186863, 0.6495843705219557, 0.0982329984190603, 0.6120292365954663, 0.6420493513793923, 0.055734684988436256, 0.6447782914455045, 0.6702115912454829, 0.6254407419874249, 0.6500476843465972, 0.5817037626520383, 0.7658052263066868, 0.7051495547811399, 0.7348345478571997, 0.7092606672164046, 0.6511524092738553, 0.6885554913083257, 0.7272602668038155, 0.7671292835568722, 0.7779109603629275, 0.2541166516843948, 0.09829752299992067, 0.09333817692022639, 0.5042007040333294, 0.5939570376173211, 0.4856093065123306, 0.44317825624893226, 0.3886602858307667, 0.10592607757496442, 0.5540620932716603, 0.5497551240486143, 0.4899196200713294, 0.5674488309555166, 0.5368740083536224, 0.5340586302596584, 0.5306325924174151, 0.5368109495758754, 0.5419069715756464, 0.8035247684666751, 0.8286414188499505, 0.8243082973663964, 0.7886388815632354, 0.8097246540830187, 0.8185223569762916, 0.8018818231332938, 0.7973259155579069, 0.8268152375456364, 0.13522952807336008, 0.10714268208206612, 0.11798738852493984, 0.12689755311625706, 0.13386869141598667, 0.14652549490593536, 0.5515255595523367, 0.129477745756579, 0.17522412934977472, 0.17904096293904914, 0.43900948018741004, 0.2294649004701752, 0.7309696189267759, 0.6379598062251932, 0.24204448346378926, 0.2481804606126301, 0.27422726401218, 0.22811551899470273, 0.5821252630992912, 0.5260826549525958, 0.5498691687780408, 0.5690858382930352, 0.5264245391467941, 0.656778348257258, 0.5972211119797657, 0.5396404539316664, 0.4914114051009556, 0.4853002828961077, 0.42520430826589517, 0.42338654874477866, 0.5304816089541657, 0.5292817427956638, 0.4640113860948851, 0.2980188001765741, 0.29414316946096286, 0.43271908231403, 0.21515012309190584, 0.1967117430186076, 0.204174102738492, 0.20697198503398573, 0.19412276290100394, 0.19455745899323307, 0.2575147408543914, 0.20667087377036575, 0.2205709250411605, 0.2194051003014953, 0.2064582610793314, 0.21594392734212287, 0.27069803643611523, 0.22401158440858593, 0.6669372223251795, 0.242237502789165, 0.19044452953692848, 0.2416215679330559, 0.898445962607163, 0.17676165516929454, 0.8174889907945695, 0.1970560501588623, 0.4569383393485471, 0.1670473575545235, 0.3476074631213235, 0.8387607333927304, 0.15248185324749253, 0.9008665384721002, 0.2111294670960161, 0.20844844998609213, 0.8886094969507808, 0.1677172573625927, 0.15285908342981058, 0.21280823616889144, 0.21145934267640243, 0.8688741154701293, 0.1831516832550979, 0.20345320258227706, 0.20393976655034463, 0.19506035984865788, 0.18270829531687516, 0.25183000206693373, 0.19205397683877068, 0.19046099287055662, 0.17863965092651957, 0.08833081138887044, 0.07998498643890306, 0.0898139533394442, 0.08740666039952083, 0.08619786022495068, 0.08728624599605506, 0.11673135922468758, 0.0916967990022185, 0.08617592167474408]}, "mutation_prompt": null}
{"id": "bfd09f8b-d120-4f57-8688-3299b53cbe89", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEnsembleEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.6, 0.9]  # Slight adjustment in scaling_factors\n        self.crossover_rate = 0.85  # Slight adjustment in crossover_rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6  # Slight increase in weight adjustment\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.85  # Slight change in weight decay\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveEnsembleEvolution", "description": "Quantum-Inspired Adaptive Ensemble Evolution optimizes mutation strategies using quantum superposition and adaptive learning to solve complex optimization problems.", "configspace": "", "generation": 26, "fitness": 0.4890978690037834, "feedback": "The algorithm QuantumInspiredAdaptiveEnsembleEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "abc90c42-6da6-4b92-90cd-aef252395341", "metadata": {"aucs": [0.874029142142579, 0.8704850803759752, 0.876595365230659, 0.8783273074326235, 0.8815796503905104, 0.8759535749537063, 0.8788586873826003, 0.8693580309467389, 0.8695385804961806, 0.754382579846765, 0.7453659837998463, 0.756050173698062, 0.7643062577872637, 0.7377470845482946, 0.7355219283372252, 0.7657780235699336, 0.7655841261572418, 0.7656850430552947, 0.1240604338234994, 0.1560464255603794, 0.22037957174845557, 0.1669275884188035, 0.6014624576478238, 0.15864436682542837, 0.17186991856313905, 0.16675545914314338, 0.14797576236578103, 0.11071519159807175, 0.12119806952045853, 0.13350969492007336, 0.1445668546952702, 0.13207419168426981, 0.12255878127617492, 0.13352151889251618, 0.14468177322619247, 0.12256756521337375, 0.9882294260209229, 0.9579745897172526, 0.981103042444462, 0.9774082978812954, 0.975437766566058, 0.9784005525195116, 0.9781393015228318, 0.9679683096849964, 0.9777526003063532, 0.6871798367039021, 0.6931048463565059, 0.6725010523480386, 0.7151344028191391, 0.653967769018549, 0.6841622443516941, 0.6797042606099784, 0.6696356806135194, 0.675947379373285, 0.8680474424307918, 0.22661170143973486, 0.8573821582764747, 0.8643618333843864, 0.8483243323184835, 0.21060591103564363, 0.8697127225755579, 0.8335693896881765, 0.8742903823237573, 0.567948417251057, 0.6563253177474734, 0.5904353725353457, 0.5873621513576721, 0.6537508997268946, 0.12873704050774482, 0.6716492113001415, 0.5475559522832945, 0.5800129842522586, 0.5979094634363452, 0.6410182111146221, 0.6405357061207949, 0.6413040755002327, 0.6691669703394703, 0.5966552546771442, 0.6183931243450612, 0.6827089734647196, 0.5691361758462161, 0.6413264487340461, 0.6121703148922493, 0.5112239381670708, 0.605108523071934, 0.6005334638137803, 0.6306063925330047, 0.6606508521099714, 0.610727200826427, 0.6471731651012405, 0.6601648990807215, 0.692111417291291, 0.7254197417071301, 0.7175396749916911, 0.682648057342002, 0.6847370452217783, 0.7361620929042636, 0.6983653283138698, 0.7340809984698942, 0.352231398300885, 0.11130248842543389, 0.21392864577379156, 0.5531086055200568, 0.25183812242057135, 0.45782298049808423, 0.13715797329145485, 0.4272607376403387, 0.4045900902720768, 0.5275424942595809, 0.5544138228897595, 0.5290577361419461, 0.5649917287608774, 0.5111338538475947, 0.5157934660994283, 0.5178693905241303, 0.5412809696621379, 0.5005819796180015, 0.812038103693361, 0.7933199751326389, 0.8093196802219096, 0.8182020499350493, 0.8033522944787135, 0.7912549159397815, 0.830357967320206, 0.817562382969937, 0.8240090090544571, 0.11931825464134271, 0.12193947496361102, 0.13376611544928385, 0.10908815524833204, 0.1180973667600882, 0.13137948514253694, 0.11105292144607937, 0.10460656389513623, 0.1028263152570631, 0.1933225350078681, 0.16137090848762214, 0.17604308172538075, 0.15800052657139185, 0.1874151117298687, 0.4878701008783197, 0.24718659150068, 0.1535722718560948, 0.16756469770324633, 0.6187645649049833, 0.5550400124471968, 0.6214888324965251, 0.5279972354481914, 0.541182831455538, 0.5935397165531338, 0.5387788734317253, 0.6331865282608449, 0.6592630544900319, 0.4762309873606465, 0.43137508282508674, 0.4471181151266105, 0.44889114955603304, 0.21064390537153932, 0.480811019927856, 0.4855876835899683, 0.4878835817479128, 0.5567501290353776, 0.21192043386797443, 0.181596844553097, 0.20961583647696402, 0.18608384394411348, 0.2107596067254639, 0.21995654720443458, 0.2162022584487424, 0.19735711862753402, 0.19716890842524892, 0.2296072870636443, 0.2133357969743762, 0.19745970493550535, 0.6982371190796548, 0.22616493461289222, 0.24349362092504612, 0.21424737585692277, 0.21498835389844229, 0.669885855450896, 0.8625634025194464, 0.1648584459434974, 0.15313150542596177, 0.893701534267291, 0.19635591012030018, 0.8724918032201007, 0.18382920250346102, 0.839712188383696, 0.8606747903283827, 0.8729443640776071, 0.20922904830867062, 0.2073329344893905, 0.2066817483501754, 0.8599069477212231, 0.8649674083475034, 0.21301260495972207, 0.10404563530145683, 0.8747087843963651, 0.19667427747979604, 0.1941459667510218, 0.19433135040366456, 0.2016143315426554, 0.202035756625341, 0.18828458888244792, 0.2034290274594851, 0.207559833471049, 0.18431720949219532, 0.09998090519579328, 0.08483317308805816, 0.11310261569125701, 0.0888713429342064, 0.08326931167252205, 0.08233042528080714, 0.08322634039884402, 0.09015171802299338, 0.0958008457200038]}, "mutation_prompt": null}
{"id": "c7443591-3424-4d46-9533-489811d2198a", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEvolutionWithVarianceMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.learning_rate = 0.1  # Adaptive learning rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_var_1_bin  # New mutation strategy\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += self.learning_rate\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= (1 - self.learning_rate)\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_var_1_bin(self, population, idx, best):\n        # New mutation strategy that uses variance of historical positions\n        history_variance = np.var(population, axis=0)\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (history_variance * (a - b))\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveEvolutionWithVarianceMutation", "description": "Modified Quantum-Inspired Ensemble Evolution with adaptive learning rate and a novel mutation strategy based on historical position variance.", "configspace": "", "generation": 27, "fitness": 0.3891518815274461, "feedback": "The algorithm QuantumInspiredAdaptiveEvolutionWithVarianceMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": "abc90c42-6da6-4b92-90cd-aef252395341", "metadata": {"aucs": [0.7758434735090691, 0.8264455022432018, 0.8010905501596949, 0.7795941041829619, 0.795465343929618, 0.8007620505882597, 0.7762877304940167, 0.7902091662499705, 0.7969174746599702, 0.5942477411457315, 0.6719494751798241, 0.6256103490747402, 0.6435214269040666, 0.6469635324005122, 0.6414735702932499, 0.6442547629631472, 0.6170726265451858, 0.636451994114466, 0.16081248135089077, 0.13338682932619905, 0.24931791731904207, 0.11519839247549968, 0.13162300429524898, 0.24420822789275987, 0.2947658176125276, 0.11644650631214026, 0.14392129174927193, 0.1283446022140723, 0.11272956232240072, 0.13056284786947958, 0.1404273540071792, 0.14823135158336664, 0.10074921508476842, 0.14472771815686114, 0.09713960970973567, 0.11049951481279296, 0.9919100768372066, 0.9730928083150633, 0.9831122233764839, 0.9775126597522099, 0.9710307321956334, 0.9940244665019992, 0.9791726210026518, 0.9942091858480636, 0.962859202798452, 0.2998426620401732, 0.3121503916448668, 0.3248239546524615, 0.28243142514451447, 0.3161045060606479, 0.2905383349817253, 0.3311474262131915, 0.3148678209233615, 0.2482117053053513, 0.7974431014909604, 0.8365619146973621, 0.845245280074402, 0.8628196864771664, 0.8580414221933531, 0.7953212042067088, 0.7942908708238032, 0.8357173072861489, 0.8401100994492734, 0.4453113125105652, 0.39545203129060724, 0.5117329492190896, 0.39563062770022106, 0.13183988968410265, 0.5135778693508832, 0.48932879965504794, 0.43478977525582163, 0.44032639215031844, 0.0531480715543039, 0.3917500661841715, 0.43967084617393115, 0.45944956646423063, 0.12544373380392515, 0.37225190268304675, 0.3134320766554589, 0.1200187296388634, 0.1279069280702788, 0.5739218490696825, 0.26405902126695435, 0.46615410997369344, 0.6223252736381845, 0.5729121261334962, 0.574348856115432, 0.5783996417814248, 0.6231365465791268, 0.5465790090786701, 0.6492675409416759, 0.612855136717819, 0.6449871152695456, 0.6185331539596951, 0.6800718235823906, 0.6614862806172632, 0.6538569317108966, 0.6786379875490065, 0.6477392708452232, 0.30565605206113955, 0.1408321991498489, 0.04868076723515946, 0.24829037844744783, 0.146072768055017, 0.3466308675494937, 0.26342245921342544, 0.20835506272260196, 0.17576831208497656, 0.36258958156168497, 0.3546234661053934, 0.3729604464601214, 0.2982716309446334, 0.31964314214332956, 0.3499375834586541, 0.26287349264915205, 0.33349482938808483, 0.29160727589600854, 0.6602105227382464, 0.6612639221622088, 0.7260565725635448, 0.620911996257024, 0.5827010233460508, 0.6357146849972302, 0.6914060277998082, 0.6579757973337913, 0.6818452933547565, 0.11680742196652505, 0.10542677926331379, 0.1314519073732172, 0.08384676524059653, 0.11393558754221089, 0.1278264103919713, 0.1198663430066843, 0.08950868530689071, 0.10989074359794382, 0.1298236318470668, 0.19124144173948043, 0.11842175776965747, 0.13521774728009828, 0.19973569865084573, 0.16267926214118866, 0.505068436085961, 0.10990643805867928, 0.18190697889788, 0.35509397803780407, 0.33358741914667145, 0.339196222381033, 0.37728409222852455, 0.33353846124424436, 0.4191160960570405, 0.3929510881616326, 0.42231973782680565, 0.3920688832918905, 0.35588843668441605, 0.3102940313917749, 0.2887104987914435, 0.3114188931126526, 0.29666068166252135, 0.2958685731302284, 0.3307172514947101, 0.3383364583018895, 0.35344859927546457, 0.19751337335705088, 0.1894641844022109, 0.19354613872534532, 0.19649719556512146, 0.23566668068293317, 0.19757317582119405, 0.21376568325636158, 0.18881548498050216, 0.1949547065083893, 0.19657142130592553, 0.23556736048964344, 0.1977964693315326, 0.20820700998551145, 0.5648649146109959, 0.5905429804782559, 0.20696057325794237, 0.46544810702427886, 0.23433499108251776, 0.1685338074750069, 0.16116824494055093, 0.15399290773499397, 0.16348731609799383, 0.19822670143651056, 0.8569974735248038, 0.18619065613382446, 0.14028081445411977, 0.12145500365570971, 0.8571301131935718, 0.8376824674804542, 0.1661478921038575, 0.2015473844216188, 0.16698619038372542, 0.8603228521363886, 0.20109604485938093, 0.20150023292683072, 0.2117739171351214, 0.15474627040156297, 0.18635262052392498, 0.178402729987312, 0.1912834550167818, 0.16155918066105746, 0.17551020711387955, 0.16184418845654547, 0.17076530260355027, 0.17300438055614664, 0.09321965162643886, 0.08771272994631873, 0.0993389093736381, 0.08784384419666291, 0.08866186370614249, 0.08496586869397893, 0.0935778436673731, 0.08004889473804211, 0.0883209517388277]}, "mutation_prompt": null}
{"id": "bf8fb868-6445-4d78-897a-16713ef407d5", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEnsembleEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveEnsembleEvolution", "description": "Quantum-Inspired Adaptive Ensemble Evolution integrates quantum superposition principles to enhance mutation strategies using historical performance.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "abc90c42-6da6-4b92-90cd-aef252395341", "metadata": {"aucs": [0.8648592592834818, 0.8508048394866384, 0.8709068458013013, 0.876566902791248, 0.8717539668705648, 0.8704276880536199, 0.8603351706160125, 0.8689817813276226, 0.8568803579127634, 0.7442844642327662, 0.7663036494020166, 0.7201116860952688, 0.7422911800028242, 0.7295107345510672, 0.7527930878464473, 0.751381407419492, 0.7228511997103013, 0.719174834845209, 0.13600127167465614, 0.1430154623721237, 0.45299224527874926, 0.42235506116552957, 0.15655363621978235, 0.4338241421683101, 0.14105428958395116, 0.4493465927616257, 0.14980325377769677, 0.16618465209661148, 0.13165914233478493, 0.11314434574956744, 0.12200214217287508, 0.1142791501622119, 0.10891074941767198, 0.1309993343248509, 0.11527607702436904, 0.13035154936204163, 0.9854861256979982, 0.9731917555733575, 0.9839372199826757, 0.9777403895360776, 0.9730935367036666, 0.9767197543426536, 0.9866358701487625, 0.9882845173439609, 0.9865774448965784, 0.6744214961444142, 0.6687192952420864, 0.6684251385648413, 0.6987852376214795, 0.678848668917822, 0.6780574893778237, 0.6548312941039944, 0.6617489419068743, 0.6781082584249314, 0.8725530767647338, 0.8568890150203697, 0.7894835578532711, 0.8524089626294391, 0.8930519943749284, 0.2107561074362797, 0.8194339583387036, 0.8629870996262061, 0.8531680901982861, 0.12995082140920822, 0.7108482508314495, 0.42706446747175764, 0.615543703525943, 0.6831260857729273, 0.6759491272541212, 0.6355790385075983, 0.6206560494027062, 0.6812646658539643, 0.6574355115104478, 0.689889511607348, 0.5926265461310201, 0.6288801938940528, 0.6705899618600892, 0.66988222796063, 0.7178760581981073, 0.536033228385686, 0.6718510490077312, 0.618887162457552, 0.6646543799239805, 0.5276255532698924, 0.6716051527926867, 0.6235643975816256, 0.6359634413105594, 0.6508705620656445, 0.6787070879182656, 0.6802156810080874, 0.736056234954113, 0.696784155779144, 0.7157913386555275, 0.7086846477345872, 0.7555001625746189, 0.7180811471350825, 0.7431272436032101, 0.7272181648009562, 0.7379250288254195, 0.14221642042466998, 0.0877189170646181, 0.09895584425314341, 0.5347782203758711, 0.34175889742848264, 0.5052975186686128, 0.47233437050990146, 0.15563432731464633, 0.168604868095086, 0.5609630485592199, 0.5526705919695449, 0.5437811446956421, 0.5216985442359547, 0.5433243083513026, 0.5581236425539211, 0.5523679371664912, 0.5705707634062236, 0.5574074622330483, 0.8239818847031385, 0.8283322200835769, 0.8210665947742247, 0.8156571835826841, 0.820615719431953, 0.8012702681680686, 0.8122015410743877, 0.8115910854013328, 0.8100606486147107, 0.22917402513882112, 0.12081604989940065, 0.12112920223244472, 0.12558028690991507, 0.1607322176276702, 0.11002970454373551, 0.11858715154526112, 0.14844461347143512, 0.11045203674396398, 0.1819283097360287, 0.17510985121313827, 0.13780277284949227, 0.3719361176740055, 0.14452183648108408, 0.15426407327826308, 0.1880061371886551, 0.21792384928850705, 0.1815757852872617, 0.5715952140014403, 0.5831207173493571, 0.4736439433359355, 0.5604422769425237, 0.5757387476013793, 0.5090540953888236, 0.5860125230943343, 0.5843113402451738, 0.6089682241843648, 0.5331706596266383, 0.46419778236723996, 0.4530032448353143, 0.4934253501156599, 0.5277157867923032, 0.47104358819232717, 0.5554489688924278, 0.5395199454766763, 0.4418246029393982, 0.20574262668279963, 0.2046332028168263, 0.1991111346192006, 0.2051071287037305, 0.19338278956106192, 0.1979498924102382, 0.20973013185869382, 0.2135729170250602, 0.22087981957403902, 0.1969589976145817, 0.20600927216317877, 0.21888684004428682, 0.2192250882606418, 0.2130697958263652, 0.23376973562725234, 0.604947708801757, 0.6546955778222642, 0.235174717899734, 0.18272352616402843, 0.1835248608371427, 0.15287068932313996, 0.8946770982868334, 0.19814891809786084, 0.8777033590705493, 0.8855203155279023, 0.8303803832154149, 0.858171875091993, 0.8646976426153794, 0.20995618602066557, 0.1669981995288624, 0.20731507763863588, 0.8414964615381917, 0.16496329345166538, 0.21253098538459303, 0.2050919716240106, 0.20940977924435433, 0.18217858127519992, 0.1997265937300261, 0.18021903523916427, 0.17968762958702922, 0.1901353034642218, 0.19316590444297355, 0.1908773815686543, 0.19316600229408254, 0.19986572823087556, 0.08478727089215732, 0.07976308488499761, 0.0832786775131995, 0.09307389100893104, 0.09466871556973966, 0.0911002821335305, 0.13216069483283555, 0.08878916555478578, 0.08080032375835977]}, "mutation_prompt": null}
{"id": "e1aee3bf-e53a-4ee4-a208-509123bd56a5", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEnsembleEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9\n            \n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n        \n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveEnsembleEvolution", "description": "Quantum-Inspired Adaptive Ensemble Evolution integrates quantum superposition principles to enhance mutation strategies using historical performance.", "configspace": "", "generation": 22, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "abc90c42-6da6-4b92-90cd-aef252395341", "metadata": {"aucs": [0.8648592592834818, 0.8508048394866384, 0.8709068458013013, 0.876566902791248, 0.8717539668705648, 0.8704276880536199, 0.8603351706160125, 0.8689817813276226, 0.8568803579127634, 0.7442844642327662, 0.7663036494020166, 0.7201116860952688, 0.7422911800028242, 0.7295107345510672, 0.7527930878464473, 0.751381407419492, 0.7228511997103013, 0.719174834845209, 0.13600127167465614, 0.1430154623721237, 0.45299224527874926, 0.42235506116552957, 0.15655363621978235, 0.4338241421683101, 0.14105428958395116, 0.4493465927616257, 0.14980325377769677, 0.16618465209661148, 0.13165914233478493, 0.11314434574956744, 0.12200214217287508, 0.1142791501622119, 0.10891074941767198, 0.1309993343248509, 0.11527607702436904, 0.13035154936204163, 0.9854861256979982, 0.9731917555733575, 0.9839372199826757, 0.9777403895360776, 0.9730935367036666, 0.9767197543426536, 0.9866358701487625, 0.9882845173439609, 0.9865774448965784, 0.6744214961444142, 0.6687192952420864, 0.6684251385648413, 0.6987852376214795, 0.678848668917822, 0.6780574893778237, 0.6548312941039944, 0.6617489419068743, 0.6781082584249314, 0.8725530767647338, 0.8568890150203697, 0.7894835578532711, 0.8524089626294391, 0.8930519943749284, 0.2107561074362797, 0.8194339583387036, 0.8629870996262061, 0.8531680901982861, 0.12995082140920822, 0.7108482508314495, 0.42706446747175764, 0.615543703525943, 0.6831260857729273, 0.6759491272541212, 0.6355790385075983, 0.6206560494027062, 0.6812646658539643, 0.6574355115104478, 0.689889511607348, 0.5926265461310201, 0.6288801938940528, 0.6705899618600892, 0.66988222796063, 0.7178760581981073, 0.536033228385686, 0.6718510490077312, 0.618887162457552, 0.6646543799239805, 0.5276255532698924, 0.6716051527926867, 0.6235643975816256, 0.6359634413105594, 0.6508705620656445, 0.6787070879182656, 0.6802156810080874, 0.736056234954113, 0.696784155779144, 0.7157913386555275, 0.7086846477345872, 0.7555001625746189, 0.7180811471350825, 0.7431272436032101, 0.7272181648009562, 0.7379250288254195, 0.14221642042466998, 0.0877189170646181, 0.09895584425314341, 0.5347782203758711, 0.34175889742848264, 0.5052975186686128, 0.47233437050990146, 0.15563432731464633, 0.168604868095086, 0.5609630485592199, 0.5526705919695449, 0.5437811446956421, 0.5216985442359547, 0.5433243083513026, 0.5581236425539211, 0.5523679371664912, 0.5705707634062236, 0.5574074622330483, 0.8239818847031385, 0.8283322200835769, 0.8210665947742247, 0.8156571835826841, 0.820615719431953, 0.8012702681680686, 0.8122015410743877, 0.8115910854013328, 0.8100606486147107, 0.22917402513882112, 0.12081604989940065, 0.12112920223244472, 0.12558028690991507, 0.1607322176276702, 0.11002970454373551, 0.11858715154526112, 0.14844461347143512, 0.11045203674396398, 0.1819283097360287, 0.17510985121313827, 0.13780277284949227, 0.3719361176740055, 0.14452183648108408, 0.15426407327826308, 0.1880061371886551, 0.21792384928850705, 0.1815757852872617, 0.5715952140014403, 0.5831207173493571, 0.4736439433359355, 0.5604422769425237, 0.5757387476013793, 0.5090540953888236, 0.5860125230943343, 0.5843113402451738, 0.6089682241843648, 0.5331706596266383, 0.46419778236723996, 0.4530032448353143, 0.4934253501156599, 0.5277157867923032, 0.47104358819232717, 0.5554489688924278, 0.5395199454766763, 0.4418246029393982, 0.20574262668279963, 0.2046332028168263, 0.1991111346192006, 0.2051071287037305, 0.19338278956106192, 0.1979498924102382, 0.20973013185869382, 0.2135729170250602, 0.22087981957403902, 0.1969589976145817, 0.20600927216317877, 0.21888684004428682, 0.2192250882606418, 0.2130697958263652, 0.23376973562725234, 0.604947708801757, 0.6546955778222642, 0.235174717899734, 0.18272352616402843, 0.1835248608371427, 0.15287068932313996, 0.8946770982868334, 0.19814891809786084, 0.8777033590705493, 0.8855203155279023, 0.8303803832154149, 0.858171875091993, 0.8646976426153794, 0.20995618602066557, 0.1669981995288624, 0.20731507763863588, 0.8414964615381917, 0.16496329345166538, 0.21253098538459303, 0.2050919716240106, 0.20940977924435433, 0.18217858127519992, 0.1997265937300261, 0.18021903523916427, 0.17968762958702922, 0.1901353034642218, 0.19316590444297355, 0.1908773815686543, 0.19316600229408254, 0.19986572823087556, 0.08478727089215732, 0.07976308488499761, 0.0832786775131995, 0.09307389100893104, 0.09466871556973966, 0.0911002821335305, 0.13216069483283555, 0.08878916555478578, 0.08080032375835977]}, "mutation_prompt": null}
{"id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "solution": "import numpy as np\n\nclass QuantumInspiredDynamicStrategyEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.3\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredDynamicStrategyEvolution", "description": "Quantum-Inspired Dynamic Strategy Evolution combines quantum computing concepts with dynamic strategy adjustment to optimize mutation and selection processes.", "configspace": "", "generation": 30, "fitness": 0.5022700213818055, "feedback": "The algorithm QuantumInspiredDynamicStrategyEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.30.", "error": "", "parent_id": "abc90c42-6da6-4b92-90cd-aef252395341", "metadata": {"aucs": [0.8719334053441028, 0.8651882874544924, 0.880224015737281, 0.8762723601020995, 0.8833321700732475, 0.8933156568010017, 0.8950136235861684, 0.8766194153215868, 0.8751862900493572, 0.7703664167350006, 0.7709168883662348, 0.7652661360915941, 0.7619923387278658, 0.7670484174584975, 0.7348908586675567, 0.773696169543908, 0.7731468581166792, 0.744779679046216, 0.17220875465835084, 0.13751005114670756, 0.14078571737869439, 0.1734910050962113, 0.36612543312099843, 0.12773263369461185, 0.1342243123839023, 0.12916282004554847, 0.17418256078996364, 0.10561266129040703, 0.13703551046898355, 0.153921515642228, 0.1288960375519944, 0.38164537241423757, 0.16971348876222014, 0.11475111403677052, 0.13277075820185313, 0.1359856235714071, 0.9836956424960058, 0.9771472626725661, 0.9854418193803819, 0.9821305436081286, 0.981433128053874, 0.9864493368180358, 0.984900652053274, 0.9818615867742352, 0.9855823621216317, 0.7248081882043045, 0.69904267438662, 0.7255959580085743, 0.7026248098799053, 0.6711131882807646, 0.6985030348215413, 0.6799104149227566, 0.699301205957858, 0.7217002794573666, 0.8571695238523814, 0.884069699580269, 0.8762700787554925, 0.9097721873057003, 0.8590104934165037, 0.873132011500779, 0.8501592808438553, 0.8716968472523687, 0.8289056228235965, 0.13189561016238316, 0.6173417440641016, 0.6275506849472179, 0.6036039920020588, 0.6552192698379011, 0.6570577759955794, 0.7368429165517367, 0.6551980194292244, 0.7431779863459766, 0.1309192431930576, 0.5994958898291922, 0.6869041628419742, 0.1323891519949355, 0.7603888377541896, 0.7747114851045591, 0.6935034853193021, 0.7592716017739788, 0.6539442085334157, 0.6689430992942014, 0.549914883467582, 0.6147598126227045, 0.6224840883736564, 0.686742813394983, 0.7137650418402804, 0.7003109315310031, 0.6748387543022528, 0.7063140645191202, 0.7595892271631614, 0.7430453275809157, 0.7357665607115099, 0.7428335392407148, 0.7364570175781383, 0.7601578642943474, 0.7615613048744372, 0.7619379813941517, 0.7759096758450974, 0.4486675484468474, 0.2668826205655974, 0.1485029965793747, 0.586253686567116, 0.39551221439038753, 0.4936206272833713, 0.45134458782299935, 0.3982745469415814, 0.18954333330730444, 0.5909041560785251, 0.5841234639843189, 0.6083573453010029, 0.6252208904211098, 0.6204352074933165, 0.6231521265753246, 0.6122385827046188, 0.5868312437465539, 0.6034345916651541, 0.844447338324755, 0.8159261802691196, 0.8399566544857302, 0.8290937115592104, 0.8246900979709999, 0.8416594364894753, 0.8633532681501483, 0.829306304775377, 0.8419244981934728, 0.16517804920860746, 0.13177153621066806, 0.1467891113574873, 0.13650824044693344, 0.11619225499792296, 0.11291382059191835, 0.14597570919328895, 0.14051114716209323, 0.1589760854497001, 0.17733378032126823, 0.20268081293590356, 0.16166523837839408, 0.3717604960059422, 0.1327964356156497, 0.18445879209268878, 0.3014342326189088, 0.3106842179045911, 0.2837280840642046, 0.535097311439449, 0.47234145732798183, 0.6503611464720875, 0.6841457885966922, 0.42358694081833503, 0.6496219367884168, 0.7142987810703236, 0.677736641260811, 0.5546092396347659, 0.4386007821588772, 0.2633518469284871, 0.56073856470209, 0.584737887458816, 0.5340282156165594, 0.49493326169946816, 0.5487650018195804, 0.3829439205876347, 0.48971039869041344, 0.19883890504022794, 0.2005301804512747, 0.20537314816100838, 0.19486673768255336, 0.1910728467680044, 0.1953784989698092, 0.2189111701637646, 0.19567572840693914, 0.19861853952134956, 0.20283296092024217, 0.21906886882553922, 0.6691941885947863, 0.2153879872551141, 0.24485168742753138, 0.23402918664163153, 0.23364434028220582, 0.2206494899710636, 0.19706077131037836, 0.9094287629525952, 0.15666220639609185, 0.15433309404072193, 0.18527031146570228, 0.211905525899713, 0.17793625189225226, 0.14146696991978602, 0.17833550071709925, 0.20321000914713594, 0.9078200926071794, 0.8721129880090585, 0.9006120334194404, 0.8941015629581245, 0.20538206718819352, 0.8164768538110787, 0.21049613974050396, 0.20791285183306052, 0.8902363370675489, 0.17112581439895713, 0.19521224027938655, 0.20225460858984134, 0.1858753941811484, 0.18331456207528307, 0.19769071896978307, 0.18329464712230703, 0.1796753158826475, 0.21191075979891716, 0.08767598189424863, 0.0884169199497935, 0.09646457795622498, 0.098221716883089, 0.08430412355382177, 0.08669745480860225, 0.08787106974795678, 0.08962799087591122, 0.08526125390783434]}, "mutation_prompt": null}
{"id": "2a7e18bb-7a58-4837-bdce-d20e6527549e", "solution": "import numpy as np\n\nclass QuantumInspiredDynamicStrategyEvolutionWithAdaptiveMutation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.2, 0.5, 0.7, 1.2]  # Changed scaling factors\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4  # Increased weight increment\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7  # Decreased weight decrement\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        scaling_factor = np.random.choice(self.scaling_factors) * (1 + np.random.rand() * 0.1)  # Adaptive scaling\n        mutant = a + scaling_factor * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        scaling_factor = np.random.choice(self.scaling_factors) * (1 + np.random.rand() * 0.1)  # Adaptive scaling\n        mutant = best + scaling_factor * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        scaling_factor1 = np.random.choice(self.scaling_factors) * (1 + np.random.rand() * 0.1)  # Adaptive scaling\n        scaling_factor2 = np.random.choice(self.scaling_factors) * (1 + np.random.rand() * 0.1)  # Adaptive scaling\n        mutant = population[idx] + scaling_factor1 * (best - population[idx]) + \\\n                 scaling_factor2 * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredDynamicStrategyEvolutionWithAdaptiveMutation", "description": "Quantum-Inspired Dynamic Strategy Evolution with Adaptive Mutation Scaling utilizes quantum strategies with real-time mutation scaling and selection to enhance exploration and convergence.", "configspace": "", "generation": 31, "fitness": 0.4620570376749488, "feedback": "The algorithm QuantumInspiredDynamicStrategyEvolutionWithAdaptiveMutation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.31.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.9264991542657814, 0.9168216380829222, 0.9162256441356023, 0.9056825442852042, 0.9077692070616088, 0.9151332879513793, 0.914132971220412, 0.9083780862617167, 0.9185178239677424, 0.8164818587824687, 0.8288016757243879, 0.7917012572874021, 0.8411054320894584, 0.7811688253550255, 0.8234743723729723, 0.8002607979989244, 0.6705535366968287, 0.8382124833103064, 0.11490359810424378, 0.13914077797904756, 0.1317729897662131, 0.17774998206966408, 0.12629021572663568, 0.12391772992985095, 0.15484719066943742, 0.1127265973894962, 0.12267222967229241, 0.10777821043779057, 0.11940859413333582, 0.10938969067824911, 0.11086187122592095, 0.15067939242921546, 0.13307673938346487, 0.1192448926752313, 0.14519274902657053, 0.11077687187801388, 0.978641246706243, 0.9884953492651869, 0.9825762219565047, 0.9838266421520163, 0.9793183637482742, 0.9652549177702873, 0.9799501727750457, 0.9754892051758964, 0.9859686730004372, 0.7529863188745388, 0.7672195049146073, 0.6820793876688793, 0.7462271054209114, 0.7706750942415848, 0.7258288032124931, 0.7704164262935203, 0.7147225727828188, 0.751765229006705, 0.9148273895735403, 0.8804239464224972, 0.8887714405858005, 0.21439337672997916, 0.23479100578658885, 0.2788789172834406, 0.3608355309900907, 0.23266618408247008, 0.17723069047148732, 0.7774116196377994, 0.1308253902052453, 0.6344142321245708, 0.6407074352261197, 0.6508981803185494, 0.12735499747491574, 0.7662849754103258, 0.7238256012586073, 0.7536393724480088, 0.7772386167883407, 0.5559547873552668, 0.1268501262436561, 0.7735112017528772, 0.13421845040101565, 0.7250383702396406, 0.6733228718144963, 0.6428708699878907, 0.12127152429081256, 0.41279590469775007, 0.6070159567264585, 0.6959056143154729, 0.6459035657961372, 0.6289289666757744, 0.5988299559205106, 0.7381017094427069, 0.721373968772155, 0.7208299680980201, 0.7517367700560211, 0.797620310407922, 0.818930682553452, 0.7723993955966394, 0.7522214453065731, 0.8238214385638742, 0.8053979536018325, 0.766923284591499, 0.8185314849420865, 0.10356502694449554, 0.09865586073694632, 0.15412754031418263, 0.46855425577866505, 0.43372886241782405, 0.41608288002179306, 0.3201440537516449, 0.1374582899459681, 0.4427170665781337, 0.5636122800290638, 0.6795858098994847, 0.6558626082553278, 0.5127350711238866, 0.6993604679440696, 0.6854887417827459, 0.5927776146391112, 0.6593484534597187, 0.6525942642760378, 0.8638013553454825, 0.87268385666853, 0.8562300554813174, 0.8682994317954659, 0.8669502007698915, 0.783443620735308, 0.8847650001886367, 0.8633281103138937, 0.8673857230867481, 0.17310832984897295, 0.12233419096804887, 0.15060413689418406, 0.12602477529983114, 0.10950291537590706, 0.12781375009662366, 0.10916663463163112, 0.1331438467670485, 0.10607264567918595, 0.21430809610693724, 0.14641644029632117, 0.15641251034885495, 0.6377713664525536, 0.5063977706601964, 0.31750384566122747, 0.408944920946827, 0.17287607331059984, 0.15149423579466348, 0.24975016447110798, 0.2803377848374232, 0.34513836668592257, 0.48039386904642256, 0.3356465437317494, 0.28334062240102276, 0.47725491941235887, 0.2658108185652024, 0.45500835455736455, 0.382650432343973, 0.36749253467603404, 0.28879077228018857, 0.5031244834999908, 0.3083073934139897, 0.439435613939005, 0.2224955976488292, 0.5717719803605097, 0.3613414527301345, 0.21417801113498913, 0.2062385687129531, 0.21407239923029653, 0.2144623873857725, 0.23653336214165843, 0.216112737765499, 0.23565898306851163, 0.2116183543987259, 0.22525422810250206, 0.2500998697540293, 0.21309454004774087, 0.19892909087275878, 0.19039333491260724, 0.22629652028795244, 0.19130292547519978, 0.21507375519072558, 0.20212793135461282, 0.24664503057648945, 0.18807518172621696, 0.17581910806933743, 0.1998035706915151, 0.17189342133255814, 0.19970816659165636, 0.1168063996876032, 0.1426006815617269, 0.17925433329066598, 0.17805804081392163, 0.9166569647477341, 0.21231682025207943, 0.8772678283602247, 0.8825673209736502, 0.9267085690208237, 0.2112775557712594, 0.16748235295335578, 0.2112714363653838, 0.890921160816315, 0.20283847420147916, 0.1864106359994172, 0.19223891869875076, 0.16225740402291555, 0.19173469705846413, 0.18938765347779418, 0.18804556551839036, 0.1959238424047065, 0.20585166608261718, 0.10228464668225423, 0.09303444127315019, 0.10026732949156558, 0.07392606498003684, 0.09221985402351307, 0.08616399080031167, 0.08828313005204946, 0.08823462340614241, 0.08884392819144338]}, "mutation_prompt": null}
{"id": "fcb4d722-96ff-46bf-a1b2-090e7ce65b04", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveRecombination:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9, 1.1]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.25\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.85\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.adaptive_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b + c - best)\n        return self.adaptive_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.adaptive_crossover(population[idx], mutant)\n\n    def adaptive_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveRecombination", "description": "Quantum-Inspired Adaptive Recombination integrates adaptive recombination strategies with quantum-inspired dynamic mutation to enhance convergence.", "configspace": "", "generation": 32, "fitness": 0.40966201326721785, "feedback": "The algorithm QuantumInspiredAdaptiveRecombination got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.26.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.7955389787233603, 0.7945138277910649, 0.8264586326308808, 0.8058107483329459, 0.8091398236916388, 0.8027008329713762, 0.8115524319607017, 0.8033842381018275, 0.8188496415137243, 0.6534849223002507, 0.6184332289055625, 0.6585400586690431, 0.6156209208921821, 0.6595542360635648, 0.6530035825660818, 0.6507620340824041, 0.6445146859105524, 0.6547210521096999, 0.12412692269662262, 0.12584723130326436, 0.13012949929195416, 0.12537151149422243, 0.12628172451798259, 0.12206276531008131, 0.1267755795652027, 0.10539903782062832, 0.13641874403976018, 0.1002524791775169, 0.1165326733757871, 0.10514250879569098, 0.12241433288095338, 0.10914499315372106, 0.11149272610681782, 0.1134641939526877, 0.10260533548766615, 0.11612728125560556, 0.9678423539997625, 0.943874942094666, 0.9822585722588081, 0.9620797803452951, 0.9652952482469718, 0.9806321153205801, 0.9665643370767957, 0.9647180932289398, 0.9747381542603238, 0.45872318701895365, 0.5039041858741222, 0.48949504469357563, 0.5380053040661499, 0.5301385403839641, 0.5808660310099414, 0.5019003179935517, 0.514809072436845, 0.5269837137725838, 0.7452231907720577, 0.7866077154202997, 0.7622094002936143, 0.8101073558129745, 0.7658543829034214, 0.8071693286893227, 0.7813523668150311, 0.7541516133437791, 0.7495202614142632, 0.48404913874771227, 0.12370872510572772, 0.5241900825620582, 0.44140352459898025, 0.5042134564551934, 0.538515278684061, 0.46150361327482403, 0.5530394880084712, 0.5096787462064527, 0.4802370863670925, 0.12756075030269332, 0.4697421026819072, 0.5130793746630127, 0.5313499907586046, 0.49897815838281, 0.4735165477113441, 0.4906843040781931, 0.5063245407808119, 0.44161043794698374, 0.40743093333690616, 0.45929275690169935, 0.4829636857558085, 0.4616704168009059, 0.43798942661223406, 0.4398358162714089, 0.4438574484932112, 0.41792764732918664, 0.5581706374224673, 0.6054127666101932, 0.579174950425106, 0.5297892082414623, 0.5766578765364028, 0.5375580315497063, 0.5650079917672239, 0.6289853405902306, 0.605647387333924, 0.11798530288302522, 0.18059613391465879, 0.24819442696577787, 0.31744224379074437, 0.2430527215651862, 0.2244750312557049, 0.2732401891299634, 0.1890719635875855, 0.1359066163203213, 0.326702847528641, 0.32595962047177496, 0.355636895679754, 0.32951225655125105, 0.34738843868474145, 0.3820816296160925, 0.3318283681215919, 0.3375712697420312, 0.32444293284160597, 0.7445431126890636, 0.7236692466770442, 0.7224534455958914, 0.694233237605323, 0.7083584615192211, 0.7163699328908357, 0.6840334704277731, 0.7035781251341018, 0.7201033249725886, 0.10603655584181848, 0.10101453059883947, 0.0864700805601355, 0.10657865144605672, 0.09492432367921588, 0.09493579009052977, 0.09603543308075535, 0.0969207561124793, 0.1044032451096436, 0.14266784497724816, 0.1563935135654756, 0.1634980313931843, 0.16462421523626858, 0.14791430106002268, 0.16946907327514094, 0.15295222924029772, 0.13472278481032696, 0.15774722879631864, 0.4498614900948612, 0.4409327855192079, 0.418098726821444, 0.4283601245605362, 0.447902666125638, 0.4371596217865754, 0.44661680688014826, 0.44721496012213524, 0.4878393445296896, 0.30533969868725985, 0.34113733431972126, 0.3421564526125168, 0.2908811558453023, 0.3600411684428444, 0.31954181186316477, 0.3222763857284363, 0.37781437681976826, 0.3623441286790574, 0.18905710216986094, 0.19200383447511826, 0.18406157530742717, 0.18933196650301565, 0.18517912395416714, 0.21132313901200928, 0.22119999642342014, 0.21086531209973236, 0.19916688607314326, 0.21870950618597185, 0.17803003416509544, 0.1842493053453519, 0.20564149697838052, 0.19531256197103097, 0.20547191213979032, 0.4951747065292018, 0.28638739008187464, 0.19494824599903193, 0.7662325629842254, 0.16402383934919307, 0.8285449772794957, 0.1653480007624588, 0.7382744263439326, 0.694355035549832, 0.1822461983574113, 0.18549241401307304, 0.805235481005945, 0.7896844325049136, 0.20601700763691055, 0.6415636127162876, 0.20435963240793842, 0.7573787141312445, 0.19709279519263423, 0.14798090897190763, 0.20902874503229119, 0.7680028481779255, 0.2073579254428326, 0.18916227542498032, 0.1745700700977021, 0.19043580376588365, 0.1798419642579031, 0.1869430572568147, 0.19798125299637193, 0.20206658867020932, 0.21119793785669316, 0.07869782595242125, 0.08721790184474265, 0.08033023197895506, 0.08095975610115724, 0.07110832094103281, 0.08387322853736712, 0.07825973063325486, 0.08020045812181065, 0.07660023724868426]}, "mutation_prompt": null}
{"id": "c4503e8f-e2e5-4f25-90b5-a0211d37bad5", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredStrategyEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9, 1.2]\n        self.crossover_rate = 0.95\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.85\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.copy(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n        return trial", "name": "AdaptiveQuantumInspiredStrategyEvolution", "description": "Adaptive Quantum-Inspired Strategy Evolution optimizes mutation strategies using adaptive weights and improved crossover techniques.", "configspace": "", "generation": 33, "fitness": 0.44529200125101803, "feedback": "The algorithm AdaptiveQuantumInspiredStrategyEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.8149672786675339, 0.8042845783304676, 0.812783101629452, 0.8208768968212462, 0.8287923278946134, 0.8253858028362762, 0.8179623703970227, 0.8118740370124261, 0.8058287253226367, 0.6180038780552695, 0.6438700501204484, 0.6584208718483, 0.6536772004212732, 0.6464903446190468, 0.6217053621576916, 0.6459542127931136, 0.6277116642403642, 0.6632272645383954, 0.12139987084610093, 0.12588879928721686, 0.1533967425244226, 0.14506210403919217, 0.122402864230999, 0.14252343695653236, 0.16477198540759286, 0.1070964718717411, 0.1277554200355464, 0.09755720381906652, 0.11828889559544642, 0.1114840575228031, 0.12478315218983282, 0.13435129021609082, 0.13694916282905722, 0.13408414932099344, 0.11575470645666042, 0.1225398040798722, 0.9836092910241819, 0.962990717733818, 0.9768785507049723, 0.9833525657458463, 0.9818874832569638, 0.9632383120009896, 0.9881861395431404, 0.97899371791323, 0.9832723634037063, 0.462498663277245, 0.5444056356860297, 0.43967027302125006, 0.4700781127792317, 0.47107330640628164, 0.513880959205703, 0.5083965655620102, 0.4921925091797674, 0.5330908243926687, 0.8149492172356211, 0.8082060976668196, 0.7850885002479062, 0.8050668367886277, 0.8354797607356906, 0.841755919847824, 0.8439773461905126, 0.8478117713937818, 0.8043371229394444, 0.6727251033395122, 0.5611228398710817, 0.48650592975468354, 0.12570062045724772, 0.12298317623225141, 0.6200515206820563, 0.5713942463335802, 0.5852597454692396, 0.6017811335780865, 0.5518434754994366, 0.6223266915112333, 0.6170964498440261, 0.5641760568227459, 0.12746136948001185, 0.5605049248786999, 0.12694693736059814, 0.6169600570857774, 0.5639769468953786, 0.5840775192630149, 0.5755744181438771, 0.5716706875572984, 0.6017340134914857, 0.5856865531930231, 0.5945950330478827, 0.5544589326554257, 0.5865377081419647, 0.558510666233584, 0.6618869257088906, 0.6885865850229997, 0.6844329952164707, 0.6741947407810229, 0.6704580458585537, 0.6836765288672626, 0.7042880828265163, 0.6725959379162365, 0.6735122883099711, 0.4674535214570007, 0.4077483329982351, 0.09205364191199461, 0.4720303661242059, 0.24449163742637636, 0.34081602292092616, 0.12099640270036505, 0.31953581194108505, 0.32558135376341946, 0.45329323204297667, 0.4960638607192074, 0.43935504975515505, 0.4670338534246551, 0.4382638326158047, 0.4455964990781215, 0.4426057160705218, 0.43763644997500684, 0.482215291208241, 0.7608594047042865, 0.7502254690854658, 0.7534918985854311, 0.7237631900554677, 0.7768208817339134, 0.7494721427992238, 0.7891394703232114, 0.7475877907346404, 0.7354150642701158, 0.12547190810121522, 0.14061849068689825, 0.11996757941588132, 0.13410374530418723, 0.09597673057774936, 0.11776948173639012, 0.11235163556178485, 0.1054770399735333, 0.11996654751015212, 0.17016805357777354, 0.15518118221978516, 0.18437526419955652, 0.18457031276485258, 0.16358134205857477, 0.35250089461025014, 0.19300005662026376, 0.19837655018835054, 0.240369992183465, 0.47244919522236817, 0.48527907461319497, 0.4638637382795934, 0.4953282909529244, 0.4888318722674416, 0.4608521058285302, 0.48072794205641634, 0.50725659951915, 0.4538135121904373, 0.434978239477421, 0.25690003687800056, 0.40979004171712163, 0.40132472965639976, 0.4190675123726072, 0.33940903958126545, 0.38762525363527445, 0.4181762858869813, 0.3968748930003736, 0.19035384796114574, 0.22239237672044132, 0.19061428340322717, 0.18481911385534044, 0.18615094399264476, 0.18720155047719478, 0.19139562677579747, 0.19657752721561061, 0.20046752716419114, 0.20004796119947388, 0.21187547921992977, 0.21469257253144225, 0.23251449068677843, 0.2156351406355651, 0.6117033343801191, 0.23292709932629552, 0.21500708747252661, 0.23352144667053876, 0.8847191699810687, 0.18649532268383096, 0.8776721720244328, 0.8522723083208752, 0.19610691054488494, 0.19016088547700505, 0.1639847533376333, 0.8562487134056336, 0.8490175377695303, 0.8569230002613788, 0.20921898650549542, 0.12590859131783094, 0.7673689424125948, 0.752955403128317, 0.15294513748890437, 0.20817918916446554, 0.21148810493376746, 0.8653423577955788, 0.1853692474177704, 0.18149295197644366, 0.18633733771892325, 0.18827431873613631, 0.18533376255773248, 0.19041847673725165, 0.17459197644913016, 0.20341447499248055, 0.18071489856355238, 0.08433499574246084, 0.08226130158388245, 0.08605821639474431, 0.09235962972417566, 0.0795915179709209, 0.08272426608337591, 0.0737630703703861, 0.08667653461584446, 0.07095950134283902]}, "mutation_prompt": null}
{"id": "c9815cef-db55-47b0-a3a7-129f2b7c9b43", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Slightly more aggressive\n        self.crossover_rate = 0.85  # Adjusted for balance\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4  # Slightly more reward\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.75  # Slightly less penalization\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEnhancedAdaptiveEvolutionaryStrategy", "description": "Quantum-Enhanced Adaptive Evolutionary Strategy combines quantum-inspired mutation with adaptive population dynamics to efficiently explore complex search spaces.", "configspace": "", "generation": 34, "fitness": 0.4781223497789187, "feedback": "The algorithm QuantumEnhancedAdaptiveEvolutionaryStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.31.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.9061509869213289, 0.8955891750867988, 0.8946600037645971, 0.9159643831092845, 0.9036787973074984, 0.9139038613941748, 0.9034454356818777, 0.8921791321452802, 0.9029000253540195, 0.7722659219241167, 0.8106055258201585, 0.8229500239251786, 0.8109738268036153, 0.7775178125104103, 0.8056114248651681, 0.7863445499833465, 0.8025318780034316, 0.8130909852793271, 0.1534851101035365, 0.1520883573776598, 0.13044831808257606, 0.13818270815182154, 0.5555567036426117, 0.16833983409772335, 0.13968339554914078, 0.6264868050973773, 0.1703778070012817, 0.17464562607623724, 0.141906738537517, 0.12035948620799208, 0.1599569677303312, 0.1545167627180174, 0.11320783710530669, 0.09355087688349717, 0.11138682830704105, 0.1302567393553229, 0.9779099937535557, 0.9748966885765327, 0.9817754966096345, 0.9724080044636972, 0.9834046310389039, 0.9811694786645597, 0.9782939289861372, 0.9816174799817474, 0.9686655985569861, 0.7749242696589618, 0.7600315527298016, 0.7496756973632712, 0.7705456962579439, 0.7706049992100553, 0.729679690037895, 0.7491334802194529, 0.7497664598046272, 0.7677712778790247, 0.885085066796525, 0.908394406685836, 0.9114669644630422, 0.21214066822742828, 0.9116645113380648, 0.21986558147068513, 0.8275548146681637, 0.8852257473511522, 0.8765466207918408, 0.7195063567151807, 0.7765706756488142, 0.6743252729142941, 0.13107675447994493, 0.6742370075792257, 0.13276540813735282, 0.47682608518744807, 0.13328659174990298, 0.7684282968821242, 0.6292231227191387, 0.6453267248501617, 0.13335030535984138, 0.7937843803719314, 0.5016126406052632, 0.6946739743077973, 0.6061864530321296, 0.5509766023349815, 0.12816772043781444, 0.2860427297624014, 0.6481777170982783, 0.4853887776507182, 0.705522718313442, 0.5868425541858986, 0.03601199568136415, 0.7340207925267528, 0.7442391158652129, 0.7314448565325169, 0.7819885409039724, 0.7547208916214192, 0.7508393229552582, 0.7740134239879356, 0.783990310545866, 0.7766555287363682, 0.761362673124108, 0.7800844486754196, 0.6135624196672849, 0.10545366618407626, 0.1599852060880783, 0.09210280608925914, 0.5397887018020215, 0.2788461701347217, 0.21461837267018735, 0.12340689647165148, 0.15422332510652959, 0.14210311837775735, 0.5177188390705634, 0.5397171183671539, 0.5598112293877838, 0.6262587476810564, 0.5255751569237685, 0.5724283575421873, 0.40147097377529806, 0.6705453760278751, 0.49698993959547066, 0.85428111053063, 0.8500548954949733, 0.8769912703415849, 0.8432418262140949, 0.8468032422228068, 0.841648132515546, 0.8511224234249823, 0.8515240697532638, 0.8362365371339712, 0.09465569606503355, 0.12100142627927157, 0.1489879952788764, 0.1581217189857942, 0.17699362340636982, 0.13474380179150447, 0.0972620576851716, 0.11538106090739131, 0.13996299561926084, 0.26714045869229996, 0.18808553895876412, 0.17075439815720295, 0.3116070250635554, 0.2244359992122048, 0.26378719633556424, 0.264760425443368, 0.3451339788019234, 0.3189438110386147, 0.3708699619413839, 0.5660451230625584, 0.4754444595219768, 0.6158114460971359, 0.3111101308667501, 0.4164210796621197, 0.6001560136020554, 0.5943266626093343, 0.3932472984293329, 0.2352849114775729, 0.26431502701629106, 0.35804004470967643, 0.33953343043920337, 0.454000894194742, 0.42994734767918963, 0.2857467219313077, 0.2900908653439086, 0.5306215044829059, 0.24069710196083516, 0.20563478554660164, 0.1978368937441568, 0.2532796681372199, 0.19949591530320077, 0.223741576045684, 0.21113594311671202, 0.2364309118991066, 0.22304671921764274, 0.22454397271383264, 0.7954451533864119, 0.19737976202360252, 0.18947973518276584, 0.19431728094743372, 0.2460158592349182, 0.19621519927820608, 0.2071602879529333, 0.17777760040486268, 0.1561950396710896, 0.16498431076408326, 0.1533530164985326, 0.9061147990825249, 0.9178126618501783, 0.19875512474591162, 0.14220155267196677, 0.9026576438348728, 0.9066585817914747, 0.9129445376275472, 0.2120968269339214, 0.2071459511096293, 0.8259164225331046, 0.9107343768171303, 0.15296882938430623, 0.10437712980754421, 0.21158445767863687, 0.9098433493801744, 0.1910923366284445, 0.192407969625347, 0.22322062617127358, 0.18336763640025222, 0.22902354654574897, 0.19301051158745197, 0.18600964659369124, 0.18476999303517727, 0.17489224792203772, 0.08985725533507372, 0.08966607107868751, 0.0930675440279678, 0.09245914568629654, 0.09730342816034754, 0.07804959839841397, 0.10855563028523652, 0.08040945907191888, 0.09531363905969725]}, "mutation_prompt": null}
{"id": "da25879a-9468-4ed6-a60b-b203060e172f", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.9, 1.2]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.2\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.85\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategy focuses on dynamically balancing exploration and exploitation via adaptive mutation strategies.", "configspace": "", "generation": 35, "fitness": 0.47125897040908693, "feedback": "The algorithm QuantumInspiredAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.8645003373946618, 0.8549233242638861, 0.8561363759395775, 0.8686324878181186, 0.8680879928582208, 0.8741009525326213, 0.8810608755297047, 0.8774882234083304, 0.8639858811408171, 0.7498091403087107, 0.7282809201180123, 0.7231624219043391, 0.7501424893891754, 0.7391941004502809, 0.7402093940235692, 0.7185783662178068, 0.7411704125699683, 0.7111746413995079, 0.15808704175675503, 0.14531301955120512, 0.15402973411861987, 0.1377783163950247, 0.15539973523227724, 0.46841247996200586, 0.3109363060561483, 0.15500567668737752, 0.11249866373434925, 0.10751465964475937, 0.1345652737853441, 0.14137734960211235, 0.1393446543734741, 0.12483867763123035, 0.14232002183828518, 0.13951427290786356, 0.12199227431165327, 0.14565073387032568, 0.9812922393694601, 0.9723947564041437, 0.9856281851838015, 0.9708645972331471, 0.969949565523669, 0.9815781364249786, 0.9817835849432476, 0.9835993285621772, 0.9856671979769236, 0.5961956234727646, 0.598045785447491, 0.6082832559124826, 0.6168881317527526, 0.6387252184824503, 0.627075417341005, 0.6378259495398804, 0.6512602108038569, 0.5929305152360749, 0.8440918164939912, 0.8409633689702211, 0.8567348814545381, 0.8659433639908269, 0.8425629539236895, 0.8490376095055057, 0.8444803727151534, 0.8345809668744082, 0.894370436211858, 0.6959086461602785, 0.6507018206040995, 0.7190865426288606, 0.12825946416704115, 0.13174136838780648, 0.12859004606601632, 0.649538891570999, 0.6023132156833502, 0.5772930769287352, 0.6479452937545724, 0.6394956023180249, 0.590045130739112, 0.6735053340127317, 0.49597870004044853, 0.5601541574119498, 0.6090420900012259, 0.12200541469747272, 0.5912918325003728, 0.5175288517837706, 0.5962236947668234, 0.5504777388779261, 0.5763987665336554, 0.5569450148512505, 0.641722409302787, 0.6099059517296354, 0.6014015087655247, 0.5897074602537535, 0.7117108032937118, 0.6961732286455338, 0.6751342251470948, 0.6599330789397357, 0.6503429805778793, 0.6548539112178378, 0.6760631696689993, 0.690096393191129, 0.7168245999869323, 0.1838467100195138, 0.22942667104326642, 0.2900223787440064, 0.5095182876405997, 0.4537761709977399, 0.2314066946543828, 0.39667768763415023, 0.36663286589218136, 0.27152836145182313, 0.5000411804570513, 0.48835134624303245, 0.46973438449378013, 0.4890904282986849, 0.523870072537679, 0.5257076464886237, 0.45806613017968234, 0.514646639945102, 0.5144899396852111, 0.8044240404918899, 0.8246386154833232, 0.8118144753010598, 0.8124991852206678, 0.7915223420833959, 0.8012367519558357, 0.816200258164194, 0.8114609093046605, 0.798850485535262, 0.11488513919415233, 0.12475505184232061, 0.12411354978283884, 0.12103936429183215, 0.20542834607872817, 0.11935737516131772, 0.13328441439708805, 0.12606240201038377, 0.10877505301424184, 0.22358280174161482, 0.19994414258424498, 0.165547080585706, 0.22226566540404447, 0.314293691983041, 0.1962355477373945, 0.45115802006828665, 0.1983532288673968, 0.1796154398009443, 0.6154791040987533, 0.5166590059934986, 0.5421723408633232, 0.5846410384665498, 0.4633284971721835, 0.5374231805983039, 0.5212593031864571, 0.6593785188782044, 0.5221147243525919, 0.2777474389091379, 0.3803269848441819, 0.5354198817674505, 0.43625271254982134, 0.2086238212276882, 0.3824989747992753, 0.4350068508156084, 0.46685943018332554, 0.48106437628408183, 0.2100538733956906, 0.1938045224434909, 0.18987061842639297, 0.20069913710780019, 0.17774390612990754, 0.20860935968065208, 0.19942671862868755, 0.19678970317118027, 0.2181055611368583, 0.19763193081929442, 0.6089830266259317, 0.20082719171681807, 0.2002645182500471, 0.2384159964012199, 0.2200255312158974, 0.2354383185248602, 0.21960641786250557, 0.23245248827403553, 0.16354094210024017, 0.1961511050897179, 0.15403577509671762, 0.19588401144023548, 0.19871993880029348, 0.867477329850421, 0.14143145800478163, 0.15915077547305068, 0.8491787347845497, 0.8422018090820238, 0.2106292960588768, 0.8388419486456596, 0.8122474063297968, 0.16733112935736338, 0.8548400133910069, 0.8286416731656928, 0.21081789537550888, 0.8984034335686705, 0.18777786410862163, 0.1806037902751021, 0.18777017250621597, 0.18979198098802674, 0.17923524380236866, 0.18495167933607826, 0.19589985876923666, 0.17258559611739532, 0.19574628342201505, 0.08745338664515179, 0.08378022080711367, 0.08128452043764922, 0.08700827520110399, 0.0845728205906513, 0.08117818002972399, 0.07361833707406673, 0.08918194718289596, 0.08447968247696847]}, "mutation_prompt": null}
{"id": "b5d18f74-00c5-4fb1-8c87-57780427fb82", "solution": "import numpy as np\n\nclass HybridQuantumGeneticAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.25\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.85\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "HybridQuantumGeneticAlgorithm", "description": "Hybrid Quantum Genetic Algorithm combines quantum-inspired dynamic strategies with a genetic algorithm framework for robust exploration and exploitation.", "configspace": "", "generation": 36, "fitness": 0.48979552026302176, "feedback": "The algorithm HybridQuantumGeneticAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.30.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.9016291971147931, 0.8943041206731456, 0.9046905185028412, 0.9024921497180906, 0.9051305771755007, 0.9140251299827394, 0.894754186721654, 0.9023480988908136, 0.899548180320418, 0.8175419608674854, 0.8066820359331268, 0.8035764895162884, 0.8076396370608123, 0.8005923827021308, 0.8073165219081706, 0.7893941543984586, 0.8107924915217958, 0.7098322155301229, 0.17837091126053906, 0.12794031748196488, 0.7834542241092156, 0.14580164290669095, 0.1466417955122814, 0.14542459910607253, 0.1685445797071794, 0.15484209776042612, 0.15453632888095692, 0.09106086227329668, 0.1315598467116622, 0.1382786486811063, 0.13464527429903805, 0.1456490764133318, 0.1293124035665385, 0.15302698526674963, 0.13630462252566322, 0.12780125143500243, 0.9833187053829631, 0.975804731656996, 0.9805677383303809, 0.9719545917864544, 0.9723105314701581, 0.9802812252012038, 0.9782274921920237, 0.9838568227797637, 0.9825206083002523, 0.7405515131221385, 0.728860381143022, 0.7438490206072438, 0.7519172702353553, 0.74196706226203, 0.7440568693764761, 0.7313645476109953, 0.7241574856179245, 0.7830429305556661, 0.8928158568007167, 0.8883040885167545, 0.221257622261267, 0.20944352497589824, 0.9349460464361398, 0.2126308556116736, 0.23364098263289756, 0.23517198566900865, 0.87557832705107, 0.6192262272404904, 0.5609915348885308, 0.6143205867290447, 0.12999519960208183, 0.6379652006863334, 0.5034009720285928, 0.6368887961487513, 0.6759317076274791, 0.6433845301300296, 0.38796389200623016, 0.6753951427783577, 0.7596311386512118, 0.6462260655988157, 0.5743766128572168, 0.39174727945822174, 0.6514702022209957, 0.6047821312418069, 0.522016968004423, 0.5243718743379668, 0.7206154596245198, 0.688489564096384, 0.6335134840952954, 0.6594478949150517, 0.0679982645931273, 0.627406208299879, 0.6726719864029813, 0.7037392966078919, 0.7365700389361165, 0.7473798183954645, 0.7520308625746546, 0.7778086955115922, 0.757541015799975, 0.7944585639990023, 0.7428577025593293, 0.753663880276564, 0.759375318207745, 0.12041157155406057, 0.25672090660391933, 0.13198847196685715, 0.39180865890200034, 0.6748179903943413, 0.5909412288278788, 0.3308239665574897, 0.14619830100484943, 0.17717266511687302, 0.5839210351909621, 0.572244177195435, 0.570221520755055, 0.6337831275024484, 0.6279563888079054, 0.5609667052929075, 0.4863289683174534, 0.6435003878521977, 0.4518676190192704, 0.8506574320902177, 0.84856324892058, 0.8658860151388141, 0.8483111719815677, 0.8388219748748393, 0.8356639657024837, 0.865347546395031, 0.8522050669597474, 0.8550786596361781, 0.13766372593363363, 0.127144131232383, 0.11403441860431562, 0.11756078283415794, 0.13562815088262126, 0.12521068931700807, 0.14586787044239047, 0.15074481029907638, 0.1424938206493933, 0.41904623484793346, 0.26390842057141073, 0.17902378053534884, 0.22909847666653294, 0.1644661569961159, 0.20193667855778674, 0.2690154885071666, 0.14189072109032874, 0.22365550710938764, 0.48334080664698864, 0.49025831395042285, 0.5652670949258962, 0.5277047958784766, 0.7273645147244949, 0.6219637090024945, 0.603790471029197, 0.5865977221934502, 0.7533321509168203, 0.3382071550388076, 0.27234395182300364, 0.31224331054189813, 0.31023915866248775, 0.22643608780721725, 0.54766645913383, 0.4277689620090831, 0.37350358246425286, 0.6019192840433921, 0.23663911877422028, 0.1819963165039865, 0.18297377299790585, 0.19669996494577624, 0.21054510253826209, 0.2003865745209532, 0.24229111104926648, 0.222861423472416, 0.20045550886142405, 0.24510144863631556, 0.24984856132232702, 0.8249123364495841, 0.2072898480038643, 0.802948774341611, 0.2197649108658556, 0.2198609746847855, 0.24632231427053652, 0.1982374430087246, 0.9136875501199485, 0.1649322008422518, 0.15329627921201394, 0.9089385204084519, 0.9148513407216243, 0.9126286684577724, 0.14240953770806264, 0.16661212358765698, 0.9187710209881758, 0.889692060898366, 0.1687576262235143, 0.1669268196838728, 0.9067229581709775, 0.16800720960121507, 0.865569846403677, 0.10461960792439473, 0.2117911704056049, 0.8373144644414838, 0.1910707686274763, 0.18888434816513777, 0.19448298107726114, 0.16930403556335039, 0.1900724197596162, 0.17318794417692807, 0.19832657622609884, 0.19064215852245492, 0.19337264544157484, 0.09427708801868862, 0.08649625845948072, 0.09429348571349805, 0.08530928850552477, 0.08375586822493364, 0.09376069686401389, 0.09020055684140171, 0.09086797515332423, 0.08877815083975404]}, "mutation_prompt": null}
{"id": "078028be-f64e-422d-98ea-5ce0227b284b", "solution": "import numpy as np\n\nclass HybridQuantumInspiredStrategyEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(7, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.2]  # Slightly increased diversity\n        self.crossover_rate = 0.85  # Slightly lowered to encourage more diverse solutions\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.chaotic_sequence = self.generate_chaotic_sequence(self.population_size * self.dim)\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial + self.get_chaotic_perturbation(i), self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.25\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.85\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial\n\n    def generate_chaotic_sequence(self, size):\n        chaos_sequence = np.zeros(size)\n        x = np.random.rand()\n        for i in range(size):\n            x = 4 * x * (1 - x)  # Logistic map\n            chaos_sequence[i] = x\n        return chaos_sequence\n\n    def get_chaotic_perturbation(self, index):\n        return 0.1 * (self.upper_bound - self.lower_bound) * (self.chaotic_sequence[index*self.dim:(index+1)*self.dim] - 0.5)", "name": "HybridQuantumInspiredStrategyEvolution", "description": "Hybrid Quantum-Inspired Strategy Evolution integrates adaptive mutation strategies and chaotic perturbations for enhanced exploration and exploitation.", "configspace": "", "generation": 37, "fitness": 0.18959352110619268, "feedback": "The algorithm HybridQuantumInspiredStrategyEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.19.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.31886460680457107, 0.3438243294095482, 0.334442040746985, 0.3573772510959736, 0.338456149040797, 0.341180483759562, 0.327127689800885, 0.3133200257867359, 0.32151359676938884, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11093592681108677, 0.1081085678664192, 0.08155473281923098, 0.08850782269687985, 0.08983158112828116, 0.10739652632428354, 0.08059045673629517, 0.1007725541876554, 0.08712062589539582, 0.07996829033957453, 0.10142425515232756, 0.0880678919524791, 0.07257670381532022, 0.08164755693917647, 0.07065379930783655, 0.0868513944996957, 0.08906971073253334, 0.08102234522987273, 0.9807237233815645, 0.9728738204967474, 0.974495227051795, 0.9616959884181007, 0.9816665671736743, 0.9816165446207622, 0.9810747229340671, 0.9714837693347529, 0.9729792766079901, 0.20194427965465978, 0.20337547359725494, 0.20277152144040134, 0.21569038567331567, 0.19198958354196816, 0.19991870821971547, 0.2275932036887952, 0.21149226569426227, 0.2100889219094887, 0.24045047546696452, 0.22370861758017213, 0.24104922887914726, 0.2594609008706358, 0.23459957198938142, 0.2401926747532559, 0.2883029260567187, 0.24416025429461674, 0.2564165312881238, 0.10707672177017336, 0.12421504666675542, 0.11637804889387149, 0.12364987050559917, 0.1199105114464708, 0.10710974625193415, 0.1352245178882736, 0.1414148930182968, 0.11578438085402487, 0.06261826431860495, 0.1397332816787552, 0.10463581307095571, 0.12245451069603264, 0.14405326978108368, 0.11172154141131618, 0.12190780646472033, 0.14068498234811488, 0.11816443263703191, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003882389200547398, 0.00043003024752197305, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0853114320715278, 0.10518016747539294, 0.09634230912042474, 0.08728885998064506, 0.1023596902827687, 0.07896608827618967, 0.08934003423334236, 0.0531149500290079, 0.07427123877406361, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04520055881926177, 0.05635380981355298, 0.04063017012525083, 0.06568945412426386, 0.056876172393084734, 0.06098979436244867, 0.04582494666353609, 0.050431227399902356, 0.057721782549545075, 0.3316969176599439, 0.32389521665996435, 0.30184144185328254, 0.33321822694556635, 0.35269944842530043, 0.3209037845725745, 0.3242255159207329, 0.32764315833024815, 0.35285579353621443, 0.1167462450654555, 0.09902351749428195, 0.09402278971959654, 0.09790483380264481, 0.07402112653201254, 0.09710845250128364, 0.09258789109243448, 0.07659711922123114, 0.08299896084539438, 0.16126745075900994, 0.1336535601491058, 0.1538676463930898, 0.149001410260715, 0.1259986828535331, 0.2260050701087395, 0.1580434984373058, 0.164078503118807, 0.17486414871754696, 0.23268208090602482, 0.24726215545593433, 0.24191350985586357, 0.23828440909353088, 0.24257764641111357, 0.2339584932371226, 0.2340129693792493, 0.2402475123335135, 0.2410517744056382, 0.1802375533840921, 0.18002082894388316, 0.20520417161716664, 0.19357457346916773, 0.2067158298112286, 0.18738610784095677, 0.19143472843533194, 0.18087637506962906, 0.17654513478355205, 0.1933829643310997, 0.17080122397443975, 0.17786261996432773, 0.21078090581654696, 0.21237298021898865, 0.18749573673290942, 0.18472977515204836, 0.20337387021176578, 0.19298842377460368, 0.17084046480571757, 0.1723599477685107, 0.18014493768112094, 0.17248271733456766, 0.18063343567769574, 0.17520270628749457, 0.18211495923678378, 0.19067047509039248, 0.1804827517016735, 0.17989573544113313, 0.4608705876427831, 0.4141408650337557, 0.17269951748340773, 0.42478840242869764, 0.17286638701206325, 0.44320141397229873, 0.20037608145675956, 0.4002720248233601, 0.4303791161777992, 0.19810470258922974, 0.20194110299890577, 0.3352260394155384, 0.3673463204304951, 0.20106497594751982, 0.20577475366251652, 0.12436535151324224, 0.3206224750515404, 0.17284345640753895, 0.1810513941739662, 0.1935384224491874, 0.18030360932234157, 0.18876382479786236, 0.1800861710092606, 0.18305409766718572, 0.18048637369761256, 0.1917428855980292, 0.07494920359493462, 0.08173425023151903, 0.07665637843767403, 0.08817649954407625, 0.0828022612186824, 0.07509081967280107, 0.08507080435169356, 0.07605554667022241, 0.07691671993086768]}, "mutation_prompt": null}
{"id": "a94d5e74-d6f3-4ace-b58d-9714cfac6bc3", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum())\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.3\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9  # Change the decay factor\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n            # Adaptive strategy weight normalization\n            self.strategy_weights /= self.strategy_weights.sum()\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredEvolution", "description": "Adaptive Quantum-Inspired Evolution using Stochastic Memetic Dynamics optimizes with adaptive strategy probabilities and incorporates local search heuristics.", "configspace": "", "generation": 38, "fitness": 0.5016214296473408, "feedback": "The algorithm AdaptiveQuantumInspiredEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.31.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.8901973386879791, 0.8797284109008998, 0.8953874370000385, 0.8961494730387847, 0.8946389082389515, 0.8866949105225426, 0.8931012775970572, 0.8902677854433972, 0.8796998842233299, 0.7720579863336333, 0.7768065419985724, 0.8096079645212719, 0.799273965765282, 0.775960506905992, 0.7807681511727509, 0.8110289634337384, 0.7826767185812068, 0.7676110302902189, 0.17915169590096702, 0.3984415250424217, 0.17165923807746042, 0.14264460628758824, 0.1709701134181889, 0.15697497635123348, 0.13152089120839427, 0.12874795646487214, 0.1085570994705849, 0.12545177817370734, 0.14857076441980122, 0.1254706831200485, 0.16142570386232125, 0.15787559736348433, 0.13562363995361648, 0.12658670027103036, 0.14530382283229826, 0.12393187806233108, 0.9813628895418925, 0.9749363834646734, 0.9849158220149732, 0.9834873890111466, 0.9784608502437372, 0.9866801142481231, 0.9829628837221513, 0.9839656290206265, 0.9768616038879279, 0.7394399232109665, 0.6584743153551766, 0.7386757369107051, 0.7101049888278372, 0.7286947843923128, 0.6842708555053114, 0.724737917363935, 0.7341047740701008, 0.7275305970126065, 0.9015263995927283, 0.8840831390261338, 0.8722185607987468, 0.9021787229056607, 0.9061345394667519, 0.8833787206849683, 0.8825041918892509, 0.8733495314415293, 0.8827565464511866, 0.7132278213154812, 0.13062897913050875, 0.5851631271655457, 0.46195139409619546, 0.13090913363326506, 0.6224713859216814, 0.7565929457997658, 0.7937522639819787, 0.6875544686307086, 0.7099327081113931, 0.730129086529903, 0.6670184194167, 0.5946339505086893, 0.6747219094003395, 0.1330530399200618, 0.666585229493009, 0.12938574975121242, 0.1288594912773049, 0.6426209229012786, 0.6909956365252559, 0.6316162725327525, 0.5844504399026038, 0.725295402221547, 0.6889991216836957, 0.7191020539752064, 0.6873089169887798, 0.7194552337192978, 0.7845350345474518, 0.7964660430497472, 0.7764614661643992, 0.7539149024044779, 0.7658847185844263, 0.7249311758309847, 0.7768368856367439, 0.7734363951734875, 0.7885201043386824, 0.1089580950973994, 0.13034140747686251, 0.6169503414294085, 0.4843339669785771, 0.6917246827913045, 0.5660753254861394, 0.22685766753513237, 0.2675932558329036, 0.15928697683232895, 0.6684923600456072, 0.6039749496155316, 0.6302248688880498, 0.6174303334485682, 0.6103365448297395, 0.6291425349296996, 0.5690696097834149, 0.5787609644941537, 0.656712190146088, 0.8527713793093334, 0.8391510389612135, 0.8530588878252091, 0.8493831313067705, 0.8463368286249981, 0.8457434629365059, 0.8559655015597892, 0.8588132563621458, 0.8482787120767246, 0.10637473699445055, 0.0886938261432817, 0.131558426954831, 0.11176123787783088, 0.20781549559680845, 0.1345619222204174, 0.1345705435694755, 0.5293406250466546, 0.10265856553537456, 0.1934524045889635, 0.21318062740953236, 0.1692719834623364, 0.1843272137509634, 0.17970036550574964, 0.176727673723316, 0.1469679343985485, 0.24533142682589526, 0.20996797407161305, 0.5252299768671754, 0.6030618730566437, 0.5872505342898819, 0.5238491823794731, 0.627963122829907, 0.5518414620389982, 0.5935862606673091, 0.5756719391962838, 0.5635872484027967, 0.5771021343668357, 0.287796019495568, 0.39539414413555374, 0.4712729285379278, 0.49420590169240874, 0.32402143806990125, 0.44039342553971406, 0.5493689469879675, 0.5574514392295277, 0.21851584848096495, 0.20384784930505606, 0.20762980812218113, 0.18320264428334554, 0.19505364975943917, 0.19015674682546158, 0.19873650419292066, 0.19470164569357917, 0.2190367912293908, 0.20655775322936465, 0.18470378583669467, 0.2198566161127622, 0.21994352453850707, 0.21708060209172053, 0.24640511043652435, 0.19575770510673496, 0.24726016451211963, 0.20333400106605604, 0.9083192055696909, 0.18614357542188298, 0.1540438612429802, 0.871484423443046, 0.9036030074202399, 0.17692784207860335, 0.8566202396497661, 0.17841222931503486, 0.1460753690035408, 0.8700892183948716, 0.16849544804840844, 0.8831648823757696, 0.8953718502102075, 0.16740068445613576, 0.8737537904738768, 0.20908223514319524, 0.16391863640951998, 0.8856043302509483, 0.20472639260432202, 0.19625288704909893, 0.20544538470121365, 0.18480759813973613, 0.2166198154692387, 0.20222022611880197, 0.21294818234426438, 0.19177638814658204, 0.18422258593662633, 0.08372990868083374, 0.08828747977506723, 0.09507397304506449, 0.07500068588138398, 0.0836957668025039, 0.08831906046129501, 0.07871898301990987, 0.10163314229532228, 0.08961396229857232]}, "mutation_prompt": null}
{"id": "82a19ad4-1903-447c-bb7b-0b6a64fb9854", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredStrategyEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.learning_rate = 0.4\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += self.learning_rate\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= (1 - self.learning_rate)\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredStrategyEvolution", "description": "Adaptive Quantum-Inspired Strategy Evolution optimizes mutation and selection processes with adaptive scaling and learning rate mechanisms.", "configspace": "", "generation": 39, "fitness": 0.47237113999889174, "feedback": "The algorithm AdaptiveQuantumInspiredStrategyEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.31.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.9050463715861418, 0.9011497648137866, 0.9174024059373093, 0.9125163174445167, 0.9161114579801769, 0.9185097595246037, 0.9130627407101992, 0.9079377181199287, 0.9174078657979818, 0.8046555377562921, 0.7993522058887044, 0.7700962458068249, 0.835708722265123, 0.8287689992997712, 0.8153636856534907, 0.8248136038076882, 0.7970510444667178, 0.8213086826886238, 0.15547420412637025, 0.6760061662098293, 0.14620484942005918, 0.11348170228035503, 0.16158495612773316, 0.15258275128890542, 0.1793267826176831, 0.12040243485446134, 0.129980330121786, 0.0988976929563884, 0.15715118158578956, 0.06980332155536217, 0.15620856568563324, 0.14261961652816046, 0.09184269794806166, 0.13473304597536495, 0.12493983368894934, 0.11516176951125312, 0.9771357147430657, 0.9728193775760737, 0.9817860943587884, 0.9725288275748232, 0.9639644258340322, 0.9823741190614743, 0.9818106101775308, 0.9849721708399622, 0.9826578297801438, 0.780393263816487, 0.7199965047046116, 0.7248023706693054, 0.7476172251303697, 0.7711095473680714, 0.7660062022391437, 0.7724908809868877, 0.7402048061766778, 0.7640589117058523, 0.8370064128241363, 0.8410543910246494, 0.9085877782381759, 0.9166780604449344, 0.21239182769518117, 0.8901219411990543, 0.23939385781379474, 0.8716196375351881, 0.8768586791914382, 0.6631722107670501, 0.6818131855394056, 0.6401908432445351, 0.13033064755985502, 0.5621794472580167, 0.615945015911685, 0.747804857384645, 0.4042112006381816, 0.13230789046203406, 0.719459997162887, 0.13115019126488225, 0.6107993406996691, 0.818118220371656, 0.7081196567665331, 0.5061862312587573, 0.6932034587063651, 0.13177756315907463, 0.13066338602134497, 0.16261891413696028, 0.5598117338234025, 0.6889617613609089, 0.031815879560555316, 0.7375557201974394, 0.5411493373074192, 0.5762754288799754, 0.6894431776060795, 0.730272615256031, 0.7987520284091214, 0.7731468541239553, 0.7880168354245062, 0.7333760817017223, 0.6066416771744418, 0.743520296094988, 0.7664423232439725, 0.759699920517027, 0.8049786822866407, 0.35364396530726827, 0.12674825077237417, 0.1923187959001582, 0.23985838849649077, 0.4559428152748194, 0.5022919359893789, 0.22624566898051524, 0.29393722037886716, 0.11200548581197223, 0.5849914046344162, 0.5293706044514126, 0.6101007213258096, 0.6186745476207975, 0.6312023552213748, 0.6513549992461258, 0.6280675676816305, 0.4196071176973527, 0.5064377710821899, 0.8595806853171868, 0.8501306797226348, 0.851986115170152, 0.8469668937587527, 0.8705206107609381, 0.8258372813321762, 0.858763315418614, 0.8662131816147185, 0.8401383558342244, 0.11995458878543741, 0.15679641491069995, 0.10298072241364475, 0.14026052123751465, 0.14858695475980044, 0.1800693310251552, 0.12266440795053823, 0.0957264827162797, 0.11021085108105311, 0.6209967443101776, 0.24988776426377934, 0.14984804135202956, 0.22311195763101221, 0.2649435813263854, 0.24430132764884416, 0.1830433098481451, 0.2728409412422256, 0.19956370899143638, 0.5303570800838655, 0.2909063562985441, 0.6508002637690138, 0.5497751544165723, 0.4776414754357253, 0.6471052654084195, 0.39259287723018654, 0.47520973394425736, 0.3176025750900482, 0.3004409224552572, 0.525753006597157, 0.2942261111445701, 0.38993849465072317, 0.28058369747158196, 0.4517604688056889, 0.2902054932492286, 0.3938474609989163, 0.2884101734141774, 0.21073063993778718, 0.18893933806749752, 0.21002582793288793, 0.17870445772812094, 0.20956340344456992, 0.19821569270181694, 0.2044036296819196, 0.21601467744307679, 0.19827320722345632, 0.248905370940806, 0.22007381535822024, 0.22095531649328948, 0.19639083840483806, 0.24550454698665147, 0.2143093585435184, 0.21189335615327975, 0.24689700602993958, 0.21412532012700147, 0.19558571020665183, 0.17609608475999683, 0.15396295425745643, 0.17161226814247388, 0.2003277433068018, 0.8933132628751066, 0.14211111449851965, 0.8468849384043424, 0.9035947625793812, 0.8746500457830556, 0.21216048463109682, 0.20899253348593916, 0.16816032831844785, 0.8160102967854007, 0.8862530284771464, 0.104466207680454, 0.2107276783497707, 0.9094135877325011, 0.1953897041699768, 0.1796637003735153, 0.19658184352750696, 0.1841811743960583, 0.17992504260183628, 0.17025529114838078, 0.19943292412590952, 0.212310006468462, 0.1819294413104422, 0.09144385416765477, 0.08312361424578252, 0.0937227867964413, 0.07935443079499271, 0.0797205487822048, 0.10835207239202149, 0.09017810401053161, 0.0904306468003313, 0.08902211139328231]}, "mutation_prompt": null}
{"id": "4efbaf19-113c-4ffa-9e34-e006792290ef", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionWithQuantumSelection:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,\n            self.de_rand_to_best_2_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.2\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.adaptive_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.adaptive_crossover(population[idx], mutant)\n\n    def de_rand_to_best_2_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.adaptive_crossover(population[idx], mutant)\n\n    def adaptive_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        adaptive_crossover_rate = self.crossover_rate * (1 - self.strategy_weights.mean() / self.strategy_weights.max())\n        for j in range(self.dim):\n            if np.random.rand() < adaptive_crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveDifferentialEvolutionWithQuantumSelection", "description": "Adaptive Differential Evolution with Quantum-Inspired Selection optimizes through dynamically weighted mutation strategies and adaptive crossover.", "configspace": "", "generation": 40, "fitness": 0.35898092646829904, "feedback": "The algorithm AdaptiveDifferentialEvolutionWithQuantumSelection got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.8299824536919622, 0.8229674260383484, 0.8311033046943404, 0.8430135450223527, 0.8250791886469113, 0.8294685224728583, 0.837862782103751, 0.8161169877060664, 0.8326012293308704, 0.6650688632422261, 0.6751166256855454, 0.6713723619060509, 0.6669934676056035, 0.6677841177187651, 0.659243780042731, 0.669108059614738, 0.6538046256227921, 0.6923523244408304, 0.5568363996650935, 0.566001746040284, 0.4965112410026904, 0.5816064459590167, 0.4474200578232046, 0.16551158876508598, 0.16840993667381865, 0.5746376519161474, 0.5149308279752025, 0.5541575541492741, 0.37677628647213957, 0.46475044702409807, 0.16791323677473735, 0.1585020111487343, 0.16984632585662074, 0.5143495765756981, 0.14311477373345294, 0.4920740857322191, 0.9583282567056395, 0.9645015200012146, 0.9558227380893192, 0.9840134331184409, 0.9547829587599876, 0.9639970528311234, 0.9613692925954778, 0.9572016304281689, 0.9624911598814183, 0.3955261698496415, 0.42041936802686963, 0.3669008303668567, 0.43613164321619635, 0.40137242098635806, 0.4500025068930069, 0.38491160792447, 0.33817806625175106, 0.37294248958489085, 0.6651025243417727, 0.6818149536440801, 0.6129580024533838, 0.6915308084927523, 0.7373586759364126, 0.7191833358656008, 0.641507304644091, 0.6719977808975577, 0.6474894334855436, 0.1798607693547417, 0.2138360964773648, 0.12495540281338968, 0.17762534399460528, 0.12100082987423044, 0.19146672642934093, 0.4122263534760705, 0.25789590196659096, 0.1745268995429624, 0.28651414286771226, 0.22506350875734982, 0.1998960565960065, 0.21538385348643452, 0.239178358471132, 0.1270572559450407, 0.18633178335771494, 0.20732098320841852, 0.20120571794869058, 0.12236814293506426, 0.1037714928770882, 0.07743398287840941, 0.028455220643798795, 0.07744436885240125, 0.05180142620366901, 0.12685297162907505, 0.09998975293420675, 0.12345750991846649, 0.2548139956801996, 0.28406184691747927, 0.25118574226230184, 0.1970845588469179, 0.15402008423228597, 0.24068313800310348, 0.2598645516767084, 0.3312735046506107, 0.26810896936452266, 0.06978722319342157, 0.030629484075657687, 0.1045880945559533, 0.09143578028655919, 0.08947384181713403, 0.06753127813385329, 0.09729756301885739, 0.058574889740484304, 0.1184416335683125, 0.17584693955218722, 0.19058190144556197, 0.17981708497893356, 0.2146055018749924, 0.21157736277021189, 0.228773565612734, 0.18501551485781365, 0.16292982595075922, 0.17552293627747384, 0.5773046463491667, 0.5467589735861902, 0.5780182574683463, 0.5518352183150714, 0.5729681690909536, 0.5560183897386375, 0.5962591495265781, 0.5953195489181247, 0.5770708683938135, 0.11307088996311154, 0.10737331661944094, 0.1057149531914976, 0.11121975589391986, 0.09808413569363605, 0.1053028129412169, 0.09654162207617922, 0.104279684257094, 0.10854174910017866, 0.19178098279125588, 0.14423497942198882, 0.1432029549506899, 0.1479155948127585, 0.16527453632704725, 0.13195949111316263, 0.1377485587683117, 0.12898126438624058, 0.1511695529794963, 0.32670376638038146, 0.3916282213928147, 0.4322384396096801, 0.41633909381332757, 0.37861912594453995, 0.3768252480757258, 0.429265798009268, 0.4113211483477395, 0.45136227289730413, 0.26855436176004754, 0.25371165802076945, 0.29991731582419645, 0.28379837907190697, 0.3111448008727399, 0.22028744137931877, 0.3009140307031809, 0.3243673699694697, 0.2445708657088944, 0.2202215931401693, 0.21042881102157085, 0.19152070808217436, 0.18486246727111377, 0.2348739993596558, 0.2326782956500396, 0.2012380244652191, 0.22009851512740675, 0.22131691593780445, 0.540075425279601, 0.5839743060243973, 0.6035811561222014, 0.22737181385977523, 0.5050317047283337, 0.2620576867421195, 0.20806857828830083, 0.20810900696111656, 0.22617965969603526, 0.18364412016013187, 0.19357565007201982, 0.17791274701717996, 0.708153302311086, 0.19056973711239633, 0.7885911715112677, 0.7583495006313861, 0.5907302128550412, 0.7452192197622101, 0.6587069722788192, 0.204164384701081, 0.19397496833369743, 0.20410625083660228, 0.614229701368176, 0.27457784112761385, 0.635287251707368, 0.5538346407849252, 0.46378657338151175, 0.17575747228245686, 0.18390521526632764, 0.19130621601589415, 0.1799232545967423, 0.1855431605111456, 0.19459543985952865, 0.17579481319333812, 0.1803446131875962, 0.1879488678728879, 0.08549157447764477, 0.09359531111601405, 0.07761729938337725, 0.08530696841930674, 0.08029460759995943, 0.08782273869351631, 0.07819604338746045, 0.08261804312419552, 0.0805226790689465]}, "mutation_prompt": null}
{"id": "fb6b30f4-a48b-4937-90f7-d54c2e98ec66", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]\n        self.crossover_rate = 0.8\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_current_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.2\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.85\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredEvolution", "description": "Adaptive Quantum-Inspired Evolution dynamically selects mutation strategies using a hybrid approach to balance exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.47211002571770533, "feedback": "The algorithm AdaptiveQuantumInspiredEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.9008475573381579, 0.8961630449737341, 0.9000245458594521, 0.9026392201059633, 0.895247543690935, 0.901505738532296, 0.9033101948626779, 0.8877678770466318, 0.8994930302332359, 0.8148005790203463, 0.8112420823736081, 0.8189227235933639, 0.8132754090063594, 0.7925068519250029, 0.7852962907757658, 0.791450343601152, 0.7962823201296507, 0.8039993331251192, 0.18549071406876816, 0.15506331864878886, 0.15664622042755416, 0.14739187009103893, 0.6184845014230587, 0.15447134846221766, 0.11439029882489982, 0.69373670513483, 0.4758654100224512, 0.11694556425988323, 0.134009466479307, 0.1294453589004907, 0.13553503702529612, 0.10883795349622982, 0.13814145532376298, 0.1407382074368292, 0.17381865018551468, 0.11189909365384432, 0.9788449492224195, 0.9759162940835864, 0.9827792755843295, 0.9767036902658793, 0.9759518699950324, 0.971652096369302, 0.9595285138042491, 0.9836466465396219, 0.9781725871842663, 0.7298227614335915, 0.7329240018524648, 0.7464288171218274, 0.7442896894420041, 0.7231641214992994, 0.7061755255733833, 0.7182551120803969, 0.7239061603116258, 0.7300698363664253, 0.8493587255275259, 0.23959198297935835, 0.7523235505782297, 0.8588227321868023, 0.8821752681132683, 0.2124524336741137, 0.22821093745780485, 0.1729219339198218, 0.8040721455491934, 0.13135756465592296, 0.7602079394110276, 0.5784818688852496, 0.556439409535398, 0.5685091025135309, 0.1259086238282714, 0.6490306897920279, 0.6940324111526448, 0.6911342389335566, 0.13382454367387142, 0.7137014363281424, 0.4518614273025241, 0.8108763592755635, 0.43445940623911505, 0.6806803771279584, 0.6192269658333958, 0.5719724756390723, 0.39624561226737454, 0.5441687341812216, 0.4857609020849407, 0.6003394678280358, 0.183668133144966, 0.5892130436414389, 0.4901391682984415, 0.6397439362437607, 0.6441549187663228, 0.5078784087155475, 0.7105185740176339, 0.6720822432664212, 0.7167189077132365, 0.7425444351113442, 0.7196231797586576, 0.6901664984261009, 0.6665465518873024, 0.7457935229133416, 0.7561889133299571, 0.09316865751281389, 0.31669860110924386, 0.47792372214717294, 0.40175938779773546, 0.11955783323763658, 0.6085977499737699, 0.42376562640432913, 0.14803737833316877, 0.12417958953008223, 0.48455332165418463, 0.5686016524827924, 0.4576398799768814, 0.6018737591950388, 0.5797391191225322, 0.5500096318648203, 0.43870589714561203, 0.525392016045527, 0.5358181561761535, 0.8394243826469654, 0.8367642037394678, 0.8186156133138063, 0.8575213813957234, 0.8418582212965968, 0.8043125193138295, 0.8311866304663605, 0.8207128671708467, 0.8309844967915139, 0.09134031585163616, 0.11997786865245508, 0.6688731237402488, 0.1529303959373416, 0.11754597610391415, 0.15004748917274136, 0.11350956282815694, 0.14419690805420338, 0.1591021288579001, 0.18557960076027824, 0.1980620627975973, 0.2675415781749171, 0.2438729115636249, 0.24119255043022125, 0.13510553910678336, 0.32746222679029646, 0.17152826822958744, 0.22088625980511345, 0.6553644890402335, 0.39044201815034285, 0.6211623464822469, 0.5568102943592752, 0.5184575314790698, 0.6797084362955894, 0.6171014189002539, 0.6269559348936814, 0.6243364050465596, 0.4031703394637247, 0.3029771003241434, 0.25970752715436773, 0.639045320712134, 0.42133126928730824, 0.4922597463690507, 0.23040084858726306, 0.5258741461609443, 0.4580421736607486, 0.21543450524652008, 0.21224449147248292, 0.19807741386356115, 0.20129528533181051, 0.2052994468706435, 0.19504866589683734, 0.2010518579939553, 0.20882899984018588, 0.2046215627322836, 0.2423346239317522, 0.22365475595183648, 0.7699363736197725, 0.2404625301976775, 0.2349659297543596, 0.19150991158737607, 0.2043498634552291, 0.23832402757538196, 0.21965881350610061, 0.16662962122336433, 0.1645833447365439, 0.15285910365015898, 0.17159856893907832, 0.9012421196469158, 0.1312281499080734, 0.14235873343012295, 0.1623078114666019, 0.9263302071719438, 0.8784950373793434, 0.20998476954726464, 0.1269683483167806, 0.8749782574928526, 0.8610133725110394, 0.152345046314582, 0.21227182029885572, 0.20985922210973817, 0.7872460117590284, 0.17385502200977354, 0.17910352423565779, 0.1833738744556095, 0.19060144594275374, 0.1795405658398438, 0.17960919150226617, 0.18827639351512504, 0.1910936020565388, 0.18720677676143527, 0.08685601328243842, 0.08261180864680828, 0.0964269671498369, 0.08971035184781595, 0.09493367533131314, 0.08398580943439515, 0.0809222537148857, 0.09029808371857584, 0.09160967128330177]}, "mutation_prompt": null}
{"id": "1dc25b5a-0a71-494c-94ae-b8c2fae47bad", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 1.0]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_current_to_best_1\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_best_1(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-inspired Differential Evolution leverages adaptive scaling and strategy diversity for enhanced exploration and exploitation.", "configspace": "", "generation": 42, "fitness": 0.4772678980075877, "feedback": "The algorithm AdaptiveQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.8833101445315424, 0.8899857351108423, 0.8870770825055514, 0.8847447780354438, 0.8820023522261915, 0.8839925998173234, 0.8746582528937097, 0.8836418656707488, 0.8802045667197603, 0.765070561431784, 0.7764328615959907, 0.7374190445953522, 0.7618513998576941, 0.7611100996746369, 0.7405888975044614, 0.7669615586708717, 0.7412446674662436, 0.7526522569488107, 0.16793670802036065, 0.15776647521583453, 0.5350090919496593, 0.17061887914629492, 0.14870007731931523, 0.1558091945496891, 0.16769656647594366, 0.14721256896274348, 0.16975834423090197, 0.13487944540676378, 0.16580654232373748, 0.15033299868703676, 0.17208056499037594, 0.14916794222548035, 0.11559502730541316, 0.13476866138756682, 0.11501429316870049, 0.11190838638718525, 0.9807666064771743, 0.962221926859997, 0.9807121237369064, 0.9832061655703155, 0.9679554650099103, 0.9724290532333795, 0.983511962126804, 0.9726065059942433, 0.9694447012903737, 0.7002263436013871, 0.7039354638783512, 0.716392582730313, 0.6928958717767166, 0.7105675123492992, 0.7045944382773186, 0.7134869768314391, 0.707080346166749, 0.6951771578831614, 0.2264540771030028, 0.8424348469999948, 0.8647566528665467, 0.8849679068819742, 0.8768127745231038, 0.8949269084609295, 0.22813396582852274, 0.8970325182150967, 0.8815960472561939, 0.6880842491333017, 0.6318666321701827, 0.6395103081521782, 0.6525266469464741, 0.4740242144631571, 0.5460992411081009, 0.13142869328822981, 0.5529245214091515, 0.4652329259480832, 0.56260402548363, 0.499814139296202, 0.7170467810540584, 0.6009942093519287, 0.4334262445454625, 0.6848226565340072, 0.3928519525873613, 0.6725211953640722, 0.6100591035890893, 0.5516164372663432, 0.6624274432048515, 0.36836428061649584, 0.6017890892067419, 0.5896841201183564, 0.6333294706367165, 0.6802402899694551, 0.6899207778714045, 0.619935822325041, 0.7160816686311349, 0.6993927589001485, 0.7187009077474765, 0.6942094558166423, 0.6892928288609349, 0.7049062418641178, 0.7265002874182551, 0.73026070003828, 0.7264617334187755, 0.2301560659807258, 0.10666493621415407, 0.14233481986696406, 0.19268517256141593, 0.5869533618074747, 0.13533163318432906, 0.18528211743916045, 0.15980998544464287, 0.11468677791196746, 0.5695212616355503, 0.5206882105155568, 0.5062126319681781, 0.5545447807053001, 0.5628602574911481, 0.5526015360832403, 0.5072161002748325, 0.5376525630707498, 0.5345753955853947, 0.8379361016745714, 0.8253426661323265, 0.8333370843747987, 0.8149823007632779, 0.8305876215172432, 0.8136542055402463, 0.8287674592952101, 0.8259496569223856, 0.7988856322078229, 0.1352694932940085, 0.15031598047558525, 0.107465603618081, 0.11888433364785556, 0.11078551873260423, 0.14652061317270126, 0.11040571398496413, 0.13576817799701824, 0.11392923104894748, 0.18212271098037203, 0.1705949975671479, 0.329019531465368, 0.42854531309657495, 0.18562239357178778, 0.23667525563297886, 0.16513671241424, 0.23963775368458173, 0.23023619634869186, 0.5624647043866595, 0.34429380250207675, 0.6406918645846271, 0.6567056549407255, 0.5094295493121277, 0.49617053389389143, 0.6019298252621206, 0.5929032091922763, 0.604787782358568, 0.2746736599565204, 0.41447655481511425, 0.39569734010917823, 0.45025098117741924, 0.4346719646540732, 0.3732950257062728, 0.5072409109057152, 0.39831751138177074, 0.21319789069541106, 0.2231032026250196, 0.2167700521731678, 0.1984529003079447, 0.19808273468439352, 0.2161521462102245, 0.2434350641527926, 0.21344698760112402, 0.21880129818898242, 0.21579125131935684, 0.19588075203921884, 0.19593380038450492, 0.21892911487912214, 0.24050999239785165, 0.22084050510811604, 0.2418497294699572, 0.24533555861534362, 0.19741657498088294, 0.20514026196919943, 0.9013267705557272, 0.18643784129925844, 0.902791999661338, 0.9155602563992257, 0.1984707373388359, 0.199039577983954, 0.17536265367684212, 0.17744772338835824, 0.17308873142988668, 0.8907270405809747, 0.8696538122467402, 0.8555876238207951, 0.8428777161214697, 0.8426291106826735, 0.16711293336923194, 0.21204454588117339, 0.10470821860150792, 0.8914944034157232, 0.18269710709684372, 0.20475677240828982, 0.19204129837176598, 0.18747756769543167, 0.18899048093601434, 0.17482631198413678, 0.1843451620735903, 0.18265692227912, 0.17698799568592927, 0.08155769314003158, 0.09133208859029096, 0.09003310357890293, 0.10177248542015149, 0.09683271376536229, 0.0968438110521167, 0.09154558863941042, 0.0931796768287706, 0.08611148452013584]}, "mutation_prompt": null}
{"id": "e6b29232-bf75-4adc-8b4a-af7c6febc2d0", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDynamicStrategyEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.7, 0.9, 1.0]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.learning_rate = 0.2\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += self.learning_rate\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= (1 - self.learning_rate)\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDynamicStrategyEvolution", "description": "Adaptive Quantum-Inspired Dynamic Strategy Evolution enhances strategy selection with adaptive learning rates for mutation strategies.", "configspace": "", "generation": 43, "fitness": 0.48869929429584685, "feedback": "The algorithm AdaptiveQuantumInspiredDynamicStrategyEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.28.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.8591825860619524, 0.8479326676745, 0.8715211064471048, 0.8732427016919571, 0.8696549466237217, 0.8774029610530533, 0.8828588695526944, 0.850497168862509, 0.8589596047571667, 0.7284550465904072, 0.714408390908184, 0.7480771358733028, 0.7564853509383713, 0.7478135357440792, 0.7550210403081482, 0.7417636729435629, 0.7179081245609416, 0.7321601049320456, 0.6120019452453541, 0.45758103099838376, 0.1412496931499636, 0.48928034765203243, 0.14210460860586116, 0.1684423699652836, 0.16524109065500636, 0.14020518886034827, 0.15827682014967182, 0.13141905851291535, 0.13241997837658548, 0.457666871004607, 0.114906869911656, 0.13837399639452574, 0.13209035690468518, 0.13090442234377786, 0.14405409010075876, 0.14362584107359322, 0.9839528770458759, 0.9740984445320164, 0.9854827026261124, 0.96725042888903, 0.9707130688248494, 0.9808151150808879, 0.9799245415208517, 0.9855252728883459, 0.9633432780672031, 0.6275723894289493, 0.6349877595031188, 0.6080098465404808, 0.5985490170368455, 0.6319432843074406, 0.6729257026925639, 0.6384008336615881, 0.6739117321027055, 0.6009409731326539, 0.8244176740042881, 0.8591205274944473, 0.8718698627564085, 0.8638975351566346, 0.8479857931535104, 0.8536958341854726, 0.851045565152181, 0.8344035698162999, 0.8422778831320854, 0.617906294658936, 0.6187346269946181, 0.6166186085285487, 0.6306424166377103, 0.5915872365507286, 0.6736483222665282, 0.6599668187524746, 0.7161521551863772, 0.4983607210389771, 0.6365963020280486, 0.13334465045491362, 0.5694922826252254, 0.6893278249920083, 0.6436645758043962, 0.709041544922593, 0.5914450712013934, 0.6925366608284276, 0.6208554807322706, 0.5618206511645578, 0.539787362749427, 0.579998042521993, 0.6414051794213977, 0.6258647395170122, 0.6039449322433281, 0.5868491993106137, 0.6043605978300832, 0.6140735590656365, 0.7082181098035953, 0.6742068712900071, 0.7261440353953779, 0.678157643482415, 0.7257389854451097, 0.6842643914087194, 0.7158317960577327, 0.7014184372536396, 0.727244171275925, 0.15420536609439495, 0.14003534803293682, 0.12156790534373663, 0.49283704239836756, 0.17398191794188822, 0.2895817273956386, 0.36158150771209463, 0.17940541144328326, 0.3596131879292358, 0.48808368107759126, 0.48824056701805774, 0.4917825671759847, 0.49888872105612936, 0.5280660970895855, 0.5142324031252581, 0.4730587345819224, 0.49013821237335564, 0.49319829287107886, 0.7925354769385945, 0.7849446144144843, 0.815975454096101, 0.8040216423136965, 0.7873769242801854, 0.8066240235352335, 0.7812917279798133, 0.800340920588481, 0.7920125694883184, 0.14704738833658937, 0.11199449380281024, 0.12603532834193187, 0.11421750575051393, 0.10819534622208071, 0.14306415073102885, 0.14209748586892001, 0.15313612659348053, 0.5237075486532581, 0.14520709423467504, 0.12781558837313656, 0.5880509335954011, 0.16871571171620037, 0.3164831310947729, 0.16477431941759502, 0.18454353322780748, 0.1520693973223438, 0.2780773853623657, 0.4686183114285818, 0.46437095147039664, 0.5760369374989216, 0.5173270711683389, 0.5512948059647649, 0.5223003230754387, 0.6194768768574832, 0.4899522926965809, 0.55032645770405, 0.42715803192596336, 0.49291027180179625, 0.2574154017981305, 0.4355308295109951, 0.21090895212825145, 0.4123568774247679, 0.4690500471975946, 0.48568758313972216, 0.5385336624469726, 0.21205934936648252, 0.19536515966022694, 0.21268981928873332, 0.19355682911783156, 0.20143251500547033, 0.21615514973299832, 0.19492962218658727, 0.20917985271031347, 0.20616072336482516, 0.22669337220470176, 0.23550955980300092, 0.203512738456755, 0.6840168339362255, 0.21144095299410215, 0.2158852637235943, 0.21882212150157232, 0.23950323058823053, 0.2044985622488481, 0.9070756173123169, 0.18469363097518643, 0.8257091982061482, 0.8866177068013069, 0.19542096565433753, 0.8528714621954304, 0.8163525292558133, 0.1889426761784353, 0.8761115127883501, 0.8657535246825446, 0.21032509960246193, 0.8720821759727326, 0.20520091737481405, 0.16650891306976134, 0.20337693802967882, 0.20775482723607863, 0.21102709006811804, 0.86968188964955, 0.19345187857643342, 0.18754711805938018, 0.21370792079553635, 0.16922400590455033, 0.18072749068763516, 0.1891160829019718, 0.18828037951497167, 0.1877603110712438, 0.20821717000737827, 0.10238870230810371, 0.0846191384557724, 0.07982894149875086, 0.07725607365763898, 0.08184268058111543, 0.08148754387881108, 0.08818642295908374, 0.07310438354281501, 0.08777138677675356]}, "mutation_prompt": null}
{"id": "613e0541-4f96-4c57-af90-d32236132247", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 44, "fitness": 0.5154414635194596, "feedback": "The algorithm AdaptiveQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.30.", "error": "", "parent_id": "f409b73c-9ffc-44a5-9426-bda0d11a3b98", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "47ab2286-fb2f-41fd-a07e-bbdf98d690a9", "solution": "import numpy as np\n\nclass MultiStrategyQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_current_to_rand_1\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.2\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_rand_1(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (a - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "MultiStrategyQuantumInspiredDE", "description": "Multi-Strategy Quantum-Inspired Differential Evolution dynamically adjusts strategy usage based on performance to improve search efficiency.", "configspace": "", "generation": 45, "fitness": 0.5130012492868892, "feedback": "The algorithm MultiStrategyQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8542886583321092, 0.8628205215086784, 0.8721573009824053, 0.8841602180832531, 0.8724647305752016, 0.8946361783388299, 0.8734278222648152, 0.8630287008793832, 0.8800585394631527, 0.7525750088184218, 0.7413113050434859, 0.7378281733947112, 0.7433650694967853, 0.7609944199631443, 0.7577393699284096, 0.7386438623269972, 0.7537426293944444, 0.7520564995360481, 0.6351561056240825, 0.13823852809560644, 0.6183890168044793, 0.16185389528328165, 0.13944521461753046, 0.2938961745442239, 0.26811255609600626, 0.3885439394187845, 0.4152521770420752, 0.09905790093231515, 0.1620085667701736, 0.13146317358445436, 0.10130857331181997, 0.1250094244855725, 0.14415811395373967, 0.12689612112623727, 0.13796934822871876, 0.1445667676229041, 0.9820831681811311, 0.9769545421900038, 0.9780933083893923, 0.9816604142415547, 0.985756058434339, 0.9749019321981212, 0.9853993996278406, 0.9841462411075061, 0.988368020362943, 0.6795894872658534, 0.6744723013776843, 0.6496901831713908, 0.6421336944285747, 0.6553205679487669, 0.6647290536788084, 0.6663531510208307, 0.6500159834315529, 0.6507956952118499, 0.8722454872060503, 0.8587689565501215, 0.8857981085906945, 0.8717195670366837, 0.8682489975496488, 0.8875886834413231, 0.8779369620921228, 0.8719086017031592, 0.8538418805738569, 0.6364726819835695, 0.534083808000522, 0.5901180178379162, 0.6071184995345963, 0.6680240670036603, 0.7220772899810128, 0.7074814834403969, 0.5965944171635362, 0.6115203413939189, 0.686665988354054, 0.6856346131041933, 0.6817967549312247, 0.6242913682922684, 0.7503763986097142, 0.6713318671350144, 0.13034484159777437, 0.6896038028129465, 0.5869855078516703, 0.6492770224695101, 0.6321311810049265, 0.6441532360816236, 0.6858307833529464, 0.4900934558532336, 0.628530974462456, 0.6397640787969838, 0.6206029676478066, 0.6676174502208743, 0.7446021818960138, 0.732585737206867, 0.7471873191548666, 0.7250588007024523, 0.7181658826168477, 0.6977454636148535, 0.7490471295554945, 0.7324602642577103, 0.7638431043408888, 0.2390128985894745, 0.5104279362740436, 0.29367003222305554, 0.43741941669757767, 0.20688046733062615, 0.6088134578129272, 0.3663339930117482, 0.21198688449098801, 0.15421722893473166, 0.5685594380629189, 0.5753223098145385, 0.5488888396059342, 0.5464801346256092, 0.558857619852451, 0.5706531221270348, 0.5614134295404845, 0.5515476374336921, 0.538609581794603, 0.8157318556208596, 0.8218853456263665, 0.8234263527126839, 0.8073054097293384, 0.8150590464604226, 0.8131646579336501, 0.8200800351106664, 0.8256524350593922, 0.8256233553831349, 0.13030675450017748, 0.11490375739301284, 0.09230163295022953, 0.13118922723580217, 0.12270771919404122, 0.1265012473084587, 0.12870914811155942, 0.14122295009894625, 0.09549953320498006, 0.14052267334623325, 0.33053099021174825, 0.17853943038778164, 0.2036145716049732, 0.25145618972134465, 0.14360731683738248, 0.2420802529174011, 0.2349995327811666, 0.15227513334545106, 0.634169625205763, 0.5734843813097827, 0.5434511888994018, 0.6458723272606649, 0.5831001737655139, 0.5863560251400194, 0.6270089814489994, 0.5959893084157839, 0.6062608088950814, 0.4607714592419102, 0.42366801685222344, 0.5501824586812649, 0.5378640251311404, 0.4738734122260655, 0.5276627925150343, 0.5525197622841513, 0.4883041010085588, 0.560101659559622, 0.2083796005785321, 0.19539230134264263, 0.22690413976706292, 0.19196241905886413, 0.19045136884270364, 0.19728781134470053, 0.19955409553089332, 0.19274021223634752, 0.21240432465271253, 0.3984121710931934, 0.21488207557459604, 0.20296960971481226, 0.23798721628819963, 0.2160804136978426, 0.23091746819303627, 0.5504725831755322, 0.20788860748342186, 0.2434251469073927, 0.1693577106232489, 0.8458848970980314, 0.15351847062741963, 0.8811948858080524, 0.8688738563990951, 0.84675895491014, 0.1411513122905601, 0.17757299555050887, 0.880631258065565, 0.8840018149215179, 0.21129361742105168, 0.8818979929433992, 0.8811900179507973, 0.8839251686710292, 0.15441601381740344, 0.21200900788358168, 0.8469437450379884, 0.8751950651877473, 0.1817264642378379, 0.18638926980614567, 0.18709081064819155, 0.17696754300229167, 0.14985861255159505, 0.18798245234782385, 0.18748708324138208, 0.18943779043956466, 0.19207983148262697, 0.08191627378365707, 0.08216864216688902, 0.10229814719245856, 0.09000068268960115, 0.08340909903890426, 0.09177061334177616, 0.08812388883472722, 0.08820422700244712, 0.10443473747145449]}, "mutation_prompt": null}
{"id": "09bb8950-3eb1-457c-90be-d222b2656cfa", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "d0438cfb-5e7b-474d-9b3e-aad886dc1855", "solution": "import numpy as np\n\nclass QuantumAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 15)  # Increased to enhance search space exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Adjusted to provide more variety\n        self.crossover_rate = 0.85  # Slightly lowered crossover rate for diversity\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_current_to_rand_1_bin  # Added new strategy for exploration\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.3  # Adjusted learning rate\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9  # Adjusted penalty rate\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n    \n    def de_current_to_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (a - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumAdaptiveDifferentialEvolution", "description": "Quantum Adaptive Differential Evolution enhances convergence by incorporating adaptive strategy selection with quantum-inspired perturbations and chaos mapping.", "configspace": "", "generation": 47, "fitness": 0.46570158667903466, "feedback": "The algorithm QuantumAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8459807000525879, 0.8432482247031354, 0.8473070985403721, 0.8635876984191195, 0.8580693265241893, 0.8627565599251728, 0.8442007820136624, 0.8339082643583959, 0.8477638241449672, 0.7126779815441308, 0.6938005282074543, 0.7115359555399359, 0.7128823170124694, 0.7114400777762664, 0.7197008454839036, 0.7005396685586629, 0.7054039736011484, 0.6928294262633432, 0.15394162766834074, 0.13348997794381212, 0.5584625048888673, 0.447938458256699, 0.15672588588258984, 0.15518765902682752, 0.1422189980742209, 0.16676100298543173, 0.14507808775844444, 0.14023600963503757, 0.13275874166515134, 0.12726169152257427, 0.09545644225936545, 0.12310274353328365, 0.15967078605268015, 0.1411531735566316, 0.15270190533314, 0.13446058268880567, 0.9793297081348188, 0.9797805289709133, 0.9723972657001996, 0.9673818355946988, 0.9714974807789435, 0.9845645793312138, 0.9799549281176808, 0.9706731243598313, 0.9778352459021121, 0.5650840956759555, 0.5717454420077801, 0.5816318745385368, 0.5741228155963181, 0.5606569424022674, 0.6225837280577693, 0.5928817358232483, 0.5829042937615858, 0.5871172246509141, 0.8123393336239568, 0.8364073402642809, 0.8305649094330051, 0.21043781351957302, 0.8357351362141983, 0.8509289090865144, 0.8464668232640361, 0.8351957034708252, 0.8530011160417647, 0.12695090692444888, 0.6226307721275389, 0.616826179744909, 0.36655705515866444, 0.5122330748634043, 0.3884634859024777, 0.5772761190023252, 0.6934679320504715, 0.5448683846155662, 0.5834209367335573, 0.5039489086354241, 0.6511232829702307, 0.5814956480562543, 0.4472572686935957, 0.6165137013565494, 0.621244539992969, 0.486165781582769, 0.5132824273366381, 0.457601647240214, 0.46553048523984886, 0.5496453013149885, 0.44747342814385427, 0.5606341645823161, 0.49349253302120266, 0.5505234437841686, 0.5128072143426, 0.5597021536969551, 0.6755518934941334, 0.6253283574519297, 0.6624622920172152, 0.6652484406324668, 0.6303485129604693, 0.6181009231606847, 0.6671925036988711, 0.6682882911809906, 0.6432532056535696, 0.2554636466626047, 0.10046794998804887, 0.35239857725955415, 0.307432068307544, 0.35402749996938365, 0.21918086519037439, 0.14486281623148134, 0.37132232735916637, 0.2620541606878394, 0.4220760778308167, 0.42305793464133823, 0.4439318602644111, 0.3986097690706455, 0.4354017600597021, 0.45145636971341585, 0.4489813883814504, 0.42901748425460273, 0.4169332348006406, 0.7864355425515462, 0.7690348198291875, 0.7925955135323124, 0.7842203475908858, 0.7689145522180263, 0.7760198822346627, 0.795223506215714, 0.7708161507076892, 0.7609069321261318, 0.1029863820372966, 0.1187419621644904, 0.1073198312338074, 0.12202594078681617, 0.1145263249351276, 0.10346075992295989, 0.12876908662197106, 0.11990716982039962, 0.11637201323393509, 0.13996838503533704, 0.1743560987470577, 0.1505088403003314, 0.22908244906464192, 0.48961305642785424, 0.4128488049675887, 0.17296517930627997, 0.35486443005864865, 0.17966615268485964, 0.5694800130692643, 0.5381952491831081, 0.543839277326638, 0.5501650052282732, 0.5289215572615822, 0.5552435649543316, 0.5515702670954795, 0.5395853752523765, 0.5077972104308031, 0.3879121663268157, 0.3997640346728776, 0.4420892994565384, 0.28469292351358466, 0.365239915735618, 0.41250657021684245, 0.45072287526215904, 0.4894949218713093, 0.43421792237450874, 0.2033817479875415, 0.2020506828434102, 0.19323116475543833, 0.185354411053552, 0.19264573680370933, 0.20557154296922087, 0.20458790057888887, 0.20143167640002646, 0.20817619563285827, 0.2167037578616009, 0.2313693808721038, 0.2116335700250952, 0.23122987879189427, 0.6033587978050434, 0.21177411289008508, 0.684247766862045, 0.2398503937844415, 0.6954865786605792, 0.881655936788331, 0.18206094930629413, 0.8266587938534318, 0.19561095576074095, 0.19889730396364103, 0.1738392114909173, 0.14268738320272, 0.16214094068899354, 0.8561453112087158, 0.8469045219939706, 0.20868950555197385, 0.7753053005915679, 0.8435196250715562, 0.20371241378547644, 0.8166840281460016, 0.7810556553675574, 0.7936432187662021, 0.8326094510634403, 0.19008164462831878, 0.199674469776551, 0.194884886258615, 0.1772354202183667, 0.19590364928227777, 0.19529927993737828, 0.18983685999160338, 0.18043518812584702, 0.1803292643829807, 0.08802935366113196, 0.08665436541063865, 0.09256723215566631, 0.08400237572681091, 0.0932342341369986, 0.08280501456722378, 0.0862518763281076, 0.08432605774947899, 0.10145102980571097]}, "mutation_prompt": null}
{"id": "bb2848be-388b-401f-9725-ae7fff1e3fec", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9, 1.2]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_exp,\n            self.de_best_1_exp,\n            self.de_rand_to_best_1_exp\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.strategy_adaptation_rate = 0.2\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += self.strategy_adaptation_rate\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= (1 - self.strategy_adaptation_rate)\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_exp(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.exponential_crossover(population[idx], mutant)\n\n    def de_best_1_exp(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.exponential_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_exp(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.exponential_crossover(population[idx], mutant)\n\n    def exponential_crossover(self, target, mutant):\n        trial = np.copy(target)\n        jrand = np.random.randint(self.dim)\n        L = 0\n        while (np.random.rand() < self.crossover_rate) and (L < self.dim):\n            trial[(jrand + L) % self.dim] = mutant[(jrand + L) % self.dim]\n            L += 1\n        return trial", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Selection leverages strategy adaptation with quantum-inspired crossover to enhance convergence.", "configspace": "", "generation": 48, "fitness": 0.41446293837933407, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.25.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.7779890909581739, 0.7900680951010418, 0.8005260538689964, 0.7902289957079798, 0.8119005909860347, 0.7692994793311491, 0.7871670656497824, 0.7812381949556857, 0.783765259688452, 0.6118863357941722, 0.6269093873232656, 0.5813494809884335, 0.5840738253742946, 0.591029561495354, 0.5814035341954229, 0.5901958729839403, 0.6070355592160683, 0.5938295323306915, 0.2299299977747229, 0.2211711385494084, 0.12361188866180806, 0.3725277944720977, 0.45761832303521566, 0.25139390975368603, 0.13803902762337106, 0.27483872516805374, 0.16498124415726179, 0.1741080767591502, 0.19071985566033334, 0.13866161571800895, 0.12864521424703745, 0.1469699096573136, 0.13404833344605394, 0.12142006017114493, 0.19153668487904685, 0.12695573365762136, 0.980053754131597, 0.9804686130104858, 0.9823970851541088, 0.9715937835233063, 0.9859912334530034, 0.9776346089733343, 0.9781692342833161, 0.9772453576695028, 0.9849669299802563, 0.40771091996240916, 0.42229375240412903, 0.3514701769526922, 0.41180371069199684, 0.3924096808786599, 0.41212177747325796, 0.38827159717633286, 0.3679079673323551, 0.4180684882161728, 0.6775708162212697, 0.7288064788961999, 0.7305457732296892, 0.21237669830283734, 0.7669873824424667, 0.7787157798105075, 0.7628444482070548, 0.7406832611448319, 0.7452409002502935, 0.4571129712240054, 0.43841525487362076, 0.4966544537287253, 0.47830579115807104, 0.4232905078547258, 0.12584021630706643, 0.403741430152015, 0.566066699170829, 0.49442384622776203, 0.5422812114218504, 0.42794724307972554, 0.45166212255830473, 0.4350641341784126, 0.4672302000436711, 0.48982549956615173, 0.49706359462125416, 0.48359955416817224, 0.48648684396402897, 0.4141858362544626, 0.3630807765799884, 0.3927989295739387, 0.11824656378266396, 0.36836829073510124, 0.40970316427149955, 0.3283250763304413, 0.39386172007422926, 0.4055322889936914, 0.5633860611186662, 0.5055419920247195, 0.5304144087631184, 0.43666584778358386, 0.5024519077716183, 0.5075035207642047, 0.514630325700479, 0.5146386240547979, 0.5392927947841359, 0.06351046098318569, 0.08533302083522654, 0.11187478498450742, 0.2605869219919137, 0.33103956941614365, 0.3157440416728309, 0.16205978446274982, 0.18611806488623084, 0.21755474939061226, 0.31937668659364327, 0.3242783100682596, 0.3155725652173056, 0.31134622053315575, 0.3613124362256265, 0.3189105227367528, 0.26798633188715737, 0.3328379501498313, 0.3528102854719125, 0.683091283598512, 0.6833303274337377, 0.68973122905175, 0.65989031407023, 0.6656560696576737, 0.7199235854972358, 0.726866754468275, 0.6822751869646627, 0.6926795713271376, 0.10080336354762398, 0.10184280080534736, 0.1351009498249749, 0.4921547831733827, 0.0943909219547342, 0.13077768581095128, 0.11445726539411594, 0.08115104951448016, 0.14461744348628547, 0.14952276521325691, 0.19652606235228864, 0.23240729247507075, 0.19764442475072375, 0.18339478968959333, 0.14635777285683693, 0.19888088928467218, 0.16472249104057923, 0.24252941130191408, 0.4008104958132682, 0.4126299021645363, 0.42455064167467627, 0.39518105408305026, 0.4013383481993592, 0.429912271858489, 0.4412215823943758, 0.4638542711724988, 0.43558622652917234, 0.22545074350744487, 0.30131000945865527, 0.29091212619843165, 0.3165828094157932, 0.34491769162761243, 0.2556310530119399, 0.3300024370271585, 0.3469650811886993, 0.38623857529777383, 0.2099611024255057, 0.19565025119873758, 0.2055863797505576, 0.18392644748180775, 0.16915295543937192, 0.18035404188026838, 0.20235494529082, 0.17413361384069181, 0.21400675732127616, 0.44585374141965295, 0.26313005532809475, 0.4714075338848236, 0.20539456990859384, 0.2090641727402075, 0.38495788855211577, 0.1880473503558192, 0.231474887240935, 0.3204157500746403, 0.8174391581011422, 0.8498973718170484, 0.8036534459201156, 0.7524393128007926, 0.8136590893464503, 0.19525562299480448, 0.7484923761506042, 0.8064038012175136, 0.17053824293666509, 0.7401990231464783, 0.7441649208978864, 0.7894514818662304, 0.20361217525530761, 0.6850336060351134, 0.7522183295435159, 0.6306553710043266, 0.2075750392002127, 0.8184608354765636, 0.18313308519922644, 0.18235268163544194, 0.17590307570439379, 0.18941067014764146, 0.17974003844500153, 0.170600150633203, 0.2088719007150246, 0.21249787547297405, 0.19134524231348649, 0.0824635292500614, 0.07713292369019087, 0.0877688412940375, 0.069114917219402, 0.07877440696145166, 0.07872538506269133, 0.07194738335021289, 0.11705981773424468, 0.0759932418146807]}, "mutation_prompt": null}
{"id": "e393eadc-7cbe-4bca-b992-4b93cebad7ea", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "e11606bf-5a3f-46c5-90df-5f57828608de", "solution": "import numpy as np\n\nclass QuantumAdaptiveDEWithLevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_leap_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_leap_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        leap = self.levy_flight()\n        mutant = population[idx] + leap * (best - population[idx]) + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial\n\n    def levy_flight(self, beta=1.5):\n        sigma = (np.gamma(1 + beta) * np.sin(np.pi * beta / 2) / \n                 (np.gamma((1 + beta) / 2) * beta * 2 ** ((beta - 1) / 2))) ** (1 / beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v) ** (1 / beta)\n        return step", "name": "QuantumAdaptiveDEWithLevy", "description": "Quantum Adaptive DE with Levy Flights enhances Differential Evolution by incorporating Levy flight-based exploration for improved diversity and convergence.", "configspace": "", "generation": 50, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"module 'numpy' has no attribute 'gamma'\").", "error": "AttributeError(\"module 'numpy' has no attribute 'gamma'\")", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {}, "mutation_prompt": null}
{"id": "0368e032-0a54-4907-b68e-3d4587a7b53f", "solution": "import numpy as np\n\nclass QuantumDifferentialEvolutionWithAdaptiveMemory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.2]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.memory_factor = 0.3\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        memory = np.zeros(self.population_size)\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6\n                    memory[i] = self.memory_factor * memory[i] + (1 - self.memory_factor) * trial_fitness\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.65\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumDifferentialEvolutionWithAdaptiveMemory", "description": "Quantum Differential Evolution with Adaptive Memory utilizes quantum-inspired mutation and an adaptive memory strategy to fine-tune convergence dynamically.", "configspace": "", "generation": 51, "fitness": 0.48674470808650866, "feedback": "The algorithm QuantumDifferentialEvolutionWithAdaptiveMemory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8736866092409568, 0.8778892818775519, 0.8786993873352378, 0.8791827320622579, 0.8897364609220556, 0.8786784396441141, 0.8752884641142133, 0.8771987692509636, 0.8766867585918845, 0.7580570503995177, 0.7411597702549892, 0.753245002539959, 0.7718901453498959, 0.756727716065619, 0.7593858875897126, 0.7190757816258173, 0.7498063967304136, 0.7631259711177968, 0.1455030405242762, 0.178877688494531, 0.166813192283068, 0.1482655410646434, 0.14486287578397838, 0.12433286178587388, 0.14063534226229735, 0.14346808588897764, 0.12605135106366616, 0.16182271589341257, 0.13717679463877575, 0.1235610500565697, 0.15502448573067995, 0.13346632847309248, 0.11597627193992188, 0.12160768078607309, 0.14233215342961447, 0.13975009887626333, 0.9782317253234502, 0.9681762132302609, 0.9840012397407334, 0.9701593467112191, 0.9841016651816274, 0.9900433156022566, 0.9793215331336302, 0.9848673124779541, 0.9836626265401383, 0.6589334906596043, 0.6332658702378996, 0.6182847397765032, 0.6550652430007942, 0.6396963905731823, 0.6668778225438612, 0.6646605660227889, 0.6420498127890284, 0.6604317227905057, 0.8491316701910382, 0.8756272260851321, 0.8679143159133769, 0.8724817765762076, 0.8716336964523415, 0.8307026445961837, 0.22135241088084678, 0.8841788884954722, 0.8634127767107169, 0.6729807754535533, 0.6245121432118911, 0.6229636968116903, 0.6089629663716956, 0.6525901432388834, 0.6640943543651348, 0.7138624488698985, 0.5599377046267244, 0.6008793433273134, 0.7321104766226749, 0.6319564176118362, 0.5881134763480669, 0.6136964378197434, 0.6325978419382033, 0.6542855744701287, 0.5929981439428917, 0.11979422036492937, 0.5805251455773042, 0.6314299260860172, 0.6127041216324821, 0.5273840333043347, 0.5943070425501698, 0.5953363111416783, 0.4534222214230411, 0.6480429049903453, 0.6419821058422264, 0.6688676642924917, 0.7276299379681891, 0.7048359622013513, 0.6698212537012536, 0.6812486122345023, 0.6817983223150814, 0.6405810665516971, 0.694309213865278, 0.7186813471961815, 0.6794298518034073, 0.41077784281269303, 0.2530864717572253, 0.08780272496456842, 0.5480057224296654, 0.28047421302183373, 0.5127477675816081, 0.4863917640014118, 0.12244407719509565, 0.1249950221496432, 0.5706318731193607, 0.5399445834378169, 0.5529340545852626, 0.4524744546618361, 0.535771004055863, 0.546594942465729, 0.5604423086838835, 0.5449268614789881, 0.5631464279597066, 0.812084400354785, 0.8048273381846466, 0.8112051687651907, 0.7893426753290497, 0.8209143216339745, 0.8149162073887298, 0.8111835577864007, 0.7981280520675245, 0.8052548030065705, 0.14107956558534374, 0.09383615869380368, 0.13990540220072967, 0.13347847221883236, 0.10756832702332864, 0.10428383182250545, 0.10602453804722245, 0.11386047386388942, 0.10206783567824917, 0.18526820286523793, 0.19492140267742586, 0.28211196853159914, 0.35670175514616964, 0.2130544398565959, 0.16620295245667205, 0.25073247138760557, 0.5438788186661805, 0.19124929315472006, 0.660661856589273, 0.5382977989086413, 0.46179172124579104, 0.5932303893175979, 0.22143975659003412, 0.6092318368012659, 0.6563800944679162, 0.611229504712713, 0.564932199285841, 0.37567244658702925, 0.30272746328827127, 0.4335920780490967, 0.44492928903518203, 0.4951803047845297, 0.5417565168091947, 0.49149703750624574, 0.5232327504237902, 0.5056289390541788, 0.21034262476145282, 0.1963687313086092, 0.1902018266627944, 0.18020261985270114, 0.20530050824545354, 0.1911991872813047, 0.1971008885275305, 0.1965070087918872, 0.21355869467995603, 0.2229247885318173, 0.20614234684160704, 0.21838051856588492, 0.7530923978702847, 0.20411646670384143, 0.23531196781374397, 0.217102301049671, 0.23445281600352885, 0.2415026648232773, 0.8532026262229213, 0.9077373579764297, 0.19732549039196312, 0.17141051164774412, 0.1955655608386182, 0.1646808047078594, 0.14212575181995157, 0.8336316565434114, 0.895817397843305, 0.8282158556410558, 0.21027746807202785, 0.8812982191365633, 0.1667435643598908, 0.8729200351060792, 0.8650358764473112, 0.2102135534324887, 0.2079433689515756, 0.8735797649781437, 0.18022948730604438, 0.20364746234529685, 0.191120581000354, 0.1825588735722895, 0.18596486812918855, 0.18464292021056916, 0.17500190161049756, 0.20563446445962708, 0.17983114139980239, 0.08758992449973924, 0.08915366125704949, 0.08328849089018109, 0.07692436640494049, 0.0887529151907791, 0.10313970365009428, 0.08333905029043165, 0.0748559058428735, 0.08457403598393998]}, "mutation_prompt": null}
{"id": "460d2747-d3b7-48b6-b773-a86e2444de68", "solution": "import numpy as np\n\nclass QuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)  # Slightly increased population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Adjusted scaling factors for finer control\n        self.crossover_rate = 0.85  # Adjusted crossover rate for diversified trial vectors\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_current_to_rand_1_bin  # Added a new mutation strategy for diversity\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6  # Increased reward for successful strategies\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8  # Less punishment for better adaptability\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (a - b) + \\\n                 np.random.choice(self.scaling_factors) * (c - population[idx])\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumAdaptiveDE", "description": "Quantum-Adaptive Differential Evolution enhances strategy adaptation with quantum-inspired mutation and local search for rapid convergence.", "configspace": "", "generation": 52, "fitness": 0.48148746674947657, "feedback": "The algorithm QuantumAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.869564514170163, 0.8803096805849974, 0.8825904390805808, 0.8726377451854319, 0.8763196720931556, 0.8733593310297146, 0.8667367556199187, 0.8832906405002375, 0.8813983764550651, 0.7742710638859986, 0.7714883746806304, 0.7451467335334025, 0.7646030641513252, 0.755667293278445, 0.7587974423846411, 0.7617525822898771, 0.7655718461373021, 0.7716697376552024, 0.14205172533833244, 0.16097160329062188, 0.17085808376760525, 0.11404168162597383, 0.13986949637412704, 0.17325394646342773, 0.14609645058859966, 0.13389754502223972, 0.7001303938209973, 0.11020670228568397, 0.1516388526536121, 0.1318896796407395, 0.12559893166047986, 0.12218180114360533, 0.11669815807661399, 0.10985877119053233, 0.13445701747525218, 0.11018579951321739, 0.9782603547150289, 0.9637375911499084, 0.9858755104155872, 0.9801908026004712, 0.9735601440687609, 0.9632593006658524, 0.9762843799551851, 0.9609370435251096, 0.9680258268737295, 0.6487682021268564, 0.6797237229348123, 0.6484160224600486, 0.666057295770496, 0.7158149826654401, 0.6550846333939182, 0.6879869292884413, 0.6734558675090714, 0.6736712809913008, 0.8649327285244602, 0.8966253561323799, 0.8884334795224682, 0.8901656139854004, 0.8923171155261442, 0.885390628948289, 0.23107949778372638, 0.883877437652284, 0.8926344336400316, 0.12993486621218475, 0.6286549471628284, 0.6698846348734109, 0.5359536325983916, 0.577686036875635, 0.5405822668928596, 0.5552445882966263, 0.6502273736943582, 0.66627079202073, 0.5466928546995053, 0.5322089445398671, 0.425996070319291, 0.5750829287126042, 0.5888518826468422, 0.6752031872925641, 0.6229468753117824, 0.557659600948857, 0.5781300682091692, 0.5929048238461458, 0.6013277986755372, 0.6013229191116589, 0.49223369139594964, 0.5477099985986964, 0.5926531374627786, 0.597005253419634, 0.6646260892735851, 0.6507001315736141, 0.7376225567638283, 0.7208131068108518, 0.7076962601813979, 0.7395605898703632, 0.7128849533148929, 0.6816380620571046, 0.7141463700858943, 0.7393562428479041, 0.7378764514873849, 0.11036737504811411, 0.43397037647458514, 0.2915435962939832, 0.3288465851799801, 0.3832869092460469, 0.3585314484563551, 0.23892493814368465, 0.09650714931174176, 0.4088079591916296, 0.5512125450805927, 0.5387453646525335, 0.5358423590121488, 0.5425660803108225, 0.5667964312678251, 0.5232930373637568, 0.49298036729635375, 0.5197523511165619, 0.5597364664518354, 0.8169851433607409, 0.8429680375201607, 0.8162236355812846, 0.8041488446522029, 0.8101690173517214, 0.8047696734970793, 0.8278591961317171, 0.8218201261700757, 0.810586342262218, 0.1122699743885458, 0.1236878549258208, 0.12661282047257372, 0.11149489762608844, 0.15647933089345312, 0.1510496373735234, 0.10274734937396846, 0.10579998720337513, 0.12082447424290765, 0.45516437514591457, 0.5028643654384697, 0.6757506723628373, 0.15261738552346082, 0.4821262884246523, 0.1720771653922435, 0.15503570719551985, 0.2169990264625523, 0.19594311495487104, 0.5420789847166966, 0.6371421131808273, 0.5503689606012727, 0.5151632888585328, 0.5125792132291589, 0.6350188931891425, 0.6671096153669053, 0.6450652745733473, 0.5927220816117429, 0.3584408516175429, 0.4009956709734015, 0.5145893414991469, 0.49351148905753894, 0.4714943256799504, 0.48679468479331733, 0.26893134998255463, 0.5309407970912166, 0.1889690247640795, 0.23743900127321693, 0.22070457458273873, 0.19648334480004492, 0.23975720842833903, 0.1923196760709599, 0.21342202280739098, 0.21287519937249078, 0.2188613738725742, 0.22522028376453196, 0.21903063207747997, 0.23936079102088137, 0.2220493407768619, 0.20433140529539762, 0.1912006453191002, 0.24194692749913638, 0.20190433831700438, 0.2169303338645675, 0.2262582223502122, 0.15719975515155216, 0.1798164963785528, 0.8946259533930117, 0.17588911701469, 0.19897346672751115, 0.13027570851690673, 0.8703641725808258, 0.8622389350432826, 0.20870093939019985, 0.8655046673704249, 0.21083462766405214, 0.1684920604712099, 0.8646017704058534, 0.15445245724715984, 0.1542335165701617, 0.10388440382866826, 0.8034838280634256, 0.8669203908117629, 0.19424131965635716, 0.1955443033988138, 0.19301407029340023, 0.19326815793698537, 0.1949166163775904, 0.18540605992555048, 0.1859835770470517, 0.18186323555347594, 0.18801469858693987, 0.08067814930457806, 0.08218343641009018, 0.09483609297267359, 0.08556940362335386, 0.09544865133059843, 0.07810278361059586, 0.08148842567878978, 0.08458738958692102, 0.08393901030040962]}, "mutation_prompt": null}
{"id": "02fce190-388c-462a-b55c-14f28211ecb1", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(10, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Strategy and Improved Diversity Control.", "configspace": "", "generation": 53, "fitness": 0.4681337247803757, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.898096628184197, 0.902606514541552, 0.9117177897376741, 0.9083314592465708, 0.9106035988670489, 0.900965946501374, 0.8961306261973212, 0.9013243102298272, 0.9049235128995441, 0.8001916970740741, 0.7992372740612688, 0.7753847591978933, 0.7886485908932874, 0.8055049047019316, 0.8112681767445614, 0.7637190728304065, 0.8008469153029686, 0.7482493053343714, 0.167411934437952, 0.18280331349657308, 0.12344291059660573, 0.16366102146507433, 0.17679508283333667, 0.1483176037782572, 0.1553135240698621, 0.14573862997278375, 0.1667413975350719, 0.08969266813348875, 0.14748744438390315, 0.11293158645436174, 0.14507834533800656, 0.13834797324546344, 0.12738449619593084, 0.12215857366283833, 0.17715494305823154, 0.15254499056409554, 0.9779099937535557, 0.9748320409015557, 0.9808740397547052, 0.9709872971760587, 0.9668036147176258, 0.9810548460745697, 0.9782378637126199, 0.9816174799817474, 0.9682354234783999, 0.7680861645715025, 0.7327937470493855, 0.7403977294572648, 0.7582960013179826, 0.7458619861992299, 0.7265709083219656, 0.7634682301096771, 0.7478696485013345, 0.7313769022452115, 0.8963131804641996, 0.22829195863589435, 0.8989259746715369, 0.21119716086753992, 0.8950411848844195, 0.9105700823217677, 0.17406882848494531, 0.8639631231410225, 0.8902779384798746, 0.623211397783066, 0.13124196550773937, 0.13263930173066096, 0.1292768022613454, 0.6249760641672114, 0.5843822072496072, 0.5158198309253034, 0.7049998333670514, 0.6405331130964421, 0.13110024565046374, 0.1319947309089321, 0.6868757750668891, 0.8279794161389022, 0.6480348217606234, 0.6796228034862504, 0.6567000267755417, 0.6957378275346844, 0.7227273710210403, 0.09761697249252432, 0.5460312381294116, 0.6789380774464445, 0.6454244600664174, 0.6653635420330446, 0.6159809906604241, 0.6856360678836324, 0.6784850337005399, 0.5575289536189412, 0.7264467061483162, 0.7334207176931796, 0.7423431340986312, 0.763269570333926, 0.7557179958753872, 0.7826647525477785, 0.7759938456395935, 0.779548267923892, 0.7899004505545988, 0.08364059995868156, 0.17219572714196751, 0.2795258727742015, 0.5251956105878456, 0.15191289093845683, 0.3657251441772259, 0.30868154793033775, 0.13615202282313343, 0.27245785022440017, 0.5870643506622826, 0.5873811677579923, 0.6070910624243344, 0.5588992122165346, 0.6183001583463239, 0.6481648549039674, 0.4109168737219746, 0.4868207675741836, 0.5391249195882124, 0.8648590878091107, 0.8510173410274202, 0.8406219961713557, 0.8492521296288784, 0.8564716683261329, 0.8403417402191095, 0.8632637004355503, 0.8316497193296637, 0.8554383253831199, 0.12282599719456377, 0.13387630785055427, 0.13611603538538986, 0.1177760078097736, 0.13254419705991372, 0.13141718372819666, 0.1160505931203043, 0.12268341929206128, 0.13656093730262908, 0.4420138768527522, 0.7937392976860093, 0.24189115420055218, 0.8078338265750051, 0.2149938810386377, 0.26036613027696087, 0.2604642279563122, 0.16529172451171525, 0.1888606771213408, 0.46011286453847355, 0.5507172419027881, 0.3916435981535734, 0.6234063874632296, 0.6288321727744308, 0.49741757313788526, 0.500121359498182, 0.6210090252341898, 0.569364234137002, 0.3556414277130068, 0.43836285179921775, 0.3255488853267292, 0.4548028028360602, 0.26783444255109823, 0.3440983134791481, 0.46751177331936566, 0.5340641304222046, 0.6368983143353836, 0.19855234222500417, 0.17161304725351345, 0.21520531337676396, 0.19115961449477237, 0.2065795450532375, 0.19809890188046497, 0.2328760663215843, 0.20186792404520337, 0.22065762416723966, 0.20726527532096473, 0.2261582082673005, 0.1951605756645971, 0.19769986859855382, 0.22091108756606048, 0.24977742519611223, 0.24659132863616728, 0.24720969188384956, 0.19597059564899044, 0.18595620886637276, 0.1649665008917649, 0.15349834349186953, 0.1730369131247993, 0.9061340016745669, 0.19897144095600994, 0.1423494008844709, 0.16145321936497836, 0.21091702313356642, 0.9005857881963093, 0.212031417266912, 0.8562164001751217, 0.20754599604124102, 0.8770565498339247, 0.1649553488089216, 0.10465577900646617, 0.2114736644162395, 0.12707165673546006, 0.20994638812918764, 0.1869910653121326, 0.2012792569302464, 0.182060579328728, 0.17730457339733618, 0.1871130401251344, 0.19312939633833193, 0.19043618541205964, 0.18062964244167035, 0.0830297080623843, 0.09047507267861021, 0.09079878000051833, 0.09036231665394967, 0.09222989948690496, 0.08985988351652541, 0.10233714581351472, 0.09508411455074961, 0.08388301792500696]}, "mutation_prompt": null}
{"id": "77b972eb-992f-44a7-b123-09abe4ef49b8", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.archive = []\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                    self.archive.append(population[i])\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            if len(self.archive) > self.population_size:\n                self.archive = self.archive[-self.population_size:]\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution integrates adaptive strategy selection with an archive to avoid stagnation and enhance exploration.", "configspace": "", "generation": 54, "fitness": 0.5154414635194596, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.30.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "9edcbc9a-2a9c-4ad2-8c5c-9a8e8f835870", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 14)  # Increased population size for more exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Adjusted scaling factors\n        self.crossover_rate = 0.8  # Slightly reduced crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_current_to_best_1_bin  # Added new mutation strategy\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6  # Adjusted weight increase\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.65  # Adjusted weight decrease\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_best_1_bin(self, population, idx, best):  # New mutation strategy\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum-Enhanced Adaptive Differential Evolution uses quantum-inspired strategies and enhanced mutation dynamics to efficiently explore and exploit the search space.", "configspace": "", "generation": 55, "fitness": 0.4457329783179889, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.874930098652704, 0.8670610955929825, 0.8588994062597217, 0.8672347170273071, 0.8665274596005675, 0.8643056523006492, 0.8648382875238285, 0.8639776934489433, 0.859496712563688, 0.73461622683456, 0.670721898646697, 0.7292689549688292, 0.7308606613961208, 0.7349571633849526, 0.7214851406738634, 0.5488401561840106, 0.7250090826331308, 0.7231906839434903, 0.11336406856079717, 0.428999298174633, 0.17003285575338634, 0.591634132477438, 0.47057388168592773, 0.16408394700023254, 0.16225176853820633, 0.1229015260665185, 0.5500180631614735, 0.13664286518893953, 0.14646206268023454, 0.14286785230799615, 0.10754199456604308, 0.1310297616539554, 0.14279615189552364, 0.14419325263313076, 0.15208996893784754, 0.10872830713955517, 0.9707421924826799, 0.9792283709301206, 0.9797507211562705, 0.9647959616984917, 0.9722244974341622, 0.9386462834296341, 0.9710228833893256, 0.981155061628584, 0.9600261136899345, 0.6731364282627328, 0.6387422691644729, 0.5997098991544141, 0.6769513101268801, 0.6568317730553512, 0.6622340237304982, 0.6613764495691492, 0.6621417222555063, 0.6660240352613915, 0.8726716827804045, 0.8656248933401592, 0.7886371096366841, 0.8882535441733781, 0.8687966729925352, 0.2762922779106245, 0.8570442862575394, 0.8481689354491608, 0.865100755476567, 0.11696655961712477, 0.1326203222145398, 0.123223052497623, 0.35566943459975153, 0.45853630385059163, 0.12800059657468443, 0.5789254620702355, 0.3726534878451382, 0.7118418858912614, 0.5188303928695717, 0.6031248714997304, 0.5702464186460203, 0.7153585029896646, 0.5841901097706124, 0.3325272868279535, 0.5964498114420383, 0.643759371191901, 0.6174963881915569, 0.5494220869445512, 0.4866836498424475, 0.5362507212816741, 0.5241808307726264, 0.3005272928165865, 0.5422989314274509, 0.555932165028644, 0.5075030246546015, 0.5227272415066047, 0.6194516781452244, 0.635201317258082, 0.6807375836175362, 0.6206642345664182, 0.6265953771987596, 0.6110303509750282, 0.6483899871547787, 0.6455841154540128, 0.6212396197127183, 0.15298635749740008, 0.13740171485686792, 0.38534782257039024, 0.3748486420306749, 0.26816131510638985, 0.251750035518182, 0.20299987733751046, 0.21516329188190053, 0.21048732532552072, 0.4243156287707851, 0.36329364517045337, 0.3921146593669098, 0.42344163818630964, 0.468758176514646, 0.4392055887206492, 0.3457017612094472, 0.42682977358551344, 0.4200877333607854, 0.7810151760828827, 0.7643079096412257, 0.7892249468179753, 0.767760339903252, 0.7807609128462929, 0.7789758258886605, 0.7632667716292031, 0.7608215344643254, 0.7876547975576949, 0.12475474005254106, 0.10115284901936006, 0.11304028667828858, 0.10320981773114657, 0.14606777325922848, 0.15587468851683628, 0.12444885408912565, 0.1448862266108003, 0.10644716832087264, 0.14324373446178884, 0.1728572927313804, 0.21232707216051072, 0.28637925328045244, 0.2294742204256055, 0.1320520298903768, 0.3395422800604895, 0.15239797287558654, 0.15108063120384774, 0.6138525692510315, 0.552621829224428, 0.35861320555456677, 0.4776150722263829, 0.6409393460812047, 0.35254938927808965, 0.49871032078609645, 0.6001407490701725, 0.6283028760402245, 0.30177876087341615, 0.3027276264802208, 0.45018640850318103, 0.5102380100503145, 0.33972843700954447, 0.4623186567196209, 0.36883859962032306, 0.5191371914595784, 0.20802474921046865, 0.21082560992654364, 0.19647182295859422, 0.23193775663016014, 0.23276415232506809, 0.20251249951641281, 0.21537153252408647, 0.2160164648304489, 0.19079534227051742, 0.21351454880878118, 0.1961146010032977, 0.20323482626520362, 0.21655984821223206, 0.24483900556824, 0.23964799559019034, 0.19775074418222582, 0.23540355822401093, 0.20916825058495225, 0.23930636077217637, 0.12964335218232592, 0.1773642293593357, 0.1866516702728943, 0.19489248906600565, 0.19958069352727037, 0.1210649486866412, 0.17458458310948666, 0.1835493070166676, 0.8673420850868974, 0.8714229171611643, 0.857058591377872, 0.7917729905485027, 0.2096787384757849, 0.8167030286875654, 0.8260579723818533, 0.1041108557664262, 0.12433687494370183, 0.8477121454696314, 0.1801931900939262, 0.17773608945316932, 0.17896967508461892, 0.19071030652891974, 0.1921507337380085, 0.18581907538707776, 0.18522969838175862, 0.18973755028450012, 0.18595966962753174, 0.09458935402628288, 0.08578654197062174, 0.09081494669259205, 0.0945641768212494, 0.09086764638359601, 0.08750239589634312, 0.08804053348070628, 0.07990771868134494, 0.08913425874894909]}, "mutation_prompt": null}
{"id": "b973c9d6-fc4b-4344-9818-c6d946e6b4aa", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 8)  # Slightly reduced population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Adjusted scaling factors\n        self.crossover_rate = 0.85  # Modified crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_current_to_best_1_bin  # Changed strategy for diversity\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4  # Adjusted weight increment\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8  # Adjusted weight decrement\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum-Enhanced Adaptive DE uses probabilistic mutation strategies with reinforced learning to optimize convergence efficiency.", "configspace": "", "generation": 56, "fitness": 0.49925762185870076, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.32.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.9214437651986085, 0.9196635018624514, 0.9242604686171167, 0.9295673957231683, 0.9162178501361038, 0.91252772755036, 0.9283663483040421, 0.9218842688430413, 0.9196959947095809, 0.7764761235881276, 0.7961525700499066, 0.848850667532953, 0.8485230470462014, 0.7760537861853627, 0.8223088325636125, 0.8402066320153853, 0.8263097054071601, 0.8186650972853007, 0.1579480020792795, 0.13260086127907234, 0.15908179824587787, 0.17154402909383848, 0.1197801285896769, 0.15951272999362887, 0.15444252675105996, 0.13467816748595307, 0.1576845406056906, 0.09205167300572104, 0.1541287227003062, 0.11931623306419514, 0.09584739702791045, 0.11045322957340797, 0.1098214921114321, 0.14744601893682097, 0.09998888288468055, 0.14130946707015324, 0.9847032902476585, 0.9812595912738256, 0.9851375201746195, 0.9665551488065871, 0.9865521158674104, 0.9845625833444774, 0.9800674717649757, 0.9837615760626313, 0.9842128765383447, 0.7865345156593391, 0.7988896910654708, 0.8164368287278354, 0.7856670335949143, 0.8142858163226557, 0.8062664686355496, 0.7971388318012789, 0.8011365049387491, 0.808635816993355, 0.9225778463225285, 0.900720258585672, 0.2287248590220302, 0.9191082371938363, 0.9179168128525199, 0.9371121415705752, 0.9191865203562385, 0.8955722547023391, 0.8798979421003447, 0.7207240107861163, 0.13417775769762064, 0.738540982727284, 0.13119270848636133, 0.6994688905544838, 0.5848605582706254, 0.650780525978037, 0.6106798154134525, 0.7556316487740358, 0.5875240649610299, 0.6230426332944864, 0.13437633982135266, 0.6350800506132581, 0.6540741779150434, 0.6452127761754659, 0.13317396910392365, 0.5806041697809627, 0.13351302392343145, 0.717564609520407, 0.6282163483861823, 0.7054364358061552, 0.779090578772641, 0.5491726853473804, 0.4219376785578446, 0.17713323507003664, 0.7156967971643192, 0.5437407028831563, 0.7866100173960722, 0.7970811447771756, 0.7964699067291158, 0.8294121659334, 0.7428103223918772, 0.4074506267279271, 0.7406569704769645, 0.8116424908582579, 0.7797022893165986, 0.16357574772242955, 0.5407286385462352, 0.23116286378353457, 0.40586871178368844, 0.1478218763584619, 0.6238217895774272, 0.13845718711822208, 0.41447925147646725, 0.18857945528683717, 0.4070159598622709, 0.6039756602173854, 0.691395784600316, 0.6658232277732645, 0.697660184366671, 0.5039227631693755, 0.5948725476243826, 0.3743094224841681, 0.47164349287853824, 0.8810097642897382, 0.8872361112707157, 0.882634584901395, 0.8632551341102914, 0.8409215240362504, 0.8670351039784496, 0.841136653005976, 0.8905452224971215, 0.7707771007331553, 0.1101347401654752, 0.18684174520024088, 0.11802851022322647, 0.14408668632479715, 0.1252368399273457, 0.7434435517003474, 0.12734332509887047, 0.12968144668902482, 0.12218729549034835, 0.28688786060524185, 0.15521234171537768, 0.21623609732739302, 0.2449138839769257, 0.21451170855886736, 0.17763360342421952, 0.39563698239501865, 0.18339846284435013, 0.2746163055205073, 0.5771276233584915, 0.37742264979167706, 0.4293469165243582, 0.48477526846196095, 0.619003087019194, 0.5262660012694362, 0.5375504809187287, 0.6227784061871218, 0.6498467370874571, 0.2642697217747252, 0.24992327581535356, 0.263540673041766, 0.3945605643926492, 0.5129666213429835, 0.44138724317050726, 0.2872673316148643, 0.3222983220876403, 0.6112857762848695, 0.19873948698351174, 0.2268785599197667, 0.20817051114877305, 0.21674247566737026, 0.20589950691233294, 0.21621394930003046, 0.2324558440248633, 0.20335149178660317, 0.22468951124239023, 0.20560176787864992, 0.19814588578318204, 0.24679395452070008, 0.8644452643318943, 0.2134352288619088, 0.20959847208483728, 0.20015363978358225, 0.20799505451067435, 0.208144839274102, 0.9418431208304211, 0.18715129527269547, 0.15389365029186064, 0.9413837927536484, 0.8874302434457192, 0.2000080447103233, 0.1423347659412506, 0.16914754889427464, 0.1705730817334028, 0.921431925388138, 0.8567653463999716, 0.9186601773320175, 0.9167937390051817, 0.9244163047425112, 0.8915508015138909, 0.15693111298161222, 0.10500737341813116, 0.9118788651017525, 0.2001891150691324, 0.1860580872100066, 0.19926408672303653, 0.19158568938685783, 0.19477291147596398, 0.1849569231877909, 0.19324020698233624, 0.19030010631789196, 0.18528172330170223, 0.09134555624073559, 0.0824529701841944, 0.08008928926044323, 0.08185784472467861, 0.10137553292775314, 0.08834289488546843, 0.08697494244696702, 0.08218279103535531, 0.0974918175275008]}, "mutation_prompt": null}
{"id": "581b18fe-3545-4eca-89f4-d0ae5d1c0f73", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "aba8da8c-eea4-4de5-91b4-68ce2d63e0fd", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(6, dim * 12)  # Slightly larger population\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Adjusted scaling factors\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6  # Increased reward\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.6  # Increased penalty\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum-Enhanced Adaptive Differential Evolution leverages a quantum-inspired selection mechanism and adaptive parameter tuning to enhance global search efficiency.", "configspace": "", "generation": 58, "fitness": 0.4675109190888766, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.891940178802076, 0.8907952543190492, 0.8867570010221971, 0.8990487169128897, 0.8866895980086549, 0.8915147654566637, 0.8894801730610782, 0.894211613889302, 0.8946978457026004, 0.7854344413857626, 0.786553474834328, 0.7568862772570064, 0.7747687667677402, 0.7878250468187409, 0.7808550932550304, 0.8079507563459648, 0.8092357210707254, 0.7612246013736793, 0.17913399699860566, 0.14965516361178055, 0.15507990847773745, 0.11556772285921557, 0.545632802245782, 0.15476082521657786, 0.13671193087994837, 0.15534920537719266, 0.15226300195241016, 0.14997239133929474, 0.12341017624803985, 0.13814388494314078, 0.09795476700779104, 0.1064136627906912, 0.1298634939333082, 0.14326204969900014, 0.14951779613037974, 0.13118519308982035, 0.9780567465135898, 0.9882252744449613, 0.9770137674303764, 0.9753731831891853, 0.9621091858500915, 0.9726242184206344, 0.9718589394541972, 0.9827070900507474, 0.9793896461334155, 0.7019312363269159, 0.7283784306422119, 0.7292684402252638, 0.7135093618371424, 0.699228662005684, 0.7180399015839987, 0.7263946096398559, 0.7305082614790948, 0.7261481322628227, 0.8770940366756401, 0.22696640511310184, 0.22615662609121479, 0.8373304876166608, 0.8586628159041885, 0.8391835778525606, 0.8423319757259908, 0.8119524948290944, 0.2345659369638814, 0.6360801925343675, 0.6342877953172898, 0.5651824846357756, 0.5701065912249279, 0.5887617480107245, 0.5375639748077454, 0.4788808865978089, 0.5706979651705768, 0.622167941071726, 0.7465363144561207, 0.49844094632367053, 0.6303531655747073, 0.6439167620012315, 0.6018871693693476, 0.1354272396965538, 0.6381727492704303, 0.6450037528446946, 0.5978584549252859, 0.5499544429601413, 0.5617916420988844, 0.5680041538358949, 0.04313137420590918, 0.5939237153618339, 0.5942599571762689, 0.6494139896867392, 0.6949520336550772, 0.643071240475724, 0.7423443710358351, 0.7141034951368928, 0.7407754836617837, 0.7445184188312102, 0.6893190096642231, 0.688776107868641, 0.7449215836517074, 0.762454679684897, 0.7712389169106151, 0.10079766955442082, 0.13657119656274097, 0.1260243884300597, 0.22154944286990963, 0.19749221183573573, 0.2914812432110986, 0.14958028715894944, 0.09973558033259955, 0.3173637030193166, 0.5796204008978003, 0.45372556633812267, 0.5454200159413336, 0.46791884684626606, 0.5530471034533069, 0.573903139945142, 0.47493362556983065, 0.5646623487140332, 0.41214050793516976, 0.8339625287375092, 0.8283114741622951, 0.8210279548725125, 0.820416695542348, 0.8169590946960068, 0.8171071593164787, 0.8322175020050849, 0.8226012607564221, 0.8240731401297696, 0.12687690109030014, 0.10163458288724236, 0.16377804621723413, 0.13615574641736272, 0.14900503623783623, 0.138684653212501, 0.13983527970666798, 0.16745672575636272, 0.12507881809345778, 0.18999677846313323, 0.1319647244477401, 0.14933421567032712, 0.28684052398211, 0.21566776425637135, 0.27481340254450726, 0.3201841334217591, 0.15583318219947528, 0.19076115896206924, 0.3812126193095867, 0.5612559897712499, 0.5512286374467676, 0.29838002869415947, 0.6329983019776548, 0.35178086142166765, 0.5738876666245357, 0.7571806027813406, 0.587018237549257, 0.4856518729687339, 0.38893149825865314, 0.3953096469731199, 0.4447551868415598, 0.5296645381263152, 0.3741064564566038, 0.402375853457975, 0.6624252638152699, 0.4440777050029614, 0.23170188682904969, 0.19206779815896902, 0.19306493344864128, 0.2473063851953079, 0.2009157312868317, 0.19867236484746154, 0.20672725009516613, 0.24495080551772686, 0.2211132517419242, 0.20844539292889785, 0.24647731944335383, 0.20205144053894586, 0.2476994707079896, 0.19581349320856012, 0.19486751626797583, 0.2199879704284976, 0.7876498069477629, 0.20905830241647383, 0.18517243669285732, 0.18781723256699812, 0.9051365960283643, 0.9077713495726655, 0.19937274914105052, 0.1987649734179433, 0.14226815432759377, 0.872593514627765, 0.18653464575758238, 0.8942918147346656, 0.21196391025641081, 0.16813039826955078, 0.8714500720185405, 0.15510445499141734, 0.8343504061544357, 0.2117440247817043, 0.21099721465700827, 0.16579291781935224, 0.17937348949795995, 0.1878365248713525, 0.18244290143817166, 0.18958287033345922, 0.18810601617219092, 0.17984688033480856, 0.20115817451520213, 0.18397769292457955, 0.19377110501833095, 0.0914542066549191, 0.0840799109278767, 0.09618438718596478, 0.08886496834526547, 0.09968947740139156, 0.09080545991916444, 0.09250624005398089, 0.0900013142424515, 0.09302469457470375]}, "mutation_prompt": null}
{"id": "8a47c390-9781-4900-a412-d55d4827f452", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = np.linspace(0.4, 1.2, 5)  # Dynamic scaling factors\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.convergence_factor = np.random.uniform(0.5, 1.0)  # Added stochastic element to convergence monitoring\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n            if np.random.rand() < self.convergence_factor:  # Stochastic convergence check\n                self.crossover_rate = np.random.uniform(0.8, 1.0)  # Adjust crossover rate dynamically\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "EnhancedAdaptiveQuantumInspiredDE", "description": "Enhanced Adaptive Quantum-Inspired DE with dynamic scaling factors and stochastic crossover to improve global exploration and local exploitation.", "configspace": "", "generation": 59, "fitness": 0.46862436463237783, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8698737231376933, 0.8562728749285773, 0.87174156095175, 0.8654530754544971, 0.8557401087594001, 0.8566734703985269, 0.8603205950272905, 0.8725521134321487, 0.852370594269807, 0.6931019778509084, 0.7311388860141355, 0.6479334657184104, 0.7140546161268497, 0.7297928680491061, 0.7574539343452447, 0.751245829475061, 0.7178118966550721, 0.6055072782571722, 0.10476262570045203, 0.10203469925010233, 0.1577777830277861, 0.11960798544259965, 0.161718703887334, 0.15830569348374468, 0.15658593953506006, 0.13923340139086338, 0.12476745175769954, 0.11479425123943343, 0.16770017057950848, 0.12439866516944187, 0.10005788552655848, 0.14357824977688327, 0.13002614232889576, 0.14456412778936045, 0.16051282324437322, 0.11522524665229539, 0.9798332487406494, 0.9735770426117955, 0.9836517481837896, 0.9752160194606802, 0.9837868539064624, 0.983913738033539, 0.9851283771136967, 0.9755996236537999, 0.978891566554456, 0.6455836482965442, 0.6229177376966873, 0.6464079587264937, 0.6426863551090265, 0.6046331439383443, 0.6098501188504954, 0.597726414050552, 0.6526742801475831, 0.6411148287118864, 0.8565117471164129, 0.8771734324487914, 0.8702212591169015, 0.8775486575729634, 0.8716547398191663, 0.8730111621203408, 0.8939755227890717, 0.8583368837223402, 0.8739718883586909, 0.6095355887893266, 0.13086763661499468, 0.5908084236065235, 0.13009533365941028, 0.6957059505833886, 0.6270133368334238, 0.6826973442640254, 0.12585667434544123, 0.5784751721387343, 0.5119592975397673, 0.05346264873314999, 0.6255339954454617, 0.6411126810763297, 0.6884034664549387, 0.7326031394248214, 0.7001348188864956, 0.5684510309586049, 0.6696993858629592, 0.6593711456692117, 0.6381232048277428, 0.616619595625567, 0.6922897230059852, 0.5898337156520779, 0.6256902711858175, 0.6165532824414135, 0.6494306593448929, 0.6280564076326569, 0.718167373841335, 0.7218180463841757, 0.7234312125151394, 0.7589605822176309, 0.7207719301988071, 0.6960329408980193, 0.7760663980463149, 0.7416227975430818, 0.7029599333866878, 0.35159088516525927, 0.39512945955227374, 0.12389054289358759, 0.32435392471124047, 0.4218673539720589, 0.49813873247279594, 0.14473883984289082, 0.19361787840344413, 0.31034051838368504, 0.5326236720761832, 0.5167564618758951, 0.5243192786972711, 0.5580209515917829, 0.5868678435230541, 0.5195119444629108, 0.5550468677048717, 0.5751856687493959, 0.5158361032713586, 0.8099181765193428, 0.8100556533079599, 0.7969589832210469, 0.8109415602114906, 0.8278451714380263, 0.8213809669280593, 0.8102993334379048, 0.8190738909191545, 0.8310149883244353, 0.1446757212339388, 0.11170386748647054, 0.12319304246524587, 0.11265073579786367, 0.1253205554487833, 0.11445401674056943, 0.11033348570288637, 0.11908964038594783, 0.11761754360162924, 0.1573740803226671, 0.3625987551405977, 0.1448884703786545, 0.1351421061792618, 0.13934900461669497, 0.21379012556340915, 0.19231909201694408, 0.1980207453449243, 0.29462201491049456, 0.5234066382509324, 0.5976291877331104, 0.6160128259241686, 0.49966677822776284, 0.5428077603817114, 0.3863722125838205, 0.5432232941895359, 0.6157583599416716, 0.4281319449109897, 0.3102984816532568, 0.5074979107812648, 0.49963823076033687, 0.5113322646197128, 0.4685589548566371, 0.3901675739688598, 0.4752340508787606, 0.3139809311508519, 0.4674748853069024, 0.1902947083529417, 0.18111774484334187, 0.19421880569480832, 0.20107158956939053, 0.20518293169429302, 0.18070472120276804, 0.2019957729527726, 0.19002091261554854, 0.21525142806933883, 0.6522136438513517, 0.21220366385271594, 0.2180354551289866, 0.1980982213746887, 0.21825940909981623, 0.2175127554493116, 0.2285780651204009, 0.23104834630013138, 0.2147273775022268, 0.1832557106173397, 0.8987095476554908, 0.15806665730490044, 0.19756512509375979, 0.8889605938579271, 0.14984112703096342, 0.16375156916355516, 0.8682569813753926, 0.8639881898634053, 0.8324505828435037, 0.20919925626140723, 0.210778892971335, 0.16396228780038546, 0.16699416061870165, 0.8475020289934547, 0.20907593373499, 0.21146461072964617, 0.21047192209223942, 0.1717026771887067, 0.21794236547819013, 0.20879356430148033, 0.18715187884489493, 0.1953663247429177, 0.18574727450634787, 0.1957521292613138, 0.1773338338666519, 0.20882795524253406, 0.09741358594205196, 0.0965701854890696, 0.08728692131140992, 0.07919835255872443, 0.08475899073012638, 0.0919441446848347, 0.07749925686598469, 0.08049324125437374, 0.08608454940655463]}, "mutation_prompt": null}
{"id": "c144b60f-be5e-4447-9666-bd240cadf261", "solution": "import numpy as np\n\nclass QuantumSelfAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.2]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_current_to_best\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n    \n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        \n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_best(self, population, idx, best):\n        a = population[np.random.choice(range(self.population_size))]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - population[idx])\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumSelfAdaptiveDE", "description": "Quantum-SelfAdaptiveDE employs quantum-inspired differential evolution with dynamic strategy self-adaptation to enhance exploration and exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.4700461341906603, "feedback": "The algorithm QuantumSelfAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.875803836692723, 0.8666530294690988, 0.8779250402019599, 0.8726871955002182, 0.8686732676879093, 0.8817116575710415, 0.8730043807337831, 0.8707717214336054, 0.8692526811445316, 0.7421021967202717, 0.7595032743862329, 0.7530707683320655, 0.7501003931362324, 0.7445443509310687, 0.7774567474486006, 0.757381813994884, 0.7355154601398922, 0.6966654492231457, 0.1672479590044641, 0.13765561164898832, 0.14628487533776624, 0.15237259378248236, 0.11335780768553738, 0.10802899369094598, 0.15103247804074238, 0.1635588822256313, 0.13183737719778033, 0.15085040771148217, 0.14507856517022277, 0.1448164478894558, 0.1330943296474315, 0.1090255350656053, 0.13337768651693627, 0.12917792531653327, 0.14885092500184327, 0.16753888782797643, 0.9778103638227341, 0.9819443328976167, 0.9872847337893322, 0.9764121396372143, 0.9816733571942577, 0.979037964007655, 0.9770971238663986, 0.980225855825868, 0.9776066851373744, 0.6645026542246344, 0.6853190359034441, 0.6706080923982587, 0.699088824830796, 0.6282678071922554, 0.7249854331418886, 0.6622974223156013, 0.6650753440423096, 0.6702976642755831, 0.8363686660779073, 0.8524099274702159, 0.8514926110607388, 0.9015721671208372, 0.8116048643684496, 0.8521434805883985, 0.8536576087720438, 0.8647431428011296, 0.8364898302104256, 0.6314439899770834, 0.5407933405199481, 0.6282718313503415, 0.4675587059726819, 0.5970602700252211, 0.5839310546339234, 0.7013445203102423, 0.5441529729202454, 0.5657451608161528, 0.441212763997316, 0.4604240528191397, 0.716623688961068, 0.6313019098654626, 0.6189559701128373, 0.5034158308306674, 0.6067191888946799, 0.7034987468798326, 0.5512899343324615, 0.5283206131792009, 0.5788262419706989, 0.5707024082946675, 0.040934058517316796, 0.5681358898066874, 0.6020666573229642, 0.6724232763283939, 0.6150142897149808, 0.6455683234235083, 0.6997656308670777, 0.7240367202173951, 0.7115758085496537, 0.7228000660331679, 0.6989877777411416, 0.7364100977094694, 0.7457135665230075, 0.6844930652923901, 0.7439904540898927, 0.32342233136444287, 0.09026511843800877, 0.18770686216952603, 0.21846667549626786, 0.25329486871749307, 0.12332668280769499, 0.12113062181803302, 0.2712486378366007, 0.27509327680911533, 0.5285306336166761, 0.4493672846779856, 0.45404405105473866, 0.5286660196677506, 0.49079450616557396, 0.4991879847931604, 0.5044154725255112, 0.4691817734093423, 0.38807046688842906, 0.813405945046517, 0.7886290315577872, 0.806214825213704, 0.7953820035995288, 0.7947207924705165, 0.80641181796176, 0.8322369464798942, 0.8037622705692683, 0.8066467502493184, 0.13637452907781666, 0.11017804932844355, 0.08570863364447856, 0.14424974980737515, 0.13970913136154317, 0.14310689343422378, 0.13515382680895927, 0.1353946347832632, 0.11487000911575762, 0.32513514353769213, 0.2586414347340876, 0.34201665689457006, 0.3952653309230023, 0.2185842724691075, 0.21812469399821843, 0.14766358006801328, 0.21694306065948232, 0.24933507113220132, 0.5266061530602962, 0.5339788644669103, 0.5405806458568287, 0.4189764265972532, 0.6532749834273059, 0.5377227427188042, 0.5345236214471178, 0.6843963286307169, 0.5963995006056729, 0.49308069876102323, 0.2561669160730249, 0.2846873176841941, 0.20794238433938794, 0.21517534962498386, 0.47500712081805796, 0.26429403751699854, 0.37153675735160263, 0.2637538145240689, 0.20374435487324094, 0.23398360154950737, 0.20409988536389967, 0.20208718901114875, 0.1856198668186433, 0.2127806459717798, 0.202794075911913, 0.2260520897129119, 0.2106951162920846, 0.18089015064085057, 0.24056755901190685, 0.6967640391726864, 0.22225778543829133, 0.20998010499142816, 0.19579224987622834, 0.6720270684070385, 0.20441105195941311, 0.19423584786027182, 0.1875646487538114, 0.8142149623562746, 0.1877306184447589, 0.9079162465742519, 0.18795726002669888, 0.8700357836076171, 0.8862670113797925, 0.8856826362899136, 0.20991741887807658, 0.8915851145387683, 0.21079206149306817, 0.21086482086857772, 0.8569570432456809, 0.1665459285244093, 0.15438478649465526, 0.12702992964244664, 0.10374786757705534, 0.21202925166181152, 0.19236604696776083, 0.1957442315430007, 0.18871217104350424, 0.19278467739408722, 0.1816706129198965, 0.1851854412398759, 0.19645213980424747, 0.1795278121310595, 0.17751383889629524, 0.09533960311428968, 0.09345831892321455, 0.09033738700813176, 0.08725202386761832, 0.09715027081827632, 0.08654854386965749, 0.07891866494725364, 0.10597613837657649, 0.09730240712645755]}, "mutation_prompt": null}
{"id": "54d1137d-9800-4d5e-b5ed-fa509ab8ff0c", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithMemory:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.memory = np.zeros((5, dim))  # Memory to store successful mutations\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                    self.update_memory(trial)  # Update memory with successful trial\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def update_memory(self, trial):\n        index = np.random.randint(0, len(self.memory))\n        self.memory[index] = trial\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        if np.random.rand() < 0.1:\n            memory_sample = self.memory[np.random.randint(0, len(self.memory))]\n            mutant = memory_sample + np.random.choice(self.scaling_factors) * (a - b)\n        else:\n            mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                     np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredDEWithMemory", "description": "Quantum-Inspired Differential Evolution with Adaptive Memory enhances exploration and exploitation using memory-based adaptive strategy selection.", "configspace": "", "generation": 61, "fitness": 0.49828405811745036, "feedback": "The algorithm QuantumInspiredDEWithMemory got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.30.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8776480938147513, 0.8861617596930212, 0.8819318792124154, 0.8933419650255455, 0.8771371083963816, 0.8934129695236027, 0.894494196405064, 0.8674590075708631, 0.8826351068628069, 0.7881212618507142, 0.7797531051748702, 0.771809318059065, 0.7722859759534265, 0.7976963073593675, 0.76499570123638, 0.7644091410309735, 0.7725514442126307, 0.7585559929022548, 0.16946537246302618, 0.15904659392366505, 0.13118518415597225, 0.16546511611594883, 0.15101312989422, 0.14157228965219837, 0.13349810380592475, 0.13356931232627922, 0.1373913828777379, 0.10497955885296506, 0.14546115212695454, 0.09145563176849059, 0.13490889468984513, 0.14521928374125637, 0.11406399599193906, 0.1517484526755779, 0.13369698120474383, 0.10758144850731954, 0.9802581518395512, 0.9798714245292276, 0.9780634671833687, 0.9724280825086381, 0.9844636218614359, 0.9781880164733384, 0.9843152608718999, 0.9855825166729679, 0.9815798522813841, 0.6552679749158102, 0.711342905360841, 0.6991557083585986, 0.693461127583602, 0.7107639787119134, 0.5809896485955384, 0.6921312861806741, 0.6082725179964739, 0.6586395018434253, 0.8868654761722752, 0.893024284471294, 0.9045602760225133, 0.9037321004011498, 0.21931125506228066, 0.18914012080051534, 0.8738513594056383, 0.8816827504116042, 0.23233254416516957, 0.6831043472570586, 0.12688948427903157, 0.7546822420879173, 0.6771810072005608, 0.662218326202711, 0.13209164545788776, 0.6716339984356661, 0.6888233122447516, 0.7838644146465461, 0.6564292652781885, 0.6539063551724413, 0.6842684645925505, 0.6480752445938769, 0.12749487503762624, 0.6677701755240313, 0.7612494419308329, 0.7385730358182062, 0.6012786047185299, 0.6356468204546615, 0.6876167962508772, 0.7101630597170314, 0.7163735745913451, 0.6804405641184172, 0.6715227712783998, 0.6390229711779882, 0.6971936628501687, 0.7055929010160843, 0.788017456854148, 0.7573576664027833, 0.7682537276029048, 0.7496932884270526, 0.7617105718607055, 0.7381818160172255, 0.7661712677054985, 0.7631369244649913, 0.7814137505629676, 0.4929118012293474, 0.13956913712643815, 0.47745628532229456, 0.5514826324258852, 0.23057026669571645, 0.614555866359719, 0.20298764804575675, 0.12684545707870853, 0.3992450441370464, 0.6188353570783667, 0.5981663882407005, 0.6095423758543124, 0.6228406570878819, 0.634577540856955, 0.622755239729911, 0.5104040028334277, 0.6086691528867427, 0.6445604682355537, 0.8525993066311446, 0.8525319127094787, 0.8449375005987976, 0.8292209178283327, 0.8322318943545722, 0.8231655749469708, 0.8331802970098761, 0.8248955707363677, 0.8451790388066621, 0.12123287788432868, 0.1640780787733198, 0.1311225332013295, 0.11973195151843119, 0.12761593868043697, 0.11565106131172143, 0.12308386804742988, 0.10691959494889836, 0.15272481373444802, 0.2542360352416455, 0.23078690707620253, 0.24908521977680032, 0.618534873982965, 0.4382206407917183, 0.23701266545004618, 0.24993304528268356, 0.3360682017713952, 0.15273597575368003, 0.6605626991462435, 0.5102543089511207, 0.6571987953580447, 0.5432773092640608, 0.6732328074786491, 0.5672912547686237, 0.6316508268810637, 0.5706134124986746, 0.6660528419133893, 0.4613271576777719, 0.4792041172955539, 0.546776501632516, 0.5820381032992701, 0.5621235331354312, 0.5751307949888005, 0.4630053387637948, 0.49300669516902906, 0.5198134909266914, 0.2054878689599584, 0.20208257573497124, 0.2210374193699327, 0.18978128125260596, 0.2057432866540021, 0.2025960981416398, 0.20726697903740343, 0.23051577447158667, 0.1954632154139796, 0.19315449431816933, 0.21325814956229983, 0.7056284260326107, 0.7692923892657129, 0.20184781839719312, 0.23434975003731406, 0.19714276284046517, 0.21817099607045543, 0.1836874122879697, 0.20180471429718239, 0.16836957721136003, 0.15375370414932021, 0.8852052811717811, 0.19853179112265085, 0.8726870375904725, 0.8873466751843775, 0.8267541533600123, 0.13075870177363236, 0.8925283270202418, 0.21182852510840855, 0.20784122395676696, 0.12633225846587082, 0.8740843687538586, 0.8958892652739828, 0.2117969375847243, 0.21093054146573353, 0.16495575738251333, 0.18722568918234272, 0.19116459513506356, 0.18215701412393004, 0.19341536559588868, 0.18129285207488488, 0.20119562366049204, 0.19554563449331763, 0.17899394157198478, 0.17265057305759057, 0.08234060142885535, 0.08214064542245447, 0.0731994756871922, 0.081914578982907, 0.08957887415502552, 0.1026493237135162, 0.0931111495804765, 0.08679816724461165, 0.08878404074340451]}, "mutation_prompt": null}
{"id": "2f5ae191-4f04-4f3a-943e-90d456a01bb2", "solution": "import numpy as np\n\nclass QuantumAcceleratedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Adjusted scaling factors\n        self.crossover_rate = 0.85  # Modified crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6  # Slightly increased reward for successful strategies\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8  # Less aggressive penalty for unsuccessful strategies\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumAcceleratedDE", "description": "Quantum Accelerated Differential Evolution utilizes quantum-inspired population diversity and accelerated convergence through adaptive mutation intensity.", "configspace": "", "generation": 62, "fitness": 0.46655397454281583, "feedback": "The algorithm QuantumAcceleratedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8895894595593665, 0.8969970204181388, 0.8784316849820378, 0.8846531462239449, 0.882342460810358, 0.8867072541486293, 0.8951513578428053, 0.883383096890121, 0.873168703366659, 0.7878263769184444, 0.7866913704672774, 0.7743587567867837, 0.8017516637084061, 0.7856592971591498, 0.7799935347498519, 0.6385394843848156, 0.7628665907971363, 0.7369673729082631, 0.4985447224343553, 0.15229691294137282, 0.13636998883214402, 0.146117082860447, 0.17288223760350974, 0.13581081172142206, 0.14582358532877238, 0.6127600099313852, 0.1358157897534258, 0.15735981570083257, 0.13837976559295262, 0.10379360922674297, 0.16267635841540273, 0.11571779333760057, 0.14852977164193015, 0.15005616266832567, 0.13734755668416088, 0.1439891290821259, 0.9781898389580124, 0.9740677700159931, 0.9824639995269304, 0.9667763375624885, 0.962797657434262, 0.953138292051869, 0.9745043253442909, 0.9824266536575893, 0.9857984437904479, 0.6832329441272619, 0.7244882725824185, 0.6967262751471511, 0.7247046754830041, 0.7344271821597629, 0.7007239366770335, 0.7191415891235499, 0.7109177800907347, 0.7215667838174027, 0.22808168719748334, 0.8767884371720573, 0.23990619536932112, 0.27583520121042926, 0.2777098071880877, 0.8917783860720374, 0.13647118216908438, 0.8666153603966757, 0.8880549289031746, 0.5883907201591179, 0.6561152596398188, 0.7307433618577054, 0.26127456231221013, 0.7403129845141381, 0.6788148362900869, 0.6502929878912596, 0.648972615350693, 0.6266847062857064, 0.13153293722907478, 0.5785862728886559, 0.726141942164632, 0.6463631988717542, 0.5809824756561899, 0.5372202095277429, 0.4282200994575194, 0.4283015904746512, 0.6192685785781108, 0.5454729442354296, 0.6750428545610654, 0.5773697593784517, 0.5817043334829147, 0.5436719292104777, 0.6171284664968926, 0.6438680411857518, 0.5612904322576231, 0.5376156185350969, 0.7309253260680322, 0.7379467528906365, 0.7469987194583962, 0.7243263608127475, 0.7008937022656229, 0.713153230114296, 0.7211130384645634, 0.760568305207091, 0.7356553177367484, 0.19662391848141292, 0.1003388105557933, 0.2722782222387815, 0.11936912051117343, 0.36760992196939424, 0.17581460806112936, 0.12331580068769687, 0.17100911061309376, 0.21182882263904224, 0.558613255973395, 0.4479172319551329, 0.5591780627708237, 0.544420873937933, 0.6133280493383994, 0.5789115366544909, 0.5621028802093804, 0.5289050821139964, 0.5740586722277456, 0.8482110594819833, 0.8389490992004223, 0.8253157941589699, 0.8215782005634975, 0.8237689085288329, 0.8157288542898963, 0.8302772954409541, 0.8239271151414266, 0.8188802936929593, 0.12552945001607296, 0.11959811471306436, 0.11493069913676968, 0.1328621795227657, 0.11826482948501305, 0.10656455416731858, 0.15003781471014832, 0.12500601109284393, 0.1374992214319143, 0.2820658216105011, 0.18859119296309612, 0.339230261108008, 0.22736729973692094, 0.19556303071173653, 0.2254743084446037, 0.20809133804382796, 0.2564174047501411, 0.20182742921205665, 0.24359515324569014, 0.39122429259068536, 0.4512794639704335, 0.6812166046163537, 0.31022022637654423, 0.5864923349032538, 0.688389546538902, 0.6777499172003667, 0.6513608007906156, 0.2897903226493873, 0.6245372702127289, 0.4941260696415247, 0.4866667400054976, 0.4529615878171912, 0.40868663044271314, 0.28051044665015656, 0.4519553097793064, 0.24580685377706835, 0.21179559665526548, 0.20511988448609875, 0.19677358678788381, 0.22992472220986537, 0.20920745061942503, 0.19674401123327512, 0.2147776175810998, 0.25008988414724864, 0.2183325858741153, 0.20995762382161665, 0.5911658829477512, 0.18549632487813805, 0.19569147247826613, 0.22036206536225722, 0.21983209858516461, 0.1977983838435684, 0.1956404900183919, 0.8037472196483119, 0.8987160529506826, 0.18687898701314132, 0.9104925612305201, 0.8823606714251865, 0.19947416173746446, 0.19782503213020208, 0.14187145364407894, 0.16030100637424916, 0.21030971620157124, 0.894057513535661, 0.21186665747890931, 0.21066671192485287, 0.8510235335109368, 0.16564546680601722, 0.20570348102344183, 0.1046966348105367, 0.8301896371597468, 0.16743114128016645, 0.1913978875112251, 0.18078394850482615, 0.20935141403993363, 0.18534228909154626, 0.19741501217320212, 0.17843263561435574, 0.18268288473791594, 0.1886404323173556, 0.1937075995311791, 0.09211301079451495, 0.09456654042435397, 0.09552984364159633, 0.09510091502620877, 0.09050616593307237, 0.09075373867459435, 0.1337280018281093, 0.08907098382496936, 0.09116859204261052]}, "mutation_prompt": null}
{"id": "e245899d-c401-4835-95a5-0801b449a240", "solution": "import numpy as np\n\nclass QuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.2]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_current_to_rand_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies)) * 1.2\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.65\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_rand_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm combines diverse mutation strategies with adaptive probability distribution to enhance exploration and convergence.", "configspace": "", "generation": 63, "fitness": 0.4872767404921176, "feedback": "The algorithm QuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8736866092409568, 0.8750319991813089, 0.8802004780887562, 0.8763836279590583, 0.8697613751546625, 0.8746007817510446, 0.88071716333336, 0.8771987692509636, 0.8766867585918845, 0.7580570503995177, 0.7411597702549892, 0.7817298519814848, 0.7629003363273308, 0.756727716065619, 0.7593858875897126, 0.749465912593671, 0.7603977781100558, 0.7631259711177968, 0.17078876870302395, 0.178877688494531, 0.12057516403249369, 0.2948638593365377, 0.5577377544132958, 0.12433286178587388, 0.12714314435756346, 0.12673152991855952, 0.12605135106366616, 0.1653105983388763, 0.1339117149106649, 0.14506897676908448, 0.14399916357209785, 0.12299335680239654, 0.11597627193992188, 0.12160768078607309, 0.14233215342961447, 0.13975009887626333, 0.9782317253234502, 0.9667023254379624, 0.986170601587415, 0.9701593467112191, 0.9812885903743791, 0.9900433156022566, 0.9782364088353982, 0.9826070395189112, 0.9836626265401383, 0.6147794031255698, 0.6298628086473217, 0.610958644866417, 0.6550652430007942, 0.6396963905731823, 0.6668778225438612, 0.625669451544276, 0.6564917192357117, 0.6604317227905057, 0.8618988537632054, 0.8515856261969994, 0.8679143159133769, 0.8353392266991259, 0.8839401989164088, 0.3149975612296865, 0.8707586041710209, 0.8841788884954722, 0.8609362793083272, 0.689941161371759, 0.6245121432118911, 0.6229636968116903, 0.6453086441196212, 0.6167865622676049, 0.7117933747257111, 0.6024196630715859, 0.5599377046267244, 0.6008793433273134, 0.7321104766226749, 0.6319564176118362, 0.5881134763480669, 0.6082306181258996, 0.6313510565812828, 0.6542855744701287, 0.5929981439428917, 0.11979422036492937, 0.5805251455773042, 0.5894440734395535, 0.6127041216324821, 0.625807029154192, 0.5943070425501698, 0.5910474155777765, 0.4534222214230411, 0.6480429049903453, 0.6568301108170223, 0.6688676642924917, 0.6976230372680242, 0.7048359622013513, 0.6698212537012536, 0.6812486122345023, 0.6817983223150814, 0.6850531957516777, 0.694309213865278, 0.7084294470388172, 0.7134086649638705, 0.41077784281269303, 0.12799799312811788, 0.30255730666296654, 0.5480057224296654, 0.25767809476836967, 0.5217411530889333, 0.4863917640014118, 0.2091107418793393, 0.1249950221496432, 0.5230521380008982, 0.5073401767694647, 0.5529340545852626, 0.46402930596340175, 0.535771004055863, 0.47087705271342817, 0.5604423086838835, 0.5193763648571653, 0.5631464279597066, 0.8162583720636226, 0.8058618974820834, 0.8112051687651907, 0.7893426753290497, 0.8209143216339745, 0.8200472295853156, 0.8111835577864007, 0.7973982274929268, 0.8052548030065705, 0.09728322475231366, 0.09307196826766961, 0.09683436404855927, 0.11876525986640007, 0.12317232753745155, 0.10428383182250545, 0.10602453804722245, 0.11386047386388942, 0.10206783567824917, 0.22103409321077072, 0.225159508802786, 0.28211196853159914, 0.20435945357614027, 0.2130544398565959, 0.20705267504765956, 0.2740552228377725, 0.2745004975869906, 0.23086260049995255, 0.5165944989100226, 0.5782496120221641, 0.6460174944912782, 0.6458284309759832, 0.5231646590394967, 0.5346927156909304, 0.6563800944679162, 0.611229504712713, 0.6468670252147684, 0.4678086725469175, 0.4437702836792672, 0.4335920780490967, 0.44492928903518203, 0.4951803047845297, 0.45686751268782944, 0.49149703750624574, 0.4341729821279119, 0.5210636942202742, 0.2173101277979138, 0.1963687313086092, 0.18804608761510888, 0.2013005534415514, 0.20530050824545354, 0.22307489743451314, 0.1958174865529161, 0.19862357487715376, 0.21355869467995603, 0.23798475085648185, 0.20614234684160704, 0.21132677331075644, 0.7336800817222939, 0.20411646670384143, 0.23531196781374397, 0.2427265046179149, 0.21983814953334402, 0.19809695381587744, 0.8532026262229213, 0.9077373579764297, 0.15399660097341317, 0.8861140775622803, 0.1955655608386182, 0.1646808047078594, 0.14212575181995157, 0.17621545224347024, 0.895817397843305, 0.8282158556410558, 0.21210647315404563, 0.8812982191365633, 0.1667435643598908, 0.16651456748067028, 0.8650358764473112, 0.2102135534324887, 0.15500129627027748, 0.88942865565661, 0.1847461181361797, 0.19137524099014858, 0.191120581000354, 0.20716101445101764, 0.18596486812918855, 0.18677768141636553, 0.19217052460896888, 0.1967743778405321, 0.18096765258205716, 0.08758992449973924, 0.08313331417923386, 0.08328849089018109, 0.0830608247003447, 0.08246427493754549, 0.09718794859857027, 0.09716358077432419, 0.08380381011915072, 0.08457403598393998]}, "mutation_prompt": null}
{"id": "cfbda688-c0b8-42a9-bede-666ffba018bb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.scaling_factors = np.linspace(0.4, 1.0, 5)\n        self.scaling_factor_adaptation = np.zeros(len(self.scaling_factors))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                scaling_idx = np.random.choice(len(self.scaling_factors), p=self.scaling_factor_adaptation / self.scaling_factor_adaptation.sum() if np.sum(self.scaling_factor_adaptation) > 0 else None)\n                trial = self.mutation_strategies[strategy_idx](population, i, best, self.scaling_factors[scaling_idx])\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                    self.scaling_factor_adaptation[scaling_idx] += 1\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best, scaling_factor):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + scaling_factor * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best, scaling_factor):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + scaling_factor * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best, scaling_factor):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + scaling_factor * (best - population[idx]) + \\\n                 scaling_factor * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "EnhancedAdaptiveQuantumInspiredDE", "description": "Enhanced Adaptive Quantum-Inspired Differential Evolution introduces an adaptive learning mechanism for scaling factors to improve convergence efficiency.", "configspace": "", "generation": 64, "fitness": 0.36709128802543606, "feedback": "The algorithm EnhancedAdaptiveQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.570509710447157, 0.758323647183542, 0.9366301419538116, 0.6613247333010925, 0.7685001736900408, 0.9367126732547665, 0.6069580316419196, 0.7725866655647765, 0.8600383586915896, 0.07024186760561513, 0.5395306680707791, 0.4811345080682644, 0.35334179209223315, 0.850780826560294, 0.12893449016413183, 0.13781021678932792, 0.565929396839226, 0.7154037471952224, 0.15487741796678545, 0.1572613862127903, 0.1331968649699804, 0.1285744204340994, 0.12894964155707134, 0.1605558562016739, 0.14719872301375758, 0.13008503863298715, 0.12326557556814355, 0.11427437993002698, 0.14411399954490411, 0.10415233639770849, 0.12307387322816865, 0.09618295802306054, 0.13973419761979478, 0.1794833576918723, 0.09597468314928848, 0.12010151068166086, 0.9843060204427726, 0.974564315421967, 0.9877569653494515, 0.9892296073983073, 0.9837265485597286, 0.9850872723414571, 0.9878819063565816, 0.9783444242233236, 0.986297612047558, 0.25799219817763164, 0.36159238132716753, 0.662947897086051, 0.2950802530895741, 0.3022019474577289, 0.43614585461405364, 0.3144824231614769, 0.3875292656408078, 0.8282361279007964, 0.245122678485025, 0.21330826009082504, 0.9307992054014781, 0.2828059986932243, 0.7439348819147023, 0.8424120255590098, 0.2359106796092042, 0.7119941000169763, 0.8262760237634132, 0.2888057237282844, 0.45433004861496007, 0.1899128822536691, 0.1293837430700625, 0.4852404961828213, 0.1274382620039436, 0.22596351325478858, 0.45807590899202, 0.5722686647936899, 0.6123283502590435, 0.5238927549953267, 0.13289132859663189, 0.23947023422606573, 0.4596966657270257, 0.2031697595131372, 0.14381554479484604, 0.4672298060028116, 0.6817994521308317, 0.05377783923123747, 0.42210555273944417, 0.10318683910966375, 0.3474395003843542, 0.34303380445419185, 0.6390674516968895, 0.3975643877708783, 0.4331246754447723, 0.146363113617889, 0.10717859898644255, 0.4878535552351918, 0.72647535073215, 0.6916340021555544, 0.491958607000332, 0.051824377516428655, 0.782186572097076, 0.558039537947846, 0.735991345042337, 0.41523867768556566, 0.17164717123583417, 0.28887012477437124, 9.999999999998899e-05, 0.1811081690475651, 0.30798617850334564, 0.08120510946303161, 0.16245266184478713, 0.18778118341141148, 0.1311485024859872, 0.31347824442996064, 0.45515301074896997, 0.4948739001924568, 0.33536832147285156, 0.2751579692054539, 0.12645392529652633, 0.27983598216697436, 0.3555263541297995, 0.47067327440030204, 0.6686842574264065, 0.8145628578147197, 0.38887559025560137, 0.7005469862910337, 0.7222376221886329, 0.7949936483384348, 0.6694685406433762, 0.8453267766047065, 0.14306135193998326, 0.1306031483811526, 0.11138289303248317, 0.1360212052503026, 0.10979007538914887, 0.11505296549831767, 0.06692121593355482, 0.09582913428774953, 0.0869795639172235, 0.17394659195775675, 0.1891846742348241, 0.21062380882584653, 0.1449441866095056, 0.1381884702977897, 0.2005428827181851, 0.1426952177140136, 0.36248311570600655, 0.1247890988289102, 0.19317448096914125, 0.37128110927018554, 0.4321708097746305, 0.4089430852678273, 0.363422962347585, 0.510737738703414, 0.34508243172237896, 0.3892226825107269, 0.5085446394073541, 0.22789936352152618, 0.32403224276168674, 0.4091489211573638, 0.44928553175684405, 0.33443198034616994, 0.4496391847510124, 0.36802822948001324, 0.312653286675341, 0.4077492903235169, 0.18866576918547517, 0.20707742085467384, 0.19758355387012616, 0.2242565006389846, 0.174648695933586, 0.20912804494113124, 0.21295066600261858, 0.18681010121384511, 0.2123807887220076, 0.20054039994852124, 0.19958168508976892, 0.18562477807243472, 0.560887228594009, 0.20372616198350857, 0.17971319055746315, 0.21013148466914366, 0.20444728446851546, 0.22542477797470906, 0.19512870430299278, 0.16308335536652308, 0.15443996031682017, 0.8411697527963685, 0.751545942742823, 0.20116895361622822, 0.19460795699095046, 0.1579971969885301, 0.8570445381504596, 0.9447855631869412, 0.19774099618178487, 0.8584716882938725, 0.18841797823564788, 0.19711237649767044, 0.8020970795458529, 0.21213011330420384, 0.2053163074872033, 0.8121381842874322, 0.1860563171522438, 0.19644198479309194, 0.18035829199969577, 0.19146601031798838, 0.18549118709276913, 0.176277766710489, 0.18211492430797904, 0.1725713811891888, 0.18792433043938572, 0.09129039043988163, 0.07111786867524061, 0.07560035287299016, 0.08857524968952635, 0.07876137052128473, 0.16984113721810423, 0.0859473981500134, 0.08547794268419051, 0.09495352252922751]}, "mutation_prompt": null}
{"id": "4cd197ea-474a-4425-9543-409a53413f45", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.chaotic_sequence = self.init_chaotic_sequence()\n\n    def init_chaotic_sequence(self):\n        sequence = np.empty(self.budget)\n        sequence[0] = np.random.rand()\n        for i in range(1, self.budget):\n            sequence[i] = 4 * sequence[i-1] * (1 - sequence[i-1])\n        return sequence\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best, eval_count)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best, eval_count):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        chaotic_factor = self.chaotic_sequence[eval_count % self.budget]\n        mutant = a + chaotic_factor * np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant, eval_count)\n\n    def de_best_1_bin(self, population, idx, best, eval_count):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        chaotic_factor = self.chaotic_sequence[eval_count % self.budget]\n        mutant = best + chaotic_factor * np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant, eval_count)\n\n    def de_rand_to_best_1_bin(self, population, idx, best, eval_count):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        chaotic_factor = self.chaotic_sequence[eval_count % self.budget]\n        mutant = population[idx] + chaotic_factor * np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 chaotic_factor * np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant, eval_count)\n\n    def binomial_crossover(self, target, mutant, eval_count):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        chaotic_crossover_rate = self.crossover_rate * self.chaotic_sequence[eval_count % self.budget]\n        for j in range(self.dim):\n            if np.random.rand() < chaotic_crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution introduces chaotic dynamics and adaptive parameter control to enhance convergence.", "configspace": "", "generation": 65, "fitness": 0.4169083369881978, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.27.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8838973669363508, 0.8780958408579854, 0.8822554407270219, 0.8890119604006308, 0.8725279422184942, 0.8897074811616899, 0.8652162026744457, 0.8837142059311847, 0.8737611805756327, 0.7666012763461254, 0.7760747678736868, 0.7965050537399654, 0.7717602301197632, 0.7704835917952758, 0.7676283888392544, 0.7820138140427826, 0.7616926892623863, 0.7633150677784262, 0.7595091207095436, 0.15353716522011984, 0.7315687684267398, 0.182371173963931, 0.7410931443251758, 0.1807372300922243, 0.1296377075193884, 0.1553028189049408, 0.18240306047969435, 0.17909310716563265, 0.17864739527390816, 0.18148363887650598, 0.1401227322737545, 0.6279423432425745, 0.12197308670390195, 0.16813207483035075, 0.17280769694715614, 0.1776052592477254, 0.9540043531096404, 0.9678961094143685, 0.9587242069526836, 0.9737554127731881, 0.9681537929802532, 0.9848058052871536, 0.9743338140394815, 0.9642889584933674, 0.9695088710016133, 0.6023495111607253, 0.5759217587567874, 0.5579050740133831, 0.5560822848504189, 0.5616516586013641, 0.5639512820931118, 0.6052069824429782, 0.5847940018053206, 0.539412737756257, 0.7786068093306984, 0.7660650916204462, 0.8209525842337215, 0.8554344208090865, 0.6865955170524314, 0.777202041133937, 0.8002809086152824, 0.23052125631394904, 0.8165736851642814, 0.12007238068932458, 0.32913513944307704, 0.3190902062439309, 0.34138224240782455, 0.3679297062299097, 0.13271122326318507, 0.38744798741585074, 0.3547087587287352, 0.5020675588832346, 0.26288090311242185, 0.13117578703946087, 0.3150930550959995, 0.28563816325165725, 0.4751542529330134, 0.48344089722567263, 0.12567906333146606, 0.5039392762652939, 0.36941221178106265, 0.2582499180343846, 0.29544131028284426, 0.2836319298890252, 0.3095419995465696, 0.28746372485235216, 0.27058847462613544, 0.13948439375644306, 0.3107738794043762, 0.32079751342268725, 0.46541157309305314, 0.42889675009400274, 0.4746570445054151, 0.4471967897726795, 0.42813413267238243, 0.40847179545733625, 0.5013412704273954, 0.5064779167714385, 0.5331799877965828, 0.08403299709775236, 0.19097459077794976, 0.08879709362481758, 0.12023859387145508, 0.18196740597829053, 0.22748320016034573, 0.15660080334994675, 0.11248619307887475, 0.08119159253564101, 0.3240849857109013, 0.3368988025398587, 0.2748780355509042, 0.29918870515314766, 0.34076511568726386, 0.3115112546137402, 0.22669653088932862, 0.3245510506921585, 0.2744235947835111, 0.733149811966358, 0.7141425061474534, 0.7180768337563224, 0.7133475796630178, 0.6864947911257542, 0.7294109699064872, 0.7149739160168744, 0.7096742169702502, 0.7266267916605033, 0.1401745929299013, 0.13134272215459564, 0.11783836881935728, 0.12924712475162325, 0.12049841852482823, 0.14598757284879926, 0.1755985812106292, 0.12940205215338463, 0.13462530362710645, 0.15993229808859089, 0.2166416642761354, 0.17590691953244675, 0.18517492842628236, 0.1527779118051389, 0.24594583063603837, 0.14967770172518757, 0.190588855275171, 0.26488373502884854, 0.3277028933133298, 0.42186726554478904, 0.35735470287595195, 0.42177554055928745, 0.4824348306929426, 0.4823645831348593, 0.45148785934488567, 0.3499531725263022, 0.3503490024678826, 0.3674105363921617, 0.2866541308814582, 0.3345576660998968, 0.3354149224535484, 0.367701955765394, 0.343569650874749, 0.36975135307176454, 0.3435861440333904, 0.27685714305513176, 0.214009657508751, 0.2302833767518302, 0.2285437613728123, 0.22723714735619316, 0.21289356012431981, 0.234889679731205, 0.21723643444397467, 0.25314713653999554, 0.2257579601003984, 0.24767276841672492, 0.2360803885107945, 0.24923028958313076, 0.24658390597863467, 0.2215456124138947, 0.2087742962194279, 0.24196838541843835, 0.731866302388323, 0.21841650446616934, 0.7215849481481245, 0.8450491603277446, 0.1645750355704635, 0.8531867786804945, 0.9002377713739854, 0.17621120701540827, 0.7496480366486377, 0.8203990407260913, 0.8191070842356963, 0.5919876258468265, 0.16739753873052154, 0.2092531466298816, 0.7797997396625015, 0.7347918489735352, 0.16739948612479127, 0.20703987989239236, 0.7889030571805118, 0.1047630086861866, 0.18683334776858007, 0.19408340290518977, 0.2048351840863255, 0.18811390008366602, 0.19226082743349793, 0.19176416138008334, 0.20082566472477115, 0.18881288857219525, 0.1926794354295459, 0.09226660516049034, 0.10320233290622105, 0.13919471661969618, 0.09305282046507657, 0.08941965057954893, 0.10223039305086001, 0.09846068505626171, 0.09826936685819987, 0.09880977334446528]}, "mutation_prompt": null}
{"id": "69ad5d3f-440e-4728-be5d-2972d2d6eadb", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "5fbaa7fa-a043-48b9-a811-a1362b1e32ce", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "9c4a204c-56a5-4a87-b53b-f9d3f4e76829", "solution": "import numpy as np\n\nclass HybridizedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.local_search_prob = 0.15\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                if np.random.rand() < self.local_search_prob:\n                    trial = self.local_search(population[i])\n                else:\n                    strategy_idx = np.random.choice(\n                        len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                    )\n                    trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial\n\n    def local_search(self, individual):\n        perturbation = np.random.normal(0, 0.1, self.dim)\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)", "name": "HybridizedAdaptiveDE", "description": "Hybridized Adaptive Differential Evolution enhances adaptability by incorporating local search phases for refined exploitation.", "configspace": "", "generation": 68, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'strategy_idx' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'strategy_idx' referenced before assignment\")", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {}, "mutation_prompt": null}
{"id": "47592dfb-b8cb-4e96-8a9e-a0dc5cf9ce2f", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9, 1.1]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum-Enhanced Adaptive Differential Evolution incorporates quantum-inspired insights for dynamic convergence acceleration.", "configspace": "", "generation": 69, "fitness": 0.4408803700431414, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8223536890604135, 0.8122946171872246, 0.8006186454580072, 0.8233321738005243, 0.8072227449888429, 0.8166673041377205, 0.8144533937386076, 0.8217027305985467, 0.8159024400980801, 0.6198799402065086, 0.5896173177842037, 0.6449708664600041, 0.6439214563847291, 0.6383086486176919, 0.6504333289789395, 0.6473253254368835, 0.6631818129669851, 0.6465023927131754, 0.13117180273069773, 0.1340487837319948, 0.15960817550477935, 0.11477088853899042, 0.15478070971239488, 0.12456083366629644, 0.12821083105393005, 0.11492175087198064, 0.23333422499425083, 0.11862793297067076, 0.13375314266766036, 0.12122120765240285, 0.1265245370565311, 0.12233507178641978, 0.26528969129915536, 0.12881617676104884, 0.12898042475356475, 0.12494866882970634, 0.9880795272858821, 0.9693358413891392, 0.9741071011367958, 0.9808071630539124, 0.9820689015316902, 0.9743063443887056, 0.9890070384910242, 0.983220859492987, 0.9860065236800495, 0.37801610369501715, 0.5243661120985262, 0.474867692066247, 0.5005401194985267, 0.5572854062152799, 0.5344789411561215, 0.5467517966340245, 0.4994496550417059, 0.5354436928705114, 0.7928286972325782, 0.7834367697998446, 0.7984944407555696, 0.8093838344847942, 0.8076797554495863, 0.7976494658288706, 0.7975314989492601, 0.793015566760408, 0.8027211039568747, 0.5833866802396754, 0.52637792850289, 0.5740833934604583, 0.6507872104215262, 0.5243997086586693, 0.5795064783984103, 0.6032148970556586, 0.6330682000295738, 0.5652178571260025, 0.48535219780394323, 0.5410752745677364, 0.5797960991231484, 0.5663763969272898, 0.5297742250974179, 0.559817755618106, 0.12694970903828817, 0.5599475616896761, 0.4730154440805715, 0.5450943214585027, 0.5486377440517026, 0.489930473510912, 0.4869695958851832, 0.4998492456250606, 0.5017808243751006, 0.51188141944844, 0.5245065909013694, 0.5069583368336987, 0.6668170114939935, 0.6264756609867893, 0.6374558298803914, 0.6285626505316833, 0.6053363539916435, 0.5881404152267244, 0.6270854108274311, 0.6355360106178045, 0.6226118890496172, 0.11118425925829345, 0.31827708620063067, 0.09412375685240604, 0.3274384360289355, 0.34267396926552807, 0.30792465442045913, 0.12560775622896014, 0.3047651371414182, 0.0999364059794905, 0.41113666767964896, 0.3995937080271038, 0.3714929128684471, 0.39617469590918486, 0.4393375588620465, 0.41255665378856665, 0.41757651846519006, 0.4379448624334278, 0.4117099366162129, 0.746017755304718, 0.7598423803137373, 0.763340841476597, 0.7467698805131553, 0.7406399796454912, 0.7116096916621137, 0.7731006739154128, 0.7559672853310475, 0.7506314484088635, 0.1440075152719501, 0.11087852752647087, 0.11544207264979289, 0.09014645927603016, 0.09248011120433808, 0.12076213280757142, 0.10692236013790568, 0.10628517308058016, 0.32510749721851184, 0.22132979270603115, 0.13061356535238156, 0.4765843239792218, 0.30045003341369414, 0.19135603573089732, 0.20743900173736296, 0.21422570000759988, 0.16375841659895796, 0.1702925324783362, 0.4286376475984778, 0.4661410232435318, 0.45507157092391703, 0.48113168639633563, 0.49914739766125227, 0.2121767422349099, 0.5049315491455524, 0.4674419561671749, 0.47661220337392274, 0.38482029545116836, 0.3885077652504252, 0.33937363034871315, 0.3890309132503067, 0.40088770622848746, 0.3511130265369702, 0.40790749754755085, 0.42060160353785636, 0.38488718565339086, 0.20232236622921496, 0.21334461292571827, 0.18905750340695116, 0.21099887833295827, 0.20745226161088737, 0.23513331396780213, 0.20284224291714203, 0.19105428908709476, 0.193433057854016, 0.20622091232605677, 0.19916317618648738, 0.4863106319853937, 0.21393793311751652, 0.38683905645050376, 0.20655105422081765, 0.5392127456447986, 0.19957606221855495, 0.23056884584055237, 0.8225787807728917, 0.15558989901478903, 0.8607276608700731, 0.8218864295259691, 0.19507083978225637, 0.1738870694721667, 0.1737524384107102, 0.16155709146214536, 0.8248102513780916, 0.8160157001374048, 0.167544971292513, 0.7725841450246413, 0.7974460019827432, 0.8205014678933351, 0.15184115335606296, 0.21047041858572724, 0.2110608952058971, 0.824972949041717, 0.19209749817853294, 0.18112673266176837, 0.18673383136255506, 0.19556308061155758, 0.18222963894311683, 0.17619980208690866, 0.18117385147914045, 0.19097025630714848, 0.19101158424867826, 0.08680853293782642, 0.08177026218834105, 0.0926017424543556, 0.07070964856649808, 0.07645394228790248, 0.07696229361404583, 0.07816031504723053, 0.08303994773259749, 0.08510185807548498]}, "mutation_prompt": null}
{"id": "e7d39c60-1767-465d-9ec4-136757d0ae81", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDEWithDynamicScaling:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9, 1.1]  # Adjusted scaling factors\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.3  # Adjusted weight increment\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8  # Adjusted weight decrement\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDEWithDynamicScaling", "description": "Adaptive Quantum-Inspired DE with Dynamic Scaling optimizes convergence through variable scaling factors and strategy adaptation.", "configspace": "", "generation": 70, "fitness": 0.49632750626851846, "feedback": "The algorithm AdaptiveQuantumInspiredDEWithDynamicScaling got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.30.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8920237231930471, 0.8971280877155293, 0.8874019149241379, 0.9019401245222093, 0.897571290559509, 0.8951852263937063, 0.8966178709251973, 0.8935701464766481, 0.8842940708266993, 0.7801743682961166, 0.7804138554057334, 0.7727930085518679, 0.7621333992989741, 0.7838374315878252, 0.8031300648529925, 0.6382294936269024, 0.8037318622251617, 0.62160475591633, 0.1629894719540682, 0.6366843049960826, 0.14137522940179947, 0.15139001436973865, 0.12181775238493397, 0.15804866149081953, 0.13448930279403448, 0.16249811153258376, 0.1661292167677133, 0.1196935883910053, 0.13942319529487246, 0.10600977181566018, 0.13880100528195016, 0.12396754477880878, 0.10723927851850434, 0.13708046258781725, 0.11345013967890116, 0.11520090264238969, 0.9814149666157519, 0.9775650526952923, 0.979362507338166, 0.9864071376712665, 0.9753450605649034, 0.9704932456903407, 0.9815025373931278, 0.9796041222109131, 0.9834211018780401, 0.7271725559278246, 0.7291933058081722, 0.7198385749003375, 0.7177429240877808, 0.719695947097807, 0.7060681478919124, 0.6950661744697363, 0.7185189649428827, 0.7424145563920748, 0.9007659592482804, 0.21762700424300352, 0.3900324772323055, 0.8767879968584158, 0.8963166152123553, 0.8562126481383522, 0.8106386642929095, 0.2320755872145539, 0.8266463982747223, 0.8098190776714582, 0.7227905818209222, 0.7233509657466134, 0.13264960656072655, 0.669565661310721, 0.1314050968240228, 0.6248355823732117, 0.6528190067149715, 0.7752210604954501, 0.13358935775852676, 0.683749192797039, 0.5637854586531723, 0.7090875304837059, 0.6027362253109407, 0.6799840698261597, 0.1325753438045052, 0.604636734348888, 0.759119147152036, 0.7039886792814183, 0.7103734146494567, 0.729892531213935, 0.717027861478305, 0.5583498022156089, 0.6906849783708664, 0.6893867238243561, 0.6978335562914881, 0.5910227088539985, 0.7590485054006421, 0.7644275603308248, 0.7881750668379568, 0.7674215277926009, 0.7939255901140644, 0.8028393631625896, 0.780719130555344, 0.7930298378184277, 0.8031487347313865, 0.1686228461241681, 0.42031245654751637, 0.11880594449180137, 0.5553868817669683, 0.40905979559431516, 0.6036694756436916, 0.13990400215129106, 0.41783249993949456, 0.4837855366240549, 0.6079051730832041, 0.6303852736976744, 0.64237476799111, 0.6483425571231612, 0.6398327598769498, 0.6800369029676742, 0.563969169545309, 0.6094903997415336, 0.6462740024328155, 0.8609475520363459, 0.8380218494526976, 0.8470911668023475, 0.8627309509982577, 0.8359780549566733, 0.8444851929599333, 0.8495320539631044, 0.8243670175503022, 0.8463931115151303, 0.11140456725436021, 0.17563543836206863, 0.09788372302689785, 0.10687663455666496, 0.11425423252291989, 0.10769224691824475, 0.10536131656532033, 0.10793211584845086, 0.12771012757252032, 0.5762145741627274, 0.19953157223624474, 0.3776488592597941, 0.22035739087303718, 0.21665789722975082, 0.6664471742544402, 0.20449909505939656, 0.1808303185865202, 0.22403104367255178, 0.5757187623860354, 0.558553403422607, 0.5923386706902777, 0.7378691337452885, 0.6197548931133068, 0.5150036495274019, 0.6491459922470377, 0.5858014743798743, 0.5563760140631718, 0.27641335907186537, 0.2325405576587325, 0.5772025967426003, 0.5086393595171581, 0.4881358123804317, 0.3996442740420615, 0.4143270991584266, 0.6053920349723976, 0.40953216208359067, 0.18181805073421686, 0.21597935487736641, 0.21547330123073494, 0.20926383195206066, 0.19270342668129958, 0.2312351814753636, 0.1999877979254545, 0.19667309793794174, 0.21619671610222568, 0.22614659945141502, 0.20494533935066017, 0.22175776978141848, 0.20412598527667647, 0.7510184874153798, 0.2110781669974725, 0.20427686909619958, 0.21776137385994776, 0.22503649362377132, 0.8437900934625124, 0.16509291727060882, 0.15286315943571882, 0.9228474632713018, 0.1987958238747698, 0.1686097119547909, 0.14269179574187651, 0.1756157441823918, 0.920645972934112, 0.8779426399360337, 0.2115120428587859, 0.8936094561829506, 0.8908200968474089, 0.9036645789490848, 0.167326661356353, 0.21223155872349775, 0.21054735204016384, 0.2081544673705874, 0.18075110523495042, 0.18456808922113233, 0.19367984023697227, 0.19529574045950826, 0.20662271932978338, 0.18882300731638801, 0.21815946922102103, 0.1810391658497691, 0.1824303817145947, 0.09287643644521526, 0.08866534463779041, 0.08224299646981603, 0.09759645070467216, 0.08033894650909312, 0.07352689253087885, 0.09219341605483733, 0.08803714029090492, 0.08974570202056054]}, "mutation_prompt": null}
{"id": "15062166-3673-45ed-ac1e-62dd101db53b", "solution": "import numpy as np\n\nclass QuantumHybridEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.6, 0.9, 1.2]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_current_to_rand_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.75\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (a - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumHybridEvolutionaryStrategy", "description": "Quantum Hybrid Evolutionary Strategy enhances Differential Evolution using quantum-inspired mutations and adaptive crossover for improved global exploration and convergence.", "configspace": "", "generation": 71, "fitness": 0.47871841376862606, "feedback": "The algorithm QuantumHybridEvolutionaryStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8734006868470829, 0.8714829917683391, 0.8749436232043001, 0.894227253412705, 0.8712186273802338, 0.8847349181805833, 0.8770639925739808, 0.887875204029217, 0.8719772378461926, 0.7548250467913475, 0.774313852090712, 0.7684840582569145, 0.7797883514937104, 0.7629761758000152, 0.794092359715673, 0.7230355510177267, 0.7690699501021467, 0.7542681387391775, 0.11830614053905286, 0.14282295835781478, 0.13646029652177982, 0.23449758805937082, 0.17172713133245165, 0.4701555968371324, 0.16796471799432167, 0.10837065685385439, 0.12597790090536987, 0.15093661276090442, 0.13296108352402192, 0.14792635579899083, 0.14149206729960484, 0.142928290410407, 0.12962366330607256, 0.5935235212886996, 0.1230450366187551, 0.10896213117135445, 0.9835423913681348, 0.9834698456082502, 0.9827597023902455, 0.9664351466535607, 0.9832494036380065, 0.9728768148669599, 0.9822666700544611, 0.9856403608012823, 0.982128026386089, 0.5639803374185637, 0.6348354058060164, 0.6180696231393228, 0.6484873844300696, 0.6690445425098767, 0.6154873473099267, 0.6351882308210048, 0.6433992198255858, 0.6395573137465804, 0.8739982450908419, 0.2260932877195745, 0.8555771514031354, 0.9118068906057664, 0.8369046236947806, 0.8017740903861805, 0.8476422669397434, 0.8542345560625022, 0.8433519894337009, 0.13048480459874356, 0.6579788471457911, 0.13022365714500517, 0.5659289436987304, 0.7198604030717124, 0.6420353773695755, 0.5708344137106531, 0.6836364328847293, 0.7462253943979688, 0.4899934143220439, 0.7416021980061714, 0.6165381495439192, 0.7379544333196624, 0.6510323481158193, 0.6534963705566625, 0.6036880494339334, 0.6724946340878173, 0.6849692868610919, 0.6663630392266922, 0.4912835300020484, 0.6294561966958112, 0.29675601486659287, 0.6436775606112513, 0.5622180420708018, 0.6390724941899761, 0.5932905493771435, 0.6556280956083743, 0.6805071957872728, 0.6975113841583847, 0.6993554585959583, 0.7181118284212082, 0.7247553316950492, 0.7006108411486024, 0.7337949166011287, 0.7058380014166952, 0.6951977136589405, 0.4254144579687452, 0.08724962756526222, 0.31536818586211623, 0.5184234711838216, 0.4527495222267328, 0.4195099609923504, 0.3788744773353333, 0.12011680314227646, 0.1497731621919045, 0.543963255695677, 0.5104507604751412, 0.5476831278601133, 0.5267769600787348, 0.5740690316532879, 0.5787345547965754, 0.5395553505291819, 0.5448296178715871, 0.47683641132455246, 0.80654774679981, 0.8379819326837628, 0.8171011305012371, 0.8302174790711789, 0.8224322863529188, 0.8204782753469084, 0.8354738103249837, 0.8213844792215563, 0.8214450007142526, 0.17719777417805072, 0.12974258958078355, 0.12298268117188238, 0.14407138568836053, 0.12868852724299362, 0.1098109116903685, 0.09657790946387579, 0.13026809999218458, 0.09367930314228301, 0.162135400045901, 0.17832633237278772, 0.18136830281885807, 0.20405549197559092, 0.4647662958919324, 0.17014516516582334, 0.17684681153771453, 0.16305721509565196, 0.2534160141399403, 0.5527875097979054, 0.6485226927917725, 0.47156283830562973, 0.5662750346817169, 0.5287407989691837, 0.6719846436293403, 0.698057498529264, 0.4498167736425922, 0.5045669174578282, 0.3246385815198478, 0.48856488070575943, 0.4285237519314633, 0.420263083369234, 0.45170422674414834, 0.25046714569143824, 0.3497397109752859, 0.4563137397087359, 0.41425513984215045, 0.19085111056693238, 0.20568924711064518, 0.18489853779764542, 0.19178581574465348, 0.19596654767650756, 0.19888117226113022, 0.21826205882862182, 0.18654142835955712, 0.1902934116485473, 0.20248974905852157, 0.23709563734476002, 0.22359499098525892, 0.22310836611077356, 0.2268097795989218, 0.2334902779035123, 0.6089746914371921, 0.20309114122266814, 0.19767750350392999, 0.1853963335969756, 0.17016868450177602, 0.1534968684774789, 0.9163576016753647, 0.16491370676541028, 0.8849756521799412, 0.17128553585509732, 0.1845991832506806, 0.818036596889869, 0.2087889046756748, 0.2114419657058353, 0.1265584443102663, 0.8934464216884223, 0.852299624901592, 0.8170166047037627, 0.21025566106722704, 0.20491066023698246, 0.9081472665855057, 0.17591590501948262, 0.1994217034585012, 0.1892453056602057, 0.1870172231377739, 0.18122155271019746, 0.18485827760244888, 0.19894951087322277, 0.16700345274540107, 0.18022569909710162, 0.0798075900054459, 0.07944909311673143, 0.08438402461585026, 0.08496620768751217, 0.08294199007574188, 0.07807574839491593, 0.08771651780230583, 0.08365344541611741, 0.07969889377620953]}, "mutation_prompt": null}
{"id": "1683628d-e65d-4621-9e18-12a03f95da1d", "solution": "import numpy as np\n\nclass QuantumCooperativeDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9, 1.2]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_current_to_pbest_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.6\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_current_to_pbest_bin(self, population, idx, best):\n        pbest = population[np.random.randint(0, self.population_size)]\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (pbest - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumCooperativeDE", "description": "Quantum-Cooperative Differential Evolution utilizes cooperative co-evolutionary strategies paired with quantum-inspired adaptation to enhance convergence efficiency.", "configspace": "", "generation": 72, "fitness": 0.3915811671015074, "feedback": "The algorithm QuantumCooperativeDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8220513953061137, 0.7921398101165589, 0.7830509794358709, 0.8034565909699655, 0.7965747715314146, 0.8225377742324347, 0.8150344096625638, 0.803678757993446, 0.7899412483789486, 0.6521876726996718, 0.6506307567648835, 0.6379553539852946, 0.5929652206859934, 0.6232379751726157, 0.6105776203653901, 0.6196059888624253, 0.633339612631433, 0.5581833043699775, 0.1303688148226989, 0.10858448764845674, 0.2664579250120055, 0.11564808339987942, 0.12927131487698718, 0.12051829463985686, 0.33747279196615754, 0.20283629387279, 0.1389187038852342, 0.09941033996261428, 0.12172898660106912, 0.11731551352746372, 0.10990587346923952, 0.15196342993969159, 0.11662741417536437, 0.1326660542134419, 0.11107267094770723, 0.12288114617156976, 0.983854408633624, 0.9881903984889545, 0.9816058224497368, 0.9624032179555537, 0.9647845893131121, 0.981119161981112, 0.9885602240765097, 0.9791074216695937, 0.9773386713911814, 0.32267466711186255, 0.3318254302813861, 0.28617321861619993, 0.2904327507536476, 0.28479207334863865, 0.3153163345726624, 0.3633172011141499, 0.293497164502886, 0.4306324206558324, 0.7494429364230325, 0.7851689308707132, 0.21837750910142661, 0.7512114613936588, 0.7644275406331866, 0.7269600119302908, 0.7821653522122279, 0.7603211214201675, 0.7351434491492553, 0.5094361163129166, 0.364507836750086, 0.5106287912674836, 0.12492289160576675, 0.5313216173262916, 0.49888028419414765, 0.12508691807559702, 0.4569653552183669, 0.4819642027059672, 0.4100338386940424, 0.5552522478584332, 0.37798526286751977, 0.4973742872126804, 0.48851686266197414, 0.12106429267869556, 0.5854420811509256, 0.5044698348898193, 0.5102594281819272, 0.4353096927364527, 0.4342527437205307, 0.4499184470549795, 0.3793319814048369, 0.40499081003092463, 0.4043137619555196, 0.48385689019116673, 0.4350277140122597, 0.1617916582205291, 0.5672586001095868, 0.5118993631220391, 0.2920476505049301, 0.4681803207683599, 0.5534697749018861, 0.49993219982504666, 0.5695198031714794, 0.5818306975326588, 0.6203451822537227, 0.250268501341504, 0.09825807574356604, 0.17094073089148065, 0.2278008646951739, 0.13806031270265706, 0.21516200527142515, 0.22261793798975682, 0.10665085189511014, 0.2748186659298162, 0.3452672864054003, 0.2919313848616746, 0.30128454027697293, 0.3624604613165475, 0.3325152203657453, 0.24761810625532632, 0.35156655750551113, 0.2554255432829986, 0.33682194684035804, 0.6619433379763254, 0.6228608095661108, 0.7037681442757242, 0.7228930728536987, 0.6973754749101481, 0.6950303953950412, 0.7465202884339566, 0.7159677538277107, 0.7160648838966726, 0.10276859192081633, 0.09233946312741592, 0.0994471449217168, 0.08954170918284654, 0.10151971896788092, 0.11176305386663277, 0.10616737112513697, 0.23577161361736765, 0.10667364402699153, 0.1405809006461477, 0.16318720857175828, 0.16077376628842033, 0.17865154904470804, 0.3535524042185356, 0.15789512347246581, 0.12802297245895078, 0.17932994945878522, 0.15327434380772353, 0.45452722187534755, 0.40270855609054035, 0.42281173824858775, 0.44052980206259673, 0.4611986144796788, 0.4037664082889818, 0.3914638092423569, 0.4655680067577457, 0.4473145293167172, 0.28346909360513095, 0.3822140738477523, 0.35402706375696036, 0.3239984801974548, 0.2988434272024172, 0.2908760206077513, 0.3809514575921884, 0.3805994268334414, 0.35760311271628087, 0.21810369221036807, 0.18303093759399913, 0.19593256458547237, 0.1759189045746471, 0.18584161182859105, 0.1875978043146509, 0.19917241844851008, 0.18647184555798646, 0.1925033231628015, 0.22060501453587678, 0.1890263823467544, 0.5878030387643649, 0.17713327213167884, 0.18599007011273483, 0.21321164351502753, 0.18837597455825816, 0.207928593881182, 0.3192984975324934, 0.19483326311688298, 0.18332177938904493, 0.6918162192373571, 0.1876149018464749, 0.7865036539054852, 0.1911208705582026, 0.7253687043990816, 0.7897093627415419, 0.20455849214720612, 0.7826436885020644, 0.20758105746113908, 0.7490387068036521, 0.20289523552565336, 0.7159137035792521, 0.5979699181764723, 0.21105657893729945, 0.21076142136664577, 0.7858850387889411, 0.1904166402124371, 0.1875769652620941, 0.17960739015655725, 0.18457382273497835, 0.18858835509399252, 0.19598648024933252, 0.19529176578242524, 0.19643579594549787, 0.18782279849148076, 0.07255239671932123, 0.08105794675939104, 0.07640936644524587, 0.08385772653119261, 0.07157053881973119, 0.08194610012165138, 0.06953045790466972, 0.06819172413904018, 0.07492279674874758]}, "mutation_prompt": null}
{"id": "76ee854c-0868-4e9d-b9ab-bdf36bee77f7", "solution": "import numpy as np\n\nclass QuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.2, 0.5, 0.8]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,\n            self.de_rand_to_pbest_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.65\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):\n        a, b, d = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b) + 0.5 * (d - best)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_pbest_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        pbest = population[np.random.choice(range(self.population_size))]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (pbest - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumDifferentialEvolution", "description": "Quantum Differential Evolution with Adaptive Mutation and Crossover Rates dynamically tunes strategies for enhanced optimization efficiency.", "configspace": "", "generation": 73, "fitness": 0.43945189094486753, "feedback": "The algorithm QuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.28.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8776811706720351, 0.87078503254492, 0.8549210104879037, 0.869551171997099, 0.8766586779424594, 0.8892541477546378, 0.8807803533596763, 0.853073051980552, 0.8574145903392287, 0.7438883578888205, 0.7501378620358035, 0.7387494352459343, 0.7549650294791977, 0.7538565273879834, 0.7448004552541718, 0.7342932232105439, 0.747787433347685, 0.6083614789262402, 0.16932612247368284, 0.14104767910656157, 0.14622564187481024, 0.17022951926592722, 0.13450646235860675, 0.12446493318555607, 0.13893733700301525, 0.16159508258253863, 0.17153853882306846, 0.12999611683107037, 0.14097172542219671, 0.1356956767929305, 0.13320407455887728, 0.13655105036925475, 0.1367035334669484, 0.12967470010472937, 0.10752006617082921, 0.12523632274157626, 0.860196036183001, 0.9066235378871086, 0.8758046641309875, 0.9309959626151607, 0.8591824764586737, 0.8367816674013282, 0.925653831354273, 0.8207850722700925, 0.9378594611531332, 0.5656412757442324, 0.5481673318696432, 0.6973557506546444, 0.6922575617184442, 0.6876474145209103, 0.6570528764393813, 0.6804106434655942, 0.6901678438146782, 0.6461302153446266, 0.8673336068215629, 0.8871414431436145, 0.8173223943665937, 0.27551309018444403, 0.8851175543546915, 0.8641678934439887, 0.8045654261331807, 0.8866607845954109, 0.8335606689629385, 0.15653063013804835, 0.4798652759155493, 0.16492803663208577, 0.6952347619986092, 0.18403139637619526, 0.2672357938115636, 0.15532752765943825, 0.19732830907051435, 0.20186529795518038, 0.49874992205319957, 0.194261230467222, 0.19223722570865487, 0.17804578760980017, 0.28439645439531414, 0.14730404974889366, 0.18878168849851407, 0.23210206058113014, 0.1860120294763753, 0.3116858613328003, 0.32418445831011433, 0.60615530490131, 0.6225342273960238, 0.4143003208734656, 0.5597201755570749, 0.5717041029479851, 0.4780111860156103, 0.6007588921592729, 0.7556392295675015, 0.74772628703047, 0.6722890644814515, 0.6522438553933989, 0.4785602904843391, 0.6881888406341488, 0.7363662645775393, 0.6892824278035866, 0.7210247534726555, 0.29412267262838054, 0.17215553419807383, 0.2597661830952518, 0.24200414646940915, 0.2757679101662932, 0.4120553140521718, 0.09647988547703534, 0.19923499974839165, 0.31440926204048414, 0.30136224301467907, 0.5127037381004991, 0.45623167585415836, 0.34196217952819274, 0.5366872961522811, 0.40350781544285064, 0.3943671070071382, 0.5059280546740628, 0.2845630383441633, 0.7813620868054056, 0.8289099790284484, 0.8208373730861354, 0.8065051348507333, 0.7887771689107075, 0.7863438728685175, 0.7742518309456035, 0.6732304473231965, 0.8334616897151578, 0.1426596512430267, 0.11490832605248802, 0.11293161840742139, 0.10449636160502873, 0.12354727502795304, 0.13615695261294136, 0.1252552035548209, 0.12187562551887765, 0.13685256756802755, 0.18108822086903054, 0.1737200516703994, 0.14435875813443455, 0.16488336238396806, 0.20259939480681954, 0.18959940104814021, 0.12297781320357026, 0.14317668678760243, 0.1397180103182487, 0.5980176769230623, 0.6845980988063769, 0.6204860328076133, 0.5907929037398134, 0.7028480047625911, 0.6490478696642588, 0.5495524302006405, 0.7106190395745956, 0.6225617533096595, 0.3016557148986856, 0.5304432607641715, 0.45382080072796926, 0.5289097635643603, 0.5245176421550188, 0.5475914118117742, 0.6222570112060195, 0.4958204136902137, 0.4389477607296106, 0.23482860732041677, 0.21943048988622404, 0.21155290827673356, 0.22302028667487006, 0.2190326842754654, 0.2050000070293858, 0.2712607419282179, 0.23899244741258918, 0.22764464614528512, 0.21439850344599798, 0.2374447112292385, 0.21134846301790156, 0.225650158073897, 0.20542340751619304, 0.20793622985346716, 0.2006333312148756, 0.2584416793764477, 0.5086333788625965, 0.17817812242322362, 0.19243328112016156, 0.8528902624380134, 0.8777853028618456, 0.7633167337595512, 0.8803231934620597, 0.13965178159890435, 0.7934608029114502, 0.7905481466354564, 0.8707362837901385, 0.21004027087728105, 0.20501495947119808, 0.20621133986446216, 0.7076988715330585, 0.16613015418494415, 0.20966052183715023, 0.20844131682487588, 0.8176406678942274, 0.1880833132001417, 0.19643923436548105, 0.18428246798912418, 0.18358036207202777, 0.1914024961581472, 0.18206092698231902, 0.17685890371802293, 0.18792232659444674, 0.2024012704373377, 0.10640403893676698, 0.09096989220732321, 0.09621143830274648, 0.0900114602822285, 0.09080530701827705, 0.09565725479006737, 0.11746841126821017, 0.09691129851017688, 0.08792873749963581]}, "mutation_prompt": null}
{"id": "3cca6ec3-788e-4ded-b335-a3b71ca7166b", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithElite:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.2]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.3\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        elite = population[np.random.choice(self.elite_indices(fitness), 1)[0]]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (elite - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial\n\n    def elite_indices(self, fitness, percent=0.2):\n        num_elite = max(1, int(self.population_size * percent))\n        return np.argsort(fitness)[:num_elite]", "name": "QuantumInspiredDEWithElite", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategy and Elite Recombination enhances global search using elite-guided mutation and adaptive strategy reinforcement.", "configspace": "", "generation": 74, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'fitness' is not defined\").", "error": "NameError(\"name 'fitness' is not defined\")", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {}, "mutation_prompt": null}
{"id": "bb447ec8-13cc-4557-a135-8252faefdd87", "solution": "import numpy as np\n\nclass QuantumInspiredDE_DynamicPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.learning_rate = 0.1\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += self.learning_rate\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= (1 - self.learning_rate)\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n            # Dynamic population resizing\n            if eval_count < self.budget / 2 and np.std(fitness) < 1e-5:\n                self.population_size = min(max(5, self.population_size // 2), self.budget - eval_count)\n                population = population[:self.population_size]\n                fitness = fitness[:self.population_size]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredDE_DynamicPopulation", "description": "Quantum-Inspired DE with Dynamic Population and Adaptive Learning integrates dynamic population resizing and adaptive strategy learning to enhance convergence and diversity.", "configspace": "", "generation": 75, "fitness": 0.470561479713495, "feedback": "The algorithm QuantumInspiredDE_DynamicPopulation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.7963275667769876, 0.7400142600859109, 0.7890260857183404, 0.7779758998453137, 0.7869200291459568, 0.7339732895999924, 0.7635269948041592, 0.7864971883580119, 0.7235742561067906, 0.6983381442236478, 0.7156555648361194, 0.7387964547089056, 0.6408457162009158, 0.7080313349758036, 0.7283170089863858, 0.7948530419211562, 0.6654933851261524, 0.698236305248882, 0.13823149911985366, 0.145571112057863, 0.1226764896611805, 0.14212962953486563, 0.13108235677802982, 0.14471465754009638, 0.14097436548265996, 0.1327980573607308, 0.14756338449256035, 0.12960957969257814, 0.1078386964686886, 0.15330105830407592, 0.15044800690491378, 0.11273969062941469, 0.12361039864286849, 0.11388680128228168, 0.14440075855808754, 0.16524963071677434, 0.9856319198123675, 0.9726784971942933, 0.9839618962447727, 0.9709958209279224, 0.9816752473688957, 0.9784386204183668, 0.9798593676610501, 0.9767777768098489, 0.9824542768144692, 0.6136242921710211, 0.6662898445443869, 0.5862687029612264, 0.6712194574320124, 0.6762373242640376, 0.6840754211622706, 0.6149753050778404, 0.6103794466158255, 0.6113620808847164, 0.8686039371159782, 0.228819858646506, 0.8747133014515935, 0.2189717684561976, 0.8382492100815573, 0.8821290251149126, 0.8820758971704546, 0.8749161668155305, 0.8891074591295601, 0.63214073078241, 0.1258266575208623, 0.6975392282526609, 0.602908168382106, 0.6122645215535678, 0.6265674499138738, 0.6486052587419886, 0.6228281580524749, 0.672684749894713, 0.6621214016344248, 0.6248407630290389, 0.6143546964039517, 0.13073036164286556, 0.6360912845518625, 0.5759148730717337, 0.6839487461241142, 0.12747418166604096, 0.5873382622280514, 0.6197920580283163, 0.6118201814701767, 0.6173062323432614, 0.25603315582102826, 0.6296395300981252, 0.6803930690848544, 0.6529319832435581, 0.6181203157641446, 0.6420356714823294, 0.6529851862540151, 0.6308118060382151, 0.6323312976632709, 0.6057896170028616, 0.6665253674185028, 0.6504873448836137, 0.729004037013041, 0.6715970193354956, 0.6490260606230094, 0.09843896238470728, 0.16413278262613862, 0.5032256134558133, 0.519115110176062, 0.26259543752018255, 0.44105636980728624, 0.45367927798270835, 0.3466980452389582, 0.5063327798389258, 0.6161804793870361, 0.5729345527617982, 0.6161962703360738, 0.6200310017135326, 0.5765472649136765, 0.6286862178392341, 0.616918967312159, 0.578030788396058, 0.5663712460304503, 0.6874126599776424, 0.7532714046348841, 0.7249792624099126, 0.6601041912395933, 0.8138455576139793, 0.7073023573262596, 0.6929296809850158, 0.6959090346705918, 0.7444687827831996, 0.1331855098823671, 0.11699314678969663, 0.15292574897013456, 0.18081737529381026, 0.13751505114541873, 0.13844808667768516, 0.12189466332269616, 0.13846549684718779, 0.10533364442926307, 0.19425671804640965, 0.5818019891661357, 0.19948938021281137, 0.29012969215697126, 0.21282447363699497, 0.17580242215135566, 0.22558365331154417, 0.15762877777189355, 0.23754012668652658, 0.6231814694629217, 0.5191126661896541, 0.629916704618963, 0.652362099820662, 0.6533574274739742, 0.5434293504833342, 0.5677685643200996, 0.5794257150966248, 0.6684197645526387, 0.5295961945447945, 0.2637398346621972, 0.5167105341229394, 0.3935382199814914, 0.3933342946029892, 0.4625010184882493, 0.23066654195961878, 0.6065184723399426, 0.5735634378056178, 0.21576850600783515, 0.19509405419568382, 0.23405947934038351, 0.22034612044562318, 0.2085598437209384, 0.21890556262335126, 0.19535791725138463, 0.2025382229153112, 0.20772101302219337, 0.20767425498521652, 0.2182301242856124, 0.7061983380441192, 0.6089895000595619, 0.5779388121747913, 0.2189220551961073, 0.24502024294760494, 0.21553379472803258, 0.23901509515639707, 0.9172559782567312, 0.8456982518750219, 0.1532117926894363, 0.19446864561052768, 0.19914962788193802, 0.19747838588432864, 0.15955843542792447, 0.16067268663137768, 0.7908911945852293, 0.8983579770717445, 0.20978316980876432, 0.9016278980103425, 0.207491385848818, 0.794352592430985, 0.16548104228155247, 0.12654051568033864, 0.8885951968007126, 0.20783138103340826, 0.1877975040588271, 0.1960561090284697, 0.19455389579241733, 0.1950164475794013, 0.18865813651964514, 0.17972729524186093, 0.19224837799448702, 0.18170934892417734, 0.19081057375372756, 0.08280317560442996, 0.08093390665740086, 0.07674738237688894, 0.08136172382293083, 0.08678307646613026, 0.08859414207069005, 0.09659656154315421, 0.08738435956810531, 0.08547609055622685]}, "mutation_prompt": null}
{"id": "6bf83447-1d15-4538-bb3e-12682c68656e", "solution": "import numpy as np\n\nclass QuantumInspiredDEWithRestart:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n        no_improve_count = 0\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.7\n                    no_improve_count = 0\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.6\n                    no_improve_count += 1\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n            if no_improve_count > self.population_size * 2:\n                population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                fitness = np.array([func(ind) for ind in population])\n                eval_count += self.population_size\n                no_improve_count = 0\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredDEWithRestart", "description": "Quantum-Inspired Differential Evolution with Strategic Mutation Adaptation and Random Restart.", "configspace": "", "generation": 76, "fitness": 0.493383988518826, "feedback": "The algorithm QuantumInspiredDEWithRestart got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.31.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.91518080909269, 0.8960762678439649, 0.9228919131310842, 0.9129367089725278, 0.9118778069518181, 0.9022160400829047, 0.9200772584525172, 0.9223578132422467, 0.9017000609273159, 0.7997427303578362, 0.778060573185301, 0.7830103403814725, 0.8204004671128798, 0.8166339878678764, 0.818512912633852, 0.752588659121974, 0.8215445797884535, 0.8235660089281882, 0.1771544609565433, 0.14452882233193964, 0.14567173803338596, 0.10656420088693086, 0.14472922845678604, 0.1521892710364191, 0.18595632336912327, 0.11609323147978434, 0.15111970979370148, 0.12194003669152187, 0.11361808897213543, 0.11572215439094635, 0.13021142307476352, 0.13086266188710793, 0.11983071339062734, 0.13278203490317386, 0.13297929039470624, 0.15495949363920258, 0.9820751627170878, 0.9724294409693647, 0.9704856065043631, 0.9720035636882802, 0.9663866194688493, 0.9859176053045366, 0.9800115817048721, 0.9845287304932807, 0.969361493832511, 0.8217314981138069, 0.7593209403127776, 0.7916496362314233, 0.7694849475900587, 0.7787814683484944, 0.7687634472995032, 0.7707582874601667, 0.7832103009696553, 0.7938728694212968, 0.9279518947587249, 0.9044180857012117, 0.92981484530706, 0.5086330423549987, 0.6223187167151951, 0.5833877388743138, 0.4983185391958991, 0.8850807434760192, 0.7247017015698398, 0.547234359600393, 0.8050123648666324, 0.7281958179623393, 0.8138381947957957, 0.6050586616659791, 0.6399134227801953, 0.5882533270355585, 0.6897483133741069, 0.8161119765436512, 0.6072007428194793, 0.6176658717543151, 0.6153305454672982, 0.7584216528266088, 0.6830482953196553, 0.4941688132569322, 0.7054632623688684, 0.5646199195757682, 0.1228901363242656, 0.08664263275728823, 0.7039346597251008, 0.4290522433695454, 0.5799841495021059, 0.7258650993780897, 0.5444216908588833, 0.6893895424545411, 0.7558681966847434, 0.7307227018002402, 0.7966766459062727, 0.8074829865026235, 0.835602242505244, 0.7949136765511603, 0.7895413990945659, 0.8225408727098642, 0.7870400114093503, 0.786984259268061, 0.8147268369091948, 0.23473786251952655, 0.08488638357245071, 0.5247906768935058, 0.672491462558326, 0.6886667397151072, 0.4576591571680987, 0.1618037917111126, 0.12521633892917194, 0.12776680604540902, 0.7020902000197387, 0.5356362713349281, 0.6536524991817295, 0.688629304523646, 0.6958845393842594, 0.5970659989582761, 0.6195728480994013, 0.6164402262133462, 0.5918795861142567, 0.8708754825895927, 0.8695371425166505, 0.8534388683897774, 0.8612451493511095, 0.8517388030908634, 0.861577911566589, 0.8703221799281612, 0.8441446293685102, 0.8669790141932088, 0.15571749445015337, 0.12375165598691562, 0.13102243053991425, 0.13875891340568547, 0.13815283994357974, 0.12435190422794817, 0.10076310501495467, 0.18278913204517655, 0.1135380786518313, 0.19797673522058745, 0.21419918827183715, 0.24394693629817088, 0.1602702021830582, 0.18003808360317286, 0.19838072529580097, 0.1495189990117658, 0.17064414576685027, 0.7124414933244597, 0.49753413422444437, 0.42756647853893004, 0.755030226219339, 0.6052277340244588, 0.32129076871876927, 0.573442102736005, 0.5411684584289875, 0.7413971419226579, 0.7698757326314241, 0.6345598218208862, 0.6009206985134792, 0.3221255164150453, 0.37754967922515936, 0.22445081253517385, 0.2570751418271696, 0.4130088676707131, 0.6313200758530932, 0.274315082642243, 0.18635269212678052, 0.21647671337294705, 0.20710864766625514, 0.19139520563771228, 0.20836308686212546, 0.20853225419671695, 0.2073159984618661, 0.2236896202529114, 0.20497178097009838, 0.8297276508966138, 0.21969862280388752, 0.1947818424992933, 0.2122432783888758, 0.2104287489869796, 0.21638946237438583, 0.25197281807962735, 0.2095013990247404, 0.21440909938459485, 0.22083887730598628, 0.1853042573504997, 0.15455396448957148, 0.9282369433756646, 0.5447875390495729, 0.42578139651121305, 0.29042100505674484, 0.16737724866860604, 0.16278506745747012, 0.9179922666124908, 0.2116127523045659, 0.12882971254054043, 0.1696678110101435, 0.2774417101308291, 0.15614753495199163, 0.21271697260615974, 0.5275053041439719, 0.9051584412395858, 0.1893075082642327, 0.1905631199539004, 0.18981725526833448, 0.1836190751290976, 0.19046760041512756, 0.18301149762438296, 0.18423377121611073, 0.18145322536856345, 0.2061168023331139, 0.0809118976282045, 0.07808399887370399, 0.08241018290199331, 0.08832804910434877, 0.08564317291337775, 0.10233797549862989, 0.07603164141220753, 0.08423176959898415, 0.07575298277149245]}, "mutation_prompt": null}
{"id": "33480a50-ffac-4cd9-a02b-b4e6aa7b4d4b", "solution": "import numpy as np\n\nclass StochasticSwarmEnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n            velocity = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial + velocity[i], self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.75\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "StochasticSwarmEnhancedDE", "description": "Stochastic Swarm-Enhanced Differential Evolution incorporates swarm intelligence principles to dynamically adapt mutation strategies and improve convergence efficiency.", "configspace": "", "generation": 77, "fitness": 0.2720358857486854, "feedback": "The algorithm StochasticSwarmEnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.50464216527342, 0.5260842986077947, 0.48646372239522284, 0.4764237774290271, 0.48142372486413965, 0.5038016219576789, 0.5026176736991121, 0.48524000940954015, 0.48294787516654347, 0.08484819013080125, 0.04701490753553428, 0.0736392224680058, 0.08546420610462935, 0.04396486912302411, 0.10613342030175843, 0.08497402483746497, 0.10399780131931691, 0.057139904944899844, 0.11645832779807497, 0.13298704456839627, 0.11304994610247465, 0.10615754314360215, 0.12454464831973888, 0.1316558005177232, 0.13650753678449679, 0.15593847694142837, 0.13344495582797122, 0.1289098119822869, 0.10544926312605185, 0.13116273666733524, 0.10086434201561056, 0.1165052278571913, 0.10525788417698445, 0.13055292927022144, 0.10469474003131363, 0.12661742251038433, 0.9736030177264494, 0.9801516288113706, 0.9772807757366212, 0.9797480877036892, 0.9530156052470791, 0.977343136773999, 0.9785599259503622, 0.9830253486083659, 0.9779167132761586, 0.3291499658111152, 0.3288179112705828, 0.3386792620664605, 0.34749323676332855, 0.3475158855162451, 0.33376898405532174, 0.3264990776518858, 0.3329056182891682, 0.3367234011018284, 0.7160937751418206, 0.6779025951963278, 0.7122148952648009, 0.7187392828819068, 0.7737933855520658, 0.7151960751154538, 0.7220613692298075, 0.7451141540159931, 0.8151793052321609, 0.20246043681314008, 0.21820061810421687, 0.1979595788627555, 0.09871135326699132, 0.21057433218202615, 0.2161856313326923, 0.25625970457507496, 0.20227148052215282, 0.22781605640607727, 0.2380706454788859, 0.21614029578907845, 0.2050671320633478, 0.21476158774541276, 0.21798013186603904, 0.1996368242691664, 0.20415080944690256, 0.20725436328424252, 0.12731903343242523, 0.0858490368624929, 0.0800945528337137, 0.07061980102331977, 0.007627197273960107, 0.07701780205771103, 0.04992055162752218, 0.061369424872064204, 0.008376704607374608, 0.05924837606122546, 0.12843712214324476, 0.164553773977821, 0.18187833170507994, 0.11170803758259862, 0.16036512762075505, 0.18300714653688088, 0.16143630411920185, 0.1709348925793963, 0.13557280208750722, 0.0023566966336422412, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008428650227772616, 0.12244615221078858, 0.11421608203425149, 0.1466334140166613, 0.13601448175839814, 0.14453239257407202, 0.13589227029527828, 0.11018706059676697, 0.1222480744862241, 0.10769719789233945, 0.4492464103965018, 0.46267959162712347, 0.4480721554593595, 0.4449403115107967, 0.4402979600207475, 0.447902239749827, 0.45134376460246983, 0.43076127834850864, 0.43938353346701653, 0.14794006377773616, 0.12891297637592503, 0.10210711467289835, 0.10418252522511917, 0.12917985636033613, 0.13893534966691334, 0.12899412667281762, 0.12238210221323897, 0.11660274382477032, 0.24641246748100043, 0.157292614105091, 0.2701000312868336, 0.20946618832628272, 0.13389776958258448, 0.14795457459409522, 0.16396009758682417, 0.1693997150950105, 0.24158431428169613, 0.3234470809564456, 0.3099095913440084, 0.31721239955071145, 0.31582424783538665, 0.31834610277150954, 0.3350151544276362, 0.31649229551283453, 0.32186631894834095, 0.31535514622682337, 0.25822394983344343, 0.24566946627557418, 0.2479829041203797, 0.25984177159707356, 0.24513489973227642, 0.2553687349087379, 0.26134118426382047, 0.2598678779489334, 0.20305762474760936, 0.22525097023509266, 0.21082420349108943, 0.1921499257086291, 0.18914195675789736, 0.21220650108936057, 0.24340357217521846, 0.211197849868764, 0.20138337344016055, 0.22138761837381737, 0.30387722020787633, 0.20007074330105257, 0.30251583157856954, 0.2916012550196827, 0.20433288568850372, 0.3063327288440856, 0.20839675442138117, 0.2383229358619221, 0.3153412769872903, 0.693942646224562, 0.8062028351182804, 0.18616828373821592, 0.8092161510528788, 0.19946637148486968, 0.19946021971986871, 0.14176653071899692, 0.16333384995688116, 0.17103394612696754, 0.7496684004390811, 0.21090608594279125, 0.21036101164525134, 0.7054406785140126, 0.16312096074458238, 0.6404473384341551, 0.21027180704089843, 0.6813779022855251, 0.6622844544120059, 0.17821130628355564, 0.18252518525622707, 0.1994781969856022, 0.1877046753818168, 0.1820865891198069, 0.18847301618783663, 0.19856211878967245, 0.17799924903411324, 0.17627605318049222, 0.09589679347604285, 0.07990599929238884, 0.0907415237054271, 0.08555358928007795, 0.08017805545976753, 0.08510139084682777, 0.08739331403634709, 0.08449586958154032, 0.0868107449169635]}, "mutation_prompt": null}
{"id": "39b3d8b6-b7a1-4e86-89e4-4ecf4ae8f7b8", "solution": "import numpy as np\n\nclass QuantumStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]\n        self.crossover_rate = 0.95\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 1.0\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.6\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumStochasticDE", "description": "Quantum-Stochastic Differential Evolution blends quantum-inspired mutation with stochastic parameter tuning for enhanced exploration and exploitation balance.", "configspace": "", "generation": 78, "fitness": 0.4794553327667721, "feedback": "The algorithm QuantumStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.32.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.9235123086232035, 0.897638933826304, 0.9246750125332233, 0.9196602009249689, 0.9163010178561242, 0.9167120390539715, 0.9214567436201844, 0.9187274066866454, 0.9125090513475647, 0.8405812072566534, 0.8020164378165764, 0.8209771706107417, 0.8048589870330759, 0.8146884388980886, 0.7939494606981208, 0.05158328777273202, 0.7685030957231496, 0.11115512762274449, 0.16201949307765207, 0.1249645230750771, 0.1530635716923171, 0.1537343923229728, 0.1141409636939219, 0.17585859973211537, 0.09875154469947156, 0.15211035716924648, 0.1123775929936901, 0.05279399169334342, 0.0923057628379742, 0.07755202322540389, 0.11969828534680038, 0.11623000213484758, 0.12043212896104327, 0.10791606367050066, 0.09080352138652292, 0.1417576254513362, 0.9820626549955513, 0.977671439020933, 0.9861904796244861, 0.973009441159092, 0.9763276789684534, 0.9859091846979361, 0.980217797696826, 0.9863743723006905, 0.984349063018145, 0.7921017692936893, 0.7688492558781033, 0.7931790417381286, 0.776121682930053, 0.8070720675367367, 0.7974283169879062, 0.7945518552502284, 0.7962445834166308, 0.8112622243607445, 0.9320111816874602, 0.5267512572410291, 0.8829652622576402, 0.2799925652412598, 0.21442896587684868, 0.9103627068224479, 0.12781493936536903, 0.21907688466705, 0.9000130413726071, 0.6228030320105105, 0.3147760189263863, 0.20580209065826116, 0.8313352620695066, 0.17477089612471097, 0.5456223981060323, 0.6709283316301358, 0.7890902537558154, 0.775433923614155, 0.5429677270937117, 0.6827968298239403, 0.20219136319063769, 0.40228046776799953, 0.1336186615295526, 0.4875006063340447, 0.5957317608675912, 0.24321342154191017, 0.13093210985733117, 0.8070730690454392, 0.7460493346990168, 0.7270870033162727, 0.02759268479328969, 0.7306243639564629, 0.7994255370901622, 0.7033075531313242, 0.7929892165632686, 0.5576246249147845, 0.6515414450080943, 0.8338994113733752, 0.8305238610498484, 0.8255828202039965, 0.8388222067802908, 0.8341704409534216, 0.8192676581213983, 0.8274125715341067, 0.8452619486603685, 0.08350755890589678, 0.106568426045904, 0.43515460099143943, 0.4147498171057151, 0.7218598231446719, 0.25380136711772017, 0.17673246844283808, 0.25754219703755876, 0.239472421834391, 0.5735073794125094, 0.7148272516535459, 0.6585665946494458, 0.729904647141042, 0.7351073921115135, 0.7418407171123561, 0.728185057244895, 0.5531617065379395, 0.5865287597223636, 0.8745248486733179, 0.8758866569332414, 0.8947401140295025, 0.8554186265669493, 0.8654574472924276, 0.878826329672563, 0.8867414122464506, 0.8909690275087995, 0.8377984396554563, 0.1401980534956594, 0.11076719851716244, 0.1255333841840457, 0.13331730746143733, 0.10597403984663578, 0.14147259416413394, 0.13615297801028048, 0.13823083858498197, 0.11589320490037569, 0.2278105728985652, 0.16652117786912768, 0.2042184206148251, 0.15075331660536972, 0.35811131772296845, 0.248001000291875, 0.46578508199788016, 0.20552893901376923, 0.20488727880846458, 0.23728909084782057, 0.5862333026145223, 0.4068135249466953, 0.571098285324485, 0.6048133131676048, 0.5425600866205986, 0.5414483083589678, 0.5479811481889072, 0.48265395265132793, 0.3641516081963151, 0.2813711293740243, 0.36235693668474334, 0.38377433969752606, 0.3176994333666101, 0.2628778589103691, 0.3849000021074016, 0.5808167894466357, 0.6096485189391632, 0.20329916328672248, 0.2257582712666596, 0.19144059660793966, 0.19190580372969523, 0.24410778338536432, 0.2042008618091904, 0.21779545465588557, 0.21046844253916674, 0.20608822463809595, 0.21246345210420725, 0.2063427310827749, 0.20573471706890556, 0.25207113495625577, 0.18502065161861703, 0.2241468326656001, 0.20056719801624223, 0.19717404902540125, 0.2227497905621747, 0.91921182933562, 0.1686621318575775, 0.15431043510313558, 0.17226029135658205, 0.9185400009296826, 0.9223881950101189, 0.2008946355867579, 0.1643578716437225, 0.9441533899709846, 0.9085377260037558, 0.21265930177144443, 0.8639635210490821, 0.9060078744987127, 0.9125878862086787, 0.1550579728810324, 0.8984042721156964, 0.10484510241912226, 0.8980944548392097, 0.18540131617622857, 0.18674386925893138, 0.192942120726456, 0.2033457450757259, 0.18927745459933254, 0.1926054836192047, 0.18153835769730697, 0.19182792297068596, 0.1807566867151954, 0.13930809408610167, 0.09587677717221499, 0.09529043775862789, 0.08816145338312564, 0.08740649131044609, 0.11419829193962339, 0.08333334498108957, 0.09087713771007089, 0.07975642704935049]}, "mutation_prompt": null}
{"id": "3c5da1cb-b8cc-42c8-be44-f6825986aa85", "solution": "import numpy as np\n\nclass QuantumEnhancedEvolutionaryStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 8)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 1.0]\n        self.crossover_rate = 0.95\n        self.mutation_strategies = [\n            self.quantum_de_rand_1_bin,\n            self.quantum_de_best_1_bin,\n            self.quantum_de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def quantum_de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.quantum_crossover(population[idx], mutant)\n\n    def quantum_de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.quantum_crossover(population[idx], mutant)\n\n    def quantum_de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.quantum_crossover(population[idx], mutant)\n\n    def quantum_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEnhancedEvolutionaryStrategy", "description": "Quantum-Enhanced Evolutionary Strategy uses quantum crossover and mutation strategies with adaptive parameter adjustment for robust convergence.", "configspace": "", "generation": 79, "fitness": 0.4770799186566431, "feedback": "The algorithm QuantumEnhancedEvolutionaryStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.32.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.9337112442577569, 0.9292186219628928, 0.9279483431789746, 0.9223673461366242, 0.9274045692141771, 0.9292484893110815, 0.9293357633706331, 0.9158868716293412, 0.9259139799189344, 0.8553005108694327, 0.6465693124315033, 0.8410379316989753, 0.8440589482750147, 0.7386275801368267, 0.612041586391331, 0.393828973423055, 0.8279060325170026, 0.834299582238958, 0.16081163339394422, 0.15934245950533854, 0.12261542879509468, 0.1557797866999876, 0.13531335610726147, 0.16149411746755216, 0.12876332816216385, 0.09657999619468738, 0.10134290185899408, 0.11236606681390726, 0.08402889818170711, 0.09507680960273934, 0.1598273348334558, 0.09603489880459315, 0.15499656385394978, 0.09176258780935187, 0.1395632558424117, 0.10764392500502651, 0.9839574447854591, 0.9813767216176259, 0.9817868073252559, 0.945723289479435, 0.9867900678891822, 0.9756303539480109, 0.9888495590027326, 0.9870951404316313, 0.9851631332931835, 0.7886664178215977, 0.8103629777399053, 0.8041038936524426, 0.8188559550408372, 0.8065382369401872, 0.8111112518937282, 0.7923012697803237, 0.8216355651690482, 0.8262455967085316, 0.9347400023336054, 0.9400820393535704, 0.9296118512681137, 0.9387717083783536, 0.9298313165475364, 0.914351030714118, 0.8902861043737091, 0.23065126448547502, 0.9246003105087552, 0.6557805715156562, 0.704750800162351, 0.6437466244599483, 0.7214631905527213, 0.13558746049616932, 0.5719360035468404, 0.832733558146919, 0.53831916594052, 0.7088461584822221, 0.8555209970076724, 0.8085476757626142, 0.6968931747667129, 0.46136533316840045, 0.36895040792743117, 0.7053092713063918, 0.7916978787526734, 0.5929350343878479, 0.1344125672832559, 0.8297816216426241, 0.17010644748670112, 0.7748865204686115, 0.049330791795686446, 0.45508968973201824, 0.06031864858823288, 0.7630148591629887, 0.25900868394213816, 0.8163939883263197, 0.871207217624808, 0.14995722090267283, 0.85416234349656, 0.8665079010657513, 0.8552258384592727, 0.847713835368924, 0.35053696381798727, 0.8513276674915499, 0.5707639141026295, 0.15652345535248902, 0.11841697311651278, 0.4008404561712401, 0.5022586931866793, 0.19933167871111657, 0.4561742602951022, 0.36174492353676946, 0.3380551301142758, 0.23584793588380193, 0.35598236699387387, 0.44570320449882006, 0.6382193058257261, 0.7374393964211088, 0.7448965420477545, 0.7470764493795228, 0.6674706167607063, 0.45021544574426364, 0.3731162692549893, 0.8796383595657693, 0.8685057511601239, 0.9039203740582831, 0.8135409374038621, 0.8851187625282564, 0.8863355613076439, 0.7457023762571662, 0.856018772566747, 0.8876272084865359, 0.12481798565370261, 0.10767043886461147, 0.1420176355721604, 0.10817970211558636, 0.0696107526819284, 0.11193422249900942, 0.11314593792086669, 0.10729593724517095, 0.14603287181263347, 0.26912729067721963, 0.3720355035698357, 0.17641033655612737, 0.19449238227275023, 0.29310824534520075, 0.23084815541723425, 0.19206072974685517, 0.15802462449938048, 0.22404175567640627, 0.4350442115072024, 0.5408237378291971, 0.4555853465054652, 0.4506364268691605, 0.42382455167014044, 0.5362405439251463, 0.4801359024080507, 0.8171345428322322, 0.5166975486209349, 0.4998845224885292, 0.20067833776294908, 0.520180444832208, 0.47388308565801585, 0.26168666534456475, 0.3701544060834886, 0.35201641187270094, 0.3635389752080145, 0.2913271918456253, 0.1995631000776844, 0.20499299298720375, 0.2648025411649715, 0.1950869982614909, 0.16194021758342347, 0.18218690239518365, 0.25354181540262666, 0.18547672582062147, 0.20486037338089158, 0.20121154398234742, 0.2083459659684268, 0.17835285283077096, 0.1825339910135233, 0.1865222488414119, 0.2247453696946099, 0.21190075773978523, 0.21699382093385888, 0.2244688578496059, 0.9573224463676793, 0.9451547001970856, 0.15385600669837074, 0.9612734908718116, 0.20055062809135848, 0.1995103883942475, 0.14246138590188073, 0.16962145649146254, 0.1755273343484871, 0.9213657020432792, 0.21345623638651523, 0.1251010832804904, 0.9211230564282606, 0.16900950483335386, 0.16774357956873298, 0.21270171769883273, 0.10446922669240466, 0.9334965860471144, 0.20049535755019632, 0.20285212729680047, 0.2069703059107162, 0.19303637296519705, 0.22987697710311428, 0.17360547191952935, 0.18418080638421275, 0.18303822818736304, 0.2076192038941026, 0.08165982347294065, 0.09315680714659524, 0.12633060974941712, 0.08487645840730729, 0.10114724112991802, 0.09707855534613063, 0.10491912718747043, 0.08815496059055328, 0.09164544778522066]}, "mutation_prompt": null}
{"id": "86092eb2-38fa-41a7-8a6d-4f57bc0ce983", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)  # Increased population size for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.5, 0.7, 0.9, 1.2]  # Adjusted scaling factors for more aggressive exploration\n        self.crossover_rate = 0.8  # Slightly reduced crossover rate to preserve more diversity\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,  # New strategy for better exploration\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies)) * 1.2  # Increased initial weight for more exploration\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6  # Increased reward\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.65  # More aggressive decay\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):  # New strategy for diversity\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b) + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "EnhancedQuantumInspiredDE", "description": "The Enhanced Quantum-Inspired Differential Evolution employs dynamic parameter tuning and a diversity preservation mechanism to enhance exploration and exploitation balance.", "configspace": "", "generation": 80, "fitness": 0.3572509806765851, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.7772682353884974, 0.7794206401732575, 0.7651595497239279, 0.7930736785037872, 0.80540161078148, 0.7608418151136513, 0.8061252745035918, 0.7840131336662477, 0.7801469317701605, 0.5740318155778937, 0.5842155568649103, 0.5699693102152811, 0.5213197926656785, 0.5663530507733329, 0.5730113795700134, 0.5880374940842059, 0.6071379877692424, 0.597947783922347, 0.10146830404703977, 0.09765720727680405, 0.10490337531389438, 0.10785172749510585, 0.1167069524364841, 0.11251599107869914, 0.11841614220263874, 0.111342057848267, 0.0990815729151665, 0.10829003169072748, 0.0939041968075287, 0.09146659943583457, 0.11879886642938475, 0.09421828178904101, 0.09380455236264917, 0.1034078602640307, 0.11437868339191659, 0.10088063335104325, 0.9784299761929129, 0.9765606975723062, 0.9783172094801775, 0.9735591614663253, 0.9834082658882471, 0.976464176883023, 0.9834103587569147, 0.9888118959947683, 0.9842210269650731, 0.386081028981779, 0.4118898967725285, 0.3679079659581094, 0.39225704974367814, 0.345325781611175, 0.40267041214476407, 0.3090948131566401, 0.4286605491762687, 0.3839466825505031, 0.7122603833603511, 0.7384735775290958, 0.7161098185173687, 0.7721521230679103, 0.7558760807388127, 0.7312275536817422, 0.7259010848702905, 0.7043493033641715, 0.7701389226692714, 0.4279029893058288, 0.38608920011988035, 0.33711535143032445, 0.3943907951198451, 0.3366792563475477, 0.4702538047861532, 0.12070025784927241, 0.3951325120621887, 0.4526191347841234, 0.2609556433953155, 0.32382458171179873, 0.28736185515541046, 0.4560494702256367, 0.40731374357572125, 0.40989914101521285, 0.4029626363492481, 0.4090545871009271, 0.4484971126178985, 0.29941698240674064, 0.3023202260293253, 0.24253675399870822, 0.26288314287209025, 0.2169375283936591, 0.24970323404248074, 0.2778791288282275, 0.2866228005527157, 0.25021677104223006, 0.41347545206345027, 0.4014042000407235, 0.4371737721441973, 0.35614245076148865, 0.42171360452022155, 0.37467654841745357, 0.35004087927300975, 0.39882382290654483, 0.3636515058721843, 0.0753598391392516, 0.14404619019652087, 0.09711563496960696, 0.15696856882882182, 0.09462982923903218, 0.12068464423495406, 0.1749258774897573, 0.14136394671739239, 0.12833355516690337, 0.267009297019815, 0.25502918413133413, 0.255496878073022, 0.2781725183636993, 0.2673648779904335, 0.2747110925928168, 0.27079741774737176, 0.25968550639097165, 0.2847717769802819, 0.6522140217844097, 0.6528753593223158, 0.612277700792228, 0.5858180328372031, 0.6098999279366972, 0.6465869958229602, 0.637305489275386, 0.6117736728248282, 0.679679148028378, 0.0929799833561008, 0.09853193114077252, 0.09027579878373959, 0.09226913013371418, 0.089516729642933, 0.10245577321933852, 0.08986253587242754, 0.09146531413996384, 0.10589567387433396, 0.1533403116974088, 0.13338706648905352, 0.16547557206596208, 0.13814998313725757, 0.1484077536698415, 0.13689317186549288, 0.1771207596721488, 0.13055382878428445, 0.16125237140533244, 0.37058443689889387, 0.42168701639935224, 0.38543739269969646, 0.38680923980600124, 0.33089266667349704, 0.3686013696687567, 0.4299042032857969, 0.42281560758504433, 0.4098499575814941, 0.2621421102613435, 0.29109696039893895, 0.2864402261594008, 0.2817998161151498, 0.3097554695871423, 0.18913225057874483, 0.34213584051707835, 0.3023198425399869, 0.2839989870234456, 0.19441386338384103, 0.19531764145707686, 0.18649142374433292, 0.1854370212111407, 0.208402741076549, 0.1914700764836521, 0.18906861086286508, 0.17861985073655684, 0.1862910417157525, 0.18798448641822285, 0.1817024125250175, 0.1795791658167618, 0.18198244747639147, 0.1983405929960974, 0.20352080565626052, 0.19697915090886187, 0.22286813069251743, 0.17977621412571843, 0.8316672603060373, 0.19709182566663608, 0.8160279094361619, 0.7836018448587783, 0.67700899951196, 0.1636006096750653, 0.4515507392135204, 0.17244174485302377, 0.5554060785892259, 0.7149001848164088, 0.20710063074677454, 0.5207410528339413, 0.20116564202532028, 0.1988539209946778, 0.6697606071700679, 0.15032456907039393, 0.12654162866459884, 0.7203277205402974, 0.17455670483807972, 0.18704573406993075, 0.17731726170003348, 0.19649195015586218, 0.19614793171354827, 0.1963674289852838, 0.18061134682116275, 0.18215754907131998, 0.19267002133663347, 0.08930499356741961, 0.08128204942825445, 0.07838716504738219, 0.08908871922424022, 0.07694772183477983, 0.08146253795996239, 0.07581624885061444, 0.08450504992841379, 0.07906394730693989]}, "mutation_prompt": null}
{"id": "5e2adade-8a90-4c65-83df-5f4468e49f7b", "solution": "import numpy as np\n\nclass AdaptiveQuantumLevyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.beta = 1.5  # For Levy flights\n\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_levy\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_levy(self, population, idx, best):\n        # Levy flight mutation strategy\n        levy_step = self.levy_flight()\n        mutant = population[idx] + levy_step * (population[np.random.randint(self.population_size)] - population[idx])\n        return self.binomial_crossover(population[idx], mutant)\n\n    def levy_flight(self):\n        sigma = (np.math.gamma(1 + self.beta) * np.sin(np.pi * self.beta / 2) /\n                 (np.math.gamma((1 + self.beta) / 2) * self.beta * 2**((self.beta - 1) / 2)))**(1 / self.beta)\n        u = np.random.normal(0, sigma, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.abs(v)**(1 / self.beta)\n        return step\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumLevyDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Levy Flights to enhance exploration capabilities.", "configspace": "", "generation": 81, "fitness": 0.499983014129126, "feedback": "The algorithm AdaptiveQuantumLevyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.50 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8770664325371007, 0.8777071512926066, 0.879743865016446, 0.8847609225217143, 0.8846799589531025, 0.8852324351751426, 0.8841662823575248, 0.8756680327364816, 0.883423378210103, 0.7815247108061126, 0.7671459938129527, 0.7677474453123853, 0.7611264926793123, 0.7914807863783179, 0.7654583173526869, 0.7810658904719971, 0.7562670134289506, 0.769385121476863, 0.14643016720675517, 0.30777637877737885, 0.12693587703428533, 0.16684185495789028, 0.15061290909417424, 0.12650119865241738, 0.14990087448670453, 0.5865894101893684, 0.14800962323301992, 0.11949460005494872, 0.13578941617841356, 0.13574359707663808, 0.14335900461015094, 0.09255181698891135, 0.08855083803126762, 0.12711836908050955, 0.153004406553777, 0.10621592095918808, 0.975977586950783, 0.9757096537064038, 0.9856455830529219, 0.9732632908296078, 0.9799459815306216, 0.9532737805991918, 0.9849976486425495, 0.9856940373917432, 0.978103010100398, 0.677293213262216, 0.7014985483939352, 0.6992982650158873, 0.6721586030945039, 0.6730822139686609, 0.6837813078304956, 0.7388255380233939, 0.6991821745575523, 0.6606025325415761, 0.8760622470933054, 0.8711563481999023, 0.8922392089704538, 0.8974353655771174, 0.8883746253022868, 0.842190509432154, 0.8483703156523372, 0.8775483213465729, 0.8127244939310918, 0.7384170135547903, 0.7029664997747083, 0.6580956699348, 0.6664119842413196, 0.64426613466036, 0.6610645760164138, 0.6339187344966326, 0.6413858619521715, 0.7323910313308877, 0.5720156326146714, 0.6480376642203889, 0.6764938165495057, 0.5420104733100075, 0.13048899403524805, 0.7245892155552898, 0.6433939740536323, 0.4790597750583456, 0.6442285904841194, 0.6207325474526333, 0.713545036697381, 0.661162930586991, 0.5492255457056783, 0.6606306064699595, 0.7436256693862471, 0.7158724827537187, 0.7134924200670889, 0.6757795523062068, 0.7592665802174761, 0.7534861345520616, 0.7773034925463158, 0.7371917545114484, 0.748583939692514, 0.7285375124734499, 0.7121910981783308, 0.7647022646560782, 0.7658723201432122, 0.2704820560220541, 0.3928540861179035, 0.6691452576816679, 0.5287665965492381, 0.6315182490181248, 0.4575449411016905, 0.4036800767122001, 0.15656192564974591, 0.2527124273751765, 0.6182741465717051, 0.5432466243575331, 0.616095302058987, 0.6102689664597694, 0.6271238407082778, 0.6175152757053797, 0.5831110446259957, 0.5748316333882244, 0.6133591987149452, 0.8199195556224805, 0.8367010390103692, 0.8339220497011033, 0.8268070257004261, 0.8331819755882341, 0.8407058575314668, 0.8373857589292173, 0.8203837316336535, 0.8291435084953207, 0.15996091494089648, 0.12410214267446229, 0.10675525815694709, 0.1356710632271565, 0.14399925444575523, 0.10359852995197649, 0.08806124096842927, 0.15558640287556136, 0.10756261784206367, 0.21507474361842416, 0.42720603024466286, 0.5558160018307715, 0.23345566719837485, 0.1505948641694277, 0.24195925566679066, 0.2403869249849797, 0.20914420632803576, 0.17804124162685786, 0.5770960378431524, 0.5016751067656662, 0.5191266115326664, 0.6285138413917966, 0.5544510064850909, 0.6287913659688518, 0.5746922194348143, 0.7026317630038783, 0.5028487760449283, 0.2595829645297705, 0.2796490024575321, 0.3405079579754581, 0.38899841436149085, 0.5078659284199882, 0.4915195289130504, 0.5501282687500564, 0.5268589593956639, 0.5438222032683371, 0.20494872369696593, 0.19601597607390686, 0.19489738546571855, 0.20544144633742412, 0.1983038927492281, 0.21198176500412236, 0.22855000619791854, 0.22259484190226053, 0.21883152453136034, 0.22454050914790036, 0.23825233030310655, 0.4880704867240697, 0.21242713728453744, 0.20794137321830575, 0.2425189069079724, 0.1861766546804483, 0.22933282919844244, 0.2384901276880359, 0.1850030254497016, 0.1716898434924038, 0.16349601247450285, 0.818353809152048, 0.19918225676708612, 0.19920525662680033, 0.8944704060453182, 0.16876039326449466, 0.1777520486792511, 0.8944687456084501, 0.8777977741647771, 0.12673657870753618, 0.7968302476893232, 0.8825761594980859, 0.2083797091379299, 0.20736214647270157, 0.2107178468055374, 0.21080900872402586, 0.19300303562763788, 0.19612517054958467, 0.20857365763014735, 0.20903871762558357, 0.1926934615872713, 0.16947167625718484, 0.17979341232049173, 0.19707685056774837, 0.19302174552743434, 0.09093585522117353, 0.08558001755063893, 0.08317257234610265, 0.08724518282989735, 0.08064869064968949, 0.08413827513690464, 0.10322101495998537, 0.09107154523682204, 0.07768608714721903]}, "mutation_prompt": null}
{"id": "2e505713-77b5-4b63-804e-483139a7e4dd", "solution": "import numpy as np\n\nclass QuantumEnhancedADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)  # Slightly larger population for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9, 1.2]  # Extended scaling factors for wider search range\n        self.crossover_rate = 0.85  # Adjusted crossover rate for exploration\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.diversity_threshold = 1e-5  # New diversity control parameter\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            diversity = np.std(population, axis=0).mean()\n            if diversity < self.diversity_threshold:\n                population += np.random.normal(0, 0.1, population.shape)  # Introduce noise to enhance diversity\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEnhancedADE", "description": "Quantum-enhanced Adaptive Differential Evolution with diversity control for improved exploration and exploitation balance.", "configspace": "", "generation": 82, "fitness": 0.46143757005019076, "feedback": "The algorithm QuantumEnhancedADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8721788421137893, 0.8617227410446191, 0.8668174110417578, 0.8769988598923408, 0.8528894690939706, 0.8787164130808943, 0.8723985176701334, 0.8574279247154242, 0.8655261649874004, 0.7474295233714179, 0.7465066502535731, 0.7414802716579567, 0.7136707428032072, 0.7635179625961387, 0.7605332386339598, 0.7438861090669988, 0.7568056655912858, 0.7279763706364846, 0.18194225701578093, 0.15078325863010467, 0.16869010682558094, 0.11262791579247422, 0.14745793334925272, 0.12579949308226712, 0.1625007715090927, 0.17236228925055241, 0.44531401702570617, 0.1455278989160106, 0.13833982790862775, 0.14679226857450556, 0.11022406447626176, 0.14747549508234825, 0.16716377067567334, 0.14215769996344296, 0.14047874269581884, 0.17583959721901288, 0.9771552900993496, 0.9630726778475827, 0.9804878368786497, 0.973893121631022, 0.9681070553370198, 0.978046463010227, 0.9811793917668753, 0.9739160565359964, 0.9809262694989732, 0.5977831567806248, 0.5822679277699745, 0.5984960210393151, 0.6051556733379976, 0.6207181712892067, 0.6464003802380818, 0.6558760368274443, 0.6140712906927295, 0.6513473769328684, 0.8632298156811482, 0.22571592523924422, 0.8350837231447443, 0.8890976891299854, 0.8771851175531411, 0.8620553174203587, 0.8667939274218752, 0.8573728942495011, 0.8831127564527667, 0.669156308796029, 0.5740421710312691, 0.5476986882211748, 0.12963924716339248, 0.7263503812247394, 0.6321532923331774, 0.6051431448581474, 0.6433598619424286, 0.6709401017046044, 0.5820848171009921, 0.5581258270860027, 0.12864287944211084, 0.5354439267628139, 0.6567939107404803, 0.6851956461472959, 0.5178203162428168, 0.5659487692600251, 0.13164453410315513, 0.5944059255736509, 0.6232149436606045, 0.59613151024281, 0.6226240849611651, 0.5679908624550871, 0.020297411416185573, 0.6062994163360489, 0.5567831970185985, 0.5729722948649227, 0.7361131449968896, 0.6624334156468349, 0.7120577707926051, 0.7056970657384447, 0.7188563300270798, 0.5931370886089926, 0.6977479970821425, 0.6902128111826904, 0.6862588075073018, 0.14389681952351507, 0.4322612800310399, 0.21632381713279514, 0.41272359108487466, 0.4892095538227246, 0.13149308512903446, 0.11849418576991488, 0.14286696283448985, 0.4058591129352964, 0.4826357579081709, 0.48299948110219815, 0.5061643341203068, 0.5026779488131852, 0.5369797729894301, 0.47418226886618076, 0.5306126961129471, 0.4832774466281149, 0.4746125926329171, 0.8083060366066496, 0.798160519820927, 0.8229612584978208, 0.8040631038289109, 0.7963792879741585, 0.7813141244721951, 0.8082211456559684, 0.7953470073932825, 0.8204359986675761, 0.11624699850080411, 0.13254013570618428, 0.14695051912183243, 0.12207026690326006, 0.11852592898749625, 0.12769905780349233, 0.12495812630811765, 0.11923039809768832, 0.11132818566997504, 0.1547920693412711, 0.21245255300182886, 0.5047929783709058, 0.2548290832536517, 0.14040535389184405, 0.20684672987234853, 0.229817460280328, 0.19157842357184107, 0.31526603053674185, 0.46917613418001125, 0.4053210193347815, 0.2900540399725543, 0.546667655335175, 0.49289513188000034, 0.3165127955361138, 0.529263843194105, 0.5670591137090867, 0.5308329272417721, 0.3240109389122743, 0.45554715740650076, 0.4455963409974574, 0.37377506681071193, 0.28117948629890555, 0.36154313215159395, 0.42960366674533756, 0.4769675189315913, 0.38080111972961794, 0.22248483283834708, 0.19795073122702767, 0.19679508632469933, 0.21856370917403767, 0.18876349493763633, 0.21553670962837657, 0.1924844419460291, 0.19188348763815444, 0.19238496033620323, 0.23974250329943736, 0.22025730156399093, 0.22087822454836137, 0.2176750532132301, 0.19649714489171843, 0.4401382387973646, 0.20087302045505617, 0.2347502106843422, 0.19289212578582315, 0.1552918021614027, 0.1669976138670154, 0.1635459260025235, 0.19915462941857764, 0.19685733638985725, 0.1650426872920261, 0.8572347101284152, 0.8806822492545667, 0.8968723104204214, 0.8550321413374455, 0.840823513141024, 0.2023954875132331, 0.8679374375348411, 0.16878825594766167, 0.652645332353867, 0.10480325077264951, 0.20621535682786296, 0.8813850325656769, 0.18101621457833228, 0.19057442885011877, 0.19967355102546125, 0.18238256443742307, 0.18257004739401117, 0.20529149039087613, 0.20828321539105932, 0.225348325375348, 0.1859795964940707, 0.08223922902418779, 0.07655144798205782, 0.07897334647064158, 0.09811494304845148, 0.07947474674422628, 0.07784962114918603, 0.07201431609176745, 0.08176157077338753, 0.09063799513660231]}, "mutation_prompt": null}
{"id": "2a8ada5c-9d24-4d74-8fc2-b492f5083f45", "solution": "import numpy as np\n\nclass HybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = np.linspace(0.4, 1.0, num=4)  # dynamic range\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.uniform(0.4, 1.0) * (b - c)  # dynamic scaling\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.uniform(0.4, 1.0) * (a - b)  # dynamic scaling\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.uniform(0.4, 1.0) * (best - population[idx]) + \\\n                 np.random.uniform(0.4, 1.0) * (a - b)  # dynamic scaling\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "HybridDifferentialEvolution", "description": "Hybrid Differential Evolution with Dynamic Scaling incorporates a hybrid mutation strategy and dynamically adjusts scaling factors to enhance exploration and exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.48634871551252606, "feedback": "The algorithm HybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8579960804527177, 0.8559478306884385, 0.8689157390165779, 0.8738903694388322, 0.8727101808191065, 0.8800129350604605, 0.8694908064969926, 0.8801044945523109, 0.8667237606115118, 0.7519345269220895, 0.7528035060557723, 0.7641332534330866, 0.759713573789303, 0.7650588272896146, 0.7594111079220817, 0.7465058337197474, 0.7757744283349138, 0.7483074098027958, 0.13835043504181943, 0.13852328522307766, 0.4218859594107084, 0.1775503307803854, 0.14929196451119642, 0.1573597239131821, 0.6350328179529542, 0.14839563750899232, 0.16133245265354124, 0.11408788712649587, 0.10514656738239059, 0.14272562825005441, 0.11377716957200412, 0.16157076503348144, 0.10926408913578578, 0.11635221068319279, 0.14081892189179912, 0.12346030804476849, 0.9852174394862169, 0.9135435293181989, 0.9775736982257158, 0.9802335957364244, 0.9805512562069522, 0.9683449654981575, 0.9860774280658429, 0.9812888732917256, 0.9806955830005029, 0.6896108465097279, 0.6933611971754353, 0.6705864960446659, 0.7012750378798223, 0.7139280878468512, 0.6856504669544201, 0.7027609113468639, 0.699357654220319, 0.6998400895600753, 0.8786808271336927, 0.8699928922541597, 0.22632640050895303, 0.8938229048083678, 0.2732248637972432, 0.8651668965148824, 0.8871550586412793, 0.8612093641837966, 0.8665309483430735, 0.726068576010169, 0.6747985412292021, 0.6429632993752614, 0.5727695914760469, 0.13233736406687346, 0.7446075219348702, 0.6757725371904764, 0.6046027976657751, 0.6261717885306621, 0.6675544676137132, 0.6400955565865816, 0.1277354830738282, 0.13114772667540675, 0.1306157626481409, 0.7134814056648302, 0.6906092830800674, 0.5403705420731895, 0.5195438162676764, 0.6399664315153808, 0.6231210359106311, 0.6450057595448926, 0.6737475813403013, 0.6274860458477115, 0.5856376929588396, 0.6383522301995096, 0.6507224407997918, 0.705943178618504, 0.7239957192767058, 0.7448516494966542, 0.7339439792860509, 0.7398951808838405, 0.753481043946762, 0.7636342363882803, 0.7492749504109274, 0.7685611534842717, 0.7603427040861827, 0.38116311418170856, 0.07812559678646813, 0.19784981203144603, 0.6100017260224693, 0.37105698521105246, 0.34185400661763354, 0.15308445135700077, 0.45473828894934654, 0.3777991450068131, 0.5654054029751459, 0.5977401376620726, 0.6006181250984369, 0.59398248584154, 0.6068025438691149, 0.6014800407604135, 0.5682952667106749, 0.5948680352830333, 0.5890378516166421, 0.8302310336806321, 0.830252827410696, 0.823031023084267, 0.819840154185641, 0.8378078426065434, 0.8286444548724307, 0.8240041565911391, 0.8351533641854001, 0.8266494956351603, 0.11144271405106865, 0.12234600012383323, 0.11685137832416825, 0.1489642379970486, 0.10410559717713608, 0.1133328087821277, 0.10945716625631452, 0.13743540358191297, 0.09944365535518229, 0.17120624191804568, 0.2673325232004793, 0.33971457148951834, 0.20297235932077262, 0.26491546700343305, 0.3062888686262055, 0.2433281857919164, 0.20615631116831168, 0.17933100043078287, 0.5638558136795646, 0.6221230441581627, 0.6032759253462732, 0.6317311257245958, 0.6237322438091994, 0.5671207538608329, 0.6581248118516261, 0.6527610095164254, 0.5796634472051254, 0.5148782951203981, 0.4677557232670996, 0.34924220900938163, 0.5972073568651883, 0.4622140788671474, 0.46892308296261254, 0.49086464514252737, 0.46698097815432227, 0.4538220505239503, 0.22487207803367293, 0.19806801920032435, 0.22243148462206874, 0.2002800544524953, 0.2141087215595069, 0.21233893257076308, 0.1868230091276567, 0.20500675078959607, 0.21508997850093248, 0.23849108341654246, 0.20458749272068255, 0.24088578485923173, 0.5007370624820703, 0.2164265708237877, 0.23884901517270285, 0.20325776645225713, 0.20515441839139825, 0.2077891088724242, 0.18480358598064772, 0.8684985776689113, 0.15317396055125976, 0.17746194936394166, 0.19923333381729535, 0.19763146628970485, 0.8652236371530024, 0.17545826492948802, 0.8946185187522072, 0.8514721608620999, 0.2098395267484977, 0.12610551478216547, 0.2078760814238343, 0.8519754968859758, 0.12430190786649387, 0.21218391823654148, 0.8884474644633666, 0.8721813448389681, 0.18773149696635827, 0.2146836919577525, 0.18270378489835393, 0.18373128700113472, 0.19750894314178424, 0.20540511001225792, 0.17104266577948923, 0.19345490042186464, 0.1870434271232312, 0.09568004590696655, 0.08580723393422718, 0.07181269542426394, 0.08017225775293224, 0.10709426117107701, 0.0707569088571256, 0.0746958937844191, 0.0816884086804186, 0.08062983510029442]}, "mutation_prompt": null}
{"id": "194e39cf-6e70-431b-bff3-68b306873422", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.2]  # Increased one scaling factor\n        self.crossover_rate = 0.8  # Adjusted crossover rate for balance\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.45  # Slight adjustment for strategy reward\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.65  # Slight adjustment for strategy penalty\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum-Enhanced Adaptive DE uses quantum-inspired adjustment of mutation scales and crossover probability to refine exploration-exploitation balance.", "configspace": "", "generation": 84, "fitness": 0.4597199385874679, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.28.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8763635577999359, 0.863818126611937, 0.8763751598399633, 0.8778387892578972, 0.8660126597487772, 0.8660020659737127, 0.8598272598437207, 0.8665447339922897, 0.8754568246858597, 0.7660402040093959, 0.754786773358644, 0.7623179931853407, 0.756123852064442, 0.7513640185504016, 0.7630900038255267, 0.7492372132251455, 0.7519214590912234, 0.7621525276753026, 0.13976987007121056, 0.13993511347103904, 0.5522221716482741, 0.13715682620725456, 0.1579114777557279, 0.14158395418286585, 0.17209002701840181, 0.6250325737397597, 0.16782743831624958, 0.16154506214751307, 0.14186781666206205, 0.14423458789033317, 0.13647871048403393, 0.14204980805538747, 0.14842913258943735, 0.1157765115982351, 0.15664553254816804, 0.1605887649921126, 0.9843921155731868, 0.98489708446645, 0.9805881212020395, 0.9786339109173988, 0.9844589510408771, 0.9839558213174568, 0.982126259832901, 0.9847081902395187, 0.9732495226368774, 0.6433872949612973, 0.6144805512905194, 0.5167470016920848, 0.6254453830455184, 0.5502340415851692, 0.6094307103988879, 0.6327736101604879, 0.6106816074931828, 0.6278235171421245, 0.8673973221773996, 0.8111519003486171, 0.8261224689964135, 0.895455335662562, 0.8750315184203715, 0.8562037526332497, 0.8415633613459654, 0.8414777957584394, 0.8740458211879869, 0.6258141562849493, 0.6644080515522752, 0.6154169314869123, 0.588089184779316, 0.5968953126271801, 0.5654303697217742, 0.5719220222087755, 0.5982261804922977, 0.1300051484537127, 0.5232293009681723, 0.6222367596758414, 0.5013666020260589, 0.13285273977588163, 0.5909209343539976, 0.6245852598106318, 0.13285804312247562, 0.12232623288616506, 0.5261234052169567, 0.5155032013018295, 0.5526119526571436, 0.5588530219895536, 0.36169904332744085, 0.5401272844087048, 0.5144002647499268, 0.5747253691427363, 0.43982797036624843, 0.5383052012934431, 0.6462394900571893, 0.6182434970815628, 0.7081325803811409, 0.46342664248411625, 0.653191830599372, 0.6224201487371064, 0.6982536664642369, 0.60691171932879, 0.6864624625361224, 0.43202088880074185, 0.119872627456717, 0.2064167315775305, 0.479976298574032, 0.45989420270379955, 0.44945314641156564, 0.23365967431355528, 0.3567251594378572, 0.17033436887828834, 0.45610508942046735, 0.4645636132983717, 0.40664972758186246, 0.4810341332419048, 0.4811503023237672, 0.4447575264506367, 0.39813972891192173, 0.47358797695540256, 0.39463963793682055, 0.7849692029168943, 0.7738932303852011, 0.7959957662873427, 0.7945147972674336, 0.7937493831991055, 0.7906647335719051, 0.7918030188926778, 0.7953559556722618, 0.7724663118638059, 0.4010233667035622, 0.10744831180311232, 0.10445024792805913, 0.12988966147130632, 0.13042513934638666, 0.10478222544374693, 0.09801135533680028, 0.08781396503771377, 0.09852805819994825, 0.23724257448344876, 0.14200660610182803, 0.1641117354109496, 0.33577796179235975, 0.23000623464669323, 0.3275797008727904, 0.1437764069772669, 0.13411829531396724, 0.1453959651678539, 0.5685260234571419, 0.40977618357712275, 0.5264259336768959, 0.5244648093984119, 0.4835794056472441, 0.5156019866513238, 0.5230018050202263, 0.5831307677960276, 0.6052564234520645, 0.425613081499414, 0.4188562469121304, 0.2738405581728911, 0.4211259052441656, 0.39683584747345213, 0.40484762145931263, 0.46053392982451047, 0.4598217405956475, 0.43999728951672845, 0.20514141413017584, 0.1972406096277627, 0.19499649613838632, 0.2215843290498185, 0.20676562099494022, 0.21855715335318104, 0.22044827085725482, 0.21220706406069645, 0.20768964681122937, 0.23126731923425492, 0.2362040513223752, 0.2206858653381386, 0.19831104473275996, 0.19994868908346375, 0.19795678179262333, 0.6379177023669074, 0.21737563094202728, 0.2291226765666048, 0.19169860451963527, 0.1670959160760931, 0.1540110223444976, 0.8595440319454677, 0.19710366895034814, 0.16563617063545555, 0.8686606429370769, 0.8509581262464392, 0.8653427551199366, 0.8544844268135545, 0.21085718326587954, 0.15491427566995042, 0.16848180489545195, 0.8022622076991061, 0.10401110018460435, 0.21213243216654087, 0.15354456215670453, 0.8742668445994775, 0.17508314517870915, 0.18461691058037455, 0.19702352853104532, 0.17737505834436218, 0.1919517967198192, 0.19001062508637578, 0.1800723713746436, 0.20112331460411437, 0.18254212395624814, 0.08609159517005793, 0.08492129576471286, 0.08858737381622772, 0.09551161116842033, 0.08128269110344122, 0.0885281445072591, 0.07674621734536446, 0.08696535830261742, 0.08170726897149927]}, "mutation_prompt": null}
{"id": "f8715505-5358-4b0f-89d4-95fcdff40458", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "b3a51811-9568-46f3-9d8f-1ab4ad9b193b", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)  # Adjusted population size for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Slightly modified scaling factors\n        self.crossover_rate = 0.95  # Increased crossover rate for more mixing\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6  # Increased weight increment for success\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.65  # Slightly adjusted weight decrement\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumEnhancedAdaptiveDE", "description": "Quantum-Enhanced Adaptive Differential Evolution integrates quantum-inspired strategies with adaptive mutation weights to enhance solution exploration and convergence.", "configspace": "", "generation": 86, "fitness": 0.47999396253776333, "feedback": "The algorithm QuantumEnhancedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.31.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.9009207547304721, 0.8894121306005615, 0.8924278083669002, 0.9002497458867286, 0.9035105090185265, 0.8928064302246291, 0.9065755724884207, 0.8956406963274759, 0.9018430604794985, 0.7726665926151426, 0.735133007413437, 0.7708200632839977, 0.8108293801679507, 0.7959879872742396, 0.7697864395166661, 0.42864317630659876, 0.8094517944243191, 0.785894877815695, 0.1081238225564577, 0.17365686545367276, 0.14559829912044497, 0.153883139450115, 0.3825532834472317, 0.17426031527356522, 0.14959580130737582, 0.13054495297342616, 0.14298185155272036, 0.11175134263619113, 0.10841019850241063, 0.11564088663553962, 0.17808252680696046, 0.12102923624887407, 0.1030907720440033, 0.10687096994953826, 0.11274951943864364, 0.12247433207513136, 0.9736783944043463, 0.9729816265263832, 0.985416381745649, 0.9730993508822073, 0.9626933302626002, 0.9829607501094378, 0.9542820592550143, 0.9749482590520798, 0.9797594034081566, 0.7587839305995008, 0.7490544909786598, 0.7590276084964438, 0.7476447979231367, 0.764765775185694, 0.7455930007529002, 0.7645018187744476, 0.7524566591192079, 0.7547097243961671, 0.9040693572271956, 0.9272237733048341, 0.9098310988480843, 0.8893110180393103, 0.9091625586691451, 0.21138694015396564, 0.24009402414603942, 0.9067476318910138, 0.8864932719588453, 0.6314338844273963, 0.13333716108206595, 0.6899063633362936, 0.7888849447867176, 0.3081101755226511, 0.3146471924529104, 0.13270626138006558, 0.5492331101470294, 0.4552594633016164, 0.8155208562335892, 0.13490497591006456, 0.7545636767077994, 0.5941003316529792, 0.477480730358962, 0.45223976423334633, 0.5567326253868613, 0.6408810263432607, 0.1312613678767992, 0.7340651646252503, 0.6896064293607476, 0.21710862822509647, 0.7684611392231778, 0.6454235036970202, 0.09528508484015452, 0.24302354473017207, 0.741708425168262, 0.7793781794578196, 0.8366499251433434, 0.8013029036141835, 0.8368252772361391, 0.8175055062993795, 0.7944998737186897, 0.7871736392135924, 0.7228294019875869, 0.803121357815504, 0.8166866587263805, 0.22974296145816886, 0.07721419506056104, 0.09466668217377405, 0.19842552647740186, 0.7095089818162146, 0.20319000883369098, 0.13972337271252544, 0.31220002021125837, 0.18047839924168296, 0.5825257834518026, 0.6719855869460755, 0.603715727836901, 0.7069565058385896, 0.5855558398076057, 0.5930862808725337, 0.5567887794542622, 0.6566723468907281, 0.5900350468626222, 0.8580657698727004, 0.8578286706859972, 0.8700378229837833, 0.8573564454867005, 0.852126975642217, 0.847636843015505, 0.8662233045685159, 0.8485283977437605, 0.859905140178281, 0.1551430251575081, 0.0866895116913371, 0.10797484191285855, 0.1325238097247946, 0.12368545254204455, 0.1535445437608709, 0.14020674573477587, 0.15058200108090192, 0.7709682744550783, 0.7236965335187995, 0.18129474230799092, 0.24447469409188116, 0.22076650448901758, 0.2016255258009566, 0.36003706018724313, 0.19342421389524733, 0.27759179164843506, 0.18695701409612686, 0.3724040622195257, 0.3008977972930297, 0.4660829193504513, 0.6187049136477745, 0.5311962257108978, 0.5277809712100943, 0.5932261398165622, 0.6238504954584048, 0.5715872098282084, 0.697159096249673, 0.5023299448167553, 0.6937482601130611, 0.3099457602154977, 0.2667830845882905, 0.26922166540478465, 0.4236047542775253, 0.3093449340308899, 0.16835404223636619, 0.1928177208784876, 0.21616456150606744, 0.22082635101589698, 0.1970187566883982, 0.21821221487318654, 0.22151724020954944, 0.23640856891160966, 0.19636615112152445, 0.21351099851421018, 0.2086892976136575, 0.1915768055460494, 0.19618136118108398, 0.20668812106667422, 0.209765744667337, 0.7848545046372145, 0.20817439990698106, 0.22095342112267602, 0.17854453745436427, 0.936015688391861, 0.14792316124042104, 0.9231323570631116, 0.9188134517044435, 0.19908867589645562, 0.19511782638350506, 0.1423226859085105, 0.1602137369850154, 0.9185357920914653, 0.9135539897798202, 0.21225977564662657, 0.870298422121067, 0.21120816946815435, 0.1653727940037688, 0.16669028575976663, 0.1280768831486866, 0.2117606563789457, 0.9221906438271696, 0.18712627989745756, 0.1826372942290383, 0.19183734387024842, 0.1787700025999438, 0.18124922539356403, 0.19641392026727433, 0.1998413117825225, 0.188533202545623, 0.20179695178862267, 0.08266387385807739, 0.08756483814044091, 0.09867944736657774, 0.08127009983820954, 0.09112574044462385, 0.08702402098733963, 0.09423568537172433, 0.08538890795506104, 0.09766829767231333]}, "mutation_prompt": null}
{"id": "9762cbfc-1c62-49ce-82c7-2bb9402ffef7", "solution": "import numpy as np\n\nclass QuantumInspiredDEAdaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = np.linspace(0.4, 1.0, 4)\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n        self.dynamic_scaling = True\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            if self.dynamic_scaling:\n                self.update_scaling_factors(eval_count)\n\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.9\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def update_scaling_factors(self, eval_count):\n        progress_ratio = eval_count / self.budget\n        self.scaling_factors = 0.8 * self.scaling_factors * (1.0 - progress_ratio) + 0.2 * progress_ratio\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredDEAdaptive", "description": "Quantum-Inspired Differential Evolution with Adaptive Strategy and Dynamic Scaling leverages dynamic scaling factors and adaptive strategy updates for enhanced optimization performance.", "configspace": "", "generation": 87, "fitness": 0.18233058552079517, "feedback": "The algorithm QuantumInspiredDEAdaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.41141199000720297, 0.26755664401368595, 0.4717422544347417, 0.47866559836140354, 0.4071785831608852, 0.41768046540724957, 0.38192158686284783, 0.44953032150397576, 0.33025720972782113, 9.999999999998899e-05, 9.999999999998899e-05, 0.06442357790547248, 0.027850150207184066, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.13859847548244308, 0.13637946635304743, 0.1068079775199482, 0.10666424014152165, 0.11236903339236326, 0.12358022035600025, 0.1598592705855717, 0.13389455637779046, 0.11178141873663883, 0.08636620217426594, 0.09007004910250493, 0.08402187774614156, 0.13322165201422143, 0.10826091129172288, 0.1112578874709208, 0.15159689767309814, 0.08234907614085674, 0.07717148288407005, 0.9560625768227399, 0.08008273585207659, 0.9780944836174873, 0.17026162586813187, 0.9620705342503366, 0.9856227401301925, 0.9787496496970894, 0.9778912841384524, 0.9821400412892345, 0.1848320874224486, 0.20583290838278756, 0.18098315019110567, 0.10310161912839122, 0.1841302284854297, 0.1468226342163862, 0.1374025901800967, 0.16242252992035078, 0.13532520797385983, 0.3437667146078235, 0.22899461060114512, 0.2930268237683774, 0.17844527761311924, 0.21896506744957367, 0.21024441769757563, 0.1264451719655283, 0.15171866774850695, 0.2329344642513108, 0.1287973248228782, 0.1007872479602826, 9.999999999998899e-05, 0.11991057944311945, 0.1509264456401085, 9.999999999998899e-05, 0.08159249047916983, 0.133585266797973, 0.13794270749631976, 0.002264639298176774, 0.1307316675784279, 9.999999999998899e-05, 0.13059287093196958, 0.14525696868804772, 0.031280571845137994, 0.12835133515853503, 0.0016290739563610268, 0.12832293466079137, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0029824492134550296, 9.999999999998899e-05, 9.999999999998899e-05, 0.09378440615800832, 0.06587231522611947, 0.08637202513944298, 0.07252464016019389, 0.03752661655390699, 0.02765755029219641, 0.11895311896630789, 0.07005605127409764, 0.11483352302043381, 9.999999999998899e-05, 0.009849750636241827, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10482189227845995, 0.03406848310694366, 0.08305927842230043, 9.999999999998899e-05, 0.08788365021582145, 0.07533391437354275, 0.12159860926688748, 0.16464520505825986, 0.06773692555870914, 0.4221587449894463, 0.31248069749130714, 0.408307672447071, 0.2759359502318023, 0.4118401709651969, 0.3705573847092003, 0.34736971909701464, 0.3073021236535819, 0.34112462604742944, 0.07273131669154687, 0.11579379753409835, 0.09562142334771362, 0.0640443969273603, 0.09997867145577277, 0.10124922264833436, 0.08049393863592502, 0.06099356949167345, 0.08530400368776936, 0.18273330019002065, 0.12252653232892285, 0.19714669345574498, 0.12731323806003858, 0.1952519641459376, 0.19666414226872908, 0.3168701721063655, 0.25589485067649176, 0.18058165082348987, 0.20859691075185305, 0.20999381275929152, 0.250945984672193, 0.23120906098710092, 0.20203501867831497, 0.2410213487242766, 0.21027290398372256, 0.292192508759218, 0.22766516239860413, 0.21723545175124892, 0.19034370705655013, 0.1746324542735005, 0.2606364403676946, 0.19410599548237173, 0.19252283797316738, 0.19804976318925172, 0.2300584127579326, 0.24877196649403654, 0.21630528795037218, 0.19356526619220515, 0.278580515880381, 0.22668006428418952, 0.22592713150022448, 0.24652191718276473, 0.22460413439540805, 0.24732073216702688, 0.24991987102829294, 0.20273519365611337, 0.18196035725795667, 0.1768507828720498, 0.2242384215696458, 0.2152594015290883, 0.18587875083210292, 0.18785982436177828, 0.19676720504565182, 0.1712811776022256, 0.3208336862370996, 0.15189950734336422, 0.15212370831389765, 0.15772826755212377, 0.18637370207386683, 0.19982516551965324, 0.3750271048908881, 0.1203674569833042, 0.1981222455440702, 0.3591883172482735, 0.21237297181259085, 0.07352415389478151, 0.32481924122102046, 0.25515057846158107, 0.12682682714483673, 0.10500001190739827, 0.20170692657176081, 0.4308001681703858, 0.183533136316116, 0.18030787165570294, 0.23484321752993909, 0.21290464836624423, 0.19784339993738898, 0.18550884424309022, 0.2301111852650891, 0.19455573731163456, 0.2032908865962484, 0.08483753440548991, 0.07548117985808855, 0.08441569250882497, 0.09290095683199129, 0.08565713155451593, 0.08443790228247305, 0.08363314684037104, 0.09248969628067372, 0.09107706335740573]}, "mutation_prompt": null}
{"id": "d7405300-9adb-46c2-b215-a1a3442b30a2", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDEEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.3  # Reduce reward factor for balance\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.75  # Adjust strategy reduction\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        scaling_factor = np.random.choice(self.scaling_factors) * (1 + 0.1 * (fitness[idx] - fitness.min()) / (fitness.max() - fitness.min()))\n        mutant = a + scaling_factor * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        scaling_factor = np.random.choice(self.scaling_factors) * (1 + 0.1 * (fitness[idx] - fitness.min()) / (fitness.max() - fitness.min()))\n        mutant = best + scaling_factor * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        scaling_factor1 = np.random.choice(self.scaling_factors) * (1 + 0.1 * (fitness[idx] - fitness.min()) / (fitness.max() - fitness.min()))\n        scaling_factor2 = np.random.choice(self.scaling_factors)\n        mutant = population[idx] + scaling_factor1 * (best - population[idx]) + scaling_factor2 * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDEEnhanced", "description": "Adaptive Quantum-Inspired DE with Enhanced Mutation Control incorporates fitness-weighted mutation scaling to improve convergence stability.", "configspace": "", "generation": 88, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'fitness' is not defined\").", "error": "NameError(\"name 'fitness' is not defined\")", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {}, "mutation_prompt": null}
{"id": "f54a66c1-df77-46b5-8e29-1468e2b254c8", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "7fcc2e46-3b63-43e0-b554-b66480ab945f", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Adjusted scaling factors\n        self.crossover_rate = 0.8  # Modified crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,  # New strategy\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.7  # Increased adaptation impact\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.6  # Decreased penalty\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):  # New strategy implementation\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b) + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "EnhancedQuantumInspiredDE", "description": "Quantum-Inspired Differential Evolution with Enhanced Adaptation leverages dynamic mutation and crossover adaptation for improved convergence.", "configspace": "", "generation": 90, "fitness": 0.47259081546731907, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8950659742208056, 0.8902405737648917, 0.8922754482514164, 0.8926938809025832, 0.8908996092579627, 0.8956313818540118, 0.8915015886191816, 0.886876392955446, 0.8883176826754317, 0.7839513639552697, 0.7897646550341701, 0.7847144047221818, 0.7845045697081412, 0.7589860895970127, 0.7821812681824322, 0.7746555995792757, 0.7791993220661825, 0.7906909054934148, 0.1644533666227751, 0.16726331979013487, 0.39972133571034874, 0.31176846609500486, 0.5167996992341986, 0.13919702359564745, 0.5265889242935902, 0.15107058613966784, 0.41039972642746403, 0.1455760044897172, 0.1237367487414256, 0.1332259891234202, 0.1363960237994939, 0.15933180073194853, 0.12801499877734845, 0.13313040026853518, 0.18065942592830475, 0.11420870442520825, 0.9776634248486056, 0.9710058744568852, 0.9750202088182078, 0.9472783455547455, 0.9780479530378773, 0.9732326370424332, 0.9793099704461301, 0.9896195681676371, 0.9731923544542558, 0.7175369346147038, 0.7280398964805181, 0.7157022607602733, 0.7345492171873184, 0.7282384306506475, 0.7468077644394548, 0.7478612796637158, 0.7085225785345447, 0.7221274570035324, 0.8667512607998233, 0.85519512601252, 0.36769628378980634, 0.8808949291810692, 0.9061768731005782, 0.9012262732948144, 0.8716103412391256, 0.23534493741173712, 0.8642401457088491, 0.6988221936845009, 0.12453102957327122, 0.1256008580187541, 0.5717271391144425, 0.49416127316463654, 0.13033248251747243, 0.7390415356650544, 0.5594341352722932, 0.6257793557160752, 0.47522276371055516, 0.6789773266151656, 0.13227956644917416, 0.5896517049585943, 0.7322437240562726, 0.5875673389295781, 0.5749986467449169, 0.7283033929598344, 0.5442954083440015, 0.512739150556051, 0.49238210894791834, 0.6356205194720317, 0.4258084216962884, 0.5922851947330925, 0.5867435311194893, 0.5985101001896368, 0.48738270788067073, 0.6443271022499493, 0.685767669088109, 0.6700134964393503, 0.7079324634086877, 0.6812754367959484, 0.6897767145652032, 0.6922631038710583, 0.7157771328346971, 0.7292380448965738, 0.7335912535439866, 0.34391847389489416, 0.18940166931760793, 0.2851903154091642, 0.33814655009085226, 0.16262211263847326, 0.26024812462228797, 0.1794547383706515, 0.11910222281997818, 0.10909218933175058, 0.5228168545845149, 0.5080422121909901, 0.4739395977668761, 0.507210053049606, 0.5104714123369017, 0.5254939957788163, 0.454602314864167, 0.5054374187644747, 0.4302374266546932, 0.8218172201184449, 0.8183114351195618, 0.8187920655575817, 0.7994211151297269, 0.8326309324627412, 0.8106526607842254, 0.8124620742948704, 0.8225216878357073, 0.8166962902814909, 0.11386345908430717, 0.10394933908310144, 0.126002083173804, 0.11204043308323486, 0.10844842896047646, 0.1289246540917398, 0.12019515857223673, 0.14112282962888545, 0.10763723009505344, 0.18649982218799288, 0.14102515189197762, 0.17309816097840158, 0.1765375430715107, 0.14243431589597144, 0.13144104278903723, 0.16585591271184297, 0.28944038263880434, 0.1501993922713305, 0.3506720600875125, 0.4714486386790381, 0.5249320192090476, 0.5772898933158787, 0.5290144344318248, 0.6513830985944137, 0.48637137771099836, 0.7018803943952117, 0.6315745947639224, 0.3550977602636972, 0.49708695325972774, 0.36217997653884115, 0.3503543778446562, 0.40474152054666146, 0.3648606359976089, 0.28448027743509974, 0.5074549958606487, 0.4910603140392835, 0.2119483893355899, 0.2009321509212959, 0.19694048938142272, 0.19114665184695667, 0.18851988756894245, 0.19180358274424048, 0.202766062505784, 0.22596559027977425, 0.20552106376098678, 0.23439996190742085, 0.23678605343472092, 0.5436718661995619, 0.2407525201765358, 0.21826271025208566, 0.20790573666368217, 0.24074060524388685, 0.24228027956265397, 0.24221005965990794, 0.18411272039716386, 0.8881258048093672, 0.8718797322900188, 0.9014237748050556, 0.8908360767170633, 0.19924333670571537, 0.8780550279131437, 0.16116336943053888, 0.1675676489701049, 0.8869607453095179, 0.21061325415397036, 0.2075710363158706, 0.8431629935568434, 0.16783564758601188, 0.1538907628146604, 0.21253198982773147, 0.21078714770288187, 0.8705369706646057, 0.18383589534420364, 0.20277755222569294, 0.20083871388592967, 0.18150057400098307, 0.1907204598802109, 0.19285463922828683, 0.19679006765306395, 0.18409412361690758, 0.19746894055052333, 0.08324337074378452, 0.08478511582741799, 0.07489743316570241, 0.08363782894561123, 0.07587706687170559, 0.07946828395420857, 0.07807494887159605, 0.08124051372645114, 0.08833747426087935]}, "mutation_prompt": null}
{"id": "e6ebe246-5173-49d3-9855-ea85d3c5252a", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "0c919300-4bfb-410a-8df4-74c247f6c951", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 12)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]\n        self.crossover_rate = 0.85\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.6\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.65\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "EnhancedQuantumInspiredDE", "description": "Enhanced Quantum-Inspired Differential Evolution introduces stochastic scaling and adaptive mutation strategy selection to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.4803114362492545, "feedback": "The algorithm EnhancedQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8901281340403945, 0.8936425902109373, 0.8851694386987197, 0.8909795195074179, 0.8918239367500086, 0.893615679416917, 0.8886197185371489, 0.8916110818291979, 0.8815849981493157, 0.7783437101500985, 0.7036072014860031, 0.796145981785235, 0.7833575361527445, 0.7903146473818998, 0.7872724375378264, 0.7951798888782129, 0.7734547024701351, 0.7553922623324202, 0.12866060620390563, 0.6658882905068368, 0.16976015706310676, 0.6103151076089666, 0.14438916799887624, 0.14785990591009834, 0.489430231954618, 0.13606836406649636, 0.16992340006415874, 0.1393975718150412, 0.1490008742881982, 0.11782803037148626, 0.1482093819216167, 0.14949244301322395, 0.14813184464788287, 0.14855583343120327, 0.17642622106676442, 0.16353297938397027, 0.9780654076834862, 0.9882252744449613, 0.9788645755433155, 0.9753731831891853, 0.9668002657329583, 0.9676175509765992, 0.9719866745032599, 0.9827070900507474, 0.9701244444432677, 0.7188945000206803, 0.705220869147258, 0.6970039166112012, 0.7186667618900171, 0.7361952610412716, 0.7238891257800388, 0.7246255077941459, 0.7223030522925616, 0.7056729983030523, 0.2512553718949111, 0.8628094661692811, 0.8156948630433277, 0.9335468805438418, 0.8584007626427068, 0.27698857415419775, 0.8731872973865604, 0.8754510268555424, 0.8896267404318247, 0.13260277545659105, 0.5389895520126895, 0.5957096301940543, 0.6000602318621795, 0.757986199292297, 0.5248847433376427, 0.5363377202396462, 0.5558277355241042, 0.5962440613198183, 0.7683930739286734, 0.5069640098164876, 0.12874857038984033, 0.5265911071249454, 0.7108679022754862, 0.5088559812455542, 0.6453914911288757, 0.7476106433104015, 0.5303979418233767, 0.6238295277067158, 0.6939100065481334, 0.6341855087587827, 0.574644232221919, 0.6559780126695978, 0.6643279843230963, 0.533769761982652, 0.678097420595331, 0.5705399306732466, 0.7496842004308311, 0.7170258526285325, 0.7330209788524749, 0.726937527686486, 0.7777086367168802, 0.7004006335022408, 0.7299943386482141, 0.7377371468189283, 0.7596356256330504, 0.1420950753350022, 0.1561848725537669, 0.36528581764091483, 0.5881735145047576, 0.4327508453496509, 0.19553379233875356, 0.1383478459390759, 0.1506054923817992, 0.16533710654779588, 0.5289143865036572, 0.6100990639029189, 0.527521792176427, 0.5669651678749295, 0.5852279880036834, 0.5107131278700723, 0.5107357350494572, 0.5747960117363156, 0.5711272611820306, 0.8626264160960464, 0.83095843399154, 0.814298459522034, 0.8001040717886643, 0.7695555746339602, 0.8317892022522493, 0.8371748118442119, 0.8160138415627184, 0.8237983918871774, 0.12995359726812727, 0.12009350021732357, 0.1336156774834486, 0.14249533901529599, 0.12436034734308232, 0.15546822823998863, 0.12671239081611252, 0.15200127905988503, 0.13721949340962925, 0.28111227599950595, 0.2608892014938994, 0.3218434001951055, 0.374038514994656, 0.17887156984204633, 0.15200381547702713, 0.6418866435690538, 0.2051499449239097, 0.18538567889061408, 0.573971048597425, 0.47709982137694595, 0.6049896570743387, 0.4282470228997959, 0.5505774026379122, 0.5104990654975188, 0.528406438287497, 0.4930466692070561, 0.5214326114345171, 0.4184442878739938, 0.4838959459497726, 0.49429922036025786, 0.37242852752109634, 0.28126068490059275, 0.30879371100238573, 0.47243587215658867, 0.3318434991130844, 0.21709761817918272, 0.200882517046706, 0.2440548177739289, 0.19391921759618103, 0.21247945224964337, 0.2187111617155184, 0.19608939308078432, 0.20566725571614497, 0.21132116792365951, 0.2360970744956743, 0.2096050384578061, 0.6504264640154478, 0.22386869504554063, 0.2458442643468952, 0.21695750036033523, 0.2448123532140024, 0.24336723053434495, 0.7942153626657915, 0.19164454917913454, 0.9001335776539454, 0.18723972557569357, 0.9171509829632467, 0.9148413865885511, 0.1994644010604043, 0.1981272652281556, 0.8797069390583271, 0.16396766543037955, 0.2102418688904889, 0.9050904272438544, 0.21220626830697453, 0.16846195297370958, 0.12629936371553652, 0.15606336901497253, 0.15475477996397802, 0.10464557670379415, 0.10462203120815994, 0.166345938989929, 0.18167451715412475, 0.18846225838138697, 0.18508268608741885, 0.21339910401578033, 0.19046945145767247, 0.18308027765633783, 0.18897163628519087, 0.1980597976644668, 0.18620795260019884, 0.08573477882936509, 0.08667378617124433, 0.08670460641938293, 0.09455770445405853, 0.09782204818925966, 0.08782817656848019, 0.09978940263591718, 0.08962733944883894, 0.0789915511728746]}, "mutation_prompt": null}
{"id": "8d8f926e-ed6d-4030-a268-be8e0b613c08", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveCrossoverDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rates = np.full(self.population_size, 0.9)  # Adaptive crossover rates\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                    self.crossover_rates[i] = min(1.0, self.crossover_rates[i] + 0.1)  # Increase crossover rate\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n                    self.crossover_rates[i] = max(0.1, self.crossover_rates[i] - 0.1)  # Decrease crossover rate\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant, self.crossover_rates[idx])\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant, self.crossover_rates[idx])\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant, self.crossover_rates[idx])\n\n    def binomial_crossover(self, target, mutant, crossover_rate):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveCrossoverDE", "description": "Quantum-Inspired Differential Evolution with Adaptive Crossover dynamically adjusts crossover rates to enhance diversity and convergence.", "configspace": "", "generation": 93, "fitness": 0.3092140778985418, "feedback": "The algorithm QuantumInspiredAdaptiveCrossoverDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.857892224516324, 0.8571496979555737, 0.8735349114769759, 0.8633716605367465, 0.8730588259200827, 0.8719454470850176, 0.8682584037131095, 0.8565995332154047, 0.8614254484934983, 0.7452472922061704, 0.7078436298028008, 0.7233500534081634, 0.695214229803844, 0.7443366990621774, 0.6800974606492439, 0.7072599537412276, 0.7014671240346777, 0.7261548194354674, 0.5976615382977015, 0.5978603868916663, 0.5756647125584158, 0.5757682308186531, 0.5812083496401288, 0.6239283666228028, 0.6558569685765339, 0.5933409663783431, 0.6265712418470117, 0.5466651919399741, 0.5384345524526969, 0.5221393314048122, 0.5584395169136207, 0.45026556795861994, 0.5113679561526685, 0.5414559283340765, 0.5413829733419979, 0.5024504870588822, 0.9837476745380959, 0.977262925469401, 0.9743858543745418, 0.9781036303907567, 0.9858012130327791, 0.9860175164699447, 0.9834909291444375, 0.9841730998767955, 0.9821753784599656, 0.24313433914904004, 0.28704040355408145, 0.2633600235922241, 0.2971349852142664, 0.2824875680629626, 0.3016996615669123, 0.28381070034228306, 0.25614595153582354, 0.23664975721176762, 0.30969670716395326, 0.2983240864591603, 0.24766020405688005, 0.784783854014458, 0.32672220486911807, 0.254340256570156, 0.29236956207646503, 0.36053474948732456, 0.27144450189668756, 0.1717931215754226, 0.18592224323543516, 0.16888408478849903, 0.1313732110680127, 0.17915801302709644, 0.1665440177496713, 0.1725207012923171, 0.16562545939693007, 0.19334555752932092, 0.14229203795046574, 0.16640704022704833, 0.17337823312862344, 0.1822216818035548, 0.21555279062121746, 0.1604996557265691, 0.1321248898701589, 0.11300942892208587, 0.15643084460982593, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00816855966245622, 0.0030355620804098926, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002767903374555347, 0.1210281776501082, 0.06774321399527383, 0.08923429255922632, 0.08342066043655738, 0.08088728764051467, 0.02717926729786102, 0.07468951250559697, 0.09514046462881909, 0.07361804874306965, 0.01753635889861105, 0.01596812431539585, 0.01593112354210202, 0.03373221661499415, 0.019403814153593935, 0.057080718254681084, 0.01824174550338864, 0.0038446200551770504, 0.02709325831078535, 0.13404706776713016, 0.06805463161304559, 0.15824543296154392, 0.10940977728213652, 0.11298794913556409, 0.13957124588670144, 0.1327138030861057, 0.08786502010190111, 0.1336551121562345, 0.5038638339737904, 0.500278225696891, 0.5232615430839297, 0.49689919850678, 0.4618027994402142, 0.4803761487661419, 0.49197823796772056, 0.4971070722107622, 0.5001806527174583, 0.11479455638910496, 0.08333514514426699, 0.12284946179770362, 0.10420604415483126, 0.10340720120825975, 0.1360460075980423, 0.13007215131150074, 0.10174771357748835, 0.09872908714956774, 0.14909981933923044, 0.19427298301479923, 0.1571280176464417, 0.1642988006334667, 0.13850970373473936, 0.13872363234952334, 0.16921973556183334, 0.16352050280297503, 0.14313758721615744, 0.26636147046822534, 0.30914594677772045, 0.30529267316887354, 0.24942097637653837, 0.2648659123878939, 0.2909072384538446, 0.3513122982578025, 0.33045587430225865, 0.3643937493745768, 0.2104237091986637, 0.18626271336138234, 0.20509157174834536, 0.22428187555046886, 0.18861199847954524, 0.2394989976202221, 0.24934579720786465, 0.24446430758705706, 0.23553865388669304, 0.2620584503847663, 0.21078747066990022, 0.22378602556249105, 0.21174360127324965, 0.21698969946314306, 0.20066277650408915, 0.24053951329489487, 0.1988056705863085, 0.1904645664156851, 0.3106807817101539, 0.22632221060585966, 0.29923254553719913, 0.29451043950676215, 0.2524523441438966, 0.27259416590416774, 0.3391741395000738, 0.2626269278557103, 0.22210093004132792, 0.16313005486906806, 0.15818948158098156, 0.15451769753988343, 0.400909757875233, 0.409674217357648, 0.3564479631838965, 0.18738588671791634, 0.23643003731148327, 0.23757816648454666, 0.31635255849744515, 0.20688009038770339, 0.29360356024583, 0.2842622967588825, 0.16628793749525195, 0.14709629835037508, 0.18068343774354267, 0.32664773134728453, 0.3114627499428628, 0.18923155502582534, 0.1886347673541291, 0.1873001011525356, 0.20684487685439013, 0.1850134463739207, 0.17906041070235057, 0.18200283121701877, 0.19264496426536692, 0.18124997106159624, 0.09338197289453343, 0.07716921508408892, 0.08573745064687233, 0.08965235301582075, 0.08375582050425678, 0.08324492035287001, 0.0906842350568724, 0.08479625060518081, 0.07758758354220696]}, "mutation_prompt": null}
{"id": "bcc37084-b637-4dcc-a429-60500fefdcf5", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Slight tweak in scaling factors\n        self.crossover_rate = 0.85  # Adjusted crossover rate for better diversity\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.8  # Adjusted decay factor\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution utilizes strategy adaptation and quantum principles to enhance optimization convergence.", "configspace": "", "generation": 94, "fitness": 0.4681337247803757, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.30.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.898096628184197, 0.902606514541552, 0.9117177897376741, 0.9083314592465708, 0.9106035988670489, 0.900965946501374, 0.8961306261973212, 0.9013243102298272, 0.9049235128995441, 0.8001916970740741, 0.7992372740612688, 0.7753847591978933, 0.7886485908932874, 0.8055049047019316, 0.8112681767445614, 0.7637190728304065, 0.8008469153029686, 0.7482493053343714, 0.167411934437952, 0.18280331349657308, 0.12344291059660573, 0.16366102146507433, 0.17679508283333667, 0.1483176037782572, 0.1553135240698621, 0.14573862997278375, 0.1667413975350719, 0.08969266813348875, 0.14748744438390315, 0.11293158645436174, 0.14507834533800656, 0.13834797324546344, 0.12738449619593084, 0.12215857366283833, 0.17715494305823154, 0.15254499056409554, 0.9779099937535557, 0.9748320409015557, 0.9808740397547052, 0.9709872971760587, 0.9668036147176258, 0.9810548460745697, 0.9782378637126199, 0.9816174799817474, 0.9682354234783999, 0.7680861645715025, 0.7327937470493855, 0.7403977294572648, 0.7582960013179826, 0.7458619861992299, 0.7265709083219656, 0.7634682301096771, 0.7478696485013345, 0.7313769022452115, 0.8963131804641996, 0.22829195863589435, 0.8989259746715369, 0.21119716086753992, 0.8950411848844195, 0.9105700823217677, 0.17406882848494531, 0.8639631231410225, 0.8902779384798746, 0.623211397783066, 0.13124196550773937, 0.13263930173066096, 0.1292768022613454, 0.6249760641672114, 0.5843822072496072, 0.5158198309253034, 0.7049998333670514, 0.6405331130964421, 0.13110024565046374, 0.1319947309089321, 0.6868757750668891, 0.8279794161389022, 0.6480348217606234, 0.6796228034862504, 0.6567000267755417, 0.6957378275346844, 0.7227273710210403, 0.09761697249252432, 0.5460312381294116, 0.6789380774464445, 0.6454244600664174, 0.6653635420330446, 0.6159809906604241, 0.6856360678836324, 0.6784850337005399, 0.5575289536189412, 0.7264467061483162, 0.7334207176931796, 0.7423431340986312, 0.763269570333926, 0.7557179958753872, 0.7826647525477785, 0.7759938456395935, 0.779548267923892, 0.7899004505545988, 0.08364059995868156, 0.17219572714196751, 0.2795258727742015, 0.5251956105878456, 0.15191289093845683, 0.3657251441772259, 0.30868154793033775, 0.13615202282313343, 0.27245785022440017, 0.5870643506622826, 0.5873811677579923, 0.6070910624243344, 0.5588992122165346, 0.6183001583463239, 0.6481648549039674, 0.4109168737219746, 0.4868207675741836, 0.5391249195882124, 0.8648590878091107, 0.8510173410274202, 0.8406219961713557, 0.8492521296288784, 0.8564716683261329, 0.8403417402191095, 0.8632637004355503, 0.8316497193296637, 0.8554383253831199, 0.12282599719456377, 0.13387630785055427, 0.13611603538538986, 0.1177760078097736, 0.13254419705991372, 0.13141718372819666, 0.1160505931203043, 0.12268341929206128, 0.13656093730262908, 0.4420138768527522, 0.7937392976860093, 0.24189115420055218, 0.8078338265750051, 0.2149938810386377, 0.26036613027696087, 0.2604642279563122, 0.16529172451171525, 0.1888606771213408, 0.46011286453847355, 0.5507172419027881, 0.3916435981535734, 0.6234063874632296, 0.6288321727744308, 0.49741757313788526, 0.500121359498182, 0.6210090252341898, 0.569364234137002, 0.3556414277130068, 0.43836285179921775, 0.3255488853267292, 0.4548028028360602, 0.26783444255109823, 0.3440983134791481, 0.46751177331936566, 0.5340641304222046, 0.6368983143353836, 0.19855234222500417, 0.17161304725351345, 0.21520531337676396, 0.19115961449477237, 0.2065795450532375, 0.19809890188046497, 0.2328760663215843, 0.20186792404520337, 0.22065762416723966, 0.20726527532096473, 0.2261582082673005, 0.1951605756645971, 0.19769986859855382, 0.22091108756606048, 0.24977742519611223, 0.24659132863616728, 0.24720969188384956, 0.19597059564899044, 0.18595620886637276, 0.1649665008917649, 0.15349834349186953, 0.1730369131247993, 0.9061340016745669, 0.19897144095600994, 0.1423494008844709, 0.16145321936497836, 0.21091702313356642, 0.9005857881963093, 0.212031417266912, 0.8562164001751217, 0.20754599604124102, 0.8770565498339247, 0.1649553488089216, 0.10465577900646617, 0.2114736644162395, 0.12707165673546006, 0.20994638812918764, 0.1869910653121326, 0.2012792569302464, 0.182060579328728, 0.17730457339733618, 0.1871130401251344, 0.19312939633833193, 0.19043618541205964, 0.18062964244167035, 0.0830297080623843, 0.09047507267861021, 0.09079878000051833, 0.09036231665394967, 0.09222989948690496, 0.08985988351652541, 0.10233714581351472, 0.09508411455074961, 0.08388301792500696]}, "mutation_prompt": null}
{"id": "e98d41fc-4e98-4e56-af1d-b2d79b72f5d2", "solution": "import numpy as np\n\nclass QuantumLeveragedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9]  # Modified scaling factors\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.75  # Adjusted decrement for weight\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumLeveragedAdaptiveDE", "description": "Quantum-Leveraged Adaptive DE employs quantum-inspired adaptation and dynamic scaling to enhance search efficiency and robustness.", "configspace": "", "generation": 95, "fitness": 0.470430465366174, "feedback": "The algorithm QuantumLeveragedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.31.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.9061509869213289, 0.8904377272534064, 0.8946600037645971, 0.9078657327942262, 0.9036787973074984, 0.9139038613941748, 0.9121721019851124, 0.8984712468093433, 0.9029000253540195, 0.7722659219241167, 0.8106055258201585, 0.8185231353189932, 0.8109738268036153, 0.7775178125104103, 0.8112747039813732, 0.7863445499833465, 0.8084668466710665, 0.8368285499496756, 0.1563766837224786, 0.1520883573776598, 0.14103858870421715, 0.15030587305015275, 0.17704315282568384, 0.17326342132787909, 0.17771680776220333, 0.184146952860596, 0.1703778070012817, 0.13842426280150244, 0.141906738537517, 0.12035948620799208, 0.1599569677303312, 0.1545167627180174, 0.09553300645284746, 0.09355087688349717, 0.11138682830704105, 0.1302567393553229, 0.9779088443491006, 0.9725411066051526, 0.9752429940810229, 0.9724080044636972, 0.9687731726427546, 0.98065492782102, 0.9782939289861372, 0.9822621943719952, 0.962419472554731, 0.7749242696589618, 0.7438744822442482, 0.7348746380832158, 0.7705456962579439, 0.7544526065020781, 0.729679690037895, 0.7491334802194529, 0.7643634414100289, 0.7841173891976018, 0.8823275134383232, 0.9172987645494222, 0.9114669644630422, 0.2781582262541392, 0.9204250207346429, 0.21243727942042767, 0.8566617801092679, 0.8658476588131951, 0.23468478298922246, 0.5546129921589101, 0.7765706756488142, 0.13309256795255497, 0.13107675447994493, 0.6151654610196187, 0.6232592301606033, 0.47682608518744807, 0.13328659174990298, 0.6304441556082465, 0.5794604038697238, 0.13275010867073156, 0.6284316687098221, 0.7937843803719314, 0.5862512199345447, 0.6946739743077973, 0.6061864530321296, 0.5509766023349815, 0.12816772043781444, 0.2860427297624014, 0.6481777170982783, 0.4853887776507182, 0.5451215091531033, 0.6990017063674469, 0.5784300067484487, 0.6836103149843097, 0.7442391158652129, 0.6985898641320858, 0.7644955689269173, 0.7724312099310743, 0.7508393229552582, 0.7662570547620013, 0.783990310545866, 0.7855356311473637, 0.768409122941012, 0.7609225343956548, 0.6135624196672849, 0.11605278857662293, 0.15500093035628326, 0.5030127285996047, 0.5397887018020215, 0.3883592708696989, 0.21461837267018735, 0.12340689647165148, 0.15422332510652959, 0.14997020549097595, 0.5578034770546527, 0.5397171183671539, 0.5598112293877838, 0.6405738402874276, 0.5255751569237685, 0.5724283575421873, 0.40147097377529806, 0.4845879072988152, 0.49698993959547066, 0.8437500258285765, 0.8500548954949733, 0.8542557783171093, 0.847785015537041, 0.8468032422228068, 0.8452244838985644, 0.8511224234249823, 0.8515240697532638, 0.860665203617447, 0.09465569606503355, 0.12100142627927157, 0.1489879952788764, 0.11630021588694706, 0.09606615188907963, 0.14143186356424953, 0.0972620576851716, 0.11302421828949705, 0.13996299561926084, 0.14915375541274933, 0.1833551730187607, 0.17428190141973587, 0.17178195684002184, 0.16251916483513873, 0.26378719633556424, 0.14747412289676398, 0.3451339788019234, 0.17646224637158503, 0.3708699619413839, 0.4930289655180492, 0.4754444595219768, 0.7274724914526502, 0.5561331987029265, 0.3662708705775978, 0.7163214948638679, 0.5608161173065905, 0.3932472984293329, 0.22537336073827896, 0.49577853192679755, 0.26640606420890356, 0.33953343043920337, 0.454000894194742, 0.5182707692725957, 0.4692549785433111, 0.2900908653439086, 0.5306215044829059, 0.20193357181914562, 0.20563478554660164, 0.1978368937441568, 0.19022809889962267, 0.21158518032156326, 0.223741576045684, 0.20358949675616755, 0.22147967251521672, 0.21418968794832716, 0.20601427428675656, 0.24677528799663373, 0.19737976202360252, 0.20513187117227383, 0.19431728094743372, 0.7481002059069788, 0.18906904845323025, 0.2071602879529333, 0.19616345973071736, 0.1871539348116874, 0.16498431076408326, 0.1533530164985326, 0.9096277286967785, 0.9066729962695572, 0.165821673034951, 0.14262652639119444, 0.9026576438348728, 0.9066585817914747, 0.9129445376275472, 0.21240516597898595, 0.2071459511096293, 0.21001176579622638, 0.9107343768171303, 0.20626501722936685, 0.10447369049479616, 0.21158445767863687, 0.9098433493801744, 0.17899922599107698, 0.192407969625347, 0.22322062617127358, 0.19820797601151174, 0.22902354654574897, 0.18703897132518732, 0.18600964659369124, 0.19673931228047925, 0.19171643398028404, 0.08604107592256405, 0.08966607107868751, 0.09226399771548843, 0.09245914568629654, 0.09730342816034754, 0.08320168177581488, 0.10855563028523652, 0.08648808480435621, 0.08505783354061658]}, "mutation_prompt": null}
{"id": "23481188-28e5-4e8c-aa26-d0b9c2501152", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "3c923033-ad95-488c-839a-343639f81ff6", "solution": "import numpy as np\n\nclass QuantumAdaptiveDEwithGaussian:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin,\n            self.de_gaussian_mutation\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_gaussian_mutation(self, population, idx, best):\n        mutant = population[idx] + np.random.normal(0, 0.1, self.dim)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "QuantumAdaptiveDEwithGaussian", "description": "Quantum Adaptive Differential Evolution with Gaussian Mutation enhances diversity and convergence by integrating Gaussian perturbations into the adaptive DE framework.", "configspace": "", "generation": 97, "fitness": 0.4756616024280722, "feedback": "The algorithm QuantumAdaptiveDEwithGaussian got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.28.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8562122861187147, 0.8764524883567886, 0.8756446278070287, 0.8751603469598054, 0.871507893978062, 0.8915425591663222, 0.8707137360760704, 0.8573000381449507, 0.8729193760444452, 0.7232446278211911, 0.7597591371168871, 0.7591527024143467, 0.7328795721302166, 0.7635740258200259, 0.7497381628266285, 0.7641053847049644, 0.6868720302877138, 0.766429010356058, 0.1105876819621242, 0.14588539180315108, 0.14266165172744327, 0.13574103598012588, 0.4702394179081425, 0.14862192951888176, 0.5232506238582042, 0.12917435607298267, 0.1502183787014485, 0.12306968989642575, 0.10684057347120857, 0.2574695832706816, 0.12296252154909193, 0.12438987935182866, 0.15921459324778475, 0.10790244787460779, 0.12990641208479192, 0.13004370035820723, 0.9868923339451734, 0.9769116459980551, 0.9818402319545334, 0.986111424813713, 0.983928942250017, 0.9675021939000018, 0.9775584729946085, 0.9895241885688829, 0.9730406053273534, 0.41134065908290496, 0.6086647482017612, 0.37871698431989764, 0.37854606710094374, 0.3959663108503312, 0.6445057365038824, 0.52241398385928, 0.5135034311716926, 0.6707939546207, 0.8682007886428079, 0.844954510307577, 0.8627663332084204, 0.8572071882235385, 0.8603945332868217, 0.8924348112271057, 0.8114768415874436, 0.8490458984925238, 0.8793265080641088, 0.5478962784702439, 0.12461708702602758, 0.5056127932647905, 0.7557464078980034, 0.6351758173899971, 0.6191618358827349, 0.6448023077372539, 0.6619747049029643, 0.1316008615768024, 0.6986504423298666, 0.12080595199524757, 0.636949791233068, 0.6101544512118506, 0.6463422235058285, 0.621576533112359, 0.600680439361683, 0.7095944201491902, 0.6304310655289922, 0.6589707028434275, 0.6499896275497005, 0.6507493319829758, 0.6632539376244503, 0.6422284573526881, 0.6780066092109173, 0.6888845923534512, 0.6804294104941473, 0.6619018927801574, 0.7296304686678716, 0.7285917918744881, 0.7675645406490699, 0.7384795525762045, 0.7170551828422047, 0.7372520962450738, 0.730630914726192, 0.7438638933220774, 0.7717653212747884, 0.10361981370782047, 0.27426689990375386, 0.5225109536802024, 0.49757572032874786, 0.33382946190480134, 0.20495107374274668, 0.5306546289131091, 0.16203862971732996, 0.22580954243987994, 0.5904509628021781, 0.5596731644417293, 0.6146999433765075, 0.5929409837740693, 0.6125250968860079, 0.6384433761555831, 0.6085154186951308, 0.5953815436159874, 0.5876579113116559, 0.8374653421395872, 0.8207386606190745, 0.8148264492212601, 0.8336371483592165, 0.8318165899682759, 0.8291356027620397, 0.8104650612167736, 0.8252245876781775, 0.8208932212805249, 0.12118879211150502, 0.12653377310861091, 0.11345118286181421, 0.10949901270993356, 0.13695535674731563, 0.12562145081620113, 0.12287531144003638, 0.12460159166273643, 0.11098813694092147, 0.18946272886474613, 0.22148405787188108, 0.18490635794331434, 0.21619936955817998, 0.21352285594319387, 0.19225073007508253, 0.1648771066125313, 0.1816394680142175, 0.21095886114285278, 0.40979468628289484, 0.39897849595404866, 0.5752320362957923, 0.46996420546216455, 0.6065310621449671, 0.5862708901759731, 0.5409982824213884, 0.6007995118571243, 0.6723543272977037, 0.3186901793544117, 0.21949139586374689, 0.37619886009625303, 0.4218337910244665, 0.4826484088121171, 0.32810977609695835, 0.28373916436898694, 0.5050645490926902, 0.4490528502568326, 0.2150114367880669, 0.21810273667531077, 0.20652290578124954, 0.20935526741234067, 0.17989076686661687, 0.1947808405588155, 0.23225146094030846, 0.19242941856435625, 0.2048889409384418, 0.21002904495153785, 0.2023863153022949, 0.32007981886954706, 0.19098671126431976, 0.20087104664351696, 0.2312392773761598, 0.2214379874446034, 0.41610850899167895, 0.2189838139662913, 0.8856824923349182, 0.4672015090099203, 0.4766126174119215, 0.15845019753185774, 0.19335492996808912, 0.4099090681247092, 0.670553188531408, 0.3957233530715484, 0.5485404182369951, 0.5475997135698653, 0.5380955040448974, 0.7147408399814339, 0.7363862315416754, 0.6064352686213653, 0.12652583973858367, 0.21224786332075463, 0.15170749852416265, 0.21274390545742727, 0.19779563321023153, 0.19649138519738418, 0.18130164622329725, 0.18414198587698916, 0.2011583886281345, 0.1874135301367167, 0.18547722418917334, 0.1764361344744515, 0.177760454469998, 0.08641438174300164, 0.08210847710795555, 0.0834840501174875, 0.09165137237370413, 0.07927798368620864, 0.08372438287498263, 0.08382287593164861, 0.08415568458361755, 0.08392844913763697]}, "mutation_prompt": null}
{"id": "54a655aa-cf1d-4e1d-8b05-ed2da486e3f4", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 10)\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.4, 0.6, 0.8, 1.0]\n        self.crossover_rate = 0.9\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_1_bin,\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.5\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.7\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "AdaptiveQuantumInspiredDE", "description": "Adaptive Quantum-Inspired Differential Evolution leverages adaptive strategy selection with quantum-inspired mutation to dynamically improve convergence.", "configspace": "", "generation": 45, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8912182345020502, 0.8706041265415861, 0.8845048100721302, 0.8885820940288609, 0.8796377605294831, 0.8862656904481184, 0.8836615213181822, 0.8829396733566806, 0.8866268382891614, 0.7595656225301349, 0.7323475712903771, 0.7421777452083037, 0.7760733742550581, 0.7760405958276508, 0.7757179060879918, 0.7522054849953, 0.780757315182997, 0.7732703100717901, 0.1761247505139123, 0.1461030850056797, 0.14599697581657278, 0.18135531723095377, 0.13613583431108967, 0.15573291509142562, 0.12185633559935338, 0.1487077880415183, 0.14022837881048633, 0.13337859854955292, 0.1496869056481941, 0.1669310170181627, 0.16604357323715557, 0.1110778702787999, 0.1545838456980959, 0.13303804473008363, 0.1380032891624875, 0.1670477586844581, 0.9837802851167637, 0.9769668458045252, 0.9794560009996297, 0.9729951337224557, 0.9835733518007606, 0.9864493368180358, 0.9857542472075572, 0.9818851443037736, 0.9821753784599656, 0.70721622050249, 0.6655559147007593, 0.7032429782456646, 0.7021690121542055, 0.7199881886601358, 0.7186497802360029, 0.6937699853042021, 0.6956937715747553, 0.7226680861377413, 0.8840175370615556, 0.8883267206907323, 0.8547950512458112, 0.27578230630047995, 0.8350578909610805, 0.8912654726159949, 0.8785069723149546, 0.8871120707322111, 0.8753627309792062, 0.7230228866604465, 0.6112623765540472, 0.6986096513947246, 0.7133562479166367, 0.7434640759532349, 0.6680030294819171, 0.6049344705429316, 0.7225427679771774, 0.7555575650708559, 0.5826197723572252, 0.5611883871682664, 0.6949628531027559, 0.13258697708167944, 0.6160109165832974, 0.6449281777452935, 0.7195515288858613, 0.7558177855788384, 0.12962692519942665, 0.6191899328951421, 0.7014984571993612, 0.6799784764840564, 0.669193908481142, 0.6627362066392599, 0.7181902601567619, 0.7009170952494599, 0.688855076427705, 0.6971488418753927, 0.7213547065828849, 0.7353253403976034, 0.7584699471180949, 0.7623809799223562, 0.7693293392171191, 0.7540921831295596, 0.760929085068181, 0.7782279866039382, 0.7756788137205435, 0.5392064711408251, 0.28922332665668904, 0.5911152543006135, 0.6312628720070874, 0.5260677148269898, 0.34722412434486705, 0.20177377347679515, 0.14282828952009718, 0.19676501020268955, 0.6134171965506474, 0.6465444052138306, 0.6322492139132307, 0.6568752683607217, 0.6326554104389178, 0.6410557322777393, 0.6472906893302097, 0.6397576608222476, 0.6229586616751123, 0.8440642905946858, 0.8442596080739316, 0.8470140153433692, 0.8428728850895629, 0.842375316205984, 0.8553548504510415, 0.8344247753944493, 0.8403633381506244, 0.8316727490798642, 0.11257950705813569, 0.13186885445850272, 0.10411259042229104, 0.1005589521995418, 0.14185775010117707, 0.14072302612539878, 0.1391207734962443, 0.14430027311298177, 0.13718395702810904, 0.20529112201271238, 0.3073843980960028, 0.23639434656135072, 0.17171784687900016, 0.25918577277071086, 0.19166545206590901, 0.1838483300567566, 0.16836113340438974, 0.2056666988775281, 0.6677360292052977, 0.5351080128042534, 0.5780710979706585, 0.5094865803307479, 0.49976385428074266, 0.5925324471821014, 0.6908382065717391, 0.5558589630756221, 0.5421502770947302, 0.4508629435101147, 0.540589116396432, 0.49470265913358713, 0.5349506086816433, 0.5585694927578468, 0.6042812074547803, 0.6492103559404583, 0.287426390346432, 0.2820900994337777, 0.2110873081227459, 0.18968566273636056, 0.20409946361538533, 0.2070574055890344, 0.21971312347707528, 0.22213808169321514, 0.2268744505816458, 0.20555574510034047, 0.1955721601519973, 0.24566585602439106, 0.21970409011276792, 0.21914869851122443, 0.23430813696089126, 0.18411436296715455, 0.2097100287437058, 0.703177565051127, 0.2248761083865607, 0.20398481050006934, 0.9114412077829064, 0.1651128337125296, 0.15410673637768546, 0.8678916454471357, 0.8812752236961586, 0.9029570454975328, 0.9035142083718735, 0.17832713965465286, 0.8743894848408549, 0.8933832419515273, 0.21063321967133664, 0.8840001539154668, 0.1648957734451968, 0.8752099805796189, 0.15467784507970406, 0.20715651633721688, 0.8769848999413851, 0.9099065309471319, 0.22118608244901017, 0.18191914446181978, 0.18194330715414586, 0.19150721514255598, 0.14998200613073354, 0.1838809147717524, 0.18470478357979347, 0.1914036048031117, 0.19624742017925945, 0.13682381366696028, 0.0777498423287799, 0.10952416203573434, 0.10164253869575002, 0.09588152535078875, 0.10169360703013608, 0.10584189315083459, 0.09040382133307667, 0.0959732569844356]}, "mutation_prompt": null}
{"id": "4fae3e4f-1a6b-4806-8774-8ae987ac7f14", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(5, dim * 15)  # Increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.scaling_factors = [0.3, 0.5, 0.7, 0.9, 1.0]  # Adjusted scaling factors\n        self.crossover_rate = 0.85  # Slightly reduced crossover rate\n        self.mutation_strategies = [\n            self.de_rand_1_bin,\n            self.de_best_2_bin,  # New strategy\n            self.de_rand_to_best_1_bin\n        ]\n        self.strategy_weights = np.ones(len(self.mutation_strategies))\n\n    def __call__(self, func):\n        population = np.random.uniform(\n            self.lower_bound, self.upper_bound, (self.population_size, self.dim)\n        )\n        fitness = np.array([func(ind) for ind in population])\n        eval_count = self.population_size\n        best_idx = np.argmin(fitness)\n        best = population[best_idx]\n\n        while eval_count < self.budget:\n            new_population = np.empty_like(population)\n            new_fitness = np.empty(self.population_size)\n\n            for i in range(self.population_size):\n                strategy_idx = np.random.choice(\n                    len(self.mutation_strategies), p=self.strategy_weights / self.strategy_weights.sum()\n                )\n                trial = self.mutation_strategies[strategy_idx](population, i, best)\n                trial = np.clip(trial, self.lower_bound, self.upper_bound)\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < fitness[i]:\n                    new_population[i] = trial\n                    new_fitness[i] = trial_fitness\n                    self.strategy_weights[strategy_idx] += 0.4  # Adjusted weight increment\n                else:\n                    new_population[i] = population[i]\n                    new_fitness[i] = fitness[i]\n                    self.strategy_weights[strategy_idx] *= 0.6  # Adjusted weight decrement\n\n            population = new_population\n            fitness = new_fitness\n            best_idx = np.argmin(fitness)\n            best = population[best_idx]\n\n        return best\n\n    def de_rand_1_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = a + np.random.choice(self.scaling_factors) * (b - c)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_best_2_bin(self, population, idx, best):\n        a, b, c = population[np.random.choice(range(self.population_size), 3, replace=False)]\n        mutant = best + np.random.choice(self.scaling_factors) * (a - b + c - best)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def de_rand_to_best_1_bin(self, population, idx, best):\n        a, b = population[np.random.choice(range(self.population_size), 2, replace=False)]\n        mutant = population[idx] + np.random.choice(self.scaling_factors) * (best - population[idx]) + \\\n                 np.random.choice(self.scaling_factors) * (a - b)\n        return self.binomial_crossover(population[idx], mutant)\n\n    def binomial_crossover(self, target, mutant):\n        trial = np.empty_like(target)\n        jrand = np.random.randint(self.dim)\n        for j in range(self.dim):\n            if np.random.rand() < self.crossover_rate or j == jrand:\n                trial[j] = mutant[j]\n            else:\n                trial[j] = target[j]\n        return trial", "name": "EnhancedDifferentialEvolution", "description": "Enhanced Differential Evolution integrates adaptive learning and mutation strength modulation for dynamic optimization efficiency.", "configspace": "", "generation": 99, "fitness": 0.43352577673589465, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.27.", "error": "", "parent_id": "613e0541-4f96-4c57-af90-d32236132247", "metadata": {"aucs": [0.8312870333221001, 0.8126630485856021, 0.8199086608820335, 0.8206040630759458, 0.8282285235379624, 0.823366169795764, 0.8255461026421712, 0.818711686983832, 0.8312299551035168, 0.644666610444155, 0.6726135788709868, 0.6653452658650032, 0.6519212173546032, 0.6549218617344832, 0.6705177851641223, 0.6507714871407624, 0.6676706467924338, 0.5948844747529516, 0.1378822006456194, 0.12602679627903712, 0.17377362702713928, 0.13776508242078067, 0.12427233336844734, 0.11698415254791539, 0.12023085310168535, 0.13400334834718575, 0.12453560789962081, 0.11108635861730454, 0.11106870139203129, 0.11499947927380749, 0.10676568643532502, 0.09853564923885116, 0.10092832949674246, 0.13803922048229122, 0.09841817412547138, 0.11581007698447299, 0.9664258064392321, 0.9425988423407164, 0.9535930173885637, 0.9717749440533778, 0.9352709940905801, 0.9770712201706698, 0.9844334627009372, 0.9548840481884299, 0.9674387398307593, 0.5956435007620333, 0.5636910128289471, 0.5785893581794668, 0.5464809725923199, 0.584236319938487, 0.579684358244569, 0.5876499432044568, 0.6063810214894041, 0.6105730850171115, 0.8306205766834943, 0.7739115569879289, 0.818431765100274, 0.6592500192287707, 0.7941547976491216, 0.8684060579079932, 0.8061410398043116, 0.8202874595333814, 0.8015098447087174, 0.37449061779599424, 0.47945387525411476, 0.5295666263465943, 0.41703471365373934, 0.42829547625898323, 0.5170274998738984, 0.4206380396941093, 0.6190078311829783, 0.1280001690790903, 0.12597757953599886, 0.4873071506503447, 0.44581482097164893, 0.36463565492031624, 0.48230817032766915, 0.3116783028757799, 0.12936312432981556, 0.3814025829860086, 0.653812362681407, 0.414097431352591, 0.5159445533562887, 0.4512550634809188, 0.5186777085704837, 0.4281661526275884, 0.4506428273680192, 0.4724185650484424, 0.49587976423279745, 0.4567338243459601, 0.5975653179431049, 0.5786483748107851, 0.6122190986635254, 0.6092330443994329, 0.5988225204365184, 0.61495159578974, 0.6185096315850012, 0.6057368607322181, 0.5819781799390544, 0.13431807142967678, 0.08397914528256001, 0.07369580503123596, 0.33860899195830685, 0.364115816998287, 0.27820204548447014, 0.31176076191024726, 0.28857881877329816, 0.12246531006704153, 0.35150943602175055, 0.3807291618010701, 0.3978276002492017, 0.3805918728202231, 0.36395485081234313, 0.38733744829744854, 0.3392469055385503, 0.37408275980180905, 0.3903575501017741, 0.7518875652226306, 0.7390478776090768, 0.7292049100709732, 0.7387072081373832, 0.717189838497787, 0.7244690656655022, 0.7508082498794002, 0.7257569238006257, 0.7498115960810507, 0.1328404002220246, 0.09842622487687169, 0.10680325486326747, 0.13752723332812233, 0.10813597687190724, 0.09040925145809942, 0.14025660209265445, 0.11531736604298692, 0.10302964061561637, 0.14900828584882164, 0.13920123334465773, 0.14686244171170326, 0.15652509240292856, 0.1392350034986395, 0.19071241262702066, 0.15547122867323981, 0.13155914076572028, 0.1575201029696518, 0.4843128432688445, 0.47389722112020893, 0.47804925738708337, 0.4994059212750894, 0.5016448377463, 0.5130764160717225, 0.5370469793944567, 0.49326673701247137, 0.5261266235772338, 0.4374077053815205, 0.4024406629449018, 0.3789584461116844, 0.35325389037957056, 0.39524723762409675, 0.4021120449999983, 0.43836794495173104, 0.4069197504645522, 0.3277931840224747, 0.20220994052322827, 0.21051787743096662, 0.19811248487185884, 0.1920642843228223, 0.190536914476085, 0.2002320919884556, 0.22300725786736852, 0.20379486075832443, 0.24028340938812176, 0.2347027679542124, 0.19716579861584027, 0.20394336246633815, 0.5803913853150013, 0.2273839119934784, 0.5218831402688398, 0.27127436611561784, 0.4986713213179136, 0.20767208547642113, 0.6319469392874563, 0.827024762804239, 0.8369619375067042, 0.18824671931553993, 0.7552311214669244, 0.16600392614852133, 0.41962884112351917, 0.7752916932651222, 0.8518410659579908, 0.8291989371351997, 0.209101690736332, 0.20147685343975297, 0.7682978704042944, 0.20371222022562674, 0.6881696149584986, 0.6408232453460415, 0.6569053633589192, 0.8016428499104975, 0.1787885979608158, 0.19686444075355247, 0.1892870181051135, 0.1906936969751768, 0.19617958758532927, 0.18229975093899808, 0.1802300565786138, 0.18599280060732692, 0.18312231783909372, 0.09441767206445184, 0.07867077731121974, 0.08460557062879359, 0.09259294544184726, 0.08372779667503893, 0.0870633657220602, 0.07955055151671364, 0.10324452753928182, 0.09005647597896915]}, "mutation_prompt": null}
