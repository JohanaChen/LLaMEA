{"id": "3e2a9a9c-f804-4fd4-851d-11e228171dd1", "solution": "import numpy as np\n\nclass HybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)\n        self.inertia_weight = 0.7\n        self.cognitive_coeff = 1.5\n        self.social_coeff = 1.5\n        self.F = 0.5  # Scaling factor for differential evolution\n        self.CR = 0.9  # Crossover probability for differential evolution\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "HybridDEPSO", "description": "A hybrid metaheuristic combining Differential Evolution and Particle Swarm Optimization for adaptive exploration and exploitation.", "configspace": "", "generation": 0, "fitness": 0.1819989333210826, "feedback": "The algorithm HybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": null, "metadata": {"aucs": [0.30249639905045267, 0.30249639905045267, 0.30249639905045267, 0.37282441095407104, 0.37282441095407104, 0.37282441095407104, 0.3512257573444847, 0.3512257573444847, 0.3512257573444847, 0.004483097511584266, 0.004483097511584266, 0.004483097511584266, 0.018711240681727026, 0.018711240681727026, 0.018711240681727026, 0.010006409454515919, 0.010006409454515919, 0.010006409454515919, 0.10543720563287495, 0.10543720563287495, 0.10543720563287495, 0.09303472425196069, 0.09303472425196069, 0.09303472425196069, 0.08965703179572171, 0.08965703179572171, 0.08965703179572171, 0.07608161218585119, 0.07608161218585119, 0.07608161218585119, 0.07897199160771617, 0.07897199160771617, 0.07897199160771617, 0.0750712463205846, 0.0750712463205846, 0.0750712463205846, 0.9628003078377674, 0.9628003078377674, 0.9628003078377674, 0.9631908472401846, 0.9631908472401846, 0.9631908472401846, 0.9636288540437635, 0.9636288540437635, 0.9636288540437635, 0.16333040493063977, 0.16333040493063977, 0.16333040493063977, 0.18267218301628818, 0.18267218301628818, 0.18267218301628818, 0.180567849865493, 0.180567849865493, 0.180567849865493, 0.20104272502306675, 0.20104272502306675, 0.20104272502306675, 0.17413266025258622, 0.17413266025258622, 0.17413266025258622, 0.2377777036173534, 0.2377777036173534, 0.2377777036173534, 0.09261413657296835, 0.09261413657296835, 0.09261413657296835, 0.12312845540202799, 0.12312845540202799, 0.12312845540202799, 0.0866089348538368, 0.0866089348538368, 0.0866089348538368, 0.04854258883959517, 0.04854258883959517, 0.04854258883959517, 0.1097579212150327, 0.1097579212150327, 0.1097579212150327, 0.1036182890637809, 0.1036182890637809, 0.1036182890637809, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004352026886874194, 0.004352026886874194, 0.004352026886874194, 0.008089841103127271, 0.008089841103127271, 0.008089841103127271, 0.04347243804046885, 0.04347243804046885, 0.04347243804046885, 0.05048711631958647, 0.05048711631958647, 0.05048711631958647, 0.10525418655716456, 0.10525418655716456, 0.10525418655716456, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03590055499363276, 0.03590055499363276, 0.03590055499363276, 0.025090346986701317, 0.025090346986701317, 0.025090346986701317, 0.07654271461087214, 0.07654271461087214, 0.07654271461087214, 0.3284352047449979, 0.3284352047449979, 0.3284352047449979, 0.3298309966488763, 0.3298309966488763, 0.3298309966488763, 0.2909733186907222, 0.2909733186907222, 0.2909733186907222, 0.09483144354805262, 0.09483144354805262, 0.09483144354805262, 0.09301672386007864, 0.09301672386007864, 0.09301672386007864, 0.07038053047688131, 0.07038053047688131, 0.07038053047688131, 0.1839669762290731, 0.1839669762290731, 0.1839669762290731, 0.15395856973997957, 0.15395856973997957, 0.15395856973997957, 0.1477658953743468, 0.1477658953743468, 0.1477658953743468, 0.2412954715604766, 0.2412954715604766, 0.2412954715604766, 0.23619095028719062, 0.23619095028719062, 0.23619095028719062, 0.22630182184466763, 0.22630182184466763, 0.22630182184466763, 0.17122132906313092, 0.17122132906313092, 0.17122132906313092, 0.16326665086005976, 0.16326665086005976, 0.16326665086005976, 0.16529866322717024, 0.16529866322717024, 0.16529866322717024, 0.20105299428216772, 0.20105299428216772, 0.20105299428216772, 0.18862427689431926, 0.18862427689431926, 0.18862427689431926, 0.18013605152993828, 0.18013605152993828, 0.18013605152993828, 0.18070324406439253, 0.18070324406439253, 0.18070324406439253, 0.23559711644736803, 0.23559711644736803, 0.23559711644736803, 0.18369726234436345, 0.18369726234436345, 0.18369726234436345, 0.49694734419540554, 0.49694734419540554, 0.49694734419540554, 0.2695357382419469, 0.2695357382419469, 0.2695357382419469, 0.3040511000257662, 0.3040511000257662, 0.3040511000257662, 0.3101895626700172, 0.3101895626700172, 0.3101895626700172, 0.1762110705573372, 0.1762110705573372, 0.1762110705573372, 0.19085775012313633, 0.19085775012313633, 0.19085775012313633, 0.18971889461987645, 0.18971889461987645, 0.18971889461987645, 0.19049659359640614, 0.19049659359640614, 0.19049659359640614, 0.18210441301632874, 0.18210441301632874, 0.18210441301632874, 0.06849178355426444, 0.06849178355426444, 0.06849178355426444, 0.0689914684234858, 0.0689914684234858, 0.0689914684234858, 0.06877777431136678, 0.06877777431136678, 0.06877777431136678]}, "mutation_prompt": null}
{"id": "59dfe367-4241-430b-b3fa-cee8da258519", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3  # Random inertia weight for exploration\n        self.cognitive_coeff = 1.4 + np.random.rand() * 0.4  # Random cognitive coefficient for improved convergence\n        self.social_coeff = 1.4 + np.random.rand() * 0.4  # Random social coefficient to enhance information sharing\n        self.F = 0.6  # Slightly increased scaling factor for differential evolution\n        self.CR = 0.85  # Adjusted crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridDEPSO", "description": "An enhanced hybrid of Differential Evolution and Particle Swarm Optimization with adaptive parameters for balanced global and local search.", "configspace": "", "generation": 1, "fitness": 0.1891303066278675, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "3e2a9a9c-f804-4fd4-851d-11e228171dd1", "metadata": {"aucs": [0.2976241596402279, 0.3963499492807421, 0.4411167684286029, 0.3819887566253306, 0.36936958455199154, 0.46454323030786215, 0.3660449091929793, 0.4504551702958052, 0.41352316397041133, 0.01781721320584506, 0.018981653392810438, 0.02893856442645415, 9.999999999998899e-05, 0.06612015880971611, 0.02674477709053813, 0.00033048645251110287, 0.08635633101717999, 0.060888250617481376, 0.07147011247321877, 0.08252911998611867, 0.10989209184130044, 0.08152821001003907, 0.09723068697224246, 0.10694154004166434, 0.073788489392558, 0.09439670578740644, 0.08701216988137417, 0.06927964750841964, 0.08905433010833075, 0.07819881681778662, 0.05939996416909166, 0.08542050737883167, 0.07573357699949135, 0.07558010955082539, 0.07516524381717515, 0.08540060299839602, 0.9669624039568783, 0.9626459375784703, 0.9648310932794752, 0.9647766075097322, 0.9637429171545008, 0.9642628938500571, 0.963396952153247, 0.9619031684506874, 0.9632635682556442, 0.16381164124054648, 0.1896522216640394, 0.20468522614519413, 0.13110068162899136, 0.19073690464208448, 0.20157284688461963, 0.15761647162463266, 0.22453574653001118, 0.21825971553188706, 0.19226678842100187, 0.19920154787469369, 0.16733680825894737, 0.22762611062657734, 0.23260177817082106, 0.19487070619978086, 0.19723909539616502, 0.21824997636130838, 0.20767401255964213, 0.09406275089706562, 0.0930674797733585, 0.06284746999474555, 0.10782521468251849, 0.12920884391881315, 0.11767839305881933, 0.07709722976824962, 0.1271135529229801, 0.12337523345213708, 0.08213348766267303, 0.08208917557783368, 0.11014452603061131, 0.10107821813527462, 0.1297130016946294, 0.11306981750207923, 0.09291766318319461, 0.15653176008990355, 0.13769828985375876, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0043033009802866395, 0.005070680828239138, 0.03148862900176641, 0.04565342634930769, 0.07536101354574998, 0.07145286933991024, 0.00582763734396663, 0.008373952392765616, 0.04511048740923629, 0.044066084096572755, 0.05563420697346033, 0.0637227835533779, 0.0014056262732694558, 0.008204215038365104, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015259741905935265, 9.999999999998899e-05, 9.999999999998899e-05, 0.003199368474968267, 0.02152085198277709, 0.07566515316588429, 0.06455313965805742, 0.06264852057652393, 0.03447598138743868, 0.03104055616914081, 0.04140266475810128, 0.06964481067277828, 0.06793809244973181, 0.3166955565454319, 0.3562422143809766, 0.34478782090243965, 0.3080153466419655, 0.3729382021350004, 0.34381165845271067, 0.2968345637287806, 0.3557727740739586, 0.309018429654197, 0.1051673695570493, 0.0775601742577523, 0.0960088664275126, 0.07777115670871348, 0.08824167668161276, 0.10944957379887532, 0.0794831062740321, 0.10541145874189073, 0.07615548662261895, 0.21511978932964704, 0.1642609289470871, 0.2056189286582275, 0.1526947229874066, 0.17337773021530467, 0.174492655721598, 0.192008984669506, 0.17565653717888985, 0.16554911975998188, 0.2167958003408197, 0.25753087307696065, 0.2186687765634684, 0.23995634571409807, 0.21944443294507932, 0.22728117290921213, 0.23039647285067688, 0.23768024425574918, 0.23820139944809848, 0.1614229675619283, 0.17818128481634066, 0.20389048388966935, 0.18897383400135614, 0.18754233540135223, 0.1786357039469194, 0.1214590804128809, 0.1503094118982028, 0.1920466139051601, 0.1785358759430805, 0.19764435240720046, 0.19765922654457924, 0.1920412117267838, 0.2126113791296067, 0.19310603671419713, 0.19436001224164012, 0.20589211942777497, 0.20569072980071812, 0.17190656904066692, 0.17366555560396923, 0.20353465205999277, 0.1898934930942019, 0.18970996899971193, 0.1817991662809726, 0.1739267820218372, 0.19933378467608742, 0.18385465529476674, 0.45340180903946203, 0.5677537018381473, 0.5005879488271622, 0.1540703271408711, 0.1571952647546495, 0.15548317596486938, 0.3063519059193631, 0.38511218696038296, 0.3942122202926043, 0.2372444332989092, 0.35659369976067434, 0.32057409022737615, 0.17705915481431, 0.1889019322237675, 0.34650818048134624, 0.1250591640206018, 0.2912105449376916, 0.3012203345340214, 0.1915161239684542, 0.17986722329281257, 0.17971427080056834, 0.2118097344313975, 0.1882375144176559, 0.19954349768511237, 0.18454203651307355, 0.2012884512589057, 0.18972486783999598, 0.07880555519978594, 0.07284172624908936, 0.08170159975515157, 0.07727822185572841, 0.08509689495157513, 0.06937045012614707, 0.07171388342065366, 0.09818216154125259, 0.08246329547557196]}, "mutation_prompt": null}
{"id": "96afb107-629d-44d4-b11b-62fe93eeb531", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 15)\n        self.inertia_weight = 0.4 + np.random.rand() * 0.5  # Increased range for better inertia adaptation\n        self.cognitive_coeff = 1.5 + np.random.rand() * 0.5  # Adjusted cognitive coefficient\n        self.social_coeff = 1.5 + np.random.rand() * 0.5  # Adjusted social coefficient\n        self.F = 0.7  # Further increased scaling factor for diversity\n        self.CR = 0.9  # Higher crossover probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Reduced velocity range for control\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == np.random.randint(self.dim):\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridDEPSO", "description": "A novel hybrid optimization algorithm combining enhanced Differential Evolution and Particle Swarm Optimization with adaptive inertia and diversity preservation techniques.", "configspace": "", "generation": 2, "fitness": 0.18099996432051058, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "59dfe367-4241-430b-b3fa-cee8da258519", "metadata": {"aucs": [0.2987588560853728, 0.3371793742407646, 0.4232290421709046, 0.32585111777867093, 0.3980524885378719, 0.3727737592148851, 0.3150500134512615, 0.40370227610408205, 0.4061828732335955, 0.001088027750738907, 0.07197030278149341, 0.017624913071181414, 0.012680933718929754, 0.03199835349147184, 0.013580891086283242, 0.010769405462115023, 0.021686019829719183, 0.040819048993396057, 0.08725901490973187, 0.1164710641272082, 0.09766249748080902, 0.08543584144319882, 0.0998359473269429, 0.07562020743248177, 0.10360987131424804, 0.09764733283135285, 0.10101994588992258, 0.06899584607358378, 0.0640502354352861, 0.06897041870296183, 0.06703965833716463, 0.08140283771619528, 0.07742284340667627, 0.08431048718263012, 0.09758222205622535, 0.094730441520119, 0.9742183646877851, 0.9641069367414464, 0.9649366220493611, 0.9798320779475053, 0.974376034808696, 0.9797101954233396, 0.961212361738278, 0.9581502302045078, 0.9595068892823317, 0.14237216238322725, 0.22403647329977128, 0.23165304802202635, 0.1266078021041498, 0.17593952034452942, 0.2151147741457996, 0.14158209234204056, 0.17874731454265325, 0.19227839449959327, 0.14927908032618165, 0.23800692130795542, 0.163026013714339, 0.17540602545416328, 0.1783312404708668, 0.1546122656766814, 0.19075980508675183, 0.23740231916737076, 0.18718395664310017, 0.06525609012250666, 0.12153597026170537, 0.12932836691286143, 0.09386111311804324, 0.12411707036458208, 0.13923049202116822, 0.061352758010175035, 0.10785637952611249, 0.10461504336058602, 0.02083771426408476, 0.0819034920334647, 0.09833742446426696, 0.07524445816499814, 0.1015603035745094, 0.10412795630720961, 0.08921035622978668, 0.113836079023094, 0.09586399404411383, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0030110548950866844, 0.02740543508851845, 9.999999999998899e-05, 0.027748393503914892, 0.06607119432969799, 0.06715876779173635, 0.011563462052693652, 0.018960536978066878, 0.07271296075786304, 0.039351407993502674, 0.053476298100880726, 0.06227117242886093, 9.999999999998899e-05, 0.0026156696420323033, 0.005360424753956594, 9.999999999998899e-05, 0.005235359370537318, 0.0015879237672644653, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044594182886068534, 0.03344917295941774, 0.06226312230799247, 0.02595106687305193, 0.06068121647833136, 0.021294324682129995, 0.037745523125793934, 0.0815950760624411, 0.0477314288781272, 0.28401823554351424, 0.34559670933165587, 0.3217204593295302, 0.3257652123918304, 0.38865300680964576, 0.3511010364149507, 0.25939610569110605, 0.32516174042521084, 0.3353001909512229, 0.07488484280136654, 0.08234287130030693, 0.0812475988274145, 0.06492052448964136, 0.11517318052650205, 0.07502381118570689, 0.06404166090961028, 0.08570306904699831, 0.07764703513245763, 0.15100137504034405, 0.16269429640455824, 0.1408218870054907, 0.16449499854151106, 0.1448980290525297, 0.13515267950694165, 0.1588344213366254, 0.16446063558314183, 0.17358194137046556, 0.22092300063704284, 0.252067224503265, 0.23725610299483268, 0.22134613775107626, 0.22171025985867998, 0.22644923598613842, 0.20531356402226386, 0.2444403294708022, 0.2330244980015581, 0.15352225331874303, 0.15835773187929114, 0.1723007285595327, 0.17355396495332986, 0.18642348600125092, 0.1682247530917642, 0.14535779142325866, 0.17514753028640861, 0.18338060872395445, 0.16288358922278479, 0.21414428210791303, 0.19920794606833314, 0.17114960208560848, 0.18442204047056088, 0.2002884221490594, 0.1830938764401585, 0.2110233670141649, 0.18764507541380449, 0.15935594412291754, 0.18907546947886722, 0.20051179644401984, 0.16797056679087075, 0.18832410444105485, 0.18242030634786854, 0.1750898501511463, 0.17753620434255046, 0.17730234714775484, 0.37145939270009387, 0.5778640219711126, 0.5294953029367189, 0.2632868718913224, 0.21169279229338855, 0.19059190756479127, 0.16916274861401848, 0.18342027830868024, 0.4709286466402044, 0.28542883629443594, 0.28866247000204337, 0.247615178455592, 0.11570021056624502, 0.1192876044590766, 0.11790265873569095, 0.27707557276968375, 0.36436274948929914, 0.2835947091348042, 0.2088761942596895, 0.1855915252195932, 0.18462811915682276, 0.187396306735794, 0.17427840533347938, 0.18100229025382264, 0.19224513830008017, 0.18866655998470627, 0.1803499415602935, 0.07126635965705408, 0.0773625302464025, 0.0810591168104573, 0.06230364829901536, 0.07171359131417776, 0.08420814510922736, 0.061720751844982935, 0.09094363580555076, 0.08140296374385869]}, "mutation_prompt": null}
{"id": "a3d96a0e-43e4-49e9-8d61-3172d4e76f3c", "solution": "import numpy as np\n\nclass DynamicAdaptiveHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)\n        self.inertia_weight = 0.5 + np.random.rand() * 0.4  # Slightly increased randomness for inertia weight\n        self.cognitive_coeff = 1.3 + np.random.rand() * 0.5  # Adjusted cognitive coefficient for better exploration\n        self.social_coeff = 1.3 + np.random.rand() * 0.5  # Adjusted social coefficient for better convergence\n        self.F = 0.5 + np.random.rand() * 0.2  # Dynamic scaling factor for differential evolution\n        self.CR = 0.8 + np.random.rand() * 0.2  # Dynamic crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "DynamicAdaptiveHybridDEPSO", "description": "A Dynamic Adaptive Hybrid DE-PSO algorithm focusing on environment-adaptive parameters to enhance convergence and exploration balance.", "configspace": "", "generation": 3, "fitness": 0.1819684370176353, "feedback": "The algorithm DynamicAdaptiveHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.19.", "error": "", "parent_id": "59dfe367-4241-430b-b3fa-cee8da258519", "metadata": {"aucs": [0.27411296078267355, 0.3352006256052402, 0.33464514103926324, 0.32561346144895775, 0.3472936633796013, 0.3927309566261886, 0.3379595524393947, 0.3555246347543344, 0.32981106739218735, 0.016103195278364346, 0.049184990340723767, 0.06297685996749447, 9.999999999998899e-05, 0.026978776035173513, 0.014616490191866838, 9.999999999998899e-05, 0.035155611421279875, 0.024897731785891497, 0.06056454200862538, 0.10805096771165623, 0.10149750060916451, 0.08129802280418175, 0.09191009754414337, 0.08250797851630998, 0.08408476665273101, 0.08678317252759149, 0.09826933414195649, 0.09553069693175764, 0.08193598237113298, 0.08833359588358414, 0.061400237020301396, 0.0910573914513414, 0.07895252332665914, 0.057495448786087366, 0.09990561566180023, 0.07751102989106406, 0.9644304653183079, 0.9620036119833844, 0.9641520067048186, 0.9651138781838151, 0.9632475141926692, 0.9629378668743188, 0.9634328565603526, 0.9598371633850967, 0.9627484814393935, 0.18584659381854507, 0.23772439804704304, 0.23374790472397444, 0.13487153297508958, 0.21512789656878073, 0.19330522225719493, 0.1581451984848763, 0.1825804627163382, 0.2034732474434382, 0.17451469531381336, 0.26588997374097456, 0.24712834321936805, 0.17857170938598643, 0.27973102319967824, 0.2211204572138611, 0.24097773099348518, 0.2235808043434847, 0.3046571353495918, 0.07176524250970484, 0.11246696997216188, 0.12380198241101681, 0.05731612629456473, 0.1339503330338544, 0.12129125826810616, 0.07894902946994387, 0.122564472489754, 0.10133047981643162, 0.10072760162836802, 0.09636662931778106, 0.09746876179159047, 0.08727732194396409, 0.11694179929150528, 0.10789836921021945, 0.04184215615604392, 0.10539969243029756, 0.10098867812485823, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015936029322219936, 0.010973275855679643, 0.011995269483239146, 0.040265590824106634, 0.057659915715719934, 0.031082863320629595, 0.009920689915140946, 0.05987118658821422, 0.08084289283379598, 0.08622755491375955, 0.04641921700329055, 0.1376441669270564, 9.999999999998899e-05, 0.0032798250010471763, 0.003640899237365214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0011769570938194862, 9.999999999998899e-05, 0.05747757363491002, 0.052756473865593345, 0.06806212400670031, 0.016096047488156406, 0.021745761899575666, 0.026382228241866312, 0.03610115486786891, 0.07776532429579164, 0.039650943516872594, 0.2989914917371086, 0.3506393282158572, 0.3457045966754222, 0.29867155768550413, 0.3054956060235402, 0.3015618317095745, 0.27991963709708023, 0.331060494387174, 0.3155155728129716, 0.07258072696982254, 0.08485655338940601, 0.10027791670813002, 0.07097945107374948, 0.08122756856543167, 0.06704735430216224, 0.08452820823939833, 0.0941203975697894, 0.07160895023912894, 0.1364687325758237, 0.15028024122789008, 0.1972887931837235, 0.14718849433313574, 0.193897110767836, 0.17656363021871002, 0.1542160866772776, 0.1750351102823242, 0.1583258532576045, 0.21875024498213547, 0.2423170624537816, 0.24919266062071688, 0.20126049926670198, 0.24988394503540412, 0.23627462250562914, 0.22533651076834615, 0.25613170118364337, 0.23953241781623535, 0.17000719391597963, 0.1769124230836383, 0.11929700628842399, 0.14874921069675162, 0.1691124911495997, 0.16480275523282417, 0.12301446537881688, 0.2019082008411025, 0.1734746051757351, 0.17651365754588788, 0.1819086327543361, 0.1792394027400609, 0.17898651420487344, 0.19377826917524743, 0.18229765939371612, 0.19682870567688437, 0.20536716850826664, 0.2015250542103575, 0.16582562768593767, 0.18588940743404525, 0.17139892883349717, 0.16663768420600422, 0.17104469113741583, 0.1688476733771187, 0.18161651225813447, 0.17613011745857277, 0.19225317289189248, 0.42443823290237614, 0.4393078113184775, 0.44159622964156653, 0.1544521147846919, 0.1839566663233917, 0.1538886648409501, 0.2668790206131152, 0.16941258126245462, 0.11552216492891221, 0.24901205243150293, 0.36786902330502613, 0.306406438119159, 0.24124975821548655, 0.1904801280908457, 0.373003255778136, 0.12550050559398096, 0.2922015577491386, 0.4482662842872701, 0.20297722769753423, 0.21081778965872422, 0.18407615715711467, 0.1919906859921432, 0.18390933775875773, 0.1846452032111593, 0.17054720791282452, 0.19335722115971288, 0.17776603516699252, 0.06901106130791634, 0.07225976006621371, 0.06427057899520328, 0.07432594089351674, 0.08061389944403197, 0.08646494653839232, 0.052083185715126046, 0.09699897518065825, 0.08235525956443834]}, "mutation_prompt": null}
{"id": "50be12e0-31a1-411f-b55d-f821ffebfa51", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3  # Random inertia weight for exploration\n        self.cognitive_coeff = 1.4 + np.random.rand() * 0.4  # Random cognitive coefficient for improved convergence\n        self.social_coeff = 1.4 + np.random.rand() * 0.4  # Random social coefficient to enhance information sharing\n        self.F = 0.6  # Slightly increased scaling factor for differential evolution\n        self.CR = 0.85  # Adjusted crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))  # Tuned velocity initialization\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridDEPSO", "description": "A robust hybrid of Differential Evolution and Particle Swarm Optimization with dynamic parameter adaptation and chaotic initialization for enhanced exploration and exploitation.", "configspace": "", "generation": 4, "fitness": 0.1902207802548816, "feedback": "The algorithm EnhancedHybridDEPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "59dfe367-4241-430b-b3fa-cee8da258519", "metadata": {"aucs": [0.32540016066480004, 0.35779182614287186, 0.3907319921543334, 0.411991585920936, 0.42744428184803684, 0.4222202982228921, 0.33661178698418137, 0.4071314450593694, 0.40026935917810846, 0.010821963744336638, 0.050193767567132674, 0.02868944332941481, 0.00024608538080861386, 0.05915427492748315, 0.015236921294931594, 0.0036965043596232094, 0.06459973356006854, 0.021569498089523576, 0.11367376106149074, 0.09447998911268152, 0.08011884755955723, 0.0818603450317833, 0.08743810677924813, 0.09825779774490495, 0.08929292972136227, 0.0890561285763597, 0.09857529617733707, 0.06624568476404458, 0.08643812274194884, 0.07450209571059963, 0.06707388973021922, 0.0858907732114671, 0.06573221581467659, 0.08627410125140855, 0.07269842550314864, 0.08282933286199823, 0.9742460030098516, 0.9623272152001086, 0.974249292407247, 0.9697130668763981, 0.9641546893712774, 0.9641624851425529, 0.9632831480661088, 0.9617430311585351, 0.9632477475504547, 0.16803705394994628, 0.21713986335032243, 0.1778482140522314, 0.20324774751867958, 0.23922883087950875, 0.16867654513640262, 0.1794511682674732, 0.2325781446827191, 0.20957565627271624, 0.20039633545879687, 0.2717774834695872, 0.23270057266999344, 0.2345427064127259, 0.20118176803812515, 0.15740402944999676, 0.24926094819953837, 0.2741293533470024, 0.27092364244655553, 0.0693604321034682, 0.10306563973362715, 0.11942474499597189, 0.10076401400822033, 0.1047341661747192, 0.22863982575731712, 0.0804772981054872, 0.1123799175861806, 0.10206175924378058, 0.0699401637445497, 0.10725461463778596, 0.10364503357919475, 0.12626883657347243, 0.10295190528091425, 0.0879045691150877, 0.10270056026507868, 0.11966846696962907, 0.1054217919876197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003030898881861921, 0.003216668019234148, 9.999999999998899e-05, 0.0009075301449295026, 0.005924390254214984, 0.0029307552893064193, 0.06854079710804639, 0.06617072631614718, 0.040722802597332186, 0.03672000635674044, 0.011746263600806328, 0.006874655391946538, 0.05470974680490348, 0.03544412059260482, 0.046719645825111566, 0.001475456393268515, 0.01332400316074922, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00495160149722873, 9.999999999998899e-05, 0.014239941544007761, 0.001694072219011522, 0.0803964432037041, 0.08303384215447862, 0.03281099592382486, 0.020932438852198754, 0.06319288747304086, 0.02258418106034077, 0.041009052223382914, 0.07926390623740354, 0.04578440931395522, 0.310405801690984, 0.3676937840335951, 0.3528224630817095, 0.3144504802183655, 0.3551342101109033, 0.38499021633281083, 0.3258352164721765, 0.35499435035045834, 0.3785593286079698, 0.10682343102857683, 0.09537978184603957, 0.10543419129737452, 0.05879056434072649, 0.10794898913782314, 0.0806543979552482, 0.07872143907745865, 0.09969177849630673, 0.09206126523654934, 0.17285020497586845, 0.13285680490170293, 0.171221964879107, 0.17139237196155332, 0.16970027962195, 0.17917678568713613, 0.16529563163477412, 0.1729475813554231, 0.17954544841921183, 0.20778183560054542, 0.2563506045398777, 0.24552117470770085, 0.2142117427295388, 0.25960312955001486, 0.24330931946123702, 0.22800154031996722, 0.29073452391845267, 0.23926119076827945, 0.15891842998530104, 0.1723689534716525, 0.1936494534455152, 0.1525083286576122, 0.1815411755422317, 0.1586690835466208, 0.12192981168705941, 0.206693973596484, 0.18221163164847298, 0.1889451732783285, 0.19546585060385346, 0.217019197715401, 0.17545951850688712, 0.1961852762929489, 0.18942879702814974, 0.21737296867430322, 0.22367062410862448, 0.1944510821590817, 0.17156011049965314, 0.17605758805280203, 0.1784588798412824, 0.18488944623740922, 0.19151661455306634, 0.1805440703974548, 0.1824162043553832, 0.18271752407412878, 0.18286897293532567, 0.6740604839895736, 0.5496476256997002, 0.5206810258566845, 0.15319699591236424, 0.1559075467426504, 0.15479347449430703, 0.3233157670113873, 0.4806588670171924, 0.396589869849978, 0.23565929110458705, 0.24772654379875825, 0.23698358179748402, 0.17933688602965592, 0.3322705884619397, 0.19889618366569561, 0.126526581438131, 0.12690057245133934, 0.2800529482934838, 0.19439379894545417, 0.1868842206429353, 0.21403826558870842, 0.17710883804761202, 0.179427191208823, 0.18808796586337806, 0.17521053429653255, 0.1811225527207987, 0.1830630323059138, 0.0756762701164726, 0.08062320541611412, 0.06825518713060574, 0.0700386780501231, 0.07634947800946834, 0.0737511465673637, 0.0899370798424528, 0.10067605924894873, 0.09688613972552884]}, "mutation_prompt": null}
{"id": "3129e5f7-ce9d-44c8-a05b-899539509cdf", "solution": "import numpy as np\n\nclass EnhancedHybridDEPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3\n        self.cognitive_coeff = 1.4 + np.random.rand() * 0.4\n        self.social_coeff = 1.4 + np.random.rand() * 0.4\n        self.F = 0.6\n        self.CR = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n        self.velocity_clamp = (self.upper_bound - self.lower_bound) / 10  # Adaptive velocity clamping\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with stochastic multi-leader selection\n            leaders = np.random.choice(personal_best_positions, size=3, replace=False)\n            leader_position = leaders[np.argmin([func(leader) for leader in leaders])]\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (leader_position - positions[i]))\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridDEPSO", "description": "A robust hybrid of Differential Evolution and Particle Swarm Optimization with adaptive velocity clamping and stochastic multi-leader selection for enhanced convergence and exploration.", "configspace": "", "generation": 5, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('a must be 1-dimensional').", "error": "ValueError('a must be 1-dimensional')", "parent_id": "50be12e0-31a1-411f-b55d-f821ffebfa51", "metadata": {}, "mutation_prompt": null}
{"id": "30832ae9-4789-4abd-97f8-918444c7cfa6", "solution": "import numpy as np\n\nclass AdaptiveMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 15)  # Adjusted population size\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Adaptive inertia weight\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.6  # Adjusted cognitive coefficient\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Adjusted social coefficient\n        self.F = 0.5  # Reduced scaling factor for better stability\n        self.CR = 0.9  # Increased crossover probability for more trial candidates\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with boundary reflection\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Reflect boundaries\n                positions[i] = np.where(positions[i] < self.lower_bound, self.lower_bound + np.abs(positions[i] - self.lower_bound), positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, self.upper_bound - np.abs(positions[i] - self.upper_bound), positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "AdaptiveMultiStrategyOptimizer", "description": "An adaptive multi-strategy optimizer combining enhanced PSO and DE with stochastic learning and boundary reflection to balance exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.21898155971752561, "feedback": "The algorithm AdaptiveMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.18.", "error": "", "parent_id": "50be12e0-31a1-411f-b55d-f821ffebfa51", "metadata": {"aucs": [0.3769477074532419, 0.5662345122748995, 0.5056113031028001, 0.40095071619590994, 0.620187444106364, 0.5232237500275636, 0.4341152249440623, 0.6112526424650668, 0.5346938478960818, 0.07713157469173071, 0.1413182567474507, 0.2325465454696385, 0.07262395008298916, 0.223080016700125, 0.2032600411601475, 0.06664685380564461, 0.1828643377692779, 0.2031294462265928, 0.10629040871248252, 0.13018503929345004, 0.13063247561423974, 0.11931693048934044, 0.1291900498508245, 0.15070242974867631, 0.08095625278321783, 0.10577223867728447, 0.10468649591118884, 0.10011193704192412, 0.08803513090553294, 0.11592293556407496, 0.0860119562002819, 0.11496238673504044, 0.11230349008993468, 0.11058014237247737, 0.11583061781868531, 0.12262610393095308, 0.5759467975964753, 0.8382661180183825, 0.795199980525038, 0.5625571428010465, 0.8356673289557965, 0.9347364996903791, 0.17695254482306122, 0.9339476402272816, 0.2369802295488156, 0.23541158587694544, 0.345392871134099, 0.30652484256893997, 0.18143679844876148, 0.3465074433865277, 0.2923712996933121, 0.19923349998997308, 0.34436989366931403, 0.30411508808747834, 0.20435702345073825, 0.6761772685801302, 0.20519004118424833, 0.3669473508188146, 0.24771921478889536, 0.2562671149118966, 0.20081276561095218, 0.5914373472570629, 0.21764408945760738, 0.14039681675621818, 0.1575591231453063, 0.15972307110508432, 0.1183772764913763, 0.12733837736689746, 0.1513388986630687, 0.21292086402491173, 0.15476947778725625, 0.19125125323929393, 0.11956996978427947, 0.1819846283603781, 0.1353465190715788, 0.13000424287698586, 0.17834537753034152, 0.18235263739774987, 0.11324641227857268, 0.15873479722601402, 0.12358175886052736, 0.0005945252551035063, 0.057809742576240164, 0.025346710130128458, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04423160798621972, 0.02514993428107193, 0.03435400942512734, 0.03989509115276957, 0.10139456157989812, 0.14221488156932804, 0.08980856748788324, 0.030456241527647254, 0.025503637819811242, 0.10038379695675737, 0.07079827333758126, 0.09730717930478117, 0.00039650360624143843, 0.020610242444311755, 0.0675240694201531, 0.011651776474348341, 0.030107501491673294, 0.11918717170391468, 0.013680322226000463, 0.052186034149043325, 0.04907048495940036, 0.06106417736439018, 0.09944215027434333, 0.1275613210688058, 0.06777349432354807, 0.05988277168408407, 0.12385330587012033, 0.0544551893447337, 0.1589871506246998, 0.10126343040017671, 0.374796455336612, 0.45802406979637034, 0.4427784601360628, 0.3814386273368171, 0.44281558513780117, 0.4331017961077208, 0.40740964244486555, 0.45218745545720107, 0.4049570126498012, 0.09677502246560621, 0.11298610131534281, 0.1380627137256697, 0.1442706849242511, 0.12249558330178056, 0.09079004100030541, 0.07829862670218712, 0.12104063694588185, 0.0992736375351827, 0.14847105346055156, 0.19017826930130233, 0.18869659804982364, 0.15511374764034758, 0.18627526209801493, 0.13847889310215578, 0.16741008672427793, 0.22944741312840655, 0.16457852584243626, 0.2687471982877201, 0.28408819950778275, 0.3167730052732185, 0.2691574883033412, 0.3055951356679668, 0.3051054182291325, 0.26772113698770894, 0.3048413614197878, 0.2542791213384952, 0.15975812869612038, 0.20364504455162247, 0.21283787286417333, 0.19662569270556296, 0.24283660863473078, 0.23229482507732202, 0.18654740098275824, 0.22907686956131224, 0.22980520578376917, 0.19334477869693134, 0.18996942286118668, 0.21280812640749236, 0.19648234893979666, 0.24039093164744318, 0.19090413668638817, 0.19775253987561314, 0.21923921810394964, 0.21322880281334933, 0.1707821465615772, 0.2012643039642641, 0.22146292081342578, 0.17728363404831016, 0.2031273260815979, 0.1921375610604512, 0.17076175459448695, 0.21616245630999853, 0.18747124405902282, 0.531604850872973, 0.7793131703227382, 0.7449024636496687, 0.15340849778717824, 0.15572068714507803, 0.1575556320171212, 0.17786293288623478, 0.16549062718428142, 0.1416660745400231, 0.4047422872823184, 0.5744747420207958, 0.45669130749283715, 0.2047626890773463, 0.20553197370512177, 0.20540870349299967, 0.2369646722099389, 0.349107636464286, 0.48057428596535734, 0.19479225132370137, 0.18173652882796865, 0.18884985371191865, 0.18115403170105004, 0.18226920992502726, 0.17714833635459692, 0.17330560251261962, 0.17128821447024167, 0.19853337848421881, 0.07510241341328583, 0.0929020668284598, 0.09365589473796587, 0.09258822919142895, 0.09966134977642938, 0.11306186667418494, 0.07652429098281466, 0.09782692332182763, 0.09617947981955544]}, "mutation_prompt": null}
{"id": "2d2d7d03-4ab4-4b42-b758-bd94b94058d5", "solution": "import numpy as np\n\nclass RefinedAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 20)  # Adjusted population size\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3  # Adaptive inertia weight\n        self.cognitive_coeff = 1.5 + np.random.rand() * 0.5  # Adjusted cognitive coefficient\n        self.social_coeff = 1.5 + np.random.rand() * 0.5  # Adjusted social coefficient\n        self.F = 0.6  # Slightly increased scaling factor\n        self.CR = 0.85  # Slightly decreased crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with boundary reflection\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n\n                positions[i] += velocities[i]\n                \n                # Reflect boundaries\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedAdaptiveOptimizer", "description": "A refined adaptive optimizer blending PSO and DE with enhanced dynamic adjustment and boundary management for improved exploration-exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.17798776976166, "feedback": "The algorithm RefinedAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.20.", "error": "", "parent_id": "30832ae9-4789-4abd-97f8-918444c7cfa6", "metadata": {"aucs": [0.28665539498568104, 0.3202672716702444, 0.31003815540534707, 0.33291745995003963, 0.35765485026221366, 0.34074847687515686, 0.34386500028511946, 0.3420961544686517, 0.3951693875010249, 0.007332133420219544, 0.019651318033004794, 0.047360588198634423, 0.00033387740883850103, 0.012538651292776759, 0.005085172822148931, 0.0049335575075605265, 0.01033940979135528, 0.05689273559616581, 0.08709260842697364, 0.08486845294287582, 0.08216026247303221, 0.07940488962200343, 0.09997424139406808, 0.07392469096455656, 0.07209183676563713, 0.09830682623148856, 0.08807714868480543, 0.07342758933205584, 0.08890859796584571, 0.07935806528885403, 0.09190717477832278, 0.09173986163101655, 0.07830684234122764, 0.06185480165056212, 0.07934017264969284, 0.08953590517278753, 0.9785477753012873, 0.9629582311474086, 0.9784841446057849, 0.9743907187399589, 0.9694117734775494, 0.9743834763860177, 0.9743636394340636, 0.9623257274299077, 0.9743453118734504, 0.17210264445547563, 0.19501658999451899, 0.20514188587793858, 0.17562194411018717, 0.16515656438940862, 0.136264736767586, 0.0872459389402016, 0.2034802998547871, 0.18094065232494128, 0.15067350236424337, 0.2257019833989916, 0.2654708298548072, 0.1559018905063615, 0.15415905035561628, 0.18930662624757866, 0.15982298001938122, 0.20968127843498285, 0.2070057688671051, 0.08568648542552415, 0.08526544447691264, 0.12098155848398817, 0.08885190527745601, 0.09644933411907719, 0.11652779639839805, 0.05264636955036317, 0.12363542178450337, 0.08252526881007305, 0.046198830352958464, 0.049110515175380676, 0.07683602048232296, 0.08134669941447714, 0.12022339644760927, 0.16454360330036832, 0.03579934575092125, 0.11343422448674412, 0.09291855988504616, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014077725094931992, 0.01166625965228163, 9.999999999998899e-05, 0.0001686171200141473, 9.999999999998899e-05, 0.0004982838853986316, 0.021548353149644206, 0.03425393678383193, 0.08272245553469071, 0.03988581768785571, 0.005251431640653559, 0.022634887803905213, 0.05011150370067374, 0.08418368682171773, 0.04478517539871496, 0.048808397417500426, 9.999999999998899e-05, 0.0022513213995669634, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.037459827448664496, 0.04214196798858705, 0.07947104352335632, 0.02930259283371872, 0.026939312009941374, 0.03831986973306756, 0.03689439997664501, 0.041581840640965706, 0.04572025132848734, 0.33124961893910077, 0.29950635652540747, 0.3241362310111441, 0.31220124365941226, 0.3583966364188568, 0.3358776662762365, 0.2734535334874558, 0.3121758281188495, 0.29303318704482695, 0.07255892455433555, 0.0898370062586753, 0.08402646152388205, 0.07400487696081548, 0.09479480433834175, 0.10579294911500059, 0.058996199978989194, 0.07912208249831287, 0.08514349163582935, 0.1559870384676798, 0.15141021418687983, 0.16150765017687385, 0.17498885546926646, 0.15854718865219386, 0.18468790889704068, 0.13000554839844958, 0.14876857302211977, 0.14347541145276232, 0.19586645409215275, 0.24691830412922122, 0.22616622548586296, 0.2252780703898528, 0.24792212671726033, 0.24278179268969002, 0.23727428016045904, 0.25736507508154893, 0.25911693380515155, 0.16947404419090273, 0.183194478401718, 0.1570772731761252, 0.1612627726513849, 0.17057307469457006, 0.16051726284708379, 0.11479558553294522, 0.1404726875474167, 0.1593697261772169, 0.17836989642333922, 0.19055374123474655, 0.18287619220348905, 0.17782568453047498, 0.20090370056368434, 0.1909020463001604, 0.1820310595432516, 0.1898731536878966, 0.1883464822704658, 0.1676483569804753, 0.1813616056916172, 0.1773399557800911, 0.1680389214696716, 0.18553116611036224, 0.184513815778805, 0.1822712456448652, 0.1875269895046877, 0.175123884520611, 0.4844026537707443, 0.5448720822211286, 0.5927548485104073, 0.14496948493047512, 0.15615500115680092, 0.19476232953243167, 0.16758513532985908, 0.3613494300647233, 0.17850525240497495, 0.2435715864785828, 0.25564328333289454, 0.33013514346103734, 0.1870278102246471, 0.2700483773025697, 0.1899836240644488, 0.29840001151400497, 0.2674500005062256, 0.32939191973974746, 0.18125381770259008, 0.18621466212913873, 0.20042213856379865, 0.1914528783252315, 0.1741510358625017, 0.1871283498133418, 0.1740879389111687, 0.18148517663341013, 0.178772548323045, 0.06832366326729677, 0.06953004288215103, 0.06329221455066314, 0.06038812615941369, 0.06955053876731543, 0.0684730598166785, 0.06397374890263985, 0.06833176187314549, 0.07711372385030302]}, "mutation_prompt": null}
{"id": "db6a2b08-2846-40c0-b847-57bdeae93d5f", "solution": "import numpy as np\n\nclass RefinedMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 15)\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3\n        self.cognitive_coeff = 1.5 + np.random.rand() * 0.5\n        self.social_coeff = 1.0 + np.random.rand() * 0.7\n        self.F = 0.6\n        self.CR = 0.8\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.1 * np.random.randn(self.dim))\n                positions[i] += velocities[i]\n                \n                positions[i] = np.where(positions[i] < self.lower_bound, self.lower_bound + np.abs(positions[i] - self.lower_bound), positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, self.upper_bound - np.abs(positions[i] - self.upper_bound), positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedMultiStrategyOptimizer", "description": "A refined multi-strategy optimizer using adaptive PSO-DE with enhanced diversification through random exploration and momentum control for improved global search capability.", "configspace": "", "generation": 8, "fitness": 0.1800630135541787, "feedback": "The algorithm RefinedMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "30832ae9-4789-4abd-97f8-918444c7cfa6", "metadata": {"aucs": [0.2991159819141025, 0.35058510436078827, 0.3535777777696053, 0.3365075157805284, 0.3557621756044891, 0.32711003327383303, 0.2843186212033252, 0.34720332170837487, 0.36839779258804306, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000634668041786024, 0.005193166078362066, 9.999999999998899e-05, 0.002166204114889103, 0.004297762054973786, 0.010490141447782708, 0.10270319106716319, 0.09257263693953988, 0.07395342409888306, 0.09879949486983097, 0.08808152639018063, 0.08114159982439195, 0.08088315780905742, 0.09108656360367218, 0.08290483592157738, 0.06072123181115785, 0.08252533661954198, 0.07148226625402565, 0.06977733604815128, 0.08205447663106735, 0.07347579769920143, 0.08249781637132925, 0.080112500279226, 0.07552520856780376, 0.9317491731976476, 0.8754695341841214, 0.8569061693209651, 0.4288952178362905, 0.8731645368298617, 0.8361863028004105, 0.3463059408728687, 0.9039027528399152, 0.6506156476261173, 0.19320752628907423, 0.20860514286261422, 0.19543570850672687, 0.18289913950762238, 0.23625107262355893, 0.1887313679343311, 0.20407498077864894, 0.23500842488064733, 0.2083011296744819, 0.21335734795166195, 0.27714606990754664, 0.21925589204416052, 0.21959591780736343, 0.18642184179600962, 0.24528542457361968, 0.20826031677126078, 0.2715636967043704, 0.22167514388871878, 0.10932128561046106, 0.11279396025683475, 0.11253072575253664, 0.09879396350970093, 0.12938057193906638, 0.08010382098766444, 0.12565110544416314, 0.12350777621838838, 0.13353370940538312, 0.08544754082391248, 0.11466766577204324, 0.11837417263788941, 0.11850308804256293, 0.11645047979839196, 0.13314294961348438, 0.10450837745007135, 0.11057406376337897, 0.09302608575890281, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010041289699708078, 0.015250273799064185, 0.1211550380877614, 0.070384392303522, 0.0687041898914369, 0.007591999623733692, 0.1432622901646584, 0.02471462730409968, 0.059147167525354094, 0.09811934404908407, 0.05121845845840889, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.035051095441893665, 0.0673656754097437, 0.055898253858480684, 0.05747277576125798, 0.06972649603007086, 0.060157468898914934, 0.043086788372505014, 0.07107371777918525, 0.07153376588632887, 0.32050543210399696, 0.3633013161260392, 0.35099299986575727, 0.32074316266526126, 0.3382409655694073, 0.3232359883869087, 0.31811461992437085, 0.3406969583901659, 0.3381401069478892, 0.0781080075144035, 0.09076506076498081, 0.09057128971213746, 0.07325590157945483, 0.09198552789234893, 0.10280499849214142, 0.08093271157448667, 0.08087638522356244, 0.08484835350180586, 0.11891990447839873, 0.15206767569235013, 0.1605189700810844, 0.12166582557693095, 0.13198949648189284, 0.1510786825103212, 0.1375442702042523, 0.15300088353959584, 0.1560454173378959, 0.19506185317439828, 0.24818781266874457, 0.24302109251139625, 0.21538896052302103, 0.2426495821962671, 0.2338645787644602, 0.25224565117322717, 0.24124493575832107, 0.27082258596296893, 0.16325592796474375, 0.17392565338778787, 0.18759253864909098, 0.15217088107999988, 0.19077210313870685, 0.17226873933712938, 0.13905831797870027, 0.18348099612189495, 0.1448749796609452, 0.18372429822116487, 0.21025417699368432, 0.19870903696004982, 0.19763438771959052, 0.20763052502984025, 0.19062653561977816, 0.18711971118192494, 0.2262134669499094, 0.18751425528933496, 0.17811436929848457, 0.18615864389971237, 0.22673939924495756, 0.16987390520476053, 0.178498151435603, 0.18739308515597985, 0.18707556316795726, 0.189658928163414, 0.17630349659463496, 0.4260654974672714, 0.5122597203542762, 0.4824694094268067, 0.37415820561621926, 0.4971848830012996, 0.4789596888207819, 0.3076491516129062, 0.49192566529135895, 0.17755897271115628, 0.3110254129985841, 0.36111902730825063, 0.20568354684301215, 0.1776279989190509, 0.38880501291411396, 0.20374719295439103, 0.22202565097039062, 0.16376708860633094, 0.1614661134552915, 0.18170676822774856, 0.1819059860175275, 0.18716821738814382, 0.1917975430316584, 0.18787006460370725, 0.17962958443453736, 0.1906909827235369, 0.17977697172635, 0.19198090585525285, 0.07527433080839196, 0.07944674244728234, 0.07254490528320545, 0.07733572178493264, 0.09717903582373588, 0.07894135673019065, 0.07516653414523722, 0.09504923140310106, 0.07937122978878774]}, "mutation_prompt": null}
{"id": "b6d4ad0d-c8d3-4133-9693-1a0f92a14e50", "solution": "import numpy as np\n\nclass RefinedAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 12)  # Adjusted population size\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3  # Adaptive inertia weight\n        self.cognitive_coeff = 1.5 + np.random.rand() * 0.5  # Adjusted cognitive coefficient\n        self.social_coeff = 1.5 + np.random.rand() * 0.5  # Adjusted social coefficient\n        self.F = 0.4  # Reduced scaling factor for better stability\n        self.CR = 0.8  # Adjusted crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with enhanced boundary reflection\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Enhanced reflect boundaries\n                positions[i] = np.where(positions[i] < self.lower_bound, self.lower_bound + np.abs(positions[i] - self.lower_bound), positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, self.upper_bound - np.abs(positions[i] - self.upper_bound), positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedAdaptiveOptimizer", "description": "A refined adaptive optimizer that combines PSO and DE with enhanced boundary reflection, adaptive inertia, and dynamic coefficients for robust global optimization.", "configspace": "", "generation": 9, "fitness": 0.1676349260023906, "feedback": "The algorithm RefinedAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.13.", "error": "", "parent_id": "30832ae9-4789-4abd-97f8-918444c7cfa6", "metadata": {"aucs": [0.33165476496027435, 0.3799022664801972, 0.39703130076096815, 0.34348171794544047, 0.38591292048266845, 0.3571582796088807, 0.311854355245348, 0.42647976981754687, 0.3869778077430278, 0.007737189188547711, 0.062227792150946315, 0.07242199343402322, 0.050965326453536575, 0.10207407222262554, 0.08179174730068339, 0.017130084434128334, 0.05713214222288521, 0.04985649977147388, 0.11410208276329192, 0.10800280840186405, 0.08992625029540535, 0.09675131322361707, 0.08676488280305816, 0.09822441971678364, 0.08919817715469258, 0.09936938656410765, 0.10051683261656108, 0.07982775956686872, 0.0793266498250288, 0.08651333603046751, 0.08724825021943983, 0.08577221020411419, 0.0817084043011913, 0.09287065529564131, 0.0672779769049292, 0.0859760331477768, 0.7476931881833804, 0.5018262094226118, 0.1603665082241077, 0.13559098460885866, 0.7597432199482087, 0.18981752729976664, 0.17949873597341048, 0.15848721829539936, 0.16758900967977375, 0.21224302589907607, 0.25310637222544263, 0.19884762238728315, 0.1688758661082993, 0.24994529766418827, 0.23005970388441888, 0.13746381585381584, 0.16516258228385472, 0.22220171468516958, 0.18709841675022776, 0.19522023632912555, 0.4618672010991337, 0.2652276868466221, 0.18225147236858097, 0.22795517323455516, 0.1882242974516759, 0.23841461689101218, 0.20855824800997302, 0.1164694426261218, 0.10916941044294659, 0.13108617791778365, 0.07908987304105974, 0.10740166284168351, 0.12309712051335209, 0.11035260734783348, 0.12453858016312458, 0.10302223675818822, 0.07911147233473292, 0.11657002814506268, 0.09653114044830657, 0.13011853838024545, 0.16142546144414915, 0.11718464952156005, 0.04752148820791424, 0.1130240431663444, 0.13817723272479543, 9.999999999998899e-05, 0.00023667222116341424, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006165964891592379, 0.025082576195957107, 0.013056626169911212, 0.06816948954548274, 0.07791441669069066, 0.05618617417349292, 0.07279516916198558, 0.02369442245474651, 0.11382277583933542, 0.02585751596712549, 0.05110282971655111, 0.06593133633534431, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013685330831458842, 9.999999999998899e-05, 0.00987366475468554, 0.005021640702965069, 9.999999999998899e-05, 0.015203850227825, 0.009084435562381254, 0.0192660300436861, 0.06913100163581842, 0.0962101376155059, 0.04495015048041495, 0.06910900635191342, 0.07030315415949229, 0.05068026965489458, 0.06811687745460515, 0.06560145525770855, 0.2991421618381449, 0.3340024737921029, 0.3735950497044519, 0.328062213671404, 0.37198009551016753, 0.3304842342984964, 0.31504605750683534, 0.34961115072574434, 0.37252432744347863, 0.06378509543142896, 0.08450066070036633, 0.0825242661939295, 0.08356702780806224, 0.08977361237104964, 0.0979345902595038, 0.1111977501640451, 0.08103714466873935, 0.09483996819406781, 0.12237399475750643, 0.1671977759922063, 0.1416877964309895, 0.14640478907454835, 0.15251880890646552, 0.14187476616474393, 0.15150969062256048, 0.16790768613596052, 0.1419919459037372, 0.22572231401532694, 0.25321376018913244, 0.24314999251393965, 0.2645459694946777, 0.2763134940784322, 0.22071947195204245, 0.22480286968453966, 0.25220314910955355, 0.25734639529315684, 0.14426550461583842, 0.16843189566117434, 0.17985363926521425, 0.14917206527813942, 0.17164675866269985, 0.1974190739690166, 0.14668131477377244, 0.19792741041841266, 0.17565049461398863, 0.172973513522083, 0.1823924301863894, 0.20397905944145978, 0.1711892825849518, 0.18907950547361052, 0.18828450643595718, 0.18675271682857408, 0.21619668775125156, 0.19735510889695584, 0.16731416220859063, 0.1705221484010876, 0.20033211774398063, 0.18380470619517564, 0.2003634374138914, 0.1958324239963496, 0.18474128349122898, 0.18406416175313156, 0.18508840218656963, 0.4962947352342576, 0.5674031937235346, 0.585127266791744, 0.2599412625193521, 0.423008824182727, 0.45356572057143496, 0.28379130574926525, 0.385300230030196, 0.19354265478778987, 0.19708061262582777, 0.26697778011084083, 0.199430864285297, 0.19324196917490521, 0.1988737873189812, 0.19991607185402638, 0.2191248586654697, 0.286265048452669, 0.4910092848378811, 0.1926525880200438, 0.17785863718700656, 0.1921198288227246, 0.18133272479550733, 0.18386829362008705, 0.18642432504177064, 0.17357294786628097, 0.17659319963728992, 0.17944524937036388, 0.07488940991134008, 0.07514012514567492, 0.0837266789345702, 0.0528375508507255, 0.06920558291294232, 0.09263682670079376, 0.0763874951920388, 0.09103834839932201, 0.085430985983448]}, "mutation_prompt": null}
{"id": "7555b8f9-b48e-407e-aa6a-519a265d7a3e", "solution": "import numpy as np\n\nclass RefinedMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(90, budget // 14)  # Adjusted population size\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3  # Enhanced adaptive inertia weight\n        self.cognitive_coeff = 1.5  # Fixed cognitive coefficient for stability\n        self.social_coeff = 1.5  # Fixed social coefficient for stability\n        self.F = 0.6  # Enhanced scaling factor for diversity\n        self.CR = 0.85  # Slightly reduced crossover probability for varied trials\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Modified velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with boundary reflection\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Reflect boundaries\n                positions[i] = np.where(positions[i] < self.lower_bound, self.lower_bound + np.abs(positions[i] - self.lower_bound), positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, self.upper_bound - np.abs(positions[i] - self.upper_bound), positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedMultiStrategyOptimizer", "description": "A refined multi-strategy optimizer enhancing solution diversity and convergence through adaptive inertia and crossover strategies.", "configspace": "", "generation": 10, "fitness": 0.18758490417043722, "feedback": "The algorithm RefinedMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.15.", "error": "", "parent_id": "30832ae9-4789-4abd-97f8-918444c7cfa6", "metadata": {"aucs": [0.33301926256509917, 0.3562780810158055, 0.3914840519773596, 0.38012946371963774, 0.45428402457267636, 0.407993914304559, 0.38944159312093574, 0.37552439548745975, 0.4077591873031188, 0.045844236302781116, 0.1218385302097087, 0.036896095876538526, 0.005203740086577868, 0.040839984041434185, 0.06392356726093928, 0.04423047436507732, 0.09474628449744338, 0.12549299139229475, 0.10403678731620081, 0.10487556877068127, 0.09988967552120609, 0.10132646834796866, 0.0876783893015265, 0.08393996760863098, 0.0997085362159934, 0.08070741262349057, 0.08369984630053695, 0.09555000226761401, 0.0910292830532784, 0.09755318468588448, 0.07877984119212056, 0.08606676652402034, 0.06485518694364034, 0.07968798937488386, 0.07471399777602505, 0.09994142562341535, 0.474228025179537, 0.576815466430755, 0.579484618075436, 0.7166961633619696, 0.7437170605769903, 0.1737117972859905, 0.721487616009395, 0.7187007663330175, 0.7603112774705372, 0.20485129408547031, 0.2658506601379723, 0.19546945593163045, 0.20604164291752947, 0.16488141170815251, 0.169927410574633, 0.18658914711944974, 0.20208918535702813, 0.23654093893539285, 0.23511920708647982, 0.3018323306070497, 0.25760538030818947, 0.1888802334340638, 0.20055944129643544, 0.21391930053613306, 0.19328911241747926, 0.567926834253516, 0.268974370467301, 0.14272260122557767, 0.12252606879715144, 0.09621328821895603, 0.07671041974361159, 0.09448960294674924, 0.08105785313251923, 0.13088385527520152, 0.13243316898262492, 0.13807144312162678, 0.09853694332276541, 0.11805552826865551, 0.13049141960889354, 0.07460039222220238, 0.09476888365560521, 0.09742683262076257, 0.07800481568649886, 0.07535497848624595, 0.11250371158652761, 9.999999999998899e-05, 0.00745448415285066, 0.005147204092742719, 9.999999999998899e-05, 0.00126811656987047, 0.0007944493132887587, 0.04381673434770328, 0.02907520819744036, 0.038114256507839284, 0.06855997242065692, 0.08100518148548286, 0.059788505890545296, 0.05440077203937177, 0.07229341632944164, 0.06048922136222268, 0.10848480032160901, 0.08645275393397134, 0.09119891317183826, 0.007748884627225561, 0.000127146392065014, 0.005334704415706604, 9.999999999998899e-05, 0.013491335423561956, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005465242028418471, 9.999999999998899e-05, 0.06168009175114553, 0.10375560675341478, 0.10570171003893425, 0.07324711785279048, 0.0734222628642417, 0.03869606868062725, 0.04027010853206103, 0.09402795600432923, 0.08336355542663931, 0.3626148875432287, 0.39209488601860243, 0.3854228962809717, 0.34512517132387166, 0.36120801907473565, 0.3339341992730207, 0.34070066791823117, 0.3534485318812536, 0.34769230947119745, 0.08414606657665302, 0.08142289267889513, 0.12249669316943923, 0.09121250697599859, 0.09895986438232596, 0.10225894709386962, 0.0797740375526913, 0.10259336042078071, 0.088779718682935, 0.14952579602799654, 0.1359992345548171, 0.1603532489054631, 0.1349235381592787, 0.12648135946345707, 0.12750552466108822, 0.14692499504964618, 0.17235603282651557, 0.17422900035564837, 0.25619947317235015, 0.2657206008058717, 0.24597695463756142, 0.25435443357786514, 0.24998582651886436, 0.23953793012751456, 0.23638793087660848, 0.25654152243797024, 0.2557681943794059, 0.18978993040050451, 0.20112639308446856, 0.20155137027469727, 0.180624416329624, 0.1597933118482353, 0.1970761394396503, 0.1867332272377602, 0.21449153757180373, 0.2066605375314231, 0.20333758220778142, 0.18461133321069623, 0.1787131366301855, 0.20073321805808086, 0.18806793069962313, 0.19727535791988005, 0.18549060689362296, 0.1799229652048403, 0.19735966049861609, 0.17380347592029177, 0.2041697909965292, 0.18475510572144016, 0.1808480812348192, 0.1750983260516067, 0.1959346883537878, 0.18050878828454608, 0.2053331529861755, 0.1896548959204094, 0.5364445559245744, 0.6014909202462855, 0.5173438612029733, 0.34446948829003177, 0.4390867376941967, 0.4680533302057013, 0.16876875240781408, 0.16998358394652202, 0.16982429095409046, 0.2461005835541722, 0.41970777999465647, 0.35449231631164235, 0.19988514713292727, 0.2063001417440029, 0.20538836491179302, 0.5550744364105287, 0.4301106767043229, 0.3969346080020386, 0.17834904535826668, 0.20517012652632105, 0.18937239824515095, 0.19627024472356647, 0.18289244025346596, 0.18889001528087745, 0.17387541675641693, 0.19465486225786177, 0.18031041342520038, 0.08753414565090412, 0.07556395740412958, 0.09435942522287621, 0.07847107743308845, 0.07722960215123076, 0.08514184551432902, 0.09445740875892039, 0.08423098567573728, 0.09630487572136148]}, "mutation_prompt": null}
{"id": "0c5f4e4c-cff0-48aa-bd93-677a295ac69b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 12)  # Adjusted population size\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3  # Dynamic inertia weight\n        self.cognitive_coeff = 1.5 + np.random.rand() * 0.5  # Enhanced cognitive coefficient\n        self.social_coeff = 1.0 + np.random.rand() * 0.8  # Enhanced social coefficient\n        self.F = 0.6  # Adjusted scaling factor\n        self.CR = 0.8  # Adjusted crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        # Chaotic sequence initialization\n        positions = self.lower_bound + (self.upper_bound - self.lower_bound) * np.random.rand(self.population_size, self.dim)\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with boundary reflection\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Reflect boundaries\n                positions[i] = np.where(positions[i] < self.lower_bound, self.lower_bound + np.abs(positions[i] - self.lower_bound), positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, self.upper_bound - np.abs(positions[i] - self.upper_bound), positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedAdaptiveOptimizer", "description": "An enhanced adaptive multi-strategy optimizer with dynamic parameter tuning and chaotic sequence initialization for improved exploration and exploitation.", "configspace": "", "generation": 11, "fitness": 0.184212584179378, "feedback": "The algorithm EnhancedAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.16.", "error": "", "parent_id": "30832ae9-4789-4abd-97f8-918444c7cfa6", "metadata": {"aucs": [0.368325665701542, 0.42726765872974215, 0.37467611188516725, 0.3558648342382821, 0.41189679069110663, 0.33768228049435645, 0.38538623284459517, 0.45624368445933783, 0.32641313620160173, 0.04477351239214844, 0.10749814624158316, 0.06533372974275731, 0.012552585482016876, 0.11382879854094918, 0.04914054866097828, 0.028362521655949657, 0.09552382995836872, 0.1277810088078506, 0.07976454465176774, 0.10587198931869257, 0.0867411646618178, 0.07349379780294385, 0.10931434776319116, 0.08443496032499098, 0.08022697993484929, 0.09811421745808979, 0.11015340810213003, 0.06478981623806468, 0.08762765869860756, 0.09781302950624471, 0.06806930264113997, 0.10331045036826636, 0.08411949374101446, 0.06809639012134361, 0.11028424510555268, 0.08505162726022297, 0.8991176233263637, 0.806886939108262, 0.19023019361391436, 0.5978366428143379, 0.8646292428924108, 0.851352870367954, 0.667486254411999, 0.862569772922704, 0.2303157775925888, 0.19374438832932073, 0.272568886496652, 0.24036572321749006, 0.15224179859225662, 0.27431748082857677, 0.23030426719244956, 0.1957504430928385, 0.23364720967786545, 0.197218152733313, 0.23051231747304013, 0.22330226658923236, 0.20560344584805557, 0.22961433674671095, 0.2387491883496481, 0.20750439786579022, 0.1967109559222775, 0.25894982796591914, 0.2664153121360453, 0.09359167504602961, 0.12734741178786557, 0.11940724916522372, 0.12271757774088143, 0.13597187257177323, 0.13367976479702626, 0.10984268995751334, 0.108489521374865, 0.1312166644028564, 0.08642433119657111, 0.11964902522089416, 0.12044481248297456, 0.12310080361795805, 0.11533713978031268, 0.11421392554301124, 0.07356670020335299, 0.13828820984051404, 0.12648069613468282, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001352415718697042, 0.003840613039120422, 9.999999999998899e-05, 0.057360815246057406, 0.020920760525702464, 0.08263370526262082, 0.07049999618283398, 0.04937484493979882, 0.029659413514490196, 0.028920138612612556, 0.04684061251815097, 0.10061526006532584, 0.08777000028335447, 0.08636314636723386, 9.999999999998899e-05, 0.006610180581602565, 0.011355191310136958, 9.999999999998899e-05, 0.027952903578097543, 0.0026265083576053616, 9.999999999998899e-05, 9.999999999998899e-05, 0.008899780528415113, 0.04250997182708505, 0.09245300438388748, 0.058873681751061335, 0.03467390759121847, 0.0864805973010645, 0.10234264418999028, 0.03614494872262619, 0.07748382803597031, 0.08924221406275823, 0.33929742554200526, 0.40087576553161364, 0.3820678294469395, 0.32855806121449604, 0.40089881974211505, 0.34380172602229764, 0.32458762416259723, 0.37035455401215833, 0.3393001774547212, 0.07472954661785247, 0.09726274219352504, 0.0952417679406008, 0.08849522995336045, 0.09084607854671034, 0.08239161197219291, 0.06589582036733721, 0.09566246782645682, 0.08680902835965609, 0.1562265038433427, 0.12359641319642034, 0.14070358023965668, 0.15734198143638445, 0.14219178422986356, 0.20700379477460062, 0.14144593786229231, 0.13509100667239982, 0.17423369487893925, 0.19473504364066185, 0.2553815954061375, 0.27101703457501747, 0.2185537546186359, 0.22608782431424002, 0.24640724332928998, 0.24915219785095988, 0.2908860161033505, 0.25811161524162285, 0.1631099833664159, 0.21569521939696412, 0.17535551181674325, 0.18592666976185845, 0.1790538453936158, 0.17868589771631194, 0.1257886365419204, 0.19956281269985843, 0.14831024158116812, 0.17086549492404335, 0.19800753661213488, 0.18917175288554577, 0.18877310604793063, 0.20169573258672746, 0.1875717201925694, 0.18932182574664824, 0.22651084852166836, 0.20367508542853763, 0.18033389607636363, 0.18384696334492068, 0.1869006722567058, 0.16671022836430838, 0.17930664804083885, 0.19444990941726303, 0.17690968518194128, 0.19875324794623916, 0.19025946274973204, 0.3868770465034229, 0.6396154249645516, 0.5710831100415064, 0.15646035974701067, 0.41541807300520117, 0.1556997887406596, 0.3535846548541386, 0.47181671184795826, 0.16453131733393256, 0.22468389201243866, 0.3720105730854888, 0.3127298667141384, 0.1607012875780185, 0.22920302788661973, 0.16484354074419294, 0.2748269785298859, 0.408138767102725, 0.28263061004601353, 0.1753465895043408, 0.17837283280708705, 0.16971373516056631, 0.19535697595826196, 0.20867631980800838, 0.18807673112600898, 0.17161074433837797, 0.17811322882999103, 0.17379439613296543, 0.07369065460096758, 0.07338966923976531, 0.07929620996450326, 0.06957555255585235, 0.08271985536781046, 0.07629139795496176, 0.0774049430421585, 0.07080300433003972, 0.07478900566953983]}, "mutation_prompt": null}
{"id": "6f40661a-1a77-45f6-8348-fcbe087eb34f", "solution": "import numpy as np\n\nclass BalancedSynergisticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 14)  # Adjusted population size\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3  # Adaptive inertia weight\n        self.cognitive_coeff = 1.3 + np.random.rand() * 0.5  # Adjusted cognitive coefficient\n        self.social_coeff = 1.3 + np.random.rand() * 0.5  # Adjusted social coefficient\n        self.F = 0.6  # Adjusted scaling factor for better exploration\n        self.CR = 0.85  # Adjusted crossover probability for diverse trials\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with dynamic boundary handling\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Dynamic boundary handling\n                positions[i] = np.where(positions[i] < self.lower_bound, np.random.uniform(self.lower_bound, self.upper_bound), positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, np.random.uniform(self.lower_bound, self.upper_bound), positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "BalancedSynergisticOptimizer", "description": "A balanced synergistic optimizer harmonizing PSO and DE with adaptive parameters and dynamic boundary handling to enhance convergence and robustness.", "configspace": "", "generation": 12, "fitness": 0.18541788205754664, "feedback": "The algorithm BalancedSynergisticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.17.", "error": "", "parent_id": "30832ae9-4789-4abd-97f8-918444c7cfa6", "metadata": {"aucs": [0.36814354963619356, 0.4789212527171852, 0.4507964379818792, 0.30471517810001847, 0.3070479225414652, 0.2760076941717793, 0.31666848812518433, 0.2595217581280995, 0.31752959004513226, 0.016624863702397685, 0.05802073734724911, 0.07739244625211938, 0.02037875164798153, 0.07556875929757534, 0.08754466115394666, 0.03226897322873379, 0.0955899094060495, 0.09597510493144179, 0.09573777214217061, 0.10160705185652297, 0.1355669987418956, 0.06623990209557029, 0.11366321984638283, 0.0817750498498403, 0.08513892356898012, 0.1057202880601753, 0.08912925604184241, 0.07526150833729339, 0.07511240003487396, 0.0903750208311016, 0.060435896101203035, 0.09482467465991906, 0.09413323457118772, 0.0659109114950337, 0.06773302186142449, 0.07029681794170572, 0.8259511628368759, 0.8296240907316533, 0.7456944791713727, 0.7557930470181982, 0.7531689143861727, 0.7575069411012755, 0.7533437104699644, 0.9573599129389666, 0.7424656611154576, 0.14113058552188817, 0.19936833670232534, 0.20387919718013914, 0.13296437865277222, 0.19492896737994203, 0.1904972381165111, 0.1823420626611436, 0.19991105878863424, 0.20358051297867996, 0.1733287009329002, 0.20601433811218817, 0.2505695209606291, 0.17313747329867035, 0.1923384308134808, 0.19167354900331857, 0.15173903028114988, 0.20844013313968268, 0.1382041713826404, 0.0801238562874349, 0.12631442766624623, 0.12321110764440912, 0.1132054808914601, 0.12898653199399412, 0.1309606642579545, 0.08969104654427063, 0.1634851007814192, 0.12622666437479124, 0.10735474477036333, 0.1378061653644439, 0.12120682970791874, 0.10427412415553405, 0.14434892395992394, 0.1074975644853352, 0.048353005909220204, 0.07390678302477094, 0.12936182501487004, 9.999999999998899e-05, 9.999999999998899e-05, 0.001149669666568709, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03460042026758148, 0.037670699374378946, 0.006573573323392701, 0.07952280453537064, 0.06976755576874616, 0.10141250464763285, 0.054543706284959304, 0.03386196573246947, 0.05460518334230169, 0.04347128474727491, 0.09800819355464918, 0.06186298228075626, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003101299279677505, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07686279302666121, 0.12440654485997349, 0.044751399574766926, 0.0402126848405121, 0.06242424087900378, 0.037701280207917964, 0.008422886057727341, 0.07493398913881233, 0.05067877707009505, 0.369400158029051, 0.35787764682136225, 0.3451907454484505, 0.25671049783632016, 0.36291653398869916, 0.2885377282046838, 0.2826384214204346, 0.38842882201114204, 0.36659389197772363, 0.08537897701012154, 0.0951171109222676, 0.06513966783004821, 0.06840282875307135, 0.08573050279646233, 0.07178204041490366, 0.07221689814268939, 0.0701727615107206, 0.09222897844299371, 0.1409889778334913, 0.14707728203515547, 0.12809754619080105, 0.1324985087853855, 0.17206844090765894, 0.1370560290196543, 0.16073455106831203, 0.1429430984101806, 0.14017186652595537, 0.20265242069043077, 0.22673177276922107, 0.24462934286988003, 0.21929663830063773, 0.31662840976092876, 0.2933343423632163, 0.2367553739254471, 0.24252130009461836, 0.21191885054723547, 0.16087351130637706, 0.17543016712729154, 0.16009953485715944, 0.16855579981026625, 0.19380616743814016, 0.19940962149034713, 0.13025039266908767, 0.1622468824689005, 0.1510133027622158, 0.18028764500534067, 0.1778907538028981, 0.18453944828645485, 0.19127712336886693, 0.20507022539403297, 0.21664489674279053, 0.19667510334550686, 0.19244511321448465, 0.18915448792992162, 0.1779257136282153, 0.18627394068594205, 0.1871921599410784, 0.1740731156331502, 0.1798632362735203, 0.21586040688844788, 0.17723590558821545, 0.17890582600152116, 0.18090448289634864, 0.3816078354792055, 0.6594915630804461, 0.5309846665482729, 0.352678148162872, 0.5626157142135377, 0.5615764682970572, 0.39515572119687137, 0.2852720396828651, 0.37318726146554904, 0.22261780396094122, 0.34696952808369164, 0.4370646906154789, 0.1930762518479897, 0.40907685333840227, 0.19835440997157705, 0.16242848723527625, 0.32549905786654587, 0.14966641348156773, 0.18491249275293908, 0.1741790760981965, 0.1842191322218376, 0.2009159998665465, 0.1740641504490904, 0.18762921194133897, 0.19328624388354299, 0.1860300424856709, 0.18007178125522205, 0.09009574690679478, 0.08195817633248048, 0.076371838297009, 0.08497278469443681, 0.11831029859885855, 0.08757177420563422, 0.08026531110922819, 0.09233905655773378, 0.09077764660571097]}, "mutation_prompt": null}
{"id": "4d9adee1-280f-463c-87f8-001f5d11fbac", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 12)  # Adjusted population size\n        self.inertia_weight = 0.3 + np.random.rand() * 0.5  # Enhanced adaptive inertia weight\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.8  # Enhanced cognitive coefficient\n        self.social_coeff = 1.0 + np.random.rand() * 0.8  # Enhanced social coefficient\n        self.F = 0.6  # Adjusted scaling factor for better exploration\n        self.CR = 0.85  # Reduced crossover probability for diverse candidates\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with boundary adaptation\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundaries\n                positions[i] = np.where(positions[i] < self.lower_bound, np.clip(positions[i], self.lower_bound, self.upper_bound), positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, np.clip(positions[i], self.lower_bound, self.upper_bound), positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "AdaptiveHybridOptimizer", "description": "A hybrid optimizer using adaptive PSO and DE with stochastic acceleration and boundary adaptation to enhance convergence.", "configspace": "", "generation": 13, "fitness": 0.26172437994761316, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "30832ae9-4789-4abd-97f8-918444c7cfa6", "metadata": {"aucs": [0.4721108196915903, 0.6998397219028798, 0.5397664276745666, 0.5621188165441364, 0.7018991916998947, 0.6075571459976987, 0.4589978519502297, 0.6876618705400619, 0.6538667895618899, 0.1160562938163856, 0.3882002396440908, 0.27202084318175357, 0.1546740494741814, 0.3604946091449408, 0.2260281038215921, 0.15446470394080025, 0.36690238646838846, 0.25724692897800694, 0.11713434084645835, 0.156301170982877, 0.23722616094743632, 0.11908901819646911, 0.13016937716797206, 0.14987721801789045, 0.10352633768950092, 0.13982668708592594, 0.1343865873576282, 0.11803445264303136, 0.10679648841785716, 0.10184600327150217, 0.10290684100552139, 0.12112684936841722, 0.13533246888980344, 0.10746673545244978, 0.1126253283952574, 0.11102888884270556, 0.9716450546319172, 0.9710094662548984, 0.971273587391698, 0.9715117482859755, 0.9678597882135431, 0.9729072330035802, 0.9693969478684573, 0.9664738771374828, 0.9692181609245802, 0.2770329163897163, 0.46140113143140293, 0.44552814181510225, 0.22734441511981662, 0.383278106337371, 0.423093712066123, 0.32777906233414356, 0.39376213240012736, 0.3868593923847464, 0.3114787990765506, 0.6108431428983887, 0.5875472742210344, 0.2504912431109648, 0.15918848612485126, 0.15873179734107634, 0.22369510116699354, 0.6031285855099939, 0.17752729658259359, 0.13423240939353998, 0.18290027561802158, 0.2504902308664516, 0.1189588136357761, 0.12153614149866754, 0.11767085269618471, 0.15145876955601978, 0.196679059293576, 0.1841861644830266, 0.15489335108752111, 0.15919204956129507, 0.16957108682696853, 0.1305151788381148, 0.18912330980475855, 0.21326858708573238, 0.10238710749125624, 0.18568255169091985, 0.20264850615842922, 0.0017618707889359708, 0.03616148964680255, 0.027082230784244876, 9.999999999998899e-05, 9.999999999998899e-05, 0.031667994308924974, 0.050177642795428246, 0.04066280167516667, 0.07923097212413632, 0.08651957488880602, 0.10658996785420716, 0.05930316651271439, 0.09265121284146793, 0.053891690649997326, 0.13119551027484866, 0.04614706420424464, 0.11626474591726055, 0.05357851885228282, 0.01414033330063813, 0.04758983308473275, 0.03492922807157006, 0.019487648644623934, 0.08891312283263175, 0.12807167666997155, 0.04390164367063676, 0.06363208775882379, 0.05983838320401502, 0.10629129416820582, 0.06293695401129695, 0.0979488091110714, 0.06406479889227634, 0.10128609190485782, 0.033722273979655215, 0.046824745061173734, 0.07208006554738622, 0.05046858529098086, 0.40343816090290197, 0.5346113239560563, 0.4515708717557516, 0.42470986956667367, 0.4651596149731103, 0.49772947029914516, 0.40635634350085803, 0.5216709442242793, 0.5098601355047501, 0.14499131827777623, 0.12137082905556995, 0.12650756293397192, 0.12132423774089163, 0.11825061067603271, 0.09205241954888876, 0.09269325099127201, 0.11123666856330783, 0.09149189824907644, 0.1728849056196835, 0.2597705865649035, 0.3196247285722187, 0.17250863434198505, 0.19729378963139566, 0.2048818981059991, 0.15731063305018744, 0.19194009851647298, 0.19655255268554717, 0.2669191868088271, 0.40293846897176466, 0.3166654565066106, 0.27673451238301905, 0.3877441804865436, 0.3464541691015035, 0.29038770349758547, 0.40373025418682373, 0.3930744580476748, 0.15464750843431252, 0.2119476626463842, 0.23904605370403575, 0.20321257524167335, 0.26782046362517553, 0.2812903450865156, 0.22268310222949317, 0.19150313813864295, 0.12815672343107365, 0.19272045384534375, 0.21007512196892653, 0.2346319758498263, 0.24468190238076937, 0.22724216067688907, 0.21263667441202128, 0.18317432945807366, 0.22328126218776267, 0.21357746536620248, 0.21443184735283616, 0.22698866557645248, 0.1938061068431972, 0.1802242303495235, 0.22508864866660427, 0.32013145462510173, 0.19515024234341716, 0.32232902180544465, 0.19488863675320545, 0.7614776170684041, 0.8267032455571778, 0.814994547744287, 0.594799943493677, 0.7641551614706787, 0.7757701208056165, 0.15212219865455134, 0.14423740471870028, 0.15514635037629632, 0.44919446323546985, 0.5498174538321219, 0.5089472262121499, 0.19964192341430076, 0.20664089947253084, 0.2029425306969609, 0.15218374606704033, 0.16488755643634834, 0.16441861634352373, 0.19053647700389298, 0.19415992311521368, 0.1946484643747498, 0.18424877595405464, 0.19258978128980542, 0.19409416210931485, 0.19183499040874863, 0.17728274641956432, 0.2034936868902708, 0.08269527400813603, 0.08517200212776388, 0.0973320284566711, 0.10034077620667325, 0.11214901473196204, 0.12115389273814359, 0.07299040519000788, 0.10328041940995225, 0.0993498983065152]}, "mutation_prompt": null}
{"id": "b6e02986-09bb-4be6-95e6-8de1dd95000a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)  # Slightly increased population size\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Balanced adaptive inertia weight\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.6  # Refined cognitive coefficient\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Refined social coefficient\n        self.F = 0.5  # Optimized scaling factor for exploration-exploitation balance\n        self.CR = 0.9  # Increased crossover probability for better convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == np.random.randint(0, self.dim):\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with boundary adaptation\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Enhanced adaptive boundaries\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedAdaptiveHybridOptimizer", "description": "A hybrid optimizer using adaptive PSO and DE with enhanced local search exploitation and adaptive boundary conditions to improve convergence.", "configspace": "", "generation": 14, "fitness": 0.231061885273822, "feedback": "The algorithm EnhancedAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.21.", "error": "", "parent_id": "4d9adee1-280f-463c-87f8-001f5d11fbac", "metadata": {"aucs": [0.36604911937201756, 0.49223578414269253, 0.4577998657854915, 0.4090154284951686, 0.5037485309287569, 0.4478610796311947, 0.36937783330405694, 0.5483568932789722, 0.46192925834082676, 0.06516081936653295, 0.02824098561333832, 0.1270274144022987, 0.031364055548432246, 0.11816697951803212, 0.027550151553966118, 0.03362254128857023, 0.15594245323707034, 0.10543894743510462, 0.10202737421703256, 0.11652446276581052, 0.10063343268414915, 0.11004336612252807, 0.14153356708522824, 0.14320414719816454, 0.08516772094229053, 0.12053930293043635, 0.0987938478934901, 0.07089237071873844, 0.0912533480405886, 0.09493710748892359, 0.07828227345506078, 0.0958163141453906, 0.0939063328319456, 0.0839705977697387, 0.10299022691269677, 0.11923579147622354, 0.9634012354924597, 0.9602867900361303, 0.9622450709756573, 0.9640655533739972, 0.9615874248820948, 0.9636018537864289, 0.9632515128099115, 0.9583863484402533, 0.9621367613614163, 0.2177525250017629, 0.27908935685206804, 0.24491342539891847, 0.25847955588752025, 0.29534299358612204, 0.2609946217181248, 0.20193634085891277, 0.27241954021783865, 0.27411607332104293, 0.24841907866845891, 0.6015419046072572, 0.44407056786327803, 0.22296857610286347, 0.36976866631838334, 0.2195075303735451, 0.2368043453538834, 0.4448226921504381, 0.2770558131024058, 0.12095066777673924, 0.1274526670275551, 0.11757687293734342, 0.0888815352213389, 0.11424145121854667, 0.0868851322388593, 0.08695365990683857, 0.16720550421234426, 0.09501678746572728, 0.08960271237636519, 0.1452273143432854, 0.10538424116291767, 0.12392740700100635, 0.1360100763020038, 0.14291144399897326, 0.14727238493172845, 0.17018347711475001, 0.17151427799372, 9.999999999998899e-05, 9.999999999998899e-05, 0.03452278401598485, 9.999999999998899e-05, 0.026859341519421487, 0.02269274546812816, 0.025409324743573936, 0.018793327322913722, 0.051066799962507514, 0.05824841227945399, 0.13239736931551782, 0.12929823388043693, 0.09064473143608942, 0.084829845449924, 0.0649246183982386, 0.08120796451119783, 0.08785728531917936, 0.09070521421032951, 0.002842378524282152, 0.016439027692710995, 0.026327690499897805, 0.005574552219127726, 0.024817585740308234, 0.023847402776983606, 9.999999999998899e-05, 0.009021089813485372, 0.017386908125029188, 0.06880627186250732, 0.09194141120960864, 0.08964641610438795, 0.07076522068110969, 0.11633449281481412, 0.09647728322985583, 0.04468377045253369, 0.11795633387682969, 0.12216016081768577, 0.31796906982839035, 0.4286694915023187, 0.4252996543386497, 0.367023888501114, 0.4153874168728472, 0.4091446642470826, 0.31023041884099634, 0.43842484313172814, 0.38105794969357853, 0.08308088537016978, 0.09444817560999075, 0.10239699539115721, 0.0837856710209568, 0.11939259015431036, 0.12231242603459214, 0.09731083669076979, 0.08735425204079561, 0.10934605083508409, 0.16542113098662325, 0.17955786321260492, 0.23703289788687265, 0.18505554716467532, 0.19528522922909208, 0.16521438468511385, 0.1794960921224511, 0.17926556753705225, 0.2743178722296089, 0.26808626807558944, 0.3125142580367748, 0.2818241946677221, 0.23079116576967085, 0.2820012749424753, 0.28776524483101296, 0.26196799193635656, 0.3117371509553504, 0.28935111993730056, 0.13626055827719208, 0.20102213889253084, 0.21116453862312212, 0.16454562929017102, 0.20419082417108947, 0.23934208836580684, 0.19602249147862827, 0.18814391528268581, 0.22304662916764306, 0.19692430323786525, 0.20241242810474824, 0.22241218517998207, 0.1992171285411486, 0.20798214272704874, 0.21406289178061866, 0.18033331625730875, 0.20298371563313078, 0.18513250340450638, 0.17310492611845696, 0.24730612477930813, 0.21419648633114552, 0.180273453040648, 0.22080877784040087, 0.20136929890696043, 0.19020201074371013, 0.3499384691319085, 0.17991922011707517, 0.5542644047815543, 0.7052990206276694, 0.7433560000080722, 0.48294348181318114, 0.671551202436831, 0.5329771562121919, 0.4120774663997415, 0.5951014486351289, 0.6062988417959951, 0.31043481673383533, 0.45636409364181363, 0.5154829161623918, 0.2685421047957166, 0.16760066714215716, 0.34945079276193536, 0.39066384356639616, 0.12716328290589296, 0.5135461068545322, 0.20722012190816919, 0.17613280357766703, 0.19530920008932828, 0.17951943269650217, 0.18939114845571114, 0.19556230144395415, 0.17434192281900973, 0.1788126269465784, 0.20312743671508182, 0.07418655052884571, 0.08879137365100376, 0.08473329477227776, 0.07839710017059265, 0.07356851694217914, 0.08397786602688662, 0.09053356569780913, 0.11095393985881585, 0.10036214786815179]}, "mutation_prompt": null}
{"id": "2d5cd303-f3a9-4680-a9cb-aa7eb2d56014", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 10)  # Increased population size for diversity\n        self.inertia_weight = 0.5 + np.random.rand() * 0.4  # Narrower adaptive inertia weight\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.6  # Enhanced cognitive coefficient\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Enhanced social coefficient\n        self.F = 0.7  # Adjusted scaling factor for better exploitation\n        self.CR = 0.9  # Increased crossover probability for better convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n        self.restart_threshold = budget // 5  # Dynamic restarting mechanism\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        last_improvement = 0\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n                        last_improvement = evaluations\n            \n            # Particle Swarm Optimization update with boundary adaptation\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n                        last_improvement = evaluations\n            \n            # Dynamic restarting mechanism\n            if evaluations - last_improvement > self.restart_threshold:\n                positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n                velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n                last_improvement = evaluations\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer using adaptive PSO and DE with improved parameter tuning and a dynamic restarting mechanism for enhanced exploration and exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.18962851213002452, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "4d9adee1-280f-463c-87f8-001f5d11fbac", "metadata": {"aucs": [0.2711459184815389, 0.3188749422969027, 0.36755979129013494, 0.35086503998799856, 0.4741607063947534, 0.398660966852577, 0.36577209063385185, 0.47145024243499034, 0.4328439967521648, 0.005289668487863275, 0.007314936774788894, 0.0455330987239968, 0.02764123887314418, 0.022159456544784684, 9.999999999998899e-05, 9.999999999998899e-05, 0.00039268114550650157, 0.03701403900767131, 0.09043101600450376, 0.09644650615790584, 0.09630524564283005, 0.07163124365574436, 0.08419421309618791, 0.08966671934736481, 0.08103552184843499, 0.08870886456417826, 0.08311552114529064, 0.07522810805990643, 0.08442930726274278, 0.07253048239924753, 0.05877881778440841, 0.07222808854209162, 0.09480595262899494, 0.07689255664820338, 0.07291756582054454, 0.09330453669963157, 0.9718607572472657, 0.9713644400297899, 0.9714899663642904, 0.9711341368667092, 0.9696263244503007, 0.983773854414035, 0.9701006405096516, 0.9693317162142088, 0.9697196891027935, 0.1673798249855607, 0.21560968148578308, 0.19121192194657644, 0.13037011282983224, 0.26602965334233764, 0.17042362605545625, 0.14780692603856294, 0.2086078518107215, 0.08655704744567883, 0.15525283731818895, 0.1852682523630298, 0.19424598381309088, 0.22259464114711158, 0.19213198171291224, 0.2380551044034157, 0.2015248144701135, 0.21420853546026264, 0.2166380962665232, 0.12197167836634892, 0.13251611889078052, 0.09249202858277117, 0.06269196865764826, 0.13025862790305764, 0.12989151968935853, 0.0781546969251734, 0.12169130814084494, 0.11725827849648596, 0.11047153581916225, 0.13365530437201012, 0.10581826243907166, 0.0653212190966237, 0.14428594671368322, 0.07506454570152432, 0.028245536330336996, 0.14644209864487168, 0.07043649005704178, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012750121732917452, 0.021592520790034375, 0.02844165036728885, 0.09048890059562165, 0.05938440570081294, 0.07878937918750184, 0.030835332783546776, 0.056510056414569965, 0.021268711289693765, 0.12029035641170682, 0.05107710319497105, 0.0224989870644835, 9.999999999998899e-05, 0.008787302923534246, 9.999999999998899e-05, 9.999999999998899e-05, 0.002573141568378068, 0.008583053392793749, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04244664568370915, 0.08013079606034212, 0.06370558336607735, 0.06167465695554275, 0.08972558968259525, 0.026224276573804328, 0.049092920395528705, 0.050278212062911165, 0.04948003984715488, 0.36190597306200023, 0.3867387388029405, 0.3686684421365326, 0.2642137867707526, 0.36931878212890557, 0.35383643346686466, 0.24836187413761757, 0.37640181454666866, 0.3292932825825461, 0.07146940567512117, 0.0961940652399067, 0.09810213926119671, 0.06286612196987007, 0.09459771844226728, 0.08132927556375269, 0.07206410478514313, 0.08377383911120373, 0.09081634599560762, 0.1468407672626958, 0.16954573997165967, 0.1921269662126518, 0.14200867637820525, 0.14273646241347993, 0.14344464331043305, 0.14801569263645176, 0.13535086728842038, 0.13347203262504448, 0.20252320828965553, 0.25016152178009443, 0.2546350016810641, 0.21001057843355175, 0.2380966152513223, 0.2564071254240504, 0.2399417524442351, 0.3250062124291839, 0.2591246522119265, 0.15092347426275332, 0.19682226526116797, 0.14452624863385843, 0.15315604424864337, 0.1721472563863352, 0.17689479571104838, 0.1344901253400591, 0.15199661392752695, 0.13765524743189195, 0.1613624279177418, 0.17731672769425355, 0.18626961545757925, 0.1807988643970222, 0.1681809494057961, 0.193595468434676, 0.17801791881152462, 0.17702628045808866, 0.19275785019872915, 0.17428930439423496, 0.2046047018983922, 0.18555669816734321, 0.18241844738163326, 0.19732190749744838, 0.2632053992574902, 0.17001587245446592, 0.1821751495690913, 0.21124826825375054, 0.518415673640592, 0.6318335346814082, 0.6090121854814912, 0.3543360298342837, 0.5801698834621734, 0.49994597702158783, 0.19510958048672544, 0.5038909209745936, 0.1522405539525744, 0.24352230837903788, 0.3493058513674058, 0.3061027631260895, 0.25568832581728806, 0.2037981953905832, 0.20356236235598513, 0.14267955523256182, 0.2609761016855995, 0.15168483131465804, 0.1880196977279215, 0.17865891189039773, 0.1968976570976908, 0.19654924551269093, 0.17936829713778246, 0.1890637830020686, 0.20724105793662884, 0.1828279219607466, 0.17238319447180817, 0.07285837009389196, 0.07109120437182248, 0.07365933037037609, 0.05684000483030249, 0.06695147854059891, 0.07484545590573577, 0.06806489469762733, 0.07984154506282304, 0.11180294373677757]}, "mutation_prompt": null}
{"id": "75443003-eb86-4042-a669-1d8df894674e", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 12)\n        self.inertia_weight = 0.5 + np.random.rand() * 0.4  # More balanced inertia weight\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.6  # Streamlined cognitive coefficient\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Streamlined social coefficient\n        self.F1 = 0.6  # Scaling factor for DE mutation\n        self.F2 = 0.8  # Second scaling factor for dynamic mutation strategy\n        self.CR = 0.9  # Slightly higher crossover probability for enhanced exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Dynamic Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c, d, e = np.random.choice(indices, 5, replace=False)\n                if np.random.rand() < 0.5:\n                    mutant_vector = positions[a] + self.F1 * (positions[b] - positions[c])\n                else:\n                    mutant_vector = positions[d] + self.F2 * (positions[e] - positions[a])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with adaptive inertia and boundary handling\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundaries\n                positions[i] = np.where(positions[i] < self.lower_bound, self.lower_bound + np.abs(positions[i] % (self.upper_bound - self.lower_bound)), positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, self.upper_bound - np.abs(positions[i] % (self.upper_bound - self.lower_bound)), positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridOptimizer", "description": "An enhanced adaptive PSO-DE hybrid optimizer with diversified mutation schemes and adaptive parameter tuning.", "configspace": "", "generation": 16, "fitness": 0.14479825590199, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.14 with standard deviation 0.10.", "error": "", "parent_id": "4d9adee1-280f-463c-87f8-001f5d11fbac", "metadata": {"aucs": [0.28333063251687485, 0.407127303375975, 0.33704319368279123, 0.2731434540373896, 0.25515556671454953, 0.25620141579108535, 0.2766510513033018, 0.32922874049147133, 0.24820598177760367, 9.999999999998899e-05, 0.040165611694278236, 0.00944357870803103, 0.0008127270585555069, 0.06775980262932679, 0.06910453306250841, 9.999999999998899e-05, 0.05929024467047783, 0.022171974501781766, 0.09912358374408192, 0.08896757015181789, 0.0784959195550975, 0.06760591958781825, 0.10648900499374958, 0.06998100345770963, 0.06265729695828026, 0.10250030086539552, 0.09419451164433845, 0.07715820360367054, 0.0671333712798502, 0.06697345977208313, 0.06653362767294879, 0.07483101290679284, 0.07889235305694964, 0.06927190698793462, 0.0753109953558374, 0.06232913564228415, 0.241166028204308, 0.1267359631912094, 0.11925395026663266, 0.1407201427072141, 0.11913143502237511, 0.1526651446539663, 0.1967432997527453, 0.48175734952320726, 0.15017904028930484, 0.1305193642082988, 0.17673771176416397, 0.16822153009482843, 0.16363839365779786, 0.17163138429200753, 0.1670918477569996, 0.1516089483499603, 0.16903250842035888, 0.142084604422403, 0.17384605355282579, 0.32425652373622493, 0.2722629663185787, 0.16892216621836265, 0.20813416107986793, 0.20203052016651846, 0.14674675625125622, 0.16111309708125898, 0.19768740051889133, 0.0903596247365922, 0.12502607996798687, 0.12505371130147924, 0.07389628468023601, 0.11368841636612448, 0.09417863537151583, 0.08217733898450608, 0.13269405693382819, 0.12182990197716659, 0.0806935611801135, 0.1317756636069023, 0.09672123402759447, 0.08390953036144944, 0.12958670419807072, 0.09764431638835436, 0.08179768500906026, 0.134871965862714, 0.08316144487302646, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.002345077511557103, 0.07373118109167043, 0.005635866889232455, 0.09113006785282851, 0.10314259417630456, 0.12974837305245224, 0.04835406607336501, 0.08237376663514984, 0.051412790689140286, 0.08542759874425232, 0.07230871275114825, 0.06656184929484121, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00516387156852649, 0.07468952954763408, 0.047136419332203694, 0.0003122712124280502, 0.05322436097582961, 0.01953159193710219, 0.012001554903923406, 0.027001992257259966, 0.014412133301979546, 0.3275706114208521, 0.35553084507072286, 0.3732348245688738, 0.3220281696355082, 0.2688205540384694, 0.26927479331148385, 0.2819723943445509, 0.37280256598791717, 0.3776511074299699, 0.0467393790174192, 0.06737218050686011, 0.05252771637441933, 0.07107297567031168, 0.08829819053382326, 0.08037957287817876, 0.060349878884387365, 0.09941922294014316, 0.09315899794024918, 0.1562595341341364, 0.1719728736591447, 0.16834563515394163, 0.18154666197344227, 0.13787678555496385, 0.13627558636331505, 0.14025585294764675, 0.16186316282353796, 0.13387884283708595, 0.17590234472736155, 0.20963116485568423, 0.21910183783864523, 0.19603577802808358, 0.25984171459467176, 0.2374860393298952, 0.20823842140676674, 0.22804574947878242, 0.2091458781313742, 0.14184091932847753, 0.13489537828024245, 0.1525222941507416, 0.1611726833762268, 0.19942307397524606, 0.16430939572803727, 0.12000223653758113, 0.1600796526912316, 0.15944547749953708, 0.16223893095104125, 0.2049394128536105, 0.2281838590906592, 0.19381431717659414, 0.19093984296680167, 0.19955054508657188, 0.19317411078457858, 0.19150571313065845, 0.2125775513568947, 0.17510870313309557, 0.17997265172339538, 0.19238454128286353, 0.18453963485585367, 0.1853347623799807, 0.2144646046664146, 0.1733510878854846, 0.1824800085711844, 0.19300064308177522, 0.3462380056795462, 0.584853893704872, 0.45555590720334915, 0.21669305932353888, 0.16734673657385446, 0.2853956001709791, 0.15664794566825424, 0.2724239983092601, 0.30186205045449566, 0.21221069068796472, 0.17635172272488364, 0.1920235953460835, 0.37336312706313135, 0.226521520076848, 0.2947234674337592, 0.13254544317429373, 0.1859000585995808, 0.22541953141428772, 0.18097670221874151, 0.18012009293061293, 0.18666762807738302, 0.19439183735462107, 0.19180577393972564, 0.1741345535002301, 0.17516533248506916, 0.18684924291815275, 0.17734029882797386, 0.06760360653242603, 0.07987765375346312, 0.06924359642973321, 0.07697538015451277, 0.07085754431492697, 0.0813911535031111, 0.07578601789052208, 0.09214568867663042, 0.10423983439587015]}, "mutation_prompt": null}
{"id": "8ea9fd69-ac5e-444d-8515-e14ed2cdce25", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Fine-tuned population size\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Dynamic adaptive inertia weight\n        self.cognitive_coeff = 0.5 + np.random.rand() * 1.0  # More balanced cognitive coefficient\n        self.social_coeff = 1.5 + np.random.rand() * 0.5  # More focused social coefficient\n        self.F = 0.5  # Slightly reduced scaling factor for improved exploration\n        self.CR = 0.9  # Higher crossover probability for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = self.chaotic_initialization(self.population_size, self.dim)\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with adaptive parameters\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Dynamic boundary adaptation\n                positions[i] = np.where(positions[i] < self.lower_bound, self.lower_bound, positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, self.upper_bound, positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value\n\n    def chaotic_initialization(self, population_size, dim):\n        # Logistic map for chaotic initialization\n        x0 = 0.7\n        chaos = np.empty((population_size, dim))\n        for i in range(population_size):\n            for j in range(dim):\n                x0 = 4 * x0 * (1 - x0)\n                chaos[i, j] = self.lower_bound + (self.upper_bound - self.lower_bound) * x0\n        return chaos", "name": "EnhancedAdaptiveHybridOptimizer", "description": "An enhanced hybrid optimizer using chaotic initialization, adaptive PSO and DE with dynamic parameters for robust convergence.", "configspace": "", "generation": 17, "fitness": 0.2508590145965893, "feedback": "The algorithm EnhancedAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "4d9adee1-280f-463c-87f8-001f5d11fbac", "metadata": {"aucs": [0.4987926764135102, 0.6527917350954195, 0.6300000094463781, 0.4696920578852032, 0.6512039151966051, 0.6396588645969645, 0.1748075276878882, 0.658351200964826, 0.6087286004217879, 0.10161848362564285, 0.4077077447882407, 0.17631888047957112, 0.163506055139646, 9.999999999998899e-05, 0.15558583528992365, 0.19495148324969658, 0.415489363279432, 0.03996429096912302, 0.1492277193036634, 0.13890682755120065, 0.1095298870498882, 0.08992843870318501, 0.1039227629923496, 0.12028511742590375, 0.12023036819130828, 0.15228300490038604, 0.14152223702560407, 0.10945477210951271, 0.15094896527456825, 0.12789834424670732, 0.1024706776530454, 0.08200142329231652, 0.1258613186905574, 0.11812843073224011, 0.1367174642335216, 0.08635117624644595, 0.9869674458608622, 0.9869115789781341, 0.9868758334151349, 0.9878275236090995, 0.9831637484797991, 0.9831647767873896, 0.9807497905095087, 0.9805599224415564, 0.9802705432413692, 0.34147722973373196, 0.5174198062140869, 0.5027213971008737, 0.328445924371106, 0.45432168703309495, 0.3858530531427309, 0.35117832378767533, 0.43202828804363547, 0.42302888523817583, 0.35322513515612664, 0.6316896824461101, 0.1610820337286757, 0.15948983204843992, 0.25788060524350354, 0.26111014483861306, 0.49551466003776146, 0.23328656202800435, 0.7117821550196664, 0.10198253579733496, 0.20884619792029646, 0.24283739684233474, 0.09033736823673966, 0.09771115866810864, 0.11370755994460247, 0.14133187592239937, 0.19092986673918078, 0.15340286961853378, 0.16179677079383548, 0.021344509003170087, 0.11680641053530705, 0.1948697724196481, 0.18607237920769026, 0.1888781022067908, 0.1522413359860173, 0.2121500572804942, 0.14515267724037118, 0.00013722413275751855, 0.0103960281327109, 0.0001380419012071421, 0.020416262994048195, 0.020253094748865497, 0.02445612795512131, 9.999999999998899e-05, 0.025252861820152628, 0.031128628027593863, 0.03875941728083965, 0.07572800410973246, 0.03615122159688999, 0.08599830169126232, 0.05662781782837423, 0.053685541242454726, 0.006319243895708815, 0.04235228856227058, 0.035881088124786964, 0.024012032011427653, 0.05431754130849964, 0.06087951442189676, 0.0457174937824566, 0.0706569561114988, 0.06047710178124721, 0.07204127191146903, 0.07186743787764394, 0.14112728319269863, 0.08519833019219736, 0.146690156691901, 0.09382264252010375, 0.07134187946632153, 0.10839589338664701, 0.11437692006764888, 0.04419005901840989, 0.07422481196834874, 0.10109359864079093, 0.41342935315811513, 0.4741294799808444, 0.5161579969065637, 0.3965504837462702, 0.5139340198920546, 0.5031196207400037, 0.42089101583908073, 0.4583038828831606, 0.49212450023635446, 0.10519863745532643, 0.10605678974364541, 0.14149107751147838, 0.06686499829743575, 0.0975632345742049, 0.08760523199231174, 0.0858070611280396, 0.09137894921565526, 0.08192218291830544, 0.23945732623928306, 0.2068603528505446, 0.2889330259561538, 0.1919417612856471, 0.18686187828563794, 0.229549826012445, 0.1967595414394846, 0.19390854201579755, 0.2124303165953575, 0.22604191852791655, 0.24547126473623626, 0.23559330039772763, 0.27469372046123086, 0.3554840939473469, 0.37430945779855807, 0.3588191359563272, 0.3945141996114738, 0.3398478334893079, 0.23322071779790454, 0.17058680464179776, 0.1633851957127841, 0.1761463182839862, 0.19977153202093956, 0.2067605380560703, 0.21613751033705986, 0.18672675035170605, 0.25032224357766386, 0.2075674895092724, 0.24840867543564482, 0.1915956459300996, 0.20301908970748073, 0.19190221555818388, 0.20822679590837645, 0.20118285798275837, 0.18672786347920345, 0.23348202514182803, 0.2091895427948839, 0.19046428280935268, 0.2298211004207963, 0.1735854011946727, 0.4192527867945136, 0.2272046755824425, 0.21315427488787764, 0.2337329253700896, 0.20571572347600275, 0.16456921200865926, 0.16486105713333943, 0.16514313591459828, 0.7327068154937568, 0.16825931264034721, 0.1929914102100173, 0.7295648729372437, 0.7312680749673242, 0.13919757035309344, 0.5543630636115874, 0.6240160996312719, 0.5786113861771154, 0.16279835552206046, 0.43157323167966544, 0.6092340015361497, 0.1544762303854652, 0.15532989945170173, 0.15504023879308948, 0.20646005348971208, 0.1900946010035195, 0.19060183174774936, 0.19451578189944008, 0.20388136862318373, 0.21368618630213498, 0.189965767417966, 0.21369073783406622, 0.18730953346456714, 0.0905440772468693, 0.08028240115166185, 0.10199152063502648, 0.07760429712240235, 0.09862519807992942, 0.0991273067279177, 0.08782906740091434, 0.08007247194534228, 0.09638879628971486]}, "mutation_prompt": null}
{"id": "202050b5-6f01-45c2-acb5-f168d8b0ccc9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)  # Increased population size\n        self.inertia_weight = 0.2 + np.random.rand() * 0.6  # More adaptive inertia weight\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.6  # Adjusted cognitive coefficient\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Adjusted social coefficient\n        self.F = 0.5 + np.random.rand() * 0.2  # Stochastic scaling factor for controlled exploration\n        self.CR = 0.9  # Increased crossover probability for improved exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with improved boundary handling\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Enhanced adaptive boundaries\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedAdaptiveHybridOptimizer", "description": "An enhanced adaptive hybrid optimizer using improved diversification and convergence strategies with stochastic adjustments for better performance.", "configspace": "", "generation": 18, "fitness": 0.27642313269695284, "feedback": "The algorithm EnhancedAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "4d9adee1-280f-463c-87f8-001f5d11fbac", "metadata": {"aucs": [0.5852294117324612, 0.6979875755122553, 0.6953442499877388, 0.5608515908436158, 0.7069657920428565, 0.675915236904566, 0.5645977874538252, 0.6960157091583943, 0.6818305061681156, 0.1705804944966598, 0.3474249738747276, 0.2998337514977877, 0.1871026600839294, 0.3569307668362882, 0.30769124795655056, 0.19456263667245288, 0.3840178311838547, 0.33907576947739493, 0.1280092282207541, 0.12876705053248316, 0.13446753046367177, 0.09174748055663673, 0.11878909225315815, 0.1140222458789909, 0.11445527079095141, 0.11840810202647278, 0.3225094217115967, 0.1219429524425153, 0.10796389301112175, 0.1330159672142447, 0.10970408815320976, 0.11875014799272177, 0.1324509817673747, 0.09819712944979442, 0.11439350073470489, 0.14127221038518578, 0.963707381261811, 0.9421623007810382, 0.9626312194876516, 0.9636693414109827, 0.9604249667020412, 0.962915392815701, 0.9631004773681624, 0.9569180530633633, 0.9625063658444587, 0.2860736829238698, 0.3337161718948499, 0.4039631087074471, 0.32391643245602186, 0.43691087337752077, 0.3883299033996209, 0.3091571375544735, 0.38894098408677846, 0.3673158315298002, 0.21097509880595022, 0.28220953456698417, 0.6861095640680542, 0.25383487928091875, 0.611182621847971, 0.3020998574107846, 0.46621311013857825, 0.5656737441877652, 0.5681858819704655, 0.15624410456909077, 0.14281882633182363, 0.17403997418258677, 0.12616087136331522, 0.17814727915512196, 0.12022672386885747, 0.11269334973536893, 0.1767516901203915, 0.26564041171555397, 0.17138486623118898, 0.1177662643056907, 0.2236584017598372, 0.16634331994445273, 0.1872037685572956, 0.19236127872646147, 0.19044023667329713, 0.1915757014378736, 0.21399399827986854, 9.999999999998899e-05, 0.0029887665236717487, 9.999999999998899e-05, 0.030677007635199538, 9.999999999998899e-05, 0.016669217954921267, 0.07076674837493935, 0.055594508001541865, 0.10668406214572401, 0.05169130024936075, 0.07334881503263135, 0.027025180785791636, 0.009262053257207525, 0.040327665275200486, 0.03799360759393078, 0.062465441063213833, 0.06755337403937156, 0.10273294410369105, 0.028232106783028788, 0.10280104373041254, 0.035828070321737515, 0.08692137816321266, 0.07510271637585297, 0.15673301037220044, 0.10945167668643885, 0.09709547024145027, 0.19360555486331865, 0.04850809991645477, 0.05585419568147387, 0.06316383196759756, 0.14289929269049972, 0.14682137343397195, 0.07960551375113523, 0.050395098892449974, 0.07847514558948221, 0.05080960624310682, 0.43677489550674975, 0.47008341970784084, 0.46721219474624176, 0.48225050501622146, 0.5197920261766301, 0.48717308167160056, 0.44711911609225685, 0.526867544295534, 0.483243830509127, 0.10641123078025017, 0.10938308455592727, 0.11043073174920215, 0.10135479799648706, 0.10550598643133469, 0.12181149705965777, 0.10151954166487054, 0.12404701378801852, 0.09629520765832367, 0.17965876625095423, 0.2581699836748207, 0.22660960941226138, 0.18643183571029953, 0.19292786938445838, 0.15067430784464464, 0.1867124961133061, 0.24563166948905535, 0.25247386903570124, 0.2978716759643383, 0.38415648082071674, 0.3261168094250637, 0.30447094047831225, 0.28508136926270533, 0.38525311025498243, 0.3192864317625317, 0.3887201132969209, 0.3954299993851208, 0.2738056708566806, 0.1514047116888414, 0.17267010681769424, 0.1892805599917894, 0.3032363565838062, 0.33202381571779915, 0.1290579570583955, 0.24742120918205568, 0.13205181406226585, 0.18285230522271823, 0.22782151642342374, 0.19196194321705373, 0.19207497507442428, 0.20713407269046757, 0.21682109831282181, 0.23299115790345482, 0.2246289665476161, 0.21811290332179933, 0.20749139262135474, 0.20010802603438693, 0.19980291726531674, 0.21222833969671373, 0.21542311387561808, 0.19866889435358692, 0.194483483158838, 0.21605986702521263, 0.21099363933731896, 0.7403398770729364, 0.8071705181277389, 0.7973030182889959, 0.6840724160723382, 0.7212217000120645, 0.76689024578417, 0.17967956819825137, 0.7730576180911504, 0.17398121191088034, 0.4651373928318656, 0.4972648462205682, 0.6089170645541698, 0.2001287805187285, 0.2050501112987667, 0.20353636651733253, 0.4385211532155976, 0.5748352870044586, 0.3300839547791171, 0.17404007234466534, 0.19258141492985825, 0.17750578889741186, 0.1788585128464596, 0.18667431955390457, 0.18598640749389284, 0.18769667737534845, 0.18206153254043633, 0.1872726316139548, 0.077422710778842, 0.08545662560425737, 0.09093651856960283, 0.08130086420607385, 0.1076725095222626, 0.0836416792990945, 0.12120158979453644, 0.10204993283104535, 0.10477873971668195]}, "mutation_prompt": null}
{"id": "df251b09-6b61-4e11-a46f-6549b9ce2a3e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 15)  # Adjusted population size for efficiency\n        self.inertia_weight = 0.3 + np.random.rand() * 0.5  # Distinct inertia weight range\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.8  # More adaptable cognitive coefficient\n        self.social_coeff = 1.0 + np.random.rand() * 0.8  # More adaptable social coefficient\n        self.F = 0.6 + np.random.rand() * 0.3  # Enhanced stochastic scaling for exploration\n        self.CR = 0.85  # Balanced crossover probability for blending exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with improved boundary handling\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Enhanced adaptive boundaries\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedAdaptiveHybridOptimizer", "description": "A multi-phase adaptive optimizer combining differential evolution with guided local search for dynamic exploration and exploitation.", "configspace": "", "generation": 19, "fitness": 0.2571763358968441, "feedback": "The algorithm EnhancedAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "202050b5-6f01-45c2-acb5-f168d8b0ccc9", "metadata": {"aucs": [0.4856292353354724, 0.7064475731027957, 0.5645204531125007, 0.554873566300156, 0.6809504437465193, 0.6399357634949594, 0.559805878932869, 0.7128155768563345, 0.6142993220442525, 0.1661476363043779, 0.35177040319759223, 0.17966669623735543, 0.14313623717128698, 0.3261523183370265, 0.1714485977650504, 0.17351657672636178, 0.3318472262355081, 0.27696186493816755, 0.12501639540195497, 0.1326502670646147, 0.11017602360271539, 0.09110039398159875, 0.1580352730666431, 0.10672704445943693, 0.09761618429268348, 0.13161585881161775, 0.11811197493829328, 0.0747648050537073, 0.11562226346672799, 0.11449545037690023, 0.09798429835482325, 0.10464179331199575, 0.11734932763077155, 0.08775590413625245, 0.13228863767245658, 0.12514708270127628, 0.971794072932674, 0.9709498078097131, 0.9713331592446344, 0.9712349267108181, 0.9678668153654458, 0.972875536919092, 0.9694527865943107, 0.9665662728425859, 0.9693532965140672, 0.2667320822829893, 0.41716342884941837, 0.37085681894680356, 0.2148050110738816, 0.2957493854225607, 0.36362010102243447, 0.2512317919542908, 0.43374797486773564, 0.08673523070834943, 0.3902286560548156, 0.5200952606515886, 0.5602570259466848, 0.3794070170183782, 0.19578534529382796, 0.1580449702845026, 0.396260509796322, 0.22088606141112843, 0.22932866001624996, 0.1467415878507794, 0.17011153384254118, 0.16641447710174184, 0.10256804568777222, 0.17424970054741118, 0.1955089739530499, 0.14604021290993163, 0.1655138017132034, 0.19714983507283146, 0.13848793460019293, 0.1740513288605151, 0.17603723790792103, 0.16567912210680313, 0.12457905998353525, 0.20863221130257603, 0.10175004673720067, 0.15977227294066143, 0.23398057469795586, 0.0017062645452032843, 9.999999999998899e-05, 0.0018611554866765356, 9.999999999998899e-05, 9.999999999998899e-05, 0.12260360785874003, 0.0444889331787397, 0.03285348740856464, 0.07520606478217329, 0.04483563417020653, 0.14133100439977553, 0.08508805700925381, 0.044513949735771385, 0.03450978181553199, 0.11279788953485681, 0.025045732473899296, 0.07910278653629943, 0.03625200944522511, 0.05623887545919881, 0.03523939435976353, 0.0644418769900088, 0.05306496978942654, 0.0723274724944789, 0.045697397341739054, 0.010938190874596354, 0.052154500417310956, 0.09220437080513233, 0.09713372017765831, 0.12472243328076493, 0.14736857229895028, 0.032493488601827214, 0.1535746390786662, 0.03495838240821125, 0.06815512932761958, 0.12237812764020395, 0.07318358910323863, 0.4256052166045382, 0.4774769342244545, 0.4977551695053102, 0.3740517382225296, 0.5292634455530872, 0.43441320530495775, 0.4056542268404376, 0.4989800675856392, 0.48125607986789287, 0.10637284047400719, 0.10732857820064579, 0.10982433224730137, 0.10718148204239009, 0.12105990668926203, 0.11471371904831562, 0.14931476428068347, 0.12743108136221548, 0.13887718872772226, 0.21121438466506592, 0.1483759834288394, 0.1817864477376302, 0.14375374877207814, 0.18417597937070318, 0.21206841555177924, 0.16299040486775118, 0.14250416583679892, 0.33674703310131215, 0.27051960603503067, 0.3389381175174976, 0.23411266441347867, 0.2917574757449405, 0.31743572397390085, 0.21600010088287658, 0.3172175213052063, 0.38929129456999734, 0.3377409851359936, 0.1728750199436312, 0.2701908034839988, 0.16222493310968022, 0.21509095343567775, 0.2723889414357853, 0.2690653869390338, 0.1993985825022967, 0.18755606943547398, 0.20126166275390545, 0.1877754920366017, 0.18775252821388466, 0.22930423206344852, 0.19168236510307668, 0.20807517902703732, 0.1670653565247081, 0.20286518801055398, 0.19429104563009436, 0.22639428587978405, 0.2028650750794574, 0.19429345844017343, 0.34798366713724216, 0.19046202619552755, 0.3701043661167056, 0.2057426608018844, 0.1921484865414309, 0.19178813446785392, 0.2185932468845332, 0.6605580611043251, 0.834975269334336, 0.8181929403248733, 0.6542671728820999, 0.819949676463477, 0.7616855863549212, 0.5241671693540799, 0.16927273258304054, 0.19408673189811754, 0.2959324263167106, 0.6368585379767888, 0.6627244805489226, 0.2037548110489774, 0.20667802222434073, 0.20210343114156326, 0.15410900672648242, 0.20876047675777465, 0.15289196860578047, 0.1892118854576078, 0.18776238424996328, 0.18300359736445226, 0.20249751100367908, 0.19638398837680693, 0.19702774576377924, 0.18174506719860806, 0.19248933981739935, 0.19638675410614703, 0.07415468395238456, 0.08277259976791973, 0.08363719836340056, 0.07318633379163897, 0.09057125425405865, 0.08333070463104231, 0.08633273247318207, 0.11533706024359747, 0.141434233025598]}, "mutation_prompt": null}
{"id": "2eef2a7a-0feb-4f32-9fb3-a6895b0c4849", "solution": "import numpy as np\n\nclass StochasticBoundaryAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)\n        self.inertia_weight = 0.1 + np.random.rand() * 0.7  # More adaptive inertia weight\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.8  # Adjusted cognitive coefficient\n        self.social_coeff = 1.0 + np.random.rand() * 0.8  # Adjusted social coefficient\n        self.F = 0.4 + np.random.rand() * 0.3  # Stochastic scaling factor for controlled exploration\n        self.CR = 0.85  # Increased crossover probability for improved exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with improved boundary handling\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Enhanced adaptive boundary handling\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticBoundaryAdaptiveOptimizer", "description": "A novel stochastic-adjusted optimizer leveraging differential evolution and particle swarm dynamics with adaptive boundary control and mutation strategies.", "configspace": "", "generation": 20, "fitness": 0.274526211515812, "feedback": "The algorithm StochasticBoundaryAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "202050b5-6f01-45c2-acb5-f168d8b0ccc9", "metadata": {"aucs": [0.5421006495644987, 0.7435164361582726, 0.6760559714645074, 0.6051876842415782, 0.7357602586004005, 0.6683327245203738, 0.5438129974507342, 0.7199922996584425, 0.6739028666199122, 0.2336807433719258, 0.3205550616375884, 0.3126053725876561, 0.20191379778688323, 0.40043742787925507, 0.27477954321123466, 0.18247192228635567, 0.4477835067850915, 0.4039460109609023, 0.12170034660335372, 0.12590179143223978, 0.10500086339262582, 0.12510326655195536, 0.23451135224878572, 0.14729455056906104, 0.10210049833644042, 0.15585268132626062, 0.1266604546155924, 0.14989822582059698, 0.11730231023559134, 0.14296219953088152, 0.10430474699329517, 0.11477577855074361, 0.12087950056307906, 0.11022597807567358, 0.1295926557851379, 0.12563501622328355, 0.9627455487694437, 0.9368373207821808, 0.9573301830927795, 0.9639566439587658, 0.9611368385364957, 0.9629587241656765, 0.9630460786320305, 0.9439698782497997, 0.962604749317242, 0.3070330549474627, 0.46403243610531586, 0.4868717650891654, 0.277498421752019, 0.45287599951967794, 0.26582262747863383, 0.31328564943663484, 0.43722738524490423, 0.39840634492531457, 0.2946705991700632, 0.21735724664251532, 0.7235456149698634, 0.15961878517950412, 0.2642390261266966, 0.20530195886431002, 0.4874773806916848, 0.7391594874286029, 0.6802449804985676, 0.17980329075781087, 0.16417118034112355, 0.21123528607444209, 0.15520769635911458, 0.1717106429990345, 0.12136420497427702, 0.16653042702730236, 0.1144166188138721, 0.12110289791176132, 0.10022599972865409, 0.12174583357782542, 0.21069961561505157, 0.18031440057081438, 0.20356898988625027, 0.1503973928333353, 0.16474040861175931, 0.12703431349769667, 0.2389907374028244, 0.03857936591583999, 0.030414599243467455, 0.005070457763684089, 9.999999999998899e-05, 0.12460623048457509, 9.999999999998899e-05, 0.006980848871269929, 0.050376048531385775, 0.0608572794885438, 0.06124514299850048, 0.08272404371202668, 0.0620400947858456, 0.048795080730348994, 0.07061567536447544, 0.02001397850927855, 0.08795343009755563, 0.062215410028023665, 0.11519338398510681, 0.026293920078616195, 0.08986550736071386, 0.03502314061406686, 0.06982041016021434, 0.08338356451408124, 0.09543959547312042, 0.1054788464257157, 0.12867896041606186, 0.22837174134850224, 0.08227985231227453, 0.13503704328995791, 0.14517169871612934, 0.12289606920372176, 0.06570652060652771, 0.17055983238279437, 0.04823404665026587, 0.18156761906545138, 0.17646895412833585, 0.4364729012894166, 0.5062686473553358, 0.494871272265928, 0.42441568408990427, 0.4853355344489131, 0.519905607501173, 0.4360477798271811, 0.5080165703073891, 0.5028621642752035, 0.06979129826306385, 0.1445553800927306, 0.0960634775662973, 0.08925549126357313, 0.11658907914648076, 0.09765900130785798, 0.10213375946085546, 0.10772326427132362, 0.13101108533039296, 0.20126405539411263, 0.1998392942877132, 0.38529140730995104, 0.193136401314845, 0.26128473326191193, 0.32272370962692454, 0.19602406534235928, 0.18997452700713824, 0.26073479774574415, 0.2991709123895495, 0.4091579009314159, 0.32632092259884626, 0.29879914134466967, 0.38842813358119466, 0.4453969415712814, 0.3380868104804333, 0.41411196019461827, 0.37268480470893117, 0.14089103462958041, 0.30021817386697125, 0.19970545041777754, 0.20648314607093532, 0.280513465769069, 0.2439290199528843, 0.22994320819893388, 0.25139050816520025, 0.19641397486750556, 0.20417634008408414, 0.20014228786355492, 0.21085539953214028, 0.20895653598970088, 0.2069388289161883, 0.22040391449302543, 0.19890943662757898, 0.22635426145436854, 0.18991124635276846, 0.216998892512123, 0.2040717372881371, 0.1934674977009091, 0.19023580081530322, 0.20241269166376752, 0.23232987308145714, 0.1898619462852199, 0.21498797875481046, 0.19461225678603467, 0.6986120280033188, 0.8156186849537014, 0.8090886156371168, 0.1561758521498655, 0.15504786784172486, 0.15638484545081033, 0.1596549804206301, 0.16589900825803194, 0.5939803123446508, 0.3924922923417229, 0.5824856661501137, 0.6353573328358778, 0.20059843901332575, 0.20619580302543328, 0.2072297286237853, 0.5151114307963554, 0.4083608513466799, 0.7079637218835494, 0.18280410411802828, 0.17535162342839794, 0.18007850617020216, 0.1795400800470761, 0.19461462547844566, 0.18177761240466228, 0.18180763097947883, 0.2022713255504145, 0.18011679547364856, 0.08371356606116931, 0.09554432059709339, 0.08877869771238889, 0.07509296624873385, 0.09472976690052437, 0.08302462262147003, 0.09923407690481267, 0.12187421495033213, 0.1473157139421466]}, "mutation_prompt": null}
{"id": "05d6fcae-612f-4d4c-b604-c5e2ec325ea5", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)\n        self.inertia_weight = 0.4 + np.random.rand() * 0.5  # More adaptive inertia weight\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.8  # Adjusted cognitive coefficient\n        self.social_coeff = 1.0 + np.random.rand() * 0.8  # Adjusted social coefficient\n        self.F = 0.4 + np.random.rand() * 0.3  # Stochastic scaling factor for controlled exploration\n        self.CR = 0.8  # Adjusted crossover probability for better balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "AdaptiveHybridOptimizer", "description": "An adaptive hybrid optimizer combining differential evolution and particle swarm optimization with stochastic parameter tuning for enhanced exploration and exploitation.", "configspace": "", "generation": 21, "fitness": 0.2382708723038945, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "202050b5-6f01-45c2-acb5-f168d8b0ccc9", "metadata": {"aucs": [0.459771779622537, 0.6043331160314094, 0.5777915654841892, 0.45688443864887507, 0.5876937824447495, 0.572986738157591, 0.4715404090007047, 0.6087199805308189, 0.6086032560417364, 0.08528981835283467, 0.14714454455429127, 0.15853596569671013, 0.03791398393768963, 0.16075042165650644, 0.10191935668924723, 0.10602884558917414, 0.15640381645315826, 0.19003152057183037, 0.11984546991612766, 0.12433414862872416, 0.13319378100315848, 0.08994530666493206, 0.13105165270741403, 0.11561301305104976, 0.10994262850677095, 0.12269135341839066, 0.13763755968868097, 0.08402682025593444, 0.1115910473079702, 0.1565446059826603, 0.09987872208539028, 0.09963408753245295, 0.109296766436624, 0.08511617188832787, 0.10385014049728947, 0.1255877176238993, 0.962842007957322, 0.9369180419331595, 0.957580247650207, 0.9640073743448642, 0.9611582371601577, 0.9629589323233154, 0.9633011283047975, 0.9559174110060027, 0.9627583692935344, 0.2800089554933034, 0.3302224006630108, 0.337500613060858, 0.2267928720770379, 0.3104087049433333, 0.22578566931206445, 0.24679396271903342, 0.3219684475322282, 0.37084676850137843, 0.21656574799399264, 0.24954514896097202, 0.44669477779121247, 0.20749796425292066, 0.2077696113920261, 0.23574297654859688, 0.2815382055218921, 0.44399948846206827, 0.5008890410125817, 0.08571381517108934, 0.1643621580619964, 0.16785498113418018, 0.10417885851128394, 0.18349151705347777, 0.16091305171897352, 0.11801002509123537, 0.134798668246789, 0.12196504436396338, 0.16225971183790167, 0.11474636359366797, 0.09715719668989786, 0.1334516788250134, 0.16146892248020817, 0.16132456540998663, 0.15569565846667244, 0.15294201084905568, 0.17553998802821913, 9.999999999998899e-05, 0.021071912896953315, 0.007011092801660901, 0.0004571939512272305, 9.999999999998899e-05, 9.999999999998899e-05, 0.009409334264274705, 0.06725199202916987, 0.018310010039650715, 0.04184044839150536, 0.08514353652225692, 0.03824422801150518, 0.03751673636633146, 0.08145490606512795, 0.005229995132276399, 0.05560369275275656, 0.06740629653739905, 0.04830363024013751, 0.011499626692780152, 0.07722743427567513, 0.02516163657611037, 0.008126464990659943, 0.05502707254353867, 0.04935448253962027, 0.012456217807488845, 0.09687635527307126, 0.04949746954840406, 0.08862146418823735, 0.06535185215768158, 0.13131428203548057, 0.03065736082646453, 0.05179387157805215, 0.16873839384341804, 0.061720441737898146, 0.09494681545164696, 0.11386694661100427, 0.391175112214458, 0.48109528898884324, 0.42035732577060014, 0.3796718075867863, 0.4547556904989315, 0.4565825217804902, 0.41032083549730025, 0.4578558137197396, 0.43729285220668324, 0.09393869973353153, 0.09588119829589448, 0.11679599286265474, 0.09123864260210013, 0.11065884233353429, 0.1266590176729232, 0.08939351186405953, 0.11253089973454244, 0.10708754395641773, 0.1874944832742934, 0.21727766029084083, 0.1920565365292045, 0.1961006928848369, 0.13993825915749436, 0.13853849774870908, 0.1634833959919133, 0.17993168575153085, 0.22950431801193094, 0.2630984152086756, 0.2560762690454691, 0.22245015122213008, 0.21157824866354802, 0.28090683092828717, 0.3085555719476454, 0.30804987254129934, 0.3276124049730611, 0.2568508435683886, 0.22155088024948566, 0.2211764214864015, 0.18037397465875582, 0.20943223133697864, 0.27191832892394174, 0.2669266152661417, 0.21986562130498866, 0.2683491563469209, 0.12875186832628338, 0.22289888215737663, 0.20279628889186385, 0.20741194711912236, 0.19544008445625582, 0.2308406091449956, 0.21156008810746418, 0.20392521337594982, 0.19057554701559487, 0.2000622953755452, 0.18826768111671988, 0.2272820739929272, 0.20693203224836465, 0.17930276779600918, 0.18791545899844864, 0.18605455745758914, 0.17734248853922308, 0.2095935901409023, 0.2035856933878295, 0.6650423803431507, 0.7483915784212717, 0.729627365049786, 0.1541225568806034, 0.5602321224337269, 0.15616232358910587, 0.16730017423829358, 0.7123300438621878, 0.5530666102682914, 0.3385669841598571, 0.4885161862865228, 0.624814466050428, 0.1653156954128071, 0.16707729626321322, 0.35053606282636296, 0.41366572434228943, 0.3186323151260203, 0.6235189272217687, 0.18659154524045363, 0.1845138501613085, 0.1940965211262815, 0.18429555469178027, 0.1741918780809114, 0.18547625328424966, 0.1853218789316169, 0.20628651508934504, 0.18026890736522905, 0.07634739588883455, 0.07895610316106305, 0.08959010744691809, 0.07556796381760433, 0.07318301348582112, 0.08307694488876638, 0.09164984991707259, 0.1055098518711367, 0.08893248905149742]}, "mutation_prompt": null}
{"id": "0800a80f-3fc0-491f-b0ca-817f7c11d79e", "solution": "import numpy as np\n\nclass NovelAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(120, budget // 8)  # Slightly larger population size\n        self.inertia_weight = 0.3 + np.random.rand() * 0.5  # Adaptive inertia weight for better exploration\n        self.cognitive_coeff = 1.1 + np.random.rand() * 0.7  # Slightly wider range for cognitive coefficient\n        self.social_coeff = 1.1 + np.random.rand() * 0.7  # Slightly wider range for social coefficient\n        self.F = 0.4 + np.random.rand() * 0.3  # Broader range for scaling factor\n        self.CR = 0.85  # Adjusted crossover probability for balanced exploration-exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with enhanced personal learning component\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling with reflection\n                over_bounds = np.logical_or(positions[i] < self.lower_bound, positions[i] > self.upper_bound)\n                positions[i][over_bounds] = np.clip(positions[i][over_bounds], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "NovelAdaptiveHybridOptimizer", "description": "A novel adaptive hybrid optimizer that enhances exploration and convergence through stochastic adjustments and personalized learning strategies.", "configspace": "", "generation": 22, "fitness": 0.2215571902296173, "feedback": "The algorithm NovelAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "202050b5-6f01-45c2-acb5-f168d8b0ccc9", "metadata": {"aucs": [0.36457182790761766, 0.5600880909705102, 0.4789255898971472, 0.40230458640131306, 0.5287600027611594, 0.45329014440016513, 0.42143680325195887, 0.5196627030060659, 0.48527991345981436, 0.046084605349469565, 0.13963760807814418, 0.11527010391337367, 0.02462208551489531, 0.14269552256621065, 0.10893340618473446, 0.050065124548425266, 0.1666982808994668, 0.003701331982917666, 0.13086136130121995, 0.11908291540222304, 0.1082283210468129, 0.07494042328950945, 0.11780388921175822, 0.09811152378392707, 0.10988460867961225, 0.10830707094688696, 0.1370701127649736, 0.09637415930891291, 0.09356089510201693, 0.10533937360317691, 0.08764978348265573, 0.10361735396709859, 0.11075422638786081, 0.07808661296605479, 0.08719741683711524, 0.10578555480903429, 0.956104630443836, 0.9539936120624276, 0.9558517693864818, 0.9564254899055012, 0.9529936695979359, 0.9550965835631449, 0.9544468960925371, 0.9522271194533884, 0.954365031317248, 0.19688034663975773, 0.26196067280077473, 0.26336472463078864, 0.23698654763586247, 0.2914952056782578, 0.29269698696875557, 0.21421570557880298, 0.2782789706798543, 0.28718761782320246, 0.19802572778129146, 0.48910576671485495, 0.29127493363692925, 0.18239103854795513, 0.23072703259355198, 0.236206922339245, 0.2240778048689498, 0.2271478091643081, 0.40850400739191706, 0.0836618009725415, 0.15019858505887018, 0.1052478299460674, 0.10882078447624666, 0.13395840748454635, 0.14459799918985716, 0.12865869246002803, 0.1366803571801476, 0.15354945639307793, 0.11627817072491775, 0.12838768834397796, 0.13733893925474117, 0.11672138020412659, 0.12677464795122273, 0.14341943173481797, 0.12006877320881282, 0.09571298244080484, 0.1758750760086657, 0.008676963481335065, 9.999999999998899e-05, 0.026293089905070177, 0.008974772568698053, 0.010025157382817285, 9.999999999998899e-05, 0.010913707820402796, 0.04651673286085112, 0.007816399413215325, 0.016408940156640295, 0.09338761700717191, 0.11613572720173726, 0.03317711048819527, 0.03987476537730672, 0.020510336753289393, 0.05575146135871678, 0.11220144900499196, 0.11723459717730844, 9.999999999998899e-05, 0.03531859213352495, 0.019792824583982682, 0.006862222351183278, 0.04800751390961866, 0.016888442526330927, 0.015044550706747928, 0.035699254404221725, 0.04309494229035593, 0.07809556464767464, 0.06581041115455522, 0.07374693349528483, 0.08694322020804812, 0.11366083474661504, 0.10682227771818376, 0.0638569125232662, 0.1216429643238538, 0.04737278582981541, 0.37360982431826273, 0.42492513807260734, 0.4069216361284683, 0.3758769805578972, 0.4486931078993621, 0.44106813070603024, 0.340441835361992, 0.46586885319962645, 0.4073914485627127, 0.09345069102548953, 0.16359029276700898, 0.10207238109620487, 0.08844341616660167, 0.11113296813247431, 0.11573940121456328, 0.09096383597391322, 0.11230284280956804, 0.11615495481177585, 0.16984721126579083, 0.2051503057921361, 0.14318041566228057, 0.15373550340916553, 0.17526501634359504, 0.21396571082015958, 0.13245887126140843, 0.15192217619739534, 0.17211656905701966, 0.21712186357023466, 0.29940798146918945, 0.27141048673281576, 0.2512143134133835, 0.2891381467823725, 0.2731042232322217, 0.251842972153285, 0.30812937618788416, 0.3069628671643455, 0.16577285502369055, 0.22499498612968638, 0.24244414936836844, 0.20327094631341525, 0.2483413223991735, 0.17401737654715976, 0.173348754404548, 0.15819254996498144, 0.1853194086614378, 0.20220453011719963, 0.21208897949179195, 0.23650113587054244, 0.1925033767332256, 0.1925503825866446, 0.21670900896450007, 0.20728105388241436, 0.24451912391062836, 0.206450540457362, 0.20080098480755637, 0.18925277529994788, 0.1955763131235254, 0.17445772428542516, 0.20559760297826657, 0.18621167635306968, 0.18561725899335402, 0.18735576855771818, 0.19787250020646596, 0.6126933362073581, 0.726938628742986, 0.6980000980289403, 0.15734819801493194, 0.15354882537720493, 0.12401433943413209, 0.5103211559184433, 0.6766747038831621, 0.7135534017604208, 0.40392263848767385, 0.44222179017339636, 0.3206357838163566, 0.1929473672133134, 0.19007091452201885, 0.20077215624498335, 0.3421305278153338, 0.48148305432414884, 0.126061511847261, 0.17598419358457762, 0.1795155446776704, 0.1671289164288572, 0.21605165105262936, 0.19515405998805968, 0.195757910532939, 0.1869259677449695, 0.18312870463577435, 0.2021354507680203, 0.077930159148763, 0.07707907313363926, 0.08427306728960504, 0.07443895793875477, 0.07373058415561895, 0.07816068315266289, 0.07526379301177799, 0.0889065364033701, 0.08204853355996344]}, "mutation_prompt": null}
{"id": "e1273e3d-3b4b-4b4f-bc4e-02744fb32d85", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 12)  # Adjusted population size\n        self.inertia_weight = 0.1 + np.random.rand() * 0.7  # Broad adaptive inertia weight\n        self.cognitive_coeff = 1.5 + np.random.rand() * 0.4  # Adjusted cognitive coefficient\n        self.social_coeff = 1.5 + np.random.rand() * 0.4  # Adjusted social coefficient\n        self.F = 0.4 + np.random.rand() * 0.3  # Fine-tuned scaling factor for exploration\n        self.CR = 0.85  # Optimized crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with improved boundary handling\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Enhanced adaptive boundaries\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedAdaptiveHybridOptimizer", "description": "A stochastic and adaptive hybrid optimizer combining elements of PSO and DE with enhanced adaptive parameters for improved exploration and exploitation balance.", "configspace": "", "generation": 23, "fitness": 0.26461294638311045, "feedback": "The algorithm EnhancedAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "202050b5-6f01-45c2-acb5-f168d8b0ccc9", "metadata": {"aucs": [0.6651349256989041, 0.7397027463575847, 0.736288045060582, 0.6587720724655672, 0.7559867976516215, 0.7356562023104407, 0.6242885328101695, 0.7610439764172788, 0.7274648003488624, 0.1832828528319349, 0.47714182733028365, 0.4435512504960839, 0.22513570414443762, 0.4712350590761142, 0.2412980065480429, 0.04614883323122909, 0.4597835964307203, 0.4025273307432621, 0.13320915130180544, 0.13504743538017705, 0.10919009899386023, 0.21369451743936374, 0.06875662045681052, 0.16884931217388277, 0.11569693789612612, 0.13625550614333992, 0.12580299477914736, 0.10692716257413071, 0.11287529280038144, 0.11763446634385166, 0.11097277756962753, 0.12572904993306966, 0.10682037537271138, 0.11342918338907382, 0.12881757555771578, 0.10812413082860162, 0.971608054716191, 0.9712647194980388, 0.9719981492961886, 0.9786717878202756, 0.9714403243516431, 0.9786496571026029, 0.9702137276169395, 0.9691392311287353, 0.9697326439808117, 0.27320600806800566, 0.46670535530148605, 0.4220137334857553, 0.14656428534307775, 0.40447889434449247, 0.3246507961869959, 0.31531249716657717, 0.33498463967319614, 0.3509788998392098, 0.5497317414165919, 0.7726444401854025, 0.3007372697966333, 0.5144856442254091, 0.2043296647454953, 0.20568935985143144, 0.27165420210163727, 0.16956112725011296, 0.6359734846733426, 0.18162125258537798, 0.12082378432899443, 0.18475668224412534, 0.16501519549105048, 0.19603217813168172, 0.125915892395413, 0.19456810894981358, 0.25750585173201357, 0.3994522711611126, 0.1569964801951268, 0.12346561037875836, 0.21371847554031365, 0.14661440360855726, 0.20407934904984526, 0.2171078133260822, 0.20197103116976367, 0.21288257936156774, 0.11592255810286456, 0.0011277147709093382, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04967294909048592, 0.07188116123262767, 0.056735181054083816, 0.024937322381811677, 0.09359326927692069, 0.13554833681076284, 0.005679073737363982, 0.047941648746121834, 0.031585736198559755, 0.04575630266214137, 0.03320756755168608, 0.03322559710734896, 0.03022716214531973, 0.03958943214944188, 0.037786984182600625, 0.06691575775443492, 0.10206896412079147, 0.07125065375447648, 0.06344678730406672, 0.0785239679833587, 0.0722124387424048, 0.03772960974890016, 0.18977721742745302, 0.16986340174181647, 0.03414082484754477, 0.1158015135607906, 0.04633329665206676, 0.07272598439034295, 0.23596895829462683, 0.07919903691610775, 0.43509546558454537, 0.5190705630128771, 0.46702597385906763, 0.469009582442397, 0.5384315207668937, 0.4954647158262391, 0.44994030665217, 0.5399097991292162, 0.4929538238384775, 0.1234856168143651, 0.15918634983218927, 0.12174029861849434, 0.0982157926301983, 0.1619838630487902, 0.12751931188470012, 0.12932533380281053, 0.11949465372569068, 0.09027457605193034, 0.15416739285301773, 0.1992588683892602, 0.23039560144201232, 0.15824417080662423, 0.14511925954142457, 0.1843292260288535, 0.19090216435225182, 0.20980153785002198, 0.21284646037824273, 0.2701171610519323, 0.31038760661504083, 0.37708042684568366, 0.3195027447787442, 0.4313629678450632, 0.21336769989787696, 0.3585764746088317, 0.4063323406609145, 0.40086823414773387, 0.2011780081014377, 0.19485864887088322, 0.19620779885868112, 0.2186347880056021, 0.2361634697678513, 0.23327557190007697, 0.14397588477866807, 0.22098959197319634, 0.21464798622329528, 0.21131133216773224, 0.20570254498670415, 0.24179784397105109, 0.19485665725413415, 0.19297353990619914, 0.22590546250342114, 0.1848804159961812, 0.22217845713691453, 0.252446661629276, 0.19336504205688143, 0.19037853475716648, 0.21006763564525233, 0.285491939949002, 0.19978501208017674, 0.19106543532911824, 0.23901284221252383, 0.20479680762768449, 0.20321008965895315, 0.8083016772816993, 0.8392580440366739, 0.8268142111817974, 0.16791430326461354, 0.1905719492273793, 0.15739796128997918, 0.20628140638243664, 0.14515675701002728, 0.2078471846019131, 0.384361881069214, 0.5622225577977286, 0.5425447874336943, 0.20785184252462507, 0.15320636980943036, 0.20821514211390724, 0.1246789063054442, 0.12770403648611228, 0.12607842560434723, 0.17545589278759233, 0.18693062072917854, 0.1820485994437444, 0.22059436116057618, 0.17382999033507762, 0.1773943508217004, 0.18720073735181775, 0.1903023795562253, 0.19557001731521295, 0.09183157443227552, 0.1049995550136602, 0.09388396655275932, 0.08231892199148627, 0.0885863195819544, 0.08473980121585334, 0.08912510238923754, 0.1133942743507469, 0.10973776319617534]}, "mutation_prompt": null}
{"id": "38414141-0d1e-4ef8-8a2b-1318fc03c21c", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)  # Increased population size\n        self.inertia_weight = 0.2 + np.random.rand() * 0.6  # More adaptive inertia weight\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.6  # Adjusted cognitive coefficient\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Adjusted social coefficient\n        self.F = 0.5 + np.random.rand() * 0.2  # Stochastic scaling factor for controlled exploration\n        self.CR = 0.9  # Increased crossover probability for improved exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with improved boundary handling\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Enhanced adaptive boundaries\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedAdaptiveHybridOptimizer", "description": "An enhanced adaptive hybrid optimizer using improved diversification and convergence strategies with stochastic adjustments for better performance.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "202050b5-6f01-45c2-acb5-f168d8b0ccc9", "metadata": {"aucs": [0.5852294117324612, 0.6979875755122553, 0.6953442499877388, 0.5608515908436158, 0.7069657920428565, 0.675915236904566, 0.5645977874538252, 0.6960157091583943, 0.6818305061681156, 0.1705804944966598, 0.3474249738747276, 0.2998337514977877, 0.1871026600839294, 0.3569307668362882, 0.30769124795655056, 0.19456263667245288, 0.3840178311838547, 0.33907576947739493, 0.1280092282207541, 0.12876705053248316, 0.13446753046367177, 0.09174748055663673, 0.11878909225315815, 0.1140222458789909, 0.11445527079095141, 0.11840810202647278, 0.3225094217115967, 0.1219429524425153, 0.10796389301112175, 0.1330159672142447, 0.10970408815320976, 0.11875014799272177, 0.1324509817673747, 0.09819712944979442, 0.11439350073470489, 0.14127221038518578, 0.963707381261811, 0.9421623007810382, 0.9626312194876516, 0.9636693414109827, 0.9604249667020412, 0.962915392815701, 0.9631004773681624, 0.9569180530633633, 0.9625063658444587, 0.2860736829238698, 0.3337161718948499, 0.4039631087074471, 0.32391643245602186, 0.43691087337752077, 0.3883299033996209, 0.3091571375544735, 0.38894098408677846, 0.3673158315298002, 0.21097509880595022, 0.28220953456698417, 0.6861095640680542, 0.25383487928091875, 0.611182621847971, 0.3020998574107846, 0.46621311013857825, 0.5656737441877652, 0.5681858819704655, 0.15624410456909077, 0.14281882633182363, 0.17403997418258677, 0.12616087136331522, 0.17814727915512196, 0.12022672386885747, 0.11269334973536893, 0.1767516901203915, 0.26564041171555397, 0.17138486623118898, 0.1177662643056907, 0.2236584017598372, 0.16634331994445273, 0.1872037685572956, 0.19236127872646147, 0.19044023667329713, 0.1915757014378736, 0.21399399827986854, 9.999999999998899e-05, 0.0029887665236717487, 9.999999999998899e-05, 0.030677007635199538, 9.999999999998899e-05, 0.016669217954921267, 0.07076674837493935, 0.055594508001541865, 0.10668406214572401, 0.05169130024936075, 0.07334881503263135, 0.027025180785791636, 0.009262053257207525, 0.040327665275200486, 0.03799360759393078, 0.062465441063213833, 0.06755337403937156, 0.10273294410369105, 0.028232106783028788, 0.10280104373041254, 0.035828070321737515, 0.08692137816321266, 0.07510271637585297, 0.15673301037220044, 0.10945167668643885, 0.09709547024145027, 0.19360555486331865, 0.04850809991645477, 0.05585419568147387, 0.06316383196759756, 0.14289929269049972, 0.14682137343397195, 0.07960551375113523, 0.050395098892449974, 0.07847514558948221, 0.05080960624310682, 0.43677489550674975, 0.47008341970784084, 0.46721219474624176, 0.48225050501622146, 0.5197920261766301, 0.48717308167160056, 0.44711911609225685, 0.526867544295534, 0.483243830509127, 0.10641123078025017, 0.10938308455592727, 0.11043073174920215, 0.10135479799648706, 0.10550598643133469, 0.12181149705965777, 0.10151954166487054, 0.12404701378801852, 0.09629520765832367, 0.17965876625095423, 0.2581699836748207, 0.22660960941226138, 0.18643183571029953, 0.19292786938445838, 0.15067430784464464, 0.1867124961133061, 0.24563166948905535, 0.25247386903570124, 0.2978716759643383, 0.38415648082071674, 0.3261168094250637, 0.30447094047831225, 0.28508136926270533, 0.38525311025498243, 0.3192864317625317, 0.3887201132969209, 0.3954299993851208, 0.2738056708566806, 0.1514047116888414, 0.17267010681769424, 0.1892805599917894, 0.3032363565838062, 0.33202381571779915, 0.1290579570583955, 0.24742120918205568, 0.13205181406226585, 0.18285230522271823, 0.22782151642342374, 0.19196194321705373, 0.19207497507442428, 0.20713407269046757, 0.21682109831282181, 0.23299115790345482, 0.2246289665476161, 0.21811290332179933, 0.20749139262135474, 0.20010802603438693, 0.19980291726531674, 0.21222833969671373, 0.21542311387561808, 0.19866889435358692, 0.194483483158838, 0.21605986702521263, 0.21099363933731896, 0.7403398770729364, 0.8071705181277389, 0.7973030182889959, 0.6840724160723382, 0.7212217000120645, 0.76689024578417, 0.17967956819825137, 0.7730576180911504, 0.17398121191088034, 0.4651373928318656, 0.4972648462205682, 0.6089170645541698, 0.2001287805187285, 0.2050501112987667, 0.20353636651733253, 0.4385211532155976, 0.5748352870044586, 0.3300839547791171, 0.17404007234466534, 0.19258141492985825, 0.17750578889741186, 0.1788585128464596, 0.18667431955390457, 0.18598640749389284, 0.18769667737534845, 0.18206153254043633, 0.1872726316139548, 0.077422710778842, 0.08545662560425737, 0.09093651856960283, 0.08130086420607385, 0.1076725095222626, 0.0836416792990945, 0.12120158979453644, 0.10204993283104535, 0.10477873971668195]}, "mutation_prompt": null}
{"id": "8684829b-b54e-415a-889a-5abbf4b912d0", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 8)  # Adjusted population size\n        self.inertia_weight = 0.3 + np.random.rand() * 0.5  # Adaptive inertia weight with a smaller range\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.8  # Broader cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.8  # Broader social coefficient range\n        self.F = 0.6 + np.random.rand() * 0.1  # Slightly increased stochastic scaling factor\n        self.CR = 0.8  # Reduced crossover probability for controlled exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer integrating adaptive parameter tuning and elite strategies for enhanced performance.", "configspace": "", "generation": 25, "fitness": 0.28736742174968277, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "202050b5-6f01-45c2-acb5-f168d8b0ccc9", "metadata": {"aucs": [0.6107595771944092, 0.7336076492275037, 0.7218867831929905, 0.6441271529487209, 0.7458443798803229, 0.7232908330790281, 0.6207207413443914, 0.7694375478868992, 0.7301622812476694, 0.16801123922506178, 0.4257680890816289, 0.14580319301324052, 0.23884269481327247, 0.3917016502915097, 0.39013516750663657, 0.20935296171396334, 0.41546948268631145, 0.32101323294140693, 0.15236105069216754, 0.1627393007634773, 0.14230643241979546, 0.1381027705897735, 0.1334122630388418, 0.16705964802125894, 0.1450439544215606, 0.12317867245481506, 0.14428843242178757, 0.09344502977309443, 0.12284780123833938, 0.11485148783983024, 0.11253786646551944, 0.13401230037348832, 0.1198653534671541, 0.10281327809957841, 0.15109432225478125, 0.11735064569272147, 0.9715550890279523, 0.9716795094354467, 0.9710746527821017, 0.967426966376479, 0.9557935770059035, 0.9691133770188564, 0.9733468086244532, 0.9659152971556774, 0.9695314551742413, 0.3632846981562208, 0.46873650285685486, 0.48553550794034017, 0.36384800933487127, 0.493478972985847, 0.44794728989052524, 0.3584238556072752, 0.44448969082285983, 0.48604522157041696, 0.6438063260477971, 0.6483071265071431, 0.6377961899441513, 0.4965117761667671, 0.6760883561749138, 0.35188667266579754, 0.23082656913312583, 0.6074824070783418, 0.1672034296716982, 0.15806307801808595, 0.1937717909503872, 0.11466768854055243, 0.16142764958670286, 0.18271839918451815, 0.2038765487576102, 0.16067837201517488, 0.20285162326343253, 0.19425823001025255, 0.1632342859608078, 0.19872017912962658, 0.19168080710007052, 0.22292561521312304, 0.2057636767258748, 0.21700450871934795, 0.17481376344438393, 0.22480027541541425, 0.1099085207186068, 9.999999999998899e-05, 0.06324271589367803, 0.04335002768453977, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.029459278142541567, 0.05217202792340381, 0.10143732177220133, 0.052328565315270636, 0.07988201932902761, 0.05135158023099606, 0.03226078423252399, 0.028937918915133976, 0.04891358185043504, 0.03025029710666116, 0.0668296613753977, 0.04657410639328552, 0.08527357277077241, 0.024782672052716226, 0.14341007643682147, 0.04997604671838107, 0.06260804849917745, 0.05850242395970995, 0.0633555434362193, 0.08400295780335676, 0.08694834506495897, 0.09502421486383605, 0.12535306975490135, 0.1063223251839932, 0.16279659490494947, 0.0680409521628812, 0.09556115209064031, 0.07015202892496741, 0.07614910449529655, 0.0746812119454251, 0.44643780839715397, 0.5544822903900354, 0.48823243332704347, 0.4679630934297533, 0.5495246586041629, 0.5001751647734292, 0.4611342993695351, 0.5510795662718037, 0.5444323605437928, 0.10056425479854136, 0.11908963024671082, 0.1290585444572303, 0.11924986898049739, 0.1508417150798621, 0.11329581194971272, 0.11620257638382592, 0.118136951410592, 0.09987717270228791, 0.24034558869472356, 0.1260451974918384, 0.30815562413444764, 0.13380121632672448, 0.1366093199494861, 0.18400458335743142, 0.13831017861872585, 0.16739141759062004, 0.19716725196333174, 0.34761366571615226, 0.31055642765505787, 0.3994808391590995, 0.27964767839294635, 0.41783287397617475, 0.40039137560125193, 0.35012899170276146, 0.46810904265879016, 0.44476697393123654, 0.21146376177196946, 0.23868923758552119, 0.1438770449063722, 0.26136139427021376, 0.26011186125349006, 0.14181049257630274, 0.25002032048980405, 0.32705895974282184, 0.2949849432118977, 0.17805065139636556, 0.20327871881739523, 0.2240459710017375, 0.2001056139717421, 0.2378104271646041, 0.23160009576058738, 0.1881921512288155, 0.23641736925119705, 0.20765716828333358, 0.1942159755360513, 0.18499170490171213, 0.19632779220625884, 0.3443756334604704, 0.23736557951993464, 0.5437556328978688, 0.20262532206784012, 0.3971931866279659, 0.2147400078894227, 0.7980370198247051, 0.8338393609208957, 0.8471423313445697, 0.7344673942451276, 0.8002046389672286, 0.17047635509654013, 0.16533686499192246, 0.1948337898998007, 0.11323928777417236, 0.47059348025763026, 0.6791792693948604, 0.6768861286899372, 0.20830087201761238, 0.2068775985934137, 0.20943654221879593, 0.20575362326429336, 0.12707700331958383, 0.7501641432855739, 0.18500183775027157, 0.1899789302054311, 0.18298029876562127, 0.2038397142597711, 0.19511475327104355, 0.18106265792180842, 0.1730347079719612, 0.1888143068115975, 0.20649588302918132, 0.09443294108523093, 0.08782109210883104, 0.09047129097904949, 0.11156483477043733, 0.10565773695235892, 0.12073772418207518, 0.10777331396666179, 0.10622477269144892, 0.10437128882648794]}, "mutation_prompt": null}
{"id": "f6642dd0-d72a-44d6-936c-edb83e40e60d", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 8)\n        self.inertia_weight = 0.4 + np.random.rand() * 0.3  # Slightly increased adaptive inertia weight range\n        self.cognitive_coeff = 1.1 + np.random.rand() * 0.7  # Adjusted cognitive coefficient for better balance\n        self.social_coeff = 1.1 + np.random.rand() * 0.7  # Adjusted social coefficient for better balance\n        self.F = 0.65 + np.random.rand() * 0.05  # Fine-tuned stochastic scaling factor\n        self.CR = 0.85  # Slightly increased crossover probability for enhanced variation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer with enhanced adaptive inertia and crossover strategies for improved balance between exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.2787511838229568, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "8684829b-b54e-415a-889a-5abbf4b912d0", "metadata": {"aucs": [0.6053313112054768, 0.7325803909119435, 0.7112087032489214, 0.6089424070239744, 0.6961905485537381, 0.6864091853330805, 0.632900576421261, 0.7316296979155241, 0.7132063932220091, 0.0298009750596806, 0.3773674604624633, 0.27450935713162694, 0.24506850608049746, 0.3606692242856119, 0.26917941279612856, 0.2492941093600497, 0.40406488594257484, 0.37807627737898364, 0.11930058680215139, 0.11435837575855146, 0.15663671032837811, 0.1322406388463525, 0.13799456001964971, 0.12162385663836084, 0.09723297850724266, 0.1456799635430589, 0.14597964844131528, 0.08827001917678823, 0.1165461388653688, 0.13222501909565887, 0.09780661365299004, 0.09513014273244713, 0.11833695456472526, 0.09754155843917378, 0.1093589024010293, 0.12355963652635071, 0.9737237039836322, 0.9705713825039268, 0.97365225171126, 0.9710641355002525, 0.9701288169413159, 0.9703165327580433, 0.9704600662448859, 0.9684092775947605, 0.9697066457490181, 0.28691030816906093, 0.43749539588019093, 0.43506098783971614, 0.3123188409632023, 0.35375023084616075, 0.14787301399982133, 0.32371146749102564, 0.41450259887114027, 0.4535329167006905, 0.2083483466199647, 0.7107002026762783, 0.21654082502104977, 0.1895588892141018, 0.7244234917033303, 0.15967278236869975, 0.27912120925435324, 0.6020137292483195, 0.6563696731512936, 0.16673732348968062, 0.17982030618452516, 0.1953145435601228, 0.1472390704375266, 0.197796127449115, 0.18436647751425816, 0.15735051617855222, 0.176146751332231, 0.18699705987662907, 0.16770508444655607, 0.19427168603837608, 0.20491297407171138, 0.17395333455677686, 0.21363250845718484, 0.20562198870000248, 0.19817478247860876, 0.12528761646905628, 0.2072427684430238, 9.999999999998899e-05, 0.04390107967853929, 0.07755684992735312, 9.999999999998899e-05, 9.999999999998899e-05, 0.0001267268766630414, 0.07042889744889147, 0.10274392035684521, 0.055979153605619336, 0.11064290423202916, 0.10265995787116422, 0.04287300963570306, 0.007285990220453287, 0.05232068624944697, 0.07286381628900329, 0.06406968276085367, 0.044035457596437344, 0.1004616190948866, 0.08969643203867139, 0.0376415843609722, 0.12508839506920488, 0.04371913675336747, 0.0564457138651302, 0.05706199571244175, 0.09082746860763091, 0.08554232483892665, 0.07415372856940505, 0.05970709305181354, 0.12708344399193083, 0.1336506910579245, 0.03340440412785051, 0.0358088986906836, 0.12569626222998798, 0.07027830788192846, 0.1558085733977177, 0.07653579088709173, 0.4290353545237733, 0.5059353385821102, 0.5155353460693219, 0.4621241000031947, 0.49668466618640084, 0.5167162022450432, 0.46553058028481265, 0.5069096843100274, 0.507082780818333, 0.09553988176712169, 0.11810815216466741, 0.12852989996923592, 0.10993275190443219, 0.12227962749844157, 0.13369924981573167, 0.10999819934590449, 0.09782914398475417, 0.11261615207449482, 0.14347113970684344, 0.180451067295461, 0.1955563101382659, 0.13916335892074272, 0.14029225456007532, 0.14253128771676582, 0.1681936200166032, 0.24864971551003368, 0.20211640167658185, 0.26754290310435547, 0.4037834256094548, 0.2609874346899319, 0.264692907859138, 0.35017101981652, 0.3931649995735452, 0.2612015942216467, 0.4237872096788451, 0.38808818232431264, 0.2488886907815704, 0.22613031743544276, 0.26062002129628425, 0.23718294734993395, 0.30326093265545473, 0.29208160837519703, 0.18253460259955878, 0.2763712664290824, 0.20239101848698926, 0.20214460185476013, 0.2313698313832241, 0.23230323062252933, 0.19152532324613436, 0.20411845056811107, 0.22779387346816593, 0.21014124557445613, 0.2105947789930558, 0.22661282481709955, 0.22333419416715972, 0.22324146528021638, 0.19581041370209196, 0.3190977588137913, 0.22157422171386854, 0.4277788185835387, 0.19971528521428705, 0.4035643115731974, 0.1835606227641028, 0.7476808279465794, 0.8452487723954754, 0.805851182974531, 0.7642402988114209, 0.8339082988152724, 0.8112204947520273, 0.14341474436678636, 0.7409401511718898, 0.12436707955702075, 0.34542635416830936, 0.6627954291948659, 0.6068249452458356, 0.16437544188587105, 0.6369385722896242, 0.2037801631691022, 0.15308445303181883, 0.1516352506440699, 0.15442943464680414, 0.19569858365689918, 0.18451568853462175, 0.18381003399463536, 0.18379081620055904, 0.17647765420604333, 0.19337884685356999, 0.18537240212926298, 0.1925204479663971, 0.17768990815237817, 0.07977543424854561, 0.08749395548969874, 0.08924736675637668, 0.08579529089947924, 0.1011144883600189, 0.11482757331134219, 0.07628409859812857, 0.11075931702246145, 0.10870693625558214]}, "mutation_prompt": null}
{"id": "235cff98-de8f-42ea-aca3-629e293cc396", "solution": "import numpy as np\n\nclass DynamicMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 6)  # Adjusting population size for dynamic adaptability\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Narrower adaptive inertia weight\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.6  # Slightly reduced cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Slightly reduced social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.2  # Broadened stochastic scaling factor\n        self.CR = 0.7  # Adjusted crossover probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n\n                if np.random.rand() < 0.5:  # Adaptive strategy switch\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR:\n                            trial_vector[j] = mutant_vector[j]\n\n                trial_value = func(trial_vector)\n                evaluations += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n\n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n\n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                if np.random.rand() < 0.8:  # Selective exploration\n                    elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                    r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                    velocities[i] = (self.inertia_weight * velocities[i] +\n                                     self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                     self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                     0.3 * r3 * (elite_partner - positions[i]))\n                    positions[i] += velocities[i]\n\n            # Adaptive boundary handling\n            positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n            for i in range(self.population_size):\n                current_value = func(positions[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n\n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "DynamicMultiStrategyOptimizer", "description": "Dynamic Multi-Strategy Optimizer using adaptive learning and selective exploration for robust optimization.", "configspace": "", "generation": 27, "fitness": 0.21347054117125738, "feedback": "The algorithm DynamicMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.21.", "error": "", "parent_id": "8684829b-b54e-415a-889a-5abbf4b912d0", "metadata": {"aucs": [0.3872265203282079, 0.641714413864849, 0.3781620721615634, 0.40433752066356576, 0.5145863617237035, 0.520986242688477, 0.3838743215350654, 0.6962858641521203, 0.6320616369351533, 0.035936504362861665, 0.14682257681999822, 0.10970736122175873, 0.10615516670709424, 0.16021088366193614, 0.09983199031912715, 0.0848822362982945, 0.11128741897835592, 0.13109502887993985, 0.09625688563038803, 0.12330325524391139, 0.061837108546842545, 0.06961797254850421, 0.09955634668050384, 0.06398846557523508, 0.0825101099723401, 0.08424263561674028, 0.07951811721111557, 0.05646233408131518, 0.0967132435385305, 0.10245402787695135, 0.09493902351959982, 0.08910374401322896, 0.07944806812954064, 0.09482812461722401, 0.10352408859576923, 0.0960706718655494, 0.9680860019008521, 0.9671058344393372, 0.9672630704569762, 0.956320979841051, 0.9645466992858652, 0.9573863293028018, 0.9456319821999671, 0.9350951495238056, 0.9548977779359974, 0.10892199824467519, 0.2919765394055981, 0.1907097690064905, 0.136143502821385, 0.14351879078208407, 0.1428195687293211, 0.08800489792560018, 0.3083039210444596, 0.08916906461848118, 0.2633203428740901, 0.2189200247870936, 0.5234014599784365, 0.15784584521891576, 0.15711125427213624, 0.15738825299282344, 0.18490519502590108, 0.6138574426355641, 0.14735250861257065, 0.11137470123477633, 0.15949526423966454, 0.1542126788933933, 0.12686269507759373, 0.1572606477436539, 0.16096782968015755, 0.11462273155931746, 0.15859362498249663, 0.15060886921321803, 0.12771113543225732, 0.12234483238305272, 0.20133040502217325, 0.11946510428194068, 0.0961123286355452, 0.19839376514885498, 0.0842416190612757, 0.18251179759326575, 0.07347030336781613, 9.999999999998899e-05, 0.013679888383750005, 9.999999999998899e-05, 9.999999999998899e-05, 0.027961228737596655, 0.025455907283271295, 0.0001196031242020057, 0.0015391307808815258, 9.999999999998899e-05, 0.03834288094873628, 0.059841165835573196, 0.022143884204230968, 0.008495118550732705, 0.014122679411176065, 0.048579379174795934, 0.0785822761106878, 0.06792452527123205, 0.04194839444923215, 0.004122684282324873, 0.04486535198083608, 9.999999999998899e-05, 0.013480483115227093, 0.059546919261440734, 0.08838327358979003, 0.01844382999284866, 9.999999999998899e-05, 0.038102834655773354, 0.06161876196022642, 0.16142134611925518, 0.10205693232353097, 0.02987414666555155, 0.0974653631903395, 0.02644954629494145, 0.06408266413739039, 0.15427866591095662, 0.06041032329730045, 0.3814018222648572, 0.42726207713446285, 0.45672086022747016, 0.3814325130012105, 0.42578042269444627, 0.42942085859227497, 0.3440436929828182, 0.44199277118123104, 0.40454325721206674, 0.07847467284043219, 0.10552843578722693, 0.11160271666492882, 0.09060208332674591, 0.11285108221554274, 0.09322812098265565, 0.08498113811930874, 0.0910980314387616, 0.14301258974766273, 0.1590907299544353, 0.20049139212668432, 0.1912820566066571, 0.18424575045857328, 0.15694816527476274, 0.15836989692553072, 0.17462885925229055, 0.18985733469050103, 0.16780725088714987, 0.2126563911861945, 0.24193548215085048, 0.21185035827838394, 0.2588778927732873, 0.3086354396477057, 0.29616935828414337, 0.25431809736646205, 0.28535958397527217, 0.3165305075234284, 0.16075538307204518, 0.2504628058082764, 0.1639696991618984, 0.1657881022969554, 0.22286399478379137, 0.18323573451930875, 0.1267647585849081, 0.24941778289211092, 0.13098734498693398, 0.17691792215220536, 0.1652887094735881, 0.1913503118804084, 0.1961988824636478, 0.24047013107512616, 0.20686299548092424, 0.17083620794055254, 0.20624641002144029, 0.20710476538333555, 0.1949379279462351, 0.3116676114254575, 0.18852874289833121, 0.2055555566749917, 0.19073941659457283, 0.18204800891586415, 0.20707546571761226, 0.22594195366600356, 0.2057492153907614, 0.5783788886822925, 0.79692614243141, 0.4758801719319027, 0.16847493283588533, 0.16914803322749394, 0.16619080909199258, 0.14184403257098854, 0.74528022161092, 0.17157826884048322, 0.41267223931025476, 0.4600710491521264, 0.4620531290723445, 0.20858449734545115, 0.21024398939154065, 0.20631321646553746, 0.14915644173439868, 0.4538322255512174, 0.15290716368485813, 0.20674896510126395, 0.18118903161752664, 0.19821283811219326, 0.1831943367590535, 0.18775861965518192, 0.1898760054363594, 0.1822858819678005, 0.18723277027647955, 0.17993134524083265, 0.0760767711063638, 0.08435111284019692, 0.08255032558286202, 0.07124239167265312, 0.08107596519145077, 0.09439320925249306, 0.08446639689966107, 0.07611884314043216, 0.09953702420206223]}, "mutation_prompt": null}
{"id": "aded3575-7a31-4d01-b28f-a70286cfaa10", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 10)  # Slightly larger population size for diversity\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Narrower adaptive inertia weight range\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.6  # Focused cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Focused social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.15  # Adjusted stochastic scaling factor\n        self.CR = 0.9  # Increased crossover probability for enhanced exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Increased initial velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                if evaluations >= self.budget:  # Ensure not exceeding budget\n                    break\n                \n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]  # More elite members\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                if evaluations >= self.budget:  # Ensure not exceeding budget\n                    break\n                \n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Increased influence of elite partner\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedHybridOptimizer", "description": "A novel adaptive hybrid optimizer utilizing dynamic population management and multi-phase learning to enhance convergence.", "configspace": "", "generation": 28, "fitness": 0.24263781617476235, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "8684829b-b54e-415a-889a-5abbf4b912d0", "metadata": {"aucs": [0.4620148588848342, 0.5903371129523087, 0.5844977539163443, 0.46117836658338773, 0.5537656220000758, 0.5929149014188704, 0.45027543267074766, 0.5981751810475726, 0.5731853139281284, 0.09147119064823184, 0.06500434243257946, 0.1839646925375923, 0.035580610873960694, 0.15455875644330586, 0.11087395183681004, 0.035207071971850024, 0.1643438451274446, 0.14819339681650834, 0.10071116947734193, 0.13209049610139667, 0.17092324789190405, 0.0809069240522029, 0.1011082699574456, 0.10432498307100924, 0.09357205538032576, 0.1205011362392916, 0.09825603255299853, 0.08099454970590181, 0.09367061848384273, 0.11439055648995489, 0.07877173174058771, 0.10323939956633021, 0.13504487097068707, 0.0835164213473768, 0.09598581054828703, 0.08427664611795405, 0.9635893738217056, 0.9629382515380848, 0.9634855182099595, 0.9726124582049077, 0.9629485245274415, 0.9631209259089375, 0.9646424239394862, 0.9604637085536665, 0.964398854845586, 0.23952669678784277, 0.3022932830473506, 0.3054300037959511, 0.22026313222315852, 0.3135902440354835, 0.3169326948657314, 0.23351479174419176, 0.29861518908507434, 0.30644715049412363, 0.4913800525657641, 0.5923559470530146, 0.639628468091032, 0.2805688951291152, 0.5324314553897405, 0.15975169548368717, 0.2652643736320711, 0.4951369346723995, 0.45829151915079647, 0.1356114515401845, 0.16564720630405116, 0.15407154390679711, 0.11281754077428197, 0.11593117306138978, 0.11780124042786355, 0.118109484314596, 0.15396483058635935, 0.13422854497610825, 0.14491029155075907, 0.16740014626993327, 0.20697653176459407, 0.13242943046759315, 0.15217327334988984, 0.16456758378370018, 0.10345080899089154, 0.15841062176078957, 0.18245956826273346, 9.999999999998899e-05, 0.03446491302077537, 9.999999999998899e-05, 9.999999999998899e-05, 0.025068595149665862, 0.017500137651724423, 9.999999999998899e-05, 0.020850712858524245, 0.06586891201727862, 0.05523882372792688, 0.06331979146534072, 0.05500288128145314, 0.016191634340346317, 0.009931933724217967, 0.02100436042344922, 0.05885694605860137, 0.1430967208313063, 0.036726504351083156, 0.0003180429079817637, 0.0308963468324307, 0.02622620535827913, 0.02191870780960925, 0.04341687721299892, 0.03720595474778088, 0.019425809353146528, 0.03502678114673252, 0.06936136440047702, 0.08388352097371476, 0.08442523209227182, 0.07805667398812077, 0.029466904785472092, 0.07227127544060641, 0.051585843160958156, 0.04298656793060507, 0.04830007684557658, 0.04543761337978247, 0.3794449522846355, 0.4346697162165344, 0.43831132680993345, 0.390752773863001, 0.44646830913903646, 0.44300909168984604, 0.41332732028697416, 0.43721386420642117, 0.445676344518942, 0.09877360698225601, 0.11675191693199738, 0.10674632858890432, 0.08145387049177477, 0.09820151397343291, 0.1055586474085699, 0.08617470843865227, 0.08643428431074518, 0.10415023900931974, 0.13378931260829408, 0.13933150867622845, 0.1724537793069485, 0.1587039788870317, 0.14629798373233038, 0.19398681988320077, 0.154154037711566, 0.1466628232217323, 0.13204128210224264, 0.2992938841696947, 0.3133501040590462, 0.33343194312638147, 0.2872551682933674, 0.3119675803626938, 0.3071487162727551, 0.28305568293002203, 0.33271847288144596, 0.33710187222701027, 0.19620753493183296, 0.23929486499143404, 0.23983920791359037, 0.22610843402870218, 0.2369704771596599, 0.25700816266679316, 0.18475808902189406, 0.24038985666613444, 0.2361263132643301, 0.19349731061165099, 0.19363525295417994, 0.18792956152914053, 0.1813019048378255, 0.1942399273501222, 0.2487098771129973, 0.1892887603032649, 0.23285448038456902, 0.19561423692431468, 0.18177154491991598, 0.20416688199908772, 0.22207389917515652, 0.18767149575806552, 0.2031872851077231, 0.22342703410975095, 0.16911424199473002, 0.2200106889056016, 0.22424547602741618, 0.6054420884566518, 0.7125611295194519, 0.7403283536906003, 0.6032754920139024, 0.7237731508740903, 0.1573173680233736, 0.19966034616515216, 0.6924262712568936, 0.7280076134898756, 0.3139598587160637, 0.411372041414131, 0.48308325666482055, 0.3468047087857188, 0.4062564154495195, 0.11147356957213794, 0.41542116816038344, 0.2027357756032847, 0.5444257443707108, 0.18761818383192996, 0.18137101110737663, 0.18195232582400345, 0.19746502680704914, 0.19325278877862162, 0.17923489799805825, 0.19503132174928595, 0.1881752714317082, 0.1947608707367381, 0.07727702807146508, 0.07646575793049193, 0.08389190992858253, 0.07925061025454361, 0.08003449940955165, 0.08860797645098939, 0.07986254304344542, 0.10900060736053852, 0.11074091861222224]}, "mutation_prompt": null}
{"id": "68d523fd-40c3-48c1-af96-b0ddfccf4d3a", "solution": "import numpy as np\n\nclass EnhancedFusionOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 7)  # Adjusted population size\n        self.inertia_weight = 0.2 + np.random.rand() * 0.6  # Wider adaptive inertia weight range\n        self.cognitive_coeff = 0.9 + np.random.rand() * 0.9  # Adjusted cognitive coefficient range\n        self.social_coeff = 0.9 + np.random.rand() * 0.9  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.2  # Adjusted stochastic scaling factor\n        self.CR = 0.7  # Further reduced crossover probability for controlled exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with competitive information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedFusionOptimizer", "description": "Enhanced fusion optimizer leveraging dynamic strategy adaptation and competitive population interactions for superior convergence.", "configspace": "", "generation": 29, "fitness": 0.27826781656457744, "feedback": "The algorithm EnhancedFusionOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "8684829b-b54e-415a-889a-5abbf4b912d0", "metadata": {"aucs": [0.617663579196986, 0.7309531490346148, 0.7060366514733232, 0.6241821322685062, 0.7164994241472109, 0.711117493968095, 0.6233003218176509, 0.7259640086869192, 0.7203745564136486, 0.23147893358162286, 0.385729790063463, 0.37426619203591815, 0.19652431833401518, 0.3769461270654728, 0.36111748062016846, 0.2102443991315437, 0.40040430997753185, 0.3726229983292777, 0.11121756179860043, 0.13798867540784554, 0.12742968021427348, 0.12493531449754447, 0.15768004261451896, 0.10983322043121158, 0.11905704079521329, 0.1503798386028271, 0.16545765038756943, 0.09632395303050056, 0.12060146092043467, 0.11659712407039258, 0.09241650694564374, 0.12344303210371488, 0.09278113162784374, 0.11292796725824605, 0.1238744319382249, 0.14386262198881372, 0.9647514601564577, 0.9507369686849891, 0.9634800888328515, 0.9643621583877078, 0.9616468964462461, 0.9640964985850498, 0.9680001742677989, 0.9515478237949404, 0.9637414848894965, 0.303253225178454, 0.44363543761453494, 0.48554223975974997, 0.26842056487428967, 0.4681722125997747, 0.4592501370298272, 0.3139305512972723, 0.45507287806278507, 0.44050329875797056, 0.21481604637612461, 0.736707427173066, 0.2197731968915838, 0.15761042454223828, 0.2103259859872032, 0.7081989410824672, 0.585913645391703, 0.6790842335622158, 0.22751754306195815, 0.16214307524132487, 0.1755067110957671, 0.20895834763654453, 0.11286011628266623, 0.18078843626727392, 0.12302189537444519, 0.1273798108880574, 0.1731599411101804, 0.10332108049331434, 0.08260340381194398, 0.18244581291866702, 0.12178960742608036, 0.1666460755443877, 0.2241083587708902, 0.12326005262278794, 0.15528813828240895, 0.21995703322739812, 0.26260907331573335, 0.02939586555937257, 0.002576904754485798, 0.014246642746620797, 0.019143159247377972, 9.999999999998899e-05, 0.03678016555110808, 0.034372680525072585, 0.0839476679804908, 0.08137392111826591, 0.09007043727997466, 0.0878581817069859, 0.0649811345902861, 0.034450782572294725, 0.05943494103325608, 0.06192885973657436, 0.05851840950996079, 0.12224384588921744, 0.04316874748307509, 0.02704534486728627, 0.047747857992388676, 0.03610681786194858, 0.045558900176456696, 0.05992011276766884, 0.05680709074463719, 0.0751977665276925, 0.0739845039341932, 0.05162902574938233, 0.1291975502295052, 0.08171966071820824, 0.22540823468511206, 0.1353807050443505, 0.2152585293367968, 0.14524279230875714, 0.11178466470742221, 0.07781073151341877, 0.20867193614572355, 0.4452728460449292, 0.5368988689012537, 0.5301557738178604, 0.46900310860925387, 0.5130053355904756, 0.5316809346189394, 0.460816647401152, 0.489131386708467, 0.5686158186721293, 0.08877966995329556, 0.11140553220875937, 0.07501612407235048, 0.09162101415630963, 0.11605634709508772, 0.09841282592303413, 0.09925101524064162, 0.11852632769793126, 0.10729584422017435, 0.18098185219930107, 0.18001818945025516, 0.3964451089667016, 0.13125128322895785, 0.16118159189272407, 0.4274955048928567, 0.14122792382933336, 0.18274242283820064, 0.4272759471321439, 0.3248098569707982, 0.43864380270903736, 0.4120767616456946, 0.3166117089841277, 0.4004069390161834, 0.39152429573678094, 0.33619726598869637, 0.42062466022334644, 0.42910545335124584, 0.19569119521126188, 0.25363930362044107, 0.21584536472442895, 0.265289080456677, 0.33059157191693633, 0.2791632076899423, 0.2068558448757215, 0.22218208734792866, 0.2551150392701601, 0.20917132377564884, 0.1968399202369051, 0.2052691437978189, 0.1897846786635936, 0.23085431756227637, 0.2144541394607169, 0.19257578422317556, 0.2168078129067872, 0.23637848745029122, 0.21360506436697468, 0.228967862626006, 0.1912264539441889, 0.19641281806058153, 0.20491420498100932, 0.19230343056048682, 0.19819172857201162, 0.20598719172815783, 0.17687356004474353, 0.7577751002150712, 0.7977368276469706, 0.8384201369718528, 0.20255807179243146, 0.19515335372912823, 0.15591257358770128, 0.6921271676694686, 0.1683330089532301, 0.1692206017997001, 0.5098168311186984, 0.5743589134651079, 0.6487777108699464, 0.16526914276635363, 0.16647228140700832, 0.16755509620928055, 0.5823023814276376, 0.6186056205551047, 0.12692320995252648, 0.17939205967269423, 0.18046212091763714, 0.19322176610698316, 0.21171331139691096, 0.20299593023596285, 0.18104411446019608, 0.18901710678134676, 0.18126170922301676, 0.20133425266557925, 0.07542928772361213, 0.07976957454176536, 0.07657368636937156, 0.07846970085531924, 0.08760890879440886, 0.08677111977349528, 0.09460217934087145, 0.10811150378870682, 0.10895920012694349]}, "mutation_prompt": null}
{"id": "39b35395-2348-460a-9a83-4ac3e662a064", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, budget // 10)  # Adjusted population size\n        self.inertia_weight = 0.3 + np.random.rand() * 0.6  # Adaptive inertia weight with a broader range\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.7  # Adjusted cognitive coefficient range\n        self.social_coeff = 1.1 + np.random.rand() * 0.7  # Adjusted social coefficient range\n        self.F = 0.7 + np.random.rand() * 0.1  # Increased stochastic scaling factor\n        self.CR = 0.9  # Increased crossover probability for aggressive exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n\n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer leveraging dynamic constraint handling and adaptive information sharing for robust performance.", "configspace": "", "generation": 30, "fitness": 0.26370595827322996, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "8684829b-b54e-415a-889a-5abbf4b912d0", "metadata": {"aucs": [0.5634962429561279, 0.7276809615388447, 0.7042794026318551, 0.5550999952556928, 0.7050387210601072, 0.7034903826442487, 0.5709898031652595, 0.7313482469989809, 0.7266433308785081, 0.16419673061654483, 0.3623709038522568, 0.319281595279421, 0.19756376294045508, 0.4005076300602759, 9.999999999998899e-05, 0.20945516795521368, 0.4150195887420971, 0.36775968414042504, 0.10356644662336689, 0.12689464621372593, 0.1290524428607549, 0.10712833018156653, 0.15667955740498551, 0.11096321994332703, 0.09984808987515914, 0.14523952849174493, 0.13780873975495922, 0.09586884916154359, 0.14661188719706975, 0.11458348404019703, 0.08700448782494019, 0.10534950736484372, 0.1052496320993681, 0.08972127206377645, 0.10231145448438106, 0.103661688884785, 0.9739863225791585, 0.9727356171641696, 0.9741906423155596, 0.9741093657515822, 0.9709479531705006, 0.9738971535744179, 0.9725795537410008, 0.9664448611742653, 0.9723678035136842, 0.24192577026967343, 0.4380967310066042, 0.45272716343969, 0.28646451872402967, 0.36773475972861913, 0.4289326619460927, 0.2955605554730911, 0.4161196266643442, 0.40215251460763257, 0.2841130374930151, 0.32267682890894, 0.6457780435307707, 0.20431044380079688, 0.27015309004281385, 0.2583721750316529, 0.4035787541091944, 0.6741889180539314, 0.2307258593411945, 0.15577675396916946, 0.18628911403760906, 0.18840504973619232, 0.15200248294325824, 0.1683965023854771, 0.1347245274754939, 0.140549415308021, 0.19357689039976744, 0.1723858275755682, 0.11576564675583145, 0.1843852334221583, 0.21394863096247663, 0.1595436577591849, 0.20399981502657583, 0.19971730462536164, 0.15663148917407066, 0.21875142925549274, 0.2087612319108505, 9.999999999998899e-05, 0.0025998692103694765, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004839432245765107, 0.0493205687491578, 0.03655646006457769, 0.07737159957882467, 0.061974321642410124, 0.11082068922710242, 0.033005668179647674, 0.03727622410024212, 0.053805415756352115, 0.09113348179072256, 0.06358922227900743, 0.045710717943084456, 0.028934801166372592, 0.2189109622791362, 0.035874466798242244, 0.04606915471664452, 0.11488773494751181, 0.1088206098521095, 0.04677868404777019, 0.05150158581388209, 0.0677040156664741, 0.09486426168843232, 0.1991684338332086, 0.1278240699542431, 0.10595305899312257, 0.09446996443919375, 0.09964492685590431, 0.05216586060381345, 0.09812977389987987, 0.04463856110778108, 0.40525640463731194, 0.47316497526188606, 0.48779172004444016, 0.4093779664368745, 0.5386085903816501, 0.5177968513828914, 0.42995301204215663, 0.5138394798176265, 0.5068345524787219, 0.0902048949021893, 0.09872891604840917, 0.08752913376139604, 0.09936405925969738, 0.11546218708220635, 0.1251649795254014, 0.0930209261663616, 0.09921842400810033, 0.125768677575264, 0.12483913056530149, 0.12656586531021552, 0.14064944190354434, 0.1771967732852292, 0.14266189942130658, 0.19829410402600078, 0.12205076809184812, 0.14168512855420157, 0.13663840820194784, 0.31261647568125817, 0.38221085379095576, 0.268005133456092, 0.3054144749334792, 0.4075349761318554, 0.4152411651381115, 0.304732214646681, 0.41201459347149416, 0.4204310679222163, 0.24795149001901873, 0.3127045255136529, 0.1720381054701533, 0.16767420696510615, 0.18772517222168694, 0.25849367625253605, 0.19289013339060768, 0.18892176589225596, 0.29359246398975614, 0.18150006830824672, 0.1728605595141044, 0.18848999801847877, 0.21443765931586056, 0.21052494447378145, 0.19309878505301348, 0.20212780549343623, 0.20602736792080556, 0.22614417454578106, 0.19981130781099343, 0.18273164591108582, 0.40594626915125964, 0.18596052164499155, 0.18909979270920307, 0.3918069507142806, 0.19135920010672125, 0.41419987217751975, 0.20867140475291002, 0.7362825209627796, 0.8493928890692356, 0.8466785095369732, 0.1608567039777976, 0.19530433514391488, 0.8082236107386155, 0.12678670040793205, 0.14527267412785128, 0.14528062800723496, 0.49914478466789325, 0.5693643877258114, 0.5358291287924086, 0.20113722441346837, 0.21058536811503392, 0.20544864153375209, 0.15139355570165658, 0.6880840209960619, 0.1550574302445884, 0.20546836144994074, 0.18086483290547795, 0.20927499888350065, 0.18495350620972473, 0.18896393245101284, 0.17707298108305736, 0.18202740204225654, 0.19359176653636445, 0.18371978874174644, 0.07237222310676139, 0.09401689112238487, 0.07423086463666373, 0.07599708600992994, 0.0801823078483983, 0.08577043432265996, 0.08551052619285149, 0.08024994431337962, 0.10824619182020057]}, "mutation_prompt": null}
{"id": "2b28c8c1-231f-4af4-bd44-6223db46654c", "solution": "import numpy as np\n\nclass EnhancedRefinedOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(100, budget // 6)  # Increased population size for diversity\n        self.inertia_weight = 0.2 + np.random.rand() * 0.6  # Broader adaptive inertia weight range\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.7  # Modified cognitive coefficient range\n        self.social_coeff = 0.9 + np.random.rand() * 0.9  # Broader social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.2  # Altered stochastic scaling factor range\n        self.CR = 0.7  # Further reduced crossover probability to focus on exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Wider initial velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.3 * r3 * (elite_partner - positions[i]))  # Adjusted elite influence weight\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedRefinedOptimizer", "description": "EnhancedRefinedOptimizer: Further refined hybrid strategy incorporating adaptive parameters and diverse population techniques for superior optimization.", "configspace": "", "generation": 31, "fitness": 0.2762695016679982, "feedback": "The algorithm EnhancedRefinedOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "8684829b-b54e-415a-889a-5abbf4b912d0", "metadata": {"aucs": [0.6244135455496109, 0.7081305153735586, 0.6997174820001042, 0.6547479873289314, 0.7285362262904732, 0.7076062298585175, 0.6066671953067188, 0.7430782563651797, 0.7291720822304344, 0.1906462814284018, 0.37693184702776483, 0.28847016394442626, 0.2203197902869326, 0.37551121602628545, 0.23578062643505282, 0.21701503725509208, 0.379483920410147, 0.3954036008167331, 0.1095036477256437, 0.1419650013726217, 0.13273788129072694, 0.1322977031222783, 0.2605377985447498, 0.11116721945178176, 0.13635728840982286, 0.14974605994899615, 0.1487498922089321, 0.10337783762639174, 0.11281958775639178, 0.09104705272066638, 0.10633408937142541, 0.11135163927939906, 0.13579810220639288, 0.09107621102968311, 0.11827181913128237, 0.12936044437003058, 0.9641595717705692, 0.9527178896708307, 0.9630909731384906, 0.964102198167056, 0.9614353831831091, 0.9634150307034006, 0.967873570857398, 0.9609773302429742, 0.9638192841509291, 0.3078912600615519, 0.453518692014966, 0.42679804735474336, 0.3029220142325526, 0.42191667979629743, 0.4230425344051165, 0.28671460175756114, 0.4389675905924846, 0.40221199050725176, 0.355282848399022, 0.6699018214703821, 0.16916640040082565, 0.41910311986304527, 0.6384572182291708, 0.15744434694673815, 0.30720522133361383, 0.5373294269684845, 0.5741603472275074, 0.15203682267122964, 0.18170406968247432, 0.1932446038382728, 0.11880689468378713, 0.17724802809941864, 0.17127172641968025, 0.15976847954342122, 0.1920907227584545, 0.18119682817902383, 0.15223764441850984, 0.20371612935634553, 0.2608266141767167, 0.14201574092451097, 0.17411665218200356, 0.20799472414878928, 0.1628593382700646, 0.12235069634280538, 0.2099986367709743, 9.999999999998899e-05, 0.05303521449464965, 0.0007326944165441107, 9.999999999998899e-05, 0.02057258134863127, 0.0002786844375128883, 0.0012885554872859029, 0.045244143135319215, 0.15495024134377977, 0.10781167955392157, 0.10187968868393893, 0.05482690601306406, 0.029214626699429758, 0.06082300330739088, 0.03729117815006244, 0.055623862473729635, 0.06279993276191342, 0.0736413343857224, 0.028150818211271744, 0.09186452435963588, 0.034943476924781725, 0.04404034984380634, 0.08111436230796776, 0.05460173596817708, 0.04964431753722642, 0.1703154802840814, 0.053230042257162324, 0.05787697666480818, 0.11795812394642302, 0.09991263199969802, 0.17039385941500718, 0.1852249577480991, 0.04228737319672471, 0.06813802058082297, 0.09035483678437872, 0.16771850270117505, 0.43774435482481444, 0.5085542187478548, 0.4999878638498201, 0.4490000068537926, 0.5201893031841991, 0.5152166199623549, 0.46784135584815345, 0.5030068086438132, 0.5010557310076076, 0.17830928960026504, 0.3779811586100492, 0.13505126152634728, 0.09946548928983379, 0.149759680796961, 0.14469718502843842, 0.10119097084240603, 0.11777713651082156, 0.12052027608153548, 0.14775133135669372, 0.13812452480411308, 0.22391701731650016, 0.2334077992173469, 0.18880629892783596, 0.25754787745908947, 0.20326876192780263, 0.1752095343572755, 0.18477853998132943, 0.28018062645517283, 0.3345024194061702, 0.4001562935960513, 0.2866094312006634, 0.33802225973736666, 0.36924027623975286, 0.3259476234137707, 0.4065584997858709, 0.40412093720002895, 0.22629872069768675, 0.22930365194437963, 0.18697912402143668, 0.22043187883619697, 0.28041340935796044, 0.3062602396670392, 0.16948352995240656, 0.2561401358700188, 0.3314865597722433, 0.18513803719254607, 0.2035936136426827, 0.1928793629506237, 0.18051570142674667, 0.22813246462344683, 0.22849054568855398, 0.1941281565339006, 0.2495338554245975, 0.19552966841266273, 0.19445841546034304, 0.18616333487588477, 0.20292012709037444, 0.19094336662198863, 0.19293597015450037, 0.21180314615061047, 0.21895132122325356, 0.21625510116951685, 0.21366852208215792, 0.7083446372444127, 0.8155573516320191, 0.837667460062246, 0.1559391029319922, 0.1463410793452078, 0.15773175781067217, 0.17078628062007573, 0.7784284652081993, 0.1695564870080576, 0.3223119890982016, 0.6111746617588671, 0.6274085929587341, 0.1657288456972028, 0.16782488765885006, 0.16757850081754588, 0.4591754479598482, 0.6058195002744484, 0.7273801255519173, 0.19438454639380542, 0.18216974240176298, 0.19879681279486672, 0.18106865827754093, 0.1785046551145093, 0.18001587144255937, 0.19635309119007793, 0.1762984366670104, 0.17691637894108103, 0.08271163505905754, 0.09075517653912979, 0.084383819571208, 0.09129505139032823, 0.08258978386216809, 0.08175486412993138, 0.10114195704407125, 0.09915714665562159, 0.09359709190044874]}, "mutation_prompt": null}
{"id": "9d509cf9-d4f4-49f2-8ee9-d00270930062", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 8)  # Adjusted population size\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Slightly reduced range for balance\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.7  # Broader cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Slightly expanded social coefficient range\n        self.F = 0.7 + np.random.rand() * 0.1  # Increased stochastic scaling factor\n        self.CR = 0.85  # Slightly increased crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer incorporating randomized neighborhood exploration and selective elitism for robust optimization performance.", "configspace": "", "generation": 32, "fitness": 0.2639777519617729, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "8684829b-b54e-415a-889a-5abbf4b912d0", "metadata": {"aucs": [0.5486428206277194, 0.6915430312975113, 0.6815924311843212, 0.5815180271574798, 0.7033457673331054, 0.6713722873058601, 0.5580545432113897, 0.6941332106970803, 0.7001982633815819, 0.13667906938093788, 0.3364211278397513, 0.2603316730500663, 0.10936113852109486, 0.3149256611206461, 0.2816344011448415, 0.21015266346955752, 0.3514318843120906, 0.30447097942992973, 0.09413209587594906, 0.2229929404877511, 0.1476620280252009, 0.09327430675528192, 0.10926168884956444, 0.1309571606726302, 0.10146986925499712, 0.11317754822311832, 0.12296623007230845, 0.08989817384237664, 0.09857791980818509, 0.12367784936037984, 0.0922287812533088, 0.10734659246017708, 0.11480728477060875, 0.10817234578393076, 0.10765935628551526, 0.1177843282805403, 0.9715159081359168, 0.9696600010072685, 0.9700774150610183, 0.9707735723197805, 0.9679115655878792, 0.9710222314811554, 0.969403251082387, 0.9679796350252933, 0.9693262595022754, 0.27183977525020164, 0.402659423173657, 0.39281437852316525, 0.25240519806127293, 0.3837203522484628, 0.3435156571228891, 0.28358088883282917, 0.3863113277572071, 0.36737993955159176, 0.20390488546637442, 0.4869670570154755, 0.6495447405959837, 0.20377800172685234, 0.2531541849014687, 0.20173555243220176, 0.29688981868646036, 0.38798952408843457, 0.11532063325226549, 0.1429251286681782, 0.17096625661847542, 0.1695078634738948, 0.11758999384173252, 0.16881249352506167, 0.10262248829933174, 0.16892827005470645, 0.12068336527128254, 0.18792830514683567, 0.1422015224215385, 0.18358043431543625, 0.20865376809002678, 0.14868498931277085, 0.18644389399775285, 0.1971729304960178, 0.1476821616262558, 0.18925670125451322, 0.2025297864204042, 9.999999999998899e-05, 0.002594439210301225, 0.04006650177553017, 9.999999999998899e-05, 0.03932539207833974, 9.999999999998899e-05, 0.03466483682548804, 0.06714361367722521, 0.05109837036261322, 0.049928951365463714, 0.08295585555579421, 0.1270298611612969, 0.014212788680112887, 0.05608580149379938, 0.039810941764340746, 0.0364769056113502, 0.03447220792880834, 0.030184596970426858, 0.024658659286341922, 0.04165237434910718, 0.036355248529757356, 0.025916688425136836, 0.05657818715570251, 0.06575251623338663, 0.037646767642349865, 0.16876368920771057, 0.1306332082115157, 0.09855188028774098, 0.10001466708165185, 0.07207319624579434, 0.11602123222381633, 0.10720844609072477, 0.08765045537023575, 0.04492874906198263, 0.12584117794130012, 0.13778010558673703, 0.4160268319317535, 0.5133293358806861, 0.48954453806548404, 0.42546884515885774, 0.4682873714084239, 0.49343658062409324, 0.41841261637378246, 0.4975218090506731, 0.5064064763864178, 0.08087819968367005, 0.10068139457913727, 0.12251103048595757, 0.07966091973906475, 0.1320986428021368, 0.10149590012107379, 0.10528387515684112, 0.1347438062900368, 0.12740032643854615, 0.17836707238125094, 0.18704051356084728, 0.25878176096701466, 0.14215047105443024, 0.14217418923704062, 0.19247388617398897, 0.1593979035459825, 0.16969982898938174, 0.21390250491380824, 0.2955658923236256, 0.3600012882592928, 0.3714914472208991, 0.297937349462045, 0.2660512404223646, 0.26757084824781197, 0.31353304574846785, 0.3861739055786917, 0.39354606036201056, 0.2254552034224898, 0.2021881694688138, 0.24396685910015803, 0.18176091010100892, 0.3157676201950055, 0.2548417679583592, 0.20468331965760822, 0.21424798317629346, 0.1904746321260974, 0.2011503519173592, 0.22446805001534953, 0.19594835733102767, 0.1803105444343186, 0.2021471149522478, 0.22645735355108587, 0.19950645617322582, 0.23274733889085464, 0.19947187175648173, 0.1762138138220849, 0.4653629567544103, 0.40579678202810743, 0.1801500419707741, 0.2196507584284444, 0.2240435097683754, 0.2185252662549403, 0.2504231410024548, 0.18966572280710692, 0.7408211933530207, 0.7894332411323534, 0.8034620527185092, 0.6849928550244548, 0.7805761090936068, 0.7909099708153263, 0.15628809440947444, 0.7040407581937417, 0.15909278382846137, 0.3025338197940415, 0.47767762787872325, 0.5463941067514304, 0.44080279272970857, 0.20391221696217632, 0.20724107766914324, 0.44424348617978615, 0.1522150799269235, 0.15172709050677935, 0.18528477229381668, 0.17233182545541148, 0.19609271898220682, 0.1896882957257906, 0.19146825719665406, 0.1884646329150872, 0.19304021037551566, 0.19089206212144316, 0.17730192746963225, 0.07889877672805046, 0.0871318917170536, 0.08184952816930213, 0.07557553565810027, 0.08264445564990042, 0.09021274276632651, 0.08987980511180682, 0.09938681991543985, 0.09462687819101634]}, "mutation_prompt": null}
{"id": "729e5e89-c193-478e-9e8a-6de2b2000b10", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, budget // 10)  # Adjusted population size for more variety\n        self.inertia_weight = 0.2 + np.random.rand() * 0.6  # Modified inertia weight range\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Adjusted cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.15  # Adjusted stochastic scaling factor\n        self.CR = 0.85  # Slightly increased crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizer", "description": "A stochastic hybrid optimizer blending adaptive differential mutation with dynamic particle collaboration for efficient optimization.", "configspace": "", "generation": 33, "fitness": 0.3148225220544693, "feedback": "The algorithm StochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "8684829b-b54e-415a-889a-5abbf4b912d0", "metadata": {"aucs": [0.6961053628881055, 0.8023255233112209, 0.783859436735587, 0.7360141482996214, 0.7895890991134221, 0.7841736260310602, 0.7063968544714923, 0.7957652292476602, 0.7716265351966247, 9.999999999998899e-05, 0.5278066488831282, 0.5367082011605997, 0.36760047645477056, 0.5583794212042263, 0.5274369271674175, 0.42513803563625996, 0.4283914514943826, 0.5791529805568283, 0.14478268343264722, 0.1477487363806831, 0.16385273756496466, 0.12328992887557122, 0.4562114837018505, 0.16607414257160724, 0.13930783684750336, 0.13313514170624585, 0.1197357498798649, 0.12284550355199075, 0.12114358129377123, 0.12746799212413384, 0.11310478673365942, 0.12974616400039396, 0.1124527522544777, 0.12249117884180083, 0.11712564996715302, 0.11445929137171784, 0.9742173834130397, 0.9726524447279982, 0.9750801775347264, 0.9768954081968139, 0.9737871566188938, 0.9738025797663392, 0.9703235832814603, 0.9728167289368196, 0.9725948115784776, 0.4194913053565976, 0.5761479010817736, 0.6245250568437808, 0.37940177431579536, 0.5954964085562584, 0.5712242557621098, 0.346323844927669, 0.5050339066876652, 0.253628156976208, 0.6745680822890692, 0.6124192040516798, 0.8306358097542641, 0.2045862635833512, 0.7659493278441492, 0.8249441284578066, 0.35271388373563195, 0.7582355210521674, 0.37021919800655445, 0.16884027683525915, 0.2308351127201813, 0.12747104067194992, 0.16837149165120702, 0.21858997400818414, 0.1249101375388505, 0.23982441419239453, 0.21841425072696063, 0.2520260574784684, 0.19968348616631915, 0.30383081479575813, 0.2390166664477359, 0.1796340187417591, 0.24260606508527016, 0.25122842647428734, 0.19846145912975832, 0.25882160187780223, 0.0967655585401258, 9.999999999998899e-05, 0.0029336407939339892, 0.004327991234687967, 9.999999999998899e-05, 9.999999999998899e-05, 0.024313897843425858, 0.07816684337068314, 0.08210096083718077, 0.1494687192774511, 0.043221903203876866, 0.05885236714012321, 0.043227485397972276, 0.11388722837068255, 0.10488040487000727, 0.07062608774102974, 0.1062287814526448, 0.1363291650837185, 0.12889776442240253, 0.05199763884512665, 0.03799419877528687, 0.08071678238071323, 0.08726540276392303, 0.06734458093063855, 0.08844491033078417, 0.14246046652096978, 0.10506296509776825, 0.08278218689341343, 0.10133246201314561, 0.24735631439872618, 0.11262825099992457, 0.15363948760754798, 0.08077735921245621, 0.16828865280975203, 0.04594356856157722, 0.07774792200886715, 0.048072543152954283, 0.4794335217388309, 0.5057910077677841, 0.5563439112541908, 0.49840831669499575, 0.5260916149512439, 0.529553108849454, 0.48978274126766175, 0.5510842383320731, 0.5626743224756172, 0.09453271529199336, 0.10400120238707311, 0.13149091602189944, 0.15652510286059174, 0.14810223306188763, 0.1417442307728214, 0.14691962686278126, 0.15713565081967773, 0.16958985679587912, 0.1462997086471889, 0.3900151303527545, 0.18945855362717312, 0.33115351970865003, 0.19554949333963145, 0.17885333496533462, 0.19355674558331248, 0.2300913435456654, 0.1909978583228108, 0.36929950046905224, 0.4717701967020296, 0.45829985841816934, 0.3206878879254398, 0.4911938118694742, 0.3191493384513049, 0.2726905945207897, 0.526500052207719, 0.4292670792972738, 0.1715737546386914, 0.22299955566966456, 0.1908749768341298, 0.2850200262811621, 0.27144948007754266, 0.2545933043594255, 0.21376222688208435, 0.3192259237562416, 0.18911870102449624, 0.20089594082059525, 0.21192250331219398, 0.21532041574423888, 0.2085026492804971, 0.25751772967914144, 0.23577586930381889, 0.2237191790095855, 0.2570824646355654, 0.2274819784175265, 0.20955059607071325, 0.20348246565501127, 0.18739151967183454, 0.48170437213617223, 0.2128158157347515, 0.17874560455558497, 0.3027608025826076, 0.20340071797758763, 0.19270261563860092, 0.8253439363159151, 0.863958227392987, 0.8849046116370003, 0.13097344694500113, 0.7836761366581604, 0.7972990106904596, 0.20331430286253094, 0.11416900038261757, 0.11422497275454757, 0.47799114884343985, 0.7268833417679575, 0.7733057679555422, 0.2097459921063064, 0.20977785015304184, 0.21073434329170793, 0.620862633399299, 0.7654426142008632, 0.15395307580973117, 0.17714626324988858, 0.18689140435757212, 0.179852614845869, 0.1804595340275269, 0.18768957090244154, 0.18090141191468412, 0.17904625878327984, 0.18256584163351985, 0.18781417070865314, 0.09670782957858737, 0.10151281422711023, 0.0866873025719127, 0.10814961303104209, 0.08206371464209083, 0.12853287381588108, 0.08661028981892627, 0.1339483205405333, 0.11888561632384609]}, "mutation_prompt": null}
{"id": "1c24b7f5-36e9-4d9e-aa45-ff2a4666f299", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(75, budget // 10)  # Slightly increased population size\n        self.inertia_weight = 0.3 + np.random.rand() * 0.5  # Narrowed inertia weight range\n        self.cognitive_coeff = 0.9 + np.random.rand() * 0.8  # Adjusted cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.8  # Adjusted social coefficient range\n        self.F = 0.45 + np.random.rand() * 0.2  # Adjusted stochastic scaling factor\n        self.CR = 0.9  # Increased crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with enhanced elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.35 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "A stochastic hybrid optimizer integrating adaptive differential mutation with dynamic particle collaboration and enhanced elite sharing for robust optimization.", "configspace": "", "generation": 34, "fitness": 0.28929954985363165, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "729e5e89-c193-478e-9e8a-6de2b2000b10", "metadata": {"aucs": [0.6440583058569633, 0.7636858324836311, 0.7489521635689911, 0.6849247224759671, 0.758721237552122, 0.7472487680512341, 0.6542531153453068, 0.7632981899018482, 0.7631327818001721, 0.2944644815143873, 0.4507802769639827, 0.4128324866896268, 0.05367287074589966, 0.4480064082695012, 0.2511241125314728, 0.276640280542253, 0.4623163898356968, 0.5166454568719456, 0.13300604552898043, 0.2686599024424795, 0.14261409695191996, 0.12034792859810528, 0.1617813967582331, 0.16322694323894615, 0.11722566761544295, 0.1504012721176745, 0.11721842206189359, 0.09753363770656176, 0.12003625268616835, 0.1311481410218679, 0.11628470141726066, 0.11405076214633159, 0.12059711386432681, 0.11341902458874442, 0.12896564282722933, 0.1300648540163868, 0.9721531364680278, 0.9672438715016709, 0.9723246692845599, 0.9738892334736611, 0.9723122156133102, 0.9734697824712603, 0.9746041443771364, 0.9712514324817841, 0.9738587544525897, 0.3747721078835502, 0.5159667888799422, 0.5338844338663378, 0.37768838864635057, 0.533140300001979, 0.5399562823826882, 0.3759436397341176, 0.46749823811959046, 0.5148927675084253, 0.33198747991360267, 0.7089555284273723, 0.6813111005825202, 0.26307192855002226, 0.2068853961646332, 0.19108185251329746, 0.238665050434949, 0.744335154837094, 0.17593054002988795, 0.174296574389462, 0.20058997551408375, 0.23469773912398872, 0.17786000738005492, 0.21428630281473982, 0.21679985721794282, 0.2653028921468452, 0.23755217331414347, 0.2299361249614178, 0.12292560375896722, 0.20621993723315446, 0.23717623988545178, 0.1713728178970827, 0.21412426039906907, 0.26692061113595356, 0.20634397899120693, 0.22636682773677608, 0.2484247829189763, 0.03689856923525858, 0.028462445454968344, 0.05125834220342107, 9.999999999998899e-05, 0.007618770423515886, 0.008496489291427323, 0.0021212397225895963, 0.05801974682794242, 0.05064402646276345, 0.05874079387557363, 0.17361961914461221, 0.03884876013746541, 0.0992642034898743, 0.0860501365094356, 0.015853289258841108, 0.02364473256859312, 0.12352218361706291, 0.048112410721744325, 0.033150126401480295, 0.07535710830682563, 0.16251539306871987, 0.0552968123155515, 0.07041670117594134, 0.08588778615317116, 0.06331945908571956, 0.06723631617446624, 0.07408313031882607, 0.04563423481246409, 0.14541644443010482, 0.1626998446484602, 0.03403669799035891, 0.1458615800548505, 0.03616917149146559, 0.04605956174927195, 0.17037944577840025, 0.05392054776507926, 0.4580268341802809, 0.5008111355823606, 0.5450596999050761, 0.4581719407184408, 0.5215070888301558, 0.5451295800077567, 0.48447066654455817, 0.5107841945237637, 0.536167930752566, 0.12402885882358183, 0.16488618133307442, 0.08758237791563628, 0.11344408118560712, 0.11734492745120118, 0.1201342707414591, 0.10240668521538832, 0.12993930056466874, 0.09166017840107399, 0.2763392695495981, 0.2121803509196829, 0.23793663759306705, 0.20289276395112077, 0.22870398569232497, 0.293705501841496, 0.14942644130991156, 0.17818354665384284, 0.21234279750581753, 0.26635013928261564, 0.44663802494259586, 0.4621093699039124, 0.28488020044237206, 0.3561280692315689, 0.40420668990527897, 0.3579797692532224, 0.45504267649748753, 0.45120202662855835, 0.18931605723749434, 0.22870192485947927, 0.2501652771966636, 0.26309501118328293, 0.2538126342155478, 0.25000968678916824, 0.2518552679269713, 0.2883969023614996, 0.16264405487436817, 0.20683371144165563, 0.20390189963952288, 0.21097704422497254, 0.2248507965928297, 0.19664880870402235, 0.20448260869249546, 0.1975386968255145, 0.20306495052707307, 0.2446873523815669, 0.1887229472285663, 0.21060902750974442, 0.22357763551909138, 0.21266670315480307, 0.20178354707174817, 0.19756112185195385, 0.18527201210435573, 0.19838352946872362, 0.1885799953253291, 0.8223693089904203, 0.8791094467257882, 0.8609767026100422, 0.7224204945030359, 0.13934110510057107, 0.19564905013005296, 0.11402432964951537, 0.14705861524142105, 0.1423866386177013, 0.6044761170819949, 0.6980642039352133, 0.6980894619396028, 0.2030586399392661, 0.20899572975319147, 0.2070700632489727, 0.5189477510884376, 0.7955062179411213, 0.1525116530336108, 0.1927986158604158, 0.17857145068891533, 0.17931791636666916, 0.19005658840623596, 0.18287205029269193, 0.17737547380715968, 0.18000665460408505, 0.19743332669789626, 0.1907320015306342, 0.08265405851626206, 0.08730576399370371, 0.12056981901273156, 0.08666968786635532, 0.07982329169001312, 0.08737375022430738, 0.08009156073593293, 0.099806820120112, 0.10091827707531087]}, "mutation_prompt": null}
{"id": "b684daba-7214-44a9-8321-695d1bd8d86f", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, budget // 10)\n        self.inertia_weight = 0.2 + np.random.rand() * 0.7  # Broadened inertia weight range\n        self.cognitive_coeff = 0.9 + np.random.rand() * 0.8  # Slightly shifted cognitive coefficient range\n        self.social_coeff = 1.1 + np.random.rand() * 0.8  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.2  # Broadened stochastic scaling factor\n        self.CR = 0.8  # Reduced crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.3 * r3 * (elite_partner - positions[i]))  # Adjusted contribution from elite partner\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer employing adaptive differential evolution with elite-focused swarm dynamics for improved convergence efficiency.", "configspace": "", "generation": 35, "fitness": 0.2867240080910725, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "729e5e89-c193-478e-9e8a-6de2b2000b10", "metadata": {"aucs": [0.6500972341159904, 0.7881253175224766, 0.7556752946716782, 0.6460050006634441, 0.7681977239133216, 0.7720959069778619, 0.6444937146162316, 0.7933766324596674, 0.7677438763477117, 9.999999999998899e-05, 0.5351053897342457, 0.4392206211854984, 0.27156298242254917, 0.5294143142245442, 0.4816022853860521, 0.3059372525330124, 0.5418037227044202, 0.0478493129385803, 0.1242583345058551, 0.12337839885080937, 0.11175779950212272, 0.1575355208605519, 0.1367560503903693, 0.10979030216669294, 0.11576092598776155, 0.12331850468804806, 0.1450516542217689, 0.12212617536390358, 0.10096673271554135, 0.12349487632765632, 0.10518519877043564, 0.12479497908729287, 0.0795728679201766, 0.10532595042987036, 0.10231680359042727, 0.11398307978784084, 0.9733014155982422, 0.9723554138032254, 0.9731108496229617, 0.982400509123221, 0.9708884735418649, 0.9738965837977704, 0.9739213873784204, 0.9689712983283014, 0.9688712206601706, 0.37379525857420814, 0.5135168008063252, 0.560739486481441, 0.2326566164226087, 0.5287437724032564, 0.5603934491935645, 0.3550295910628599, 0.549933926379415, 0.5248312275370615, 0.47265882509369916, 0.7214637891690658, 0.7711832018675333, 0.2601528812620463, 0.21163431765111185, 0.16018956369088333, 0.6716171266818453, 0.7165507391055074, 0.23256082250149634, 0.16800106911340917, 0.21592501589894275, 0.2212078213957428, 0.12131433155429072, 0.12467956480955711, 0.12672570426001695, 0.166608154255537, 0.2385887981785315, 0.21343450554589405, 0.11349218193611088, 0.20458956495544178, 0.12503571888438159, 0.19280975927108113, 0.22831777540388754, 0.2473757095712783, 0.19002676254724926, 0.22116788126785225, 0.1876190572119233, 0.00683667668693233, 0.0006581358699426776, 0.00047331310497633616, 9.999999999998899e-05, 0.0069611136412286445, 0.014541796345569846, 0.07634168223772175, 0.1546307777313829, 0.05339474128225996, 0.03871284071688352, 0.11422258731175683, 0.08521935834311445, 0.03993614006748636, 0.022702747373582688, 0.013764155005852485, 0.045966035519873216, 0.095640284569673, 0.07477604732246967, 9.999999999998899e-05, 0.04100035757556175, 0.02612813911815648, 0.10208085942833423, 0.06474597218958555, 0.14862873460199522, 0.045866163738929044, 0.08258343963921011, 0.09119124778348942, 0.08008699206649339, 0.07874425646711403, 0.0929141015166649, 0.1950308002319432, 0.09714636496469575, 0.14967989356049605, 0.05179984715574826, 0.1858692684703721, 0.05365797236317904, 0.4533322178897502, 0.5121263506905965, 0.5421517552356276, 0.4766073020051911, 0.5239555451909585, 0.5385189517653213, 0.4579529307185245, 0.5257080424240511, 0.5466239254939702, 0.07407076847899496, 0.13569337413998894, 0.09234595722165972, 0.1133502718545416, 0.12208417736173538, 0.10078421217075806, 0.10140840078729141, 0.13184764753365796, 0.12008748846346329, 0.16928349581008606, 0.17680857215495582, 0.28290936776656217, 0.16117221930045111, 0.20462276750216546, 0.3259552087231874, 0.24338558415369405, 0.16848699364665864, 0.16202420843884224, 0.35855384650116207, 0.3355889026305997, 0.41910080158440843, 0.3400172562296244, 0.39022080794723446, 0.3989642537485544, 0.35840036520697094, 0.26418684285421135, 0.45967529081300496, 0.18322293120248467, 0.16321204017619806, 0.2466830452567078, 0.26535249032065433, 0.3251570595989215, 0.30605967424230474, 0.23225592338992784, 0.2705589244341018, 0.13737299097785072, 0.18993407762290182, 0.20889444245946465, 0.1988101259730204, 0.19989599683404802, 0.21350330248806493, 0.21278921565406128, 0.2050313102815201, 0.22047512894210264, 0.22791594487510303, 0.3017156785711681, 0.5003673926813486, 0.20134293637283351, 0.22166756250843045, 0.19720609746582118, 0.6421011397522767, 0.1808147173135849, 0.4626951708138496, 0.19228730606645617, 0.7989171507552282, 0.870756762947148, 0.8621347027791493, 0.12964008023063545, 0.13010909318966313, 0.13049708637750246, 0.20875132639834482, 0.16134629387148558, 0.12494019471057216, 0.4004005815851326, 0.7719067987250694, 0.5785547777506563, 0.20441632526094866, 0.20828433796201107, 0.21029745765841212, 0.4076754300398425, 0.15385049000537743, 0.6446908589221922, 0.17745444878068395, 0.17957648285102568, 0.17778318673458793, 0.20599342212058547, 0.18415844020161454, 0.18276716781680602, 0.1854038421905605, 0.19089409908572874, 0.17422733511298627, 0.0821367448878596, 0.08263407172401238, 0.0951785183611994, 0.08360310195406129, 0.08477132080646643, 0.09388950184723566, 0.09560453828352311, 0.10368225067291637, 0.08192728897045598]}, "mutation_prompt": null}
{"id": "111e3414-cb83-49e5-ab62-20edf19b1f5e", "solution": "import numpy as np\n\nclass StochasticHybridOptimizerRefined:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 12)\n        self.inertia_weight = 0.3 + np.random.rand() * 0.5\n        self.cognitive_coeff = 0.9 + np.random.rand() * 0.8\n        self.social_coeff = 1.1 + np.random.rand() * 0.9\n        self.F = 0.6 + np.random.rand() * 0.1\n        self.CR = 0.9\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizerRefined", "description": "A refined stochastic hybrid optimizer utilizing adaptive mutation with elite-guided swarm dynamics for improved global exploration.", "configspace": "", "generation": 36, "fitness": 0.3031775646712301, "feedback": "The algorithm StochasticHybridOptimizerRefined got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "729e5e89-c193-478e-9e8a-6de2b2000b10", "metadata": {"aucs": [0.7069622581715889, 0.8149160617147984, 0.7589429783492794, 0.693173086781603, 0.788355165142476, 0.7583213993460982, 0.70489308305213, 0.7872395751797736, 0.7752635033360054, 0.2390466590818766, 0.519540677790417, 0.5418647509522487, 0.29091716262317857, 0.5601661907427216, 0.4532000926019385, 0.3256212847142431, 0.5654154276991896, 0.5309706066182528, 0.13180142854778132, 0.16389729694577038, 0.13533168060163825, 0.09875316436831472, 0.1353888771956534, 0.10946452568935205, 0.09316754939107685, 0.15465591840165016, 0.12090120334618937, 0.09736898292097029, 0.1263451681339488, 0.11989291466961949, 0.1342290950814915, 0.12388932054669843, 0.0975728768517703, 0.10044548297385814, 0.12726527444640723, 0.0997525864798614, 0.9777125679927307, 0.9755212122344337, 0.9775704253178615, 0.9779894663074924, 0.9747211359272563, 0.9787059712465473, 0.9781953533369873, 0.9760242864639309, 0.9780251609435429, 0.3801346503105081, 0.5855232757519384, 0.5730024077350202, 0.38967314403975317, 0.5860413422358499, 0.14941226128540597, 0.34121601779457755, 0.5625021901259, 0.5492000009196926, 0.2181608185719185, 0.21609364481813542, 0.7601463937844622, 0.6511817010718435, 0.2590475700427627, 0.21332070985407037, 0.2183094505461719, 0.7379195419609235, 0.17620422898075228, 0.18529099898813095, 0.2105331130733552, 0.35582848093468655, 0.11562853125777073, 0.2402466223790397, 0.246827875091705, 0.16442251517962447, 0.12577045077658056, 0.2287443122394548, 0.021501357074793614, 0.09328875068898856, 0.04872800467272298, 0.18917662006253422, 0.22199405136354544, 0.30375791492034065, 0.16603621849311545, 0.24061142616007314, 0.2099898180100237, 0.035645305113198855, 0.05200078535311825, 0.0013779290800948196, 9.999999999998899e-05, 0.0016612933286543896, 0.005681083792416053, 0.0038923823241773237, 9.999999999998899e-05, 0.0271973826016072, 0.08439454573083327, 0.1273167942467699, 0.06503929798460051, 0.02371164098115719, 0.053668986204645996, 0.06876189692748436, 0.04490959947571338, 0.016973618531710755, 0.059741824716584624, 0.036617461625845005, 0.04906532405647901, 0.04167929077102195, 0.18470383135314627, 0.23924001590648736, 0.104455124512697, 0.06535379583341416, 0.12418098293066437, 0.1672567387754269, 0.162166638075515, 0.07609714230437714, 0.2178190306428882, 0.09231488247390529, 0.15286594028665534, 0.21838978837323453, 0.12860276342951893, 0.0786714790085079, 0.0780506758509466, 0.47757240888522035, 0.5521655917994803, 0.5418511369938466, 0.49049003235507116, 0.5340914055876689, 0.5317455706267253, 0.4857988313613536, 0.5342732688258072, 0.5523835261494703, 0.09839474134942083, 0.10644920594185803, 0.12394964439469547, 0.11753198676319165, 0.1317257408498934, 0.1651543105207196, 0.1289107209086665, 0.13397606707018417, 0.13411952364521473, 0.1508041038487392, 0.28264280429382427, 0.12175039979023872, 0.24293742386616324, 0.3390733398879431, 0.22862047322580348, 0.16601945427894915, 0.2951757981280936, 0.4303732871667606, 0.2942603352513353, 0.4302980098844822, 0.472926861052434, 0.3250866364631123, 0.4656023489303558, 0.36782251529371823, 0.3934082080321667, 0.46007132527824, 0.4729236286622176, 0.21808015621233767, 0.3475909074689427, 0.3604681867837116, 0.18034041543367452, 0.23872924503062443, 0.18567290760102173, 0.14278642901140826, 0.37056481368539307, 0.1830091421743394, 0.1896755210512353, 0.21451623584218937, 0.20999081599511793, 0.21828466966989368, 0.220690642888012, 0.1980455694699308, 0.22560586854154996, 0.21067966181822972, 0.2066250287116581, 0.20093256805424964, 0.2029548156476334, 0.20265767586096162, 0.22788903479701195, 0.20419258627751147, 0.23728101448704786, 0.4190568890038294, 0.6402906159657376, 0.1879872267748781, 0.7487736130736286, 0.8817031298608935, 0.8592877635195294, 0.7901310603006605, 0.8317818295636673, 0.8560260157151023, 0.16573153227660564, 0.13230478704763082, 0.167430322408324, 0.456886114616591, 0.7053549061762934, 0.677070197291332, 0.20580473597762172, 0.2094096361354032, 0.2103612543233523, 0.1527733083948568, 0.7212601273515302, 0.1530812640593836, 0.18038222830175377, 0.18145578707757237, 0.1747286742675913, 0.19026716987264047, 0.1925697024486741, 0.17736547886370824, 0.20285058904289244, 0.20290466052103717, 0.19295328956906088, 0.08012705633941208, 0.08505689792972115, 0.08992620637465953, 0.08284111316446374, 0.0906178811471916, 0.08928372567883947, 0.10608109337019433, 0.1045874457016096, 0.10763348554074637]}, "mutation_prompt": null}
{"id": "ef652432-d133-4ad4-9bc7-e3d59de8ece2", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, budget // 10)  # Adjusted population size for more variety\n        self.inertia_weight = 0.2 + np.random.rand() * 0.6  # Modified inertia weight range\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Adjusted cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.15  # Adjusted stochastic scaling factor\n        self.CR = 0.85  # Slightly increased crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizer", "description": "A stochastic hybrid optimizer blending adaptive differential mutation with dynamic particle collaboration for efficient optimization.", "configspace": "", "generation": 34, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "729e5e89-c193-478e-9e8a-6de2b2000b10", "metadata": {"aucs": [0.6961053628881055, 0.8023255233112209, 0.783859436735587, 0.7360141482996214, 0.7895890991134221, 0.7841736260310602, 0.7063968544714923, 0.7957652292476602, 0.7716265351966247, 9.999999999998899e-05, 0.5278066488831282, 0.5367082011605997, 0.36760047645477056, 0.5583794212042263, 0.5274369271674175, 0.42513803563625996, 0.4283914514943826, 0.5791529805568283, 0.14478268343264722, 0.1477487363806831, 0.16385273756496466, 0.12328992887557122, 0.4562114837018505, 0.16607414257160724, 0.13930783684750336, 0.13313514170624585, 0.1197357498798649, 0.12284550355199075, 0.12114358129377123, 0.12746799212413384, 0.11310478673365942, 0.12974616400039396, 0.1124527522544777, 0.12249117884180083, 0.11712564996715302, 0.11445929137171784, 0.9742173834130397, 0.9726524447279982, 0.9750801775347264, 0.9768954081968139, 0.9737871566188938, 0.9738025797663392, 0.9703235832814603, 0.9728167289368196, 0.9725948115784776, 0.4194913053565976, 0.5761479010817736, 0.6245250568437808, 0.37940177431579536, 0.5954964085562584, 0.5712242557621098, 0.346323844927669, 0.5050339066876652, 0.253628156976208, 0.6745680822890692, 0.6124192040516798, 0.8306358097542641, 0.2045862635833512, 0.7659493278441492, 0.8249441284578066, 0.35271388373563195, 0.7582355210521674, 0.37021919800655445, 0.16884027683525915, 0.2308351127201813, 0.12747104067194992, 0.16837149165120702, 0.21858997400818414, 0.1249101375388505, 0.23982441419239453, 0.21841425072696063, 0.2520260574784684, 0.19968348616631915, 0.30383081479575813, 0.2390166664477359, 0.1796340187417591, 0.24260606508527016, 0.25122842647428734, 0.19846145912975832, 0.25882160187780223, 0.0967655585401258, 9.999999999998899e-05, 0.0029336407939339892, 0.004327991234687967, 9.999999999998899e-05, 9.999999999998899e-05, 0.024313897843425858, 0.07816684337068314, 0.08210096083718077, 0.1494687192774511, 0.043221903203876866, 0.05885236714012321, 0.043227485397972276, 0.11388722837068255, 0.10488040487000727, 0.07062608774102974, 0.1062287814526448, 0.1363291650837185, 0.12889776442240253, 0.05199763884512665, 0.03799419877528687, 0.08071678238071323, 0.08726540276392303, 0.06734458093063855, 0.08844491033078417, 0.14246046652096978, 0.10506296509776825, 0.08278218689341343, 0.10133246201314561, 0.24735631439872618, 0.11262825099992457, 0.15363948760754798, 0.08077735921245621, 0.16828865280975203, 0.04594356856157722, 0.07774792200886715, 0.048072543152954283, 0.4794335217388309, 0.5057910077677841, 0.5563439112541908, 0.49840831669499575, 0.5260916149512439, 0.529553108849454, 0.48978274126766175, 0.5510842383320731, 0.5626743224756172, 0.09453271529199336, 0.10400120238707311, 0.13149091602189944, 0.15652510286059174, 0.14810223306188763, 0.1417442307728214, 0.14691962686278126, 0.15713565081967773, 0.16958985679587912, 0.1462997086471889, 0.3900151303527545, 0.18945855362717312, 0.33115351970865003, 0.19554949333963145, 0.17885333496533462, 0.19355674558331248, 0.2300913435456654, 0.1909978583228108, 0.36929950046905224, 0.4717701967020296, 0.45829985841816934, 0.3206878879254398, 0.4911938118694742, 0.3191493384513049, 0.2726905945207897, 0.526500052207719, 0.4292670792972738, 0.1715737546386914, 0.22299955566966456, 0.1908749768341298, 0.2850200262811621, 0.27144948007754266, 0.2545933043594255, 0.21376222688208435, 0.3192259237562416, 0.18911870102449624, 0.20089594082059525, 0.21192250331219398, 0.21532041574423888, 0.2085026492804971, 0.25751772967914144, 0.23577586930381889, 0.2237191790095855, 0.2570824646355654, 0.2274819784175265, 0.20955059607071325, 0.20348246565501127, 0.18739151967183454, 0.48170437213617223, 0.2128158157347515, 0.17874560455558497, 0.3027608025826076, 0.20340071797758763, 0.19270261563860092, 0.8253439363159151, 0.863958227392987, 0.8849046116370003, 0.13097344694500113, 0.7836761366581604, 0.7972990106904596, 0.20331430286253094, 0.11416900038261757, 0.11422497275454757, 0.47799114884343985, 0.7268833417679575, 0.7733057679555422, 0.2097459921063064, 0.20977785015304184, 0.21073434329170793, 0.620862633399299, 0.7654426142008632, 0.15395307580973117, 0.17714626324988858, 0.18689140435757212, 0.179852614845869, 0.1804595340275269, 0.18768957090244154, 0.18090141191468412, 0.17904625878327984, 0.18256584163351985, 0.18781417070865314, 0.09670782957858737, 0.10151281422711023, 0.0866873025719127, 0.10814961303104209, 0.08206371464209083, 0.12853287381588108, 0.08661028981892627, 0.1339483205405333, 0.11888561632384609]}, "mutation_prompt": null}
{"id": "edcc3d9c-6f1b-44ff-9be6-c10c4dfd92bd", "solution": "import numpy as np\n\nclass EvolutionaryParticleSwarmDifferentialOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(50, budget // 12)  # Adjusted population size for dynamic adaptability\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Modified inertia weight for balance\n        self.cognitive_coeff = 0.9 + np.random.rand() * 0.8  # Shifted cognitive coefficient for enhanced local learning\n        self.social_coeff = 1.3 + np.random.rand() * 0.6  # Adjusted social component for global collaboration\n        self.F = 0.45 + np.random.rand() * 0.2  # Fine-tuned differential scaling factor\n        self.CR = 0.9  # Increased crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n    \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n        \n        evaluations = self.population_size\n        \n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n        \n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EvolutionaryParticleSwarmDifferentialOptimizer", "description": "Evolutionary Particle Swarm Differential Optimizer integrates elite-driven mutation, adaptive velocity, and collaborative crossover for robust exploration and exploitation.", "configspace": "", "generation": 38, "fitness": 0.15082800788211984, "feedback": "The algorithm EvolutionaryParticleSwarmDifferentialOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.17.", "error": "", "parent_id": "729e5e89-c193-478e-9e8a-6de2b2000b10", "metadata": {"aucs": [0.23223676293235596, 0.26339057673791355, 0.24390866052747862, 0.25120178768720425, 0.2730792866321178, 0.2731915649705987, 0.2479166200635513, 0.27398521849383106, 0.2679957432611263, 0.00230513303909774, 0.003684925054937782, 0.010610044492702975, 9.999999999998899e-05, 9.999999999998899e-05, 0.001444250236756539, 9.999999999998899e-05, 0.0006206835073324646, 9.999999999998899e-05, 0.06245938527749384, 0.0811926283826464, 0.0588495437108264, 0.06307992737388501, 0.07052664484172988, 0.0869537380066322, 0.06330081397326615, 0.0737494645518213, 0.0638121613415944, 0.04956833562826346, 0.05828549262028082, 0.058232868209399435, 0.05158128625473224, 0.05432401420470012, 0.05190112670170999, 0.050557056270075784, 0.05136222886913744, 0.04936747287080312, 0.8421855696001277, 0.8273389338985264, 0.8392872864602248, 0.8438104463846215, 0.8437305011516245, 0.8438406453852595, 0.8434622843377917, 0.8338147339099349, 0.8433288898614009, 0.10183957286781409, 0.12741232584730222, 0.12341333912843255, 0.11303694866494318, 0.11693666585001483, 0.13048606339638624, 0.1232307487898675, 0.13278771736999095, 0.13085879840280779, 0.1712262404910634, 0.20980281598316075, 0.17845975430223848, 0.17803182637888093, 0.17450003058951913, 0.15970983440516007, 0.1606945875374477, 0.20355368580056132, 0.17815056350391256, 0.05974894969000799, 0.07160980860302224, 0.06332092904783548, 0.047455044122786005, 0.06460026894430992, 0.06904566745000862, 0.0632319753540378, 0.06817722053828634, 0.07114211540750781, 0.06034715616659947, 0.05779151796775672, 0.06953897675957088, 0.05693033377484957, 0.09889412670591446, 0.07277548327474614, 0.05553476835842863, 0.06672545803100816, 0.07535681019075235, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03410823752471992, 0.07844105776640231, 0.05955798931369005, 0.048401024018369765, 0.05656592263635307, 0.06995789814520048, 0.061013262460537065, 0.053277234445301636, 0.03445726263620197, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.012691553603344397, 0.021139800066457215, 0.013136878272363761, 0.028846109731236025, 0.022738632635436296, 0.02504530319631071, 0.01871166854526496, 0.019899117448582526, 0.02478433549906711, 0.24422101883957625, 0.2617999029747228, 0.2608350868910032, 0.2555877085373224, 0.28047890445829904, 0.27029617422971497, 0.24835048080722266, 0.26881650195908, 0.2596798326803993, 0.07018990213355825, 0.06651372869406036, 0.0782953388335722, 0.06556651814535885, 0.06936834746338749, 0.06620219014946582, 0.0617087075114614, 0.06504701054587492, 0.06881106777605561, 0.1453296677159377, 0.1456550735262816, 0.12559307340772907, 0.15612134315680182, 0.13765660800142943, 0.13189463292065684, 0.12672931199287263, 0.14725868866974323, 0.14852424327707647, 0.19327459892049847, 0.20273037272138594, 0.20505033425565622, 0.16488169408124542, 0.19793308114880503, 0.1741050841887496, 0.20031023378913393, 0.21543709119824617, 0.19639726609927677, 0.14853956657166567, 0.19342181681058568, 0.13757648656569432, 0.13329064406965174, 0.1341802599743167, 0.13760505945535173, 0.13579893692220013, 0.13958566644111292, 0.13602089805483342, 0.1778910509121241, 0.19106165394683228, 0.17111095987102798, 0.1745682173285008, 0.1829425267589294, 0.17612715221128872, 0.15395478432361742, 0.17946399264307433, 0.17542555728852405, 0.154034256072347, 0.16445923352568192, 0.16613601362779606, 0.15364088765883677, 0.1662008434114146, 0.15991955072804576, 0.1687371666511699, 0.16960419367286994, 0.1633272761236234, 0.3287325514904783, 0.28346553838006416, 0.30689527100843816, 0.15014874628689834, 0.1501930853190181, 0.15551456867519298, 0.251937355283272, 0.322361288868399, 0.32940331780205323, 0.19362882278570515, 0.22708316188503985, 0.24737803124719449, 0.20759160585290037, 0.19324455080473923, 0.25342784471325164, 0.23217629038938514, 0.29219758457602474, 0.22660352403858774, 0.19799052346723167, 0.19847420954668138, 0.19806351793197485, 0.1817298201156453, 0.1934068281779442, 0.17623687645376462, 0.19317986418159405, 0.18600559962929641, 0.1895215222178369, 0.06142098884256775, 0.0656160844774526, 0.06349654807717342, 0.06349565655768452, 0.05861460399057983, 0.0796142832634208, 0.06557369751451514, 0.0653345406319168, 0.07100976937389791]}, "mutation_prompt": null}
{"id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 12)  # Adjusted population size for improved exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.5  # Altered inertia weight range for stability\n        self.cognitive_coeff = 0.9 + np.random.rand() * 0.8  # Narrowed cognitive coefficient range\n        self.social_coeff = 1.1 + np.random.rand() * 0.8  # Adjusted social coefficient range\n        self.F = 0.4 + np.random.rand() * 0.2  # Broader stochastic scaling factor range\n        self.CR = 0.9  # Increased crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizer", "description": "A stochastic hybrid optimizer incorporating adaptive differential mutation with enhanced particle synergy and diversity mechanisms for robust optimization.", "configspace": "", "generation": 39, "fitness": 0.32045342969082874, "feedback": "The algorithm StochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "729e5e89-c193-478e-9e8a-6de2b2000b10", "metadata": {"aucs": [0.6689504025992485, 0.8014335901312517, 0.7842350074809151, 0.6937369460637929, 0.7819518694621226, 0.7459802541930312, 0.7036233606942813, 0.8132484855480165, 0.7641964151074203, 0.28023351405020813, 0.4872025124357229, 0.5176258834506966, 0.28124105410419764, 0.5087341532072739, 0.4285153009783511, 0.09708951276643873, 0.5902524881725798, 0.19034126913276272, 0.1936859662250302, 0.15298988718007533, 0.13659929742401966, 0.1280785574076455, 0.14007330985164024, 0.1161203070205653, 0.18792480145991086, 0.15629404629010502, 0.1332097984828573, 0.11856630149975977, 0.15154340754772133, 0.13288033410893763, 0.0999542256743281, 0.10404564253657977, 0.12603308186083795, 0.0970286654183743, 0.1489194754549521, 0.06633577149533754, 0.9778414859584456, 0.9757775692734144, 0.9772610617504754, 0.9778612037825845, 0.9744256957652657, 0.9778866492738862, 0.9783749187996509, 0.9759183421727928, 0.9771703808000552, 0.41709653961870785, 0.5546628303416953, 0.6159067605725235, 0.43856704850091177, 0.6018050835086819, 0.4255089117535814, 0.4017275632295102, 0.5754564821353614, 0.5901379798932638, 0.6048869366352351, 0.7237170639528364, 0.7397295680076769, 0.7710450365007318, 0.2763426028985415, 0.16126894084892296, 0.5488034871756866, 0.22263513644233623, 0.6846172547499461, 0.17360746467171995, 0.22150283600075438, 0.2504768538338228, 0.12168310921610104, 0.2391257143740485, 0.12922414349298017, 0.21197577386493316, 0.2269518797807486, 0.23429760616478534, 0.1858061245547511, 0.1020091359135804, 0.23488621228327133, 0.16114142539137788, 0.21767095013576476, 0.261157137181924, 0.1741361100435761, 0.24911139341511712, 0.1297905972789184, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01262139642559601, 0.0034471776562224887, 0.044558763312143146, 0.06764786596962402, 0.05625704124063091, 0.07304548244015063, 0.1165259561019224, 0.04313316873917339, 0.06869106201160924, 0.12221867145292786, 0.0746431736594585, 0.03637801494094017, 0.13419625525357548, 0.04210746908088181, 0.1533319269457627, 0.09407051675094369, 0.1274368178961489, 0.06868733210211553, 0.0955017548356043, 0.08376160210179329, 0.16493243150776138, 0.21030710243135653, 0.06005132291598059, 0.14914189458130678, 0.11712678766520535, 0.12686474412231508, 0.07597274146485611, 0.10751651458682898, 0.0532054579318163, 0.487413558073829, 0.5439921118085609, 0.5284861838671393, 0.5061446755233598, 0.5439623446082062, 0.5502003651187195, 0.5019111704615753, 0.5460454507945383, 0.5293147705170705, 0.1253475262539363, 0.15664749955256307, 0.10538700234482434, 0.10093244749918939, 0.1338250272538788, 0.1253305132271515, 0.11267451288767538, 0.1381622586348571, 0.11289804525804925, 0.14617395649180254, 0.2881606234035281, 0.2822499532314069, 0.26723023717874617, 0.31881760285576033, 0.20097492791894078, 0.16254368418427878, 0.1639357478740774, 0.4998604350334659, 0.3444541183644555, 0.26424084415152804, 0.46277099318800363, 0.306067343511491, 0.45498236547883575, 0.5004515622785717, 0.37376770567021556, 0.4819711918192897, 0.47034468368234417, 0.2556713911401617, 0.30963781265626644, 0.20792686076505773, 0.20858415146199372, 0.3425723193063154, 0.231551500408393, 0.1310403693734472, 0.2202807617055269, 0.139651963760829, 0.1992440184870985, 0.21754156150465398, 0.18895949140288026, 0.19373320089521662, 0.21724775703837296, 0.21071970612881985, 0.19818616189474814, 0.25311989347039365, 0.22143070838440848, 0.21147590162546603, 0.19795252452947454, 0.2160898917247258, 0.20876036570817147, 0.2002939218874331, 0.5472541051392946, 0.49514961811261204, 0.1977734570304106, 0.1930336714895141, 0.8065585781235843, 0.8748797317980876, 0.8627069251843178, 0.777899692937434, 0.8468228873202885, 0.7975708930624833, 0.772867291174791, 0.1673082117426642, 0.8593091864138344, 0.6536014668927886, 0.7228665096161856, 0.8158658363763379, 0.20675097241704865, 0.20695585404925443, 0.21008877975603857, 0.5264630721139799, 0.7732904685296857, 0.7973486650883447, 0.18024665396230322, 0.18818008714477097, 0.18269388912747853, 0.17472429542835377, 0.1867185461490688, 0.174445637941829, 0.18810634931525094, 0.1869285715918486, 0.1832274235354585, 0.08042849160056487, 0.09054232581622379, 0.09105693291165606, 0.0845353547104607, 0.08478565969130536, 0.08640704481601147, 0.10581081733290121, 0.12516954180748785, 0.10827929612280363]}, "mutation_prompt": null}
{"id": "0dc62191-c16c-4e50-99af-d97dbd726dca", "solution": "import numpy as np\n\nclass AdaptiveStochasticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Adjusted population size for enhanced resource allocation\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Modified inertia weight range for better exploration-exploitation balance\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.6  # Adjusted cognitive coefficient for fine-tuned personal best attraction\n        self.social_coeff = 0.9 + np.random.rand() * 0.7  # Tweaked social coefficient for improved global best convergence\n        self.F = 0.3 + np.random.rand() * 0.3  # Narrower differential scaling factor range for stability\n        self.CR = 0.85  # Slightly reduced crossover probability for consistency\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite diversity pooling\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Dynamic boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "AdaptiveStochasticOptimizer", "description": "An adaptive stochastic optimizer integrating variable dynamic scaling, elite diversity pooling, and differential velocity adjustments for enhanced convergence.", "configspace": "", "generation": 40, "fitness": 0.3024005482071676, "feedback": "The algorithm AdaptiveStochasticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.699075606380265, 0.7956059973000392, 0.7769127045214611, 0.6906186424008929, 0.7707002483203729, 0.1882167139126616, 0.7400351518635793, 0.7883800135511472, 0.7849967997381769, 0.34396983219783883, 0.48627736773455066, 0.41525985586053826, 0.1464603782759223, 0.5080665886833706, 0.4531119507260192, 0.35354357386798696, 0.47802724993759294, 0.047073459537372075, 0.1286078757200838, 0.39469551459868013, 0.119782465877172, 0.18532007263990713, 0.12818402871113865, 0.16398391662728884, 0.11893755598502898, 0.1550113427453863, 0.14442594137329712, 0.11243349458089691, 0.1288649184465428, 0.11525395847306574, 0.1146247778632471, 0.11206505364532005, 0.14850339309873384, 0.09342178970097625, 0.14056260857476321, 0.12766334282262692, 0.9768249815465304, 0.9755594649374694, 0.9755488584177998, 0.9776762632249913, 0.9674556595902695, 0.9744478238508887, 0.9760184423455791, 0.9670856175297774, 0.9744403413409407, 0.4378047080248141, 0.5909620218377414, 0.6063536573660206, 0.42172599047519166, 0.5313800270373179, 0.5545153386866317, 0.4109491539315281, 0.5523114199808983, 0.5956467907667211, 0.635330778479558, 0.2159841346676642, 0.21242801851960436, 0.25897638242105836, 0.21155070849823177, 0.21485867188441188, 0.16996835433858482, 0.6622874616815239, 0.23245095099684165, 0.1584080508558362, 0.12851360920276034, 0.21537399463135087, 0.10972630638587066, 0.12588002672256493, 0.16094189889031218, 0.12196146389092866, 0.20874808447775228, 0.25141763284758356, 0.19939743241314523, 0.22149216442053898, 0.2165169980324767, 0.18426223694492216, 0.22669183872833887, 0.24398218109073555, 0.09657353175351002, 0.1185890016679958, 0.08450465412736485, 9.999999999998899e-05, 0.056811323904611744, 0.0037497521010140256, 0.02337737331017964, 0.009622659045787296, 0.03511549870384023, 9.999999999998899e-05, 0.04605705343350619, 0.037823038753792004, 0.08334928395987795, 0.11397653331801594, 0.048785872361874705, 0.065005565781873, 0.10524294391421696, 0.01818240656718395, 0.13901379732117003, 0.07402071478854455, 0.06829275737447382, 0.03690345245157911, 0.05847024082640184, 0.04119295139496826, 0.060330242735073036, 0.1008560280841786, 0.1319037961705768, 0.07286158843535195, 0.12248378350657718, 0.10353582032726649, 0.12081577529457188, 0.18024659168890556, 0.08619663040746361, 0.15081858238447188, 0.14957806697971843, 0.11753938791968177, 0.17086099596477566, 0.21961237853283078, 0.14959385386475388, 0.4746161085378019, 0.5220519589107552, 0.5499727272355773, 0.5030660779196019, 0.5434884069784046, 0.5230399032701321, 0.4896870649931615, 0.5169081633621846, 0.5461676910615942, 0.1336138683474405, 0.12618886265834084, 0.11256472876851076, 0.1331297381077684, 0.14902692666937256, 0.14205772404808048, 0.11100869511343903, 0.12183893999164175, 0.13363692801579674, 0.28488865108931505, 0.204729433546173, 0.27758020361878255, 0.3429868389369989, 0.23806914937171386, 0.20132987386488843, 0.24564767385415898, 0.13539445747230328, 0.5446583874149089, 0.3772199199401408, 0.3777220859528333, 0.31973123013233196, 0.35636775830630707, 0.36153616680690137, 0.462265209476697, 0.4091930579689108, 0.4420838430502595, 0.4672925254793211, 0.2517632650606664, 0.2566579108268122, 0.32606927010743614, 0.21733807820383821, 0.324489490696404, 0.20258731886623382, 0.24495038294195115, 0.2511550326537042, 0.2252263632191257, 0.20569678013035042, 0.23492807205713584, 0.22381929095264586, 0.20275755912026794, 0.19401912347414896, 0.20752152734423468, 0.20616248745957555, 0.2305424126337805, 0.2133662803686731, 0.1922622581519361, 0.2087115287038347, 0.23505963810295538, 0.2255317108762278, 0.23891543592977493, 0.19336630148476575, 0.2206544017270211, 0.24093978933019766, 0.21873538147111704, 0.8369954295697196, 0.8318585855843361, 0.859431673556319, 0.7945047455720975, 0.8266584688345012, 0.8247956239676812, 0.167297665549058, 0.1673012588325823, 0.1675807295512195, 0.5315625286156244, 0.6902648512614944, 0.7046440723342072, 0.20798173582696577, 0.21042260815676594, 0.2089341891830644, 0.6432303322367822, 0.7387172309034111, 0.8151843591059982, 0.19383923831589867, 0.184836412260714, 0.19173859232079016, 0.17322380595374764, 0.1923211110518327, 0.1754851049344387, 0.1948681366386802, 0.19332409495366032, 0.18785035809552897, 0.08793242159411785, 0.09590049445199389, 0.08930599545380524, 0.08528728497899318, 0.08888291858916364, 0.0973131798053899, 0.08773118525009682, 0.13857310962955394, 0.1041267502949742]}, "mutation_prompt": null}
{"id": "b4abc9ea-e6ec-4445-b0eb-7b3a12d94dbd", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 8)  # Modified population size for better balance\n        self.inertia_weight = 0.5 + np.random.rand() * 0.4  # Adjusted inertia weight range\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.6  # Modified cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Redefined social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.3  # Modified stochastic scaling factor range\n        self.CR = 0.8  # Reduced crossover probability for exploration balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(5, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer utilizing adaptive differential evolution and adaptive swarm dynamics for improved exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.2617017954652247, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.629452155553798, 0.7428484484558096, 0.7128255969013628, 0.61423609868136, 0.7336428743129995, 0.7300821638089492, 0.6031493384454194, 0.7402588369720261, 0.7142635538538206, 0.1859622330207774, 0.3897603802608135, 0.2948016328266162, 0.17522457740516162, 0.3623930081196328, 0.3382061765319294, 0.04133653560395156, 0.41110215997149213, 0.28501855917355856, 0.10130125288837222, 0.14262573545822144, 0.15157681597630257, 0.10506380221015021, 0.42914116162295446, 0.12342957730081905, 0.051136929232503125, 0.1285779185484256, 0.11645493500346804, 0.09375933799550062, 0.10869763129978294, 0.14019408813090395, 0.08752152220668086, 0.13641954094367648, 0.09038096855308053, 0.08752113318620036, 0.12374808582932495, 0.1126092073650028, 0.9812853006034914, 0.9729255883216034, 0.9809036688790465, 0.984573036158269, 0.9844953704777538, 0.9845065492733205, 0.9822855343929074, 0.9812415833770476, 0.9822787590910952, 0.316186186603164, 0.487710341005263, 0.48718727123204053, 0.3414411146529982, 0.4703015811009935, 0.14894394724244575, 0.24699118049899904, 0.5035452312667221, 0.4686553836488834, 0.2926618921650668, 0.3610253634076369, 0.7252402019368505, 0.2037452814996974, 0.2762600293802008, 0.18958415201780443, 0.11550254820073458, 0.633019665790362, 0.11585577671137326, 0.15922663806463966, 0.1965234758779726, 0.2203991977667581, 0.12163952956420476, 0.18978040123923012, 0.1930679073662369, 0.18181748848443113, 0.1227611450998698, 0.21084452756596805, 0.12185133699345985, 0.25335068877108136, 0.2034191260070326, 0.1733556400280959, 0.21060804930619137, 0.25342323868367034, 0.1879705444822687, 0.19813378059559916, 0.2150816148545398, 0.044893039647780686, 0.098884857146741, 0.02178565392507681, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.023587938613776505, 0.07314703049488414, 0.13296945051385378, 0.04373664052142612, 0.029305031566262407, 0.012648352651097206, 0.04184732197930918, 0.08930222316797298, 0.07116674881100293, 0.04225881163909784, 0.12814098048554, 0.10375667207661776, 0.056607422146128905, 0.07336861987003818, 0.06954056991846103, 0.05692286055196638, 0.057042021320658165, 0.07599801524780947, 0.0554102960117594, 0.038194065303012614, 0.03884840674178103, 0.12530950029429255, 0.14631709982467056, 0.14028948746632053, 0.06971541824107441, 0.050954646245795265, 0.05239568357387692, 0.43038905735041066, 0.5082260072937779, 0.4974268651361805, 0.4604171335942189, 0.4785386235605361, 0.5245611241806696, 0.44621849176223716, 0.512788817549846, 0.5378838431610556, 0.09090199787510334, 0.1528925613264187, 0.08623345208272515, 0.10093658847456721, 0.14067522292366486, 0.11722516630014179, 0.12066134747102386, 0.12251217023405003, 0.12368167031067301, 0.14817823282989706, 0.22825145882385145, 0.23851875801523303, 0.16664832789383743, 0.23107721986553686, 0.1540815754787207, 0.17939600426039726, 0.36355460520743077, 0.24900619713743732, 0.3274237444996513, 0.4556639521079143, 0.33289654436303506, 0.30998198433401536, 0.35483288601206264, 0.38229543652919296, 0.3402507164507894, 0.4405721389160947, 0.16140578722220122, 0.13876405398693026, 0.17915639053043464, 0.23932699014485592, 0.2161971154601009, 0.2359772186912822, 0.201641347628974, 0.1143909226969001, 0.14335442994342829, 0.3349334965006828, 0.18650557245952382, 0.20784867237199756, 0.2085687782323864, 0.19791699146515918, 0.20492254255080533, 0.23283622104763968, 0.19473113654508045, 0.23666973730735552, 0.21263021496430456, 0.2290848775033193, 0.2247990061015266, 0.20901891263602812, 0.18401722497457218, 0.1940517731809226, 0.2372559451945342, 0.17488394406059904, 0.41560325425695754, 0.23509140947701912, 0.7489473062118057, 0.8235452596915288, 0.2632182260756234, 0.1555702218748315, 0.15631679899952144, 0.15634527310118518, 0.1697499537940621, 0.1692073389266343, 0.17020502326778275, 0.4103042890119164, 0.5835693557163757, 0.1419412233204561, 0.20594947011879938, 0.21049240618457965, 0.10530865330660322, 0.19180022062781277, 0.6194158215555109, 0.6654373024234268, 0.18374638341626326, 0.1872810680690774, 0.19615321239479822, 0.18708668139790374, 0.17741249418410587, 0.17879789040174743, 0.18991283366816103, 0.19530492750718242, 0.20247807466060253, 0.09096435281712201, 0.0862414856911955, 0.09147618139901803, 0.08954894034787853, 0.09121432725935774, 0.08665458513430235, 0.10098413998379274, 0.11125966179907487, 0.09608683636462012]}, "mutation_prompt": null}
{"id": "40dd21ca-7820-460d-bd4d-303d418901cc", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 10)  # Increased population size for better exploration\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3  # Refined inertia weight range for better balance\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.7  # Slightly adjusted cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Refined social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.2  # Moderately adjusted scaling factor range\n        self.CR = 0.85  # Slightly reduced crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.05, 0.05, (self.population_size, self.dim))  # Reduced initial velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]  # Changed elite selection\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))  # Adjusted elite influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer combining differential evolution and particle swarm strategies with dynamic control and adaptive mechanisms for improved global search.", "configspace": "", "generation": 42, "fitness": 0.24736773465360445, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.5149631326973296, 0.6556035733902686, 0.6343370120458538, 0.5613687351889277, 0.6356233391693497, 0.6288633676313986, 0.5218151447764869, 0.6252790773830356, 0.6396469765428444, 0.13384587088173538, 0.22739226381820876, 0.19979398362486722, 0.09738396723524334, 0.23591099924251346, 0.09384914558426605, 0.008326844988386761, 0.3047735186074042, 0.24287269847455417, 0.08648212647129472, 0.13191398843102264, 0.11533429600630807, 0.09716738865666807, 0.10731834566587872, 0.12819584161035036, 0.1195803401896397, 0.14529620328428106, 0.11843519952558001, 0.09382011141461666, 0.10472576211554152, 0.11591286717476923, 0.09205108245949489, 0.0945909621331581, 0.09943638125786547, 0.09344956987016229, 0.12257927089783605, 0.11341115092810217, 0.9706319411727466, 0.9700825474575878, 0.9710268143964678, 0.9692516467987161, 0.9690036140031639, 0.9703554808624723, 0.9694980765304005, 0.9687040938479365, 0.9689633522142653, 0.275015817864503, 0.3396768585687725, 0.36643911402359486, 0.28314181011488915, 0.35699345514227576, 0.3689267302181428, 0.3094399383078532, 0.33958048893084547, 0.3573483090878016, 0.3904277104397821, 0.5146572846897948, 0.6018223493595454, 0.2375654153010014, 0.20052029278319805, 0.20548939536497168, 0.11564190422100984, 0.16695623335240162, 0.21281133139421926, 0.15154096974985354, 0.18045403272295824, 0.17127401230525907, 0.14045914377910396, 0.1596288636852693, 0.17461471052854738, 0.14569889102183786, 0.18187982651628176, 0.19190923174785546, 0.129881343051249, 0.15641666403531962, 0.17582339330574037, 0.13960369680998996, 0.1742984076839057, 0.18765530518414397, 0.06054740916908252, 0.16250189924839342, 0.20333030204323954, 9.999999999998899e-05, 0.02397287165658668, 0.001533602727318617, 0.02299618239339396, 0.01742769067715766, 0.01730357551327144, 0.01336012513827467, 0.12613649157744533, 0.07792942276529935, 0.047009356726112284, 0.1265217446838085, 0.08917551800027956, 0.03030384390840679, 0.02090232389401847, 0.06511641455877726, 0.0640202208477596, 0.0665328150418123, 0.03736047330786785, 0.024752323115985964, 0.051267159869296086, 0.029420044064685458, 0.027161235977670173, 0.04894218564469843, 0.059307222161558815, 0.0325044827478872, 0.05464113542198079, 0.059447010888136864, 0.06227922075947678, 0.18841447700909097, 0.058963658300799415, 0.08349301583328872, 0.09004967557984256, 0.12740490855495357, 0.1300639997272508, 0.10124592230016716, 0.04500466432302541, 0.4016477899072002, 0.4593080829912686, 0.44177308000125026, 0.4418056424456285, 0.46497612664846055, 0.4616975454197084, 0.40337144866390295, 0.46322232526164087, 0.4612757107986356, 0.1071104423412913, 0.08966074743724783, 0.10491995076336247, 0.09690769556934664, 0.10727810950292638, 0.10036102846324246, 0.08488934647624502, 0.10604071904697354, 0.11541641786820311, 0.14291157201059745, 0.13634329969190662, 0.24179216775523993, 0.1473563143166251, 0.1550755454038948, 0.21381393397700843, 0.133565094599859, 0.14806047273026357, 0.16975720649582782, 0.22859889701060998, 0.3275165888135778, 0.2640812480480257, 0.27300540853069466, 0.35368127384601444, 0.32916136594878176, 0.28444617066452316, 0.36935870956951466, 0.26670181461532616, 0.20333399039192646, 0.24408707222450887, 0.18332625920821188, 0.20218870667062183, 0.25770461846779424, 0.2583932165030477, 0.2194133783308172, 0.18201795741945093, 0.17244859200955598, 0.23348897151376669, 0.20543227581721357, 0.20163381301018934, 0.1980198010695613, 0.19504262776453152, 0.19815930381668345, 0.18094815712222356, 0.19107191563320935, 0.19855435660896859, 0.22885006743325031, 0.18561634014881923, 0.2043605140763458, 0.1850323747880861, 0.1968927285748342, 0.20390133453103554, 0.23573890883202553, 0.1946124339935693, 0.1952576826939032, 0.7523114392657384, 0.7573584587488088, 0.8084367147811284, 0.6758774649371919, 0.7544206811412186, 0.7454706168439516, 0.1429449802754763, 0.6254788087642321, 0.14195792588817535, 0.3312271196240939, 0.3861473432317549, 0.37036225375668586, 0.19934528692368647, 0.20606122046988162, 0.20554621363077408, 0.15877371673889762, 0.5907358201736332, 0.15950835344730763, 0.180031429549791, 0.1753774980446966, 0.1780215072377348, 0.19220950716796803, 0.17820062738290832, 0.18558498581335636, 0.1764161036440306, 0.18012279500830897, 0.1825229887627, 0.07621357857779476, 0.08633355201799808, 0.08507737198566478, 0.07791823374039719, 0.07910625707634389, 0.10305474717968832, 0.0945349591519995, 0.1122589990755678, 0.10315876872097818]}, "mutation_prompt": null}
{"id": "dee93b67-8ca6-41e8-822f-44ab32a0e2ea", "solution": "import numpy as np\n\nclass EvolvedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(65, budget // 10)  # Adjusted population size for improved exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Altered inertia weight range for stability\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Narrowed cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.1  # Broader stochastic scaling factor range\n        self.CR = 0.85  # Increased crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EvolvedStochasticHybridOptimizer", "description": "An evolved stochastic hybrid optimizer fusing adaptive differential mutation with refined particle dynamics and enhanced elite learning for superior optimization.", "configspace": "", "generation": 43, "fitness": 0.279673441072421, "feedback": "The algorithm EvolvedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6277999615639196, 0.752987104026595, 0.7309478171931442, 0.6428059075900551, 0.7473476435697952, 0.7493121820563224, 0.6376838634781197, 0.758664300454053, 0.7459207100886356, 0.24954654225417128, 0.420842546098239, 0.42238693202903976, 0.23162194510289236, 0.4086053823728023, 0.3934815588132359, 0.2713423554837988, 0.4606488738319957, 0.01182631513520338, 0.14532732601948517, 0.13357858637640752, 0.10270974551485046, 0.09852675795984922, 0.13133886902317915, 0.07133450911666672, 0.1050203831547929, 0.14317360145384372, 0.1395160107678315, 0.11469077499257296, 0.09924478639410095, 0.12173449187506558, 0.10198291263857029, 0.09459940555213431, 0.0915117175203577, 0.12015606233474996, 0.10194774942438145, 0.13194442810147944, 0.978805704790113, 0.9743346822843948, 0.9741222458675232, 0.9753961531052839, 0.9723609036611337, 0.9741510285666533, 0.9763439383599029, 0.9715218480921968, 0.9750383272302131, 0.31965713320164, 0.48952625494541846, 0.5294311001864236, 0.3349311669517059, 0.4803001169874356, 0.41992914551416394, 0.3466613211000672, 0.5009464963078037, 0.4730535198595014, 0.6320714614179923, 0.7084188304250896, 0.3623937617871811, 0.7005044721713632, 0.26466560394588645, 0.3641940710872854, 0.620820725073939, 0.3638047812504276, 0.7459764958236159, 0.16493676951894265, 0.20516044867577798, 0.11835012589552929, 0.09644193092766595, 0.18583053216222, 0.21793085129765255, 0.1615795763480692, 0.19609711330871382, 0.2488641926017865, 0.04869936082896953, 0.22907949245374848, 0.0157640799333032, 0.162405285068286, 0.23878872922607497, 0.10114839919148033, 0.19155728899733604, 0.12113286316886007, 0.22224803710378616, 9.999999999998899e-05, 0.040545697296867966, 0.0017721690222249897, 9.999999999998899e-05, 9.999999999998899e-05, 0.016252653735703837, 0.014131019601608896, 0.0011809155208520883, 0.03767540436582717, 0.06796999597006304, 0.04940224101958923, 0.027199949682179092, 0.1026825891075247, 0.11428914128040635, 0.059826092310243384, 0.028633432423688654, 0.07205945301315109, 0.06889162119816905, 0.03157939057150838, 0.0377288400738387, 0.2532103496081858, 0.04645441456302246, 0.09001471731802102, 0.10048148774681853, 0.04974058589582875, 0.05511623404945876, 0.18208559448723483, 0.07281455612151588, 0.1324185583953258, 0.03603566949749715, 0.11726438589243204, 0.14774430292843865, 0.22843521081448992, 0.10525557125028684, 0.07568980049684237, 0.20670462424687353, 0.46099946139767056, 0.5524414954692749, 0.5311417335443835, 0.4699585819772144, 0.552673987030595, 0.5162420431648225, 0.4521000560864511, 0.5387483569694002, 0.5208770150076389, 0.11386752874972039, 0.11791778499528704, 0.11989930788695691, 0.1113498495425076, 0.11552698779211168, 0.11299451789744308, 0.08841864349445372, 0.1353992186187274, 0.12070476647465689, 0.23341261449618056, 0.2674202493437877, 0.23465033685566217, 0.2040566129366994, 0.15325629397831197, 0.4064122309406468, 0.14222753303469582, 0.13088599663021727, 0.2618573480223182, 0.22556191407689574, 0.39542204269501513, 0.23226944578864306, 0.29125154627604233, 0.42721677230999133, 0.36517495791187804, 0.35856205335443136, 0.4364632177520339, 0.3308674440205045, 0.18653127424431903, 0.29733576055411204, 0.23034502671730372, 0.2207338579628788, 0.23216914025723, 0.24945345264504537, 0.1664476833954277, 0.21234853999843373, 0.1965883565951635, 0.20168984674959956, 0.213062028497639, 0.2840845248721764, 0.19230385812026984, 0.22654627860035403, 0.21002223966740052, 0.1895143445537163, 0.2186827704069091, 0.2210543584783492, 0.18564837385718447, 0.21800539355376802, 0.22778995299382587, 0.20023911789627669, 0.18039644379118314, 0.2179356084872569, 0.18873884130165397, 0.21760667128311106, 0.2177700746336495, 0.7644646677450921, 0.853072339769771, 0.8541096046163333, 0.7143605390829453, 0.16590116226376928, 0.15621186169464873, 0.16843980107412315, 0.16559282059932956, 0.1681336711589242, 0.5047329724855429, 0.7295379916694191, 0.6890312947607025, 0.2023807100459929, 0.20720175351151937, 0.2054698940351567, 0.15244811224416555, 0.152172641784191, 0.1551517078921879, 0.17382135509161145, 0.1799763515612396, 0.19072403283222006, 0.19953185258821815, 0.18571815543621328, 0.1880174112480678, 0.20089005972456742, 0.18812681202831505, 0.18341965619106881, 0.08655543290687273, 0.0882164414301635, 0.0970529474771673, 0.09032464003791685, 0.08847216914525524, 0.08841190945421018, 0.09620715059226537, 0.12032301884336105, 0.08491346641226027]}, "mutation_prompt": null}
{"id": "e17c7729-a390-4667-b930-54df8a693740", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Adjusted population size for enhanced exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.3  # Dynamic inertia weight\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.7  # Refined cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.5  # Adjusted social coefficient\n        self.F = 0.5 + np.random.rand() * 0.1  # Tighter stochastic scaling factor\n        self.CR = 0.8  # Moderate crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite opposition-based learning\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                # Opposition-based learning\n                if np.random.rand() < 0.3:\n                    opposition_position = self.lower_bound + self.upper_bound - positions[i]\n                    opposition_position = np.clip(opposition_position, self.lower_bound, self.upper_bound)\n                    opposition_value = func(opposition_position)\n                    evaluations += 1\n                    if opposition_value < personal_best_values[i]:\n                        personal_best_positions[i] = opposition_position\n                        personal_best_values[i] = opposition_value\n\n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "Enhanced Stochastic Hybrid Optimizer with dynamic parameter adaptation and opposition-based learning for improved exploration.", "configspace": "", "generation": 44, "fitness": 0.28567895802244797, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.718494116511637, 0.7570196361390743, 0.7631421749270437, 0.6887758788599551, 0.7406797280271893, 0.762150133284965, 0.6735363362361668, 0.7441610944348678, 0.7534539651999697, 0.33452338421802863, 0.4033751687968843, 0.4172250047481162, 0.24395336124984468, 0.48019560352932467, 0.4669408812785114, 0.19106183637322782, 0.4929661667336128, 0.013823465540717228, 0.06904550939427223, 0.13444984896566603, 0.09862833337776278, 0.10514515092525378, 0.13168158643069672, 0.13972643588037448, 0.11611934308962513, 0.16002392096668794, 0.14066104571584404, 0.10664511488969475, 0.12072648792112362, 0.10649126176743118, 0.10351832196163491, 0.11370756543770089, 0.1250663045760384, 0.08572884602412045, 0.12712112405485565, 0.12747471829185508, 0.9879598191466024, 0.985234364365216, 0.9836960779307842, 0.9758685533105753, 0.9758870087736633, 0.9760613999357746, 0.9759213982949396, 0.9731007315213385, 0.9740850342212171, 0.44787103852835153, 0.5259478415134567, 0.549662538347419, 0.3621146490970414, 0.5219960233695833, 0.5352912666856278, 0.42806504135353696, 0.4818356400469598, 0.5673871593291278, 0.7122523425862903, 0.21773064514193496, 0.7671698205195538, 0.5645377844510302, 0.19042804640800737, 0.7571300138127589, 0.22777097016754255, 0.3414997955931639, 0.7225167349832041, 0.1879266373868954, 0.20634478085668917, 0.2069046897495247, 0.12367362181525332, 0.1254003115375797, 0.23241241006513325, 0.1571173365904862, 0.19146645821861163, 0.20526917145277668, 0.19069688526596829, 0.20342535689649566, 0.22434804720471935, 0.19963240114652703, 0.14615722103532514, 0.24324040334733543, 0.1958592159253022, 0.0915820051872861, 0.23436238026029343, 0.004154378954721816, 0.00018364722777153286, 0.029584546947239665, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04368155449358857, 0.04153487953139723, 0.0027307168751665722, 0.03279657693554616, 0.04651083380343157, 0.08122087128692967, 0.05207423372018072, 0.021725319454796055, 0.030912313211220677, 0.1019198339275712, 0.09703183397136395, 0.06195039497509858, 0.03361132180534565, 0.0409757152084983, 0.03817484666468185, 0.13168119095913478, 0.10105630326054871, 0.07575111493145792, 0.06946387946437882, 0.16905743847316823, 0.07777430273478914, 0.21804922250729208, 0.2937352984692866, 0.03828779824431827, 0.08422029311430745, 0.15134280337235428, 0.08045892997449833, 0.047649718233010896, 0.048023266228299555, 0.04799316932321507, 0.4891962711028398, 0.5392405823069042, 0.5005539317012935, 0.5022633202698178, 0.537701530375595, 0.5958140704005266, 0.4833502984265028, 0.5386933262886432, 0.5317992534599707, 0.09097809286113712, 0.086947200541864, 0.11410427096957843, 0.11068682356622428, 0.12146174501928986, 0.12938311743049458, 0.12820070419919172, 0.11865962225975613, 0.1383939395660564, 0.2015308783454538, 0.13318551011146496, 0.1576834897543371, 0.23091466057414878, 0.1419128508649934, 0.1630046169491881, 0.13638633521615484, 0.19676377207796103, 0.31131517578164125, 0.36638640674750167, 0.4150600740727135, 0.4583495888173966, 0.39395684215339843, 0.3923730286891548, 0.4282345883484282, 0.381848704592333, 0.4496326134740398, 0.44112689649410053, 0.17449317670347186, 0.20730224922508078, 0.21440000129386894, 0.24120536539899085, 0.1958929581291028, 0.20750484896798338, 0.2998836832610787, 0.20531717479182676, 0.33559913174013145, 0.21559848703562923, 0.22857577599034817, 0.22981359703586024, 0.20304963230640083, 0.1958940803506961, 0.2144471774403448, 0.18663402917602268, 0.22630449152548793, 0.20802117935041808, 0.19728250376968803, 0.1930456651708874, 0.19547748802581177, 0.1988081520482512, 0.23033907043562685, 0.19836395730136047, 0.4967641766718023, 0.20190888161240284, 0.18004255484108267, 0.835150083622042, 0.8401022500099093, 0.8550872457446805, 0.15260284057790063, 0.14632928061029848, 0.15702742729589847, 0.17530498005177286, 0.17711010039042008, 0.1753016345574221, 0.5058149729721623, 0.7340782969802078, 0.7346214070286523, 0.2066999940155373, 0.2091281854217053, 0.2090252423098362, 0.20594308975097797, 0.20905308655266575, 0.18670586376181086, 0.188874955525419, 0.19775893284422186, 0.20225685894563972, 0.186033955996725, 0.18150795714057144, 0.18444230059074906, 0.18890240805851044, 0.17747453979985062, 0.18059007725537035, 0.0940723103808837, 0.08655565569106516, 0.07982309733084525, 0.0805119780001623, 0.08845792240760653, 0.08305226807293076, 0.08226106980467629, 0.1109490313729461, 0.11108153114564412]}, "mutation_prompt": null}
{"id": "b6572c7b-fe1a-4358-80cf-7af67a8d8f36", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, budget // 10)  # Adjusted population size for improved exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Altered inertia weight range for stability\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.7  # Narrowed cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.2  # Broader stochastic scaling factor range\n        self.CR = 0.85  # Increased crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizer", "description": "A stochastic hybrid optimizer with adaptive differential mutation, enhanced particle synergy, and elitist strategy for robust optimization.", "configspace": "", "generation": 45, "fitness": 0.2697788909447198, "feedback": "The algorithm StochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6123144043805637, 0.7108879162351767, 0.6896279754138563, 0.6208377388522279, 0.7067035656093339, 0.7052787570728731, 0.6059189883984704, 0.7089004358379285, 0.7116596929415198, 0.2269076919088031, 0.2386336011573228, 0.35895116314725606, 0.049930341918341004, 0.3526030286672318, 0.2962455673940151, 0.2505830769572013, 0.36046330801909243, 0.38743598651218203, 0.09789260922656462, 0.1237722390107665, 0.16579418604587026, 0.1147800570874088, 0.2792346616084914, 0.31962690998504695, 0.10563960409596707, 0.1536657283757522, 0.12897687494471954, 0.10559735066856979, 0.13768087686979003, 0.1248178553039263, 0.09093619863262414, 0.1091448012045525, 0.09136372219305922, 0.09623795447555639, 0.1217450411738491, 0.11188491394547162, 0.9785063718661993, 0.978481722640627, 0.9743633839292265, 0.9820556973198707, 0.9741761614888386, 0.9818892684809357, 0.972581112765796, 0.9718284023719409, 0.9719516644357374, 0.3092401847454177, 0.4155780534471575, 0.41218517817081246, 0.2830269132624744, 0.4514533890215441, 0.4231291940538837, 0.2950940250228343, 0.4336473989234705, 0.4121955164819352, 0.20713915497361757, 0.6460812652064419, 0.80025911381405, 0.5919905292921838, 0.330701661016343, 0.27472407325353865, 0.21076492876726338, 0.22343988759672861, 0.12401414742697414, 0.15742220519593397, 0.17882399364410828, 0.19397782754916804, 0.11175327376473143, 0.12289090804665337, 0.09612658451938683, 0.2618713973217558, 0.18008438052075837, 0.17973117867717214, 0.163918047596731, 0.18327207772657694, 0.20389808818389532, 0.18553035088510894, 0.21291843538332578, 0.19926702777379002, 0.1706964833317034, 0.20520822542660777, 0.09899483465185499, 9.999999999998899e-05, 9.999999999998899e-05, 0.006942707609808307, 0.0001822429668425496, 0.01257157207895232, 9.999999999998899e-05, 0.05190301491784555, 0.09008048406816305, 0.011422126191915072, 0.015836736261252593, 0.09075285432420133, 0.0647519963556813, 0.06690398668705022, 0.04357524440217331, 0.10541648499608469, 0.06747329970311733, 0.04924700321716169, 0.061561845230776124, 0.026861065463335443, 0.046177471306565354, 0.03566388069705495, 0.05812683613547287, 0.12311540875633742, 0.059848621454198336, 0.05891279262417315, 0.12060116199691617, 0.07445368920376916, 0.126128180086983, 0.21910923062656074, 0.18469469026030305, 0.08907902868143303, 0.11156885192820387, 0.22953550937000433, 0.047534690825134396, 0.21962475743804466, 0.0928663513181135, 0.44000903746375064, 0.5196439673653517, 0.509784639932508, 0.4682706319546214, 0.479244704723525, 0.5133010880357346, 0.45695227311353803, 0.5004649333906671, 0.5131014995068887, 0.11266904837179559, 0.15596125805277494, 0.10899027724197707, 0.10030900577415724, 0.14509426546337323, 0.12107462786614487, 0.1080933353850374, 0.1046223077809516, 0.11226757893972827, 0.1414506704185775, 0.20295936627605926, 0.17791204562498952, 0.17855375610688973, 0.16875835198664013, 0.2811563190322719, 0.13552447581827742, 0.17424062389487005, 0.35014732882298616, 0.2265919324861404, 0.38803959384861053, 0.4376208235328747, 0.2934108783670679, 0.4027985984833261, 0.3610863870210427, 0.3348616569332681, 0.4096983875016226, 0.278477408248465, 0.18893703676682616, 0.2220942509676388, 0.13162602001187806, 0.2724066347143651, 0.28613722388198604, 0.3007228447820618, 0.1731750141355327, 0.3183119072405838, 0.188706088208348, 0.19760441884006164, 0.2055733047092424, 0.19529595833157365, 0.24365075746928666, 0.21093575145233612, 0.19883582523103005, 0.18339199773903547, 0.2329619391561576, 0.21040426556776415, 0.23243582596898638, 0.19487707261541753, 0.21013528676755922, 0.1777303791781054, 0.3213645319586933, 0.32451886499920823, 0.2010586613038997, 0.21679733513803745, 0.3628566749404438, 0.76406056741237, 0.8137549105712818, 0.8544154715980318, 0.1295006274531919, 0.19417108599310218, 0.11643233056173574, 0.20907702908592118, 0.14220482952074331, 0.20698409610655744, 0.3270741422310185, 0.5392573082958279, 0.5222659115152049, 0.2044283246223385, 0.20861935189232572, 0.206104727693186, 0.48579125467670903, 0.15377201657285045, 0.6084837428155656, 0.1819566353961496, 0.18479766940880327, 0.1794876927732263, 0.17698426488526475, 0.19613906199019226, 0.18725115414093096, 0.1808598036101564, 0.19215805973235978, 0.17898997308867015, 0.07589758978368977, 0.08433991001359131, 0.0866608249503108, 0.08757419041949066, 0.11231119881861962, 0.10530105818233426, 0.08369219833062325, 0.09639163703896048, 0.10697847360545798]}, "mutation_prompt": null}
{"id": "137a48cd-9563-4999-941b-b73b26bc934d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 10)  # Increased population size for enhanced exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Balanced inertia weight range\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Adjusted cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Broadened social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.3  # Stochastic scaling factor range\n        self.CR = 0.85  # Slightly reduced crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite-driven synergy\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedAdaptiveHybridOptimizer", "description": "EnhancedAdaptiveHybridOptimizer: A refined hybrid optimizer integrating stochastic elements with adaptive learning rates and elite-driven synergy to enhance convergence precision and exploration.", "configspace": "", "generation": 46, "fitness": 0.266953178901715, "feedback": "The algorithm EnhancedAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.534305385836444, 0.6887685008203343, 0.6823516963698699, 0.5159150782675241, 0.7031959051055359, 0.7025955276049067, 0.5804077445329483, 0.6987441421634366, 0.6678997491006218, 0.11263605935542143, 0.28554153573814844, 0.23683415119353746, 0.1597930242237482, 0.2999368602182123, 0.29150920455982177, 0.19004780134255117, 0.35133696040286044, 0.009366490465743671, 0.09803149819715506, 0.155294500223789, 0.13462023108747212, 0.09269274483245193, 0.16139997436297704, 0.2013294799523897, 0.11116156661581766, 0.17106038101471, 0.10695404057170288, 0.1000235693485696, 0.11641154450690316, 0.11953140542840646, 0.08933330922529581, 0.11186582497542008, 0.11702531537170946, 0.08433742397531552, 0.11682618268195788, 0.12678979345047114, 0.9714201398302545, 0.9694425453017471, 0.9769757643131323, 0.9713100887832831, 0.9670688381846151, 0.9709845117949237, 0.9695507437157812, 0.9667305114151856, 0.9688242965032958, 0.2886959555817922, 0.41864661714790297, 0.38825057839074906, 0.27777471000434906, 0.41140790355859413, 0.4283854647268215, 0.2851178965894804, 0.44588094291392466, 0.4313440265550148, 0.5332856152161837, 0.21198686397128863, 0.6782781606393788, 0.2921255648315182, 0.15830036981940976, 0.16008708123011273, 0.39654134557074905, 0.22246373537884034, 0.7124898180654484, 0.14987995528811315, 0.13003216233925308, 0.18067246296998896, 0.11537280691298146, 0.11694444164422424, 0.10040223156505723, 0.15442489386361247, 0.19192792425190086, 0.11871263392024123, 0.14145025782895904, 0.1594614004891367, 0.19138405853896845, 0.11116094280328637, 0.1931344010559265, 0.20764701144965436, 0.15632326830514376, 0.2047058185695353, 0.21499362225750052, 9.999999999998899e-05, 0.06901587194465797, 9.999999999998899e-05, 9.999999999998899e-05, 0.0031082849170052107, 9.999999999998899e-05, 0.030811179877528017, 0.10147657910943586, 0.09045304123167663, 0.06968890335995492, 0.07493746420040515, 0.028482537643984673, 0.024147463103218025, 0.05190344171363981, 0.0480015261134904, 0.028197900380652174, 0.13799423462214877, 0.07993228214280823, 0.028890063308440017, 0.036095995490941446, 0.036664333887309164, 0.03593061876203463, 0.1413834450228817, 0.08484701638836034, 0.055469167585459944, 0.056794761696612794, 0.09160791487351305, 0.1504365181887395, 0.15414462706771226, 0.17468635064331306, 0.07724759095379852, 0.05165534397186533, 0.10659338004333097, 0.10490708451807607, 0.18953597753006124, 0.23022546465029314, 0.42312999033479404, 0.4840990373126005, 0.47958940504003245, 0.4341347745653903, 0.47796701104587525, 0.5002922305568587, 0.4363085381676203, 0.5008371576276809, 0.4930012975518865, 0.09779451195597899, 0.11394187704985548, 0.12301794652404441, 0.09876246235465791, 0.09380221612988604, 0.0917445345287331, 0.11356247450227508, 0.10821454337195446, 0.1245785046206489, 0.15525046430039746, 0.15442837452828084, 0.18371556584720106, 0.1519607575662758, 0.22445656848040463, 0.15644992935007962, 0.12339017237961158, 0.19835098388124628, 0.12793048658888495, 0.3137806200489879, 0.3865228950793276, 0.2563161262208681, 0.3184097864432254, 0.38227391377702313, 0.39757281292870006, 0.3163617157253248, 0.40941035236072587, 0.4031380125715135, 0.14719383204652348, 0.25711958183791583, 0.1853044950247077, 0.21337753763524292, 0.21047643538013272, 0.2543206631072017, 0.26447992751855987, 0.21067790976865441, 0.2021462892653909, 0.1989512782619115, 0.21867043623435833, 0.23152829838517142, 0.17398134193211112, 0.2308848788510106, 0.19041645344564861, 0.21124130575696165, 0.220293813805019, 0.22107586995687056, 0.21990744830090625, 0.2094814252732241, 0.34785315516673565, 0.17154631775639995, 0.2015972701531068, 0.1938324104529905, 0.22533186177377484, 0.38544943509894736, 0.17425109455188625, 0.7245145068943029, 0.8185822752227409, 0.82038468267293, 0.7400909481793647, 0.7897464846779962, 0.79528182828046, 0.14162376877213645, 0.15565870216255573, 0.14374503017403473, 0.43212119730116805, 0.7134643217671727, 0.7314231339513064, 0.45965899894155804, 0.16818450486350944, 0.20687356079574648, 0.16356256696127947, 0.12594927295653235, 0.2816496583343181, 0.19690467804908474, 0.1760784332958074, 0.18631051372239005, 0.17195680154405524, 0.18097140649669896, 0.18841346691305594, 0.19760490237026773, 0.17938757867207822, 0.18193290399523543, 0.07359214280178417, 0.0828251657051049, 0.09214459157804777, 0.1035967872692003, 0.10186646518206521, 0.11131952924818689, 0.08654050155335813, 0.11163151668776283, 0.11686364456213183]}, "mutation_prompt": null}
{"id": "1bd4ff84-69c7-42c1-85b9-e4744e5af52a", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 15)  # Adjusted population size for balanced exploration and exploitation\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Adjusted inertia weight range for improved stability\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.7  # Refined cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Optimized social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.1  # Fine-tuned stochastic scaling factor range\n        self.CR = 0.85  # Adjusted crossover probability for increased diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer integrating adaptive differential mutation with elite-based particle collaboration to achieve balanced exploration and exploitation.", "configspace": "", "generation": 47, "fitness": 0.28135044268858106, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.7266175743735095, 0.8029724422333933, 0.7593494171769156, 0.181682125973902, 0.7681832186832214, 0.18148083601747134, 0.6938754619906866, 0.7935155158364597, 0.776964800240239, 0.3220386872502726, 0.486811265071152, 0.03687251261940705, 0.2607202500686264, 0.47041771443631586, 0.47452473278002616, 0.3650160557132657, 0.566803486639941, 0.5304494944518396, 0.12370399038510549, 0.12482882778841431, 0.132927023225327, 0.15344858058230326, 0.2276802176997863, 0.07330006240931941, 0.08985731961315413, 0.13212843297484067, 0.1149156085629155, 0.09422189819005888, 0.10878890946768427, 0.12645012345201956, 0.12360577108616821, 0.14287014886719585, 0.11978145932559203, 0.10996848502998169, 0.1044999213404666, 0.09468903766055026, 0.980709098262066, 0.9789535993603082, 0.9797915410513238, 0.9867058684899552, 0.981294691000456, 0.9866666026725064, 0.9823576505262157, 0.9804767322952878, 0.9823434714924714, 0.38492165795283717, 0.5601543461833469, 0.5329052215467522, 0.38797187997648475, 0.5216692371405562, 0.14831606225046357, 0.3968639716105201, 0.5119494670336631, 0.5762024698981849, 0.5801546239910108, 0.7055456651625287, 0.2210430134924941, 0.21293899617380252, 0.623459142729577, 0.21639719700858795, 0.16911875726686032, 0.23160392391672302, 0.11628704885679131, 0.17567994312005752, 0.21276339360693797, 0.2219225034090695, 0.09354941493027835, 0.19382394648266077, 0.21473037625637315, 0.19930496347818483, 0.20133003315926246, 0.21996005732908908, 0.18279043598079903, 0.20846397727749044, 0.23596213653437215, 0.11554653038894958, 0.12474211474843033, 0.2347298643851231, 0.11778307606552574, 0.24865398907220637, 0.24598909388556345, 0.03855089121872657, 0.04872341155576543, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09459076187266091, 0.09511819365590668, 0.06313260401491028, 0.02644418728855147, 0.013953691218462683, 0.012545546084938408, 0.028386175596795016, 0.07648839875667657, 0.028211229492430157, 0.03686402138904288, 0.2472229617225582, 0.04173933796314011, 0.0649728667838001, 0.08305990230262994, 0.06753565361728908, 0.1688787587713192, 0.12344743687903847, 0.13310670679738612, 0.18343701675192214, 0.13758372023980447, 0.13006907172058002, 0.18020219553333539, 0.2726642342017769, 0.1061183979408088, 0.0506085953037857, 0.16726350414695168, 0.05154918944358655, 0.4665840784641475, 0.5199722785006493, 0.5050760867351894, 0.46834690096275433, 0.5343420888002306, 0.5351267536112976, 0.4951698555209043, 0.5481460560981595, 0.5581458885804228, 0.14662804639564742, 0.09565357591538248, 0.13133304915511912, 0.10202032409456019, 0.10243647010753032, 0.13641973159264797, 0.1527958461909038, 0.1342485720416331, 0.11173127752901257, 0.20427072616984476, 0.17302088552440642, 0.3801045945055992, 0.18481828650385235, 0.17446342569565731, 0.27634070615494977, 0.18220842261428505, 0.19976867535358356, 0.19993691623858834, 0.35703013885649526, 0.3511967321417836, 0.4113819633786038, 0.3582063250614024, 0.36398699034883397, 0.45358902944793444, 0.36432369074364923, 0.45018966533782645, 0.488674417406752, 0.1384489111738807, 0.18439612920348636, 0.1503041598001741, 0.17794360082650507, 0.18480680761355495, 0.33021363405567805, 0.2435100758241583, 0.34791822608367484, 0.22227558473373799, 0.21806597952941542, 0.20754834387966092, 0.2748375118725179, 0.21090492601519573, 0.22684886831868623, 0.23384723122675655, 0.2017055588069353, 0.21415760244741933, 0.21776992367260062, 0.4788093750685666, 0.6167524242470355, 0.19194519780651387, 0.2266788566805601, 0.497760324862326, 0.19512639774807228, 0.23457086459945575, 0.2269788285045914, 0.1995539318756251, 0.8119925945975808, 0.8677641529563953, 0.870445614600372, 0.16631377939507908, 0.16651152462988172, 0.16668101050753958, 0.1698105862903765, 0.168741550029732, 0.16991536661530826, 0.2996768017910385, 0.20558536410953843, 0.16117623591171593, 0.20828378190649477, 0.20888476458623628, 0.20891952028003868, 0.19727218692710335, 0.7611482249424322, 0.7083725728772412, 0.1814500287699572, 0.1845863155336951, 0.18710681317722688, 0.18235739287738184, 0.18557558401929053, 0.1839617862939853, 0.17669620604773262, 0.18379731461945115, 0.19411966709950645, 0.10549844216365711, 0.09155901230793062, 0.08991260333730244, 0.09194559553325676, 0.07334099731533428, 0.09359981674862916, 0.09591806355865062, 0.09520914134685066, 0.13253959983828445]}, "mutation_prompt": null}
{"id": "030eec84-1c9a-4ec2-9e31-ee0ca4132dac", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Slightly smaller population size for better efficiency\n        self.inertia_weight = 0.5 + np.random.rand() * 0.4  # Adjusted inertia weight for improved convergence\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.6  # Adjusted cognitive coefficient range\n        self.social_coeff = 0.9 + np.random.rand() * 0.7  # Modified social coefficient range\n        self.F = 0.3 + np.random.rand() * 0.3  # Narrower scaling factor for stability\n        self.CR = 0.85  # Slightly reduced crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.05, 0.05, (self.population_size, self.dim))  # Reduced velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution with multi-strategy mutation\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c]) + 0.5 * (personal_best_positions[a] - positions[i])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization with dynamic parameter tuning\n            for i in range(self.population_size):\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Boundary handling with random reinitialization\n                positions[i] = np.where(positions[i] < self.lower_bound, np.random.uniform(self.lower_bound, self.upper_bound), positions[i])\n                positions[i] = np.where(positions[i] > self.upper_bound, np.random.uniform(self.lower_bound, self.upper_bound), positions[i])\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedAdaptiveHybridOptimizer", "description": "Enhanced adaptive hybrid optimizer utilizing multi-strategy mutation and dynamic parameter tuning for robust performance across diverse functions.", "configspace": "", "generation": 48, "fitness": 0.22178572010686667, "feedback": "The algorithm EnhancedAdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.410787080343584, 0.6581632039055179, 0.5440494129155903, 0.2526049279436624, 0.2926678291367262, 0.26935689053755507, 0.37211385170557276, 0.43819382033763454, 0.42510785798837236, 0.003938634988052914, 0.09320706218545805, 0.15926976087957723, 0.12191850639902024, 0.2930939433747607, 0.17280974551471995, 0.06441300611834921, 0.2994357360594153, 0.18808179637810996, 0.08755616753358986, 0.14647262975773645, 0.13755060515933015, 0.08197753551456188, 0.09921526608145725, 0.11826438098203818, 0.09285925809795481, 0.10651828030580979, 0.11280563599005633, 0.1003599205994049, 0.10810103352349665, 0.11031854610494751, 0.10714652816372583, 0.09974841500841192, 0.09733087832355014, 0.051361839042733504, 0.08477799688402843, 0.10703288407508493, 0.9660551880015227, 0.9655383189095901, 0.9408293311857918, 0.9503736068150276, 0.9501384352868143, 0.9480407233872941, 0.9758612107488226, 0.9764142686355473, 0.9519785505848024, 0.22558270887023968, 0.19567881093649786, 0.2831210008058691, 0.14951304387891107, 0.2734653070112525, 0.19762398345292786, 0.16917297064033376, 0.19761565149125293, 0.24151281762790044, 0.19836890356381764, 0.24806683223341575, 0.6410195122965566, 0.16472250575522285, 0.19510723120086848, 0.23178889656826274, 0.2249633661853473, 0.22126987736734594, 0.220161735515074, 0.1270123697029476, 0.14778932387906685, 0.15439337789836172, 0.12402481901413609, 0.12962559830415044, 0.20263234620810244, 0.1429339420678989, 0.1347971918458567, 0.15278671421982049, 0.1014332517874531, 0.16642331572149216, 0.1694488018930037, 0.11841398653294732, 0.15094002545817764, 0.15838731053276656, 0.1413683446075542, 0.18362314769775134, 0.19956508042908072, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05751451664458895, 0.06216738734377392, 0.10370014500083058, 0.09286277380765329, 0.06723784917906506, 0.09654393152120033, 0.11366710520666023, 0.050945004899637936, 0.08294698725804939, 0.07365163878264158, 9.999999999998899e-05, 0.00016301650381955746, 9.999999999998899e-05, 9.999999999998899e-05, 0.017290672025092158, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11192948881384601, 0.10249681465516258, 0.029783109195970048, 0.01757859102860171, 0.1389616196544461, 0.03666384915794019, 0.04746783446624636, 0.03243321650156017, 0.02924216255320533, 0.35194304904181684, 0.44195000131371653, 0.5117620582439188, 0.2904120616068201, 0.3682657709121204, 0.31110343220054215, 0.4094923729961204, 0.46833898543269914, 0.4660963816308109, 0.10637833060813595, 0.08369770411204513, 0.1069084097734947, 0.07261009186332756, 0.1094774454316717, 0.07921117025482449, 0.0715279324550453, 0.08408005302125654, 0.1275400829049015, 0.1253843090179727, 0.2204631228413334, 0.18178949612812745, 0.14916604153127533, 0.16123964173473648, 0.14952597823420688, 0.14555802412716512, 0.1981850449833461, 0.1304372299794766, 0.2557770472403543, 0.2904893202173152, 0.27166751900816, 0.2907251758874999, 0.3031452859456992, 0.3144319423444548, 0.20921370849018595, 0.26987328996182824, 0.2338702276373671, 0.17567730783694502, 0.21238705830362326, 0.21609401739383083, 0.23909651406278432, 0.26150827884950856, 0.2448825589567526, 0.1888624647527649, 0.16146507469349458, 0.1639924223656799, 0.21866160394314982, 0.20782417997440394, 0.19873643525179718, 0.2000191943056826, 0.1978115793598375, 0.224287803270236, 0.19838883946294184, 0.2056780502302934, 0.19737141193348218, 0.19611758203786311, 0.3202276425719013, 0.19916363235676904, 0.18396339836289077, 0.2165210291345926, 0.23078278641225758, 0.16910634031903815, 0.3005215345191604, 0.18991114484278637, 0.4577636530369946, 0.7074033984378825, 0.7033555782709748, 0.304287740353979, 0.7633054538345546, 0.5424907376776286, 0.3316962162835403, 0.606184708599897, 0.49003464853713863, 0.27036718960443895, 0.29274878812494465, 0.17324485364509878, 0.193864294607765, 0.20765878072762312, 0.20698067836699252, 0.27994279081648443, 0.5329608361275185, 0.4767665505409229, 0.19911665966499337, 0.19957263358884192, 0.18278217487084192, 0.17365174798768135, 0.192381524103296, 0.1786267420179638, 0.1735828498917923, 0.17126981965937516, 0.18356526333932066, 0.0744650316707346, 0.08184931538645779, 0.07720789441668607, 0.07138825763307266, 0.08965883940481523, 0.08112684674530102, 0.09893909516688859, 0.0897980063708197, 0.0799360001352396]}, "mutation_prompt": null}
{"id": "9fb56654-3680-4162-b3d3-02ac572a40f6", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for enhanced exploration\n        self.inertia_weight = 0.2 + np.random.rand() * 0.6  # Modified inertia weight range for balance\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Altered cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Altered social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.3  # Adjusted scaling factor range\n        self.CR = 0.85  # Modified crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "AdaptiveHybridOptimizer", "description": "An adaptive hybrid optimizer utilizing tuned stochastic parameters and elite-driven synergy for robust optimization.", "configspace": "", "generation": 49, "fitness": 0.31232365211220564, "feedback": "The algorithm AdaptiveHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.7635395124573794, 0.8528749677891706, 0.8479241803253283, 0.7807879681506025, 0.8428261605742862, 0.843466346492735, 0.7597892621240886, 0.8572929071740467, 0.8524611998601849, 0.5005967908658332, 0.5206829337161685, 0.6474884748097665, 0.3639795426830206, 0.6705241313590665, 0.6634272396787932, 0.5205587127793792, 0.6934958368489839, 0.6591208868786124, 0.1268006460162101, 0.12009785871244116, 0.1415483939116704, 0.0910679102905475, 0.15783735256347775, 0.07083194347717037, 0.13023256963929686, 0.1437890308769484, 0.11011525776087783, 0.12666924165420101, 0.12215366511277082, 0.0867155801845334, 0.1204793831475175, 0.13446916904909523, 0.1486095961549907, 0.11935850414424443, 0.12620435190450485, 0.10881012613812058, 0.9792436280909225, 0.9717192033207714, 0.9792697151328135, 0.9819485377072567, 0.9746293620991637, 0.9804818152371629, 0.9826122298725463, 0.9803222420092292, 0.9821663655599244, 0.4416426901013317, 0.6758080819244694, 0.6730383764205773, 0.14927166938535041, 0.6751659155048134, 0.6982078027267844, 0.43890597077253957, 0.08873144664321753, 0.6973512177378132, 0.2199321925433615, 0.3671503018210377, 0.36639798738261375, 0.3601402343949185, 0.2098124202908075, 0.8791660700805981, 0.7390923066803965, 0.8529102093847287, 0.17494242470608168, 0.18496472223229166, 0.2609726669157799, 0.2965922943819791, 0.18985979673623565, 0.22602139817615596, 0.12238422183451259, 0.18784534282065657, 0.233285203827015, 0.27470828352850063, 0.19834956656446523, 0.22817059844403975, 0.13057531282422574, 0.20560292640475564, 0.13016787791292395, 0.28628100227285724, 0.21979143275034663, 0.2711849033344983, 0.28411231938143044, 0.031943969360679, 9.999999999998899e-05, 0.03790900758593274, 9.999999999998899e-05, 0.006153683933083132, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025002750741824897, 0.09382955592961606, 0.1053711266651044, 0.13865430646530275, 0.018306602509393644, 0.02703173267058956, 0.013862057058431354, 0.015409395637115075, 0.06984555671847115, 0.06054073099425583, 0.03981355714683943, 0.06021087408679682, 0.04559192085559971, 0.07813798134416883, 0.07508748425481104, 0.07063373640463577, 0.08765761849900178, 0.2136672554941227, 0.06756787475120996, 0.055622334661667994, 0.29036560500563824, 0.26260467276976296, 0.19413808713216285, 0.20959825527433773, 0.11110374802263778, 0.08979236595486584, 0.22385655131040716, 0.049117291823409515, 0.4918926613481174, 0.548949726259707, 0.5368569296475452, 0.5497713473866888, 0.6173869910381498, 0.6109263545816908, 0.5519648381363145, 0.5556009127979329, 0.5749087815483711, 0.1165454500487807, 0.08457564962927377, 0.11781994554682185, 0.10014148124359767, 0.15122532532049204, 0.10039793316134304, 0.11253199378653422, 0.17834000543982398, 0.08891762602402964, 0.14424993966803745, 0.21251710824062842, 0.17299761863412355, 0.1757146853010212, 0.34470063714863897, 0.22587619061857234, 0.2311526155032243, 0.2738695697523995, 0.25608212035824596, 0.4009012974172721, 0.32641099920057015, 0.4050279942237346, 0.4142377509959384, 0.5069593163123634, 0.5193992790041226, 0.44601504050550245, 0.5005729622381652, 0.26753857755635635, 0.20883191423335856, 0.22313097760223477, 0.23710955626320585, 0.3097467871919445, 0.3104951981905909, 0.25988467031559936, 0.13465202786375063, 0.2220569929886187, 0.13847446011335274, 0.2119041976850644, 0.20185433031823408, 0.21418909264909236, 0.21394494223221328, 0.2007580107203758, 0.19355575959039384, 0.20663456758959386, 0.21432691392562486, 0.21678870406060258, 0.34064778080616676, 0.21926174648804586, 0.1810716967253163, 0.19302709381911953, 0.219130573731955, 0.19626210169725833, 0.21894638390439136, 0.23644839671026407, 0.20643317323942756, 0.8581009154866724, 0.8899553382813271, 0.8977832877742006, 0.15653613690805834, 0.8590179977884804, 0.15749843447711742, 0.16961716506993674, 0.168530307834166, 0.1693920050661223, 0.5284726886373927, 0.6553621770344622, 0.17262906297503544, 0.21007465758130084, 0.2113103964634513, 0.21152203277142956, 0.6332399004669598, 0.7847645257906376, 0.15516524633702322, 0.19159241853028586, 0.1948247148707556, 0.18087829427682012, 0.17219405504150276, 0.2014875958517136, 0.2075428380530452, 0.19075748812477555, 0.21326037868771797, 0.17703038956158013, 0.0856541455456108, 0.08921862748055553, 0.09138152422377022, 0.08632432620859198, 0.08779877224341504, 0.09396154797388934, 0.10277221480200238, 0.12675666728423185, 0.11297173587827236]}, "mutation_prompt": null}
{"id": "60c0d17c-de5d-48aa-a7e3-16ff7d0f84df", "solution": "import numpy as np\n\nclass EnhancedMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for improved trade-off\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Balanced inertia weight range\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.7  # Balanced cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Refined social coefficient range\n        self.F = 0.3 + np.random.rand() * 0.3  # Adjusted stochastic scaling factor\n        self.CR = 0.85  # Slightly reduced crossover probability for refined exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedMultiStrategyOptimizer", "description": "An enhanced multi-strategy hybrid optimizer combining adaptive differential evolution with information spread mechanisms and elite-guided PSO for dynamic exploration and convergence.", "configspace": "", "generation": 50, "fitness": 0.29031204699350543, "feedback": "The algorithm EnhancedMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6591525132816229, 0.7971407213304064, 0.7571275744542034, 0.6645564307982972, 0.7850160393409736, 0.7454113915647168, 0.6863864250479401, 0.7825444065082765, 0.783017000915002, 0.3022430412666258, 0.39204594105376767, 0.26760439042945916, 0.2622703814586823, 0.4894658714733582, 0.04253062962207588, 0.30470665843119193, 0.5528532397869792, 0.4900665261741721, 0.12544556334965984, 0.158525253321241, 0.11174691049053653, 0.06975413460982782, 0.1209808030067232, 0.12672914069734853, 0.0976841757775403, 0.15160884891722848, 0.1607518221497528, 0.10474773468358256, 0.14614742045073048, 0.10202035929884057, 0.08541930763140448, 0.10473444889937022, 0.10288576058999077, 0.09954306144596359, 0.09946204516483026, 0.11760667580365447, 0.9812114913689388, 0.9788818019162898, 0.9790850626621271, 0.9816309056044364, 0.9817743136093722, 0.9814990108810769, 0.9822418635453192, 0.9813293492164936, 0.9817287539408881, 0.3669642250430456, 0.5717825547571742, 0.5313057222205992, 0.3273668928344218, 0.48299644184066715, 0.1505095003404302, 0.08887080690442728, 0.5455379136120064, 0.5353708886998583, 0.3512530605314862, 0.7076586854055789, 0.2216203001323641, 0.20713078838985277, 0.27409570610064804, 0.27050741225158803, 0.6334970456691872, 0.7384167729683004, 0.7725980022197523, 0.17473710130605336, 0.21407045246000334, 0.3122679810290929, 0.16200575997189992, 0.21561523082009293, 0.21013040062515442, 0.1608832855138438, 0.20806555107960878, 0.2332340178669161, 0.1790837343620233, 0.21132758723674183, 0.20585824484040627, 0.16411396925336996, 0.12827356207913743, 0.26915484139471857, 0.18342567949298327, 0.20879203593304596, 0.2273733007883202, 9.999999999998899e-05, 0.03975684687261416, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.010469458293971945, 9.999999999998899e-05, 0.011636044237136378, 0.040175167274994816, 0.08849711025845541, 0.009958716239910959, 0.026955815522967552, 0.01532599649218902, 0.036258736056360985, 0.17111514042908604, 0.03665733888760658, 0.028702350438088997, 0.053435280542438734, 0.04209443016934289, 0.05304051701722878, 0.06426859166150078, 0.08986359243741737, 0.1014699726416809, 0.0855759794373736, 0.08397089031152649, 0.05419539791452099, 0.21581792186505278, 0.14803638368882932, 0.12609772886145, 0.05714399115649216, 0.0596264547784332, 0.05320216607046113, 0.07132051059529354, 0.047678222514890845, 0.47846260263682494, 0.5466182555942893, 0.5394868304668916, 0.49519387074190013, 0.5171136703424477, 0.5379700110197282, 0.4547891822242307, 0.5240254211812216, 0.553335941146424, 0.09566380737058588, 0.2607043344211666, 0.12229231736602542, 0.08262870286091417, 0.10796484741752432, 0.12837702178813726, 0.09599612956233028, 0.12193549205585319, 0.1302848148956789, 0.20727695396906365, 0.20908939193890197, 0.2724824054388758, 0.15802485421669676, 0.17645766971698917, 0.3251081311626034, 0.21314381337499155, 0.21359069251599117, 0.22129821863862065, 0.3370738407422552, 0.45507481055400023, 0.3810285434049846, 0.3561975917271234, 0.23347574122927284, 0.3895145197567128, 0.26340973871496487, 0.2754447558064024, 0.5116852670727067, 0.18383278650432988, 0.23412073631018815, 0.24287888639210642, 0.2819051014339018, 0.2976333991557011, 0.2872263820552181, 0.2760008987773611, 0.2360815992011014, 0.25848969408411926, 0.20557479200881357, 0.21141147733874066, 0.2196593502571612, 0.1939463842211776, 0.19340492014379784, 0.18394196462322765, 0.2247933020738926, 0.2104475319249829, 0.1964007482668817, 0.2888123637982636, 0.6107899824588302, 0.20046784926053884, 0.19366887184813253, 0.23267824188487352, 0.20736208073434614, 0.2405044378185207, 0.5479196044635988, 0.182272914941914, 0.7863522884238586, 0.8554490822476168, 0.8565147935269701, 0.16442005196240583, 0.1976192925010335, 0.14598236294178712, 0.7530871593243919, 0.1701393846185396, 0.8486088130284551, 0.16801255064315812, 0.698333536776512, 0.6475479510548066, 0.47513879299867, 0.20935034083490323, 0.20776159291772234, 0.18131958846526353, 0.20517657547145152, 0.7221217986013833, 0.20074385942723616, 0.17589680749896508, 0.21150292097222734, 0.18689599045269945, 0.1817820298004903, 0.18748622885802946, 0.18958545961053885, 0.1687418561869557, 0.2000169812227255, 0.09598993158280933, 0.0792581829645711, 0.09626228668886883, 0.09968287473879589, 0.07820119475740661, 0.08495060572834989, 0.07494931642430891, 0.10570715948445486, 0.11410860219073327]}, "mutation_prompt": null}
{"id": "d85c07da-aec3-4be0-b4a4-8edb1373db06", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, budget // 10)  # Increased population size for improved global exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Modified inertia weight range for more balance\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.5  # Adjusted cognitive coefficient for variability\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Refined social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.3  # Refined stochastic scaling factor range\n        self.CR = 0.85  # Adjusted crossover probability for balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizer", "description": "A stochastic hybrid optimizer with adaptive differential mutation, improved particle influence, and diversity mechanisms for enhanced exploration and exploitation.", "configspace": "", "generation": 51, "fitness": 0.2701934294631792, "feedback": "The algorithm StochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.5900762382562321, 0.7044971720680753, 0.6975131012511737, 0.6180467331693823, 0.7269880271163441, 0.7026091855641856, 0.6153084935149233, 0.7235700118291648, 0.7041181894805826, 0.21341155254166666, 0.3910390175986621, 0.3369808271406337, 0.2676725745784646, 0.36059984742921036, 0.3466553328130889, 0.22538482167699836, 0.4061020993459975, 0.3479705887534891, 0.09854226015927148, 0.18823196122139196, 0.11470133857160947, 0.10220587180282725, 0.13759619618865815, 0.12434742725913461, 0.10116498250289607, 0.14314431726324273, 0.11525390648456757, 0.095891685554375, 0.12218664072412977, 0.11165718784910572, 0.0806314768687082, 0.12094518676413879, 0.1074517594912946, 0.09534481131608585, 0.12128905131198575, 0.10159100655682773, 0.9741007103253946, 0.9730207260877956, 0.9746336333842501, 0.9773213202902059, 0.9741571477544417, 0.977158329291653, 0.97086359661256, 0.9694641992991812, 0.9723913274063407, 0.3193658394940446, 0.4259856752122635, 0.42401919677427546, 0.324717016318266, 0.4553973139960408, 0.46576540067424255, 0.3182315279435235, 0.45681762647963986, 0.39835594378984684, 0.5471154143774148, 0.3587609317950705, 0.6854620667469429, 0.6644679079801579, 0.34820248768225825, 0.3465118600157915, 0.46196719565068756, 0.23049812882291443, 0.12625438659950883, 0.17380709611841938, 0.26834511199908717, 0.2137906191868857, 0.16871637654136595, 0.17181404548175072, 0.18604515252301834, 0.16290828561865367, 0.1854593718167099, 0.27648306636952247, 0.17395275160365742, 0.1643034381214058, 0.19293079905159383, 0.15453921054426012, 0.18705251481255936, 0.10551785304307104, 0.17785422651074745, 0.12611131396464248, 0.21533942328170175, 9.999999999998899e-05, 0.06155336852293802, 9.999999999998899e-05, 9.999999999998899e-05, 0.016557247440777578, 9.999999999998899e-05, 0.033123312204133226, 0.06881092226351715, 0.0930873611890205, 0.03982898192469442, 0.1034998157985334, 0.020487007400044388, 0.05071905772520857, 0.058231088262976294, 0.013849063289660957, 0.07075464434207446, 0.0508634576712913, 0.08773486636202177, 0.02078056270219153, 0.03467737082803379, 0.042034048791684486, 0.04861613164856804, 0.11830780356989712, 0.06950433415751578, 0.07839362658191751, 0.05218047996831976, 0.09032023718491455, 0.17453265219231584, 0.10667670631775727, 0.193056823312586, 0.09751051204485117, 0.19428119040320813, 0.03490631912438036, 0.04621672388243936, 0.05315333927781374, 0.047430176622637155, 0.4460719998855649, 0.47744711305033183, 0.49281376821609557, 0.44627297925977805, 0.48712444847490244, 0.4810040541113819, 0.4588099813128582, 0.5007391774146366, 0.488597650721022, 0.10614679534246918, 0.13732815001255438, 0.11603745947811772, 0.1001191052343745, 0.12723789218913206, 0.11406522431902832, 0.08204732758543998, 0.08888910373291015, 0.09922215305380999, 0.14306048912334446, 0.13551710001846118, 0.18847538665956332, 0.17692779333731978, 0.27060680273406146, 0.1631423982440019, 0.1421885151976916, 0.25943413356336376, 0.17954332919947336, 0.332647883254107, 0.3498932695222037, 0.33925492462348206, 0.3355146551182153, 0.41232847287173113, 0.40919210627760316, 0.3384943725721443, 0.39095709994847216, 0.3751185440575774, 0.1600136551254815, 0.26245551163001, 0.2607113711403627, 0.17719043573242377, 0.2920011883044207, 0.27453861174435845, 0.24900464513685616, 0.3239009762753078, 0.3150393506963114, 0.19736313029058794, 0.2019925412465693, 0.22287275762227754, 0.1895191765903631, 0.2307314063237076, 0.24204282131617727, 0.1914711311012759, 0.24919705932811775, 0.20829107890714826, 0.19558014297611703, 0.22975231113452488, 0.19700214059957055, 0.30342462671862, 0.2111166362633573, 0.2004157960893157, 0.2537339934273277, 0.20185088440903864, 0.1871159955936994, 0.7636743053720706, 0.8402927502772085, 0.8392298835980326, 0.13001135739201908, 0.12984918879309548, 0.13023548072076063, 0.2026421959159418, 0.20383855371996928, 0.20487927472551992, 0.4513823262964982, 0.6835110691508993, 0.6122460631236977, 0.2048612816283646, 0.21028541010569313, 0.20619236220080261, 0.15277614100631176, 0.6014486684497244, 0.15216168544276676, 0.17688784296016824, 0.18697597997706794, 0.19193302771841358, 0.1956617231494907, 0.18716709268290954, 0.17477974382244488, 0.1814863177499807, 0.17378515477481649, 0.1846692175300877, 0.08165631582168009, 0.09029849579706462, 0.09160701317557818, 0.07937764854471496, 0.09191869185399648, 0.08329837424986541, 0.09368029770747766, 0.10139300976526666, 0.09630810098554687]}, "mutation_prompt": null}
{"id": "33946318-93a4-43c3-90ba-438c5286b854", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 12)\n        self.inertia_weight = 0.3 + np.random.rand() * 0.6  # Adjusted inertia weight range\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.7  # Adjusted cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.7  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.3  # Broader stochastic scaling factor range\n        self.CR = 0.85  # Increased crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))  # Adjusted elite cooperation factor\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer using adaptive velocity modulation and elite cooperation for improved convergence.", "configspace": "", "generation": 52, "fitness": 0.29201819827556236, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.7002368014541079, 0.8059533906610974, 0.7770033325682033, 0.6898197515494834, 0.7918223393798257, 0.7765366648830144, 0.7122535907435309, 0.802538786735987, 0.7621473427825943, 0.3260808747461206, 0.5234692083279563, 0.03577163001094141, 0.03920188610089881, 0.5290349324328354, 0.4758407287246571, 0.30209303595334536, 0.550795321690384, 0.33101449891361634, 0.1413033967614199, 0.14890606614783175, 0.14767182736683448, 0.06889667562739321, 0.4862844595141199, 0.17845068991602964, 0.16045513196568206, 0.14843693297050808, 0.13216730849303604, 0.13582578844318083, 0.11978517129851718, 0.1071836015878096, 0.13068321305457142, 0.1054608007559582, 0.10311268242686056, 0.106523112334173, 0.14660337799084244, 0.10153209266801189, 0.9778734058469222, 0.9754276351452699, 0.9774362945576471, 0.9778458360103353, 0.9743101164881595, 0.9770126306578021, 0.9772265294957144, 0.9680166391533029, 0.9760498891732957, 0.4275119873504646, 0.6082196525910972, 0.5827708181215282, 0.4078772685769987, 0.6010075945238489, 0.5776477200036171, 0.39562010849636076, 0.5644452026363544, 0.599237901582313, 0.6917653233283096, 0.2212927406009091, 0.21747743739189762, 0.26765069689701293, 0.20781033182865682, 0.26690916118129737, 0.22621207363783902, 0.739945856947297, 0.7410444484854828, 0.1789745145319479, 0.2374839967377187, 0.12438281104316196, 0.12363138594384149, 0.21609444745108375, 0.23418635946560862, 0.1818676375422481, 0.22015070503537526, 0.2617008288531968, 0.18965766516613503, 0.1181322007094946, 0.2525372140571659, 0.1730694916404717, 0.23515888546708819, 0.24784343891522254, 0.13155592913237046, 0.23832604986535855, 0.1035207692462583, 0.002717901656917765, 9.999999999998899e-05, 0.02984759882276189, 9.999999999998899e-05, 0.05153155518772223, 9.999999999998899e-05, 0.0022308166711325628, 0.040075429577822286, 0.01741478382136863, 0.047896607883066045, 0.13741749971256034, 0.07323943816826084, 0.0389336033841744, 0.006480962172022875, 0.016357700991907254, 0.06978441793771162, 0.1317135799868514, 0.05496505860074563, 0.03894349706958855, 0.04266671752340556, 0.04409743621620965, 0.054390160572215795, 0.06637292158782215, 0.06576694071823408, 0.07886730539756481, 0.10092749888355534, 0.10301649466649887, 0.06911800809814794, 0.13754306802976646, 0.08719178808611272, 0.202679340513785, 0.12378692219563925, 0.11399423108329976, 0.05270453092797556, 0.10699216590552063, 0.05177154170374254, 0.4657976425852408, 0.544272365464153, 0.5149755089357793, 0.46765388519691364, 0.6015717363069644, 0.5216367117886622, 0.5134702661588164, 0.5327009155703621, 0.5741624694745059, 0.15271831450429396, 0.1447659540492403, 0.11906399062752404, 0.1162593557095859, 0.43934271897137167, 0.13985409166668084, 0.10043656079773422, 0.15340507246963275, 0.10393831338650728, 0.18662919514394916, 0.3176846957536609, 0.2954981927142032, 0.17729297895852691, 0.278280238285453, 0.29687714193159265, 0.2728697688078522, 0.19368364320709075, 0.3131741288989851, 0.27123338829904575, 0.4126452183265201, 0.2542713184184313, 0.3864817681586158, 0.48367045589526914, 0.2826312845208153, 0.3877892156961209, 0.4288219393996091, 0.4017832886964757, 0.27650207022996154, 0.2951618092412267, 0.2005040266853737, 0.1754852123690418, 0.30040230389940004, 0.2707176546494776, 0.13533131311537727, 0.17560446162429544, 0.20949908134501505, 0.19805817124563618, 0.22448316892848463, 0.21947207046274142, 0.18671124926368698, 0.23046319268131965, 0.2020475263515159, 0.19345999991712703, 0.21684581281978277, 0.21971475189546208, 0.39372201330453005, 0.20115283330617484, 0.19029427490192607, 0.2117110317747276, 0.2318909996051448, 0.19167435777008635, 0.19687540007373272, 0.20512032769969013, 0.21826640077917214, 0.8260203945302331, 0.8889700100438622, 0.856285340213878, 0.15750080687776158, 0.19413738876242081, 0.1562811873313461, 0.16748134455177666, 0.8123295764606486, 0.16647540305668695, 0.5070482631687566, 0.6806934773265585, 0.6408330973676589, 0.20884541603374762, 0.21069195950728126, 0.21067662230471418, 0.19209785281003677, 0.20531465930842474, 0.18368281384690321, 0.18921659828760606, 0.19412365740953397, 0.18432769709968755, 0.17893220800553644, 0.18193682769873687, 0.19653787687582813, 0.17635640893662985, 0.18572130835160205, 0.18145365254891344, 0.09546929833679874, 0.08924067471659258, 0.08398917494074742, 0.08502747414528622, 0.0971234281083101, 0.08350872104929963, 0.10930776219865734, 0.11665958950862387, 0.10656400283511025]}, "mutation_prompt": null}
{"id": "4eee2dfc-a6e8-46dc-a162-2c45fcb75a49", "solution": "import numpy as np\n\nclass RefinedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for better balance between exploration and exploitation\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Slightly modified inertia weight range for improved convergence\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.7  # Adjusted cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.1  # Tweaked stochastic scaling factor range\n        self.CR = 0.85  # Adjusted crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Increased initial velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with diverse elite sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedStochasticHybridOptimizer", "description": "A refined stochastic hybrid optimizer using probabilistic adaptive differential mutation, enhanced synergy, and diverse elite sharing for robust optimization.", "configspace": "", "generation": 53, "fitness": 0.29344365684032275, "feedback": "The algorithm RefinedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.26.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.7097772304793564, 0.7883438867368646, 0.772281452106124, 0.6993298212796855, 0.7824061607321872, 0.7800714426167275, 0.7092505281878502, 0.8092018157368663, 0.7837276445318967, 0.26853692698377596, 0.5525631565276394, 9.999999999998899e-05, 0.2543208910521849, 0.5099934916489197, 9.999999999998899e-05, 0.3560420558804672, 0.5323043195744307, 0.5670994775630738, 0.12893069262859114, 0.16516414074966634, 0.15873913909191528, 0.1353119864506811, 0.31975981292867905, 0.13439867530980643, 0.11444158246430614, 0.11604237028803277, 0.1551189553697846, 0.10190646238966727, 0.1081948929649238, 0.11101320413644022, 0.12554135716186643, 0.13096595858759408, 0.1428023340322545, 0.10419696533165757, 0.12886706179361485, 0.13441653707288292, 0.9809602870743963, 0.9726673584485417, 0.9784795674232364, 0.9815745567165839, 0.9802355904407642, 0.9813448920132093, 0.9816839164425613, 0.9811262349303382, 0.9817600348504536, 0.3719746403185663, 0.5434072526049352, 0.5692688206983799, 0.14644975650397662, 0.5723620877586015, 0.14986204055592256, 0.3885554536366409, 0.5675384368561248, 0.6043433172603703, 0.32773639833530155, 0.4966550099575847, 0.22529159675486476, 0.3430771385888116, 0.7610738298407247, 0.21120163281993343, 0.6624599581011317, 0.2288966998451294, 0.814906196110271, 0.16969046280878208, 0.20626003490661748, 0.21872433941972402, 0.18606855384892917, 0.2321641164047037, 0.22000363437690984, 0.19260416511347134, 0.2141026362160171, 0.22931347078204367, 0.17361435215684617, 0.1987982875840787, 0.2890871206307669, 0.1806026500792659, 0.12741126774375355, 0.25345828763120437, 0.1959307222683888, 0.24100336501571562, 0.24759769078795268, 0.010544653242812951, 9.999999999998899e-05, 9.999999999998899e-05, 0.017792908093455462, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04001952326274971, 0.12103649381986092, 0.10012603083556804, 0.015006258112586712, 0.03559037229493678, 0.028977296035410993, 0.08808653949420164, 0.09332699869965566, 0.1072664808038788, 0.04658683551447995, 0.042833964854655515, 0.04198001985596711, 0.1403902758045601, 0.08825189293392866, 0.0713921243084713, 0.07462350605064638, 0.16504184328084526, 0.0627033093909396, 0.061002878727057785, 0.08130969549066436, 0.04136717314992289, 0.03595659847177446, 0.2038308458093705, 0.21536695833354869, 0.08641450373827686, 0.07816925263719021, 0.07782315129285866, 0.4631685079293516, 0.5025226278842416, 0.5633494435046683, 0.4950183708891853, 0.5397082616114748, 0.5495138741254056, 0.46592116344715373, 0.5296164313073488, 0.5714248605255268, 0.08801235587615297, 0.1112399916819502, 0.08523460695856955, 0.10393928656340523, 0.12550913993308876, 0.12970480044106203, 0.15501395739777346, 0.10822881426500863, 0.10406191729445036, 0.16546383915241547, 0.13638809491188764, 0.42100326556686274, 0.17775148365086768, 0.22375344084143944, 0.3164935486292737, 0.17068578130074707, 0.2133242124603698, 0.1442827501241405, 0.4031458212169906, 0.37856788768194904, 0.31633163352594207, 0.3672101156343106, 0.42455290810235746, 0.3419998448659598, 0.388294883861674, 0.32657104583390584, 0.5064522076682398, 0.14367154447332742, 0.19247538911702244, 0.18916845601233068, 0.24421622225577733, 0.2736336243477836, 0.32814234083505744, 0.12452011445194289, 0.13608455456185442, 0.13607681241024006, 0.20025014712311984, 0.23872125588307913, 0.2195198146343974, 0.1950294456620617, 0.21917095489931127, 0.19364207502677078, 0.20838270180055274, 0.21388547055004858, 0.24206404919347502, 0.35449178250913427, 0.5885212404022491, 0.21372790262393615, 0.21039165968577456, 0.20130225484246178, 0.19523908304380733, 0.2006419403346148, 0.2175787170836907, 0.239848166135184, 0.7760138558637264, 0.8403606789802809, 0.8574048860374981, 0.16497794706426827, 0.8201078814737195, 0.16544055829099236, 0.16974995298487972, 0.16931280884992028, 0.17012203469296217, 0.17557845030726404, 0.16779317302328034, 0.6717947913716679, 0.20614055856657232, 0.20937696633724268, 0.8181037798411164, 0.619997025466984, 0.7061073007968856, 0.6866392169949236, 0.1781311456334551, 0.18178905801160095, 0.1862440544570082, 0.19037075349423271, 0.18824169887118292, 0.18308770786713346, 0.18129458326011927, 0.1859548042492638, 0.20406686104157157, 0.10581605058767674, 0.09067654098755029, 0.0916489607284271, 0.08895940797956736, 0.0839589116633973, 0.08813358373628233, 0.08222040413581633, 0.11452325730460944, 0.08372265259926548]}, "mutation_prompt": null}
{"id": "1bf0e29b-ef81-4a3f-87b7-45213b38cd0f", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Adjusted population size for more intensive exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.6  # Adjusted inertia weight range for stability\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Expanded cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.3  # Adjusted stochastic scaling factor\n        self.CR = 0.85  # Adjusted crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.05, 0.05, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with multi-species dynamics\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer with increased synergy leveraging adaptive differential mutation and multi-species particle dynamics for robust optimization.", "configspace": "", "generation": 54, "fitness": 0.2884471021371387, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6368806798070856, 0.7867412480715134, 0.7675268587847556, 0.6385211052613411, 0.7727103954913469, 0.7514240146871354, 0.6230780521457103, 0.7888730966367488, 0.7698536919691721, 0.32359844244532565, 0.48232211725832963, 0.4468718140796043, 0.08761829358830342, 0.45783938978419825, 0.46174194663281964, 0.047891565054998475, 0.5222234226563552, 0.05303321999797206, 0.10460702038671765, 0.16457772032184892, 0.14175928199577614, 0.13605408548893627, 0.12222975067299302, 0.14123180185745354, 0.1061772019001781, 0.12707558452706103, 0.5007659127933823, 0.10170228190357089, 0.11222352101774236, 0.1025228023579623, 0.09809782182132898, 0.12923397853971963, 0.09002197975882786, 0.11350118473097559, 0.12906201799912864, 0.1016594945000161, 0.9777956542002402, 0.9744473641968379, 0.9775663151347959, 0.9780454838365623, 0.9681120381656989, 0.9745383024283175, 0.9772064334829164, 0.9747211829966668, 0.976392943867883, 0.3618583764145802, 0.5591742187102038, 0.5548197612524626, 0.3273191447141587, 0.5187648574123481, 0.5301450297640703, 0.3420416713182255, 0.5385013050647831, 0.5406272983629452, 0.44687728241583635, 0.7239751224804378, 0.3597887434397109, 0.2654417054483048, 0.210117153196827, 0.19333656896697493, 0.22108165000177338, 0.8335310032715701, 0.746296567585985, 0.15388273433018074, 0.21430797436257398, 0.21476400469014412, 0.12163124897935107, 0.20382721290196482, 0.12309219700068497, 0.1383141467923198, 0.21979030310954206, 0.12672136923266064, 0.17780744480654231, 0.2090474405854934, 0.02206362090186298, 0.18752681189497067, 0.21709018969520189, 0.187772495358408, 0.16056992473545328, 0.22007283718573378, 0.1542193798394832, 9.999999999998899e-05, 0.00391055163579368, 0.00010111935079948342, 0.01999516062258022, 0.018488133033119802, 9.999999999998899e-05, 0.003000970037908113, 0.046294948927721236, 0.0061045447839421785, 0.04345258083648351, 0.1334385738113789, 0.12737487239257805, 0.05048677265854806, 0.12258494775974837, 0.012353454420946375, 0.07521755827552301, 0.051819166554825324, 0.09517395093842351, 0.11300942216645071, 0.041629185230805166, 0.0400616394577602, 0.08147609416580348, 0.09974813128055904, 0.13592380669093995, 0.12374069562327239, 0.0845912742546463, 0.08328668637648806, 0.1425400711684448, 0.04450481496371539, 0.10068478783566115, 0.13049265362928764, 0.14727484092801346, 0.13174844371120475, 0.046463915123935995, 0.18763097240747195, 0.04693362089643194, 0.46069572733062947, 0.5078054481594587, 0.5180031894421155, 0.4646952193111781, 0.5556440768113873, 0.527775502908155, 0.4499484046995531, 0.5247601998819851, 0.5411957928311669, 0.09414299905915102, 0.11010894381267011, 0.10934418118405065, 0.12743876759156614, 0.1400446617435549, 0.1272367059730246, 0.1015350701413894, 0.12462811953102537, 0.16265048244864244, 0.3256576225419281, 0.22256865783261903, 0.15643402321590094, 0.15875533658680685, 0.20714914272354823, 0.26725974790945484, 0.14833787225339856, 0.13649203251660658, 0.2788350725307466, 0.3375300122463252, 0.35977931303407384, 0.36654454860597496, 0.19565611679672668, 0.40016010562407156, 0.3784577956189811, 0.36155803744795656, 0.46741902513261824, 0.4815988178166536, 0.26164302333199196, 0.3529935991479757, 0.20193686802811595, 0.14350551778413012, 0.22896265045957653, 0.24101487360696638, 0.2478140863293623, 0.2687479470717796, 0.2088106565009742, 0.1865508216923223, 0.22747221629553283, 0.18848422148042232, 0.1950913823035736, 0.2043755618765245, 0.20748065158945406, 0.2193572941052585, 0.19750419160265842, 0.24938425110514717, 0.3885093189324762, 0.6419285919954114, 0.18769693733970783, 0.2187017777984579, 0.228497848876551, 0.2032878269573576, 0.19323378278806513, 0.24064446608735846, 0.20299263875501283, 0.8072238264973151, 0.850980617861393, 0.8769002566097276, 0.1967576634256457, 0.19884076401286965, 0.15523606264305434, 0.16556714639087788, 0.17579753224290795, 0.1681361272488361, 0.37296503341958376, 0.7703982542799659, 0.6326895230050169, 0.28803728225205405, 0.20983940859044647, 0.7575737119377042, 0.20551753718372412, 0.7434668637073047, 0.1918186759628765, 0.18461871484901815, 0.18570811004924226, 0.17986064150725634, 0.19173033395360495, 0.19186210192041175, 0.18326306880737842, 0.1828997132495107, 0.18921510850933032, 0.1883390392203942, 0.08915405170714852, 0.08268526879096039, 0.08750186139325344, 0.06717555378749263, 0.08784211525708796, 0.07140257076016909, 0.09927032172825545, 0.0877341596561646, 0.1140795886554804]}, "mutation_prompt": null}
{"id": "d7c9fc18-4035-4a55-911f-b59cccd3b6e5", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Adjusted population size for faster convergence\n        self.inertia_weight = 0.5 + np.random.rand() * 0.4  # Adjusted inertia weight range for better balance\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.5  # Altered cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.5  # Adjusted social coefficient range for increased synergy\n        self.F = 0.5 + np.random.rand() * 0.3  # Enhanced stochastic scaling factor range\n        self.CR = 0.85  # Tuned crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 5)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizer", "description": "A hybrid adaptive optimizer combining differential evolution with enhanced particle communication and multi-level diversity control for robust optimization.", "configspace": "", "generation": 55, "fitness": 0.2524770520960585, "feedback": "The algorithm StochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.23.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.5217352732768874, 0.6734355271027992, 0.6584763039510559, 0.5029067479085119, 0.6700864118137633, 0.6767908305946699, 0.5727779477635055, 0.6749905447351672, 0.6369625790237765, 0.07276312398548546, 0.2838638816024063, 0.2704926149856307, 0.056107437149009676, 0.2980086809838546, 0.2533103450649755, 0.15546124229547642, 0.24983699269942694, 0.014026862944678031, 0.09880339005836081, 0.12282153405394669, 0.12929529822379449, 0.10484646447769741, 0.06550629338848701, 0.12556278221789963, 0.10156391660651332, 0.13491450427696183, 0.11802814162707731, 0.08335072555519929, 0.09929472164701125, 0.10425267661249749, 0.08159989348835972, 0.10786480681810118, 0.09804807010585359, 0.08124321107110666, 0.09967323699735131, 0.10476023114014865, 0.987308450974841, 0.9775696831008067, 0.9783804277213408, 0.9780008238742832, 0.9775754104223798, 0.9764766776240824, 0.9831026902358354, 0.9770309343197021, 0.9784084892103684, 0.325048367997392, 0.43184776820973547, 0.3754260356426742, 0.29503455091778874, 0.4066398189476854, 0.23358286336531187, 0.23633489781438088, 0.39098742351861415, 0.3921412574290829, 0.28462768514041403, 0.6150871392187509, 0.6646536123571317, 0.20644221715725974, 0.21206929552034026, 0.20809715489071856, 0.43887322587882016, 0.6755862475817982, 0.6071455328173854, 0.14613072381633774, 0.18306951025143503, 0.17957520760305457, 0.1544432311201528, 0.18426443959367456, 0.1775530431533553, 0.15577118877506946, 0.1728466699388389, 0.19357163848623127, 0.14932520371994618, 0.19116048129328145, 0.18184210369470377, 0.13574728234759204, 0.13389555014165422, 0.17991268271291994, 0.168016371125438, 0.19606263430498427, 0.19920836076797332, 9.999999999998899e-05, 0.014981369456895322, 0.002779655444230422, 0.0003565599519682605, 0.012970043521171482, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0017372358133179722, 0.0494201140551187, 0.08754488673590788, 0.10117226570253424, 0.010930212480204649, 0.02493367081488851, 0.0013556488607430195, 0.07125179493202194, 0.08259919523210324, 0.1920101228322163, 0.024019631956268106, 0.03803518803347883, 0.10891538461754857, 0.04061939401988435, 0.0641774091236399, 0.057011578893253145, 0.07000569289248448, 0.07086632585008523, 0.049683844295942414, 0.13137312275054014, 0.08736585042201928, 0.10501676333564314, 0.12739319800971372, 0.11684819628481724, 0.1720582703109389, 0.054766599866094334, 0.1576126948041625, 0.07412415066828748, 0.4238609588160681, 0.49772161597920306, 0.46444383664086386, 0.4051575714616358, 0.48743536485235617, 0.494254614797607, 0.4136830492425161, 0.4771897983393524, 0.47020774361257967, 0.1150010852901614, 0.1013367807188934, 0.10444934126831429, 0.09576658309895925, 0.10846887274274453, 0.09962435079553067, 0.08480611206493938, 0.10304111011434947, 0.09844177208625493, 0.15756730902556992, 0.16375400235744075, 0.18363004366951596, 0.14995578219496997, 0.235554476437969, 0.1823214809521856, 0.12585043546747654, 0.150615557568331, 0.17987559562176447, 0.2913905588710217, 0.35722751099532457, 0.26362847472266704, 0.2954308555313615, 0.3546961620426725, 0.354450501193444, 0.33554019581874794, 0.35899942330118273, 0.3586613641073628, 0.24812850639256745, 0.2435873718771725, 0.20613817180371885, 0.17542425998902111, 0.22053172657422648, 0.22680406538454667, 0.15168328016069277, 0.28675195504526163, 0.21949565078715927, 0.18680325020742072, 0.21892466009182554, 0.21246158228836165, 0.19630052752439242, 0.21162666165688604, 0.2024689574063826, 0.20414226552387227, 0.2134208472780128, 0.20058914302096442, 0.19260318051903946, 0.2020526924513394, 0.20746780755147942, 0.1715489096467967, 0.35157853944341355, 0.2746331362258012, 0.18355616798580687, 0.17950179043221903, 0.20465368845543142, 0.7060374041085269, 0.8060947937067225, 0.7916515568727307, 0.15453778147966113, 0.15628443701733596, 0.15577651925356772, 0.16769467426531137, 0.6697455424669354, 0.16637479806948574, 0.36165516388257524, 0.662900745915755, 0.5557540619808818, 0.20544847478022954, 0.20906460737739385, 0.2047875222129063, 0.19608241097573387, 0.20711476408379426, 0.1933953231310679, 0.1795592130109519, 0.1925654592015943, 0.18444991497535046, 0.19853948015197098, 0.18063228152118105, 0.19187115445781522, 0.17770988783329034, 0.1757671138992044, 0.1775411382657165, 0.0807355491167967, 0.08760905510043082, 0.0865653283723814, 0.08046062330801618, 0.08892282630666382, 0.08133291020430244, 0.08713952392280822, 0.0819429367996305, 0.09070486424362023]}, "mutation_prompt": null}
{"id": "167a42ea-8b94-4666-be49-4341337a4501", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 14)  # Slightly adjusted population size for better balance\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Changed inertia weight range for improved dynamics\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.6  # Slightly adjusted cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.6  # Adjusted social coefficient range for better convergence\n        self.F = 0.5 + np.random.rand() * 0.1  # Narrowed scaling factor range for stability\n        self.CR = 0.85  # Adjusted crossover probability for balance between exploration and exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.15, 0.15, (self.population_size, self.dim))  # Altered velocity initialization\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite-centered strategy\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]  # Increased elite pool\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Adjusted elite influence factor\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling with reflection\n                out_of_bounds = np.where((positions[i] < self.lower_bound) | (positions[i] > self.upper_bound))\n                positions[i][out_of_bounds] = self.lower_bound + np.random.rand(len(out_of_bounds[0])) * (self.upper_bound - self.lower_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "A refined hybrid optimizer enhancing convergence by integrating adaptive differential evolution with elite-centered swarm dynamics and boundary handling. ", "configspace": "", "generation": 56, "fitness": 0.21236340539871568, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.16.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.5470139986326137, 0.686536632274007, 0.6586085216842887, 0.28227960746102454, 0.41403175592674457, 0.2980126316446384, 0.3798910172325497, 0.6344734160975152, 0.4272916335293738, 0.10872109698689125, 0.28750842286747447, 0.3080754748526958, 0.10399409313730412, 0.3980088698121006, 0.2319405036043236, 0.18502936881866194, 0.26711072226304455, 0.17745482903269916, 0.09673231867487175, 0.11919185826006429, 0.12318716865055179, 0.0711201674610189, 0.11546533356385824, 0.12213644536297819, 0.08572303611126442, 0.10028907224007633, 0.08887185547579268, 0.08635286486248772, 0.12114445096067616, 0.11106899259153646, 0.07173937232050698, 0.09460393391353394, 0.10384100647551664, 0.08643836109152092, 0.09393102511008455, 0.18776908269044423, 0.10371050036687846, 0.16252135064435447, 0.11189280491024733, 0.09749907619655007, 0.15868670007647656, 0.15298101853525348, 0.13758908940150705, 0.11538431672671812, 0.11107145877360003, 0.2060317222404563, 0.40715006827096845, 0.385706857066494, 0.16213332630825794, 0.3646073485929021, 0.33776671786458246, 0.1768195690868961, 0.3563143471486967, 0.34915338779748983, 0.31454061860120464, 0.6632399707812322, 0.6202042107731658, 0.24022621985203318, 0.2593213192940509, 0.26038147956641344, 0.1910111881784866, 0.6947765832562687, 0.22518917798544513, 0.12238542343426506, 0.1498693806577046, 0.1628954462583715, 0.14222396460303366, 0.16562800298318492, 0.15163165281572344, 0.12888562529246883, 0.20174586581318565, 0.21720660370055633, 0.1581932174444235, 0.1979570053502976, 0.1973839863408532, 0.14582639242293682, 0.20127769440725773, 0.17531489544415413, 0.12659780888944316, 0.21021556955871168, 0.18373708302334402, 9.999999999998899e-05, 9.999999999998899e-05, 0.00011797702282423383, 9.999999999998899e-05, 0.010923835315212238, 9.999999999998899e-05, 9.999999999998899e-05, 0.018770199402726062, 0.0008161711209899725, 0.1276405938354348, 0.07366043722510918, 0.05636409065474923, 0.03397472207795549, 0.061840937345440605, 0.06717068308117613, 0.08943830952822773, 0.11199471972186437, 0.13167427926657582, 9.999999999998899e-05, 0.11878652691604097, 9.999999999998899e-05, 9.999999999998899e-05, 0.049842650259128485, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03507118808997689, 0.17438855787600316, 0.15816224808688562, 0.07359858931868746, 0.10325087971753222, 0.06259389168443663, 0.045440933272174466, 0.20071167116361366, 0.08855943028380153, 0.39292795808334546, 0.5062926867857062, 0.4618384455259571, 0.31826142191928597, 0.46272068629190843, 0.3890233363309308, 0.42250419461781474, 0.5203843277556004, 0.4818654940167584, 0.08353001321587583, 0.0771491988144386, 0.07356744196006204, 0.0737625435957956, 0.0997552716870872, 0.11378416043986306, 0.09594829862882703, 0.08257487135887243, 0.10260834633799587, 0.12876694528110588, 0.12981908531779462, 0.15580049103262483, 0.16005474755565863, 0.13648405652632467, 0.13661858559904871, 0.1423623924807642, 0.12616264383464837, 0.15301888920560902, 0.3077756241804035, 0.37477065872797044, 0.339957100460744, 0.2853257490296113, 0.38859776646858435, 0.361314619900847, 0.2206448036089088, 0.3259297142000862, 0.351888103900157, 0.20139753886924017, 0.20829627497275105, 0.24204429049453624, 0.16062294368769703, 0.23500474096423707, 0.2890202704443019, 0.18600706650253895, 0.3059348799521324, 0.22975400574649107, 0.21027115582922762, 0.218551133397073, 0.22749516028820393, 0.19859659808681862, 0.20468038731654847, 0.20414831717391835, 0.21384293798415155, 0.250343963341488, 0.20507113368022123, 0.18623138922651972, 0.2771543884743095, 0.22956508307454548, 0.19113521434578762, 0.4068602830090463, 0.2160171018101843, 0.18189341131963277, 0.21942666161127156, 0.3575771821273388, 0.6330008817318622, 0.8140218383095186, 0.638683163754918, 0.16497900103798802, 0.19650144336461983, 0.15764341392294556, 0.6158918714390967, 0.17110738083578758, 0.36405928224039064, 0.46035107346580006, 0.5339900048582111, 0.5797768179186049, 0.2629698572270244, 0.5304225730893606, 0.19619918036843276, 0.2766625991622923, 0.6064800725094628, 0.43979200103473526, 0.18491001610030988, 0.1833067759121253, 0.19044276193822507, 0.1760231251945905, 0.17692692054702752, 0.17644943637205635, 0.1942622114324173, 0.18163634029201836, 0.1862185530864946, 0.0881578493809606, 0.08676474725150018, 0.09021523313349367, 0.08155893584765783, 0.09064049704821187, 0.08623814930122153, 0.0739292098487303, 0.08154729948224371, 0.08153234859717429]}, "mutation_prompt": null}
{"id": "5f26463c-b817-4d63-b845-28b65fb2fed8", "solution": "import numpy as np\n\nclass HybridEvolutionaryOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Slightly larger population size for broader search\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Balanced inertia weight for controlled movement\n        self.cognitive_coeff = 0.7 + np.random.rand() * 0.9  # Moderately adjusted cognitive coefficient\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Balanced social coefficient for effective learning\n        self.F = 0.5 + np.random.rand() * 0.3  # More adaptive scaling factor\n        self.CR = 0.85  # High crossover probability for diverse solutions\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with cooperative partner learning\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.7 * r3 * (elite_partner - positions[i]))  # Enhanced influence from elite\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "HybridEvolutionaryOptimizer", "description": "A hybrid evolutionary algorithm using adaptive differential mutation and cooperative particle information exchange for enhanced exploration and exploitation.", "configspace": "", "generation": 57, "fitness": 0.28592382170318487, "feedback": "The algorithm HybridEvolutionaryOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.66608514099688, 0.7543970213425899, 0.7442153541874994, 0.672663165144213, 0.7570424824122762, 0.7359606802097389, 0.6782276480419522, 0.7640434372629544, 0.7503539821061267, 0.2101603311550836, 0.4641861585512985, 0.426817275150307, 0.03760865280589332, 0.47880189531070394, 0.43385378485407977, 0.25046345929038516, 0.4890003194798064, 0.45152494258651676, 0.11697838269927285, 0.1338688140973816, 0.147472922187306, 0.10052549920242404, 0.12301365160158784, 0.1531004908834973, 0.10175270381840906, 0.21643514549671317, 0.14669792322219677, 0.11312799491670722, 0.1113329915124377, 0.11461741008289139, 0.11567927277505408, 0.13624805213771018, 0.12223377863103524, 0.09656131587863837, 0.30457556623976356, 0.08508285582291042, 0.9875889113882104, 0.9768639347112302, 0.9783797376279303, 0.9776035458215893, 0.9761458563864044, 0.9786346993452745, 0.9778288700807929, 0.9756567774433684, 0.9772292897331908, 0.3573810630662245, 0.5360225840192079, 0.5522750861898753, 0.39750592679734986, 0.5034035113417326, 0.4935740112009146, 0.37861824276004885, 0.5289258084295209, 0.49190185529401265, 0.2185546738693085, 0.21649546402578768, 0.2224064603346253, 0.25698303166975733, 0.16083525526579068, 0.3642688847700688, 0.4342484932228756, 0.7424303009500708, 0.22851964472414343, 0.17690018581260591, 0.22513348745100903, 0.21801448824825442, 0.125103783439367, 0.12654413301361578, 0.2560828110870399, 0.16470142725791825, 0.21904596348665661, 0.22300787772728137, 0.02192875421045426, 0.22148433893561714, 0.19716348853355659, 0.11346911021132056, 0.2255650993742785, 0.13699015790458002, 0.1393792014498051, 0.19638690120578817, 0.23020634668339912, 0.04452831720480155, 9.999999999998899e-05, 0.01823776302379121, 0.016425292716980566, 9.999999999998899e-05, 0.0423097674685774, 0.0019292878897108068, 0.020479875094662536, 0.010659426154439045, 0.04209238404175031, 0.0785086093537235, 0.12371401099792423, 0.007961827976056157, 0.030116700145461084, 0.066647004578953, 0.06773865128618928, 0.08936945356370163, 0.030305384736933005, 0.050494369159322705, 0.043369323911729984, 0.040063316262396786, 0.036176778927403785, 0.11523619867684798, 0.1461821217711824, 0.05857820350918008, 0.1320171113467421, 0.14502349524268143, 0.06918916233083494, 0.11669711561779472, 0.20212494232193412, 0.12679835979734777, 0.19878131944724464, 0.13376823727322518, 0.0462397460677898, 0.11105437310602106, 0.04802779980973537, 0.4501389704477977, 0.5172756222384511, 0.5102768143188054, 0.45066571274075773, 0.5280641971736656, 0.5694661325673526, 0.4743849798542862, 0.5607073282806456, 0.5270497315215932, 0.13444138007379347, 0.1448101444666129, 0.12208722337374966, 0.08875695863667843, 0.12182046471889918, 0.10029679517089918, 0.09898086073553947, 0.127594007912605, 0.1279538015877748, 0.13673757489150407, 0.2960154110680998, 0.40308011802465826, 0.1403067771440326, 0.2524744783953714, 0.21218359708318724, 0.12839647276220256, 0.1475095632809733, 0.1820089493089626, 0.3483488479206148, 0.4344844369266285, 0.38766302304442535, 0.20927759681270997, 0.3727005063740687, 0.383798873843589, 0.3303839585405165, 0.4568602659496127, 0.34171937607796266, 0.19578449994048852, 0.3568094420959307, 0.2944342992850527, 0.18343446441776834, 0.21433635021516362, 0.1922852546935082, 0.21955836747710544, 0.2001875330051922, 0.13711365744449433, 0.1890592479131702, 0.20912149431247462, 0.2039575117721808, 0.1819516065395208, 0.19222555526167284, 0.22162260087049768, 0.1914312642480841, 0.2219408017067438, 0.22605791054403823, 0.20961449340985405, 0.23513939234807102, 0.23651907976904463, 0.25354290852953687, 0.2391807998671135, 0.21356776017615597, 0.1946480572579059, 0.20774642838837742, 0.2289816219440931, 0.7713575111459245, 0.8522296880473872, 0.8492258265140811, 0.7972451559718982, 0.8178513942855168, 0.8526471139753877, 0.16533515183375436, 0.1774309918300625, 0.15945799163495833, 0.524490060586871, 0.6286921531146836, 0.5864268369834501, 0.569110834140151, 0.21119379261826188, 0.20914031510019926, 0.20445829561512308, 0.20497572623528215, 0.18378996099805933, 0.22647035817129857, 0.195005833858518, 0.18099572565060107, 0.1851801430384451, 0.19626763937169833, 0.18630569100817695, 0.17794453397176113, 0.1774228965975737, 0.17425037321222314, 0.07542907466237225, 0.09913658872300113, 0.09166048247852598, 0.08216176371650397, 0.09011607207549843, 0.08069102834943498, 0.0780987203963146, 0.11384111654016393, 0.09138957932334046]}, "mutation_prompt": null}
{"id": "4d7ce286-1df0-4281-81cd-6040c19a0bc9", "solution": "import numpy as np\n\nclass AdaptiveDualPhaseOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 15)  # Adjusted population size for balanced exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.6  # Fine-tuned inertia weight range\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.6  # Narrowed cognitive coefficient range\n        self.social_coeff = 1.3 + np.random.rand() * 0.7  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.4  # Broader stochastic scaling factor range\n        self.CR = 0.85  # Adjusted crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.05, 0.05, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Adjusted elite influence factor\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "AdaptiveDualPhaseOptimizer", "description": "An adaptive dual-phase algorithm blending dynamic differential evolution and particle swarm optimization with elitism to enhance global exploration and local exploitation.", "configspace": "", "generation": 58, "fitness": 0.2231482271046083, "feedback": "The algorithm AdaptiveDualPhaseOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.22.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.35772968560580043, 0.6223843879903759, 0.47461530166907173, 0.43660061830260277, 0.6163586314613225, 0.5425344080934529, 0.36313834030404535, 0.6432105496477325, 0.5527776725572782, 0.0008124389058445924, 0.20183560157781555, 0.13601650388304443, 0.06064118902839677, 0.26463006431206915, 0.11444708181168184, 0.06609207729302069, 0.19397864319577962, 0.09320113103721306, 0.08052343513596427, 0.09587913959076266, 0.1221178713321811, 0.08799834746999313, 0.12473604469111121, 0.06491226072016909, 0.09423579171820873, 0.09870619390104163, 0.12432347023349688, 0.07132306014145273, 0.10809515049492424, 0.09528144623422996, 0.07409577666008027, 0.08815729224230251, 0.08763251640411795, 0.09020019639633958, 0.09320145403051916, 0.0877254267553903, 0.9810652233753366, 0.9790611516895161, 0.981143766874366, 0.9818793371315346, 0.9805993852375741, 0.9817572490861874, 0.9827144886360939, 0.9815997634303041, 0.9823405027880941, 0.17936206880210936, 0.37936931297079124, 0.35726558357669613, 0.1274919025385538, 0.29517397642308285, 0.14916453501632387, 0.226859564614444, 0.345273481688539, 0.33507351750223957, 0.19974290062742683, 0.42586500116916204, 0.6366988577563089, 0.19745782644629695, 0.5429653537550422, 0.18560932213341097, 0.15480956823752678, 0.22911273856362646, 0.5120634593359394, 0.11092508418987712, 0.15422101701020707, 0.11580577644978407, 0.11698638467941236, 0.11996370755140273, 0.0877595425659703, 0.09335207743559681, 0.17003655920445926, 0.17745267628498185, 0.11819358848974393, 0.18164577141369054, 0.16932083680415055, 0.10203740621056046, 0.17077631440115149, 0.1582008451441108, 0.06682989153895103, 0.08892348752164614, 0.16582578202664222, 0.0018954994655261403, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06026350869191088, 0.08497256192954028, 0.04930229448686241, 0.0008078568729855684, 0.06100099916635737, 0.01693630657052947, 0.0554665080408846, 0.05641436562102775, 0.08759827303050716, 0.0017315625249071376, 0.034372253523427765, 0.01818680272650841, 9.999999999998899e-05, 0.03833935387724674, 0.03047401000116645, 0.019796194410896528, 0.04534106863730025, 0.0031268070907662926, 0.049810581666774656, 0.14046228870013, 0.09587043812440221, 0.06459672458975096, 0.153093214092195, 0.05302059947851434, 0.04253195557051437, 0.1516671648668314, 0.05177143014976804, 0.3540964337486876, 0.46405151845052206, 0.45864936139382795, 0.40502494522223564, 0.4380598860057532, 0.43299758932592736, 0.3827820530634267, 0.46877307019061887, 0.44870270517587796, 0.0936873572696868, 0.10644478344524522, 0.08747423476021865, 0.06779074922312578, 0.10251497595351333, 0.08634655273342828, 0.08155327181960215, 0.11470392382542705, 0.11091196780650825, 0.18957857066040995, 0.16001592457859337, 0.23484570043459285, 0.24467892045327666, 0.14806945173286623, 0.18935631596091085, 0.1507582922953039, 0.174000742047695, 0.13538951219768036, 0.26143610819687024, 0.2882771608229635, 0.23796401394564348, 0.24838540152788935, 0.3190997795876941, 0.30843206417047564, 0.23323814974293167, 0.34003933995784796, 0.292937238540283, 0.12745084910778381, 0.26135843275776083, 0.11150150398203573, 0.14227330016960826, 0.2045034448642299, 0.23832621406744625, 0.18332450823447188, 0.17889994143013477, 0.13365510480471, 0.22267388804191002, 0.2038236489081965, 0.192010746348649, 0.17018268126956138, 0.19570608053394223, 0.19341818826672796, 0.18938371149775568, 0.19478674306196597, 0.20707315131852533, 0.17330536678864605, 0.22329060889436336, 0.2030155074244282, 0.1879545092806223, 0.2015599703272004, 0.22446783512248958, 0.16483892977733683, 0.18048082125830156, 0.21589996453186644, 0.2422736101251538, 0.749423333276704, 0.7409677174556711, 0.20477739139063245, 0.15625831731651318, 0.1530684078339858, 0.16720642068577274, 0.17023171440092355, 0.1668804118429269, 0.21706903030677083, 0.4754786947067984, 0.37634738707567095, 0.32612943314353926, 0.5689761128037627, 0.4328024362404562, 0.3231243843660424, 0.6487707546602663, 0.15392133880648307, 0.17090469803412067, 0.18336056199928352, 0.1725997835987133, 0.18453813441810973, 0.19052761117912798, 0.19139259627877114, 0.18165980514259294, 0.17846320983334496, 0.1832739895970421, 0.07023850706518353, 0.08615938504609477, 0.09280682010761176, 0.07049380989728449, 0.07989852294072641, 0.08652781869914217, 0.07351029695948075, 0.07752993374970263, 0.08651454220782273]}, "mutation_prompt": null}
{"id": "c044edcc-1d1a-4763-8137-84e73190776d", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Increased population size for broader exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Modified inertia weight range for better balance\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.7  # Refined cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Extended social coefficient range\n        self.F = 0.3 + np.random.rand() * 0.3  # Adjusted scaling factor for better mutation\n        self.CR = 0.8  # Slightly reduced crossover probability for improved local search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n        \n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR or j == np.random.randint(self.dim):\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with dynamic elite sharing\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizer", "description": "A refined stochastic hybrid optimizer using enhanced adaptive differential mutation with dynamic elite sharing and diversity preservation mechanisms.", "configspace": "", "generation": 59, "fitness": 0.3061376022575298, "feedback": "The algorithm StochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6727813472088234, 0.7729125125618626, 0.7596389526995209, 0.6610058739292307, 0.7684674429437187, 0.7641544004046479, 0.6514087235372246, 0.7753668045900215, 0.7580432573770851, 0.30739074361799434, 0.46480618307278965, 0.47633576303330305, 0.2988197775739112, 0.4741388714700191, 0.43641890445431053, 0.3064887891897904, 0.5120687367694459, 0.49262975710391055, 0.13981682492796643, 0.11942754916292919, 0.12488757279900509, 0.06924963938668915, 0.1660665241627698, 0.07100487908409991, 0.10447350653819465, 0.5081825937585885, 0.13752722454930422, 0.0988683838535559, 0.14293621480816943, 0.11885191882384838, 0.07807543632674896, 0.12366777794782136, 0.11258259948049598, 0.13052388146349148, 0.10715236805710415, 0.131019349881623, 0.9784670456233122, 0.9747568067796791, 0.9782731236322104, 0.977739029325163, 0.9672296141947923, 0.9778012350883921, 0.987025911894264, 0.9756137800132015, 0.9778535492147313, 0.4014756818871933, 0.5535611645143705, 0.5177513217305816, 0.3821203219195106, 0.5659553255044381, 0.15006646741797036, 0.411876413480214, 0.5542370360402047, 0.5455680278325019, 0.5531270666382868, 0.7765143727441877, 0.7540724368173924, 0.16043454776625077, 0.822742542418864, 0.3533019407904937, 0.6121512254442092, 0.23032144889580197, 0.22488629392203907, 0.1790758463364649, 0.21260281917014934, 0.21790041939906724, 0.17528334767460652, 0.21276240302521177, 0.21984208075105016, 0.177691272495082, 0.2080457014458993, 0.2292410845804197, 0.05253315711789874, 0.12402381793495476, 0.022080749428081026, 0.1852058636522108, 0.24426865214631976, 0.11741443095435955, 0.18062983325033133, 0.12395193082108091, 0.2601429666870938, 9.999999999998899e-05, 0.00013479048468545418, 0.0034239405560432257, 0.014176344566082077, 9.999999999998899e-05, 9.999999999998899e-05, 0.0014624810550504241, 0.0004785958365811638, 0.007355490645374441, 0.08585955367890785, 0.05370440986151226, 0.05560037480531976, 0.07148290613018327, 0.0773130770260827, 0.023964649363105717, 0.14417272578208107, 0.07159059660565203, 0.0622418658010081, 0.04092913479599247, 0.1151453562411896, 0.11329602718751486, 0.05703293085450756, 0.0625372450210423, 0.11379595594302194, 0.09045942789003458, 0.07718847002170026, 0.08214345635044007, 0.14686287706366552, 0.045311198112575, 0.17629833316502974, 0.03435194652045104, 0.10163714211723895, 0.11975254313866046, 0.12816691669668434, 0.08436871222186892, 0.07497490428017628, 0.48030801837096215, 0.49659148764461236, 0.5393273977798863, 0.471541641762922, 0.5611976492091502, 0.5636658650330416, 0.464171337566995, 0.5462895517685165, 0.5333758211494859, 0.10923814299316348, 0.1273940094174031, 0.06717035496260981, 0.10809079677607192, 0.1400843643099724, 0.15205273353739868, 0.12223570797760697, 0.1290416661453232, 0.11165771809688796, 0.15327281438165685, 0.20816922119557635, 0.17619313276003268, 0.30507612892925684, 0.2821806635010363, 0.2367182071472831, 0.17300059563203707, 0.1334292763568985, 0.1863765172495998, 0.3232637617323044, 0.44966071084242487, 0.4474308114875508, 0.3571505145170618, 0.4393866260389916, 0.4171281879362183, 0.3686930372513294, 0.4346455131019129, 0.45661474904026755, 0.18757850412536836, 0.2790362538862906, 0.2654577095943699, 0.251363054799999, 0.1915592658193197, 0.3370500773136812, 0.14499800790871886, 0.33402792018369054, 0.2346712611248596, 0.22894291027830682, 0.20554305790573035, 0.2122680766719297, 0.20270810594830146, 0.23268481640198313, 0.2099698326156615, 0.20031900366164834, 0.20536957592230187, 0.2481617252936087, 0.3167292050200181, 0.19970673163519148, 0.23959149933998025, 0.20421869266110337, 0.21479721423767328, 0.24306988676807584, 0.2726296291962693, 0.4285988588863444, 0.17137909995603784, 0.8171957688115654, 0.887470233765023, 0.8610662569922994, 0.6571478456031952, 0.7959026887890845, 0.16862061694248875, 0.7958963461441233, 0.8529303138607037, 0.868587977879685, 0.5890125200068947, 0.6720100441897122, 0.5610777500339992, 0.20686365797163986, 0.1682904380671495, 0.2086749271779712, 0.15327027155027062, 0.7674900379097482, 0.1648273450470884, 0.17890047264875952, 0.1853812786915291, 0.18674179720260375, 0.17298174473947547, 0.18136429347640504, 0.17729025887462213, 0.19874190090928567, 0.21161497329097378, 0.17891056644098735, 0.08878597158328216, 0.0918571113752572, 0.08755762939822975, 0.08732150406629935, 0.1054674888660666, 0.08892508219918249, 0.10020811880342662, 0.10361437377581295, 0.08714219501166731]}, "mutation_prompt": null}
{"id": "eae81dad-5019-4447-bd0f-61dc56e07e76", "solution": "import numpy as np\n\nclass ImprovedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, budget // 10)  # Adjusted population size for enhanced exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Balanced inertia weight range for stability\n        self.cognitive_coeff = 1.2 + np.random.rand() * 0.7  # Refined cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.6  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.2  # Modified stochastic scaling factor range\n        self.CR = 0.85  # Slightly reduced crossover probability for exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "ImprovedHybridOptimizer", "description": "An improved hybrid optimizer blending adaptive mutation and enhanced elite synergy to boost convergence efficiency and solution accuracy across diverse problems.", "configspace": "", "generation": 60, "fitness": 0.2741098180186404, "feedback": "The algorithm ImprovedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.23.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.5679898934639835, 0.7011193856203626, 0.7031904063234653, 0.6672542821534486, 0.7102162394834082, 0.6916864094170643, 0.6078145198622362, 0.7307582222214858, 0.7157241576395771, 0.19896762928470757, 0.3969468238075696, 0.3663755078608548, 0.2211083115135345, 0.3280227847662395, 0.3803067120541974, 0.2558263555183261, 0.3480135794074696, 0.4034526818445795, 0.1093961537129442, 0.2581613282821186, 0.13598437952074893, 0.09944070348897871, 0.13026478720255275, 0.116591551785169, 0.12640388033264738, 0.10219340949036437, 0.11960937985783315, 0.11494739073077853, 0.10667008921304244, 0.10226361724629951, 0.08219705319566162, 0.11682048029795455, 0.09804805242800885, 0.09650024726453443, 0.12632636996450441, 0.1170561685433551, 0.9729557637046397, 0.9724206783118752, 0.9727079364560955, 0.9744473300049632, 0.972270429567991, 0.9740450123449343, 0.9720028982195565, 0.972429925088033, 0.968723050680036, 0.31493250040542775, 0.42957907308376664, 0.4421365022995709, 0.3101169178669946, 0.4568921013076237, 0.44483656238349145, 0.28620948027374193, 0.43813570393348744, 0.08861821060254205, 0.52069477341267, 0.5022265341553211, 0.6177706876379176, 0.20274175467433375, 0.47806394839396293, 0.2424333729439231, 0.22641213555364825, 0.6668800941258022, 0.22788368999449538, 0.15967343120944866, 0.22752618783247702, 0.1947334415706623, 0.1172809690553549, 0.1874551798077878, 0.1836484188502362, 0.1569554516530799, 0.1776962844929385, 0.19836405202653196, 0.15561768623206917, 0.2005455378440446, 0.2000789222647279, 0.16923044582848035, 0.1906737460078881, 0.21867850050826498, 0.20366924121140506, 0.17402818736407533, 0.1695993350537588, 0.002048197927085882, 0.0029968138949832968, 0.0006208267073809504, 0.0006012506080372848, 0.001160305512395876, 0.008540190737822528, 0.062416777968593684, 0.02551242853200053, 0.08457660497501984, 0.023483547376740854, 0.08404708274864203, 0.04375589605125185, 0.05966467213407178, 0.07231576726083677, 0.06553574653101546, 0.061398871057590676, 0.10184804191721375, 0.08236073076216543, 0.030271163083030128, 0.19183386629040056, 0.02593695971760568, 0.11950774708294298, 0.07287475810283428, 0.13626933145189812, 0.061238140166716026, 0.06849989057334571, 0.07485996228663805, 0.0913385259024635, 0.1865378114951749, 0.11941700389432175, 0.10305858939337054, 0.103198183569984, 0.15928726294959616, 0.12950464782983873, 0.11244552376967842, 0.04552948838425619, 0.4445380729398438, 0.49027619794455424, 0.5039869181076884, 0.4406853052176932, 0.5007974358471217, 0.48005230280182165, 0.44030163406116674, 0.4980231944647596, 0.5248635197241911, 0.09781506316816557, 0.13861310932027315, 0.10457255393472564, 0.0869545747895516, 0.1254950850054074, 0.12256833037925896, 0.11292594646583565, 0.11574361930505295, 0.131678321449491, 0.14316979867264912, 0.1413285135456679, 0.2823395853007342, 0.14449759792768324, 0.21889758574192342, 0.2382808758420889, 0.2045803580750667, 0.1525087682341284, 0.2851338140755766, 0.30026716009235266, 0.3990031630870787, 0.3613542461406829, 0.3183791773303162, 0.3387283130994809, 0.4187121985877934, 0.3274691785860324, 0.4088624339108946, 0.42173241778732884, 0.18640321873694954, 0.20096832486243943, 0.15108436311426687, 0.240120322579907, 0.27052720869328595, 0.23867368889205332, 0.23186538799432732, 0.2393147602138943, 0.19939013886483625, 0.17912588480916325, 0.2141669615191122, 0.22906599650175674, 0.18828557324120232, 0.19946346012781313, 0.21395528397206132, 0.18653466615045444, 0.21903790741160734, 0.2102436892342875, 0.33951358590070513, 0.21587422484626995, 0.19631443826871642, 0.19596029227007117, 0.27405425168479336, 0.20410815558045925, 0.32908150400356595, 0.4054578837182792, 0.4342455410180045, 0.7632468056072774, 0.8567175745542873, 0.8440488385388095, 0.12983810775337568, 0.16201395691405118, 0.12979198952513993, 0.2097158028025059, 0.12416791010083739, 0.19929201478288627, 0.532457636606473, 0.612333624336202, 0.6290254913465899, 0.2086493181879524, 0.2069809224031558, 0.2102200827615307, 0.5116360701879594, 0.15232661573798068, 0.6856436777482875, 0.1864319857025385, 0.1818618831274712, 0.16868723740989067, 0.18529667307144893, 0.19345538521424532, 0.17320342451999482, 0.17979368354414016, 0.18261711998042351, 0.18880956808280203, 0.08255322036588097, 0.08862001144539777, 0.07449793705204355, 0.08255471188935459, 0.10500776176067772, 0.10962271498424248, 0.09414699711294328, 0.08726446935231158, 0.11505274265383647]}, "mutation_prompt": null}
{"id": "6416bf8a-37a2-4b5e-848b-83e35bfe1912", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Slightly increased population size for diversity\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Adjusted inertia weight for better balance\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.7  # Modified cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Tweaked social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.3  # Modified scaling factor for aggressive exploration\n        self.CR = 0.85  # Slightly reduced crossover probability for stability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(5, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer blending differential evolution with adaptive swarm dynamics and elite learning to bolster convergence and exploration.", "configspace": "", "generation": 61, "fitness": 0.2777292693719062, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6623088197579857, 0.7601939907218358, 0.7551964502649691, 0.6421000653958897, 0.7416830797670682, 0.7184853044443485, 0.6704857376306541, 0.7685855257285132, 0.7647713965104324, 0.24354126542252552, 0.4384809529805832, 0.41487599599532643, 0.24342315771510314, 0.4585553029095387, 0.403136951995707, 0.29705833192447395, 0.4761601406390522, 0.3440843575165712, 0.0974339254029637, 0.14401698451645772, 0.14595739489152837, 0.11829140047073183, 0.17953054932332457, 0.11193089075017393, 0.11795708248275039, 0.12135227899829881, 0.13987968508167192, 0.09852026234890454, 0.12505178153329866, 0.1010177669852168, 0.10570875173370387, 0.11867780216665214, 0.13177354029024368, 0.10222401058386965, 0.13829349987163764, 0.1306477310155687, 0.977831251369566, 0.9768161956782897, 0.9777293266136471, 0.978048427117645, 0.9776492527470346, 0.9782356969302495, 0.977387407434394, 0.975566605219424, 0.9771034941826104, 0.3814041040540552, 0.535773192280335, 0.5135559800308893, 0.14701808272604378, 0.4888876389660821, 0.30754873539123806, 0.31026250040713177, 0.4581872797280643, 0.4696776429464564, 0.3135391056052804, 0.40222272868363185, 0.34932463629340826, 0.21164826975351425, 0.19494304651838235, 0.2695392857955724, 0.5522088565009459, 0.7639702069622751, 0.710496456914856, 0.16591726073230018, 0.1939982111268742, 0.19447819359685214, 0.12168075479132201, 0.25046417964676837, 0.12487451938771177, 0.1644540731223837, 0.19648748427159868, 0.2317660045623544, 0.12416010362017516, 0.11292358993443374, 0.31840842775047995, 0.15826492561187822, 0.19127290685794374, 0.21895203926791362, 0.11674288908697694, 0.21881568804650864, 0.09991652608527124, 0.00010066294663979569, 0.02455632818112119, 0.0021176391804524908, 9.999999999998899e-05, 0.05398167879719662, 9.999999999998899e-05, 0.0003163265384932279, 9.999999999998899e-05, 9.999999999998899e-05, 0.08233676760256892, 0.03644231075561288, 0.07064347566241647, 0.04412444024946249, 0.06389714864797258, 0.00936891904364312, 0.059267314507417956, 0.0913280441019817, 0.08763523908340498, 0.032062826979708525, 0.050435453569988575, 0.03860398683684019, 0.08729056405879743, 0.06464936733198134, 0.14615283052949068, 0.0876820603005839, 0.2889089069229981, 0.19343082972066172, 0.2063029935096784, 0.1046596257973339, 0.200955794265534, 0.13629014186144728, 0.15500217837537222, 0.16209821766482346, 0.045017512513406244, 0.07513749248368917, 0.04758584750675743, 0.45730265009190985, 0.5127030642919979, 0.5224343937862006, 0.4663117268412885, 0.5196514748945898, 0.5064905316393484, 0.474366840401361, 0.5464272535008126, 0.5233080496860154, 0.09966423775922217, 0.1300217048508161, 0.11026265305074301, 0.10219224195666743, 0.1661602044770023, 0.09373409800104271, 0.10108432580078319, 0.14492344284805403, 0.14245442771502026, 0.19205517989355736, 0.24543434381452567, 0.39469667627914984, 0.1885775069488722, 0.2848587890483839, 0.20239497917262972, 0.13558583825983384, 0.14139534584001234, 0.17133443716205043, 0.33790957402571464, 0.39553065703802737, 0.4144014566871489, 0.3220066900250067, 0.41521939388731977, 0.3994898492294032, 0.347651424099644, 0.4473688072653459, 0.42332138172913825, 0.27088962988351306, 0.22621611010671872, 0.30799567257810234, 0.19254444910341706, 0.21613635233792183, 0.21489332021951935, 0.19364649184719995, 0.1983726308294611, 0.15282290474981197, 0.20765365764153498, 0.20595183791077631, 0.23369499642961078, 0.1963350092899464, 0.21100454797446833, 0.18595018031193256, 0.20996588194134747, 0.20824051096712792, 0.19483033691148155, 0.20565968049461403, 0.2022208225480806, 0.5804238683235906, 0.21003937346616097, 0.20208857162870253, 0.20255612220935038, 0.1905875009330772, 0.2157354395706158, 0.1966303943237614, 0.8083404928490724, 0.8372480051801733, 0.8425106247754457, 0.15524517383861125, 0.15760389246726558, 0.12133033121797066, 0.16675401037451443, 0.17534166038126753, 0.16851514596986183, 0.31984111619308064, 0.6650129071589992, 0.6387061586595967, 0.20296389523489278, 0.2096709897104121, 0.20921754875300635, 0.19150629295065769, 0.20916712200696908, 0.18362966383400003, 0.18884570913559007, 0.18058968997562463, 0.17756922819863774, 0.18857648744777133, 0.18118793931820198, 0.18091468795819599, 0.2008464125420676, 0.18127894607568573, 0.18969459676847655, 0.08300213219504271, 0.08529645826498888, 0.0872906724552488, 0.07815829828704013, 0.08503703151930009, 0.0759270150740542, 0.07567417895822204, 0.10466492853930254, 0.11022251788617177]}, "mutation_prompt": null}
{"id": "c1946dfb-396a-4c32-98a8-c0e8dfbb13bd", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Adjusted population size for more exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Altered inertia weight range for better convergence\n        self.cognitive_coeff = 0.8 + np.random.rand() * 1.0  # Expanded cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Adjusted social coefficient range for diversity\n        self.F = 0.5 + np.random.rand() * 0.1  # Narrowed scaling factor range\n        self.CR = 0.85  # Slightly reduced crossover probability to focus exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.05, 0.05, (self.population_size, self.dim))  # Reduced initial velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with multi-elite team collaboration\n            elite_indices = np.argsort(personal_best_values)[:max(5, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.3 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer integrating adaptive differential evolution with multi-elitist swarm strategies for robust black-box optimization.", "configspace": "", "generation": 62, "fitness": 0.2996880039754947, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6505314202096427, 0.7847901169342801, 0.7478578645534572, 0.6935437151097532, 0.7676766047296173, 0.7583483886297451, 0.6847174805535384, 0.7831314492310556, 0.7424074827295979, 0.2928918668942867, 0.4263008594251525, 0.43438931725389107, 0.29413259988803686, 0.47208875652207405, 0.4690338695552828, 0.18894617565347138, 0.505381495355028, 0.36177747602150623, 0.14628633381105083, 0.15353394985514046, 0.16867523631797432, 0.21111208026766526, 0.14534826391727107, 0.14537440456480177, 0.15628610510488194, 0.14016002392070404, 0.12593585609236813, 0.10324633958262364, 0.1256416012518422, 0.12117619874367136, 0.10982785871948886, 0.1203894730836983, 0.12309113158331897, 0.0872065856888894, 0.15699618738436116, 0.11038224433743438, 0.9770368395256781, 0.9755860540688488, 0.9756369986591495, 0.9780604227092548, 0.9753737248220231, 0.9763606937267977, 0.9770651750483583, 0.9746839096729142, 0.9763007682162382, 0.374987791804804, 0.5545448875828556, 0.566183979309514, 0.20273974339259582, 0.5345044580556704, 0.14817415410238022, 0.36373039668595175, 0.5005832612274368, 0.539628419060241, 0.5696582946425324, 0.22140305939163218, 0.7437662667189812, 0.630481094306806, 0.26277153616720084, 0.6810376292712272, 0.602614624473812, 0.7370825084201662, 0.7475176025277583, 0.17129719895126017, 0.19977176528443863, 0.23113397143757652, 0.11641124359639832, 0.20675770241998626, 0.12582141065078833, 0.31959481133823986, 0.3157746734749989, 0.1231059581288777, 0.022015738807698138, 0.20473562377507704, 0.2199254705189324, 0.12144592475926186, 0.21732221298382892, 0.13098478503829025, 0.030695792532676403, 0.22694099189585426, 0.08950524697138007, 0.041831208487047467, 0.012875414694624276, 9.999999999998899e-05, 0.028319285796341687, 0.005590516914771415, 0.029162689259703445, 9.999999999998899e-05, 0.009181954017476346, 0.016286567005415975, 0.05395905475143392, 0.06584147976969579, 0.11204840204842825, 0.04299096365779098, 0.04763844344172319, 0.012517653553852814, 0.020511781473679935, 0.07290356890302041, 0.029144164622479596, 0.03728794500874866, 0.04176699394597494, 0.07598946774376436, 0.07154209041935133, 0.20236977165170966, 0.22873050632175063, 0.05123812828032226, 0.06171972604788534, 0.07724259436015835, 0.10137608547745225, 0.20193415187372432, 0.21440801080125704, 0.14582397338550368, 0.19644282312364014, 0.1819658674681054, 0.04619983865506494, 0.31986046112651423, 0.17126228490941098, 0.45422804595683786, 0.5247642867717575, 0.5329524658866702, 0.5027571057256977, 0.5628705878944655, 0.5360103602109405, 0.48034586836398585, 0.5283064484956661, 0.5171048373888637, 0.10926440871657617, 0.13595301521343195, 0.10932214173919708, 0.12597422544209347, 0.12954181591601177, 0.12172405107645878, 0.11124754906898582, 0.11664204571797143, 0.1081549046307898, 0.30751870116105406, 0.2677435275307898, 0.21893633244916977, 0.16516105445918872, 0.19728263387959655, 0.27984607769696423, 0.22854678307594822, 0.201800251212506, 0.18519215721405968, 0.38723993611781493, 0.34559947880913044, 0.2501136942485389, 0.28224588177167875, 0.435425211454722, 0.4705757151059592, 0.3600179298441566, 0.4663764541849488, 0.4631920704976765, 0.2553962490592153, 0.2089054223579797, 0.204405047142463, 0.21467436193395573, 0.24207899801350952, 0.20739815643021653, 0.13062174871574517, 0.20102724794401017, 0.24522839810026487, 0.20247033784484325, 0.20765302859301338, 0.21267937162210915, 0.18504182185543572, 0.2216606364010768, 0.18988246254708774, 0.18302323697139955, 0.2184042289296826, 0.2615266240697507, 0.37712296084530494, 0.5440960236099557, 0.6643579453671775, 0.2249148892643218, 0.46081689270244663, 0.2188023501131675, 0.20379352052753474, 0.21393103460727958, 0.18744867113614538, 0.8155730669671336, 0.8513203728401917, 0.8539423541506277, 0.1558704447435899, 0.8515378756701074, 0.1571358730816892, 0.17319994639880665, 0.1749633418916312, 0.17750102136816825, 0.4394917944601807, 0.6745943708615751, 0.779708532606018, 0.2069805968795021, 0.5874799243140376, 0.2077939794966569, 0.19916760882363438, 0.20835918023438071, 0.19750301128578962, 0.18886449483138035, 0.1735938776433923, 0.1895831508109742, 0.1859059342737398, 0.18393258062257478, 0.17959511297316078, 0.17835993355089053, 0.20946681527825295, 0.2033886174120907, 0.08291495642346869, 0.08775222717306497, 0.083697970153644, 0.09021377239070683, 0.08584204454888711, 0.08858776755121711, 0.10919867770323877, 0.09768106951273292, 0.1170313395134972]}, "mutation_prompt": null}
{"id": "7b124569-af3c-4db9-9c0c-58c48f69eafb", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = max(30, budget // 10)  # Adjusted population size to balance exploration and exploitation\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Altered inertia weight range for dynamic balance\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.7  # Fine-tuned cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Adjusted social coefficient range for group influence\n        self.F = 0.5 + np.random.rand() * 0.1  # Narrowed stochastic scaling factor for stable search\n        self.CR = 0.85  # Slightly reduced crossover probability for controlled diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                if np.random.rand() < self.CR:\n                    trial_vector = np.where(np.random.rand(self.dim) < self.CR, mutant_vector, trial_vector)\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Enhanced influence from elite partners\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizer", "description": "An adaptive stochastic hybrid optimizer using dynamic mutation scaling and elite adaptive learning for enhanced exploration and convergence.", "configspace": "", "generation": 63, "fitness": 0.14725858581067477, "feedback": "The algorithm StochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.16.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.24743176890641738, 0.2609066721608033, 0.27401226207148655, 0.2553811066945195, 0.24988321591940132, 0.2602749441838541, 0.22518819991517325, 0.23879764312229534, 0.23688259956844904, 9.999999999998899e-05, 9.999999999998899e-05, 0.0009368166988839022, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06032328325606573, 0.09225232487878732, 0.06387456215307097, 0.0646047202067066, 0.08593701833175638, 0.06469803864686052, 0.05870862747451433, 0.06746611243109746, 0.06717856016825496, 0.05796604631434987, 0.052663035953571136, 0.05370757819271654, 0.04239618299285153, 0.057538747179584626, 0.06405357969378256, 0.050921218131903645, 0.08110575049617896, 0.05883230273522544, 0.8139986615198029, 0.768257273088048, 0.806596244647001, 0.8125714772292771, 0.8040424253096573, 0.8125374492622326, 0.810628298601505, 0.7962150671553483, 0.8033493034378513, 0.09057942570848065, 0.12957243123975115, 0.11383062291010371, 0.11180247300298574, 0.11662892136479153, 0.11650192958883632, 0.1026975317683757, 0.11355081352375218, 0.09682326334030023, 0.16545842596542693, 0.1717971373689321, 0.18565079051906086, 0.15690080716257904, 0.16858667332015997, 0.19555857417861922, 0.1516451753248722, 0.1752505602249459, 0.18685504601052594, 0.03854098706341569, 0.07295203729003064, 0.05604796030443415, 0.04435831622147801, 0.057101807495837376, 0.044337556665393296, 0.04959580074053449, 0.07438504967136872, 0.06902043842596595, 0.07257878972377274, 0.05364402716076477, 0.0661439915050529, 0.05505943362747001, 0.061774447796988374, 0.05488813340547949, 0.05570761159499049, 0.05874542854820297, 0.05315912985633642, 9.999999999998899e-05, 9.999999999998899e-05, 0.0065155430077111776, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.053401054138567994, 0.056990666070008245, 0.06784564100118207, 0.06135540828568231, 0.10877530398265312, 0.05531147692769933, 0.026150412611637863, 0.04937524243269231, 0.08642658813796134, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014581857990790037, 0.009729464548273947, 0.026133456823661416, 0.009486786829584148, 0.022679694492978353, 0.01373869714881426, 0.014421114872870233, 0.013518746465485676, 0.02017393476193119, 0.2581331248086751, 0.2572481231971723, 0.2616293563233295, 0.2495210026111857, 0.23904790901232098, 0.24086192453043775, 0.2565366104170923, 0.2520628967844637, 0.25681803339690046, 0.06262350004959916, 0.06500686159919955, 0.06525440870339116, 0.07159496220007, 0.06542793453582796, 0.07658857950513287, 0.07305887085841023, 0.07038937242413035, 0.05838246595146268, 0.14628900290002167, 0.13184865129320933, 0.14052245867671265, 0.1333038892295848, 0.12287479174754934, 0.14034788235786577, 0.15129796773771942, 0.1430866202904223, 0.15055034071337792, 0.186964851827368, 0.19737607476456775, 0.20455712487416766, 0.19337643262392645, 0.21492706747063461, 0.20149410787319078, 0.19645404391589216, 0.19424078485312324, 0.1931492039938395, 0.13298525446603804, 0.1406631528548532, 0.13282579048881749, 0.12873448359876494, 0.1360876586359414, 0.14693472334041402, 0.12641219538036808, 0.15609029880158032, 0.13939637063520516, 0.1893359136295839, 0.17926907122555713, 0.18619268961741142, 0.1746451845081105, 0.18944255084975625, 0.20855863623857263, 0.19374563209738427, 0.18575788175593722, 0.1615420433151027, 0.15291617282685543, 0.16389334320727234, 0.16859921609590933, 0.15212453554686012, 0.1614655077532141, 0.15980866020851048, 0.18074304892400683, 0.1647576839730902, 0.1580875346961348, 0.3225698070587304, 0.3043252754672249, 0.2861266585454578, 0.24778722158409305, 0.26495278427421487, 0.27179425541254587, 0.31518753753626927, 0.24592089027994302, 0.24073366190428758, 0.1969884101263326, 0.22929611403437622, 0.1837444597906368, 0.16063118116278396, 0.18055089898663723, 0.1605007407729765, 0.23189592052330876, 0.23885431838987348, 0.18385090919338898, 0.20463571350996757, 0.19799052346723167, 0.19799052346723167, 0.18305680042653272, 0.18384806202800874, 0.17826838032730807, 0.17926143293013885, 0.18552636984337845, 0.20102839975222608, 0.06396918613103375, 0.06323759234795812, 0.05583524740539525, 0.06119344135433802, 0.0902231989245127, 0.06726657802530811, 0.0675322838831125, 0.07423988713432828, 0.06421564150194514]}, "mutation_prompt": null}
{"id": "66653a1d-4c69-416c-9153-06f3049f70e7", "solution": "import numpy as np\n\nclass EnhancedStochasticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 14)  # Adjusted population size for enhanced exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Optimized inertia weight range\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Adjusted cognitive coefficient for balance\n        self.social_coeff = 1.0 + np.random.rand() * 0.7  # Refined social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.15  # Adaptive scaling factor for mutation\n        self.CR = 0.85  # Tuned crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticOptimizer", "description": "An enhanced stochastic optimizer using adaptive mutation and elite-guided velocity updates for improved convergence.", "configspace": "", "generation": 64, "fitness": 0.31299512662353274, "feedback": "The algorithm EnhancedStochasticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.7453859315495044, 0.8141941009731829, 0.7890441160236683, 0.7360780872685162, 0.8177185607912962, 0.8071237645456472, 0.757571337527275, 0.8182384162725844, 0.8137278226853036, 0.35347995568273227, 0.5781700945486563, 0.549385370443191, 0.040110736473174424, 0.5813168615938553, 0.5843737613974253, 0.4458911649655315, 0.5692010542600592, 0.04537086280573999, 0.1356296937481105, 0.1608380678846686, 0.17621718003730835, 0.15817729073195552, 0.14011376409791287, 0.11314802821731484, 0.1176057472317178, 0.13156816608940458, 0.17101081661871054, 0.12154752761158494, 0.10288294095425066, 0.1248026115300983, 0.11879268794554332, 0.14493835685482304, 0.10495784874975145, 0.10522783893191823, 0.10976104167916345, 0.1070489927638184, 0.9730576395496515, 0.9693989782186948, 0.9807164438112589, 0.9805063846638918, 0.9729082198621934, 0.9792268423935803, 0.9817488551007446, 0.9799331680577056, 0.9808574032152492, 0.45206781049595435, 0.5940993260685823, 0.6540869143785348, 0.41656204342101, 0.6144230629676461, 0.1493233505898739, 0.4639464875953705, 0.5990261373670267, 0.6394165357690785, 0.3486759439503391, 0.78059006772017, 0.7766206965420754, 0.2135394307041405, 0.8305778088310986, 0.3741768385554727, 0.4341952258435887, 0.5951967641323195, 0.8122885385333919, 0.12334439435531408, 0.2167846923466904, 0.12874378642778905, 0.21620528934633654, 0.22062080126506545, 0.12868639031581586, 0.19040595575126174, 0.21416301450120911, 0.2494835397610201, 0.21135114884004347, 0.22462418348311508, 0.2633755970864907, 0.1891518475016556, 0.2340364287124036, 0.25669158917567947, 0.21505901589558007, 0.2726322908586365, 0.25665304911623277, 0.032922176917132284, 0.04373720093985012, 0.06346684684139214, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00037547244619440256, 0.06984360250567201, 0.08074110409589685, 0.1220261554211376, 0.09761579507504703, 0.02258851259653416, 0.016217958946063482, 0.12383315278416285, 0.058381257792185504, 0.07577565296382105, 0.03424817187756546, 0.0438500176054325, 0.04381545379806817, 0.10963540018098372, 0.07468220005793647, 0.10673494335981526, 0.07791275289092847, 0.18023161204670868, 0.18829680649791403, 0.0883778342860152, 0.041306005030514514, 9.999999999998899e-05, 0.20212009868321168, 0.26281729720828184, 0.12545783035723057, 0.0756358273687574, 0.0790478228829441, 0.054645748038851916, 0.5139871158112475, 0.5391140872831395, 0.558719773296334, 0.5005167245954139, 0.5446970583547397, 0.5452741823903207, 0.5086547922670867, 0.5783026625620791, 0.5607005713902722, 0.10245484908901159, 0.13608641729165993, 0.17350501363323567, 0.1162897002831722, 0.12032945480698132, 0.10209543547050581, 0.11670263241868839, 0.11936100003034411, 0.12934834081077773, 0.12758601344943077, 0.3657038470608913, 0.3624461878727703, 0.14703452369449643, 0.13234275237784654, 0.4831781168339787, 0.1594303919465041, 0.17744554883561436, 0.20169219715145892, 0.34180087935007797, 0.41827299668261253, 0.4674447634365937, 0.37435973774000086, 0.4633006525632263, 0.44503987257856925, 0.4067339180292161, 0.47952010290751856, 0.30211390000041294, 0.16382882615573102, 0.1819029762138803, 0.13623486419536313, 0.27502236265453817, 0.25793572542926835, 0.3046388075848777, 0.3014419926750509, 0.36625669150139817, 0.27062174503155034, 0.2038449506258062, 0.21268459179979238, 0.19330541873615537, 0.1838812757483963, 0.21251155817347012, 0.21017543906248104, 0.21459818482324766, 0.19529109015985302, 0.23073158828758566, 0.5357192469668898, 0.6552757656995185, 0.6670527997330096, 0.180919525710738, 0.21810364424419781, 0.21146318085501992, 0.20396642960482225, 0.20352605592099193, 0.19387540918246826, 0.723690208426202, 0.8665452433786286, 0.8756911218530506, 0.19400767595207602, 0.1477232581723229, 0.14659985281715604, 0.17017624851598123, 0.1688893603243492, 0.17016760780590934, 0.16889403192067598, 0.6379923542039725, 0.7657393737625934, 0.20938620624086524, 0.2113340782803802, 0.2108770878990741, 0.5893537306796268, 0.7344399604495173, 0.7859762369241853, 0.1978853479217374, 0.2177069257433777, 0.18921592068761228, 0.18787798181277882, 0.19307239318462033, 0.1787294891205944, 0.1812162629402766, 0.1965847985950424, 0.17721334678888523, 0.08856617638876763, 0.09130363185211154, 0.09112658457441325, 0.0948662901006957, 0.08970362409954902, 0.08884571053778911, 0.09684471615487711, 0.12422183338626924, 0.19131507205414844]}, "mutation_prompt": null}
{"id": "e5ddaf67-bfe6-4a3c-843e-c9658f49c6d3", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Slightly increased population size for diversity\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Modified inertia weight range for enhanced balance\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Small adjustment in cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Altered social coefficient for better coordination\n        self.F = 0.5 + np.random.rand() * 0.1  # Fine-tuned scaling factor range for mutation\n        self.CR = 0.85  # Slightly lowered crossover probability for more controlled exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Adjusted velocity initialization\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Enhanced Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Enhanced Particle Swarm Optimization update with cooperative sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]  # Increased elite group size\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))  # Adjusted elite influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridOptimizer", "description": "An enhanced adaptive hybrid optimizer utilizing improved differential mutation and particle swarm coordination for versatile problem-solving.", "configspace": "", "generation": 65, "fitness": 0.28846680594114343, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.635435829064848, 0.7582387140730316, 0.7612458972483072, 0.6685920975571178, 0.7591555000463251, 0.7561848779212539, 0.6527312275851447, 0.7838351962877799, 0.7648219142080539, 0.2930113486027093, 0.4283966480294311, 0.468380876999117, 0.18519378321066504, 0.48643947635190554, 0.3969995986720922, 0.3233897797973333, 0.5414920357173156, 0.4417291236978548, 0.12096685128891749, 0.1290284231712734, 0.13198181890105987, 0.12274100078618322, 0.15277221947262876, 0.12196914944585902, 0.1483713040832343, 0.12852627139930684, 0.12960497344592092, 0.1070960909686226, 0.1080640625309558, 0.11559368172468243, 0.09487991598522116, 0.1282569679204073, 0.09350938705006806, 0.12684615595088422, 0.09647635085091366, 0.14958395965022242, 0.9770748835045552, 0.9755682592342864, 0.9756412094225314, 0.9781370868643909, 0.9753984227436693, 0.9777658522542436, 0.9770992599160313, 0.9747697354926574, 0.9763030221289585, 0.4013073860407457, 0.5494895102005065, 0.5608885378335462, 0.3636619099758388, 0.47193821033156436, 0.14974423983522323, 0.37793913424200787, 0.5476670922255997, 0.08795435717139821, 0.5432552753352613, 0.6519301798035958, 0.7631893319343774, 0.5108672407570879, 0.20830372790778406, 0.16065482604865533, 0.6638130897845822, 0.7598609399583971, 0.23783977093304154, 0.173084909054118, 0.20764562366387418, 0.25496199283418153, 0.1253765264493717, 0.11821278281170855, 0.20766134771667022, 0.19151614245059878, 0.2418874450665096, 0.2666404491706241, 0.18597350612075336, 0.21522198339653287, 0.2143589070567491, 0.17794079719616895, 0.22465872124073571, 0.23362283539364703, 0.08484288862077305, 0.22065899156636404, 0.09377527580207912, 0.0023764841939765136, 9.999999999998899e-05, 0.019115832968398694, 0.03231157034534393, 0.07033545748350967, 0.07272255712755482, 0.04683573262839069, 0.026082706544206302, 0.004640140165450113, 0.08007650151977308, 0.1340616583088058, 0.08202982383683632, 0.019560669843795786, 0.10278687564368028, 0.03303208295109494, 0.06267043324625898, 0.06773821046000905, 0.0636197386096563, 0.03668012802681164, 0.04152466353315265, 0.04138171963981352, 0.054315060315269004, 0.21338548166335836, 0.16629379447387915, 0.10838888460375706, 0.19404117129811316, 0.07666527962742553, 0.08322003636542163, 0.18870213182877393, 0.10676272648008178, 0.10537973935879852, 0.15964980523532357, 0.1486278745564874, 0.053746556900167164, 0.17897106009788677, 0.04764449450146513, 0.4535059849275406, 0.5469309814482074, 0.5277081592664352, 0.48455615408572905, 0.502590009375814, 0.5142355657423336, 0.4597807196393233, 0.5422835373859847, 0.5414284998621428, 0.12265794635383354, 0.14335807231185282, 0.14916506102526494, 0.08573714711794833, 0.10349053248240636, 0.15402833991257336, 0.09632635867403583, 0.1363191480116982, 0.11167521443527328, 0.27426492108874445, 0.15111146790157703, 0.18150886089240958, 0.24246499272936306, 0.14604552022539008, 0.1542532922309492, 0.15868509520459506, 0.2148410197609788, 0.5276569021375004, 0.3221547158068504, 0.4122480638050241, 0.45806442005405823, 0.33656916389473734, 0.25934568493118415, 0.29495028966398584, 0.34395350941839675, 0.46344446941520157, 0.4640415265738296, 0.13666927943844054, 0.23100235759269327, 0.14500618060567028, 0.16528031819886224, 0.22990490890339332, 0.21502434142156768, 0.17514170157715958, 0.21849607655233438, 0.20093552033698736, 0.2084823606131634, 0.21422964777164355, 0.22915691624736834, 0.23316231351195416, 0.19987167467199307, 0.2760867000730166, 0.21210883710090855, 0.2265674414930916, 0.19207896946424652, 0.28406461045733067, 0.23208963643477487, 0.20413282599847393, 0.1916861423613062, 0.5621575703044484, 0.1959287681843893, 0.20751005233618902, 0.21744047938238975, 0.21937688085076334, 0.8029688685991807, 0.8583742863682048, 0.8769148149274801, 0.16346127347671302, 0.1959493170867329, 0.15644625549556024, 0.17525496013863973, 0.17465574910129888, 0.17678203503628775, 0.5281182949098603, 0.6568383276630432, 0.7124520207553475, 0.21067826881528517, 0.21069969088335527, 0.21059500638186912, 0.20085821947415639, 0.7526130419053437, 0.19863859931464134, 0.18542533995883304, 0.18000025225358496, 0.1970668417446303, 0.1778874051511501, 0.20078132548643568, 0.20719440630572272, 0.17827677804386988, 0.18732069420757147, 0.188611295014112, 0.07707176463869059, 0.08634791862249735, 0.07260379805878603, 0.07881324268018874, 0.08758922951986037, 0.07871256230913881, 0.09263369162640689, 0.10763524589797668, 0.08446219018541468]}, "mutation_prompt": null}
{"id": "2565d0a7-6f8e-4357-8e2a-1cb95f9caacc", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 12)\n        self.inertia_weight = 0.35 + np.random.rand() * 0.4\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.6\n        self.social_coeff = 1.2 + np.random.rand() * 0.7\n        self.F = 0.5 + np.random.rand() * 0.1\n        self.CR = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridOptimizer", "description": "Enhanced hybrid optimizer utilizing dynamic scaling and focused exploitation for improved convergence.", "configspace": "", "generation": 66, "fitness": 0.3007512491063511, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6906210969783424, 0.775893308153254, 0.7609723166466289, 0.7125902450000468, 0.7722514353995373, 0.7679965308018335, 0.6805612385681519, 0.7845054905149605, 0.7646851967998005, 0.34077411659416346, 0.5087329468827781, 0.44650750910398285, 0.2705343788702973, 0.5305639070987874, 0.3866505581857408, 0.3067693564904702, 0.5395700178639771, 0.5038152844715273, 0.1221327840517501, 0.14144403484613266, 0.11116516065626114, 0.09885175191880302, 0.1388874461463434, 0.11078489813069003, 0.15204045743083283, 0.1368589517726324, 0.10352755577614026, 0.1179671662943792, 0.10051066733479197, 0.10812586293822113, 0.11725785059187632, 0.11968403776488534, 0.12422961507178532, 0.10132462496707084, 0.13971741550082772, 0.129931216003648, 0.9779988812197115, 0.9766721945373446, 0.9796404988462477, 0.9778561371401528, 0.9775410954563858, 0.9780527570280203, 0.9778994173558522, 0.9757127193124877, 0.9773375591871011, 0.3980747318906911, 0.5713603406988896, 0.5722583812004993, 0.3233171247875901, 0.5378809689877593, 0.5759353963077347, 0.37151612792313027, 0.5345492150443809, 0.5020567306207343, 0.7103585169721023, 0.36981646885721176, 0.7173459321006913, 0.3339252605428765, 0.20916168921620593, 0.19229049664902387, 0.5589380526400123, 0.6902146371985395, 0.7023545863331921, 0.1680464120449362, 0.21374200805992594, 0.21514676407992384, 0.175576759924147, 0.2234874424966139, 0.125287953624036, 0.1179911481793281, 0.22120913237739248, 0.20979697490622462, 0.11194346040235792, 0.21907848191428836, 0.11146242465922462, 0.19180186009738442, 0.21318501966285774, 0.1998237322566403, 0.19049482281257657, 0.08839596996335508, 0.12678724602105962, 0.03039585237515785, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.006389237301899109, 0.03105203635138476, 0.008412891736683026, 0.004996648175265572, 9.999999999998899e-05, 0.044856248906433804, 0.07722810401201186, 0.024438726028272684, 0.009231181475576666, 0.0552677785363509, 0.021137142049163615, 0.060188426882268886, 0.0602704794889205, 0.05483748139319289, 0.03680762494786616, 0.04686081431642852, 0.04874501716396684, 0.0761582741118656, 0.13957966063406746, 0.08731133288926307, 0.10528338817353489, 0.05918511378380642, 0.23289034347327253, 0.10880897232322206, 0.12093495941057553, 0.23065089910014192, 0.13446502667467086, 0.21462663861036113, 0.19846136209094445, 0.046996308440444556, 0.15978063120393438, 0.04734346966763914, 0.47332223131360407, 0.5433458007148391, 0.523764195030163, 0.47647363936967524, 0.525509537158237, 0.5078260522761046, 0.4693729362475154, 0.5362976455054598, 0.5438492283277649, 0.08792980407709805, 0.12534520221926282, 0.08394976813051014, 0.09952939174657471, 0.12447992341525893, 0.12072830114944011, 0.1037070669164013, 0.1432504461606472, 0.13536889024753018, 0.24045672774989169, 0.17736253320820072, 0.4254553666976948, 0.12855325520624084, 0.26942426927911356, 0.2410324402210836, 0.1562587256496617, 0.15209749797779348, 0.24281022306015698, 0.3509664081918036, 0.3992097954142346, 0.42111426137788954, 0.3308398970296714, 0.23781332543348144, 0.41395154475245155, 0.3909024524594211, 0.49826989962553303, 0.27694690680702005, 0.19969801700936962, 0.36348773771075216, 0.19885003045998817, 0.19979299554908347, 0.21260139959453883, 0.21031804244293328, 0.2802086416956495, 0.1980320285872027, 0.29154142948289774, 0.19961445271740208, 0.2112934481579687, 0.18939150401099092, 0.21812490855812494, 0.22644597506681752, 0.2117276042467633, 0.20814325671748513, 0.20576530713518204, 0.18395694719268874, 0.2265977662275993, 0.5972728106785279, 0.19261491018760712, 0.37438330717154744, 0.19475397706374298, 0.2118439433039605, 0.2047247832015504, 0.23017893189461847, 0.20385380158363708, 0.8043762682781155, 0.87899472267553, 0.8422560833392636, 0.7821794993526354, 0.824519183128619, 0.8310223578154988, 0.1746895753960922, 0.17691308206904321, 0.17589300987514123, 0.6307441060464525, 0.7620529153402751, 0.8311869232446323, 0.20800443106189004, 0.21098389850071275, 0.20996836414044018, 0.20917179769456462, 0.19191412185852263, 0.19635931412319207, 0.1712334928120426, 0.18833877292256862, 0.1749167421259059, 0.21633335477894255, 0.2032632183173776, 0.18072911738982944, 0.19289562133734572, 0.1802090979156692, 0.18590831860152257, 0.08890633208273269, 0.0878779151808522, 0.08272777231950856, 0.08774362659394774, 0.097760331971811, 0.07353713283841679, 0.11714478002078177, 0.09138551109022086, 0.08164343204890012]}, "mutation_prompt": null}
{"id": "60a520a8-d833-4140-b127-b23704865760", "solution": "import numpy as np\n\nclass StochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Adjusted population size for improved exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Adjusted inertia weight range for stability\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Adjusted cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.2  # Adjusted stochastic scaling factor range\n        self.CR = 0.85  # Slightly reduced crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 12)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.7 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "StochasticHybridOptimizer", "description": "A stochastic hybrid optimizer with adaptive mutation-inertia dynamics and elite-focused exploration for enhanced optimization robustness.", "configspace": "", "generation": 67, "fitness": 0.25920201141484084, "feedback": "The algorithm StochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.23.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6095846448231534, 0.7271312732600115, 0.713136769297594, 0.6590950121740082, 0.748543436427948, 0.7422960822437878, 0.6535061238580866, 0.7396162127235352, 0.7053392547280231, 0.25828595883451466, 0.3858838980819428, 0.4229682052367586, 0.25408509336899976, 0.42375746674033, 0.47124046748199133, 0.2748509396621901, 0.4093873086356269, 0.013896905363202094, 0.10003591422368807, 0.12615343001739088, 0.14480911134094276, 0.13781343435247295, 0.2714224822456769, 0.12078693028019039, 0.10640511714325218, 0.11399675532776798, 0.4248674512940096, 0.09918063327944404, 0.1167731602608254, 0.12343950761518663, 0.08318340897084942, 0.09897960616765844, 0.09183736278464694, 0.12420355732274435, 0.1182844876326915, 0.13483830018650256, 0.9779112667985445, 0.9773828324796063, 0.9775834771469212, 0.9783586588541359, 0.9776431055346083, 0.9773134689707361, 0.977560090026879, 0.9756247329072509, 0.976391782461872, 0.34575740484573536, 0.5016406593141334, 0.5317864609767167, 0.14492473996820954, 0.47850554403010337, 0.14891043747934296, 0.08919101103356619, 0.46739447555232394, 0.0892129872221552, 0.20528567830739597, 0.21751121578168064, 0.22163384888675342, 0.3062746868459699, 0.7493935289909108, 0.26931909254209496, 0.1474585245706057, 0.22139180869560504, 0.14225902196659868, 0.1647014235156019, 0.19918054626559378, 0.21156811544228726, 0.11836552816622226, 0.1981331103976317, 0.12476196850418653, 0.16145362153756926, 0.12364434166520821, 0.12465297222556981, 0.16843333108975533, 0.1911303777094877, 0.2051198323775968, 0.12977677189580994, 0.19684123772571493, 0.2222590645042919, 0.030655286571327323, 0.17606584218242383, 0.09693010141645009, 9.999999999998899e-05, 0.031944203598398, 0.04107055031268336, 9.999999999998899e-05, 0.001790987388362586, 0.008976944053682545, 0.020963380186479807, 0.0046048245200529525, 9.999999999998899e-05, 0.015251133564260999, 0.04135133981449257, 0.06350138032983232, 0.016183542795956796, 0.05626414835537363, 0.016830204407220828, 0.06400150361705381, 0.033381634074850286, 0.0322950667173747, 0.028454229104055817, 0.09626864550168446, 0.03945940599034625, 0.03530785455668761, 0.06916540105290003, 0.11058697533902173, 0.054568827614831616, 0.05777250032292813, 0.07512140435030956, 0.1456568927473425, 0.24980280430342727, 0.15607754019972198, 0.14666963139350087, 0.23704003722098976, 0.07586158343618876, 0.047872918603633074, 0.07364446382600764, 0.046809194881647476, 0.4414142557062908, 0.5122425970772568, 0.5087730858919792, 0.44457812906517846, 0.5318922248106128, 0.5184138092506436, 0.472842936394697, 0.5144249412802043, 0.5252265218744395, 0.0943464692823287, 0.146677462686282, 0.0997374523138509, 0.0963126279854476, 0.10362180663904585, 0.1613793969824373, 0.1446021087460675, 0.1396489449552919, 0.12954898602760423, 0.12714686142985943, 0.183926777883183, 0.1456434710138752, 0.12828631388403777, 0.1381405786769745, 0.21771050586329332, 0.23551789312274007, 0.2713962293770592, 0.23389267231175292, 0.3271721180752114, 0.3415648107574488, 0.41882107718956063, 0.29879268430948946, 0.350957269090602, 0.3595292024628298, 0.34953433146076507, 0.4188937910327116, 0.44355575114326307, 0.24695516580469845, 0.17327938158274991, 0.27239052418399146, 0.21484290918413285, 0.286327436787456, 0.2364820261744982, 0.22551576339701385, 0.2975423674990749, 0.1296384188012598, 0.23303191908819687, 0.2019886097595911, 0.21372072736553038, 0.2003336475279741, 0.2059487051585912, 0.1989180420246276, 0.1794001438810814, 0.21290185241867332, 0.20963435640333938, 0.18082182397292057, 0.18711950821688228, 0.19002719335293716, 0.21985466265496412, 0.2347581041039234, 0.22160913537859905, 0.3271251269865244, 0.2164371714207154, 0.19894955532620984, 0.7832757066599574, 0.832117756985111, 0.8390365258551576, 0.12937831875706363, 0.15650406167238473, 0.15634341962711928, 0.20484922640511927, 0.17459664423625, 0.19503455732647312, 0.4987176445077868, 0.2072360622848829, 0.7251753685488858, 0.2042171104290671, 0.20803792729580384, 0.2075548069269163, 0.19753931404348835, 0.1842186091896083, 0.20942529836784163, 0.17870591694820526, 0.19850261875298647, 0.17959921170643556, 0.18524348775314636, 0.20043195134657277, 0.19697273881987587, 0.18069508152626146, 0.19203496083667737, 0.19334608097116723, 0.07299802592436277, 0.10135961831084384, 0.08849951135544853, 0.07596648257863403, 0.0808874366032416, 0.08856154277014516, 0.09780599581365224, 0.10969706688179937, 0.09958713012465448]}, "mutation_prompt": null}
{"id": "2b3a6a6a-6bcc-49e9-a9d8-39db391cd464", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for better balance\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Tweaked inertia weight range for better dynamism\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Adjusted cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.7  # Slightly adjusted social coefficient range\n        self.F = 0.5 + np.random.rand() * 0.3  # Expanded stochastic scaling factor range\n        self.CR = 0.85  # Altered crossover probability for enhanced exploitation\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer leveraging improved differential evolution dynamics and adaptive velocity updates for superior performance in diverse optimization landscapes.", "configspace": "", "generation": 68, "fitness": 0.291377886975545, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.7079989460937768, 0.7970058122732605, 0.8134419224552168, 0.7326689881358552, 0.792611899655913, 0.814191938440174, 0.7057880836045864, 0.8211476029062914, 0.8055462432440459, 0.3577931758031154, 0.5056292287970322, 9.999999999998899e-05, 0.3829693360942409, 0.52511784604362, 0.5352932318631598, 0.34520142614928584, 0.5906087094404395, 0.5671440950640863, 0.09461359005041126, 0.14667478617986818, 0.11207566270895508, 0.12594047185108215, 0.13269782832171095, 0.5163465426092264, 0.12012088446502023, 0.13637358653148657, 0.06802129672575152, 0.10265070544279442, 0.11891837810907802, 0.10818554122798196, 0.12611093828839803, 0.15349952486855145, 0.12847868992070088, 0.1089230113384374, 0.1256592802651556, 0.1033981700971408, 0.9797376253064451, 0.971283893938794, 0.977472085995135, 0.9819557964003854, 0.9779184419250454, 0.9794278916579542, 0.9825371390131041, 0.9803170257988045, 0.9818703853264042, 0.45007435020505304, 0.5740004440746478, 0.6187959447392136, 0.16339555262386873, 0.6117367019552824, 0.1508213195016831, 0.3965474785711999, 0.5147024927560133, 0.6135468250290876, 0.21935778116018823, 0.21864478425752387, 0.223801122118222, 0.26510815073307936, 0.1927767918940736, 0.36768932941287336, 0.6217827040618517, 0.8004407639271383, 0.7741669954967165, 0.172989130253141, 0.2327403029718681, 0.251616387697594, 0.18201301260908864, 0.21468771622723803, 0.24867614956807926, 0.1825574128943197, 0.21626486740670903, 0.2499135199350485, 0.15349153626002532, 0.21402209483764145, 0.24304652887160672, 0.18313938677159192, 0.23235203600695198, 0.2697436095642184, 0.11891138380135124, 0.18686184189056143, 0.1274663739185975, 9.999999999998899e-05, 0.0004313394171276963, 0.06460181729936854, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.020199887371784686, 0.05507379768687404, 0.07324822866847769, 0.11765603132567137, 0.09946682754857428, 0.03482893829454292, 0.01541150961256299, 0.02080335424443469, 0.06531481430754171, 0.08728066463937179, 0.04374428194189528, 0.0944076687694625, 0.06446140913634013, 0.043589790249896954, 0.05815118253411744, 0.0651763752389437, 0.06560695967070063, 0.12801630553978738, 0.20836873233877296, 0.1127237342065488, 0.09685870623398207, 0.08872594640882381, 0.12123425203071525, 0.1926398535050472, 0.13826864386428728, 0.11554438246609866, 0.07713481591383664, 0.16578268119148976, 0.046417572061069445, 0.4859359158838239, 0.5134303040011533, 0.5478146200765158, 0.4988347230115959, 0.5237545380375694, 0.5614933930803601, 0.49879077662322147, 0.564544342974571, 0.5468742946009499, 0.11607849653690705, 0.15126779704646376, 0.10088553435241998, 0.1015087097258065, 0.11173823480343237, 0.12792617837612374, 0.11001736435116583, 0.11650945246060562, 0.1373767746799749, 0.17845235917691737, 0.1565111820738655, 0.17742945378272612, 0.2370529812217389, 0.22465241653817714, 0.17288278147721015, 0.1768884508151094, 0.23856716135141398, 0.19162492840205414, 0.3821535197514664, 0.34476417889518984, 0.3981789051207818, 0.35163082648252453, 0.37114379514098805, 0.32283413870496735, 0.396315302724212, 0.472694220185202, 0.2784491139246502, 0.24241084336879426, 0.18470737961098815, 0.23668857223619466, 0.2533604474754674, 0.24049338110883822, 0.23934246219879118, 0.31723318084366625, 0.21614482320822104, 0.17506046973658174, 0.19666429375164485, 0.2406739234290901, 0.19900844146341323, 0.20005200321962036, 0.2106156878402392, 0.21331341421745365, 0.20201196730688264, 0.21251632297487144, 0.21279859380702026, 0.18764301844561382, 0.24429159150938562, 0.24074001862321914, 0.20381763853486667, 0.18812538433186987, 0.22270392024567576, 0.20597786270991014, 0.21433134725288638, 0.2142110889587403, 0.8064997918727249, 0.8561754033479857, 0.8542241611680204, 0.20323971354143067, 0.19398465479125426, 0.15661868698757841, 0.16991048503239692, 0.16916785349390706, 0.1702090178253598, 0.381518413343226, 0.5190148942155854, 0.17549813290502603, 0.20591400879956667, 0.21109680929397623, 0.20967271003855303, 0.6637293622432738, 0.7248264250055734, 0.7770370840227786, 0.17827017391705358, 0.1954143155653577, 0.17594289429646637, 0.17822534381531097, 0.17466192029890204, 0.19718695361809546, 0.20792572403715692, 0.17869885109585448, 0.17859566121154458, 0.09090768207711897, 0.0934596974389682, 0.08399715314135225, 0.08635105099752305, 0.0923392566666269, 0.08172566436639661, 0.09354261488943594, 0.12517271585244472, 0.0939020725526738]}, "mutation_prompt": null}
{"id": "2c505b9d-7cf6-4962-b3ea-cdaab6a4a183", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 15)  # Altered population size to balance exploration and exploitation\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Adjusted inertia weight range for stability\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.7  # Modified cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Broadened social coefficient range for synergy\n        self.F = 0.5 + np.random.rand() * 0.3  # Enhanced stochastic scaling factor range for diversity\n        self.CR = 0.85  # Slightly reduced crossover probability to balance exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with enhanced diversity control\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 12)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer with improved diversity control and adaptive parameter tuning for robust search across varied landscapes.", "configspace": "", "generation": 69, "fitness": 0.2905990309682726, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.7207165686182141, 0.7997723394322439, 0.7947200505730039, 0.7195914586074628, 0.805797420353846, 0.76310801306821, 0.6958586455705285, 0.8050388182555712, 0.8108173563361711, 9.999999999998899e-05, 0.5594575157515838, 0.44326300592733703, 0.04057976743938996, 0.5937460237577301, 0.5633712486732623, 0.3915223301543288, 0.5704714407555957, 0.5493880800446185, 0.26169033742452996, 0.10439286030130202, 0.12550454473141348, 0.062401505443404726, 0.15346317473182147, 0.11644134763647873, 0.15350730877384233, 0.1545416926429165, 0.16136990158117115, 0.10284704838810699, 0.10078818019430402, 0.1708780830323845, 0.11642897982025402, 0.12025794321964967, 0.11236792498132675, 0.1358300142763792, 0.12645098756687878, 0.1415941896802151, 0.9798891871772828, 0.978322273290752, 0.9817167788287677, 0.9819547361612554, 0.9690331117154874, 0.9813089298291559, 0.9822369931268289, 0.9794290298596026, 0.9816127469672251, 0.4275198082836309, 0.6091401508053702, 0.5964119545610931, 0.46266871367990825, 0.587895355374727, 0.5859397109976947, 0.42625694113401746, 0.588414400004092, 0.4706301610711212, 0.5714606914376998, 0.21759087699331936, 0.7309875305903695, 0.16013530629242545, 0.21031164083323695, 0.18787954357757441, 0.6616026791394162, 0.17570597412976585, 0.802973233043971, 0.19913955039869957, 0.23588886487158633, 0.24885065338697, 0.13532726037415455, 0.2298991671357261, 0.12387925924691734, 0.16874842186932526, 0.13072547637027276, 0.2368044885493792, 0.17424900188121706, 0.21188437133479554, 0.22409585472727267, 0.19040962115228266, 0.2146242108464418, 0.2227115905315581, 0.1270399480005333, 0.24343836842622046, 0.2520559074680717, 9.999999999998899e-05, 9.999999999998899e-05, 0.03431238449829177, 9.999999999998899e-05, 0.005379982052728383, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0737887521740489, 0.08853106161555202, 0.16822066824996784, 0.012743182194175695, 0.015307826416664505, 0.011644600883312317, 0.07671410327386508, 0.03176537465395157, 0.08374032287870692, 0.035625563008489736, 0.04293147202971781, 0.10653309171760461, 0.0565048157887742, 0.12275591199446712, 0.06495021899108344, 0.12352904754365901, 0.1708051762483006, 0.23879922313783464, 0.03942204754118561, 0.20521374132663472, 0.193835681987936, 0.16201204412005754, 0.26494601821188135, 0.07549057081009214, 0.07514188873578498, 0.04757191881082268, 0.07737603320127728, 0.47940525896489183, 0.5448066318840222, 0.5418937169342294, 0.503118275624604, 0.5508722272003082, 0.5747875582739633, 0.5177276740116477, 0.547093124185067, 0.5532502342349733, 0.11802323363298961, 0.11889242516066678, 0.09775189784715332, 0.1401480225742705, 0.1449827621179982, 0.14407792258327612, 0.12486556244093827, 0.10330285948779638, 0.16477510192562095, 0.162598187509984, 0.15506106462185087, 0.20494663638848865, 0.17069474225932812, 0.22682578213398208, 0.19216337858394483, 0.22694123589116633, 0.1667080738169492, 0.1440801295500409, 0.3787146217753641, 0.4657949427399687, 0.41194979725829695, 0.37614045934196205, 0.40335349639450757, 0.43035347040795713, 0.40263687057505526, 0.3824857009866218, 0.49061872615046387, 0.12786252356483108, 0.16961428738168238, 0.27150598038706564, 0.21996504319266563, 0.3734921839262796, 0.22754321359311247, 0.26988951934569505, 0.14568566050144638, 0.19974140705766863, 0.23579902280713627, 0.21883175968791946, 0.2082233222333345, 0.20042592864604036, 0.2235124430090304, 0.19709404175138823, 0.21099082227718713, 0.21958717096450053, 0.211407758874824, 0.22861016432646497, 0.19278213264700594, 0.23591288676074762, 0.23095910799339858, 0.23316384200702445, 0.20661183545627815, 0.21850099362374054, 0.24330635591167948, 0.20248607823451426, 0.8049734348890607, 0.8592096351216789, 0.8666202184436138, 0.15628648310215376, 0.16296420343273987, 0.21045176200565807, 0.1700161197835658, 0.16635439815425912, 0.17023205096251126, 0.16841725602746505, 0.5302066714342, 0.16753480554072597, 0.20599806930990627, 0.21000112654054082, 0.2100641278993437, 0.46459977820997167, 0.6935798278858026, 0.15550542690848235, 0.17196494517709016, 0.1736146690064312, 0.20436780695396406, 0.18939330652362274, 0.18176923503780695, 0.19645153354494316, 0.17990949650875065, 0.18928297510838665, 0.18770193203031005, 0.0859412537601496, 0.09048883610880987, 0.08469891505249239, 0.07792338457498005, 0.08863817953061515, 0.08901808823061164, 0.11406431419473428, 0.08495417168492891, 0.10767565151400726]}, "mutation_prompt": null}
{"id": "9be9b305-2450-453b-9cd3-e1347a14c0f8", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, budget // 10)\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.6\n        self.social_coeff = 1.2 + np.random.rand() * 0.6\n        self.F = 0.5 + np.random.rand() * 0.3\n        self.CR = 0.85\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer integrating adaptive mutation and elite-guided particle movement for balanced exploration and exploitation.", "configspace": "", "generation": 70, "fitness": 0.28134370344792337, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.6473285061691265, 0.7312325041072296, 0.7275627018747768, 0.6259489486171781, 0.7496816586325448, 0.7066500615991632, 0.6642649207744407, 0.7290931474057118, 0.7376400194927819, 0.2630209880827674, 0.3692715835881347, 0.3133593706451163, 0.24191958959205317, 0.42545563188294433, 0.3350025119214888, 0.27401996380072946, 0.43588544028511644, 0.32602953401111023, 0.10908899699796182, 0.12824249161402224, 0.12863707152259052, 0.09862822652399195, 0.14418575110855458, 0.3781171454547021, 0.0982395622358736, 0.10505160247726653, 0.11059243228642368, 0.10107132180696465, 0.106758149353268, 0.12962219108391604, 0.11188773322765955, 0.12363509371502945, 0.12340264856096006, 0.1064532895580036, 0.11157271051430129, 0.11730177613114878, 0.9745570223076582, 0.9725979819996289, 0.9747628175807332, 0.9775010226085771, 0.9741526010935354, 0.9744091237817849, 0.9704683754280923, 0.9660903696386777, 0.9694737462595272, 0.3299316106166409, 0.4786278612896523, 0.47323651648791043, 0.2782229489202055, 0.5183338136810831, 0.3996832568150962, 0.31591557678193194, 0.47813263095958647, 0.42141062583879707, 0.5202719624338623, 0.6743253577480303, 0.21688995066360006, 0.2644321477879794, 0.6966356734877521, 0.3547637218948757, 0.22215550817109242, 0.4575146803991371, 0.6459566147107754, 0.15793414724139732, 0.24158972903707543, 0.2294813355671418, 0.16367768773217817, 0.20965848296451906, 0.20606828745177685, 0.17041101097513822, 0.20320956908522536, 0.2053404103291424, 0.10318753342266596, 0.19229700789278814, 0.21131991701617048, 0.1281727783594524, 0.18314774321430172, 0.22799820343115984, 0.1986638781668263, 0.22713576533452062, 0.22915310986374504, 9.999999999998899e-05, 0.0013446533656218396, 0.052853501212743126, 9.999999999998899e-05, 0.029266522602832246, 9.999999999998899e-05, 0.04643889261863987, 0.11473435642806395, 0.13925587171677567, 0.11208160811399759, 0.07998622136439226, 0.048913648823667444, 0.03256518351228532, 0.06102909841716997, 0.00924260814766309, 0.12718595608219452, 0.09752908352741929, 0.09713718391924453, 0.03634154259140121, 0.027058815037052097, 0.08158876008578264, 0.05146864330174539, 0.0922997060528582, 0.05914247823088459, 0.043446034416867785, 0.056732803732326254, 0.07085129067376306, 0.1664333041154047, 0.09355613957512154, 0.11279175872759573, 0.15554318674231804, 0.07607709469335566, 0.18448823562356076, 0.050259472950581086, 0.0538669756440846, 0.04677674046632785, 0.4650113794836548, 0.49442618429926266, 0.4900687143476109, 0.46049710038892944, 0.538059298765223, 0.5420122974645881, 0.4678404216747488, 0.5134036531722201, 0.5226529708406649, 0.08558096740005416, 0.07762885798942065, 0.12159107572893624, 0.14921788816418924, 0.1421178947432964, 0.13224995310834387, 0.10032095332755764, 0.10517755519320449, 0.31056428184786156, 0.30350653794015836, 0.12918182942578493, 0.34615525763990085, 0.15230952036337964, 0.19922343109044327, 0.19497797207740664, 0.22603171619379325, 0.1469944918398436, 0.2310950197899182, 0.35189822098175094, 0.409290469332112, 0.3404683251201086, 0.3675845368889159, 0.39527675635073667, 0.4119106848474321, 0.35445444116457725, 0.4457234270038929, 0.4343769223956647, 0.25110108841465917, 0.24772794845969803, 0.25011838452835244, 0.17785775332959952, 0.30152733865419923, 0.31607986161138246, 0.18772161693764244, 0.3724945158445875, 0.20874615091851634, 0.22791194705591777, 0.25316087232234163, 0.20795095760107174, 0.20564160832548428, 0.1907807012762902, 0.2178296970199659, 0.21636344732645008, 0.20641173187306783, 0.19697918612974963, 0.2249350600328225, 0.21801177417255313, 0.1992763100542616, 0.19541699463777062, 0.19427166492974313, 0.21583214786048133, 0.18758501318168563, 0.21718428258135525, 0.21191753424254134, 0.800066135944423, 0.8577463060829706, 0.8504926276297826, 0.13029215205880862, 0.13012955689024963, 0.13004819326466022, 0.203643243417712, 0.20559347918344306, 0.20330139976087214, 0.49398652505211393, 0.66944440231801, 0.6824555998769752, 0.2061388712871305, 0.20863431798530407, 0.20775683006214796, 0.1533127945224836, 0.6683734715789991, 0.12900188993498884, 0.19344883889627396, 0.19246211166409843, 0.18074002357564112, 0.19177698404956, 0.1803215549625935, 0.178240127808036, 0.17300368665195653, 0.19210973919538754, 0.17953505000722803, 0.08724338634538686, 0.08611417451189485, 0.08306100764931945, 0.09093765698571277, 0.09040847874276603, 0.09399588522017399, 0.08020776841743005, 0.08419811525108767, 0.08895819461780319]}, "mutation_prompt": null}
{"id": "dc3b7333-046f-4457-aaef-07aaea34b11f", "solution": "import numpy as np\n\nclass EnhancedStochasticOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(80, budget // 15)  # Increased population size for better exploration\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Narrowed range for consistent balance between exploration and exploitation\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.6  # Adjusted for improved personal learning\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Tweaked for enhanced global learning\n        self.F = 0.5 + np.random.rand() * 0.3  # Fine-tuned scaling factor for mutation\n        self.CR = 0.85  # Adjusted crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = np.clip(positions[a] + self.F * (positions[b] - positions[c]), self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticOptimizer", "description": "An enhanced stochastic optimizer combining adaptive differential evolution with elite-guided particle dynamics for improved global convergence.", "configspace": "", "generation": 71, "fitness": 0.266196900637075, "feedback": "The algorithm EnhancedStochasticOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.24.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.5103681195742029, 0.6761416647753327, 0.6488928841138586, 0.548430219493459, 0.6590547764332825, 0.6533804665587715, 0.5487569477030588, 0.68152548572943, 0.6884750740469638, 0.06638370263629223, 0.12088006187845057, 0.05454069545268392, 0.14843020731586798, 0.24638447605107072, 0.26914644508626373, 0.035377714508124325, 0.275139422115932, 0.31817195106351237, 0.09643291380338215, 0.11900416993367713, 0.1559658832110814, 0.09841207853493539, 0.09487452470347746, 0.14740098790686862, 0.09819906561548919, 0.1482385629709836, 0.10648554152736522, 0.08602626800900448, 0.1191466657632474, 0.09502973272039994, 0.08043894758658476, 0.08801282607590288, 0.10440350613672544, 0.10129403560908701, 0.09722277775565946, 0.12070276881002429, 0.9716695731578742, 0.9700475769416976, 0.9708796431553602, 0.9713217399624876, 0.9691081677209118, 0.9711568104299035, 0.9696518006376842, 0.9675234445350491, 0.9699665289491958, 0.28637070317306257, 0.3981496708136406, 0.41513622366937275, 0.2818968104443029, 0.39740025499634335, 0.39559324197668644, 0.30619240785542245, 0.3964339409955596, 0.4012168972825325, 0.4685701087352001, 0.5088643602869628, 0.6099732013178798, 0.2744099499408119, 0.4904718403892274, 0.26315524971562, 0.31102298196906764, 0.6528891308586771, 0.5203992789812191, 0.151272483333189, 0.17534721615603943, 0.16801447781576972, 0.10123477991465857, 0.17119923681652605, 0.10814737743154779, 0.18199986484059172, 0.18966542063506175, 0.17505832273420052, 0.11826447171051113, 0.17717146551537044, 0.1994496960627885, 0.14090855762215304, 0.19017395702669426, 0.19285824459203682, 0.10668651515165106, 0.2095914206911268, 0.1914665285922884, 9.999999999998899e-05, 0.02765899961137397, 9.999999999998899e-05, 9.999999999998899e-05, 0.026828776997633752, 9.999999999998899e-05, 0.011698175075616435, 0.009659589036748684, 0.048873909029797824, 0.02675165360687881, 0.0918681571958383, 0.052655504466026626, 0.06849806812840575, 0.006692932143148922, 0.011350115147382711, 0.034353617005099424, 0.16645993107036317, 0.0908435235109637, 0.01918807627963215, 0.03245364397993855, 0.03318129011706783, 0.03570275817429325, 0.16643731247650118, 0.05517484606217771, 0.0386536150276392, 0.06683003473233495, 0.060233154411792, 0.0563795199075543, 0.16446754600493263, 0.11072258474068863, 0.15409672104976035, 0.05796282293617572, 0.060674871240451456, 0.04291955034270922, 0.08939595762503738, 0.04546250166815402, 0.43025748945124476, 0.49873093852901473, 0.476704174187234, 0.40876522144928684, 0.46897174262406927, 0.4790183213860605, 0.4297157988863466, 0.5053634938704354, 0.4863285006969178, 0.11522716000693545, 0.11349408476826028, 0.1035167068878925, 0.09067426313964311, 0.09737239110373053, 0.14783307642357613, 0.09323221797991121, 0.09254129277362866, 0.09475372528628667, 0.13572349148644203, 0.13316192466825272, 0.23783869867199314, 0.19639727415099983, 0.1262716593073313, 0.22384650564574193, 0.14970611024717506, 0.14766184735447074, 0.22969147005440826, 0.2998040335234974, 0.3503049798478931, 0.4061435292683412, 0.2690286708078675, 0.36869688535011236, 0.367218679242307, 0.255487662710721, 0.3961772323478251, 0.3793166338596843, 0.2112696341216409, 0.2502441248936309, 0.24587728790921104, 0.2507059317543915, 0.296931175064687, 0.281933592821474, 0.240699514418526, 0.2751515847521109, 0.2754188087235, 0.21093215472623716, 0.21008371926460911, 0.2252545529355504, 0.17462893804370783, 0.23132353687043983, 0.1877641181502948, 0.1969377605106305, 0.2065563813915774, 0.20514657491629906, 0.18214332643978703, 0.31443068290292475, 0.21602513971547366, 0.21148506366879138, 0.2193560956274756, 0.20312231965838412, 0.19383457781827806, 0.3523821396478676, 0.22254254241212945, 0.7163840401391695, 0.8100250044382319, 0.8088319656304626, 0.7181686528465219, 0.7868954853501453, 0.7559893170735308, 0.13974835060219104, 0.1440022316048859, 0.11360551477401892, 0.3524297193984224, 0.6083691555603218, 0.5715495560635142, 0.4045559710464708, 0.20900469247730102, 0.20770687586575765, 0.15402144200052859, 0.5301666059456416, 0.6779901400186816, 0.19434272871569203, 0.17419512934905612, 0.19581060461557653, 0.191612769580092, 0.18977602631348978, 0.19636184718914562, 0.1977133224669908, 0.19346704334433917, 0.17648802919977336, 0.07227478988987113, 0.07922384765620605, 0.08562610579026408, 0.0992414034490845, 0.10978180684198813, 0.10791789941745389, 0.0848602778833989, 0.11147704805921477, 0.10247306430907044]}, "mutation_prompt": null}
{"id": "55d1f518-657c-4d3e-830f-27aad9e806ff", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(70, budget // 10)  # Slightly increased population size for better exploration\n        self.inertia_weight = 0.5 + np.random.rand() * 0.4  # Adaptive inertia weight for dynamic stability\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Extended cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Extended social coefficient range\n        self.F = 0.3 + np.random.rand() * 0.3  # More tailored stochastic scaling factor range\n        self.CR = 0.85  # Slightly decreased crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Broader velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]  # Adjusted elite pool\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Adjusted elite influence weight\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer utilizing a dynamic synergy of differential evolution and particle swarm with adaptive inertia and learning rates for robust search optimization.", "configspace": "", "generation": 72, "fitness": 0.23991112751276358, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.22.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.4591284322264999, 0.6329265957311296, 0.6158126718997631, 0.45908665482401156, 0.6397666437977447, 0.6110815505887894, 0.45018059643470887, 0.6510057217856458, 0.5874794526260494, 0.03127813796517498, 0.23910760319096214, 0.21102691783828864, 0.10981890329055843, 0.2267871369898149, 0.23000142944969215, 0.03845770069410759, 0.2597410649726084, 0.21726671214005777, 0.09404773333562022, 0.12212351397381194, 0.12363374466054267, 0.10390584753932253, 0.12096297429236769, 0.12679911640673525, 0.10616105763556594, 0.11114881571873159, 0.21113341929441665, 0.07191072811730226, 0.0992466503838596, 0.09370714567993277, 0.0813412272181897, 0.09503070809626735, 0.11195778639907494, 0.08560153602313081, 0.102053763699816, 0.09334739199173314, 0.9747430989408822, 0.9726851153837582, 0.9750378831240187, 0.9740281623902066, 0.973905241918, 0.9769734153459895, 0.9731387043743167, 0.972543611369177, 0.9722655109512054, 0.24886642273510706, 0.3771724020927836, 0.2973727417820301, 0.2551997813841119, 0.36523755256597856, 0.30257022455187954, 0.24498299756163722, 0.3864868830033379, 0.3744347257608708, 0.2520827593313054, 0.4515614812900193, 0.6093432252793372, 0.15725905004824003, 0.20583231412578917, 0.16012531331980318, 0.2475468163410418, 0.5202305615379764, 0.46671267038494046, 0.11146677093290713, 0.17579411928091138, 0.1942331447418847, 0.09265642945833008, 0.11902985002710442, 0.12226972625325472, 0.1294342415286328, 0.17039745629761505, 0.17934252703575404, 0.12761454914965764, 0.15374600955105466, 0.17019275989212979, 0.15381638022217103, 0.16278312443490361, 0.1982211473740394, 0.10915280985271825, 0.18291992135363866, 0.14096789407863175, 0.01237933619303222, 0.005845350580691577, 9.999999999998899e-05, 0.00615603541519727, 0.02720512331684999, 9.999999999998899e-05, 0.004899838434919146, 0.019947842536066518, 0.034147382808919824, 0.031051628147408472, 0.05850646184589314, 0.0981033350366548, 0.010865255509770022, 0.08800133131653598, 0.058838654534238644, 0.07257602785272288, 0.0842879139449989, 0.04602386941863501, 0.009450447909815196, 0.042820965418822965, 0.07324332281181045, 0.0312807333376397, 0.11108114554950099, 0.055263715013976755, 0.017507524204266933, 0.09870224574828967, 0.05812959390576666, 0.08034916396488245, 0.16896858543549675, 0.10258833839494497, 0.10273142952443193, 0.17279007506228117, 0.18909868502875404, 0.044171772264016695, 0.13893563517616092, 0.04693914423409773, 0.37248153625926506, 0.4498623375076546, 0.4555829096298242, 0.3987174462619989, 0.45770750641752, 0.4571397474296216, 0.41067463705995355, 0.4720125203565668, 0.4441777681172854, 0.1016358568738529, 0.10753130856870152, 0.08343316780101029, 0.08215103258144463, 0.10894209633962804, 0.10713425883415006, 0.09120432618278396, 0.09389981179289497, 0.10126386285903777, 0.1887669174543014, 0.12962630830670063, 0.25078337596863554, 0.15213199384539844, 0.132925164922862, 0.29823344358980497, 0.20783529437789117, 0.17810933957520936, 0.20767900870704947, 0.2777073300002867, 0.35447326576467986, 0.25057740779815996, 0.26985518761340843, 0.348991011305097, 0.31207142806933685, 0.26126014983223045, 0.3588044254731926, 0.33521854362457304, 0.19986788565158908, 0.25278384976225865, 0.21901301728862854, 0.16233040650272412, 0.2625071112920343, 0.22481461996195817, 0.17120299301546615, 0.23700867617498333, 0.17421516063913223, 0.19926560797382198, 0.22086328771365737, 0.20007350046892558, 0.1828078514865792, 0.23030514811041247, 0.19013262256671692, 0.1850123217160451, 0.19608115173897467, 0.2162963758669164, 0.24904014683889653, 0.3506735065541827, 0.24585880551314632, 0.18781611790147523, 0.2182079882840534, 0.19593515942721873, 0.18604241177127046, 0.19920496907421448, 0.3524323098035538, 0.6625579111148825, 0.788834337057071, 0.7710439203136705, 0.18204145449052955, 0.1962220531373794, 0.19524493769078066, 0.14254992376361075, 0.19993177290612185, 0.14912817662330202, 0.31478373146698846, 0.42043319460116724, 0.5330714084748491, 0.20363773329547152, 0.20554145431567017, 0.20667879237135822, 0.1513704404051156, 0.5031661361790514, 0.1521802374750003, 0.19347725402646376, 0.18225204232117254, 0.1808835702860171, 0.16994985740522028, 0.1914189972125928, 0.18057501976349954, 0.1837061949805998, 0.18866002497930057, 0.16975779857634898, 0.07557451505117752, 0.07842462535598638, 0.08263196462927258, 0.08268964765255771, 0.10173070386048189, 0.08604925400381758, 0.08657762983463968, 0.08826136180727007, 0.08983820997905201]}, "mutation_prompt": null}
{"id": "f4176069-7d2d-4437-8a0a-e2f9e29c14d6", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 15)  # Adjusted for balance between exploration and exploitation\n        self.inertia_weight = 0.35 + np.random.rand() * 0.45  # Fine-tuned for dynamic adjustment\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Broadened for better individual focus\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Maintained for reliable convergence\n        self.F = 0.5 + np.random.rand() * 0.3  # Further broadening of scaling factor for better mutation\n        self.CR = 0.85  # Slightly reduced crossover probability for controlled diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.15, 0.15, (self.population_size, self.dim))  # Slightly increased velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                if np.random.rand() < 0.15:  # Probabilistic decision to enhance diversity\n                    trial_vector = mutant_vector\n                else:\n                    for j in range(self.dim):\n                        if np.random.rand() < self.CR:\n                            trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with enhanced interaction\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]  # Increased elite selection\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Enhanced influence from elite partners\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer combining differential mutation, dynamic particle influence, and probabilistic adjustments for diverse exploration and convergence.", "configspace": "", "generation": 73, "fitness": 0.3093288473666299, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.7091035117556974, 0.820772101408426, 0.8076855644166855, 0.7226586232896549, 0.8128333042302783, 0.8041282657586988, 0.7491486916591699, 0.8152389710025016, 0.8008301852659389, 0.2330125554939072, 0.5676238348350464, 0.5616818041471214, 0.36587160075048764, 0.5388049949256969, 0.5992964774718855, 0.26826613033095315, 0.6100434602480225, 0.04935449998349739, 0.16091340187424152, 0.1491274337005951, 0.13368649211678785, 0.10815581874626734, 0.2105006196000262, 0.16428230918844533, 0.13870731419209514, 0.13422980451758082, 0.5443232852526787, 0.12446221552111258, 0.10708385147157551, 0.11213099435860785, 0.11993889069669617, 0.12158895422949012, 0.0880966344888453, 0.13875311620441133, 0.12423278398185211, 0.10646053649967258, 0.982176272350434, 0.9790838542390586, 0.9822884796752389, 0.9798854880539123, 0.9789177390321621, 0.9804735346190735, 0.9805298524104681, 0.9774767492354647, 0.9800815170267606, 0.4363214773980636, 0.6335765956096208, 0.6408201109628833, 0.36367048233493104, 0.488837307844037, 0.1521999788076015, 0.38706883907765455, 0.5945728685395271, 0.6341940822218395, 0.6433785492510761, 0.7803275195354482, 0.22015870156110784, 0.158994434022239, 0.21305951293822423, 0.19262400337850194, 0.540099324804372, 0.8132383830973098, 0.23222525181217046, 0.1822383384847972, 0.23655018225230828, 0.2825665892449084, 0.1935790133556261, 0.13103972286779297, 0.23050926962635254, 0.17778551019626865, 0.13293912734269875, 0.23645583812604198, 0.21588459997422926, 0.24469894583232177, 0.23250069929808348, 0.18160223452586888, 0.17533776857474426, 0.2889266912479146, 0.21982406047566783, 0.24705488990808022, 0.27386561675813004, 9.999999999998899e-05, 9.999999999998899e-05, 0.0057367981246130295, 9.999999999998899e-05, 0.007641079078352431, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.027707369996034292, 0.035947892383360935, 0.16336512337784426, 0.08973277637078991, 0.06352384631230712, 0.06629507472328333, 0.04358984559916168, 0.08439721029615777, 0.08465193489112677, 0.05487518356929, 0.03743295920611944, 0.04416182398463808, 0.0431552491877657, 0.08275792604536658, 0.10427753449608013, 0.0698392660466094, 0.06962957298973904, 0.20202423947219839, 0.10177101436324754, 0.03990326352668816, 0.09943766765355322, 0.10923194262967206, 0.10236156302042887, 0.21708154542592972, 0.22748557900090782, 0.05266489660310747, 0.04750708941581594, 0.048534863317301835, 0.48987087320429623, 0.5587642532961106, 0.558864508979543, 0.5325421441117119, 0.572317353423428, 0.6221427907819488, 0.5089946442787394, 0.5717821506298435, 0.550575093795811, 0.13630119987111045, 0.11140057656193947, 0.14987444136118644, 0.10197419427826082, 0.11845565013244463, 0.10779567339119456, 0.10223587821884061, 0.14539727091425558, 0.10093111401173205, 0.18987514083620416, 0.17925638224733031, 0.21857999987400967, 0.2338089852845776, 0.21101764440531867, 0.2804498136365444, 0.13823786619974998, 0.2948388786483621, 0.3858460160963625, 0.36024094421589337, 0.4845548418603006, 0.38328895977710276, 0.37527607821083764, 0.4652792428012865, 0.1923978428819737, 0.40407082807581485, 0.47276318540168405, 0.524244253291265, 0.1739153111108035, 0.3216427677718552, 0.1939127669866908, 0.2936598908185618, 0.18965419456144206, 0.18435445953374063, 0.33345480919774684, 0.16671523734907878, 0.3119398987252977, 0.190498067376477, 0.19566910934988768, 0.2001937504675988, 0.24183297996588704, 0.21650709878868957, 0.19545866720944205, 0.19152201549374093, 0.2306419780402793, 0.22214412146573115, 0.41118736216804286, 0.19766627720401042, 0.2242433172639059, 0.5121877704405505, 0.23917472676580542, 0.23708265368321535, 0.19364736913111724, 0.48721506516708235, 0.22261700336641554, 0.794333903505721, 0.861810075985937, 0.8642425200879635, 0.8197867678662126, 0.8254700966577362, 0.16295542272286423, 0.8029274909617586, 0.16676225811207568, 0.16762452285668716, 0.6114449891335136, 0.7346123671105407, 0.7244303959914906, 0.2040349482065832, 0.21322702719239617, 0.20826283179675564, 0.19490627493268364, 0.20901132101651843, 0.19769535237350522, 0.21152923017692093, 0.19241567883927047, 0.20468289455762756, 0.1793678599914612, 0.19623279290101736, 0.17344026805147605, 0.1831306980634042, 0.19243614281604304, 0.19118348256822326, 0.0930313132389714, 0.08755243699007209, 0.09560720487967556, 0.0869699974789302, 0.09802893284236802, 0.07774752480449587, 0.077957608026191, 0.0997251540064219, 0.11747668740528716]}, "mutation_prompt": null}
{"id": "8217473b-3805-48d7-9b2a-65380ac9f5a7", "solution": "import numpy as np\n\nclass AdvancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 11)  # Slightly increased population size for better exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Slightly adjusted inertia weight range\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.9  # Adapted cognitive coefficient range for balance\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Adapted social coefficient range for synergy\n        self.F = 0.3 + np.random.rand() * 0.3  # Adjusted stochastic scaling factor range\n        self.CR = 0.85  # Adjusted crossover probability for balanced diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 9)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.7 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "AdvancedStochasticHybridOptimizer", "description": "An advanced stochastic hybrid optimizer utilizing dynamic parameter adaptation and strategic mutation sequences to enhance convergence efficiency.", "configspace": "", "generation": 74, "fitness": 0.32386223048703267, "feedback": "The algorithm AdvancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "733ff506-fffa-47ef-ac23-3aa747fc80a0", "metadata": {"aucs": [0.703306293443875, 0.8051860623335235, 0.799190220819888, 0.7341118844559469, 0.7910979903803296, 0.8010268097514955, 0.7342745153075778, 0.8162850679955316, 0.8087155460559807, 0.38383789842183247, 0.565425589177893, 0.4853923401553588, 0.38435853523722097, 0.5639966530018998, 0.4639439837262981, 0.4251140849398911, 0.5836800476237888, 0.44449534461502715, 0.10895577765704534, 0.16644160425512944, 0.14656227042826375, 0.20979483715616065, 0.14564134670162965, 0.09330992761452128, 0.14120860317606543, 0.14102232460829833, 0.15095114275146337, 0.10586680719132013, 0.11475764607790917, 0.5152725153304829, 0.14493573846315633, 0.1232301460769375, 0.09361021206404108, 0.12257900075931616, 0.10232596996398202, 0.10359761309512727, 0.9774693434523015, 0.9767359186379211, 0.9786115497768788, 0.9780083555722164, 0.9777324598227406, 0.9770050177575901, 0.9780643156654398, 0.9744403110368496, 0.9763123428639799, 0.4279875672976111, 0.6280828332765577, 0.6470824972114302, 0.14611594958822693, 0.6160280032666113, 0.6334865206867268, 0.41005341900436054, 0.6196315281416296, 0.5646724085675425, 0.2074907463838065, 0.7295093455943298, 0.7914102086023396, 0.6579983434190819, 0.1921200676345789, 0.1605663894171041, 0.7277446081967524, 0.8086063155195016, 0.22662824133116044, 0.26721311614272925, 0.22309520548297346, 0.12930414594260053, 0.09792344656036167, 0.23202506053349736, 0.2568016180607897, 0.1794750926006281, 0.24594141265474379, 0.26145020283555975, 0.10446886544327938, 0.2412465376298727, 0.021514285321556192, 0.19898860910355542, 0.23369292090787186, 0.2964214418852371, 0.2425081829169491, 0.24989283564512343, 0.2691415256086711, 0.005548784718118038, 9.999999999998899e-05, 0.009098131734083692, 9.999999999998899e-05, 0.04667948459518956, 9.999999999998899e-05, 0.002681039061833479, 0.055556670425938814, 0.0036568594659889264, 0.08963613818373362, 0.06119611954442861, 0.041409877408346785, 0.024189810699886904, 0.034602286765402446, 0.07227180797015076, 0.08030012015072974, 0.09202996861974666, 0.03479201158842893, 0.037306015663137626, 0.04569899501992036, 0.04757408525033424, 0.0726521699279209, 0.11618121650032387, 0.17301204791197722, 0.1465678800030661, 0.0942306775868732, 0.14892360231567814, 0.16421606985135373, 0.14105116496228653, 0.18253254592949764, 0.2094259666854572, 0.07928682901242534, 0.129764353611182, 0.06554271566436876, 0.11874892675746074, 0.05665697910902834, 0.4927352678005359, 0.5527112165159315, 0.5772294661874986, 0.4926845955302378, 0.5794070123714223, 0.5435682185215774, 0.5199137237084666, 0.5686607774301944, 0.5701738692355935, 0.10816379277503707, 0.16851019398505473, 0.11936005663291394, 0.10303665674997409, 0.10904992943604741, 0.14205047033699214, 0.09809163468103232, 0.12365748899805928, 0.1488408019287042, 0.20546335784605885, 0.20814612605153182, 0.20294142384667913, 0.12405015731582913, 0.1982494185385555, 0.16499063250927315, 0.15365476575747017, 0.12778976559049515, 0.5653944972865896, 0.38436762216259024, 0.5031397144619194, 0.30580222138242397, 0.31878393490215995, 0.4940997257933689, 0.46827328308552973, 0.39675248118213235, 0.559774915609347, 0.2774245560882269, 0.31766701792831253, 0.23273592324230907, 0.25423298601159794, 0.27879682666866257, 0.19169858567988562, 0.2187207915213929, 0.16150726072675647, 0.16741193913064067, 0.1668883913059369, 0.21447162745709825, 0.2000859075432211, 0.21058117534496634, 0.18122000593690402, 0.19605767276995956, 0.20227845306100412, 0.22370925323983293, 0.22703931735870575, 0.2148612827561578, 0.23194539617201737, 0.2448422568547446, 0.2187477148740271, 0.3829078948458331, 0.18738361708440188, 0.20475307635905082, 0.2294133906105944, 0.5770119503608933, 0.2038213497312702, 0.8303427126731382, 0.895443347253934, 0.8767948209130375, 0.7707232419244427, 0.8414832806374594, 0.8540124214608432, 0.12814270549583284, 0.8600585276659385, 0.16821385001436284, 0.5101629662634812, 0.7413577887715086, 0.6959182809354639, 0.11280724523529062, 0.21129695629226042, 0.20952900080989245, 0.6462232752309321, 0.81447715333581, 0.8208574847841926, 0.1802912973036691, 0.1857495875217089, 0.19781196919132926, 0.1700401194308575, 0.18739453905272674, 0.1793258404926672, 0.18194223606459548, 0.18599308851636764, 0.18184999160244064, 0.0929734547336386, 0.09721646415757945, 0.09668399210586687, 0.08277303637508826, 0.08901073563916029, 0.07152618417450718, 0.08227394511399766, 0.1104319734865492, 0.12785061721707658]}, "mutation_prompt": null}
{"id": "2ced2248-8654-4adc-a329-ad063d74d70d", "solution": "import numpy as np\n\nclass EnhancedStochasticMemoryOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 12)\n        self.inertia_weight = 0.4 + np.random.rand() * 0.3\n        self.cognitive_coeff = 0.9 + np.random.rand() * 0.8\n        self.social_coeff = 1.1 + np.random.rand() * 0.8\n        self.memory_coeff = 0.2  # New memory coefficient for historical learning\n        self.F = 0.4 + np.random.rand() * 0.2\n        self.CR = 0.8  # Slightly adjusted crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n        memory_positions = np.copy(personal_best_positions)\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                random_memory_partner = memory_positions[np.random.choice(len(memory_positions))]\n                r1, r2, r3, r4 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]) +\n                                self.memory_coeff * r4 * (random_memory_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n\n                current_value = func(positions[i])\n                evaluations += 1\n\n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n\n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n            memory_positions = np.where(personal_best_values < np.inf, personal_best_positions, memory_positions)\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticMemoryOptimizer", "description": "Enhanced stochastic hybrid optimizer leveraging adaptive memory-based learning and synergistic interactions for robust solution finding.", "configspace": "", "generation": 75, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('operands could not be broadcast together with shapes (60,) (60,5) (60,5) ').", "error": "ValueError('operands could not be broadcast together with shapes (60,) (60,5) (60,5) ')", "parent_id": "8217473b-3805-48d7-9b2a-65380ac9f5a7", "metadata": {}, "mutation_prompt": null}
{"id": "ed7f2431-6f67-425b-8cb8-1af4316048e1", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 10)  # Adjusted population size for balanced exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.5  # Expanded inertia weight range for flexibility\n        self.cognitive_coeff = 0.7 + np.random.rand() * 1.0  # Adjusted cognitive coefficient for individual balance\n        self.social_coeff = 1.1 + np.random.rand() * 0.8  # Adapted social coefficient range for collective synergy\n        self.F = 0.4 + np.random.rand() * 0.2  # Adjusted stochastic scaling factor for diversity\n        self.CR = 0.8  # Slightly reduced crossover probability for controlled diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Expanded velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with enhanced sharing mechanism\n            elite_indices = np.argsort(personal_best_values)[:max(4, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.8 * r3 * (elite_partner - positions[i]))  # Increased elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "Enhanced stochastic hybrid optimizer employing advanced sharing mechanisms and adaptive mutation strategies for improved convergence.", "configspace": "", "generation": 76, "fitness": 0.29422958884603634, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.25.", "error": "", "parent_id": "8217473b-3805-48d7-9b2a-65380ac9f5a7", "metadata": {"aucs": [0.6349108585252883, 0.7682770342087986, 0.7662095451701647, 0.6455810804799125, 0.7884452472049808, 0.7814912697413752, 0.6760827111086833, 0.7795823748405469, 0.7892730183130156, 0.28513216112142215, 0.4995759783569983, 0.4638351888343254, 0.21407084809867616, 0.4961314892557914, 0.4341180353366202, 0.29245657745646714, 0.5239200415892991, 0.5288358239692208, 0.12707099216641504, 0.15066941643128906, 0.16034939374813761, 0.0979443671569119, 0.10130240143706082, 0.09342628919351448, 0.12916538213283002, 0.21631474672452755, 0.15968534444785132, 0.12061139210934013, 0.09171383355199192, 0.1258853382380748, 0.08856694933206799, 0.12091022563125842, 0.12769491974714042, 0.09358808473741043, 0.13416405310617974, 0.10148490257902121, 0.9781506858246696, 0.9769678382097123, 0.9783535605552915, 0.9778796461489135, 0.9753072039986452, 0.9773087146816953, 0.9783030506275907, 0.9769498681558471, 0.9776484232948524, 0.353404309455675, 0.5823742615638268, 0.5598817357260372, 0.36648647802948653, 0.5518482860749865, 0.5787543814364594, 0.3678036802990551, 0.5564350635514137, 0.5801029140674481, 0.5407112797270426, 0.6824284322121035, 0.7721479494303752, 0.25256841055008006, 0.21758703901476106, 0.21464342714567286, 0.5590493473855898, 0.7168210363693208, 0.7358995191357963, 0.1533696979710425, 0.2128405165220153, 0.2519238207617621, 0.11624742143181188, 0.21018587259685317, 0.09739228833879021, 0.10689806633725707, 0.20698241295998476, 0.10729367210040419, 0.16570752627769758, 0.2115066725522322, 0.021059713582892048, 0.17183771037387308, 0.22070298295090118, 0.228359185129148, 0.09180709586154534, 0.23487784018571856, 0.10094450231816532, 9.999999999998899e-05, 0.0021138949672060425, 0.0015526330787509757, 9.999999999998899e-05, 0.008597668896686783, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011798622157195848, 0.09683266261599621, 0.10576946652809671, 0.1711399302605907, 0.0986025506598518, 0.030453683863990277, 0.02417184351863544, 0.1183295782956919, 0.1315059565592177, 0.030918007298000538, 0.020804846837907287, 0.02875830411723257, 0.03964120917749803, 0.14943255978147096, 0.2162901815689574, 0.06909033334548309, 0.07070432708521912, 0.14209518213478223, 0.10495680014289865, 0.10126017142072474, 0.15299804542193762, 0.2289166074021457, 0.11443282741401783, 0.21714754743085618, 0.24252342405481742, 0.04688542950938923, 0.047488030880995735, 0.04677329091113247, 0.44839247557881656, 0.517975997240386, 0.5509351927381616, 0.4566664089735787, 0.5286494692962866, 0.5927089897780689, 0.46802983768117323, 0.5443200805442145, 0.5466380806954987, 0.08187324598729573, 0.11461257211376907, 0.12162573362534568, 0.11303160256171962, 0.163262099795066, 0.1471427792588691, 0.11452175897979555, 0.15185857682278803, 0.16113412525839887, 0.1607343973570432, 0.14721924165386757, 0.2147900739794798, 0.159372570586937, 0.23485039694576249, 0.3170964254182299, 0.14928733820691964, 0.14469258892869896, 0.21140070845790848, 0.353665149739528, 0.4749136577267359, 0.40758333377581313, 0.34156424523385776, 0.2488353306943143, 0.21214719196037302, 0.36684952667401227, 0.4624571215432609, 0.2097649563536852, 0.19375106128984187, 0.27531660740764796, 0.32616923539653186, 0.19185858074992668, 0.24104324262687415, 0.20027930550801232, 0.2536528578945535, 0.32228276085832963, 0.24983231036225684, 0.2016510407666905, 0.23151406606002334, 0.20022912684833227, 0.20583644339462337, 0.21265249147777077, 0.23636951866435052, 0.19474780166233774, 0.20560295724903765, 0.21096423963917932, 0.17339991682393774, 0.23451027895280874, 0.20907528558355493, 0.23045943132190627, 0.21984439122407773, 0.21427495117099715, 0.33180139586238033, 0.21415960430758063, 0.19236223191382185, 0.7873710977950843, 0.8610457379621809, 0.8647391476252209, 0.6150716755244863, 0.8340416076785121, 0.16760722697499264, 0.1758791007588052, 0.17500527227521512, 0.17736786811641447, 0.16559771493666942, 0.6578027420820862, 0.8315664414014505, 0.20379608326357124, 0.20980038553068192, 0.20905033134875062, 0.19854653573567083, 0.2065538682909014, 0.5373433081911956, 0.18989692541460246, 0.17962736475386898, 0.1933663730298285, 0.18309821215175703, 0.18656625491233547, 0.1787932993493514, 0.21324580961578365, 0.18908169681366294, 0.1843311670359472, 0.0785203474698406, 0.07709373952683929, 0.09081914010702252, 0.07985082591987702, 0.07558019448964826, 0.08905304515223778, 0.10951444695736012, 0.08208047862080325, 0.10392483240371753]}, "mutation_prompt": null}
{"id": "f5887de2-d27e-441c-a79e-7ea9a3380a76", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for refined exploration\n        self.inertia_weight = 0.5 + np.random.rand() * 0.3  # Adjusted inertia weight for balanced exploration\n        self.cognitive_coeff = 1.0 + np.random.rand() * 0.8  # Adjusted cognitive coefficient for improved balance\n        self.social_coeff = 0.9 + np.random.rand() * 1.0  # Adjusted social coefficient for enhanced synergy\n        self.F = 0.2 + np.random.rand() * 0.4  # Adjusted scaling factor for stochastic exploration\n        self.CR = 0.9  # Adjusted crossover probability for increased diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer incorporating adaptive feedback mechanisms and enhanced diversity management for improved convergence.", "configspace": "", "generation": 77, "fitness": 0.27920442011296387, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.25.", "error": "", "parent_id": "8217473b-3805-48d7-9b2a-65380ac9f5a7", "metadata": {"aucs": [0.5989486435501881, 0.7505296077074803, 0.7412035213440231, 0.6704828680890481, 0.7708123597782088, 0.734122883777395, 0.5995597459599351, 0.7618444698321116, 0.7508834211919782, 0.03383654436423278, 0.399803362535612, 0.4072297321642535, 0.19213664211605486, 0.4593760630342183, 0.3907224451273478, 0.007657049208597888, 0.3490391521180358, 0.015151053490963795, 0.10757540077375705, 0.12680075339384034, 0.15650383863056738, 0.10447126966528852, 0.12957000694311605, 0.12748015212104968, 0.08930431487856527, 0.12917621071101315, 0.13726442244671488, 0.10468910462949299, 0.10615375193220666, 0.10180797190155677, 0.09212131777411536, 0.13953185144503477, 0.10807881903605554, 0.08320776106160155, 0.11657564687423383, 0.10735630683322728, 0.9796586178173194, 0.9715720774598471, 0.9729613511353389, 0.9816113077330814, 0.9796505960690034, 0.9815185208811688, 0.9816061106138247, 0.980917691660519, 0.9816472433547967, 0.05882830307018083, 0.4946296885621432, 0.4926876930210615, 0.1438908980324226, 0.48743553716359256, 0.4598501190954455, 0.34142722473218035, 0.5219981775466729, 0.5140755040549769, 0.4899598735183437, 0.6973086149702513, 0.7203576010766952, 0.5257819466415193, 0.2143331522455424, 0.7556963672100061, 0.4899882430502298, 0.6897758092082826, 0.7425041211747634, 0.1647307067719639, 0.20315918846421976, 0.215118562687044, 0.11865972031947891, 0.19019740825492149, 0.20568747127467224, 0.15776645574122283, 0.21653919521461784, 0.2162721857188068, 0.15713469530734747, 0.19536257538253066, 0.12549818323945294, 0.16294821100569934, 0.1209164507545396, 0.23968685837795112, 0.17439908267871673, 0.22914409289484727, 0.2322859158577878, 9.999999999998899e-05, 9.999999999998899e-05, 0.05921928254149156, 9.999999999998899e-05, 9.999999999998899e-05, 0.04803682851689772, 9.999999999998899e-05, 0.012129035996158, 0.0011325765153294975, 0.027260583616640854, 0.0918061530449229, 0.07572376682237358, 0.04423141803092279, 0.04493851141022953, 0.023191988110327078, 0.05684796202502673, 0.1791154382327309, 0.05357239669750957, 0.03020108103124708, 0.05782885360138734, 0.03798214857435778, 0.06694573262971626, 0.10995578770624614, 0.06339060078162329, 0.06755896614631418, 0.14839648827303376, 0.11518785216313987, 0.09615548739835411, 0.1561607449598097, 0.14602645020103466, 0.04379817677041031, 0.2302612443788825, 0.11112392164754714, 0.045742347051765164, 0.09323974765578968, 0.048206896095798535, 0.45405229587290086, 0.5027578107273007, 0.5107835917730431, 0.45574150445590234, 0.5384729654183008, 0.6009484760565451, 0.43340347519550737, 0.5201627702157872, 0.5293214293456063, 0.10834591779786662, 0.1051216239481686, 0.14866603245868004, 0.10055794230819626, 0.11006578073413043, 0.12916462239391713, 0.08402261107710696, 0.1315021817025196, 0.15589114384303226, 0.13295222830316145, 0.18667116271792616, 0.14461857620502738, 0.15763810059994376, 0.13844567187335177, 0.3416491048228546, 0.13605187091668536, 0.2100123928754759, 0.1414904941947469, 0.31739042370790405, 0.410601782250115, 0.33846035206735847, 0.3445720901223982, 0.4285965447672182, 0.3700544775523291, 0.2599176143873143, 0.45412073202623304, 0.40956404667685986, 0.17429515713209098, 0.2892265566249663, 0.1771804617896534, 0.20480182685791104, 0.2984238423513661, 0.22257779100578845, 0.23837158915623347, 0.2550642427530948, 0.34562863524868215, 0.19399015149916732, 0.23405598735850175, 0.24582077043579198, 0.1836342338103737, 0.2244399670500391, 0.2059300057578639, 0.19884720346128715, 0.20251747194255643, 0.209984507988221, 0.203841908758699, 0.5695228233747962, 0.19305136044514593, 0.19203911415453712, 0.3657457225585691, 0.43266336761933233, 0.19392032232940282, 0.2094764742371169, 0.1828956779802018, 0.26405877850952886, 0.8422250284505087, 0.8164415082289439, 0.7194044740225058, 0.19774362894931397, 0.19789127849812282, 0.16903760130399537, 0.6864135980737629, 0.16962617860117912, 0.16654546491766542, 0.16596455080744377, 0.14377960620085506, 0.20692078557647398, 0.21047975197373248, 0.20834779581154161, 0.5600878091537336, 0.6827928898168985, 0.15343201782703386, 0.19806055054793603, 0.22058203909794183, 0.19313921292920555, 0.19439268174920976, 0.18054603256324753, 0.17992394359417596, 0.18494525823732277, 0.16662365289039682, 0.1883420082362952, 0.07629422630464722, 0.08719440672495093, 0.09056255555672565, 0.07067139401067069, 0.08853473021149527, 0.08648173626654354, 0.08541424673668951, 0.08925603520738601, 0.11220398562614498]}, "mutation_prompt": null}
{"id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "solution": "import numpy as np\n\nclass NovelStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for efficient exploration\n        self.inertia_weight = 0.2 + np.random.rand() * 0.5  # Modified inertia weight range for enhanced balance\n        self.cognitive_coeff = 0.7 + np.random.rand() * 0.8  # Refined cognitive coefficient range for optimization\n        self.social_coeff = 1.1 + np.random.rand() * 0.8  # Refined social coefficient range for synergy\n        self.F = 0.4 + np.random.rand() * 0.2  # Fine-tuned stochastic scaling factor range\n        self.CR = 0.75  # Balanced crossover probability for diversity maintenance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Revised elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "NovelStochasticHybridOptimizer", "description": "A novel stochastic hybrid optimizer that integrates adaptive differential evolution and elite-guided particle swarm optimization for versatile black box function optimization.", "configspace": "", "generation": 78, "fitness": 0.3367357366230166, "feedback": "The algorithm NovelStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.29.", "error": "", "parent_id": "8217473b-3805-48d7-9b2a-65380ac9f5a7", "metadata": {"aucs": [0.7929186395998985, 0.868759051007551, 0.8550106280771288, 0.8079454050611923, 0.8638909066485253, 0.8574338786796097, 0.8193506772803544, 0.8729619975511713, 0.8504973756710836, 0.6126693670203276, 0.6937935686420869, 0.6303219306721244, 0.5520182077582123, 0.6873048416669123, 0.043662786369258355, 0.5953752617682515, 0.6999185672494715, 0.7026911744842375, 0.1432135788051292, 0.13728617966612655, 0.09755060328181175, 0.16316262731409292, 0.14108461794948524, 0.12718654370224158, 0.13122373657118147, 0.13664747253992426, 0.0904248589551222, 0.12163563254764742, 0.12555513176664246, 0.15326706585835326, 0.11395488620128147, 0.10996450304979388, 0.10077058116660409, 0.1313026773748297, 0.10208779749056796, 0.11072443134698406, 0.9790768352308146, 0.9721602701364701, 0.9791464331803373, 0.9807242494071865, 0.9731566408506792, 0.9799010860666162, 0.9824306060281293, 0.9796355514522388, 0.9819770866252928, 0.5850749230415238, 0.7167980715134459, 0.718266727379914, 0.15154620652016204, 0.6916164874700472, 0.1527152130417253, 0.5832645047287933, 0.7234524900389921, 0.7226223427176343, 0.7486314274524148, 0.3733838904157647, 0.8344585113022263, 0.26723096070466534, 0.2132408303739317, 0.21185605367322158, 0.3721982707716358, 0.8403262869605201, 0.17620845120320194, 0.2188416979035449, 0.27081525235519754, 0.2961358584477882, 0.1281534806689768, 0.13150635773098862, 0.1290894380039017, 0.2062502055596539, 0.19000011623539925, 0.28771707659161516, 0.22311250413922634, 0.23264456960876934, 0.21046844007205912, 0.12655173144537535, 0.26762811691711164, 0.5074605562543333, 0.23815768555962458, 0.27560313499904054, 0.285127422715438, 9.999999999998899e-05, 9.999999999998899e-05, 0.06917028119605362, 9.999999999998899e-05, 0.004670460167366608, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001884623549929576, 0.04546176650760858, 0.030360270705926395, 0.02068502556624685, 0.012226696325025266, 0.046021951993849175, 0.03267673612728117, 0.07518824817677283, 0.056989682288747234, 0.1561640478263402, 0.04467562656857316, 0.08205915408621822, 0.07988640600194541, 0.06397492771611235, 0.3160980505009682, 0.1277937528311528, 0.08268788376379776, 0.12007555443751294, 0.06855981947886325, 0.041393388735197156, 0.25208311080112855, 0.03785060058876366, 0.058076965801024616, 0.2091039491057619, 0.05625328602372248, 0.10122483152619732, 0.08253180730894805, 0.16500976025173475, 0.5357775999413682, 0.604784615286015, 0.5444281551682963, 0.5407504639718117, 0.5714373911409709, 0.5641083049292821, 0.5878110084640167, 0.5774763762996306, 0.5743929013015507, 0.11940702143494886, 0.08802732016458847, 0.10284449865440148, 0.10466611952148397, 0.15279716938046062, 0.12192177009875249, 0.1271673328285866, 0.13872668177867786, 0.13978701660752835, 0.2141367461879785, 0.6203355552201653, 0.5188415650272616, 0.23941931947013328, 0.3846499387024789, 0.2291555393902518, 0.3674864953166417, 0.3953907902693393, 0.26750167496838906, 0.5160894474151092, 0.3555267802522487, 0.4801141353497307, 0.5120169138166089, 0.68728905130994, 0.5279386386774192, 0.4910023809946411, 0.6703710729624792, 0.3185656587798068, 0.1814526091871449, 0.29749377216469375, 0.1367830156393629, 0.3141778320327008, 0.32376165361836895, 0.24914645496523358, 0.14132587454582024, 0.16324336083085578, 0.2715006509936564, 0.22235174227931198, 0.21934426508523852, 0.2360654744263282, 0.22043315050768297, 0.23413564618478278, 0.2057738203225321, 0.1992804712422882, 0.3806375019602978, 0.20346664946866433, 0.6664951412243701, 0.7297608021472464, 0.7204202026715829, 0.18144958904820085, 0.18484970099484677, 0.1971715351479847, 0.19913452126418352, 0.7339707431500054, 0.22083028061139065, 0.2640898475727951, 0.9103679829362903, 0.9056158814423411, 0.1661743853118729, 0.1660326671092316, 0.16669096591592114, 0.17000845770182038, 0.8845012157849488, 0.16218433019795453, 0.6965139762968329, 0.8144353592588474, 0.7829559237843948, 0.20859566321485867, 0.210988585475834, 0.1049039699703257, 0.20699396847985985, 0.8251550896193492, 0.8015725266532047, 0.1990969134386099, 0.18017423089904128, 0.19839499687291395, 0.17824846604089906, 0.17849814149089105, 0.18083562832457756, 0.18116314923399157, 0.1900791169689161, 0.21053493752735208, 0.09463742069102121, 0.09290351516999584, 0.08810833870189505, 0.09367572910358268, 0.08631427525989055, 0.07984522381967984, 0.10072079775826548, 0.0946895864806152, 0.1312480230153742]}, "mutation_prompt": null}
{"id": "7a9899d6-cb00-422f-8611-37ffc08ba635", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 8)  # Adjusted population size for better diversity\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Dynamic inertia weight for balanced exploration\n        self.cognitive_coeff = 0.6 + np.random.rand() * 0.9  # Slightly broader cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Adjusted social coefficient for effective synergy\n        self.F = 0.5 + np.random.rand() * 0.3  # Enhanced stochastic scaling factor\n        self.CR = 0.7  # Balanced crossover probability with a slight tweak\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced hybrid optimizer with dynamic strategy adjustment integrating adaptive differential evolution and elite-guided particle swarm optimization for improved black box function optimization.", "configspace": "", "generation": 79, "fitness": 0.3152250165028147, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7721962401413914, 0.8162665186477226, 0.8007773401036328, 0.7385091878636758, 0.8083880634452381, 0.7907782905753222, 0.7758670941793964, 0.8340141508316294, 0.8119477746712154, 0.4209574042202483, 0.43727780875518707, 0.48074353493905086, 0.05839550051357145, 0.6189939758106907, 0.5560330055652176, 0.47161899205473135, 0.5796657866755819, 0.5810242393229205, 0.15172868148650576, 0.1703788166159821, 0.13968509212770364, 0.15077073016718967, 0.16258367343350832, 0.11570552878951801, 0.1377875065758981, 0.14672342275714167, 0.11845236991622765, 0.12743650524835504, 0.12237044026725108, 0.09416151798149763, 0.12383537765788188, 0.10486799795811041, 0.10687684543882092, 0.12587374431295606, 0.13487077946907045, 0.10556605465703828, 0.978069126682873, 0.9777844753453453, 0.9779482936582995, 0.9781068151901184, 0.9779348303253221, 0.9783473936062325, 0.9780834544186722, 0.9731634842747248, 0.9780269602941711, 0.4804530663295794, 0.6367941035920459, 0.6542625265900036, 0.48352941350484147, 0.6266287608594487, 0.6640941116161403, 0.08787948568611847, 0.635853762920693, 0.6385896920313006, 0.6976552676000063, 0.7883430921385467, 0.1360637809844082, 0.19028853927310996, 0.2113529839620658, 0.3703746046518225, 0.23259763089407037, 0.7895971630821541, 0.7967695879364074, 0.34513029914145354, 0.22997374268584814, 0.25991611707358253, 0.12266658547503428, 0.2768973991847258, 0.12961991861025834, 0.1970068309249542, 0.23369402580080345, 0.2783835054188214, 0.23934036197848108, 0.09605069842755365, 0.2521828201289721, 0.22201305503299018, 0.22563308840496665, 0.27197399202052097, 0.22840580401167143, 0.25746756678981253, 0.2426264043115668, 0.01849863353134007, 0.0008094769055205786, 9.999999999998899e-05, 0.04361335210252493, 9.999999999998899e-05, 9.999999999998899e-05, 0.0055963585863468834, 0.02516103245893031, 0.02232157263934509, 0.06406528065200656, 0.19505466956547823, 0.054220613283576524, 0.01433526551972919, 0.07012064813996022, 0.03091838047967299, 0.08633428656229702, 0.165379070337086, 0.18070311720266186, 0.06729882743403637, 0.045673529212791775, 0.045321844856922366, 0.18558816298030933, 0.08814137421028334, 0.09773837166085741, 0.1400797441789391, 0.09077124335944775, 0.08905652813612308, 0.13620433150594746, 0.15311112489066758, 0.061787726990921166, 0.10417476869774822, 0.24388833772640295, 0.24573765270205894, 0.054410214875943885, 0.1920473270762979, 0.0761211321033628, 0.52826229459804, 0.5817874799797544, 0.54534898581113, 0.5140433871167329, 0.560710380972647, 0.5457817283406052, 0.5433631026810093, 0.5757995300352782, 0.5524561470822589, 0.11624752793047488, 0.14827502236357437, 0.10066953125363742, 0.12357679589510429, 0.1657963633569297, 0.1343601656036193, 0.12558743086126756, 0.12872856380556408, 0.06603155087324464, 0.23332664856303742, 0.31107662040819983, 0.25610316690290624, 0.24262993456700155, 0.22051963984279754, 0.1919096037602157, 0.20751413795486728, 0.39803388818281815, 0.3265483155493484, 0.2986875165382207, 0.24214319378308746, 0.4106950906465501, 0.3172859177566685, 0.35787952814380686, 0.3402452263840796, 0.4612856730540812, 0.5579586998796827, 0.5494200792072795, 0.24934597792355795, 0.21423655734487945, 0.2904476436679979, 0.24709126831347306, 0.28250918989089024, 0.24176093417244138, 0.1663574271161078, 0.23202280347807702, 0.14042866525181252, 0.1951194647436253, 0.3715822967976089, 0.17286081845973678, 0.22071153883063666, 0.21300064018678266, 0.20523044823930225, 0.20661994138298279, 0.2263173037668027, 0.2028476708934157, 0.5558982138944282, 0.2150277193367337, 0.21546132435709187, 0.22989855699638462, 0.1776469161330313, 0.2072669702504384, 0.21185389325808124, 0.24067494955228597, 0.20665644184397136, 0.8481492915307622, 0.8885521945530499, 0.9005414926846999, 0.16733399644712277, 0.8438090535342595, 0.8807528267235067, 0.16749346413519473, 0.1301494035990849, 0.16027834700622168, 0.6512187370599265, 0.7002563409607796, 0.7829549280942798, 0.20807862307963587, 0.20830616654115086, 0.20988671681897064, 0.20611871889810174, 0.2094898781698865, 0.20208411729490483, 0.19208030035341683, 0.19066039517298805, 0.17393657452881361, 0.19213295648674378, 0.18381571998664714, 0.1859402651769838, 0.18926175438627446, 0.19292847372755872, 0.18938259017354964, 0.08631944855928164, 0.09320794197601334, 0.08874525594003413, 0.07901728204793657, 0.09937626773565167, 0.08631354062377505, 0.11731395732065952, 0.11834697296404517, 0.1301165079348211]}, "mutation_prompt": null}
{"id": "db4ea347-3d77-491b-a096-108214bd52c5", "solution": "import numpy as np\n\nclass NovelStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for efficient exploration\n        self.inertia_weight = 0.2 + np.random.rand() * 0.5  # Modified inertia weight range for enhanced balance\n        self.cognitive_coeff = 0.7 + np.random.rand() * 0.8  # Refined cognitive coefficient range for optimization\n        self.social_coeff = 1.1 + np.random.rand() * 0.8  # Refined social coefficient range for synergy\n        self.F = 0.4 + np.random.rand() * 0.2  # Fine-tuned stochastic scaling factor range\n        self.CR = 0.75  # Balanced crossover probability for diversity maintenance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Revised elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "NovelStochasticHybridOptimizer", "description": "A novel stochastic hybrid optimizer that integrates adaptive differential evolution and elite-guided particle swarm optimization for versatile black box function optimization.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7929186395998985, 0.868759051007551, 0.8550106280771288, 0.8079454050611923, 0.8638909066485253, 0.8574338786796097, 0.8193506772803544, 0.8729619975511713, 0.8504973756710836, 0.6126693670203276, 0.6937935686420869, 0.6303219306721244, 0.5520182077582123, 0.6873048416669123, 0.043662786369258355, 0.5953752617682515, 0.6999185672494715, 0.7026911744842375, 0.1432135788051292, 0.13728617966612655, 0.09755060328181175, 0.16316262731409292, 0.14108461794948524, 0.12718654370224158, 0.13122373657118147, 0.13664747253992426, 0.0904248589551222, 0.12163563254764742, 0.12555513176664246, 0.15326706585835326, 0.11395488620128147, 0.10996450304979388, 0.10077058116660409, 0.1313026773748297, 0.10208779749056796, 0.11072443134698406, 0.9790768352308146, 0.9721602701364701, 0.9791464331803373, 0.9807242494071865, 0.9731566408506792, 0.9799010860666162, 0.9824306060281293, 0.9796355514522388, 0.9819770866252928, 0.5850749230415238, 0.7167980715134459, 0.718266727379914, 0.15154620652016204, 0.6916164874700472, 0.1527152130417253, 0.5832645047287933, 0.7234524900389921, 0.7226223427176343, 0.7486314274524148, 0.3733838904157647, 0.8344585113022263, 0.26723096070466534, 0.2132408303739317, 0.21185605367322158, 0.3721982707716358, 0.8403262869605201, 0.17620845120320194, 0.2188416979035449, 0.27081525235519754, 0.2961358584477882, 0.1281534806689768, 0.13150635773098862, 0.1290894380039017, 0.2062502055596539, 0.19000011623539925, 0.28771707659161516, 0.22311250413922634, 0.23264456960876934, 0.21046844007205912, 0.12655173144537535, 0.26762811691711164, 0.5074605562543333, 0.23815768555962458, 0.27560313499904054, 0.285127422715438, 9.999999999998899e-05, 9.999999999998899e-05, 0.06917028119605362, 9.999999999998899e-05, 0.004670460167366608, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001884623549929576, 0.04546176650760858, 0.030360270705926395, 0.02068502556624685, 0.012226696325025266, 0.046021951993849175, 0.03267673612728117, 0.07518824817677283, 0.056989682288747234, 0.1561640478263402, 0.04467562656857316, 0.08205915408621822, 0.07988640600194541, 0.06397492771611235, 0.3160980505009682, 0.1277937528311528, 0.08268788376379776, 0.12007555443751294, 0.06855981947886325, 0.041393388735197156, 0.25208311080112855, 0.03785060058876366, 0.058076965801024616, 0.2091039491057619, 0.05625328602372248, 0.10122483152619732, 0.08253180730894805, 0.16500976025173475, 0.5357775999413682, 0.604784615286015, 0.5444281551682963, 0.5407504639718117, 0.5714373911409709, 0.5641083049292821, 0.5878110084640167, 0.5774763762996306, 0.5743929013015507, 0.11940702143494886, 0.08802732016458847, 0.10284449865440148, 0.10466611952148397, 0.15279716938046062, 0.12192177009875249, 0.1271673328285866, 0.13872668177867786, 0.13978701660752835, 0.2141367461879785, 0.6203355552201653, 0.5188415650272616, 0.23941931947013328, 0.3846499387024789, 0.2291555393902518, 0.3674864953166417, 0.3953907902693393, 0.26750167496838906, 0.5160894474151092, 0.3555267802522487, 0.4801141353497307, 0.5120169138166089, 0.68728905130994, 0.5279386386774192, 0.4910023809946411, 0.6703710729624792, 0.3185656587798068, 0.1814526091871449, 0.29749377216469375, 0.1367830156393629, 0.3141778320327008, 0.32376165361836895, 0.24914645496523358, 0.14132587454582024, 0.16324336083085578, 0.2715006509936564, 0.22235174227931198, 0.21934426508523852, 0.2360654744263282, 0.22043315050768297, 0.23413564618478278, 0.2057738203225321, 0.1992804712422882, 0.3806375019602978, 0.20346664946866433, 0.6664951412243701, 0.7297608021472464, 0.7204202026715829, 0.18144958904820085, 0.18484970099484677, 0.1971715351479847, 0.19913452126418352, 0.7339707431500054, 0.22083028061139065, 0.2640898475727951, 0.9103679829362903, 0.9056158814423411, 0.1661743853118729, 0.1660326671092316, 0.16669096591592114, 0.17000845770182038, 0.8845012157849488, 0.16218433019795453, 0.6965139762968329, 0.8144353592588474, 0.7829559237843948, 0.20859566321485867, 0.210988585475834, 0.1049039699703257, 0.20699396847985985, 0.8251550896193492, 0.8015725266532047, 0.1990969134386099, 0.18017423089904128, 0.19839499687291395, 0.17824846604089906, 0.17849814149089105, 0.18083562832457756, 0.18116314923399157, 0.1900791169689161, 0.21053493752735208, 0.09463742069102121, 0.09290351516999584, 0.08810833870189505, 0.09367572910358268, 0.08631427525989055, 0.07984522381967984, 0.10072079775826548, 0.0946895864806152, 0.1312480230153742]}, "mutation_prompt": null}
{"id": "b83f04b7-1f19-4d24-a567-73f4971c5d90", "solution": "import numpy as np\n\nclass NovelStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for efficient exploration\n        self.inertia_weight = 0.2 + np.random.rand() * 0.5  # Modified inertia weight range for enhanced balance\n        self.cognitive_coeff = 0.7 + np.random.rand() * 0.8  # Refined cognitive coefficient range for optimization\n        self.social_coeff = 1.1 + np.random.rand() * 0.8  # Refined social coefficient range for synergy\n        self.F = 0.4 + np.random.rand() * 0.2  # Fine-tuned stochastic scaling factor range\n        self.CR = 0.75  # Balanced crossover probability for diversity maintenance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Revised elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "NovelStochasticHybridOptimizer", "description": "A novel stochastic hybrid optimizer that integrates adaptive differential evolution and elite-guided particle swarm optimization for versatile black box function optimization.", "configspace": "", "generation": 79, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7929186395998985, 0.868759051007551, 0.8550106280771288, 0.8079454050611923, 0.8638909066485253, 0.8574338786796097, 0.8193506772803544, 0.8729619975511713, 0.8504973756710836, 0.6126693670203276, 0.6937935686420869, 0.6303219306721244, 0.5520182077582123, 0.6873048416669123, 0.043662786369258355, 0.5953752617682515, 0.6999185672494715, 0.7026911744842375, 0.1432135788051292, 0.13728617966612655, 0.09755060328181175, 0.16316262731409292, 0.14108461794948524, 0.12718654370224158, 0.13122373657118147, 0.13664747253992426, 0.0904248589551222, 0.12163563254764742, 0.12555513176664246, 0.15326706585835326, 0.11395488620128147, 0.10996450304979388, 0.10077058116660409, 0.1313026773748297, 0.10208779749056796, 0.11072443134698406, 0.9790768352308146, 0.9721602701364701, 0.9791464331803373, 0.9807242494071865, 0.9731566408506792, 0.9799010860666162, 0.9824306060281293, 0.9796355514522388, 0.9819770866252928, 0.5850749230415238, 0.7167980715134459, 0.718266727379914, 0.15154620652016204, 0.6916164874700472, 0.1527152130417253, 0.5832645047287933, 0.7234524900389921, 0.7226223427176343, 0.7486314274524148, 0.3733838904157647, 0.8344585113022263, 0.26723096070466534, 0.2132408303739317, 0.21185605367322158, 0.3721982707716358, 0.8403262869605201, 0.17620845120320194, 0.2188416979035449, 0.27081525235519754, 0.2961358584477882, 0.1281534806689768, 0.13150635773098862, 0.1290894380039017, 0.2062502055596539, 0.19000011623539925, 0.28771707659161516, 0.22311250413922634, 0.23264456960876934, 0.21046844007205912, 0.12655173144537535, 0.26762811691711164, 0.5074605562543333, 0.23815768555962458, 0.27560313499904054, 0.285127422715438, 9.999999999998899e-05, 9.999999999998899e-05, 0.06917028119605362, 9.999999999998899e-05, 0.004670460167366608, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.001884623549929576, 0.04546176650760858, 0.030360270705926395, 0.02068502556624685, 0.012226696325025266, 0.046021951993849175, 0.03267673612728117, 0.07518824817677283, 0.056989682288747234, 0.1561640478263402, 0.04467562656857316, 0.08205915408621822, 0.07988640600194541, 0.06397492771611235, 0.3160980505009682, 0.1277937528311528, 0.08268788376379776, 0.12007555443751294, 0.06855981947886325, 0.041393388735197156, 0.25208311080112855, 0.03785060058876366, 0.058076965801024616, 0.2091039491057619, 0.05625328602372248, 0.10122483152619732, 0.08253180730894805, 0.16500976025173475, 0.5357775999413682, 0.604784615286015, 0.5444281551682963, 0.5407504639718117, 0.5714373911409709, 0.5641083049292821, 0.5878110084640167, 0.5774763762996306, 0.5743929013015507, 0.11940702143494886, 0.08802732016458847, 0.10284449865440148, 0.10466611952148397, 0.15279716938046062, 0.12192177009875249, 0.1271673328285866, 0.13872668177867786, 0.13978701660752835, 0.2141367461879785, 0.6203355552201653, 0.5188415650272616, 0.23941931947013328, 0.3846499387024789, 0.2291555393902518, 0.3674864953166417, 0.3953907902693393, 0.26750167496838906, 0.5160894474151092, 0.3555267802522487, 0.4801141353497307, 0.5120169138166089, 0.68728905130994, 0.5279386386774192, 0.4910023809946411, 0.6703710729624792, 0.3185656587798068, 0.1814526091871449, 0.29749377216469375, 0.1367830156393629, 0.3141778320327008, 0.32376165361836895, 0.24914645496523358, 0.14132587454582024, 0.16324336083085578, 0.2715006509936564, 0.22235174227931198, 0.21934426508523852, 0.2360654744263282, 0.22043315050768297, 0.23413564618478278, 0.2057738203225321, 0.1992804712422882, 0.3806375019602978, 0.20346664946866433, 0.6664951412243701, 0.7297608021472464, 0.7204202026715829, 0.18144958904820085, 0.18484970099484677, 0.1971715351479847, 0.19913452126418352, 0.7339707431500054, 0.22083028061139065, 0.2640898475727951, 0.9103679829362903, 0.9056158814423411, 0.1661743853118729, 0.1660326671092316, 0.16669096591592114, 0.17000845770182038, 0.8845012157849488, 0.16218433019795453, 0.6965139762968329, 0.8144353592588474, 0.7829559237843948, 0.20859566321485867, 0.210988585475834, 0.1049039699703257, 0.20699396847985985, 0.8251550896193492, 0.8015725266532047, 0.1990969134386099, 0.18017423089904128, 0.19839499687291395, 0.17824846604089906, 0.17849814149089105, 0.18083562832457756, 0.18116314923399157, 0.1900791169689161, 0.21053493752735208, 0.09463742069102121, 0.09290351516999584, 0.08810833870189505, 0.09367572910358268, 0.08631427525989055, 0.07984522381967984, 0.10072079775826548, 0.0946895864806152, 0.1312480230153742]}, "mutation_prompt": null}
{"id": "5c457251-6ed6-481c-b3bb-3652cdcb7cd4", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 9)  # Adjusted population size for better exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Slightly narrower inertia weight range\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.6  # Refined cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Wider social coefficient range for flexibility\n        self.F = 0.5  # Fixed stochastic scaling factor for stability\n        self.CR = 0.8  # Higher crossover probability for improved diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                crossover_mask = np.random.rand(self.dim) < self.CR\n                trial_vector[crossover_mask] = mutant_vector[crossover_mask]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 7)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "Enhanced stochastic hybrid optimizer leveraging dynamic strategy adaptation for robust black box optimization.", "configspace": "", "generation": 82, "fitness": 0.32577528890947655, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.27.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.8054669419529412, 0.855450748551528, 0.8405936255584423, 0.8094420019692647, 0.8521549343553316, 0.8413367357508852, 0.8047350568110962, 0.8557997876296765, 0.8468705171980035, 0.5818301027106897, 0.6504625244368101, 9.999999999998899e-05, 0.4667333870741571, 0.6542994109778022, 9.999999999998899e-05, 0.5776505261098208, 0.6426519300974154, 0.639510898228909, 0.11117328485167777, 0.1502715722074296, 0.11311432905261831, 0.07574961685096226, 0.16997970558104647, 0.17740556964294862, 0.1445150148620653, 0.17328354827828896, 0.13685067778945326, 0.1283655253411623, 0.11401139902804402, 0.10083420769546025, 0.12393837378829797, 0.1274005409375768, 0.10515704270207649, 0.13868181310119077, 0.1393279143415329, 0.14610652596437668, 0.9811671116022987, 0.9724743188209827, 0.9810954851323685, 0.9799965590383761, 0.9715466094946114, 0.9815218603949188, 0.9826485821268806, 0.9802599826051921, 0.9820932285331352, 0.592284807346615, 0.7135962144979416, 0.6779940815908477, 0.44538500011240856, 0.682489982047062, 0.6505919107960427, 0.5496952352327175, 0.7153696607707404, 0.699232467016655, 0.3708299062481466, 0.22477592216023456, 0.83684647218714, 0.21094705806862135, 0.2760708292938635, 0.16050006061755828, 0.2203623558819281, 0.8393156735738395, 0.23009313799475317, 0.21810503034793283, 0.23602682125383279, 0.27091833330667037, 0.12551639498682943, 0.346352595116852, 0.1263710180993819, 0.21958155621964015, 0.25682118607219684, 0.6367209453886099, 0.2459151729833341, 0.2557097387837858, 0.27247244578784635, 0.21560846138738365, 0.29962173775616197, 0.274767567838217, 0.251403022652833, 0.2648080081656907, 0.2890420202609477, 0.024176873060239634, 9.999999999998899e-05, 0.0121093132626795, 0.04432823355664384, 9.999999999998899e-05, 0.09259811663821693, 9.999999999998899e-05, 9.999999999998899e-05, 0.0006802321791928856, 0.08083552428449348, 0.14773509950438257, 0.05032246687418496, 0.02032234200512173, 0.02813016988866457, 0.014972959616157966, 0.06742368538024512, 0.04212522050612644, 0.042374546451468986, 0.05261247196458918, 0.062255299563971134, 0.046114425978582174, 0.2451685839469977, 0.16105070960527978, 0.2492576301012439, 0.0618670010889627, 0.06765319162823236, 0.0666143870372341, 0.10152475839637431, 0.1372295965329431, 0.08355112937606157, 0.09621986789586556, 0.2613990589780014, 0.13781353778854788, 0.0767619378961032, 0.08967696766231126, 0.18821799783391457, 0.5931677759365338, 0.5711050259929523, 0.5536215677799425, 0.5389525728236808, 0.5730832253870641, 0.5598343762824878, 0.5046010162131052, 0.564725241072292, 0.5906314220386326, 0.09257957628631708, 0.15030044375642027, 0.14040247107749038, 0.12008164568718871, 0.15008843782374137, 0.13882104015849384, 0.226883246950773, 0.1368841131767713, 0.1410950125544167, 0.3312687954155493, 0.26211810338324715, 0.20825980620673012, 0.3034759097400618, 0.2719128608600765, 0.45425401796789033, 0.3888792743339482, 0.3875658229967558, 0.49664081228685464, 0.4386505842809447, 0.5867945104589526, 0.4483256010362131, 0.46819751530859743, 0.42792227535245675, 0.62873195403836, 0.484758079951384, 0.24447213289091352, 0.5939001777462987, 0.21604045516638282, 0.18389618825202336, 0.31036445816994274, 0.28687489673355104, 0.3358877275646006, 0.367622365454743, 0.20792787699872795, 0.1878442649608546, 0.14015073452556592, 0.23707154948062548, 0.26093039522548434, 0.19265457733172542, 0.20989379837423716, 0.25062060356340565, 0.2107282446001968, 0.21178816929987598, 0.20795016109730136, 0.2142796329906067, 0.21815958952128411, 0.191847876419309, 0.19638780205042428, 0.20082665316367043, 0.24318246269851707, 0.2239850345567177, 0.2022812983773875, 0.2047808071874231, 0.19755012221484658, 0.8303627704806967, 0.9007643551470271, 0.8845841387226724, 0.16731173860651982, 0.1667698980267931, 0.16710016731533817, 0.16917571170839074, 0.16886113813207215, 0.17002648117389418, 0.30032434369843186, 0.7353261063956891, 0.7346405052496123, 0.6754342548103279, 0.21074061067903438, 0.20770522767134303, 0.18371593214778492, 0.7944884845379641, 0.8189063647338187, 0.19174162068367417, 0.18806402954386225, 0.19450757536748975, 0.1906164099622195, 0.18625303016453487, 0.1848776613136316, 0.18208992884031538, 0.17907657235872154, 0.17566168947486605, 0.08506627409538381, 0.0857574764486757, 0.0896964201075785, 0.0924185811795667, 0.09471235406728717, 0.09236902456337992, 0.1257354751914751, 0.10205269799748184, 0.08618746511037534]}, "mutation_prompt": null}
{"id": "8c6c1d69-1d35-4c12-be03-b2f0006debf1", "solution": "import numpy as np\n\nclass RefinedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for efficient exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Dynamic inertia weight for improved adaptability\n        self.cognitive_coeff = 0.5 + np.random.rand() * 1.0  # Enhanced cognitive coefficient range\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Fine-tuned social coefficient for better cohesion\n        self.F = 0.5 + np.random.rand() * 0.1  # Adjusted stochastic scaling factor for better exploration\n        self.CR = 0.8  # Increased crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        evaluations = self.population_size\n\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.7 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedStochasticHybridOptimizer", "description": "A refined stochastic hybrid optimizer that blends adaptive differential evolution with elite-guided particle swarm optimization, incorporating dynamic parameter tuning for enhanced convergence on black box functions.", "configspace": "", "generation": 83, "fitness": 0.31249701118616213, "feedback": "The algorithm RefinedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.27.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7592108763441223, 0.846454290395414, 0.8401998145764709, 0.7758398844987551, 0.8369006725630603, 0.8400256624023368, 0.7784743120278499, 0.84485428159572, 0.8297923545451842, 0.5188654524168659, 0.6601463205521612, 0.5723092458163177, 0.05894820640598142, 0.5936240266423797, 0.6322384163014091, 0.3910691225624513, 0.636619716280006, 0.5812215908568434, 0.11798751303888078, 0.14530134321674104, 0.16485224732952952, 0.07208187645321995, 0.07457639082939005, 0.16772409380292097, 0.1203035786799399, 0.1364463678461405, 0.13328181010788942, 0.09727367610620563, 0.12498499926408624, 0.1248894777660653, 0.1359056610801892, 0.12463561736745143, 0.1171693196364404, 0.11820651452770692, 0.14657980001538673, 0.15441776681633923, 0.979280794052091, 0.9731019449104186, 0.9790165990000215, 0.9846209630338143, 0.9845413712480967, 0.9845041647036521, 0.982492333464279, 0.9814055753753498, 0.9820951462721617, 0.47458014989020847, 0.678277676613789, 0.6769200029559832, 0.5228196654352839, 0.7025683305992596, 0.1520916568566092, 0.5318418730698482, 0.6843575360366039, 0.5861308300219341, 0.7647828146986354, 0.8326122370825518, 0.8456397233989718, 0.6602043085854293, 0.2774456433795415, 0.20893522952907317, 0.2308634574477867, 0.8152174632618381, 0.8405404372497219, 0.22601807216753678, 0.2599050407439265, 0.13090520280289442, 0.11635224370719843, 0.3287907021712966, 0.10164897354636337, 0.21562801943129062, 0.24397939508502475, 0.26549019055777967, 0.2253334576584174, 0.2565374293478321, 0.27521016345803717, 0.21212050948648797, 0.2880542322369056, 0.3097520254663123, 0.2150923559064265, 0.2857946889668759, 0.17221447332209405, 9.999999999998899e-05, 0.0008007556628691903, 0.030999460712912486, 9.999999999998899e-05, 0.020538569228178538, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018259176083613826, 0.18913775140218947, 0.06212282444515882, 0.05161470739773555, 0.03630224963282147, 0.03811487709328598, 0.020186988785251714, 0.12675455720375362, 0.1408936927117438, 0.09378775133192196, 0.060612180873888644, 0.04583557124791027, 0.04493830524028675, 0.0766996846455904, 0.08757204767515336, 0.07788495018825436, 0.0637801069908237, 0.1619732386687185, 0.06848465165073536, 0.040843564232929896, 0.21956521697472875, 0.05993649913511745, 0.14310702084743354, 0.04059307740125273, 0.03776228863701159, 0.10390700330555536, 0.07939234558774555, 0.04767906001564548, 0.5391277663418308, 0.5560207239433492, 0.5620609386514825, 0.5316795105015, 0.5778545757521314, 0.5956593822080991, 0.5183410001807934, 0.5711492935659459, 0.5766273948986766, 0.09749019007524495, 0.08858688001947246, 0.07838717857258781, 0.11362926995351774, 0.12589130972177687, 0.11361767103568743, 0.1100719613818113, 0.5145175501502119, 0.13084613553561342, 0.3728482349706773, 0.2833017639551111, 0.6559280687449549, 0.29983746353529317, 0.46239501764550117, 0.19919017134816663, 0.21181642053482796, 0.21766704306882645, 0.5166866484308615, 0.43548591576984597, 0.5502745239026348, 0.502619624770667, 0.3991377186217413, 0.37685608787704505, 0.30631887693152315, 0.27256261114893876, 0.5666119213627548, 0.21073546494657536, 0.14189954679603067, 0.18410753966871118, 0.20721679479577926, 0.25558776207222367, 0.17660383105943944, 0.4443967980756921, 0.33336209833131836, 0.19554869784336593, 0.14820015521259733, 0.2516464994898123, 0.22663510767028416, 0.3586723034797088, 0.21179228950458973, 0.198261918513294, 0.23520884492382488, 0.23143369592454632, 0.22105945933620086, 0.22178435042558864, 0.4558110783406236, 0.1866192516668207, 0.2139340311359581, 0.2084685815816989, 0.21996769013101247, 0.19529341831079772, 0.2242131799955831, 0.20385268525208688, 0.20436131117861478, 0.8684412900983709, 0.8928312628626849, 0.9007434997369754, 0.1656968554566418, 0.1666605069548246, 0.16697521585806008, 0.16886003361061008, 0.17022972170336548, 0.1701615734159614, 0.20489753999028437, 0.16672962472962027, 0.14459222287694795, 0.2077768483443968, 0.20887306277665696, 0.21028741304896592, 0.16303117613665286, 0.19347061555292688, 0.19404463840123543, 0.19629854433618488, 0.1816647508795891, 0.19501153641045998, 0.18599654127901744, 0.1917826222063076, 0.18188641031666652, 0.18081678599564943, 0.1946476694217779, 0.18866475953833417, 0.10190973061047792, 0.09200081493330814, 0.08382149669643935, 0.07946014171850024, 0.08381929312147918, 0.08967855034910166, 0.11472707506858482, 0.08770035896077244, 0.09768542212756892]}, "mutation_prompt": null}
{"id": "b84610fe-6b4d-4b3a-be10-5faea82f774b", "solution": "import numpy as np\n\nclass NovelStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)\n        self.inertia_weight = 0.1 + np.random.rand() * 0.6  # Adjusted inertia for improved exploration-exploitation balance\n        self.cognitive_coeff = 0.6 + np.random.rand() * 0.9  # Adjusted cognitive range for more variety\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Adjusted social range for enhanced cooperation\n        self.F = 0.3 + np.random.rand() * 0.3  # Expanded stochastic scaling factor range\n        self.CR = 0.7  # Slightly reduced crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                 self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                 self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                 0.5 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "NovelStochasticHybridOptimizer", "description": "A probabilistically refined hybrid optimizer integrating adaptive differential evolution and elite-guided particle swarm optimization for robust black box function optimization.", "configspace": "", "generation": 84, "fitness": 0.334861892277878, "feedback": "The algorithm NovelStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.8431046127666545, 0.8902195425791313, 0.8831303750794445, 0.8413746894678525, 0.8781035668378527, 0.8722725418273717, 0.8458886254838336, 0.8785407947739463, 0.8738192185500658, 0.6356657780670647, 0.6988769609213847, 0.7032854968539481, 0.6229156652311107, 0.739096332002859, 0.721612341560115, 0.6388623327721124, 0.7640339496498719, 0.7107667681030982, 0.11996136182941008, 0.18371957416766738, 0.12294573309008994, 0.12995075402845746, 0.14194252734460278, 0.1085865170666993, 0.15286733782444806, 0.15727725114406532, 0.1545133761700035, 0.1412387226002415, 0.1393273505149173, 0.14189954831254548, 0.09230788996752526, 0.1217162703589254, 0.10363768429423759, 0.14345836267181056, 0.1155839803809362, 0.09021788067632275, 0.9783534829574941, 0.9714896524322488, 0.9715413059563213, 0.9799694780996906, 0.9724100999534805, 0.9785576052537315, 0.981965554540093, 0.9724985103669679, 0.9819516999161557, 0.6620194274166957, 0.7691094402108586, 0.7715518532550322, 0.6609814717603697, 0.7517676633833846, 0.7491923523897721, 0.6551743877872536, 0.7610425561770827, 0.7892743947669417, 0.16920310505708713, 0.1712131151263908, 0.22855511494608294, 0.16074091056522832, 0.35692684703370536, 0.16123633273228755, 0.38005362308448287, 0.399568525686667, 0.19447133914899317, 0.12737432823789607, 0.199313296047119, 0.31257907651363603, 0.2504393013466901, 0.1999337563403344, 0.13333470961819693, 0.2842097857421608, 0.2784430682917085, 0.3193792950020805, 0.13139518155336716, 0.23900225759980054, 0.2856665647918045, 0.3114621434666107, 0.26762586373790787, 0.1320718695587897, 0.26830265093048256, 0.12927627727160584, 0.13287701214600534, 0.021480265625386852, 0.02843596146884153, 9.999999999998899e-05, 9.999999999998899e-05, 0.007363222597832508, 9.999999999998899e-05, 9.999999999998899e-05, 0.00993259460568896, 0.007954459413758053, 0.029449545914172814, 0.11676609963650553, 0.05934004069947063, 0.013897538796502573, 0.03200888508214561, 0.010490220068393286, 0.04550498187717544, 0.058061481501965995, 0.1157108036629928, 0.04559138914560101, 0.10432973716715865, 0.04916459963039399, 0.11112833245284326, 0.31431925764116686, 0.16081826004952504, 0.21721010440526567, 0.08618244282560972, 0.09900299830360704, 0.04072430947310712, 0.08769078147593612, 0.1785725620815718, 0.09392616073579518, 0.15461293364166362, 0.0880727324089452, 0.10370139702833236, 0.08886155713158406, 0.08289596582809267, 0.548140492530554, 0.5480213140623835, 0.5825110519464489, 0.5870109835892068, 0.5977410226898497, 0.6031659560772828, 0.5956094184843069, 0.6175793579666886, 0.604476709129466, 0.16592933548690703, 0.12230780361171933, 0.14101592598259938, 0.1180702364859948, 0.15760415172190168, 0.1308008805172831, 0.12064384115029825, 0.1594058535846954, 0.1432866834909472, 0.3441062975436283, 0.27636812222313734, 0.23460190708043505, 0.20049132775033618, 0.20007781455481066, 0.24549757433044328, 0.18465149018958282, 0.3947891221089286, 0.17024307151674034, 0.39036184961964304, 0.2849231806447078, 0.5224481805315995, 0.3330336747574394, 0.5279567165834645, 0.38649167058902534, 0.6155955431685953, 0.6993592801955042, 0.36154683656526354, 0.28223352743590047, 0.39092408662513767, 0.1938492340650806, 0.3001785508575967, 0.28009405777262486, 0.2957467669478804, 0.1624837774030239, 0.13760527130028588, 0.365579671790479, 0.20692073553432833, 0.20868637299841208, 0.21610444512934013, 0.20660138861311084, 0.26766817175840774, 0.27063460080092305, 0.22875992242030085, 0.2163235401767164, 0.19354742764626065, 0.20303767194783284, 0.21094550392153866, 0.19359292206812584, 0.21823675833558764, 0.18529421364429255, 0.1966959028522206, 0.19826110255549056, 0.18484978893539405, 0.22483989759452339, 0.8750514280319764, 0.9240931706642543, 0.9176198342361173, 0.1668621329690182, 0.1994000780611016, 0.14813049365247843, 0.8681834730140469, 0.1691551789267136, 0.1758146928987797, 0.8438914699219442, 0.8360038282760839, 0.8553667049148918, 0.2092949289859649, 0.2107428919434059, 0.21105835588232902, 0.7712302521691594, 0.7803939948592277, 0.843222506676973, 0.1774812758409795, 0.17974751771797315, 0.18826158100015877, 0.1876015433694309, 0.18290001884331364, 0.1903168130225632, 0.1805808257836654, 0.17726550905260396, 0.18420976996682636, 0.09153897295338342, 0.0907815297100455, 0.10051922222444176, 0.10376281449854119, 0.09290767410925982, 0.11967951906888119, 0.09068992728713243, 0.09953479157419987, 0.08148439477280411]}, "mutation_prompt": null}
{"id": "44a4d9c4-b26b-4b4e-9225-d269faaddcaf", "solution": "import numpy as np\n\nclass AdvancedStochasticPerturbationOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 8)  # Increased population size for better diversity\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Adjusted inertia weight for better exploration-exploitation balance\n        self.cognitive_coeff = 0.6 + np.random.rand() * 0.7  # Fine-tuned cognitive coefficient\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Enhanced social coefficient for stronger attraction\n        self.F = 0.5 + np.random.rand() * 0.1  # Adjusted scaling factor for perturbation control\n        self.CR = 0.7  # Stable crossover probability for consistent diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Adjusted velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 6)]  # More elite individuals\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Reduced elite partner influence for balance\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "AdvancedStochasticPerturbationOptimizer", "description": "An advanced stochastic optimizer that combines adaptive differential evolution with elite-guided particle swarm optimization, enhanced by targeted stochastic perturbations for dynamic search adaptability.", "configspace": "", "generation": 85, "fitness": 0.3222199611205526, "feedback": "The algorithm AdvancedStochasticPerturbationOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7478764754167757, 0.8310023136210523, 0.8340075688554651, 0.7571414793718891, 0.8159439457439223, 0.7938958510009736, 0.769763570514435, 0.8354434369453393, 0.8063339035606404, 0.45983239430199285, 0.5624053483526299, 0.552754551344498, 0.37517344196958013, 0.6048830584727514, 0.557996987095468, 0.4606431092504899, 0.6268945917325921, 0.3563750690153513, 0.13680752111518135, 0.6046708180479292, 0.12413517036291577, 0.15714860389226704, 0.09434167000318872, 0.11733337927361731, 0.11933009543954154, 0.1727020974348008, 0.11399664525419162, 0.12355988642967464, 0.08870388896926173, 0.09477912049329029, 0.1307747712443803, 0.1086687177601472, 0.09548832838730215, 0.11117482908732668, 0.13763263887334287, 0.1103126897446336, 0.9867912094926506, 0.9778941634612348, 0.9868054715801274, 0.9781263299950037, 0.9760883162590259, 0.9781221318455429, 0.9834804369370567, 0.973347167049823, 0.9784202543247322, 0.509437039603877, 0.6632817704065745, 0.6606292594750707, 0.48889858895769434, 0.6715998190942153, 0.6527267827547607, 0.08833457022013935, 0.6591813596179993, 0.6460505510169574, 0.7099064312304066, 0.20815815824369988, 0.79969120037345, 0.26747649605461454, 0.27395275031442257, 0.27466034934331907, 0.7814325221963138, 0.8040441641551836, 0.17236358036567345, 0.2009325891766799, 0.13039583166085944, 0.2812113092032319, 0.21108016402663166, 0.2546836690124137, 0.2613761668796416, 0.2025246330492243, 0.26341832402427134, 0.2562095447125071, 0.009958775109710438, 0.05140353609853332, 0.02189998628418177, 0.228111536786602, 0.25788708979774344, 0.2961160079383912, 0.08774268267104057, 0.09829018305117354, 0.09673284861581888, 9.999999999998899e-05, 9.999999999998899e-05, 0.047978287189046065, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0022305327728096014, 0.005188438396012129, 0.0033563359100616807, 0.09779890739738606, 0.04448756900098927, 0.029632398476318822, 0.10336583254002563, 0.06706044919077814, 0.06477601461217741, 0.13146996207942518, 0.11040897573779807, 0.0788912377577593, 0.04103613514150062, 0.043888904663937356, 0.04303260863355152, 0.0763627351671119, 0.16202022862048526, 0.08312869718966098, 0.08262052083714244, 0.19018356643531165, 0.08628319525060546, 0.1532486152321335, 0.146427035394742, 0.2321382799990226, 0.18503159106423261, 0.1834777932611994, 0.2952807153976269, 0.05414949016812465, 0.242326978689405, 0.05545947024259745, 0.5442059173019929, 0.5464744441655205, 0.5563113455765916, 0.5028102200649729, 0.5457743646134008, 0.548692121428209, 0.5542782179013832, 0.592688217181899, 0.5770285048938284, 0.12000585876869496, 0.10226925996276803, 0.11105875249217612, 0.12603689712277133, 0.1354249829307992, 0.10017667402515706, 0.15835052858660403, 0.16365281918312213, 0.11554503510547598, 0.29894870533689055, 0.2001744593469521, 0.1737700192522671, 0.3176493047566318, 0.37783600039994725, 0.19837303809483275, 0.19938512732575542, 0.26044054125368843, 0.25043384777449285, 0.39624651101584285, 0.5685640670418083, 0.27659216880446424, 0.35024386422774667, 0.5368145580684107, 0.5418246068784311, 0.4523727118056513, 0.567766956838256, 0.5070608762637174, 0.22159606012685518, 0.36579305585920097, 0.18110655117923868, 0.190268257522059, 0.24989279095423367, 0.21935993171739954, 0.3059713184293873, 0.22799204670097428, 0.2708108673742555, 0.20138578970667487, 0.25085085615361025, 0.2361870679178245, 0.21939720368599314, 0.1985165168378924, 0.2157671269393281, 0.23079959891124424, 0.2162344367051704, 0.218712961483716, 0.2093092120689244, 0.19701733738713678, 0.20844561404695694, 0.22164153701355893, 0.2050185236929527, 0.19901925968573375, 0.21979374830717435, 0.21979119854027063, 0.6496005587114525, 0.8660813806605537, 0.898590681805661, 0.8919537247780707, 0.155083787607874, 0.8659806502204426, 0.8221978468278934, 0.17619281830043876, 0.17772905560590857, 0.17796461335606895, 0.6509044807808777, 0.7500626054222763, 0.808591980664527, 0.20770647666414954, 0.20841678693009358, 0.20718822925516323, 0.19812902039019054, 0.80619701014047, 0.19874105766457462, 0.16966045030483023, 0.1890069552035779, 0.17635246114556702, 0.1808122815661274, 0.187537831425853, 0.17427218693753876, 0.16853564519234498, 0.21169873676424877, 0.17894290987206152, 0.08865329814367928, 0.09882985142734946, 0.09179361074824133, 0.07483002775929659, 0.0878483142197738, 0.09515499832301755, 0.1183631752760077, 0.1071326659216838, 0.11276781798652824]}, "mutation_prompt": null}
{"id": "0b8dc7cf-c1d5-4da2-b224-905d81f7f0b4", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 12)  # Adjusted population size for efficient exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Modified inertia weight range for enhanced balance\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.7  # Refined cognitive coefficient range for optimization\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Refined social coefficient range for synergy\n        self.F = 0.5 + np.random.rand() * 0.1  # Fine-tuned stochastic scaling factor range\n        self.CR = 0.8  # Balanced crossover probability for diversity maintenance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.7 * r3 * (elite_partner - positions[i]))  # Revised elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                if np.random.rand() < 0.5:\n                    positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer combining mutated differential evolution and improved elite-guided particle swarm optimization with probabilistic boundary adjustments for robust black box function optimization.", "configspace": "", "generation": 86, "fitness": 0.32062447375933184, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7462119044119584, 0.8192172443536583, 0.8196839940665562, 0.7598868074276144, 0.8315579796484038, 0.7877926789431458, 0.7771665593575294, 0.8361957462241043, 0.8252392449731571, 0.48597747813543024, 0.6057994298535061, 0.6200799099566039, 0.526914750637077, 0.6298548177256422, 0.47441873243028576, 0.04787096910480704, 0.6282350290171224, 0.6373951072272677, 0.15573313220972707, 0.15735194594434776, 0.12694714873433854, 0.13877620844253957, 0.13681589034750885, 0.12161220081681001, 0.10643322217396034, 0.14616895667454433, 0.1725761847171038, 0.12814906494268397, 0.13215685593285176, 0.10898758904336647, 0.12122204155133498, 0.12288167394724336, 0.1340142780560043, 0.11318961116429804, 0.13778442455792828, 0.14487969767724485, 0.9801381238524728, 0.9803593963297629, 0.9796565285798406, 0.9816740232854231, 0.9814742766277633, 0.9864624680616093, 0.983303343034531, 0.9816582642140405, 0.9856267631607413, 0.49404770377034324, 0.6661132018204715, 0.6443223331463528, 0.3994629547964107, 0.6788165722651216, 0.6760372731495156, 0.48545425650945306, 0.663714935965985, 0.6544768587892179, 0.7281514477715565, 0.7954869390560038, 0.36787776818385387, 0.20653726730493338, 0.20887206094842026, 0.1610328114793581, 0.7126433564946184, 0.8135536315550396, 0.23666670617654462, 0.1447040376881289, 0.2428627175529121, 0.25180090966359014, 0.2068038856279153, 0.234083458257219, 0.12852297319875594, 0.20395635453561423, 0.24343625010280012, 0.2680900354835516, 0.1991321317180168, 0.24976256948445752, 0.24621094528737275, 0.2156466077626661, 0.25060088270697356, 0.27343119746653244, 0.21976512810833337, 0.26044256675007227, 0.2498145889754746, 9.999999999998899e-05, 0.040004911675325605, 0.10125420301470855, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004403358270735569, 9.999999999998899e-05, 0.166410383776615, 0.1093219233936863, 0.11892934016422774, 0.015587932217380862, 0.02264935802090351, 0.02263658190424611, 0.054813034356294366, 0.1358783101022485, 0.028200003472014012, 0.061547301819050104, 0.04252710630713086, 0.04100050036182479, 0.07044127594160876, 0.12798057143792307, 0.062236955985412123, 0.14684634109602612, 0.06476408708713965, 0.06299976636794913, 0.10052355445462491, 0.12042004346880564, 0.14310098930147253, 0.07498047050292156, 0.1286873358537699, 0.2660622600322884, 0.05464174809541111, 0.12287098781313921, 0.07925937342700451, 0.5391836320373958, 0.5711177803573151, 0.5659517074544838, 0.5295553310420317, 0.5744323217013364, 0.5915376518063109, 0.5623175993180085, 0.5655304483175516, 0.5924113414996324, 0.14809497442433162, 0.1328878780569821, 0.12643868289155746, 0.10889775543785984, 0.16619010235222687, 0.1486529475502142, 0.11641552701250912, 0.11467014639171991, 0.11009247251010146, 0.14856176907052343, 0.2582666637055778, 0.41218425337182907, 0.21972098718134325, 0.2877740151973637, 0.7348751276539616, 0.2695426800511057, 0.4518666865519766, 0.5153139552989506, 0.4412111113676074, 0.42677208839609215, 0.5635440494170855, 0.44473895091735527, 0.5600382076423907, 0.45642492983990235, 0.4381102968231093, 0.5811859916631392, 0.2313747897060765, 0.32245392072711865, 0.2610888654652239, 0.11570952133401058, 0.26982608652581486, 0.2067972583048956, 0.18039966422803588, 0.2905083393783898, 0.2809487203441826, 0.48304667626417663, 0.2012497640328883, 0.1961882230734584, 0.23055102874690492, 0.20021749962853952, 0.24512815243724662, 0.22639037325858535, 0.1903493173945563, 0.20453252402613387, 0.23257239542162722, 0.19728101068918702, 0.19889422575811344, 0.19473898547173818, 0.21453380804723032, 0.18657557277234016, 0.2198259864472044, 0.20981725265929552, 0.19292415982234645, 0.22046036187899742, 0.8564168055112266, 0.8909536715098019, 0.8252659393820908, 0.1660247262669966, 0.16562925074488066, 0.16656700713057637, 0.16601178722253096, 0.17021844821936571, 0.16954630820106031, 0.5323638557814775, 0.7364445773935224, 0.7437870299558634, 0.20896842240602342, 0.21101930681276704, 0.20785858192209528, 0.21025592097364365, 0.788334098109935, 0.20859022103006486, 0.19131067000088664, 0.17408757572174893, 0.18074331509303176, 0.18902614890680547, 0.1834565341826041, 0.178276644050948, 0.19712339114843203, 0.19225329403135627, 0.1982499921612234, 0.09062688974907018, 0.08949586313749258, 0.10003486288564123, 0.07196377190028524, 0.08930826029646344, 0.09054990842200372, 0.11918960687880464, 0.13914293601353311, 0.09744913385686382]}, "mutation_prompt": null}
{"id": "854851aa-7acd-4a71-a2fd-0fdc43e8e216", "solution": "import numpy as np\n\nclass NovelStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 9)  # Adjusted population size for efficient exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Modified inertia weight range for enhanced balance\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.7  # Refined cognitive coefficient range for optimization\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Refined social coefficient range for synergy\n        self.F = 0.35 + np.random.rand() * 0.25  # Fine-tuned stochastic scaling factor range\n        self.CR = 0.8  # Balanced crossover probability for diversity maintenance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 7)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.7 * r3 * (elite_partner - positions[i]))  # Revised elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "NovelStochasticHybridOptimizer", "description": "A novel hybrid optimizer combining adaptive differential evolution and elite-guided particle swarm optimization with enhanced exploration and exploitation for robust black-box function optimization.", "configspace": "", "generation": 87, "fitness": 0.33070641002808765, "feedback": "The algorithm NovelStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.28.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7654565225710878, 0.844046651243433, 0.8297192215467671, 0.7680758699441275, 0.8430860010027632, 0.8307185773849097, 0.7857844425117577, 0.8366595767163589, 0.8398636501003355, 0.5176572576854022, 0.6452546970292785, 0.5886900564797948, 9.999999999998899e-05, 0.6394092754242349, 0.5416678612706662, 0.5180549553402729, 0.6637465213147193, 0.5987086401116894, 0.11283198368383596, 0.600084539639195, 0.15012123256522136, 0.14546688791872098, 0.14077946584232337, 0.15175938957639212, 0.13146087561433328, 0.46645110455214844, 0.13761331291962764, 0.12941031287402405, 0.13634283494212396, 0.13023627322151965, 0.118663898312801, 0.10590149940999805, 0.0827569928978572, 0.12224460300690354, 0.10552459072376841, 0.1296932070554473, 0.9809844201382268, 0.9731654262857493, 0.9810827586840737, 0.981726355290174, 0.979776301343053, 0.981679522500193, 0.9818925844679757, 0.9801955050192501, 0.9827049083374778, 0.48903844029315724, 0.711158043440669, 0.689160235013494, 0.5698737658243634, 0.7012465509549468, 0.69674253382223, 0.5475886017878515, 0.6929623487452536, 0.6775682812050325, 0.3012061517593848, 0.22513903189709306, 0.8189081710833362, 0.1904175637589357, 0.21787433553772184, 0.1611988842759673, 0.24287877060987517, 0.8675043797913399, 0.23375028491102767, 0.19986657261860863, 0.2585456157820476, 0.2631074251278964, 0.19449467173025747, 0.267277109213655, 0.1302111876984673, 0.2757473327070441, 0.2621824892106307, 0.2696798310912717, 0.22350366841944957, 0.2487169929091969, 0.25975509830576415, 0.2064637172651731, 0.24681618163397323, 0.3166013526391386, 0.22552909881291927, 0.265184779826124, 0.25824713139907185, 0.0011409984898400616, 0.004201442466528871, 0.006152220623245941, 0.05334295316497517, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06747665137542047, 0.07125663176709729, 0.0887165353465964, 0.020721757101943128, 0.021604453647719346, 0.0166172813676545, 0.07141316558505528, 0.14557294441500768, 0.035705475890116745, 0.08079436859270195, 0.04617111353519854, 0.0758999412140714, 0.06392919427014554, 0.14206534058207398, 0.07067652823446846, 0.06630128467156515, 0.06796088488919161, 0.06755343443383721, 0.1421172594203477, 0.08040746854086323, 0.10443680739610373, 0.1618390985814374, 0.15048572286904216, 0.05050199683541956, 0.14325343803971624, 0.12890320769965746, 0.1534786911110847, 0.5264596046269695, 0.5543980031453618, 0.542788121249775, 0.5279446435163466, 0.6406819773407827, 0.5550922471865736, 0.5322999587229099, 0.5616266048881278, 0.5742691557137178, 0.14303363595965313, 0.10503019514986955, 0.0777853452083842, 0.11161033968928569, 0.13372669811247684, 0.055698013606398256, 0.10314128819542168, 0.11116017809071543, 0.1052808973253645, 0.1400248438900924, 0.301823335856513, 0.24488096125440295, 0.3174371330464677, 0.2526406763888318, 0.18972141119834218, 0.22884272524548865, 0.5377716858638841, 0.3285205912976745, 0.3968873034591729, 0.5829744695740116, 0.418097035790859, 0.33475696619766193, 0.5907215995889077, 0.26370141418160276, 0.4574325114455252, 0.6253875386573858, 0.5540534450006558, 0.19106962559457286, 0.28958450591527385, 0.14676018048006678, 0.23224425644517488, 0.28679469302172733, 0.2534912600471201, 0.15966449105983216, 0.22748003783254256, 0.137304069303114, 0.22208692634239602, 0.21249796978127966, 0.3420933589007207, 0.22729713177879596, 0.22419854706764453, 0.23634219988779892, 0.21708328775209595, 0.2164100515867915, 0.22420281690198784, 0.4621452068095321, 0.6428656684560539, 0.19430787721770515, 0.20444198240982003, 0.22074923470025254, 0.18127720052070562, 0.2159760663111897, 0.22146046201062353, 0.2210609055696221, 0.8711923456301119, 0.890394298921157, 0.9098664067419984, 0.1662091304188853, 0.17044805943814823, 0.16671473863710284, 0.7940599149344123, 0.8647798016684122, 0.17258677398250566, 0.1691820723513593, 0.1688638848618793, 0.7365136660399134, 0.7481649084198823, 0.21087749150794877, 0.7648695894186264, 0.41042222864544187, 0.7633996385971042, 0.785052929792036, 0.17623478317130736, 0.18897724590745368, 0.1873521937646636, 0.17018551014746242, 0.18259490950995194, 0.1842271633671213, 0.1934323017917734, 0.2231656992910328, 0.18651268857516656, 0.07820261937879691, 0.09415791147357155, 0.0911096463128368, 0.0869704999137666, 0.08733698089861941, 0.08542979509058346, 0.10416915920444447, 0.128191246326808, 0.09754827480409023]}, "mutation_prompt": null}
{"id": "10e617e4-ae4b-42b5-a5e3-88967c2874c3", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 8)  # Slightly increased population size for better exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Adjusted inertia weight for improved convergence\n        self.cognitive_coeff = 0.6 + np.random.rand() * 0.9  # Refined cognitive coefficient for better learning\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Refined social coefficient for enhanced cooperation\n        self.F = 0.35 + np.random.rand() * 0.25  # Expanded scaling factor range for diversity\n        self.CR = 0.8  # Slightly increased crossover probability for improved diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 6)]  # More inclusive elite selection\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer integrating diversified differential evolution and adaptive swarm intelligence for robust black box optimization.", "configspace": "", "generation": 88, "fitness": 0.31517301437732487, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7441624397360502, 0.8267524042979042, 0.8108599960811184, 0.18158426936512462, 0.8285583215211458, 0.8161421510334379, 0.7800137050046363, 0.8280118029365684, 0.8048896215993072, 0.46884556543294775, 0.55634112408304, 0.5680975776168945, 0.422381908306543, 0.582044440479825, 0.5744256185144097, 0.3774443190975184, 0.5796342010402751, 0.0045948266857569475, 0.16536359580837756, 0.11404891810512596, 0.1520348399306185, 0.14814389268195283, 0.1738334252430377, 0.11060119773157218, 0.13272789823880615, 0.16587696439384558, 0.13425395687249564, 0.0990974556436659, 0.10709944116739956, 0.12337556331458943, 0.12402244253751338, 0.11230921729644638, 0.10917340689702071, 0.12414241408896864, 0.11943218530170685, 0.09330258384113499, 0.9759159574652021, 0.9751057261825412, 0.967437933423916, 0.9779188446870228, 0.9771257813384413, 0.9762772996994906, 0.9777841336070769, 0.9732381119459085, 0.9728247379043607, 0.5082792649072541, 0.6762170377967683, 0.6742160587307442, 0.37914247153251657, 0.6207907614285322, 0.6091046409307568, 0.4650586703393048, 0.6417438298967659, 0.6699102610800183, 0.21901051548772865, 0.13687125464122896, 0.7938182035071173, 0.7610894519558992, 0.27462511553840374, 0.16031362893397638, 0.7672341176439876, 0.7942136491369391, 0.23362518035896396, 0.2326468737075038, 0.2607326660409053, 0.30022376611377266, 0.20485117027534716, 0.1309145027491393, 0.13128360601193867, 0.19639305704513954, 0.2606315124448221, 0.318469745708027, 0.050965809977180254, 0.20666779101247135, 0.2345431107301128, 0.12688447346501797, 0.44742738641783086, 0.20716090272063914, 0.21352837814424663, 0.2817304822456749, 0.16015961899562248, 0.0011418476695209678, 0.17162112571106258, 0.001226546470888934, 9.999999999998899e-05, 0.07468100811544442, 0.03199369064367896, 0.01467705268291497, 9.999999999998899e-05, 0.02225844363504581, 0.02472764199403865, 0.08877651505228423, 0.058697899407456844, 0.042606114419586394, 0.05299036736614149, 0.02388661848417173, 0.06379904453663188, 0.10791211353469465, 0.05211106682255773, 0.06109064511653428, 0.04713060332328556, 0.11977109640445449, 0.060677235505414484, 0.1754330970626775, 0.08531547953046115, 0.05881367014821193, 0.08499131870553789, 0.11901859753566746, 0.17575187643371704, 0.24082041747267147, 0.11269471136078268, 0.060812933243726164, 0.06595326105359223, 0.1768386149292559, 0.04576853458425589, 0.07223593351338464, 0.047649317267412505, 0.5356978313841654, 0.5777278328348614, 0.5649840963238872, 0.5257337393433965, 0.5190655704767548, 0.6071923172838225, 0.5483007379954179, 0.6154816231202462, 0.5717973040130357, 0.14583247888607953, 0.1515311873009001, 0.1194354297140453, 0.10742921625000978, 0.1485850826474161, 0.09766484725325231, 0.09592492329988689, 0.11625742027723296, 0.13871648842111206, 0.16136212247957338, 0.26203345888881513, 0.31422570204730393, 0.391218443866581, 0.28061450382612907, 0.18987420344219064, 0.1580208491503503, 0.30660270005278056, 0.24792450955657264, 0.34175392246936054, 0.37727973232037204, 0.3300056878746356, 0.4109562964566106, 0.5171844677971236, 0.4671395544825545, 0.4552117755436428, 0.5845570707422799, 0.5536890794142922, 0.21608877477631716, 0.30344562492981675, 0.17775563465612942, 0.19880615437020788, 0.3477016833120129, 0.32851309032494413, 0.21010858348807981, 0.2589384296791555, 0.25236487015886544, 0.22990167959650487, 0.20728970721983409, 0.2146277919234546, 0.19533575424580885, 0.22012883791646687, 0.21415537890542113, 0.19558778930723775, 0.24013904170890432, 0.18764561406261016, 0.2174395336293653, 0.20104307820614054, 0.2425807454365264, 0.22627745168332636, 0.23532583057629075, 0.2008126865203098, 0.22717804838600697, 0.21779615705135802, 0.2426805787452596, 0.8692943471308596, 0.8992543148421032, 0.8865389338007204, 0.16707549342428396, 0.16822168517378866, 0.16892514896137678, 0.17777703984603066, 0.16794515657494868, 0.8748352466669538, 0.5625729353800416, 0.8202978796149378, 0.7169318654610171, 0.21099821334353874, 0.2117757497446563, 0.209105502840918, 0.20587315847705645, 0.7925329603651639, 0.8141849435470212, 0.18533735044141253, 0.1796306066069423, 0.19666436585910962, 0.19788269395409241, 0.21460036784143766, 0.18564994911209842, 0.18063618186656716, 0.18769798534985993, 0.17505831414166606, 0.08747077148361915, 0.08655841814934395, 0.0832287215944223, 0.09480135056328598, 0.09170401259249339, 0.09904930197217732, 0.09489537784998425, 0.11809730889763248, 0.1157810684073618]}, "mutation_prompt": null}
{"id": "89b590d0-d7ba-45d0-927f-76210bd1fc6e", "solution": "import numpy as np\n\nclass RefinedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 8)  # Adjusted for increased exploration capacity\n        self.inertia_weight = 0.4 + np.random.rand() * 0.4  # Enhanced balance between exploration and exploitation\n        self.cognitive_coeff = 0.6 + np.random.rand() * 0.9  # Optimized cognitive coefficient for adaptability\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Fine-tuned social coefficient for better convergence\n        self.F = 0.5 + np.random.rand() * 0.3  # Broader scaling factor range for diversity\n        self.CR = 0.8  # Slightly increased crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 6)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.7 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedHybridOptimizer", "description": "A refined hybrid optimizer that leverages enhanced elite-guided strategies and adaptive parameter tuning for improved black box optimization performance.", "configspace": "", "generation": 89, "fitness": 0.2714005636964474, "feedback": "The algorithm RefinedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.25.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.6447190688096966, 0.7676735187931506, 0.7271146350251905, 0.6517171181259319, 0.7567363152246037, 0.7340597767531527, 0.6677640566892074, 0.7790378678708407, 0.7427426456468049, 9.999999999998899e-05, 0.455236882498702, 0.03761146783247771, 0.18966977206916502, 0.3847305959609105, 0.479726106403603, 0.04929747557392927, 0.43134140277408983, 0.3168743719607413, 0.11045960601162552, 0.1960657163396924, 0.12686470522232007, 0.11504809505942815, 0.13725768759108137, 0.1612223719088668, 0.09337499481613754, 0.15591341506376843, 0.09543414624097846, 0.09088814921483279, 0.10338775263003919, 0.10211644196647174, 0.0890068091276105, 0.12408405727202065, 0.12235340943031847, 0.07813521656675348, 0.11054663840591095, 0.09707737961216212, 0.9860634487937245, 0.9758862786564539, 0.9777421723422339, 0.9780072223488886, 0.9774246380549807, 0.9777363851904409, 0.9835933632417374, 0.9768086327341964, 0.9773919403294437, 0.36171035807385044, 0.5479947098346722, 0.5454345501883675, 0.1506419120919671, 0.15086091999743656, 0.14969775722607415, 0.12469636148693986, 0.5461321573894501, 0.43037328034482514, 0.20781395872773245, 0.6864383977813416, 0.7601440839070559, 0.1990183424744819, 0.7939036873194582, 0.2637662984550927, 0.16556219175161369, 0.23132584178088933, 0.2159452918891499, 0.17926336782488506, 0.2113192758019743, 0.2097935782405621, 0.14101524273246124, 0.2112750445265449, 0.12131007695295315, 0.18743956904525527, 0.1970519658487282, 0.24204536734800375, 0.019995937870418312, 0.2086661424162698, 0.0981688936999402, 0.1936538818540683, 0.2393232158991736, 0.2515376703677388, 0.15312917448814822, 0.22355999429955442, 0.03311918131038716, 0.0005176407919896819, 0.038815064131761945, 0.050025825631674126, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0030686379919406814, 0.002032805812615557, 0.09617604894185694, 0.07896908794005209, 0.0783557686125903, 0.007371123558051806, 0.07438025017976724, 0.014168181607945862, 0.04708214609680905, 0.03692530556116724, 0.06745881460429759, 0.03392076243828379, 0.03955633666309155, 0.040154320355929474, 0.11693515587972214, 0.1394518861736036, 0.056876004151265036, 0.09289860126289895, 0.1039942266510796, 0.0790747516207142, 0.03810074741579317, 0.08885870796124395, 0.1117282084866269, 0.11120343020838341, 0.12655348260448596, 0.1667173010797789, 0.047319238011735765, 0.054009457422225404, 0.04859937225190025, 0.4758315044515229, 0.5099667406702924, 0.49787359486350113, 0.47099386708576074, 0.5152585254718143, 0.5478044994623856, 0.46070654253767085, 0.5390081089855312, 0.5368955337667404, 0.10606626778547001, 0.12048893419503581, 0.15405335591831082, 0.09296220088917528, 0.13398295466088184, 0.12225348397806823, 0.10710826720396349, 0.1273721014170831, 0.12589341821557642, 0.14628425479840135, 0.152571435664125, 0.22466828850407405, 0.1484047635187089, 0.19280413675616637, 0.2088227463859249, 0.1848411277756351, 0.1435828905861668, 0.13604178615837614, 0.31309696795087916, 0.45107926213218885, 0.3618498174288042, 0.35005276483238545, 0.42806274139288947, 0.4377648825471643, 0.332450045505818, 0.48230496782666743, 0.4570004307195896, 0.25160447220877025, 0.24654449729412087, 0.2589672035713042, 0.18591568363522093, 0.19561462769514137, 0.1983289525998152, 0.25897926052076126, 0.28983880609442114, 0.2369600334795774, 0.20767415139440604, 0.21026391265133737, 0.20697928358307804, 0.209040751223599, 0.22346152510152284, 0.21762897017545468, 0.1931568117142034, 0.2066534407221553, 0.22951867202845622, 0.1920661533067768, 0.5261441244085157, 0.21528625868203088, 0.1805082048630815, 0.20409351339728987, 0.2035051711895478, 0.22436140325147258, 0.211639647618988, 0.18402489727668048, 0.8067256552555775, 0.8700210214553996, 0.8378588616524624, 0.1532626255094649, 0.16188818434136298, 0.16440249650986483, 0.5796722371767444, 0.1662146281991741, 0.1675941962633284, 0.5382345017515802, 0.7392739114936213, 0.723663039981247, 0.20698750772538865, 0.20717085383429712, 0.759550568183655, 0.18998877363608735, 0.19715819134976753, 0.18772917570057757, 0.18366544409639274, 0.19844716825901143, 0.20777225764010843, 0.17790601159389896, 0.18986836185425204, 0.17845925557128883, 0.19739962214975426, 0.17797180704992877, 0.18470089360096065, 0.08078311701688656, 0.09129580017080774, 0.0869703005128214, 0.08795350745009234, 0.09200876581395911, 0.08710358536689711, 0.06848692357651365, 0.12451244607109524, 0.10398629335481924]}, "mutation_prompt": null}
{"id": "5115d872-2844-4015-9f91-6ceb94ac2a84", "solution": "import numpy as np\n\nclass EnhancedHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 8)  # Slightly increased population size for better diversity\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Adjusted inertia weight for improved convergence\n        self.cognitive_coeff = 0.5 + np.random.rand() * 0.9  # Expanded cognitive coefficient range\n        self.social_coeff = 1.0 + np.random.rand() * 0.6  # Modified social coefficient range for better coordination\n        self.F = 0.5 + np.random.rand() * 0.3  # Tweaked stochastic scaling factor range\n        self.CR = 0.8  # Slightly increased crossover probability for more exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.15, 0.15, (self.population_size, self.dim))  # Adjusted initial velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 10)]  # Increased elite subset\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Slightly reduced elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling with reflection\n                for j in range(self.dim):\n                    if positions[i, j] < self.lower_bound or positions[i, j] > self.upper_bound:\n                        positions[i, j] = self.lower_bound + (self.upper_bound - positions[i, j]) % (self.upper_bound - self.lower_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedHybridOptimizer", "description": "An enhanced hybrid optimizer utilizing adaptive differential evolution and synergistic particle swarm dynamics with strategic boundary management for improved black box optimization.", "configspace": "", "generation": 90, "fitness": 0.31668514929556857, "feedback": "The algorithm EnhancedHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7269769092999895, 0.79812572067564, 0.790765521997872, 0.7389110958424877, 0.8045435309237585, 0.7675407551811722, 0.7453017616632014, 0.8180584078789673, 0.8123036277522213, 0.4414439417451831, 0.5657533039360065, 0.5124749143143414, 0.39897352160396216, 0.6178951698971578, 0.3701504398116968, 0.4059484918151769, 0.5588967295825514, 0.5755536023534288, 0.12168730053870458, 0.1373244062325415, 0.14822408583496016, 0.27793693215926074, 0.43459433645585055, 0.12874579012950493, 0.30518035818498024, 0.16973205616746723, 0.1708481948117937, 0.124255566080266, 0.1098653632038018, 0.09131541375204832, 0.1169639925089263, 0.10052631655266309, 0.14691526606175487, 0.1132282050527732, 0.1044012785645353, 0.10798284398040303, 0.240607979192347, 0.9360890279093971, 0.7986056028390254, 0.9197893283134404, 0.854480036580143, 0.8249919753172589, 0.876890408187802, 0.8906164872534734, 0.7389340457407683, 0.4654594984406787, 0.6931402712440825, 0.6620833966632419, 0.49679762578077713, 0.6647042708973028, 0.6408078832368638, 0.4850762370160454, 0.6782947006724733, 0.6553958347614621, 0.16371931848813004, 0.7744456682448161, 0.7961121933330769, 0.2755659654944822, 0.275395230284323, 0.26467279272660693, 0.39039872415837895, 0.2324148465688496, 0.7748198752239451, 0.11492418951144534, 0.1237111775354095, 0.29165498628428566, 0.21690572478423176, 0.2507788189955982, 0.2772686393727055, 0.305555871626644, 0.23756782295315815, 0.293301628742734, 0.31682097857446856, 0.37301487173511627, 0.10137507101489551, 0.11628184131127162, 0.2674262806326062, 0.11131940465016066, 0.23859534008568384, 0.25330120264915523, 0.15669633486814527, 0.00032538598342057856, 0.019615580196122973, 0.05738228163812398, 0.022906431151694218, 0.059133972112741184, 9.999999999998899e-05, 0.0001010524570936866, 9.999999999998899e-05, 0.01727456827969709, 0.0932478508715665, 0.16109314482668446, 0.0797061251055371, 0.013585625107159105, 0.021753074041109044, 0.04825664452314704, 0.15222009273942638, 0.09590152399429497, 0.10905953497578535, 0.16077420258326547, 0.08446893183592874, 0.03260150871836809, 0.11249987343459811, 0.08765588491995224, 0.18295701355995775, 0.07866274953574304, 0.14834040606354393, 0.18576904003619465, 0.1063161251458532, 0.15219277479307058, 0.08663806790135509, 0.10124021144674011, 0.18307612964921005, 0.08160711565681744, 0.12378282437233645, 0.1659511268218299, 0.17488939397762793, 0.5000220620055937, 0.6198653400972679, 0.5768007213359743, 0.5155416595569502, 0.544784028377203, 0.5430706568731518, 0.5042900755159654, 0.5650250121285972, 0.5651127003049732, 0.09828495955520689, 0.13220479976972888, 0.12051172072692606, 0.13135145064819698, 0.1131708116593001, 0.12527793418094957, 0.13196045384597832, 0.11563264380428628, 0.1489194778291688, 0.19517626428917834, 0.18070620659967485, 0.3836787464205683, 0.15145431128140663, 0.2582105258074908, 0.2690785852141697, 0.16951662495633968, 0.3919503450124602, 0.546932467184754, 0.45521982803510896, 0.4067875792241984, 0.28190482623378776, 0.3911607635255141, 0.5542130098968521, 0.49465802977941953, 0.4181607692282975, 0.5540480655036764, 0.48065441581759416, 0.2374503896241138, 0.254336885061341, 0.29559567580296064, 0.2880697790573046, 0.2550333398266368, 0.37132048770871906, 0.3470741837580321, 0.4147905455240971, 0.38684369457667866, 0.19955543944247178, 0.22006922106472315, 0.4148019434683802, 0.2080480556273252, 0.21087830225548132, 0.24040748721237315, 0.2059635684383716, 0.22155709908878174, 0.2365169407077664, 0.1953299762727606, 0.22447047665962827, 0.2232219468106249, 0.21013877292480698, 0.19252558843379786, 0.1940283183642797, 0.2279878405212329, 0.18433819411005403, 0.193297267447743, 0.8619427683339007, 0.8848339091427982, 0.8753026381679656, 0.15756409537944982, 0.8656472989229143, 0.15731481379641477, 0.13433335605327068, 0.15978332860773548, 0.1962534617653351, 0.7286212982901932, 0.7334330924071422, 0.8248757605806503, 0.20619743147070235, 0.20996543207575058, 0.20949375265813297, 0.719046887655045, 0.20947578008207268, 0.20749933380595798, 0.18358587942746585, 0.19733887777757364, 0.18209397582398956, 0.17272269512219918, 0.19654164879295533, 0.1757446593979235, 0.1827025388064153, 0.18517940366248875, 0.17865550749021508, 0.0820172395382871, 0.09719892183721679, 0.0882170647995616, 0.08653661462301898, 0.09051148686256472, 0.07560696018566415, 0.08398174128042923, 0.10318637224183802, 0.1342560980612203]}, "mutation_prompt": null}
{"id": "8c37000d-70c5-4c42-82e9-457fc112061e", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for efficient exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Modified inertia weight range for enhanced balance\n        self.cognitive_coeff = 0.9 + np.random.rand() * 0.6  # Refined cognitive coefficient range for optimization\n        self.social_coeff = 1.2 + np.random.rand() * 0.6  # Refined social coefficient range for synergy\n        self.F = 0.5 + np.random.rand() * 0.3  # Fine-tuned stochastic scaling factor range\n        self.CR = 0.65  # Balanced crossover probability for diversity maintenance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Revised elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer combining adaptive differential evolution and elite-guided particle swarm optimization with refined exploration mechanisms for robust black box optimization.", "configspace": "", "generation": 91, "fitness": 0.31566610013556295, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.27.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7928123961615785, 0.8347370107239002, 0.8340009418130988, 0.7843331349666288, 0.8376909533717303, 0.8253619452410677, 0.7892743123363266, 0.8389540423084239, 0.8328252100808677, 0.565378118523101, 0.6493408579845485, 0.4212672426321006, 0.5166452897755504, 0.636267492827234, 0.6135301474653777, 0.5357375391209969, 0.6413283939720346, 0.6523013211047467, 0.16323344048340493, 0.1726741269073726, 0.11455264824738354, 0.43715504748127076, 0.13478208989304985, 0.15253844825581486, 0.10813981570620324, 0.15291865306294583, 0.10804205658091437, 0.1168981187884669, 0.1352539051663172, 0.12471920021495975, 0.12568587090585648, 0.12494225111763813, 0.10970301424632367, 0.11288269978972276, 0.14750291675498262, 0.11043313030535917, 0.9721273428502282, 0.9701728309612534, 0.9776253295780258, 0.9796181027620746, 0.9722077559628961, 0.9791632461583825, 0.9821624845397715, 0.9812630036016853, 0.9821072522124216, 0.5299533455148442, 0.6699495131556857, 0.6671563200430431, 0.4957022867258334, 0.6522078713734657, 0.6630346433863962, 0.5430883049083135, 0.6812035619427698, 0.6752386161990267, 0.22467871640516823, 0.7764287683305235, 0.22349844375532546, 0.205285885016801, 0.20542194512037937, 0.27547161787251895, 0.7799122050385721, 0.2343079892620601, 0.8180376309491135, 0.19223794459731203, 0.2459193331584193, 0.25175792614116677, 0.12848986332960888, 0.2275264184344591, 0.12839354906388967, 0.20916486370719378, 0.2686514904696742, 0.26151322608380334, 0.204169848179807, 0.23885512628719907, 0.2506814204130353, 0.2561123716390751, 0.27795455033333105, 0.3421638108596895, 0.24145702712758133, 0.2548731243600393, 0.2744805464961966, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004703689150005075, 0.0002644232565689464, 0.11773600744830415, 0.0782405695701629, 0.09084242209418358, 0.02154774827137884, 0.02371786198662229, 0.016498347301011407, 0.017982151368033716, 0.08013878722161116, 0.046167523050308024, 0.030407213313916492, 0.090940143835464, 0.05030833535335044, 0.13247546851325476, 0.17159489213984613, 0.15936030044103822, 0.08108493718206433, 0.09798878145525325, 0.18323122006071912, 0.04137006230128504, 0.04165373895080282, 0.04049932678617352, 0.16690631763025043, 0.14171287019493317, 0.03782948964718924, 0.04702895798662354, 0.06367985495682571, 0.08208486569801499, 0.5368571289166322, 0.5783199486664499, 0.5868914370860125, 0.5493170221126438, 0.5475768654029629, 0.5479580774408701, 0.5285426560086767, 0.5753051017707239, 0.6059176624149716, 0.08278086884088476, 0.14796947973899366, 0.1137229449501469, 0.14338557646528538, 0.14128568932597352, 0.09937212021040565, 0.1365136094262609, 0.14559854664088112, 0.1483731629497984, 0.17988264502254392, 0.42215893927379766, 0.19860532954331434, 0.19711723756591104, 0.21361650150300115, 0.19698652896898894, 0.2911595138288814, 0.23970356781794389, 0.3675699280263217, 0.46573255578811834, 0.5162408242346237, 0.595488603659118, 0.2532290728464047, 0.3986124278802159, 0.45242278483452547, 0.4969246083049421, 0.29617843471719085, 0.21990969810181804, 0.28491891350139376, 0.3376968617083036, 0.1585971956702419, 0.21092531443982931, 0.3361488979974494, 0.25526907962894185, 0.23152728829716573, 0.13638989973675542, 0.16978510066346952, 0.2051748309490401, 0.20031086882484161, 0.22408303280642572, 0.20213408076606587, 0.21061457886824697, 0.20261696319481537, 0.22852552098107082, 0.20449052890755326, 0.19984606030531027, 0.433469073428572, 0.18892729673341624, 0.1846080156692378, 0.18805859960267157, 0.6671407611454807, 0.19938718830690372, 0.23705077252906448, 0.7015491143583448, 0.205584564986656, 0.8643068422822759, 0.8945928747815475, 0.8928512942126409, 0.15689010023602767, 0.14770640587680084, 0.15775114047439875, 0.12704020575259856, 0.14698031684366197, 0.12783146032331172, 0.6668135783503863, 0.7867139285204046, 0.7101116363439907, 0.1682123789934813, 0.16808246480749567, 0.16905794093474324, 0.1543669405342455, 0.20883918872692186, 0.15440799764493662, 0.18691556147200827, 0.17281253393587537, 0.1837698068463316, 0.1837280083264018, 0.1844251338886781, 0.183318582618215, 0.17604660354487955, 0.19049377647539334, 0.19399019570184006, 0.08489731626460395, 0.08653622354219026, 0.08554683338790636, 0.07954815786890745, 0.0858928882536808, 0.09465678027287538, 0.10644294477493077, 0.10578715174721331, 0.09048738463573214]}, "mutation_prompt": null}
{"id": "59d3996d-0650-4726-bcfc-7b5bd76b849e", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 9)  # Adjusted population size for more exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Modified inertia weight range for improved balance\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.7  # Refined cognitive coefficient range for better optimization\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Adjusted social coefficient range for improved synergy\n        self.F = 0.5 + np.random.rand() * 0.3  # Fine-tuned stochastic scaling factor range\n        self.CR = 0.8  # Balanced crossover probability for diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 7)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.65 * r3 * (elite_partner - positions[i]))  # Enhanced elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer that combines adaptive differential evolution with elite-guided particle swarm optimization, focusing on a balance between exploration and exploitation for effective black-box function optimization.", "configspace": "", "generation": 92, "fitness": 0.3112461631455816, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.26.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.7514252079627837, 0.7878918703395336, 0.7899649699107107, 0.747100895327304, 0.8091997155484616, 0.7860406236292585, 0.744635746091685, 0.812773984322762, 0.8043648197628299, 0.42918680519597485, 0.5682197679711196, 0.5221656666708006, 0.40068908695469674, 0.5207148422992791, 0.5621864843897607, 0.46840435147164683, 0.5478897422719828, 0.547018888482965, 0.16041484990364863, 0.1609307041469752, 0.5550718503834091, 0.1363217318609804, 0.14301227294902785, 0.07381962173259438, 0.12230385852582826, 0.16040097797430897, 0.13832218451690947, 0.11873346013190589, 0.11429261511381661, 0.10426522918602987, 0.10478268439751903, 0.10155837514888066, 0.14422635826834374, 0.11117748626401824, 0.10386149621992646, 0.114611530027801, 0.9775767529637758, 0.9762376655946486, 0.9776639832307452, 0.9776194719814761, 0.9774911553347914, 0.9779075657520422, 0.9779621380346486, 0.9762454852071449, 0.9766995852906503, 0.43301744404089815, 0.6436099818238697, 0.6281255315064312, 0.42829889229258056, 0.5740267955338825, 0.15026378904136073, 0.4127767150219406, 0.622306645262257, 0.08800132914338099, 0.22853202442681475, 0.21985455803783993, 0.7673406033627735, 0.1888645673823789, 0.7802403287148234, 0.802600790515352, 0.22429296599912718, 0.23178551800306568, 0.8171637976091475, 0.2017825878739231, 0.20917566207984195, 0.23345043033479573, 0.18148963178937427, 0.22485860804511804, 0.12974028497036327, 0.18767946723176487, 0.27397492954247904, 0.23932068583184973, 0.021886071752837966, 0.22898666230736087, 0.2359379545138267, 0.222611768796111, 0.2460078134278043, 0.24851652529907842, 0.19176949137313604, 0.24417170760241114, 0.2598998197817718, 0.0029890161570350626, 0.030812837425417405, 0.047797569066402534, 9.999999999998899e-05, 0.07256873875519809, 0.004773672602771284, 9.999999999998899e-05, 9.999999999998899e-05, 0.000728477328832744, 0.07454584732188907, 0.07228029553990944, 0.06990769430785626, 0.05862905070517721, 0.08605448245259761, 0.04511154337111878, 0.08473550634753824, 0.07729720078743318, 0.17227756371541214, 0.03960991483256837, 0.04322685667469173, 0.04193314819450844, 0.14896464701720014, 0.1510218434535745, 0.1770445631158314, 0.07683492639383438, 0.08637977519395923, 0.0844202175165758, 0.03979731190351288, 0.2709450255036058, 0.06386338183705442, 0.11292723501974122, 0.23112686378872094, 0.005915924844718812, 0.052060517665452055, 0.07905967655178936, 0.05190768474759444, 0.493771535549431, 0.5346003525310591, 0.5298518161472416, 0.4927988826638109, 0.5666552998423997, 0.5683896126096248, 0.4923578411695787, 0.5897114522419749, 0.5481218768050095, 0.112016857165954, 0.13793975017735027, 0.135943833949267, 0.10675973137588535, 0.1736706028863637, 0.12546904030867811, 0.10986765178496516, 0.12619720500629006, 0.10065542851780596, 0.21986865551025037, 0.4263223152439597, 0.327921835720425, 0.1710163294039867, 0.26381774604403807, 0.38623461576440477, 0.2789086915643225, 0.25513401721424045, 0.19462538665777818, 0.35690623067082616, 0.44400016433328915, 0.4720337758785358, 0.2880211486622769, 0.5190587855187012, 0.4779286061958026, 0.27085219628894863, 0.4873416826339686, 0.4972073022104143, 0.25780630910870883, 0.14301875721023694, 0.1848697638291409, 0.19395271088484556, 0.25421345702393316, 0.20748077842899681, 0.2858291787158238, 0.36822093481580587, 0.2586755028483133, 0.22763955534778968, 0.2089004673981686, 0.2169365827596188, 0.20466168006259366, 0.21259656060615184, 0.20965420072530194, 0.2096317252034765, 0.2179787608024749, 0.19817197814673704, 0.19261015575267648, 0.19357656607635731, 0.21803763683703636, 0.44574860919453674, 0.21663161982001833, 0.21404026287889955, 0.20968379474769872, 0.6193883526129143, 0.23838222810440846, 0.8270936097820156, 0.8742865345167415, 0.8655009141725628, 0.15622252967668082, 0.1563138345224243, 0.19625628022035657, 0.16856307168222506, 0.1752870230931729, 0.16836712573834922, 0.7299175650662691, 0.844979933688371, 0.7457310092120892, 0.6723483780105042, 0.2105943780226085, 0.7869995724372542, 0.20888702291896744, 0.20641749040872814, 0.1555152962980868, 0.18426474135879922, 0.17970481153312012, 0.17776120875988854, 0.1840188054327473, 0.17391484467162266, 0.16981293657275964, 0.18285286832434922, 0.17949698558395522, 0.1818297348846566, 0.08442097918543734, 0.08753400969681646, 0.10020494714146133, 0.07401282235799866, 0.0906314605824593, 0.09120011541018191, 0.09862059572356707, 0.12284258211725496, 0.0828528852929381]}, "mutation_prompt": null}
{"id": "24283a54-8296-440a-8532-458feaba2ca9", "solution": "import numpy as np\n\nclass RefinedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for efficient exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Modified inertia weight range for enhanced balance\n        self.cognitive_coeff = 0.6 + np.random.rand() * 0.9  # Refined cognitive coefficient range for optimization\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Refined social coefficient range for synergy\n        self.F = 0.3 + np.random.rand() * 0.3  # Fine-tuned stochastic scaling factor range\n        self.CR = 0.8  # Balanced crossover probability for diversity maintenance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Revised elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "RefinedStochasticHybridOptimizer", "description": "A refined stochastic hybrid optimizer that incorporates a novel balance strategy between adaptive differential evolution and guided particle swarm optimization for improved black box function optimization.", "configspace": "", "generation": 93, "fitness": 0.3299913589170763, "feedback": "The algorithm RefinedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.29.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.8092640684781456, 0.8629781864315706, 0.8426422914795838, 0.7964952509766104, 0.8502554790177016, 0.8533294412041804, 0.7969081019673877, 0.8560265309560818, 0.8361627721760223, 0.5905890703612551, 0.6354925647058232, 0.5759087839874812, 0.04079788124105055, 0.6408063720544878, 0.044271035793375435, 0.5582235407748356, 0.7096186836770557, 0.05027668713100242, 0.14659782313967773, 0.12076471861146654, 0.15578209835927626, 0.13643785248570695, 0.125406669335567, 0.12875224100953964, 0.10825768960745041, 0.6419603742341023, 0.12606462227797766, 0.08583832425811799, 0.12334617502379097, 0.10453907712461064, 0.11816670352438319, 0.11300417095948401, 0.1114962816596069, 0.09400356092017514, 0.126015246177281, 0.1068352906468808, 0.9792652584763244, 0.9720928164106574, 0.9784276791896509, 0.9845447427297891, 0.9794305058998994, 0.980757320129948, 0.9815473460557548, 0.9751968083835175, 0.9813409825107767, 0.558296466633303, 0.7128427313748389, 0.14289590877005232, 0.15174375946268615, 0.6744461747659073, 0.15180453655066461, 0.5722159799380551, 0.6922072495335887, 0.6949047377617875, 0.7295965157936549, 0.843672175032177, 0.8356855080852816, 0.19080155148330025, 0.27974868117628393, 0.3745887372629476, 0.7991170135990784, 0.2438535068228488, 0.22120034302936342, 0.22121093799968217, 0.2940147983551902, 0.306763667414338, 0.12736925266368038, 0.2485306451021032, 0.10285992279001854, 0.13184275458393946, 0.11992124048383246, 0.3217226030224085, 0.22055397191181458, 0.23813264043186055, 0.26699241048935773, 0.20514116344130395, 0.27791245146728194, 0.3267331371201556, 0.10309431583328821, 0.2536963206351964, 0.2978264543468243, 0.034222173859465355, 9.999999999998899e-05, 0.0858782637433887, 9.999999999998899e-05, 0.042512658139384096, 0.00017518682847783573, 9.999999999998899e-05, 0.003695483052496118, 0.0005066750725353231, 0.04234969115523257, 0.1982257608088125, 0.06695512368737688, 0.023210366273151872, 0.03170530597826582, 0.017495289109142553, 0.08829250577700076, 0.13581716808754485, 0.039067753115236914, 0.10935086034748454, 0.27348593816282407, 0.12657683071449732, 0.07971062732410206, 0.1421010039094348, 0.08833214874220108, 0.1643415391856874, 0.13236444522362367, 0.06854897375475444, 9.999999999998899e-05, 0.14374204651963884, 0.041987736665264674, 0.05360677806455716, 0.20979841859256942, 0.03817243898832223, 0.07872335200875691, 0.08006448509724795, 0.13149580688849727, 0.5030619285693858, 0.563871302251709, 0.548985396421293, 0.5274624887067692, 0.5980870679654439, 0.5490500369563329, 0.5963187406793637, 0.5626130201549658, 0.6512221794165003, 0.09024474802791138, 0.15072617449008086, 0.11586888467879708, 0.1431742365872236, 0.12825884638787777, 0.13787731798607672, 0.16408971793421, 0.1077887320593307, 0.17913716491403242, 0.21927362638530845, 0.18761428590906393, 0.6748858951991014, 0.43549967821021385, 0.26526371748866984, 0.18898811254940895, 0.37300824043607383, 0.34763079714866696, 0.19146102098231987, 0.3135027580816443, 0.5579533792267523, 0.4124004530900123, 0.32949315363960574, 0.5967316655517148, 0.3491363173916082, 0.5273510662475311, 0.6385211077357751, 0.3769338095818042, 0.17430115791286593, 0.20340593808951912, 0.1718473282930827, 0.221152107222907, 0.22216335135592913, 0.24619992671835944, 0.20626928046806614, 0.18854313831229508, 0.31930761239533656, 0.20500651721477192, 0.20634940419985948, 0.20106040318353058, 0.2135281973313089, 0.23039889667497693, 0.21748165967214605, 0.20260511448020724, 0.22203811916689253, 0.20920479815576543, 0.6654255288934815, 0.22349773329248956, 0.17458083357483212, 0.23953827387083604, 0.20598513932179308, 0.17870231652152047, 0.6189409194062649, 0.7251986289891965, 0.1763410574072144, 0.8617502602743096, 0.920402560026976, 0.9082799459914086, 0.16652613227975122, 0.855340459857587, 0.16665988529749232, 0.18645924136366798, 0.8651677771414354, 0.8765428239524544, 0.6661723546961571, 0.7592845871137145, 0.17229782519580727, 0.2084772858988274, 0.21143190065732964, 0.210208974148409, 0.18471101664630563, 0.7853796159078676, 0.8211089751240922, 0.1664801613267629, 0.1869043284105515, 0.20176838484774884, 0.1835658588622774, 0.18492532559826336, 0.1799196480496914, 0.18345161304063828, 0.1823767319202324, 0.17758934088500378, 0.08627526094045279, 0.08724586203379492, 0.10199137364472266, 0.0909001423630843, 0.08805425467476302, 0.08350180512489713, 0.09250194790044874, 0.11662038460160984, 0.14252680752176716]}, "mutation_prompt": null}
{"id": "e509b97b-792a-4118-a0ff-78bbf2f57a3e", "solution": "import numpy as np\n\nclass EnhancedMultiStrategyOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 9)  # Slightly adjusted population size for better exploration\n        self.inertia_weight = 0.3 + np.random.rand() * 0.4  # Tweaked inertia weight range for improved balance\n        self.cognitive_coeff = 0.5 + np.random.rand() * 0.9  # Adjusted cognitive coefficient for optimization\n        self.social_coeff = 1.2 + np.random.rand() * 0.7  # Altered social coefficient for synergy\n        self.F = 0.3 + np.random.rand() * 0.3  # Slightly modified scaling factor range\n        self.CR = 0.8  # Changed crossover probability for diversity maintenance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.1, 0.1, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 8)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedMultiStrategyOptimizer", "description": "An enhanced multi-strategy optimizer combining adaptive differential evolution, elite-guided particle swarm, and adaptive learning for robust black box optimization.", "configspace": "", "generation": 94, "fitness": 0.3192382363576891, "feedback": "The algorithm EnhancedMultiStrategyOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.28.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.799442438003873, 0.8433704463709788, 0.8472796853528908, 0.758726186679771, 0.8497834214768848, 0.8434957333159583, 0.8090904161019913, 0.8664704019802528, 0.8358601307913109, 0.03760460307895286, 0.5176438487536215, 0.6313858572799058, 0.5341510889680425, 0.6674688125031703, 0.5839430905281219, 0.5663562680758962, 0.6653991494244448, 0.6185007428196685, 0.10776161477718071, 0.15268937316082687, 0.07603952574064388, 0.07232178501048547, 0.15247121702558597, 0.11980306470569102, 0.14226330986182256, 0.18137783245266004, 0.10882511905461556, 0.09145582460542223, 0.10622332811644841, 0.12811876537749012, 0.13718037612164358, 0.07958374468297136, 0.11794973252620333, 0.13778019219459425, 0.14251251766904405, 0.11352278652732917, 0.9809884780080022, 0.9732312794691094, 0.9789557993372329, 0.9845286088216657, 0.980231085564866, 0.980750304972837, 0.9815844496531267, 0.9809903261142642, 0.9813837670451119, 0.5847648983153415, 0.7024929833097947, 0.686126048086086, 0.15098029746681219, 0.15152843311737285, 0.15313499868437297, 0.5780160694377249, 0.7007848422306282, 0.6732717113330093, 0.2261266602927411, 0.2253466149713057, 0.854239815299985, 0.20825096250962194, 0.37425108103223514, 0.20419816454418194, 0.14872306828554882, 0.8715749389725043, 0.12346081762756878, 0.2259335962937984, 0.3052445451492234, 0.2906056826862624, 0.10801169788687837, 0.253356460303483, 0.3460180774059116, 0.12703341667991952, 0.30576295799564845, 0.3140693184674249, 0.22811834593608216, 0.2555671169004906, 0.2899414770505304, 0.1294270696049774, 0.2794990936345927, 0.3990950560372035, 0.13278424961319657, 0.28032068166419577, 0.31489321670267234, 0.040559729576224, 9.999999999998899e-05, 0.0420904805654565, 0.02678505762470884, 0.014044291057411451, 9.999999999998899e-05, 9.999999999998899e-05, 0.0027470751628440038, 0.00487062488700285, 0.04161541228095533, 0.09111854930240626, 0.08226848558313826, 0.03407094804617716, 0.017817691760757426, 9.999999999998899e-05, 0.060473988611742024, 0.15471039290175703, 0.052863188129923966, 0.04349615972346654, 0.36407892018854604, 0.1189748819500388, 0.09164001048045933, 0.10818440568497134, 0.176342416155313, 0.11759349679074316, 0.06743524887896679, 0.10313757775642607, 0.039999716494874105, 9.999999999998899e-05, 0.1458884984455664, 0.06761061092131071, 0.1655795905896733, 0.03889543004624352, 0.17122226369626148, 0.08141576421480201, 0.0475588139025942, 0.5634661235494807, 0.5387375119917958, 0.5376651947158754, 0.5412726482460817, 0.6117263062858985, 0.6009177612580551, 0.5635893879438358, 0.6009547318055724, 0.5926284936102035, 0.1005038410942316, 0.11362442880781032, 0.07192783160933991, 0.08988463429407934, 0.0764641620640999, 0.17738886818682387, 0.1498963728148539, 0.13596119285570152, 0.1287292256346909, 0.23949165078996504, 0.37339219377574295, 0.18565110870613788, 0.4073348320009823, 0.15026681792697583, 0.2073248659158079, 0.23634358702512248, 0.35878056534067515, 0.29229169352493745, 0.3992808560456471, 0.28359813509420817, 0.4459355503992404, 0.45088715357225084, 0.20521573251564018, 0.5411160125621952, 0.4843620818903043, 0.5556257906952361, 0.2877813021022989, 0.17736561691204256, 0.21745871186593102, 0.19286196213212015, 0.27020569252773685, 0.18660076748196142, 0.3567683173419358, 0.14490402576852934, 0.24140711910012447, 0.1385518116937121, 0.20513405268656193, 0.2259620444166337, 0.20272607105119267, 0.23558382423004764, 0.2325501764018455, 0.20481548105153546, 0.18561920385218866, 0.24139742977188394, 0.233002753266497, 0.6063409212425594, 0.23608218873817766, 0.19794836687748218, 0.20310170921214898, 0.20865391448007353, 0.2091093015846317, 0.19989042261646228, 0.20826701863972397, 0.24672432101837127, 0.8465137323065357, 0.906433892122254, 0.9054333861820689, 0.16559345094982092, 0.8526617556300353, 0.16548124014197074, 0.16254144405088922, 0.17012004708681838, 0.16085859730903884, 0.6862736453016967, 0.7656808133563504, 0.8448377797653144, 0.20722001023172765, 0.21128373276657098, 0.21051934262859617, 0.8078694089908568, 0.828084939529627, 0.8691601692555465, 0.1814015762156006, 0.21188511979169666, 0.17761781667310772, 0.17819978568914707, 0.1909269386573853, 0.1817521795007071, 0.17622895201880806, 0.1868921049792266, 0.18022877571639928, 0.08156412869236374, 0.09818945050192429, 0.09167722107547238, 0.0907917009506386, 0.09819408007275743, 0.10080358459876038, 0.09101445091221849, 0.14401115117086483, 0.1334200587814457]}, "mutation_prompt": null}
{"id": "b36b263d-f02d-4b72-bdf7-7c735c5b662f", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 8)  # Increased population size for better exploration\n        self.inertia_weight = 0.1 + np.random.rand() * 0.6  # Broadened inertia weight range for dynamic balance\n        self.cognitive_coeff = 0.8 + np.random.rand() * 0.7  # Adjusted cognitive coefficient for adaptability\n        self.social_coeff = 1.0 + np.random.rand() * 0.9  # Extended social coefficient for enhanced synergy\n        self.F = 0.3 + np.random.rand() * 0.3  # Broadened stochastic scaling factor range\n        self.CR = 0.8  # Slightly increased crossover probability for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Increased velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 6)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Adjusted elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer that incorporates adaptive differential evolution and elite-guided particle swarm optimization with a focus on improved diversity and convergence rate.", "configspace": "", "generation": 95, "fitness": 0.34567737486412226, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.29.", "error": "", "parent_id": "3ad2d485-56ca-4074-ba77-98c575a06a61", "metadata": {"aucs": [0.8002528401383174, 0.8597653608194895, 0.8434979996160936, 0.8016031842691727, 0.8521945269316393, 0.8389164344759956, 0.8198605079393695, 0.861664057866535, 0.841901080742378, 0.5542416579103977, 0.6546859935126792, 0.6505686879144682, 0.04320816323337073, 0.6846291089351726, 0.6858960866142587, 0.534073379481385, 0.7008999896006867, 0.6773258518671166, 0.13568052793807273, 0.15497049650150363, 0.10918180663660093, 0.070526431659789, 0.1559507449935641, 0.155792481772694, 0.16034123146831591, 0.15765700925320614, 0.13002598267688392, 0.10537852029516748, 0.12026957784724979, 0.13986608260252165, 0.14392764520060142, 0.15095242910324436, 0.09372075247506195, 0.12479418421609256, 0.10621741453923295, 0.11300747175919346, 0.9767723681959387, 0.9751264093305582, 0.9760222436899644, 0.9776747790603628, 0.9772329607302193, 0.9754496183892551, 0.9777240241983814, 0.9674892702656643, 0.9773879177804619, 0.5912364646737762, 0.7164807370563158, 0.721858410831391, 0.525460598825652, 0.7257761192675325, 0.15076906081710983, 0.5651627263942394, 0.715641338285312, 0.7191340366153551, 0.7724676718057402, 0.22470103285140286, 0.2234780494088059, 0.25890822650191914, 0.1929520011788226, 0.2723578361074065, 0.8262508610552175, 0.8502353587440301, 0.9381497124949282, 0.20612334002620925, 0.2467400523236164, 0.13003918206902654, 0.13068164371418045, 0.2614371568299714, 0.13178476615936052, 0.19253684606681054, 0.23510251281014616, 0.13086308913868894, 0.2350597302014975, 0.26144064324185723, 0.21008303401419504, 0.24386637427392266, 0.255278235469135, 0.285291407515595, 0.1929929804436289, 0.2690037633892244, 0.28990243324213416, 0.0006040331281217393, 0.00010378563633783866, 9.999999999998899e-05, 0.005266016518803873, 0.004268624537906551, 0.016390663702740338, 9.999999999998899e-05, 0.046101442867127806, 0.023578435588135882, 0.08278825052521899, 0.11756213731917453, 0.12701773702379182, 0.06375147555069238, 0.019061588990684997, 0.010383359357530542, 0.02232316295789094, 0.04066691832763081, 0.04375679470950267, 0.14477057936823434, 0.047569358143574436, 0.17056721615274129, 0.10385570279984435, 0.14340099846737053, 0.1301198930611196, 0.09118898528339081, 0.12572345878909308, 0.17905726609790795, 0.12561113216042452, 0.19029642373237965, 0.17805794697760324, 0.17397699505750985, 0.17591156388935447, 0.21994074031077837, 0.22276584115548692, 0.10096538829558233, 0.04879141425730793, 0.5872298238841902, 0.5687284672448497, 0.5857687531666883, 0.5630779832590649, 0.579732643883187, 0.5684097670408625, 0.5340157464452593, 0.5731029322576611, 0.6158305399098294, 0.1080654415834903, 0.13648538408423738, 0.11852950171707399, 0.11067086596332865, 0.12033666255706499, 0.1160900599569803, 0.15871741448834986, 0.11888209622238632, 0.14029411365370104, 0.3084544761231922, 0.24848146590717357, 0.2403235348780247, 0.24155094990740422, 0.48475028801282993, 0.238028026754167, 0.20576635605508609, 0.47908686280466395, 0.18817568311340283, 0.4576695763564498, 0.5939899797106751, 0.3946729011100527, 0.2366992157945641, 0.6416136859546017, 0.5013135165580601, 0.4882025783166033, 0.5461409761100839, 0.42340883693388554, 0.320153781146967, 0.25197950520505297, 0.288756006045633, 0.19066730969862633, 0.2056050897934496, 0.23128875064105825, 0.2457852809583937, 0.22925741277560086, 0.13960512499036248, 0.20371663841914078, 0.20696866082016963, 0.24006199968110442, 0.2011161992831536, 0.22291743298683697, 0.20774187022721102, 0.20990364164431463, 0.22419214249139763, 0.19564199942944416, 0.6421030523187838, 0.7213433687308113, 0.20119886740947768, 0.20258514170858732, 0.20743536058674683, 0.22271760246262695, 0.18856057640339086, 0.20060936240348848, 0.2034753160702638, 0.8784498478564123, 0.9017425222760912, 0.9013425391177471, 0.8530694609023619, 0.19855334739024944, 0.13089211947517365, 0.8274052078655453, 0.8905771063276003, 0.1685658158099097, 0.6970209950081968, 0.819815694151331, 0.8071042329689527, 0.20917794768730247, 0.2110285549770824, 0.21055130995210325, 0.7508635828783484, 0.7980768792257561, 0.8729423090247853, 0.19619894818567518, 0.1886292520721039, 0.1749337254421216, 0.1803526652174069, 0.19034679744961558, 0.18854964415875386, 0.18959440422523555, 0.18159047784427285, 0.17615126764568323, 0.09452042854468623, 0.09338108429925995, 0.09151822091621686, 0.11938041876541938, 0.08392150005867738, 0.09119015833515043, 0.09131280295451782, 0.14586356558229185, 0.12404547497367457]}, "mutation_prompt": null}
{"id": "6062b130-c8b2-46c7-8ddc-148a8f8cbd15", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(50, budget // 10)  # Adjusted population size for balanced exploration-exploitation\n        self.inertia_weight = 0.2 + np.random.rand() * 0.5  # Narrowed inertia weight range for increased stability\n        self.cognitive_coeff = 0.9 + np.random.rand() * 0.6  # Improved cognitive coefficient for adaptation\n        self.social_coeff = 1.1 + np.random.rand() * 0.8  # Enhanced social coefficient for synergy\n        self.F = 0.4 + np.random.rand() * 0.2  # Tweaked scaling factor range for refined mutation\n        self.CR = 0.7  # Reduced crossover probability for focused diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Expanded velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                        \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 5)]  # Adjusted elite group size\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.4 * r3 * (elite_partner - positions[i]))  # Adjusted elite impact\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "A refined hybrid optimizer that synergizes adaptive differential evolution with an elite-centric, inertia-modulated particle swarm strategy for robust exploration and convergence.", "configspace": "", "generation": 96, "fitness": 0.3364600648448206, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "b36b263d-f02d-4b72-bdf7-7c735c5b662f", "metadata": {"aucs": [0.7992605156139408, 0.869950523994115, 0.8510284893179801, 0.8104587781666769, 0.8573587541943359, 0.861378242319516, 0.812583037630019, 0.8624020278912381, 0.8562645020068488, 0.6102172971274399, 0.6775772215357714, 0.6692488283879914, 0.5719596635870869, 0.68977347698069, 0.6854813944519067, 0.5741487331933481, 0.7110309547698315, 0.6609262275023116, 0.1471874154646483, 0.17459106039530492, 0.13773010580336742, 0.11520819866828591, 0.10915688330160378, 0.07178909876501605, 0.15081531332617015, 0.12332037444912458, 0.15227511596133703, 0.13533022943755257, 0.1130230569156071, 0.11156674906933717, 0.11008265060055966, 0.12659530417661158, 0.17096773944674737, 0.13033628578109657, 0.14901765740961692, 0.14892310870759828, 0.9776425701902228, 0.9772779766779545, 0.9790924487693942, 0.977819563833213, 0.9671801403435599, 0.9776945980197038, 0.9815151372436535, 0.9733803483467567, 0.9812684062789778, 0.6213858495286105, 0.7170633826290658, 0.7180710958591401, 0.6258899800703723, 0.6952174837207028, 0.7267842275332757, 0.571047831311317, 0.743988004403772, 0.716743465840379, 0.21027841348066312, 0.15648097198300293, 0.22725329595644572, 0.34192442406200985, 0.1927333116679072, 0.16150599197417637, 0.2198675135043786, 0.23581759345053965, 0.23338337179607438, 0.308401183534435, 0.25525587794384696, 0.25638142172395195, 0.1269164127946697, 0.24911066742067078, 0.12848616542416547, 0.12880746784820418, 0.1309389216638016, 0.37536776039779585, 0.22061767568392954, 0.2583155698214866, 0.2577451544812627, 0.24043297523454754, 0.29821669939631346, 0.2831200492992654, 0.24462150578338004, 0.12872675837919578, 0.28459015056704573, 0.046382554628067174, 0.11970008598667681, 0.006620830766486896, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0025985678052365957, 0.004042738332428075, 0.06527059404119373, 0.1735039616683185, 0.029569530769605445, 0.0523390339528913, 0.06615855200217413, 0.024117535163412307, 0.12949290234352606, 0.0939687460117895, 0.10278038442103155, 0.04301203155925304, 0.07581034118840235, 0.04698916647967033, 0.08414574391732821, 0.2677018044808359, 0.0776807982508897, 0.06356489757155359, 0.08924880863874018, 0.08648717256595029, 0.13741633984515667, 0.1546995274283588, 0.18729505947222236, 0.3906884836199691, 0.17193470257244992, 0.13937919394286313, 0.1737251182984959, 0.09081292808149866, 0.16525937485571962, 0.5732290610964081, 0.5786930074545659, 0.5487295795148296, 0.5598414811918071, 0.553517384537574, 0.5589776528405804, 0.552446278814626, 0.5473079253539022, 0.5901286332654505, 0.10650567254606846, 0.1424161788375563, 0.10759726264798153, 0.13189705819981568, 0.1292715454907899, 0.14878396281557704, 0.1303361609498308, 0.10555621889837352, 0.15527672978135398, 0.18639449531204944, 0.1804996262160823, 0.31869950617047194, 0.32941621689845413, 0.26394780585225996, 0.20779517165988437, 0.23818782309700892, 0.41583762561106186, 0.2892891527553566, 0.40753996805392056, 0.5858934130978163, 0.3956151717082498, 0.48171883526875015, 0.4347864316345216, 0.25959001812905336, 0.4350961014310196, 0.6701464747830237, 0.6818147488660506, 0.24557754740725501, 0.2572039998313418, 0.23117305399898447, 0.2631989390762164, 0.2554410310047368, 0.2200425422765956, 0.12449140730030284, 0.16616708971103822, 0.15633393189470612, 0.18847585991775306, 0.2076384973337625, 0.23026661999587938, 0.22567711056989614, 0.3026280974904545, 0.23314537450053507, 0.22624746474916835, 0.23900885869783195, 0.24675878236371918, 0.2386764180842884, 0.6704950989352367, 0.205367825022847, 0.22019304673491813, 0.20824776008620616, 0.22114466029911084, 0.23218724956312398, 0.23966012500924272, 0.20805485899855336, 0.8883437506125835, 0.9079127387093574, 0.9055599655053395, 0.1663276962681497, 0.16673594101468903, 0.16621599621967453, 0.1458275048789126, 0.8810394563948195, 0.16453153291754985, 0.8035129255061995, 0.8673922822616538, 0.8214406572600532, 0.21071310913506114, 0.21255354736031007, 0.8192608603090518, 0.6613032213717311, 0.7454383424959284, 0.8158838494948178, 0.1788186400667542, 0.1860340037601136, 0.2027398026062247, 0.2021672370133819, 0.18515760884752686, 0.18578679297304923, 0.18251274353241176, 0.1802085350075615, 0.18816716191430516, 0.09508125042375182, 0.09771263577142031, 0.09961746612349676, 0.11393478068950402, 0.08974383918892159, 0.10521286938308572, 0.11544894003640693, 0.084788169631979, 0.1098421772735797]}, "mutation_prompt": null}
{"id": "afca734a-dfa8-4bdc-8494-4a151c5221a6", "solution": "import numpy as np\n\nclass NovelStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 8)\n        self.inertia_weight = 0.1 + np.random.rand() * 0.6\n        self.cognitive_coeff = 0.5 + np.random.rand() * 0.9  # Altered cognitive coefficient for flexible adaptation\n        self.social_coeff = 0.9 + np.random.rand() * 0.8  # Adjusted social coefficient for cooperative behavior\n        self.F = 0.4 + np.random.rand() * 0.2  # Modified scaling factor range for dynamic balance\n        self.CR = 0.7 + np.random.rand() * 0.2  # Dynamic crossover probability for adaptive diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.3, 0.3, (self.population_size, self.dim))  # Extended velocity range\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(2, self.population_size // 5)]  # Slightly larger elite group\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.6 * r3 * (elite_partner - positions[i]))  # Tweaked elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "NovelStochasticHybridOptimizer", "description": "A novel stochastic hybrid optimizer leveraging dynamic parameter tuning and multi-modal search exploration for enhanced optimization performance.", "configspace": "", "generation": 97, "fitness": 0.3486499117995756, "feedback": "The algorithm NovelStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.28.", "error": "", "parent_id": "b36b263d-f02d-4b72-bdf7-7c735c5b662f", "metadata": {"aucs": [0.8289830055442025, 0.8619636394708197, 0.8643293202429017, 0.811168681507146, 0.8554856263666315, 0.852973647333927, 0.8228311910944315, 0.8666893153441745, 0.8660442448518962, 0.5416271857410042, 0.6656575038582313, 0.6732329821665454, 0.6048584031460513, 0.7055504119123405, 0.6855958805528085, 0.6137313961593598, 0.6796042023572051, 0.7114704351063839, 0.1610757234203728, 0.1557140342875737, 0.12828327517373017, 0.1668339910312988, 0.1515679134035154, 0.6807921898041981, 0.1567814227708333, 0.14944918522528294, 0.15399056657546684, 0.10919290173749563, 0.1191348527034144, 0.09415395354576084, 0.10338052161356626, 0.11208282793340929, 0.10613198035600668, 0.12787178839068114, 0.10662994214380139, 0.11202787187797403, 0.9873312363583924, 0.9702019557208955, 0.9773329347124626, 0.9775111972587492, 0.9671126571927775, 0.9752242560372872, 0.9736459777730929, 0.9669845259759196, 0.9755331457491695, 0.6540667710589929, 0.7306003828307823, 0.7694116439077918, 0.649148622073389, 0.7561764817667243, 0.7712059516211067, 0.6063151874587407, 0.7456698420262375, 0.08861384324587729, 0.8051559762386119, 0.22195552900382876, 0.2259176688290654, 0.3728949292744529, 0.3721351454815969, 0.21286996070301534, 0.22476067837066027, 0.23205255879018039, 0.24061373628143423, 0.23012038006943447, 0.21384373899570297, 0.27023639003458944, 0.21689658661513955, 0.21609856361137458, 0.3179998200276054, 0.21812538623062605, 0.3800927535696321, 0.28248320923510806, 0.2283911284129444, 0.19804676931887344, 0.2830589374635709, 0.12800599385049938, 0.26465241968318254, 0.3059982154377713, 0.10214526767644072, 0.24993900581005546, 0.12840311927059522, 0.00639906048140515, 0.001557214801799045, 0.05132993805282571, 0.11861445929295711, 0.057437689806177916, 9.999999999998899e-05, 0.057290484324892366, 9.999999999998899e-05, 0.002302730020969701, 0.07225223907810197, 0.08607169289723737, 0.050067613551952994, 0.10077493321650854, 0.03332352315492393, 0.02287126008307272, 0.1353863257875908, 0.07237361570207634, 0.11141808451273572, 0.11575132606059124, 0.1808565334368052, 0.18171771754580723, 0.13926216704470062, 0.1021868567444506, 0.16172301884494278, 0.13118200312883332, 0.10365469765572799, 0.156009880516204, 0.24079190370762948, 0.18042663391383085, 0.21820015812186233, 0.07892373023906352, 0.20079406812497125, 0.21720809741087677, 0.08716384799149823, 0.15436678979075036, 0.0811911537722757, 0.5388843034698332, 0.5285342942010813, 0.5755437935573882, 0.5713498599734796, 0.5908432581967635, 0.5859769483792203, 0.5655520281926449, 0.6740451443988729, 0.589332290342583, 0.10983646906789468, 0.1091835026567527, 0.14204300767102085, 0.16244661858117493, 0.10568008329272294, 0.14038369753012847, 0.1679316454758042, 0.15023381693675342, 0.10707525952047015, 0.4648243008061266, 0.2022288691389007, 0.33674792325156233, 0.5445601115298495, 0.17981827858932287, 0.24496085934006062, 0.14788643198109475, 0.2571073379408507, 0.25269714234915486, 0.5658175524169118, 0.3624078972296386, 0.3674564223264368, 0.5579826387734201, 0.6477565913544974, 0.6012074346727057, 0.5531281143234723, 0.6729667374908219, 0.5874111917064648, 0.2914715129528501, 0.3470063453607676, 0.40387177247299155, 0.3315011714957776, 0.21566172931766892, 0.20714294934340138, 0.16509741979867665, 0.19777713365597072, 0.14744871158144812, 0.20007677950371983, 0.22049176651536373, 0.232464225077883, 0.22130676652148817, 0.21539806257650795, 0.25208119884793434, 0.2001012637009668, 0.22684730819404897, 0.23742387288240407, 0.19923893940346526, 0.7623952260573994, 0.1910374416356735, 0.20945300325391636, 0.24179482372843775, 0.1918974361657927, 0.21766172738463385, 0.2226574734155442, 0.18369359806862562, 0.8819389483577691, 0.9170923961586658, 0.9190161586883576, 0.8730179504652195, 0.146741059498245, 0.9137479370566224, 0.17762460124115764, 0.17695636998862974, 0.17745969621593471, 0.8052134180649204, 0.8356985152241605, 0.8152287770751465, 0.21005402389688255, 0.21112240855561848, 0.21062558952113608, 0.2100935992978692, 0.8341948037715503, 0.8601928422872777, 0.16917219428112307, 0.1884839415302083, 0.17913600694188936, 0.2018454423595868, 0.19407650927965037, 0.181623502515043, 0.1952122717134389, 0.214203347390036, 0.18642916611930227, 0.08663100875347862, 0.09625692431178778, 0.08891347381957893, 0.09753327600194495, 0.11205214151285325, 0.09479543596419882, 0.10763595818727845, 0.12715687366873352, 0.1134089187929439]}, "mutation_prompt": null}
{"id": "bc3a7519-9c57-48cf-87a0-3d3dc1a3b976", "solution": "import numpy as np\n\nclass AdvancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 7)\n        self.inertia_weight = 0.2 + np.random.rand() * 0.5\n        self.cognitive_coeff = 0.4 + np.random.rand() * 1.0\n        self.social_coeff = 0.8 + np.random.rand() * 0.9\n        self.F = 0.5 + np.random.rand() * 0.3\n        self.CR = 0.6 + np.random.rand() * 0.3\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.4, 0.4, (self.population_size, self.dim))\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 6)]\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))\n                positions[i] += velocities[i]\n                \n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "AdvancedStochasticHybridOptimizer", "description": "An advanced stochastic hybrid optimizer with enhanced parameter tuning and elite exploitation, integrating adaptive differential evolution and modified inertia dynamics.", "configspace": "", "generation": 98, "fitness": 0.33874328934956527, "feedback": "The algorithm AdvancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.28.", "error": "", "parent_id": "afca734a-dfa8-4bdc-8494-4a151c5221a6", "metadata": {"aucs": [0.8100025528793102, 0.8530122913020721, 0.854577106991969, 0.8088724670328606, 0.8541262753340174, 0.8331135455145141, 0.8054915292588938, 0.8557668090578033, 0.8436622842915327, 0.5893892890148158, 0.6615886920804839, 0.6335964336941768, 0.5858480797748542, 0.6854638540270992, 0.6234733926905917, 0.5723032345966442, 0.6711436840332159, 0.6474243799078094, 0.5174065551660012, 0.5137893779947951, 0.15606428843911313, 0.16304674867452518, 0.12653655626430171, 0.14095947619390203, 0.11213310581043134, 0.17783450270378798, 0.18036606606211403, 0.13328007287490895, 0.1119203186849409, 0.11293500230874542, 0.10061606079313024, 0.10614757986397094, 0.10206834591164748, 0.1062931851858201, 0.11031616030389613, 0.15232330689692264, 0.9868619482803019, 0.977189776371255, 0.986788383357408, 0.9776380964881539, 0.9662688004197759, 0.9753674925675604, 0.9768111915936362, 0.9720697534284717, 0.9767829839576514, 0.6164999897149295, 0.7386998841252521, 0.7648859140901014, 0.14902871665846618, 0.7339921712028641, 0.22366123913006708, 0.6323592620423998, 0.7233636454744203, 0.08924238320516398, 0.7802527248372586, 0.2083357976579936, 0.21778089582997529, 0.8180277449325858, 0.19132115153761953, 0.21166235722754623, 0.22758079867281578, 0.23329951079135858, 0.2157566939875043, 0.12310730397339142, 0.26126936301951487, 0.33490117579190937, 0.12661936725635314, 0.2219421331823137, 0.3085933042807617, 0.24797944746991618, 0.12921273660974164, 0.12925589211449384, 0.2348436337593809, 0.1970803336453565, 0.288279273757845, 0.24908551565860115, 0.2536622003911361, 0.30308666234779913, 0.034350671563928015, 0.22092284892438707, 0.3172836216281395, 0.054890516784341536, 0.19902640937353266, 0.00590408442487933, 9.999999999998899e-05, 0.008314511790332269, 0.09800705060571713, 0.00627280577747602, 0.01760742619870248, 0.060184684143821165, 0.06362207860596503, 0.13874519240405592, 0.030885745289815136, 0.021630098133209485, 0.06242574536297907, 0.013497450366938057, 0.057133060684770864, 0.07609578283669671, 0.11771994268029262, 0.14363244365684202, 0.04707877662560145, 0.335801738891093, 0.17746708420155988, 0.10003432255943556, 0.1763216954818725, 0.10502759919921223, 0.07057774701296327, 0.09275256746385896, 0.09408036619433091, 0.16684899198218117, 0.15203704676183993, 0.3403300789379208, 0.09577791825024984, 0.2674191537805495, 0.05459419780435859, 0.1541987512841395, 0.0549108092997852, 0.5696521572865925, 0.5197031235151652, 0.585073390299333, 0.590718537944836, 0.5706123256991946, 0.5687395880926565, 0.5425554987136336, 0.5821675513132902, 0.6022271127708381, 0.15535468092131943, 0.15234725239377733, 0.11252862962535293, 0.12407917381569844, 0.1793675092237067, 0.1065100863390086, 0.10025166475178426, 0.17239114696031121, 0.09330881951727699, 0.19862780364668198, 0.4564873987684167, 0.20304085697925178, 0.14523185776452097, 0.3236621506476466, 0.2587239429288134, 0.20431372563026207, 0.15432223458613137, 0.25047240606886967, 0.5218979896480779, 0.36064902971662227, 0.47354336833585997, 0.5332800659219219, 0.5504855785400875, 0.5860015159448891, 0.48008940826271096, 0.6523418590413941, 0.5697271913646522, 0.2173165356268637, 0.30714893995351655, 0.29665997130662913, 0.20539107081787633, 0.24543179503421486, 0.2103410350008873, 0.2764188317632842, 0.18448738856042068, 0.27433801356966203, 0.2146387154498911, 0.2153841216848036, 0.2088637027869754, 0.18387000692896704, 0.2314729523596869, 0.23736587936757547, 0.20129943069044165, 0.21848341008721928, 0.20212538441200112, 0.20632741270357935, 0.21825736550978114, 0.19074168099814737, 0.6372437521765217, 0.2251969582881247, 0.18912861110245605, 0.2423872559973973, 0.21780879093237637, 0.22557543742027863, 0.8710025212695162, 0.9092913992775286, 0.902110802411641, 0.15679647197601754, 0.9004880736387357, 0.16031272451934797, 0.8783245407731813, 0.16806337805193983, 0.8923250260245219, 0.7892226040108424, 0.8494216675042605, 0.8929321629531128, 0.20759295267029287, 0.20975191370863744, 0.210064185488272, 0.20674645912871714, 0.20952392817389753, 0.8729768742140823, 0.18378631666335532, 0.2063654167904142, 0.18770189440240936, 0.18340437337409998, 0.18826508474328696, 0.1967566683586297, 0.18125474569678113, 0.18440374136941207, 0.17534112034483718, 0.09088539671003548, 0.09949611376126899, 0.1084214521825887, 0.09830190534650662, 0.091352008448491, 0.08667425170978926, 0.10757322472332376, 0.10965736015907168, 0.1409193759926466]}, "mutation_prompt": null}
{"id": "6d481e95-a7cc-4d50-82a1-3946d22f826b", "solution": "import numpy as np\n\nclass EnhancedStochasticHybridOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.population_size = min(60, budget // 8)\n        self.inertia_weight = 0.2 + np.random.rand() * 0.5  # Adjusted for refined control\n        self.cognitive_coeff = 0.6 + np.random.rand() * 0.8  # Fine-tuned cognitive coefficient\n        self.social_coeff = 0.8 + np.random.rand() * 0.9  # Broadened social coefficient for enhanced cooperation\n        self.F = 0.3 + np.random.rand() * 0.3  # Modified scaling factor range\n        self.CR = 0.6 + np.random.rand() * 0.3  # Refined crossover probability\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.best_position = None\n        self.best_value = float('inf')\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        velocities = np.random.uniform(-0.2, 0.2, (self.population_size, self.dim))  # Narrowed velocity range for stability\n        personal_best_positions = np.copy(positions)\n        personal_best_values = np.array([func(pos) for pos in personal_best_positions])\n        global_best_index = np.argmin(personal_best_values)\n        global_best_position = personal_best_positions[global_best_index]\n        global_best_value = personal_best_values[global_best_index]\n\n        evaluations = self.population_size\n\n        while evaluations < self.budget:\n            for i in range(self.population_size):\n                # Differential Evolution Mutation and Crossover\n                indices = [index for index in range(self.population_size) if index != i]\n                a, b, c = np.random.choice(indices, 3, replace=False)\n                mutant_vector = positions[a] + self.F * (positions[b] - positions[c])\n                mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                trial_vector = np.copy(positions[i])\n                \n                for j in range(self.dim):\n                    if np.random.rand() < self.CR:\n                        trial_vector[j] = mutant_vector[j]\n                \n                trial_value = func(trial_vector)\n                evaluations += 1\n                \n                if trial_value < personal_best_values[i]:\n                    personal_best_positions[i] = trial_vector\n                    personal_best_values[i] = trial_value\n                    \n                    if trial_value < global_best_value:\n                        global_best_position = trial_vector\n                        global_best_value = trial_value\n            \n            # Particle Swarm Optimization update with elite information sharing\n            elite_indices = np.argsort(personal_best_values)[:max(3, self.population_size // 4)]  # Enlarged elite group\n            elite_positions = personal_best_positions[elite_indices]\n            for i in range(self.population_size):\n                elite_partner = elite_positions[np.random.choice(len(elite_positions))]\n                r1, r2, r3 = np.random.rand(self.dim), np.random.rand(self.dim), np.random.rand(self.dim)\n                velocities[i] = (self.inertia_weight * velocities[i] +\n                                self.cognitive_coeff * r1 * (personal_best_positions[i] - positions[i]) +\n                                self.social_coeff * r2 * (global_best_position - positions[i]) +\n                                0.5 * r3 * (elite_partner - positions[i]))  # Balanced elite partner influence\n                positions[i] += velocities[i]\n                \n                # Adaptive boundary handling\n                positions = np.clip(positions, self.lower_bound, self.upper_bound)\n                \n                current_value = func(positions[i])\n                evaluations += 1\n                \n                if current_value < personal_best_values[i]:\n                    personal_best_positions[i] = positions[i]\n                    personal_best_values[i] = current_value\n                    \n                    if current_value < global_best_value:\n                        global_best_position = positions[i]\n                        global_best_value = current_value\n\n        self.best_position = global_best_position\n        self.best_value = global_best_value\n        return self.best_position, self.best_value", "name": "EnhancedStochasticHybridOptimizer", "description": "An enhanced stochastic hybrid optimizer with improved dynamic adjustments and cooperative interaction strategies for robust performance.", "configspace": "", "generation": 99, "fitness": 0.33576116277117396, "feedback": "The algorithm EnhancedStochasticHybridOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.27.", "error": "", "parent_id": "afca734a-dfa8-4bdc-8494-4a151c5221a6", "metadata": {"aucs": [0.7977863481467603, 0.8535181946210353, 0.8473178606922694, 0.8062627289287182, 0.8415236123834641, 0.8324722660356401, 0.8017389994750457, 0.8618306917768066, 0.8492623944995992, 0.5637194303715886, 0.6587091745534883, 0.6503143832135083, 0.5655960983952182, 0.6484683836393613, 0.6450239822669812, 0.6071156959983024, 0.6795996212613761, 0.6668047757935145, 0.14845570451995738, 0.17282139234382599, 0.15347609482954272, 0.14915791007733892, 0.11098331325456579, 0.1200691123662716, 0.16353619544152476, 0.17709684353579047, 0.11878451319022676, 0.1112607012114224, 0.12637602605802878, 0.11529440193530949, 0.12723112717063978, 0.15245943842932352, 0.08992383475594401, 0.1099583050315196, 0.12610424070455706, 0.12469581045317502, 0.9759633529940915, 0.9767738004553185, 0.9744868143116893, 0.9762885797863495, 0.9634255863474709, 0.9755048377161212, 0.977091852061211, 0.9564293320147623, 0.9753200226171155, 0.6290669887350013, 0.7148857670969644, 0.7325766266434848, 0.6104593718688751, 0.7119714402538957, 0.7302980395839942, 0.6072850263405873, 0.6992273295145897, 0.7198570220119864, 0.3668910757193232, 0.3746269216078172, 0.3842337420599651, 0.1904719163627716, 0.27665962773887753, 0.21235309611001785, 0.17516089656110867, 0.8529705783387895, 0.23342447516872766, 0.24874089663910637, 0.2214908197177886, 0.28019541113490143, 0.2165056284292589, 0.1163724598607383, 0.13080091784200087, 0.23314050749593918, 0.1980208553782059, 0.2844453141147193, 0.2316002513178007, 0.214855060456819, 0.26891043310657314, 0.23778207548983055, 0.2617073663278694, 0.2945247733259607, 0.2434186109194184, 0.2637803582691398, 0.29517669494582066, 0.06767175903349276, 0.03987260608224952, 0.04247623639332154, 0.0013597904306638098, 9.999999999998899e-05, 0.062197425101406356, 0.07980045553111104, 9.999999999998899e-05, 0.08224033756704807, 0.03225782718389836, 0.24100523506003657, 0.04430820128681112, 0.01972252736246516, 0.04010552768828457, 0.06259822853866903, 0.06234658191144171, 0.07242316367894486, 0.10432885265277492, 0.14627863185001844, 0.04733862131445998, 0.28591861391402507, 0.1894758851398266, 0.10045628935064854, 0.1727625315569672, 0.20312635068571883, 0.06859744777087162, 0.2121532268959746, 0.1641403175199435, 0.13194899349806366, 0.12021789650142567, 0.2594071730322324, 0.11835430626368326, 0.11002208040091555, 0.24275023771513204, 0.07398750386380648, 0.20162899606470597, 0.5126999452217817, 0.563008343139348, 0.5672012751013809, 0.5784677401521189, 0.5806958924819219, 0.5813507131441489, 0.5712831518897136, 0.5834443181869258, 0.6058102258482927, 0.10596786145458159, 0.17706032135948058, 0.10923675885738215, 0.16799222884820642, 0.15326908951794482, 0.1759315032515586, 0.16030646185926967, 0.1529400352178958, 0.12084865182442794, 0.35582660679757405, 0.2190177344520985, 0.26773415417465063, 0.19682656048686908, 0.28330761653095493, 0.21979934752233332, 0.15155961437769383, 0.22724940372648827, 0.24144187038641807, 0.3143484482603902, 0.6095573939946083, 0.5663287333552569, 0.3228964833046841, 0.3033561470690471, 0.5783788122337752, 0.42908589064546976, 0.5780158227738346, 0.5597486769051965, 0.20243739755993873, 0.21097666899834244, 0.412600616247327, 0.23305520517775768, 0.2631448656008393, 0.2522681428394068, 0.36240374750020354, 0.40378388558192646, 0.194486089061768, 0.21924385616213005, 0.22964632689170217, 0.22274247947854242, 0.1889752581878874, 0.21065630481955755, 0.24604533566685882, 0.2267087099802617, 0.21992113223285237, 0.2001881635261289, 0.23569119290406115, 0.194403675942175, 0.18839520503847884, 0.2018999369330935, 0.20526728940420402, 0.18506848062840342, 0.21506692516495096, 0.20016393758637663, 0.18451386287286264, 0.8865148474209961, 0.8950235986281319, 0.9161896839335785, 0.8543683088795692, 0.14689426034418207, 0.17130483661349427, 0.17625769140038705, 0.15407342568418203, 0.16891460264180036, 0.7398200005933707, 0.16872045380310996, 0.8320686861492903, 0.21027875802924956, 0.21160680060055714, 0.21106316767449806, 0.7752638832847533, 0.7910044357961943, 0.8258836960512725, 0.1855144932763203, 0.18291976156430834, 0.20678106329290313, 0.1877292344682765, 0.17066834241502715, 0.17039899019866045, 0.1767552931787605, 0.18033457561027355, 0.18996614075894658, 0.08844778914158802, 0.09531896257346684, 0.09367641855397812, 0.0778791760424059, 0.08364196472816743, 0.08866701671224642, 0.09581992242529291, 0.12808594239456217, 0.09140438637254533]}, "mutation_prompt": null}
