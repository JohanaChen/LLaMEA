{"id": "b224533e-973f-4a97-a1dc-5e3cb48154af", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # typically 5-10 times dimensionality\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.5  # initial mutation factor\n        self.crossover_rate = 0.7  # initial crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n        best_idx = None\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with a self-adaptive mutation factor\n                F = self.mutation_factor + np.random.rand() * (1.0 - self.mutation_factor)\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with a self-adaptive crossover rate\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution variant with adaptive mutation and crossover strategies fine-tuned for diverse problem landscapes.", "configspace": "", "generation": 0, "fitness": 0.25474205719287035, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6929852146809926, 0.6817626860461269, 0.7054265341432968, 0.7250244520635813, 0.7182671653456978, 0.7070746033566726, 0.6966135669554481, 0.7206402686720308, 0.6729244532821677, 0.4768041508912786, 0.48858920734458566, 0.4695038914620663, 0.5042153127372975, 0.4845055998299186, 0.5034655864163241, 0.48701749221029766, 0.47994494798652, 0.48045203328386965, 0.12412802896948194, 0.11220447468726891, 0.12072249994626727, 0.11016643105650858, 0.1117848061131348, 0.1248480965451727, 0.12218161283919982, 0.10313030372756415, 0.10901268815655929, 0.10404861503883744, 0.10648534039750956, 0.1105661867787836, 0.11648927937682696, 0.11296768276587554, 0.10352154807311376, 0.11098682001455795, 0.09923918844671042, 0.11981460127424326, 0.9732437770118886, 0.9533384440073386, 0.9651288444667454, 0.9697444527408943, 0.9735175907246257, 0.9385445569668897, 0.9627039722495934, 0.9715262118521215, 0.9528217792218809, 0.3195981524287269, 0.29229254213813993, 0.27476989690711084, 0.2882868868062768, 0.2853981966668112, 0.3127306309153465, 0.29450692162707914, 0.30425925134616505, 0.30321726916837055, 0.36975116977913536, 0.3652930760514601, 0.2407289078632593, 0.5550485443079113, 0.29359269288674317, 0.5346766684651921, 0.5335024862401485, 0.479329084364128, 0.524971308938411, 0.16858093375057037, 0.15912638397124135, 0.17484274425406288, 0.14906826318175592, 0.16398460051985253, 0.18054847699379184, 0.18720627494815167, 0.18430700709953984, 0.15935602547785999, 0.1096761182160968, 0.02118882789049037, 0.13272122327052072, 0.17184352102832634, 0.16803980729669943, 0.1695364297766362, 0.19069422061175256, 0.1677382037267977, 0.1472334186516724, 0.050048641468092514, 0.035332877362677984, 0.03264674736367901, 0.03400931865048984, 0.02225348516518022, 0.03494813213871417, 0.02616300739388644, 0.04788711967265358, 0.047690519476203175, 0.1232449763193687, 0.12822730273540017, 0.1165527752685237, 0.10744139346526937, 0.11882258790769396, 0.15583837714282234, 0.16897764574529106, 0.16765575568427338, 0.17723325795746458, 0.006695762252744708, 0.002825639319924078, 0.0043043096060966235, 0.003945025974421923, 0.009750969529058406, 0.002590925033116198, 0.013712272831357564, 0.005614350863786033, 0.0163011321341886, 0.1153318621491366, 0.12321973262850716, 0.12896866520890182, 0.13927183613768845, 0.13251869833787366, 0.14119129255555285, 0.12050815764615963, 0.1307470970775415, 0.12411774634105877, 0.47993423207620767, 0.4568127761090325, 0.47415586773843876, 0.4963900742755334, 0.4699349256585418, 0.4821161875201616, 0.45197839757883207, 0.48602233489636415, 0.4763328707031862, 0.1043928098327267, 0.07461699865832994, 0.09509516809504237, 0.08884724995112625, 0.08453129897537259, 0.08409819989407674, 0.08140603877087416, 0.09498974870966337, 0.08656470180333686, 0.13874998564749785, 0.1647901390411467, 0.21415960984310578, 0.12905478990089336, 0.14759387401488255, 0.16207254629695667, 0.13761941982053738, 0.14154433670231825, 0.13633709499846158, 0.2680781469581559, 0.27552659527408074, 0.2865638224621788, 0.26851624260477536, 0.2536974158138571, 0.29020025999704424, 0.3063459527737613, 0.31522053435873254, 0.3267621700919866, 0.21567820147842554, 0.2013606739925865, 0.20460614091820528, 0.18561760038541475, 0.17397690294867385, 0.17665986324921645, 0.22703717241444787, 0.20961890288714835, 0.22123646130514707, 0.19324695690592664, 0.17223260589607725, 0.1688200879380516, 0.218102657495178, 0.19362120166265218, 0.1855380715745335, 0.1745449270279127, 0.16855204353428888, 0.18567871047368267, 0.18267233413541917, 0.19146288974042447, 0.1938347184741105, 0.18441663572826406, 0.17546069620346683, 0.18780938396881408, 0.18905073892991053, 0.1867477296351443, 0.1763010300885166, 0.4625166669244686, 0.18069316819725934, 0.15052959799104626, 0.358949565264975, 0.1526902385531368, 0.3407840003311188, 0.1728796755879819, 0.2795604183698268, 0.17869526969478755, 0.1910529216457384, 0.4755283686131775, 0.16111073536267118, 0.17328010316326747, 0.23918162507520702, 0.25872006325028885, 0.20435045315790423, 0.39616654252471883, 0.46358894291165353, 0.18299651155220775, 0.22774905136226375, 0.22252657342202842, 0.173012217142006, 0.2012360644313116, 0.1832064540509022, 0.189239751738414, 0.20515990985796828, 0.1895734314962345, 0.08682362692441914, 0.07236739724981822, 0.07165017039555455, 0.07658605133866692, 0.07468056294586134, 0.07644414384607867, 0.0617228386683395, 0.07110271362775333, 0.07066980588328065]}, "mutation_prompt": null}
{"id": "5055915e-9d3a-4ccb-bb28-e30384809dc0", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # typically 5-10 times dimensionality\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.5  # initial mutation factor\n        self.crossover_rate = 0.7  # initial crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n        best_idx = None\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with a self-adaptive mutation factor\n                F = self.mutation_factor + np.random.rand() * (1.0 - self.mutation_factor)\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with a self-adaptive crossover rate\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution variant with adaptive mutation and crossover strategies fine-tuned for diverse problem landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b224533e-973f-4a97-a1dc-5e3cb48154af", "metadata": {"aucs": [0.6929852146809926, 0.6817626860461269, 0.7054265341432968, 0.7250244520635813, 0.7182671653456978, 0.7070746033566726, 0.6966135669554481, 0.7206402686720308, 0.6729244532821677, 0.4768041508912786, 0.48858920734458566, 0.4695038914620663, 0.5042153127372975, 0.4845055998299186, 0.5034655864163241, 0.48701749221029766, 0.47994494798652, 0.48045203328386965, 0.12412802896948194, 0.11220447468726891, 0.12072249994626727, 0.11016643105650858, 0.1117848061131348, 0.1248480965451727, 0.12218161283919982, 0.10313030372756415, 0.10901268815655929, 0.10404861503883744, 0.10648534039750956, 0.1105661867787836, 0.11648927937682696, 0.11296768276587554, 0.10352154807311376, 0.11098682001455795, 0.09923918844671042, 0.11981460127424326, 0.9732437770118886, 0.9533384440073386, 0.9651288444667454, 0.9697444527408943, 0.9735175907246257, 0.9385445569668897, 0.9627039722495934, 0.9715262118521215, 0.9528217792218809, 0.3195981524287269, 0.29229254213813993, 0.27476989690711084, 0.2882868868062768, 0.2853981966668112, 0.3127306309153465, 0.29450692162707914, 0.30425925134616505, 0.30321726916837055, 0.36975116977913536, 0.3652930760514601, 0.2407289078632593, 0.5550485443079113, 0.29359269288674317, 0.5346766684651921, 0.5335024862401485, 0.479329084364128, 0.524971308938411, 0.16858093375057037, 0.15912638397124135, 0.17484274425406288, 0.14906826318175592, 0.16398460051985253, 0.18054847699379184, 0.18720627494815167, 0.18430700709953984, 0.15935602547785999, 0.1096761182160968, 0.02118882789049037, 0.13272122327052072, 0.17184352102832634, 0.16803980729669943, 0.1695364297766362, 0.19069422061175256, 0.1677382037267977, 0.1472334186516724, 0.050048641468092514, 0.035332877362677984, 0.03264674736367901, 0.03400931865048984, 0.02225348516518022, 0.03494813213871417, 0.02616300739388644, 0.04788711967265358, 0.047690519476203175, 0.1232449763193687, 0.12822730273540017, 0.1165527752685237, 0.10744139346526937, 0.11882258790769396, 0.15583837714282234, 0.16897764574529106, 0.16765575568427338, 0.17723325795746458, 0.006695762252744708, 0.002825639319924078, 0.0043043096060966235, 0.003945025974421923, 0.009750969529058406, 0.002590925033116198, 0.013712272831357564, 0.005614350863786033, 0.0163011321341886, 0.1153318621491366, 0.12321973262850716, 0.12896866520890182, 0.13927183613768845, 0.13251869833787366, 0.14119129255555285, 0.12050815764615963, 0.1307470970775415, 0.12411774634105877, 0.47993423207620767, 0.4568127761090325, 0.47415586773843876, 0.4963900742755334, 0.4699349256585418, 0.4821161875201616, 0.45197839757883207, 0.48602233489636415, 0.4763328707031862, 0.1043928098327267, 0.07461699865832994, 0.09509516809504237, 0.08884724995112625, 0.08453129897537259, 0.08409819989407674, 0.08140603877087416, 0.09498974870966337, 0.08656470180333686, 0.13874998564749785, 0.1647901390411467, 0.21415960984310578, 0.12905478990089336, 0.14759387401488255, 0.16207254629695667, 0.13761941982053738, 0.14154433670231825, 0.13633709499846158, 0.2680781469581559, 0.27552659527408074, 0.2865638224621788, 0.26851624260477536, 0.2536974158138571, 0.29020025999704424, 0.3063459527737613, 0.31522053435873254, 0.3267621700919866, 0.21567820147842554, 0.2013606739925865, 0.20460614091820528, 0.18561760038541475, 0.17397690294867385, 0.17665986324921645, 0.22703717241444787, 0.20961890288714835, 0.22123646130514707, 0.19324695690592664, 0.17223260589607725, 0.1688200879380516, 0.218102657495178, 0.19362120166265218, 0.1855380715745335, 0.1745449270279127, 0.16855204353428888, 0.18567871047368267, 0.18267233413541917, 0.19146288974042447, 0.1938347184741105, 0.18441663572826406, 0.17546069620346683, 0.18780938396881408, 0.18905073892991053, 0.1867477296351443, 0.1763010300885166, 0.4625166669244686, 0.18069316819725934, 0.15052959799104626, 0.358949565264975, 0.1526902385531368, 0.3407840003311188, 0.1728796755879819, 0.2795604183698268, 0.17869526969478755, 0.1910529216457384, 0.4755283686131775, 0.16111073536267118, 0.17328010316326747, 0.23918162507520702, 0.25872006325028885, 0.20435045315790423, 0.39616654252471883, 0.46358894291165353, 0.18299651155220775, 0.22774905136226375, 0.22252657342202842, 0.173012217142006, 0.2012360644313116, 0.1832064540509022, 0.189239751738414, 0.20515990985796828, 0.1895734314962345, 0.08682362692441914, 0.07236739724981822, 0.07165017039555455, 0.07658605133866692, 0.07468056294586134, 0.07644414384607867, 0.0617228386683395, 0.07110271362775333, 0.07066980588328065]}, "mutation_prompt": null}
{"id": "d288d625-7df3-49cf-b7c6-eea32bed9139", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 10 * dim  # typically 5-10 times dimensionality\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.5  # initial mutation factor\n        self.crossover_rate = 0.7  # initial crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n        best_idx = None\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with a self-adaptive mutation factor\n                F = self.mutation_factor + np.random.rand() * (1.0 - self.mutation_factor)\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with a self-adaptive crossover rate\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "A Differential Evolution variant with adaptive mutation and crossover strategies fine-tuned for diverse problem landscapes.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b224533e-973f-4a97-a1dc-5e3cb48154af", "metadata": {"aucs": [0.6929852146809926, 0.6817626860461269, 0.7054265341432968, 0.7250244520635813, 0.7182671653456978, 0.7070746033566726, 0.6966135669554481, 0.7206402686720308, 0.6729244532821677, 0.4768041508912786, 0.48858920734458566, 0.4695038914620663, 0.5042153127372975, 0.4845055998299186, 0.5034655864163241, 0.48701749221029766, 0.47994494798652, 0.48045203328386965, 0.12412802896948194, 0.11220447468726891, 0.12072249994626727, 0.11016643105650858, 0.1117848061131348, 0.1248480965451727, 0.12218161283919982, 0.10313030372756415, 0.10901268815655929, 0.10404861503883744, 0.10648534039750956, 0.1105661867787836, 0.11648927937682696, 0.11296768276587554, 0.10352154807311376, 0.11098682001455795, 0.09923918844671042, 0.11981460127424326, 0.9732437770118886, 0.9533384440073386, 0.9651288444667454, 0.9697444527408943, 0.9735175907246257, 0.9385445569668897, 0.9627039722495934, 0.9715262118521215, 0.9528217792218809, 0.3195981524287269, 0.29229254213813993, 0.27476989690711084, 0.2882868868062768, 0.2853981966668112, 0.3127306309153465, 0.29450692162707914, 0.30425925134616505, 0.30321726916837055, 0.36975116977913536, 0.3652930760514601, 0.2407289078632593, 0.5550485443079113, 0.29359269288674317, 0.5346766684651921, 0.5335024862401485, 0.479329084364128, 0.524971308938411, 0.16858093375057037, 0.15912638397124135, 0.17484274425406288, 0.14906826318175592, 0.16398460051985253, 0.18054847699379184, 0.18720627494815167, 0.18430700709953984, 0.15935602547785999, 0.1096761182160968, 0.02118882789049037, 0.13272122327052072, 0.17184352102832634, 0.16803980729669943, 0.1695364297766362, 0.19069422061175256, 0.1677382037267977, 0.1472334186516724, 0.050048641468092514, 0.035332877362677984, 0.03264674736367901, 0.03400931865048984, 0.02225348516518022, 0.03494813213871417, 0.02616300739388644, 0.04788711967265358, 0.047690519476203175, 0.1232449763193687, 0.12822730273540017, 0.1165527752685237, 0.10744139346526937, 0.11882258790769396, 0.15583837714282234, 0.16897764574529106, 0.16765575568427338, 0.17723325795746458, 0.006695762252744708, 0.002825639319924078, 0.0043043096060966235, 0.003945025974421923, 0.009750969529058406, 0.002590925033116198, 0.013712272831357564, 0.005614350863786033, 0.0163011321341886, 0.1153318621491366, 0.12321973262850716, 0.12896866520890182, 0.13927183613768845, 0.13251869833787366, 0.14119129255555285, 0.12050815764615963, 0.1307470970775415, 0.12411774634105877, 0.47993423207620767, 0.4568127761090325, 0.47415586773843876, 0.4963900742755334, 0.4699349256585418, 0.4821161875201616, 0.45197839757883207, 0.48602233489636415, 0.4763328707031862, 0.1043928098327267, 0.07461699865832994, 0.09509516809504237, 0.08884724995112625, 0.08453129897537259, 0.08409819989407674, 0.08140603877087416, 0.09498974870966337, 0.08656470180333686, 0.13874998564749785, 0.1647901390411467, 0.21415960984310578, 0.12905478990089336, 0.14759387401488255, 0.16207254629695667, 0.13761941982053738, 0.14154433670231825, 0.13633709499846158, 0.2680781469581559, 0.27552659527408074, 0.2865638224621788, 0.26851624260477536, 0.2536974158138571, 0.29020025999704424, 0.3063459527737613, 0.31522053435873254, 0.3267621700919866, 0.21567820147842554, 0.2013606739925865, 0.20460614091820528, 0.18561760038541475, 0.17397690294867385, 0.17665986324921645, 0.22703717241444787, 0.20961890288714835, 0.22123646130514707, 0.19324695690592664, 0.17223260589607725, 0.1688200879380516, 0.218102657495178, 0.19362120166265218, 0.1855380715745335, 0.1745449270279127, 0.16855204353428888, 0.18567871047368267, 0.18267233413541917, 0.19146288974042447, 0.1938347184741105, 0.18441663572826406, 0.17546069620346683, 0.18780938396881408, 0.18905073892991053, 0.1867477296351443, 0.1763010300885166, 0.4625166669244686, 0.18069316819725934, 0.15052959799104626, 0.358949565264975, 0.1526902385531368, 0.3407840003311188, 0.1728796755879819, 0.2795604183698268, 0.17869526969478755, 0.1910529216457384, 0.4755283686131775, 0.16111073536267118, 0.17328010316326747, 0.23918162507520702, 0.25872006325028885, 0.20435045315790423, 0.39616654252471883, 0.46358894291165353, 0.18299651155220775, 0.22774905136226375, 0.22252657342202842, 0.173012217142006, 0.2012360644313116, 0.1832064540509022, 0.189239751738414, 0.20515990985796828, 0.1895734314962345, 0.08682362692441914, 0.07236739724981822, 0.07165017039555455, 0.07658605133866692, 0.07468056294586134, 0.07644414384607867, 0.0617228386683395, 0.07110271362775333, 0.07066980588328065]}, "mutation_prompt": null}
{"id": "d59e8ba1-6e96-4918-b812-de6a71e3bdc9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim  # reduced population size for efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # increased mutation factor for diversity\n        self.crossover_rate = 0.9  # increased crossover rate for more mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive learning rates\n                F = self.mutation_factor * np.random.rand()\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with a higher probability for randomness\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on a competition strategy\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "A Differential Evolution variant incorporating adaptive learning rates and competition strategies to enhance exploration and exploitation balance.", "configspace": "", "generation": 3, "fitness": 0.38105482258036477, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.27.", "error": "", "parent_id": "b224533e-973f-4a97-a1dc-5e3cb48154af", "metadata": {"aucs": [0.8674321194914121, 0.8662799259535026, 0.872054490152722, 0.8810271110636355, 0.8729316797979114, 0.8794276338374115, 0.839580845324061, 0.8729452305574864, 0.8644204956649295, 0.6634203029507768, 0.7538747836331053, 0.7923450709345294, 0.7481416134526033, 0.7594389067682223, 0.07597363609888963, 0.7681870989670702, 0.7619090630032809, 0.07632081124801249, 0.6544519156897439, 0.1522146480260349, 0.5955955263865664, 0.17052778065467356, 0.1430697609438495, 0.6115035909828328, 0.17035345097640842, 0.17253021615920117, 0.6732005046564157, 0.16592965032523765, 0.11471144745054296, 0.17127645690639615, 0.15174612923798536, 0.10700766528966921, 0.13303417393234684, 0.13941982123804386, 0.1467915911140415, 0.11944808282385933, 0.8859109625460815, 0.9461441926085437, 0.9079260210674522, 0.8232181501820038, 0.9672690983955251, 0.9284823744829694, 0.8535278280136276, 0.85640139802656, 0.8480092499532679, 0.48566148134185083, 0.21327801274970348, 0.4608921201138432, 0.3123492047126555, 0.35233258516849486, 0.28903220044772315, 0.37105028226911196, 0.24179288695277368, 0.27717345513818115, 0.9002451828055821, 0.838721018576727, 0.848522689958302, 0.8568344665917449, 0.8556550064334738, 0.8497285176515008, 0.8459590628508635, 0.8468429089347231, 0.38800286374909476, 0.21951254560156108, 0.18285455387065908, 0.20551533464048544, 0.4260823837570371, 0.23532902601622674, 0.19779513328203835, 0.16809502251267472, 0.14311261674746567, 0.1515062328466773, 0.11810469434332793, 0.17339660266718582, 0.16134819840236359, 0.2106249317713611, 0.1766773653196948, 0.16941000147836371, 0.21664041406525425, 0.12832927721893428, 0.15105564135605398, 0.14628212450364209, 0.10534837749691328, 0.14449728407913387, 0.18523237651718394, 0.09394728874934011, 0.11797283276380621, 0.2410378987085836, 0.14132159918795972, 0.2147893973262428, 0.27151745369959734, 0.11219366353828375, 0.37526262027410884, 0.14223000310767364, 0.6228837284795519, 0.05982384602417856, 0.4089633467359063, 0.4402013322547992, 0.5146962772005086, 0.08289472954297739, 0.1505396793560434, 0.11542799955284277, 0.19129198362144018, 0.2692598986208753, 0.20402343195691608, 0.10975496150567798, 0.20927646011848577, 0.11190136693154995, 0.4279625135728802, 0.3801254471861708, 0.20984500044363275, 0.4186971723463778, 0.466055090314458, 0.300873587085254, 0.17999137256787268, 0.2710185353303829, 0.3816770929225244, 0.6060464406846651, 0.7957593644284646, 0.5442898833977304, 0.5699220120931341, 0.6341107771742407, 0.6154391246313535, 0.8102403000005698, 0.7546545267910703, 0.6298712391215315, 0.148134110299734, 0.17922334798587414, 0.14981061066401413, 0.15077488803087558, 0.12904077063388664, 0.13517716164495008, 0.1400333376578965, 0.149194892499529, 0.17741932557621443, 0.25775136814696464, 0.24790467941949001, 0.221847128395112, 0.39643806236512946, 0.30981944838790576, 0.2173532052373729, 0.25638997602286095, 0.5832702921201742, 0.7220565347701751, 0.5040251514552991, 0.5690709614374023, 0.6903744114327993, 0.6790527035033042, 0.45263766353489276, 0.5325030332230309, 0.5386046137449625, 0.7102755540000528, 0.42414381432461257, 0.41888343557055985, 0.3869827492029049, 0.27776949012100527, 0.41769132027604716, 0.26495371015123925, 0.432586987560188, 0.4837139583053488, 0.3233335501632618, 0.4248700446018524, 0.20503768283530766, 0.32027369443724496, 0.2155928087742255, 0.23814080669779059, 0.2216212850825069, 0.22782225157631797, 0.2332594678780915, 0.20260813322908533, 0.23252706756571173, 0.754968465073859, 0.236942867251974, 0.22098133529801145, 0.2337930449204989, 0.19325662747249062, 0.19520335273361766, 0.7064369180877828, 0.22099625735973083, 0.24454093639803454, 0.16486898163249863, 0.16148984352810491, 0.1694800739317549, 0.8662933316741669, 0.18468250060092328, 0.19773308827403824, 0.18625604909325366, 0.8792662539881777, 0.8941148550043164, 0.8965015110165857, 0.21044194948704475, 0.6891985522653898, 0.7124586245404421, 0.28932990523118407, 0.20552360057591446, 0.21060701105821455, 0.12610994019545452, 0.20800511143088363, 0.17946974470108124, 0.19154256662598323, 0.18076013697286475, 0.18026417124320926, 0.19381768216183393, 0.18031228888335993, 0.20135076236978822, 0.1964963754280331, 0.21271731849330577, 0.09304588101246247, 0.0974549125201033, 0.11314920830357333, 0.08347529598969028, 0.0888715299115993, 0.0977461553104747, 0.08924009927930332, 0.09619139239472119, 0.09843180583015654]}, "mutation_prompt": null}
{"id": "37fbc8ae-93f9-47cd-9aa0-1d3370098007", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim  # reduced population size for efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # increased mutation factor for diversity\n        self.crossover_rate = 0.9  # increased crossover rate for more mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive learning rates\n                F = self.mutation_factor * np.random.rand()\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with a higher probability for randomness\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on a competition strategy\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "A Differential Evolution variant incorporating adaptive learning rates and competition strategies to enhance exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "d59e8ba1-6e96-4918-b812-de6a71e3bdc9", "metadata": {"aucs": [0.8674321194914121, 0.8662799259535026, 0.872054490152722, 0.8810271110636355, 0.8729316797979114, 0.8794276338374115, 0.839580845324061, 0.8729452305574864, 0.8644204956649295, 0.6634203029507768, 0.7538747836331053, 0.7923450709345294, 0.7481416134526033, 0.7594389067682223, 0.07597363609888963, 0.7681870989670702, 0.7619090630032809, 0.07632081124801249, 0.6544519156897439, 0.1522146480260349, 0.5955955263865664, 0.17052778065467356, 0.1430697609438495, 0.6115035909828328, 0.17035345097640842, 0.17253021615920117, 0.6732005046564157, 0.16592965032523765, 0.11471144745054296, 0.17127645690639615, 0.15174612923798536, 0.10700766528966921, 0.13303417393234684, 0.13941982123804386, 0.1467915911140415, 0.11944808282385933, 0.8859109625460815, 0.9461441926085437, 0.9079260210674522, 0.8232181501820038, 0.9672690983955251, 0.9284823744829694, 0.8535278280136276, 0.85640139802656, 0.8480092499532679, 0.48566148134185083, 0.21327801274970348, 0.4608921201138432, 0.3123492047126555, 0.35233258516849486, 0.28903220044772315, 0.37105028226911196, 0.24179288695277368, 0.27717345513818115, 0.9002451828055821, 0.838721018576727, 0.848522689958302, 0.8568344665917449, 0.8556550064334738, 0.8497285176515008, 0.8459590628508635, 0.8468429089347231, 0.38800286374909476, 0.21951254560156108, 0.18285455387065908, 0.20551533464048544, 0.4260823837570371, 0.23532902601622674, 0.19779513328203835, 0.16809502251267472, 0.14311261674746567, 0.1515062328466773, 0.11810469434332793, 0.17339660266718582, 0.16134819840236359, 0.2106249317713611, 0.1766773653196948, 0.16941000147836371, 0.21664041406525425, 0.12832927721893428, 0.15105564135605398, 0.14628212450364209, 0.10534837749691328, 0.14449728407913387, 0.18523237651718394, 0.09394728874934011, 0.11797283276380621, 0.2410378987085836, 0.14132159918795972, 0.2147893973262428, 0.27151745369959734, 0.11219366353828375, 0.37526262027410884, 0.14223000310767364, 0.6228837284795519, 0.05982384602417856, 0.4089633467359063, 0.4402013322547992, 0.5146962772005086, 0.08289472954297739, 0.1505396793560434, 0.11542799955284277, 0.19129198362144018, 0.2692598986208753, 0.20402343195691608, 0.10975496150567798, 0.20927646011848577, 0.11190136693154995, 0.4279625135728802, 0.3801254471861708, 0.20984500044363275, 0.4186971723463778, 0.466055090314458, 0.300873587085254, 0.17999137256787268, 0.2710185353303829, 0.3816770929225244, 0.6060464406846651, 0.7957593644284646, 0.5442898833977304, 0.5699220120931341, 0.6341107771742407, 0.6154391246313535, 0.8102403000005698, 0.7546545267910703, 0.6298712391215315, 0.148134110299734, 0.17922334798587414, 0.14981061066401413, 0.15077488803087558, 0.12904077063388664, 0.13517716164495008, 0.1400333376578965, 0.149194892499529, 0.17741932557621443, 0.25775136814696464, 0.24790467941949001, 0.221847128395112, 0.39643806236512946, 0.30981944838790576, 0.2173532052373729, 0.25638997602286095, 0.5832702921201742, 0.7220565347701751, 0.5040251514552991, 0.5690709614374023, 0.6903744114327993, 0.6790527035033042, 0.45263766353489276, 0.5325030332230309, 0.5386046137449625, 0.7102755540000528, 0.42414381432461257, 0.41888343557055985, 0.3869827492029049, 0.27776949012100527, 0.41769132027604716, 0.26495371015123925, 0.432586987560188, 0.4837139583053488, 0.3233335501632618, 0.4248700446018524, 0.20503768283530766, 0.32027369443724496, 0.2155928087742255, 0.23814080669779059, 0.2216212850825069, 0.22782225157631797, 0.2332594678780915, 0.20260813322908533, 0.23252706756571173, 0.754968465073859, 0.236942867251974, 0.22098133529801145, 0.2337930449204989, 0.19325662747249062, 0.19520335273361766, 0.7064369180877828, 0.22099625735973083, 0.24454093639803454, 0.16486898163249863, 0.16148984352810491, 0.1694800739317549, 0.8662933316741669, 0.18468250060092328, 0.19773308827403824, 0.18625604909325366, 0.8792662539881777, 0.8941148550043164, 0.8965015110165857, 0.21044194948704475, 0.6891985522653898, 0.7124586245404421, 0.28932990523118407, 0.20552360057591446, 0.21060701105821455, 0.12610994019545452, 0.20800511143088363, 0.17946974470108124, 0.19154256662598323, 0.18076013697286475, 0.18026417124320926, 0.19381768216183393, 0.18031228888335993, 0.20135076236978822, 0.1964963754280331, 0.21271731849330577, 0.09304588101246247, 0.0974549125201033, 0.11314920830357333, 0.08347529598969028, 0.0888715299115993, 0.0977461553104747, 0.08924009927930332, 0.09619139239472119, 0.09843180583015654]}, "mutation_prompt": null}
{"id": "66d39c6d-5b05-4ada-b86a-83567d188beb", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim  # reduced population size for efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.7  # adjusted mutation factor for better convergence\n        self.crossover_rate = 0.85  # adjusted crossover rate for controlled randomness\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive learning rates\n                F = self.mutation_factor * np.random.uniform(0.5, 1.5)\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with randomized index\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection with elitist strategy\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "A Differential Evolution variant leveraging adaptive mutation and elitist selection strategies to improve convergence speed and solution quality.", "configspace": "", "generation": 5, "fitness": 0.35996958998489403, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "d59e8ba1-6e96-4918-b812-de6a71e3bdc9", "metadata": {"aucs": [0.786465510576524, 0.7824847673202219, 0.7717854473967918, 0.8111528355456055, 0.7854519235330203, 0.7849503637045978, 0.7758404417895381, 0.7774261830720166, 0.784553245117605, 0.6278209134580934, 0.6256049779923456, 0.6368305924281952, 0.5941928115552406, 0.6321179153426104, 0.6422998873617991, 0.6366370537955026, 0.6160550074111555, 0.639850024615541, 0.11218458968177925, 0.12141502994836251, 0.11388984675843095, 0.12153149652800732, 0.10991344256730229, 0.1219102882470624, 0.1231582011270349, 0.11752259613384053, 0.114157429987081, 0.1015071515509306, 0.1019153683532531, 0.09794009384986835, 0.12299205244081335, 0.12068841827709476, 0.10633122181085197, 0.11613679315403824, 0.11557898650223053, 0.11326846912968136, 0.9723370311176301, 0.9176612760393598, 0.9306791088481233, 0.9494123891897102, 0.9721759697995087, 0.959837766980613, 0.9680247448180971, 0.9600319286579587, 0.957780309237467, 0.46160476716100296, 0.44347029407338445, 0.4751849406493861, 0.42194012577570583, 0.5055575249727214, 0.4676779664897067, 0.46400448090167534, 0.48440533404635655, 0.46566774372774467, 0.7238845557829572, 0.6783716326398027, 0.731790307306059, 0.7445336884251974, 0.740551957728973, 0.7535601317313237, 0.7529684857020178, 0.7632253980672203, 0.7723976735732367, 0.32098553367938243, 0.3045031621109706, 0.28718420901748787, 0.29282468896884706, 0.32891859264325296, 0.4048551484215762, 0.31852773227315845, 0.31121685087682294, 0.3862096624433714, 0.4740013331015607, 0.05174232062326534, 0.3051727635311019, 0.27757291187262767, 0.27142260488835623, 0.36176034958576464, 0.2905274246453008, 0.34841036985668494, 0.26536420285619644, 0.29626105663702784, 0.28473416810535845, 0.29547275985203114, 0.3057497291207545, 0.28275524385224593, 0.32954564678377796, 0.25878642557472786, 0.3195818667455974, 0.26299253519153964, 0.4474490114634495, 0.4089018040378726, 0.42449425431921106, 0.399494157706213, 0.4003751807275101, 0.47231275721889887, 0.4786486169692865, 0.5199356232375587, 0.44451425782484877, 0.08542937440274745, 0.11764613046600536, 0.13647029765223107, 0.1261977210588715, 0.2014802313424887, 0.1767712984771742, 0.12347167973245632, 0.17219292417509913, 0.10843837030685421, 0.3106639328106787, 0.23309923203278793, 0.2555149894219998, 0.24493512759036762, 0.27576785617242383, 0.3025488723508307, 0.25949083757836566, 0.2572582019100744, 0.2615855688764652, 0.6809298167845301, 0.6597802275965636, 0.6408671161046633, 0.6862287462986494, 0.6538935932700036, 0.6636947154927655, 0.6553812513525339, 0.6551266168428517, 0.6605581546158791, 0.09156003369423926, 0.1043062714996773, 0.09663429327564133, 0.09182166477019671, 0.08665729299668934, 0.10452210231910597, 0.10048164536753779, 0.09499836444292564, 0.09324297237146262, 0.1465853886388122, 0.1679018454311063, 0.25922526960314185, 0.1740600456380007, 0.15194081797143444, 0.14120785139716086, 0.17591552281557254, 0.11859416518875965, 0.1500105248835476, 0.3845315269643417, 0.36170003454766975, 0.35831670316772257, 0.3786200717110786, 0.3549648269823652, 0.3864786068698951, 0.4278459238036858, 0.38536391304542383, 0.41899735205613375, 0.2819713604421349, 0.3061908218990804, 0.27040339791609846, 0.2775619026768459, 0.2785582599042151, 0.312711489639377, 0.2929116471395681, 0.3064969796748146, 0.2855852410205908, 0.18430328302894983, 0.2039834784791732, 0.1966912924712998, 0.17968519892920298, 0.1916009425093197, 0.19300368685249691, 0.20240281431300977, 0.17841759127927725, 0.18335254862684014, 0.19116257436640427, 0.18037176849254988, 0.1895434879258624, 0.19763715204582855, 0.18504439761155256, 0.20091259373794146, 0.19809821265685468, 0.18838124231423103, 0.20306841248362106, 0.7492270669303194, 0.17024149153854085, 0.1611809639931001, 0.5679417303430142, 0.1953532402539766, 0.5710963103697766, 0.18333158956342765, 0.584732591825155, 0.7132202274377745, 0.7335177074638384, 0.2042503406388172, 0.20497495113775344, 0.7331968188626562, 0.4277442491050607, 0.1980763658979814, 0.20908467928738683, 0.7081724157737084, 0.20517443860585372, 0.19057723442533037, 0.18319686803827673, 0.17722587454104088, 0.18974061957953336, 0.15122145074399285, 0.180251086751836, 0.17772250995145988, 0.1944863813658667, 0.18444519281983462, 0.08152375558591429, 0.07425263438120777, 0.07964179532695415, 0.07478431987861278, 0.07892446392330055, 0.06881786470340945, 0.0867416669183545, 0.0754604956371393, 0.07643648025942607]}, "mutation_prompt": null}
{"id": "b8a0c7b9-f2d7-4010-8eb8-e305db22cf69", "solution": "import numpy as np\n\nclass StochasticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 8 * dim\n        self.bounds = (-5.0, 5.0)\n        self.c1 = 1.5  # cognitive coefficient\n        self.c2 = 1.5  # social coefficient\n        self.w = 0.7  # inertia weight\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.velocities = np.random.uniform(-1, 1, (self.pop_size, self.dim))\n        self.personal_best_positions = np.copy(self.population)\n        self.personal_best_fitness = np.full(self.pop_size, np.inf)\n        self.global_best_position = np.zeros(self.dim)\n        self.global_best_fitness = np.inf\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            fitness_value = func(self.population[i])\n            evaluations += 1\n            if fitness_value < self.personal_best_fitness[i]:\n                self.personal_best_fitness[i] = fitness_value\n                self.personal_best_positions[i] = self.population[i]\n                if fitness_value < self.global_best_fitness:\n                    self.global_best_fitness = fitness_value\n                    self.global_best_position = self.population[i]\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Update velocity using adaptive control\n                r1 = np.random.rand(self.dim)\n                r2 = np.random.rand(self.dim)\n                cognitive_component = self.c1 * r1 * (self.personal_best_positions[i] - self.population[i])\n                social_component = self.c2 * r2 * (self.global_best_position - self.population[i])\n                self.velocities[i] = self.w * self.velocities[i] + cognitive_component + social_component\n\n                # Introduce stochastic perturbation\n                perturbation = np.random.normal(0, 0.1, self.dim)\n                self.population[i] += self.velocities[i] + perturbation\n                self.population[i] = np.clip(self.population[i], self.bounds[0], self.bounds[1])\n\n                # Evaluate new positions\n                fitness_value = func(self.population[i])\n                evaluations += 1\n\n                # Update personal and global bests\n                if fitness_value < self.personal_best_fitness[i]:\n                    self.personal_best_fitness[i] = fitness_value\n                    self.personal_best_positions[i] = self.population[i]\n                    if fitness_value < self.global_best_fitness:\n                        self.global_best_fitness = fitness_value\n                        self.global_best_position = self.population[i]\n\n        return self.global_best_position, self.global_best_fitness", "name": "StochasticPSO", "description": "A Stochastic Particle Swarm Optimization variant that leverages adaptive velocity control and random perturbations for enhanced convergence and exploration.", "configspace": "", "generation": 6, "fitness": 0.1935835741234968, "feedback": "The algorithm StochasticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "d59e8ba1-6e96-4918-b812-de6a71e3bdc9", "metadata": {"aucs": [0.3517819823781525, 0.3341004479762303, 0.3433524316963996, 0.3873357629210401, 0.39390956792061915, 0.3475797117577326, 0.38591150259632745, 0.3619680723014228, 0.3766663351795846, 9.999999999998899e-05, 0.007342120898702897, 0.0019451712678523192, 0.03639636715488681, 9.999999999998899e-05, 0.019787376986296623, 9.999999999998899e-05, 0.0023024939923667054, 9.999999999998899e-05, 0.11365895663512815, 0.11142361013966007, 0.09170554973516809, 0.10373340610468784, 0.13673442107074074, 0.06393578086666907, 0.11086854984059169, 0.1000624528611539, 0.10805334681102086, 0.08032911644618579, 0.08175057633726135, 0.08886781684696521, 0.08783475264530194, 0.0839086327611216, 0.09591044618602174, 0.0812136518002251, 0.07820393591772357, 0.090901073725706, 0.9911431285536195, 0.9907207971103447, 0.9920923166826334, 0.9881931933883926, 0.9897005877583384, 0.9874444281630822, 0.9913061744458513, 0.9885503468290218, 0.9898464453984187, 0.23567730902619977, 0.2558449593310801, 0.2041011872535301, 0.23743687128018265, 0.2612425035560465, 0.22364204035501112, 0.20660787271147552, 0.23373678413299726, 0.2341258081241092, 0.30945231143568985, 0.27621237859054615, 0.2691706806565206, 0.22108155323978718, 0.2834722578292712, 0.22198175369613504, 0.24366276185105384, 0.23265936587167413, 0.2779712520614206, 0.1349366458009894, 0.1508484661700339, 0.1275695584794495, 0.15089326251664648, 0.12511203717089847, 0.13186095763801864, 0.1282079709364583, 0.13951291978314717, 0.1603428460381252, 0.1356770078886269, 0.11529142158852779, 0.1305162116663845, 0.12274211248349742, 0.1220191810434621, 0.14895082746929533, 0.12656419351921233, 0.06741452879339982, 0.13309419716825943, 9.999999999998899e-05, 0.02099390588322203, 9.999999999998899e-05, 0.008414968119720978, 0.0006382104918278841, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06992989552899687, 0.045172275997266476, 0.0808979619483261, 0.07432219878159008, 0.009193072112011258, 9.999999999998899e-05, 0.05478007086840919, 0.018775328982537753, 0.050796695162668604, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03032913613314936, 0.022051559223181028, 0.061261214405225695, 0.060166501485573676, 0.06712636606179767, 0.0648857547993752, 0.04606072225472868, 0.048330408355040544, 0.04540677988650588, 0.3438805853919966, 0.3605286223924129, 0.376553552389127, 0.35157969521340793, 0.35199323026705653, 0.36034861194396517, 0.3522352109818787, 0.32823792695059684, 0.34931586298472417, 0.08354581181735887, 0.10360062562098138, 0.10375448151884759, 0.10641634576789549, 0.10333877340121, 0.11174828513446589, 0.09542679156230804, 0.10393393142123186, 0.09520280278572812, 0.23375591685807073, 0.2376073782823882, 0.13860391744651102, 0.2308455272584844, 0.2109294209409398, 0.17286175765200718, 0.14338819564438987, 0.1927175940366912, 0.20155628663597902, 0.2563058599993112, 0.2613574120111998, 0.24663108083244267, 0.24621290744073354, 0.23784695757060803, 0.2737752996332773, 0.24582252117277326, 0.26376124843417414, 0.2610586433722515, 0.18529581587526012, 0.19529965909922398, 0.18234595519870922, 0.18776122242770465, 0.18566558739569405, 0.1988763523721605, 0.20558611670711824, 0.2143969396501909, 0.16971029601930243, 0.21417289093249914, 0.19700475238226944, 0.19773882563567036, 0.2049961953133138, 0.20181293579056725, 0.18575845738241714, 0.19873771016932895, 0.18482735376675885, 0.18228859800742725, 0.18982436747905684, 0.1903548730543092, 0.1843313846408332, 0.20043081818204922, 0.18411223566500234, 0.17716304684214834, 0.17233148275788213, 0.18631239163598623, 0.18240579568029514, 0.5173363163362814, 0.1256202026621388, 0.1527382760176208, 0.5098647965805911, 0.19794737747705748, 0.16721520588214756, 0.14119525868806126, 0.4656350205900023, 0.21061366839630036, 0.46533016204917044, 0.20958101935445506, 0.3330600169880482, 0.20432058213041493, 0.16765279655466825, 0.15102121820878622, 0.10431454891788561, 0.21101933232715386, 0.1585008561121254, 0.1824269991752383, 0.18482435384874174, 0.17949893620652546, 0.18560662320055932, 0.17954148194460873, 0.18093976922531463, 0.195660457408816, 0.17754715859652914, 0.17907209636516486, 0.0943232648918143, 0.0898509729732605, 0.0743911832315538, 0.08342616056453411, 0.07541673479431432, 0.0784631554017513, 0.08463289057356216, 0.08323277390734707, 0.08636934653519224]}, "mutation_prompt": null}
{"id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 6 * dim  # further reducing population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # slightly adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * (0.5 + np.random.rand() / 2)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A compact variant of Differential Evolution with adaptive mutation and crossover strategies, balancing exploration with budget constraints.", "configspace": "", "generation": 7, "fitness": 0.4416989203232584, "feedback": "The algorithm CompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.27.", "error": "", "parent_id": "d59e8ba1-6e96-4918-b812-de6a71e3bdc9", "metadata": {"aucs": [0.8604101107511122, 0.8356284551497423, 0.8657173988030784, 0.8477603560181309, 0.8515936943284856, 0.8494498375206934, 0.8613677020760171, 0.8668245091125429, 0.8553541739882592, 0.7505985276144164, 0.7474115847450862, 0.746697773121326, 0.7595229516689512, 0.7606084778731909, 0.7464397686403881, 0.7696384414885483, 0.7352929156834567, 0.7428688246006268, 0.1497779670615953, 0.12171335907412262, 0.12489034232033158, 0.12292936404110766, 0.30914668457913663, 0.22840579984700815, 0.12506479834758844, 0.12825112069787847, 0.1477667130571042, 0.11857694851907397, 0.11496937456679657, 0.15113257176958173, 0.11402060735102426, 0.1158056191327711, 0.12212016982836649, 0.13360310831850353, 0.12883573842052443, 0.11317202989454367, 0.9727983777181126, 0.9493297416488158, 0.9147309488888306, 0.9783199161268581, 0.9271438138950203, 0.9730049333882211, 0.9546596554546737, 0.9422931167548181, 0.9175313300574669, 0.6176541502404138, 0.594347999730811, 0.6048263132455644, 0.6349099976631112, 0.6562099746726866, 0.6289998411950368, 0.6272939747319326, 0.6431743913740466, 0.6512472195220291, 0.7899557485922579, 0.8415561557187536, 0.808061533935596, 0.8469793814224592, 0.8128537365028776, 0.8328051451741559, 0.8073073665008006, 0.8175027459084098, 0.8224219007348392, 0.467585675269636, 0.5059365376654247, 0.4204877101875625, 0.45829747255816444, 0.5407525109001249, 0.3461052762028428, 0.5774524127497492, 0.4522165981277685, 0.33424222477513665, 0.4223678712133194, 0.2899030649351715, 0.5776129284304985, 0.42020414239874093, 0.4040460311615891, 0.3833052004597579, 0.36329137881683127, 0.4319562059336449, 0.5450893794006297, 0.4992515460189285, 0.5079819581278592, 0.4325378205241657, 0.5073087740444189, 0.5181117830377086, 0.5131125858339277, 0.49853861199967464, 0.4522468871820412, 0.4866184978968172, 0.6414199770798221, 0.6229886641667042, 0.6191183532856165, 0.6126189829239181, 0.6619223879856246, 0.6269273841816716, 0.6294946226841911, 0.6861052042664002, 0.6542869615027032, 0.24029551480380817, 0.2935595528502696, 0.24374801302424487, 0.3435229917057059, 0.38473145987731017, 0.4029812661448, 0.2994813825848689, 0.13907352561818298, 0.23805936493113833, 0.3846960385120599, 0.4279949919964705, 0.38782176337985463, 0.40017438557012375, 0.4171239512585564, 0.4251388548309677, 0.39189092229321143, 0.40113994214901605, 0.40996287859332314, 0.755384550206438, 0.7778828571341556, 0.7616395386992576, 0.7774118340905064, 0.7741881957904504, 0.7599196314410602, 0.7414197527889563, 0.7669773465834868, 0.7608858243837068, 0.12099522984199262, 0.11900150463002879, 0.09373514250534842, 0.09336208736214435, 0.11851386734806857, 0.11980879883762574, 0.09751398585578042, 0.09766220336812881, 0.1051804257435186, 0.15345260008304762, 0.16964524667867065, 0.17953294765253036, 0.16916135766543916, 0.1653756178595691, 0.18766840578362654, 0.14388598862964208, 0.23074634324110832, 0.16802978452801376, 0.42668115317946054, 0.5146610010904235, 0.48751275615197276, 0.46567203302639604, 0.49441567177182766, 0.4625230922553436, 0.46431598618287573, 0.5070275658138245, 0.5269221750669579, 0.33732648643132823, 0.33014606863099694, 0.3430736174859941, 0.30338645363123073, 0.3359646608384711, 0.31379357086864956, 0.4064574615617108, 0.3828863910612511, 0.36926610902055423, 0.20738556808605912, 0.21079331245955324, 0.203981110964767, 0.19876212885134437, 0.18961341704427137, 0.18823562704926744, 0.21907791342433314, 0.2067342699585667, 0.18595642479515928, 0.18196180372472792, 0.27563249558672553, 0.35823388408917434, 0.4355279375915073, 0.18864372241553407, 0.2914112892831079, 0.3568475309174437, 0.21163520890185472, 0.23473557370901177, 0.715376834739321, 0.25444507110848913, 0.7296399290953282, 0.8242394935596379, 0.7594289529154479, 0.7915511853656514, 0.18546589532177082, 0.19243404307514123, 0.2079799790641621, 0.2011842632495161, 0.8428923018553961, 0.7294164552877406, 0.20396683955070616, 0.20503188548195317, 0.19083736307449828, 0.8216218377965319, 0.20566707611716495, 0.7850153107199618, 0.1822522873652579, 0.186387746858527, 0.1883673992824756, 0.19608954636986842, 0.18142547492487227, 0.17990476084353946, 0.18323030840562382, 0.17939189385656695, 0.18769871167950247, 0.09090274700420164, 0.07799805436752938, 0.07929211029265937, 0.08160190767761355, 0.08049536401199042, 0.08757363698338505, 0.08449317728988759, 0.07721511517392687, 0.07614163354157921]}, "mutation_prompt": null}
{"id": "4c123545-fcb7-48ef-a882-5c57041edc67", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 6 * dim  # further reducing population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # slightly adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * (0.5 + np.random.rand() / 2)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A compact variant of Differential Evolution with adaptive mutation and crossover strategies, balancing exploration with budget constraints.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "metadata": {"aucs": [0.8604101107511122, 0.8356284551497423, 0.8657173988030784, 0.8477603560181309, 0.8515936943284856, 0.8494498375206934, 0.8613677020760171, 0.8668245091125429, 0.8553541739882592, 0.7505985276144164, 0.7474115847450862, 0.746697773121326, 0.7595229516689512, 0.7606084778731909, 0.7464397686403881, 0.7696384414885483, 0.7352929156834567, 0.7428688246006268, 0.1497779670615953, 0.12171335907412262, 0.12489034232033158, 0.12292936404110766, 0.30914668457913663, 0.22840579984700815, 0.12506479834758844, 0.12825112069787847, 0.1477667130571042, 0.11857694851907397, 0.11496937456679657, 0.15113257176958173, 0.11402060735102426, 0.1158056191327711, 0.12212016982836649, 0.13360310831850353, 0.12883573842052443, 0.11317202989454367, 0.9727983777181126, 0.9493297416488158, 0.9147309488888306, 0.9783199161268581, 0.9271438138950203, 0.9730049333882211, 0.9546596554546737, 0.9422931167548181, 0.9175313300574669, 0.6176541502404138, 0.594347999730811, 0.6048263132455644, 0.6349099976631112, 0.6562099746726866, 0.6289998411950368, 0.6272939747319326, 0.6431743913740466, 0.6512472195220291, 0.7899557485922579, 0.8415561557187536, 0.808061533935596, 0.8469793814224592, 0.8128537365028776, 0.8328051451741559, 0.8073073665008006, 0.8175027459084098, 0.8224219007348392, 0.467585675269636, 0.5059365376654247, 0.4204877101875625, 0.45829747255816444, 0.5407525109001249, 0.3461052762028428, 0.5774524127497492, 0.4522165981277685, 0.33424222477513665, 0.4223678712133194, 0.2899030649351715, 0.5776129284304985, 0.42020414239874093, 0.4040460311615891, 0.3833052004597579, 0.36329137881683127, 0.4319562059336449, 0.5450893794006297, 0.4992515460189285, 0.5079819581278592, 0.4325378205241657, 0.5073087740444189, 0.5181117830377086, 0.5131125858339277, 0.49853861199967464, 0.4522468871820412, 0.4866184978968172, 0.6414199770798221, 0.6229886641667042, 0.6191183532856165, 0.6126189829239181, 0.6619223879856246, 0.6269273841816716, 0.6294946226841911, 0.6861052042664002, 0.6542869615027032, 0.24029551480380817, 0.2935595528502696, 0.24374801302424487, 0.3435229917057059, 0.38473145987731017, 0.4029812661448, 0.2994813825848689, 0.13907352561818298, 0.23805936493113833, 0.3846960385120599, 0.4279949919964705, 0.38782176337985463, 0.40017438557012375, 0.4171239512585564, 0.4251388548309677, 0.39189092229321143, 0.40113994214901605, 0.40996287859332314, 0.755384550206438, 0.7778828571341556, 0.7616395386992576, 0.7774118340905064, 0.7741881957904504, 0.7599196314410602, 0.7414197527889563, 0.7669773465834868, 0.7608858243837068, 0.12099522984199262, 0.11900150463002879, 0.09373514250534842, 0.09336208736214435, 0.11851386734806857, 0.11980879883762574, 0.09751398585578042, 0.09766220336812881, 0.1051804257435186, 0.15345260008304762, 0.16964524667867065, 0.17953294765253036, 0.16916135766543916, 0.1653756178595691, 0.18766840578362654, 0.14388598862964208, 0.23074634324110832, 0.16802978452801376, 0.42668115317946054, 0.5146610010904235, 0.48751275615197276, 0.46567203302639604, 0.49441567177182766, 0.4625230922553436, 0.46431598618287573, 0.5070275658138245, 0.5269221750669579, 0.33732648643132823, 0.33014606863099694, 0.3430736174859941, 0.30338645363123073, 0.3359646608384711, 0.31379357086864956, 0.4064574615617108, 0.3828863910612511, 0.36926610902055423, 0.20738556808605912, 0.21079331245955324, 0.203981110964767, 0.19876212885134437, 0.18961341704427137, 0.18823562704926744, 0.21907791342433314, 0.2067342699585667, 0.18595642479515928, 0.18196180372472792, 0.27563249558672553, 0.35823388408917434, 0.4355279375915073, 0.18864372241553407, 0.2914112892831079, 0.3568475309174437, 0.21163520890185472, 0.23473557370901177, 0.715376834739321, 0.25444507110848913, 0.7296399290953282, 0.8242394935596379, 0.7594289529154479, 0.7915511853656514, 0.18546589532177082, 0.19243404307514123, 0.2079799790641621, 0.2011842632495161, 0.8428923018553961, 0.7294164552877406, 0.20396683955070616, 0.20503188548195317, 0.19083736307449828, 0.8216218377965319, 0.20566707611716495, 0.7850153107199618, 0.1822522873652579, 0.186387746858527, 0.1883673992824756, 0.19608954636986842, 0.18142547492487227, 0.17990476084353946, 0.18323030840562382, 0.17939189385656695, 0.18769871167950247, 0.09090274700420164, 0.07799805436752938, 0.07929211029265937, 0.08160190767761355, 0.08049536401199042, 0.08757363698338505, 0.08449317728988759, 0.07721511517392687, 0.07614163354157921]}, "mutation_prompt": null}
{"id": "6f258bdd-0659-401e-bac7-887de124f6a0", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 6 * dim  # further reducing population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # slightly adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * (0.5 + np.random.rand() / 2)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A compact variant of Differential Evolution with adaptive mutation and crossover strategies, balancing exploration with budget constraints.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "metadata": {"aucs": [0.8604101107511122, 0.8356284551497423, 0.8657173988030784, 0.8477603560181309, 0.8515936943284856, 0.8494498375206934, 0.8613677020760171, 0.8668245091125429, 0.8553541739882592, 0.7505985276144164, 0.7474115847450862, 0.746697773121326, 0.7595229516689512, 0.7606084778731909, 0.7464397686403881, 0.7696384414885483, 0.7352929156834567, 0.7428688246006268, 0.1497779670615953, 0.12171335907412262, 0.12489034232033158, 0.12292936404110766, 0.30914668457913663, 0.22840579984700815, 0.12506479834758844, 0.12825112069787847, 0.1477667130571042, 0.11857694851907397, 0.11496937456679657, 0.15113257176958173, 0.11402060735102426, 0.1158056191327711, 0.12212016982836649, 0.13360310831850353, 0.12883573842052443, 0.11317202989454367, 0.9727983777181126, 0.9493297416488158, 0.9147309488888306, 0.9783199161268581, 0.9271438138950203, 0.9730049333882211, 0.9546596554546737, 0.9422931167548181, 0.9175313300574669, 0.6176541502404138, 0.594347999730811, 0.6048263132455644, 0.6349099976631112, 0.6562099746726866, 0.6289998411950368, 0.6272939747319326, 0.6431743913740466, 0.6512472195220291, 0.7899557485922579, 0.8415561557187536, 0.808061533935596, 0.8469793814224592, 0.8128537365028776, 0.8328051451741559, 0.8073073665008006, 0.8175027459084098, 0.8224219007348392, 0.467585675269636, 0.5059365376654247, 0.4204877101875625, 0.45829747255816444, 0.5407525109001249, 0.3461052762028428, 0.5774524127497492, 0.4522165981277685, 0.33424222477513665, 0.4223678712133194, 0.2899030649351715, 0.5776129284304985, 0.42020414239874093, 0.4040460311615891, 0.3833052004597579, 0.36329137881683127, 0.4319562059336449, 0.5450893794006297, 0.4992515460189285, 0.5079819581278592, 0.4325378205241657, 0.5073087740444189, 0.5181117830377086, 0.5131125858339277, 0.49853861199967464, 0.4522468871820412, 0.4866184978968172, 0.6414199770798221, 0.6229886641667042, 0.6191183532856165, 0.6126189829239181, 0.6619223879856246, 0.6269273841816716, 0.6294946226841911, 0.6861052042664002, 0.6542869615027032, 0.24029551480380817, 0.2935595528502696, 0.24374801302424487, 0.3435229917057059, 0.38473145987731017, 0.4029812661448, 0.2994813825848689, 0.13907352561818298, 0.23805936493113833, 0.3846960385120599, 0.4279949919964705, 0.38782176337985463, 0.40017438557012375, 0.4171239512585564, 0.4251388548309677, 0.39189092229321143, 0.40113994214901605, 0.40996287859332314, 0.755384550206438, 0.7778828571341556, 0.7616395386992576, 0.7774118340905064, 0.7741881957904504, 0.7599196314410602, 0.7414197527889563, 0.7669773465834868, 0.7608858243837068, 0.12099522984199262, 0.11900150463002879, 0.09373514250534842, 0.09336208736214435, 0.11851386734806857, 0.11980879883762574, 0.09751398585578042, 0.09766220336812881, 0.1051804257435186, 0.15345260008304762, 0.16964524667867065, 0.17953294765253036, 0.16916135766543916, 0.1653756178595691, 0.18766840578362654, 0.14388598862964208, 0.23074634324110832, 0.16802978452801376, 0.42668115317946054, 0.5146610010904235, 0.48751275615197276, 0.46567203302639604, 0.49441567177182766, 0.4625230922553436, 0.46431598618287573, 0.5070275658138245, 0.5269221750669579, 0.33732648643132823, 0.33014606863099694, 0.3430736174859941, 0.30338645363123073, 0.3359646608384711, 0.31379357086864956, 0.4064574615617108, 0.3828863910612511, 0.36926610902055423, 0.20738556808605912, 0.21079331245955324, 0.203981110964767, 0.19876212885134437, 0.18961341704427137, 0.18823562704926744, 0.21907791342433314, 0.2067342699585667, 0.18595642479515928, 0.18196180372472792, 0.27563249558672553, 0.35823388408917434, 0.4355279375915073, 0.18864372241553407, 0.2914112892831079, 0.3568475309174437, 0.21163520890185472, 0.23473557370901177, 0.715376834739321, 0.25444507110848913, 0.7296399290953282, 0.8242394935596379, 0.7594289529154479, 0.7915511853656514, 0.18546589532177082, 0.19243404307514123, 0.2079799790641621, 0.2011842632495161, 0.8428923018553961, 0.7294164552877406, 0.20396683955070616, 0.20503188548195317, 0.19083736307449828, 0.8216218377965319, 0.20566707611716495, 0.7850153107199618, 0.1822522873652579, 0.186387746858527, 0.1883673992824756, 0.19608954636986842, 0.18142547492487227, 0.17990476084353946, 0.18323030840562382, 0.17939189385656695, 0.18769871167950247, 0.09090274700420164, 0.07799805436752938, 0.07929211029265937, 0.08160190767761355, 0.08049536401199042, 0.08757363698338505, 0.08449317728988759, 0.07721511517392687, 0.07614163354157921]}, "mutation_prompt": null}
{"id": "4e0ff477-8a51-4096-bb36-bcc11f0c692d", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 6 * dim  # further reducing population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # slightly adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * (0.5 + np.random.rand() / 2)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A compact variant of Differential Evolution with adaptive mutation and crossover strategies, balancing exploration with budget constraints.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "metadata": {"aucs": [0.8604101107511122, 0.8356284551497423, 0.8657173988030784, 0.8477603560181309, 0.8515936943284856, 0.8494498375206934, 0.8613677020760171, 0.8668245091125429, 0.8553541739882592, 0.7505985276144164, 0.7474115847450862, 0.746697773121326, 0.7595229516689512, 0.7606084778731909, 0.7464397686403881, 0.7696384414885483, 0.7352929156834567, 0.7428688246006268, 0.1497779670615953, 0.12171335907412262, 0.12489034232033158, 0.12292936404110766, 0.30914668457913663, 0.22840579984700815, 0.12506479834758844, 0.12825112069787847, 0.1477667130571042, 0.11857694851907397, 0.11496937456679657, 0.15113257176958173, 0.11402060735102426, 0.1158056191327711, 0.12212016982836649, 0.13360310831850353, 0.12883573842052443, 0.11317202989454367, 0.9727983777181126, 0.9493297416488158, 0.9147309488888306, 0.9783199161268581, 0.9271438138950203, 0.9730049333882211, 0.9546596554546737, 0.9422931167548181, 0.9175313300574669, 0.6176541502404138, 0.594347999730811, 0.6048263132455644, 0.6349099976631112, 0.6562099746726866, 0.6289998411950368, 0.6272939747319326, 0.6431743913740466, 0.6512472195220291, 0.7899557485922579, 0.8415561557187536, 0.808061533935596, 0.8469793814224592, 0.8128537365028776, 0.8328051451741559, 0.8073073665008006, 0.8175027459084098, 0.8224219007348392, 0.467585675269636, 0.5059365376654247, 0.4204877101875625, 0.45829747255816444, 0.5407525109001249, 0.3461052762028428, 0.5774524127497492, 0.4522165981277685, 0.33424222477513665, 0.4223678712133194, 0.2899030649351715, 0.5776129284304985, 0.42020414239874093, 0.4040460311615891, 0.3833052004597579, 0.36329137881683127, 0.4319562059336449, 0.5450893794006297, 0.4992515460189285, 0.5079819581278592, 0.4325378205241657, 0.5073087740444189, 0.5181117830377086, 0.5131125858339277, 0.49853861199967464, 0.4522468871820412, 0.4866184978968172, 0.6414199770798221, 0.6229886641667042, 0.6191183532856165, 0.6126189829239181, 0.6619223879856246, 0.6269273841816716, 0.6294946226841911, 0.6861052042664002, 0.6542869615027032, 0.24029551480380817, 0.2935595528502696, 0.24374801302424487, 0.3435229917057059, 0.38473145987731017, 0.4029812661448, 0.2994813825848689, 0.13907352561818298, 0.23805936493113833, 0.3846960385120599, 0.4279949919964705, 0.38782176337985463, 0.40017438557012375, 0.4171239512585564, 0.4251388548309677, 0.39189092229321143, 0.40113994214901605, 0.40996287859332314, 0.755384550206438, 0.7778828571341556, 0.7616395386992576, 0.7774118340905064, 0.7741881957904504, 0.7599196314410602, 0.7414197527889563, 0.7669773465834868, 0.7608858243837068, 0.12099522984199262, 0.11900150463002879, 0.09373514250534842, 0.09336208736214435, 0.11851386734806857, 0.11980879883762574, 0.09751398585578042, 0.09766220336812881, 0.1051804257435186, 0.15345260008304762, 0.16964524667867065, 0.17953294765253036, 0.16916135766543916, 0.1653756178595691, 0.18766840578362654, 0.14388598862964208, 0.23074634324110832, 0.16802978452801376, 0.42668115317946054, 0.5146610010904235, 0.48751275615197276, 0.46567203302639604, 0.49441567177182766, 0.4625230922553436, 0.46431598618287573, 0.5070275658138245, 0.5269221750669579, 0.33732648643132823, 0.33014606863099694, 0.3430736174859941, 0.30338645363123073, 0.3359646608384711, 0.31379357086864956, 0.4064574615617108, 0.3828863910612511, 0.36926610902055423, 0.20738556808605912, 0.21079331245955324, 0.203981110964767, 0.19876212885134437, 0.18961341704427137, 0.18823562704926744, 0.21907791342433314, 0.2067342699585667, 0.18595642479515928, 0.18196180372472792, 0.27563249558672553, 0.35823388408917434, 0.4355279375915073, 0.18864372241553407, 0.2914112892831079, 0.3568475309174437, 0.21163520890185472, 0.23473557370901177, 0.715376834739321, 0.25444507110848913, 0.7296399290953282, 0.8242394935596379, 0.7594289529154479, 0.7915511853656514, 0.18546589532177082, 0.19243404307514123, 0.2079799790641621, 0.2011842632495161, 0.8428923018553961, 0.7294164552877406, 0.20396683955070616, 0.20503188548195317, 0.19083736307449828, 0.8216218377965319, 0.20566707611716495, 0.7850153107199618, 0.1822522873652579, 0.186387746858527, 0.1883673992824756, 0.19608954636986842, 0.18142547492487227, 0.17990476084353946, 0.18323030840562382, 0.17939189385656695, 0.18769871167950247, 0.09090274700420164, 0.07799805436752938, 0.07929211029265937, 0.08160190767761355, 0.08049536401199042, 0.08757363698338505, 0.08449317728988759, 0.07721511517392687, 0.07614163354157921]}, "mutation_prompt": null}
{"id": "420c31c5-b476-4c90-8efd-ac2025306b6b", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 6 * dim  # further reducing population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # slightly adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * (0.5 + np.random.rand() / 2)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A compact variant of Differential Evolution with adaptive mutation and crossover strategies, balancing exploration with budget constraints.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "metadata": {"aucs": [0.8604101107511122, 0.8356284551497423, 0.8657173988030784, 0.8477603560181309, 0.8515936943284856, 0.8494498375206934, 0.8613677020760171, 0.8668245091125429, 0.8553541739882592, 0.7505985276144164, 0.7474115847450862, 0.746697773121326, 0.7595229516689512, 0.7606084778731909, 0.7464397686403881, 0.7696384414885483, 0.7352929156834567, 0.7428688246006268, 0.1497779670615953, 0.12171335907412262, 0.12489034232033158, 0.12292936404110766, 0.30914668457913663, 0.22840579984700815, 0.12506479834758844, 0.12825112069787847, 0.1477667130571042, 0.11857694851907397, 0.11496937456679657, 0.15113257176958173, 0.11402060735102426, 0.1158056191327711, 0.12212016982836649, 0.13360310831850353, 0.12883573842052443, 0.11317202989454367, 0.9727983777181126, 0.9493297416488158, 0.9147309488888306, 0.9783199161268581, 0.9271438138950203, 0.9730049333882211, 0.9546596554546737, 0.9422931167548181, 0.9175313300574669, 0.6176541502404138, 0.594347999730811, 0.6048263132455644, 0.6349099976631112, 0.6562099746726866, 0.6289998411950368, 0.6272939747319326, 0.6431743913740466, 0.6512472195220291, 0.7899557485922579, 0.8415561557187536, 0.808061533935596, 0.8469793814224592, 0.8128537365028776, 0.8328051451741559, 0.8073073665008006, 0.8175027459084098, 0.8224219007348392, 0.467585675269636, 0.5059365376654247, 0.4204877101875625, 0.45829747255816444, 0.5407525109001249, 0.3461052762028428, 0.5774524127497492, 0.4522165981277685, 0.33424222477513665, 0.4223678712133194, 0.2899030649351715, 0.5776129284304985, 0.42020414239874093, 0.4040460311615891, 0.3833052004597579, 0.36329137881683127, 0.4319562059336449, 0.5450893794006297, 0.4992515460189285, 0.5079819581278592, 0.4325378205241657, 0.5073087740444189, 0.5181117830377086, 0.5131125858339277, 0.49853861199967464, 0.4522468871820412, 0.4866184978968172, 0.6414199770798221, 0.6229886641667042, 0.6191183532856165, 0.6126189829239181, 0.6619223879856246, 0.6269273841816716, 0.6294946226841911, 0.6861052042664002, 0.6542869615027032, 0.24029551480380817, 0.2935595528502696, 0.24374801302424487, 0.3435229917057059, 0.38473145987731017, 0.4029812661448, 0.2994813825848689, 0.13907352561818298, 0.23805936493113833, 0.3846960385120599, 0.4279949919964705, 0.38782176337985463, 0.40017438557012375, 0.4171239512585564, 0.4251388548309677, 0.39189092229321143, 0.40113994214901605, 0.40996287859332314, 0.755384550206438, 0.7778828571341556, 0.7616395386992576, 0.7774118340905064, 0.7741881957904504, 0.7599196314410602, 0.7414197527889563, 0.7669773465834868, 0.7608858243837068, 0.12099522984199262, 0.11900150463002879, 0.09373514250534842, 0.09336208736214435, 0.11851386734806857, 0.11980879883762574, 0.09751398585578042, 0.09766220336812881, 0.1051804257435186, 0.15345260008304762, 0.16964524667867065, 0.17953294765253036, 0.16916135766543916, 0.1653756178595691, 0.18766840578362654, 0.14388598862964208, 0.23074634324110832, 0.16802978452801376, 0.42668115317946054, 0.5146610010904235, 0.48751275615197276, 0.46567203302639604, 0.49441567177182766, 0.4625230922553436, 0.46431598618287573, 0.5070275658138245, 0.5269221750669579, 0.33732648643132823, 0.33014606863099694, 0.3430736174859941, 0.30338645363123073, 0.3359646608384711, 0.31379357086864956, 0.4064574615617108, 0.3828863910612511, 0.36926610902055423, 0.20738556808605912, 0.21079331245955324, 0.203981110964767, 0.19876212885134437, 0.18961341704427137, 0.18823562704926744, 0.21907791342433314, 0.2067342699585667, 0.18595642479515928, 0.18196180372472792, 0.27563249558672553, 0.35823388408917434, 0.4355279375915073, 0.18864372241553407, 0.2914112892831079, 0.3568475309174437, 0.21163520890185472, 0.23473557370901177, 0.715376834739321, 0.25444507110848913, 0.7296399290953282, 0.8242394935596379, 0.7594289529154479, 0.7915511853656514, 0.18546589532177082, 0.19243404307514123, 0.2079799790641621, 0.2011842632495161, 0.8428923018553961, 0.7294164552877406, 0.20396683955070616, 0.20503188548195317, 0.19083736307449828, 0.8216218377965319, 0.20566707611716495, 0.7850153107199618, 0.1822522873652579, 0.186387746858527, 0.1883673992824756, 0.19608954636986842, 0.18142547492487227, 0.17990476084353946, 0.18323030840562382, 0.17939189385656695, 0.18769871167950247, 0.09090274700420164, 0.07799805436752938, 0.07929211029265937, 0.08160190767761355, 0.08049536401199042, 0.08757363698338505, 0.08449317728988759, 0.07721511517392687, 0.07614163354157921]}, "mutation_prompt": null}
{"id": "47ae2fc6-acd8-403d-9e55-3c8258a03793", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 6 * dim  # further reducing population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # slightly adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * (0.5 + np.random.rand() / 2)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A compact variant of Differential Evolution with adaptive mutation and crossover strategies, balancing exploration with budget constraints.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "metadata": {"aucs": [0.8604101107511122, 0.8356284551497423, 0.8657173988030784, 0.8477603560181309, 0.8515936943284856, 0.8494498375206934, 0.8613677020760171, 0.8668245091125429, 0.8553541739882592, 0.7505985276144164, 0.7474115847450862, 0.746697773121326, 0.7595229516689512, 0.7606084778731909, 0.7464397686403881, 0.7696384414885483, 0.7352929156834567, 0.7428688246006268, 0.1497779670615953, 0.12171335907412262, 0.12489034232033158, 0.12292936404110766, 0.30914668457913663, 0.22840579984700815, 0.12506479834758844, 0.12825112069787847, 0.1477667130571042, 0.11857694851907397, 0.11496937456679657, 0.15113257176958173, 0.11402060735102426, 0.1158056191327711, 0.12212016982836649, 0.13360310831850353, 0.12883573842052443, 0.11317202989454367, 0.9727983777181126, 0.9493297416488158, 0.9147309488888306, 0.9783199161268581, 0.9271438138950203, 0.9730049333882211, 0.9546596554546737, 0.9422931167548181, 0.9175313300574669, 0.6176541502404138, 0.594347999730811, 0.6048263132455644, 0.6349099976631112, 0.6562099746726866, 0.6289998411950368, 0.6272939747319326, 0.6431743913740466, 0.6512472195220291, 0.7899557485922579, 0.8415561557187536, 0.808061533935596, 0.8469793814224592, 0.8128537365028776, 0.8328051451741559, 0.8073073665008006, 0.8175027459084098, 0.8224219007348392, 0.467585675269636, 0.5059365376654247, 0.4204877101875625, 0.45829747255816444, 0.5407525109001249, 0.3461052762028428, 0.5774524127497492, 0.4522165981277685, 0.33424222477513665, 0.4223678712133194, 0.2899030649351715, 0.5776129284304985, 0.42020414239874093, 0.4040460311615891, 0.3833052004597579, 0.36329137881683127, 0.4319562059336449, 0.5450893794006297, 0.4992515460189285, 0.5079819581278592, 0.4325378205241657, 0.5073087740444189, 0.5181117830377086, 0.5131125858339277, 0.49853861199967464, 0.4522468871820412, 0.4866184978968172, 0.6414199770798221, 0.6229886641667042, 0.6191183532856165, 0.6126189829239181, 0.6619223879856246, 0.6269273841816716, 0.6294946226841911, 0.6861052042664002, 0.6542869615027032, 0.24029551480380817, 0.2935595528502696, 0.24374801302424487, 0.3435229917057059, 0.38473145987731017, 0.4029812661448, 0.2994813825848689, 0.13907352561818298, 0.23805936493113833, 0.3846960385120599, 0.4279949919964705, 0.38782176337985463, 0.40017438557012375, 0.4171239512585564, 0.4251388548309677, 0.39189092229321143, 0.40113994214901605, 0.40996287859332314, 0.755384550206438, 0.7778828571341556, 0.7616395386992576, 0.7774118340905064, 0.7741881957904504, 0.7599196314410602, 0.7414197527889563, 0.7669773465834868, 0.7608858243837068, 0.12099522984199262, 0.11900150463002879, 0.09373514250534842, 0.09336208736214435, 0.11851386734806857, 0.11980879883762574, 0.09751398585578042, 0.09766220336812881, 0.1051804257435186, 0.15345260008304762, 0.16964524667867065, 0.17953294765253036, 0.16916135766543916, 0.1653756178595691, 0.18766840578362654, 0.14388598862964208, 0.23074634324110832, 0.16802978452801376, 0.42668115317946054, 0.5146610010904235, 0.48751275615197276, 0.46567203302639604, 0.49441567177182766, 0.4625230922553436, 0.46431598618287573, 0.5070275658138245, 0.5269221750669579, 0.33732648643132823, 0.33014606863099694, 0.3430736174859941, 0.30338645363123073, 0.3359646608384711, 0.31379357086864956, 0.4064574615617108, 0.3828863910612511, 0.36926610902055423, 0.20738556808605912, 0.21079331245955324, 0.203981110964767, 0.19876212885134437, 0.18961341704427137, 0.18823562704926744, 0.21907791342433314, 0.2067342699585667, 0.18595642479515928, 0.18196180372472792, 0.27563249558672553, 0.35823388408917434, 0.4355279375915073, 0.18864372241553407, 0.2914112892831079, 0.3568475309174437, 0.21163520890185472, 0.23473557370901177, 0.715376834739321, 0.25444507110848913, 0.7296399290953282, 0.8242394935596379, 0.7594289529154479, 0.7915511853656514, 0.18546589532177082, 0.19243404307514123, 0.2079799790641621, 0.2011842632495161, 0.8428923018553961, 0.7294164552877406, 0.20396683955070616, 0.20503188548195317, 0.19083736307449828, 0.8216218377965319, 0.20566707611716495, 0.7850153107199618, 0.1822522873652579, 0.186387746858527, 0.1883673992824756, 0.19608954636986842, 0.18142547492487227, 0.17990476084353946, 0.18323030840562382, 0.17939189385656695, 0.18769871167950247, 0.09090274700420164, 0.07799805436752938, 0.07929211029265937, 0.08160190767761355, 0.08049536401199042, 0.08757363698338505, 0.08449317728988759, 0.07721511517392687, 0.07614163354157921]}, "mutation_prompt": null}
{"id": "925300a6-7c94-4ab8-937b-9482fb083514", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 6 * dim  # further reducing population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # slightly adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * (0.5 + np.random.rand() / 2)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A compact variant of Differential Evolution with adaptive mutation and crossover strategies, balancing exploration with budget constraints.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "metadata": {"aucs": [0.8604101107511122, 0.8356284551497423, 0.8657173988030784, 0.8477603560181309, 0.8515936943284856, 0.8494498375206934, 0.8613677020760171, 0.8668245091125429, 0.8553541739882592, 0.7505985276144164, 0.7474115847450862, 0.746697773121326, 0.7595229516689512, 0.7606084778731909, 0.7464397686403881, 0.7696384414885483, 0.7352929156834567, 0.7428688246006268, 0.1497779670615953, 0.12171335907412262, 0.12489034232033158, 0.12292936404110766, 0.30914668457913663, 0.22840579984700815, 0.12506479834758844, 0.12825112069787847, 0.1477667130571042, 0.11857694851907397, 0.11496937456679657, 0.15113257176958173, 0.11402060735102426, 0.1158056191327711, 0.12212016982836649, 0.13360310831850353, 0.12883573842052443, 0.11317202989454367, 0.9727983777181126, 0.9493297416488158, 0.9147309488888306, 0.9783199161268581, 0.9271438138950203, 0.9730049333882211, 0.9546596554546737, 0.9422931167548181, 0.9175313300574669, 0.6176541502404138, 0.594347999730811, 0.6048263132455644, 0.6349099976631112, 0.6562099746726866, 0.6289998411950368, 0.6272939747319326, 0.6431743913740466, 0.6512472195220291, 0.7899557485922579, 0.8415561557187536, 0.808061533935596, 0.8469793814224592, 0.8128537365028776, 0.8328051451741559, 0.8073073665008006, 0.8175027459084098, 0.8224219007348392, 0.467585675269636, 0.5059365376654247, 0.4204877101875625, 0.45829747255816444, 0.5407525109001249, 0.3461052762028428, 0.5774524127497492, 0.4522165981277685, 0.33424222477513665, 0.4223678712133194, 0.2899030649351715, 0.5776129284304985, 0.42020414239874093, 0.4040460311615891, 0.3833052004597579, 0.36329137881683127, 0.4319562059336449, 0.5450893794006297, 0.4992515460189285, 0.5079819581278592, 0.4325378205241657, 0.5073087740444189, 0.5181117830377086, 0.5131125858339277, 0.49853861199967464, 0.4522468871820412, 0.4866184978968172, 0.6414199770798221, 0.6229886641667042, 0.6191183532856165, 0.6126189829239181, 0.6619223879856246, 0.6269273841816716, 0.6294946226841911, 0.6861052042664002, 0.6542869615027032, 0.24029551480380817, 0.2935595528502696, 0.24374801302424487, 0.3435229917057059, 0.38473145987731017, 0.4029812661448, 0.2994813825848689, 0.13907352561818298, 0.23805936493113833, 0.3846960385120599, 0.4279949919964705, 0.38782176337985463, 0.40017438557012375, 0.4171239512585564, 0.4251388548309677, 0.39189092229321143, 0.40113994214901605, 0.40996287859332314, 0.755384550206438, 0.7778828571341556, 0.7616395386992576, 0.7774118340905064, 0.7741881957904504, 0.7599196314410602, 0.7414197527889563, 0.7669773465834868, 0.7608858243837068, 0.12099522984199262, 0.11900150463002879, 0.09373514250534842, 0.09336208736214435, 0.11851386734806857, 0.11980879883762574, 0.09751398585578042, 0.09766220336812881, 0.1051804257435186, 0.15345260008304762, 0.16964524667867065, 0.17953294765253036, 0.16916135766543916, 0.1653756178595691, 0.18766840578362654, 0.14388598862964208, 0.23074634324110832, 0.16802978452801376, 0.42668115317946054, 0.5146610010904235, 0.48751275615197276, 0.46567203302639604, 0.49441567177182766, 0.4625230922553436, 0.46431598618287573, 0.5070275658138245, 0.5269221750669579, 0.33732648643132823, 0.33014606863099694, 0.3430736174859941, 0.30338645363123073, 0.3359646608384711, 0.31379357086864956, 0.4064574615617108, 0.3828863910612511, 0.36926610902055423, 0.20738556808605912, 0.21079331245955324, 0.203981110964767, 0.19876212885134437, 0.18961341704427137, 0.18823562704926744, 0.21907791342433314, 0.2067342699585667, 0.18595642479515928, 0.18196180372472792, 0.27563249558672553, 0.35823388408917434, 0.4355279375915073, 0.18864372241553407, 0.2914112892831079, 0.3568475309174437, 0.21163520890185472, 0.23473557370901177, 0.715376834739321, 0.25444507110848913, 0.7296399290953282, 0.8242394935596379, 0.7594289529154479, 0.7915511853656514, 0.18546589532177082, 0.19243404307514123, 0.2079799790641621, 0.2011842632495161, 0.8428923018553961, 0.7294164552877406, 0.20396683955070616, 0.20503188548195317, 0.19083736307449828, 0.8216218377965319, 0.20566707611716495, 0.7850153107199618, 0.1822522873652579, 0.186387746858527, 0.1883673992824756, 0.19608954636986842, 0.18142547492487227, 0.17990476084353946, 0.18323030840562382, 0.17939189385656695, 0.18769871167950247, 0.09090274700420164, 0.07799805436752938, 0.07929211029265937, 0.08160190767761355, 0.08049536401199042, 0.08757363698338505, 0.08449317728988759, 0.07721511517392687, 0.07614163354157921]}, "mutation_prompt": null}
{"id": "416e445a-5938-40e7-8b91-e262e532c9cf", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(4, int(4 + 3.5 * np.log(dim)))  # dynamically scaled population size based on dimension\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adjusted for improved exploration\n        self.crossover_rate = 0.9  # increased for better diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * (0.5 + np.random.rand() * 0.7)  # adaptive scaling with increased variability\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy and increased rate\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDifferentialEvolution", "description": "An improved adaptive differential evolution using dynamic population size scaling and adaptive parameter tuning for better convergence.", "configspace": "", "generation": 14, "fitness": 0.19983871946169712, "feedback": "The algorithm AdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "metadata": {"aucs": [0.7470220713291049, 0.3591146471182869, 0.5672761984402694, 0.17433048231669868, 0.29930480741202636, 0.17201111261070257, 0.7974545604533243, 0.2393610023426943, 0.3298440901967218, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11729766992981294, 0.04588388286462253, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005614427585896364, 0.12580455325096318, 0.08017713137866866, 0.10762785379988749, 0.3366209238162393, 0.10254058738197658, 0.09433365560455875, 0.1215377955871727, 0.07320271202680328, 0.09215405787094078, 0.09366026552602125, 0.09164238321538942, 0.1326944825739601, 0.10182585070855588, 0.08840477404674785, 0.1355739388224656, 0.07299574305002265, 0.11026976921837672, 0.03615058501686219, 0.987641548325631, 0.969118027645417, 0.9676008458039767, 0.9917550873199906, 0.9674096142799908, 0.0748551668659233, 0.9783355988223084, 0.9676316269057179, 0.9391249527487473, 0.1950966289567725, 0.26378165865333336, 0.22595977189956562, 0.13502827147824215, 0.13025359722937957, 0.10748357558665556, 0.14595754712326647, 0.09864083297052328, 0.2031296951953162, 0.23428811429629304, 0.11035732815934751, 0.066820292082173, 0.2143146129843091, 0.33726619827184634, 0.2088051323227471, 0.1782207543881248, 0.23276649463122334, 0.18883503222286535, 0.13910511777045176, 0.1193493865022669, 0.23893087665264645, 9.999999999998899e-05, 0.2946654099425522, 0.036227758227646345, 0.28258204817559307, 0.25300494260663187, 0.33259672122164907, 0.17740119495797713, 0.010088425606116447, 0.38557239698827306, 0.15876905738348324, 0.14078126106516042, 0.14499038818082777, 0.16391863972097598, 0.14365591657541932, 0.1295591261308746, 0.013090585420827638, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04671711718046878, 0.02801291018797125, 0.06901745277303895, 0.11465473681925831, 0.04434090612277719, 0.10992115046658946, 0.0849239798558028, 0.18257310074007704, 0.0939176481670223, 0.14977320594482768, 0.03898284824530496, 0.1994090907674193, 0.12687265186275776, 0.1125183080803498, 0.08994475997736096, 0.05503746314233782, 0.04316504994915871, 0.16975826284273732, 0.08601676079560017, 0.09199276124605471, 9.999999999998899e-05, 0.12706281966067012, 0.08519608077902374, 0.009163167487077906, 0.12295467924995396, 0.10509192958666813, 9.999999999998899e-05, 0.12215843824777073, 0.040888852932828734, 9.999999999998899e-05, 0.0618279669652495, 0.050960773841429496, 0.3479170456644807, 0.348986601246849, 0.35860949545041254, 0.16221555859690584, 0.21983345939030086, 0.40877590942115105, 0.2881655207516456, 0.22514427633774514, 0.22582476290906228, 0.09594558095711403, 0.07892619293803438, 0.1162316177761693, 0.11131589047687818, 0.10460290410304518, 0.07758654819823807, 0.08902944546572167, 0.10729953556448968, 0.10225580980626636, 0.22203551668850197, 0.20579891246115334, 0.3377291173734258, 0.19665621956459822, 0.13667408515596924, 0.16534382181236962, 0.18318247889582984, 0.14838620537507063, 0.18434800657518313, 0.20881987858038642, 0.1849808840545254, 0.30235906096750675, 0.23602317571982445, 0.3122128136542234, 0.4503964033991138, 0.45253787089376496, 0.4003507025802552, 0.21951737486297196, 0.2198724200754365, 0.1880628580549526, 0.23383335777146785, 0.20923008173452606, 0.2837447648092808, 0.2061027791898531, 0.26550874684838066, 0.22222359976332506, 0.1186701148593422, 0.21984651376583408, 0.2561330187590901, 0.2116069083085017, 0.20163985764808656, 0.23784547392649347, 0.21548157919636202, 0.257330999692285, 0.2065658548530127, 0.19791756984948583, 0.18173770024639402, 0.17508323841715023, 0.18903140680239328, 0.21150045288541242, 0.1784391920006898, 0.19950943187299286, 0.25356001364006253, 0.1933579007107291, 0.2266051551999988, 0.16823700733358216, 0.1660812735306757, 0.15888324367874518, 0.8721353985365263, 0.18917340438480612, 0.19203253471084825, 0.26876841436906596, 0.16320551014263196, 0.14766776322547015, 0.43854070418089863, 0.15420735673043073, 0.11209865630876703, 0.1697592577659056, 0.16475447909134944, 0.1667652074246233, 0.1992312183802084, 0.11734392299562424, 0.15982837728703203, 0.18919872352608647, 0.18883464377911796, 0.1914142957332875, 0.19608143676739676, 0.19365769214805262, 0.1797486884266054, 0.19365633165487528, 0.19272277532502036, 0.19449387880228974, 0.09808052501484821, 0.08582624813586226, 0.10427449452147453, 0.1221672476544472, 0.07703440346914359, 0.0897737163794109, 0.10045657603827918, 0.08451741773708532, 0.09739675427296335]}, "mutation_prompt": null}
{"id": "89b8bbc8-d4d4-4dfd-8c72-af813a3bf316", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 6 * dim  # further reducing population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # slightly adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * (0.5 + np.random.rand() / 2)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A compact variant of Differential Evolution with adaptive mutation and crossover strategies, balancing exploration with budget constraints.", "configspace": "", "generation": 8, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "metadata": {"aucs": [0.8604101107511122, 0.8356284551497423, 0.8657173988030784, 0.8477603560181309, 0.8515936943284856, 0.8494498375206934, 0.8613677020760171, 0.8668245091125429, 0.8553541739882592, 0.7505985276144164, 0.7474115847450862, 0.746697773121326, 0.7595229516689512, 0.7606084778731909, 0.7464397686403881, 0.7696384414885483, 0.7352929156834567, 0.7428688246006268, 0.1497779670615953, 0.12171335907412262, 0.12489034232033158, 0.12292936404110766, 0.30914668457913663, 0.22840579984700815, 0.12506479834758844, 0.12825112069787847, 0.1477667130571042, 0.11857694851907397, 0.11496937456679657, 0.15113257176958173, 0.11402060735102426, 0.1158056191327711, 0.12212016982836649, 0.13360310831850353, 0.12883573842052443, 0.11317202989454367, 0.9727983777181126, 0.9493297416488158, 0.9147309488888306, 0.9783199161268581, 0.9271438138950203, 0.9730049333882211, 0.9546596554546737, 0.9422931167548181, 0.9175313300574669, 0.6176541502404138, 0.594347999730811, 0.6048263132455644, 0.6349099976631112, 0.6562099746726866, 0.6289998411950368, 0.6272939747319326, 0.6431743913740466, 0.6512472195220291, 0.7899557485922579, 0.8415561557187536, 0.808061533935596, 0.8469793814224592, 0.8128537365028776, 0.8328051451741559, 0.8073073665008006, 0.8175027459084098, 0.8224219007348392, 0.467585675269636, 0.5059365376654247, 0.4204877101875625, 0.45829747255816444, 0.5407525109001249, 0.3461052762028428, 0.5774524127497492, 0.4522165981277685, 0.33424222477513665, 0.4223678712133194, 0.2899030649351715, 0.5776129284304985, 0.42020414239874093, 0.4040460311615891, 0.3833052004597579, 0.36329137881683127, 0.4319562059336449, 0.5450893794006297, 0.4992515460189285, 0.5079819581278592, 0.4325378205241657, 0.5073087740444189, 0.5181117830377086, 0.5131125858339277, 0.49853861199967464, 0.4522468871820412, 0.4866184978968172, 0.6414199770798221, 0.6229886641667042, 0.6191183532856165, 0.6126189829239181, 0.6619223879856246, 0.6269273841816716, 0.6294946226841911, 0.6861052042664002, 0.6542869615027032, 0.24029551480380817, 0.2935595528502696, 0.24374801302424487, 0.3435229917057059, 0.38473145987731017, 0.4029812661448, 0.2994813825848689, 0.13907352561818298, 0.23805936493113833, 0.3846960385120599, 0.4279949919964705, 0.38782176337985463, 0.40017438557012375, 0.4171239512585564, 0.4251388548309677, 0.39189092229321143, 0.40113994214901605, 0.40996287859332314, 0.755384550206438, 0.7778828571341556, 0.7616395386992576, 0.7774118340905064, 0.7741881957904504, 0.7599196314410602, 0.7414197527889563, 0.7669773465834868, 0.7608858243837068, 0.12099522984199262, 0.11900150463002879, 0.09373514250534842, 0.09336208736214435, 0.11851386734806857, 0.11980879883762574, 0.09751398585578042, 0.09766220336812881, 0.1051804257435186, 0.15345260008304762, 0.16964524667867065, 0.17953294765253036, 0.16916135766543916, 0.1653756178595691, 0.18766840578362654, 0.14388598862964208, 0.23074634324110832, 0.16802978452801376, 0.42668115317946054, 0.5146610010904235, 0.48751275615197276, 0.46567203302639604, 0.49441567177182766, 0.4625230922553436, 0.46431598618287573, 0.5070275658138245, 0.5269221750669579, 0.33732648643132823, 0.33014606863099694, 0.3430736174859941, 0.30338645363123073, 0.3359646608384711, 0.31379357086864956, 0.4064574615617108, 0.3828863910612511, 0.36926610902055423, 0.20738556808605912, 0.21079331245955324, 0.203981110964767, 0.19876212885134437, 0.18961341704427137, 0.18823562704926744, 0.21907791342433314, 0.2067342699585667, 0.18595642479515928, 0.18196180372472792, 0.27563249558672553, 0.35823388408917434, 0.4355279375915073, 0.18864372241553407, 0.2914112892831079, 0.3568475309174437, 0.21163520890185472, 0.23473557370901177, 0.715376834739321, 0.25444507110848913, 0.7296399290953282, 0.8242394935596379, 0.7594289529154479, 0.7915511853656514, 0.18546589532177082, 0.19243404307514123, 0.2079799790641621, 0.2011842632495161, 0.8428923018553961, 0.7294164552877406, 0.20396683955070616, 0.20503188548195317, 0.19083736307449828, 0.8216218377965319, 0.20566707611716495, 0.7850153107199618, 0.1822522873652579, 0.186387746858527, 0.1883673992824756, 0.19608954636986842, 0.18142547492487227, 0.17990476084353946, 0.18323030840562382, 0.17939189385656695, 0.18769871167950247, 0.09090274700420164, 0.07799805436752938, 0.07929211029265937, 0.08160190767761355, 0.08049536401199042, 0.08757363698338505, 0.08449317728988759, 0.07721511517392687, 0.07614163354157921]}, "mutation_prompt": null}
{"id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 16, "fitness": 0.4497236980515024, "feedback": "The algorithm CompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.30.", "error": "", "parent_id": "8a6c33b7-4771-4f1b-a1dc-c88183be2efc", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "7d1a209f-1fab-4beb-8072-6753a152288a", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Multi-phase local search\n                if np.random.rand() < 0.2:  # 20% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "A refined differential evolution algorithm incorporating adaptive mutation, crossover rates, and probabilistic multi-phase local search for enhanced robustness.", "configspace": "", "generation": 17, "fitness": 0.3770496554349589, "feedback": "The algorithm RefinedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.877761650394682, 0.8858334751883622, 0.8939178126756906, 0.9164370065330515, 0.9002119149239748, 0.9129454361482935, 0.8905034762898594, 0.8838513729653122, 0.8985107665315546, 0.8285116586665853, 0.838472835313678, 0.8393800025858924, 0.8344825537945444, 0.8321439823177071, 0.7989425972032086, 0.8310061071719457, 0.8307909196076592, 0.8284423965691745, 0.10870318966797843, 0.11968742757186612, 0.10119769203855755, 0.23464140633566033, 0.11160673661542986, 0.13239089490954903, 0.11089042880278033, 0.10395917862012027, 0.12762004975594377, 0.11336287218624386, 0.12067924514832595, 0.1015910286669951, 0.11931271955679024, 0.09985807725747387, 0.13060187773236354, 0.09630851570282817, 0.10042135167198851, 0.1303724274052911, 0.9755235520695403, 0.9421407551409109, 0.9770606298275457, 0.9771442856052254, 0.9676555843409731, 0.966860754740969, 0.9714146447602983, 0.9288512556316694, 0.9875907900441057, 0.7046172796976184, 0.6473334702761178, 0.6691085088443955, 0.639900911774874, 0.6353843501946543, 0.44422514432295923, 0.7088463087611165, 0.6309191750132503, 0.555325389983188, 0.8289593144514829, 0.8878326278443998, 0.2227104531832026, 0.8675537581121513, 0.820378150210912, 0.211972137587648, 0.8224709543166753, 0.8482067123829851, 0.23170168131058333, 0.19751667571265275, 0.24658724763590967, 0.20241219270992694, 0.22157232982483688, 0.20471318640490477, 0.1242468656434037, 0.18392749231917938, 0.1833013518292279, 0.19952582095356308, 0.1948870930367399, 0.15238322891358347, 0.2044699227163166, 0.21111171192479772, 0.17966607621547315, 0.22019264896564084, 0.2074155300372248, 0.6315896285101948, 0.2007506070394547, 0.08387434673391381, 0.10424272797594603, 0.1324028567811958, 0.22785586721421658, 0.12212631343904146, 0.2799814124939236, 0.1665505091267896, 0.25687258146813274, 0.09851323700792514, 0.1777896040291964, 0.19033455068577743, 0.2660216942116177, 0.16005259061095733, 0.12266006781649152, 0.44182246050924834, 0.11524194623880013, 0.17430166761754684, 0.3573485750475045, 0.0870259068316731, 0.29255218862863897, 0.218401439353907, 0.15387356474411662, 0.23385807268230463, 0.3257550573693091, 0.1318848622297879, 0.2346837132491858, 0.09038066795182353, 0.40512394845405086, 0.3496010025976536, 0.3408901927517277, 0.3780878670825255, 0.4424552870621923, 0.5207697457966054, 0.29948073781107554, 0.303335873159445, 0.3973010185079956, 0.8438704836481739, 0.8342974287559564, 0.8174354276767344, 0.693543336101272, 0.7594123329674881, 0.6580502269167916, 0.8293877179525341, 0.8205972350302493, 0.6827212113462422, 0.0999695667545849, 0.10162503956343649, 0.10741707343339002, 0.1101612831585349, 0.09571690920138376, 0.09396340260639702, 0.11210764973534093, 0.10311276828514815, 0.08704946172376038, 0.6148850008253246, 0.129769899654819, 0.15113557583604875, 0.15935405793378488, 0.2389491801201027, 0.24579538862576145, 0.1944809458113549, 0.24482366436245373, 0.2282209732596432, 0.5589190039075491, 0.578370845717861, 0.5967706377669133, 0.4837495205205984, 0.5946338593287055, 0.5976823554188267, 0.4387964939984439, 0.6511356812839302, 0.6424942994306057, 0.49876772253554724, 0.40996332160920845, 0.3972503449528394, 0.41893714622463996, 0.4982045636023902, 0.39344293309692213, 0.31017280155067894, 0.5118276040507306, 0.379900087616445, 0.214684892147055, 0.20185354158338997, 0.19720679869306235, 0.21737125824517733, 0.23835094152558378, 0.19167842446159933, 0.1819669073318092, 0.1822085020423322, 0.2002454376812799, 0.36493738466147874, 0.2322099277268309, 0.22739890992917156, 0.23299913897517943, 0.21116512977036783, 0.19487854998813214, 0.21194837414479184, 0.17553225786349924, 0.20678314867384073, 0.8548063839783341, 0.8989755930590964, 0.1926387424724596, 0.1651218705882257, 0.18538466765589479, 0.751267398669639, 0.12260937255272497, 0.7354603575447369, 0.16546081568508886, 0.16551597958181896, 0.16740913809864455, 0.15556359778406914, 0.20636189261981508, 0.16708128405157985, 0.1656036055895791, 0.20856057596883315, 0.20980125614010414, 0.15458875953915763, 0.18265263434974255, 0.19119580640705625, 0.18289798625762554, 0.20130563934579893, 0.18537479416766423, 0.19376771923983538, 0.18686307229357513, 0.21498851655325213, 0.18823259949530224, 0.08156690275582423, 0.08073329253898331, 0.08753257543280157, 0.07811844778848887, 0.08157414537167096, 0.08566775909942592, 0.07687716625936614, 0.07914277781235701, 0.08296702723634009]}, "mutation_prompt": null}
{"id": "1cb2c210-6a2c-4098-9e82-35bab04ec532", "solution": "import numpy as np\n\nclass AdaptiveDifferentialEvolutionWithRestart:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # slightly reduced mutation factor\n        self.crossover_rate = 0.85  # adjusted crossover rate for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.evaluations = 0\n\n    def __call__(self, func):\n        self.initialize_fitness(func)\n        \n        while self.evaluations < self.budget:\n            for i in range(self.pop_size):\n                if self.evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                self.evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Periodic restart for diversity\n                if self.evaluations % (self.budget // 5) == 0:  # restart every 20% of the budget\n                    self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n                    self.initialize_fitness(func)\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]\n\n    def initialize_fitness(self, func):\n        for i in range(self.pop_size):\n            if self.evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            self.evaluations += 1", "name": "AdaptiveDifferentialEvolutionWithRestart", "description": "A novel enhanced Differential Evolution with adaptive learning and periodic restart strategy for diverse exploration.", "configspace": "", "generation": 18, "fitness": 0.3706270209860196, "feedback": "The algorithm AdaptiveDifferentialEvolutionWithRestart got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.9235747942539327, 0.9164414968983274, 0.9252958503328722, 0.9164408814642279, 0.9135716735722038, 0.914980546955219, 0.9102883412651828, 0.7763896625014793, 0.9160300744978324, 0.7627835326785987, 0.7076920228384072, 0.7033159019228635, 0.7788424105218184, 0.7643098591531894, 0.7234192386419778, 0.7756689393595279, 0.777500778871429, 0.7817926804857775, 0.10754417901641045, 0.12926091593063482, 0.14232028292307108, 0.11875567444572299, 0.12472834838153124, 0.12784118996320482, 0.12732465559834605, 0.14609240209809105, 0.11814040163068562, 0.10712033380526631, 0.13028620230612287, 0.11361648150507975, 0.10619172896644014, 0.1396113419760291, 0.10791977182580503, 0.11054592421553067, 0.11975300373509867, 0.11481547538873615, 0.9574073825312757, 0.9228888657595542, 0.989780982502882, 0.9674851535953962, 0.9818018813761271, 0.9884414974021334, 0.9077302750800202, 0.9433757204638191, 0.964970510528445, 0.39777699150891377, 0.3624920054912094, 0.38657523077504763, 0.4436591433546885, 0.4489193329032032, 0.38228976036306783, 0.41925941973137637, 0.3709565800479532, 0.43928021515551696, 0.9181977937032255, 0.7082222911088443, 0.56394648156057, 0.9085649050755559, 0.9166841199308982, 0.9156469474137918, 0.8955975981284011, 0.7477309348628534, 0.8774968618771137, 0.2353474763210055, 0.25520560824456906, 0.3075251081550777, 0.20314581080919358, 0.17832893181901777, 0.24351348968366804, 0.2932598577729002, 0.2800391916839532, 0.23001066754766575, 0.30103736014024274, 0.18390754632743667, 0.32613958220127015, 0.23244724064484534, 0.20759512632275146, 0.1853971322897986, 0.18378408850841577, 0.22512266138248982, 0.27814206235434114, 0.17771641218877465, 0.18757971802414775, 0.18491724431986434, 0.12837629612911383, 0.25700525852928546, 0.31596344365610807, 0.3191327005548533, 0.3505890869813517, 0.11522690745813002, 0.36487365128392435, 0.3567264227584839, 0.33565858410155525, 0.20737895696123632, 0.3375871951974404, 0.15145058983521908, 0.40461463113863205, 0.3782775381503174, 0.3125409823689117, 0.13742102737861717, 0.16313189423950303, 0.22853697410189444, 0.11049864206001525, 0.19639036346793348, 0.19654585002761038, 0.15958443856313076, 0.14658067923759466, 0.13983022194882944, 0.2600076303952956, 0.2525300952984044, 0.25487735776973264, 0.29969801365147, 0.27836897391794635, 0.2580654112998374, 0.22262675696936385, 0.17816585937318374, 0.22954981312174272, 0.59647172707753, 0.6642122297094393, 0.6822170827439942, 0.6268472161924468, 0.6613782402078372, 0.7455683411843959, 0.6549283575078582, 0.7002873131269791, 0.6308777840954636, 0.10657756606074509, 0.11721132006535495, 0.11636754122329462, 0.10585939932613453, 0.10275602235016013, 0.09889339427848898, 0.09096813592726816, 0.10825917440544908, 0.09646383410520853, 0.20221876549398354, 0.14806215091259256, 0.18420322336831796, 0.19951406691872253, 0.17427944845730237, 0.12931716489322098, 0.1962160285485175, 0.15067404529934336, 0.1811765434984981, 0.3649659623797362, 0.3801097239649911, 0.4350858206728636, 0.3957590888190965, 0.38037459020462516, 0.3633922701865935, 0.41289770867160047, 0.41917093695939356, 0.4624989079462567, 0.2537679281315227, 0.2987244626211163, 0.29833644443288665, 0.30746957019728216, 0.2863123175381741, 0.34565558454500034, 0.3311390758061944, 0.36682529065638336, 0.29963157608675517, 0.19495921468980382, 0.19106903173805923, 0.2022662354669965, 0.2100262337497163, 0.19417842226133175, 0.18330940107562155, 0.21661877564981846, 0.20836715443261733, 0.21469623911148694, 0.21597947575705145, 0.24235950300491205, 0.39407937233043777, 0.19448366385353488, 0.20951744120216576, 0.22682492900173656, 0.3337860543626048, 0.23546270761443555, 0.20942863632515396, 0.9091958446645024, 0.3372344310621309, 0.9124557514992854, 0.7494467703444834, 0.3277758112731711, 0.5775931001864847, 0.6788796347059758, 0.21396842543077887, 0.5219616324427689, 0.6994156133739968, 0.3746831664500543, 0.4786960140168448, 0.44048727376064845, 0.4712652428140377, 0.20614238248900985, 0.211790057731847, 0.47826006410822863, 0.3366184237720047, 0.18510786383911226, 0.19248623844748813, 0.170933693031889, 0.18308407651171998, 0.18677657272425652, 0.18344277876350756, 0.19244426445052143, 0.19976363121003948, 0.18931212842760736, 0.0796469755398832, 0.07550226416903694, 0.08600666552806413, 0.07753076629577005, 0.09923556241107767, 0.07468813676330788, 0.07849064428308627, 0.08358518631838274, 0.08483312888607741]}, "mutation_prompt": null}
{"id": "f9bc4319-6771-4803-ac78-4d1ccac3425d", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "f5d35283-6bc6-4f3e-95d3-c9e796c5c92e", "solution": "import numpy as np\n\nclass EnhancedCompactDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 3 * dim  # further reduced population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adjusted mutation factor for balance\n        self.crossover_rate = 0.85  # adjusted crossover rate for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with enhanced mutation factor\n                F = self.mutation_factor * np.random.uniform(0.6, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with enhanced strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Enhanced stochastic local search\n                if np.random.rand() < 0.2:  # increased chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedCompactDifferentialEvolution", "description": "A compact Differential Evolution variant with enhanced mutation and crossover strategies combined with adaptive local search for robust optimization.", "configspace": "", "generation": 20, "fitness": 0.367029348391445, "feedback": "The algorithm EnhancedCompactDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.9076854637916049, 0.8861085796221372, 0.8980799944164959, 0.9021429667977148, 0.8975134782863865, 0.9317984738559958, 0.9011130976083735, 0.8917164076181625, 0.9072676340913531, 0.8550745498464651, 0.8233908575917726, 0.8400549716382706, 0.8477667261668103, 0.8436875772479067, 0.8547516936187562, 0.838141153837834, 0.8492886433179319, 0.846472518706799, 0.09861986467271999, 0.1350687810150426, 0.1568336588067497, 0.14054704461788037, 0.14822818523235615, 0.1601424500477071, 0.11447367707979261, 0.1159266055209357, 0.10359816620753803, 0.1006047894480051, 0.1086335473099369, 0.13785387216843714, 0.1312712065585736, 0.11178078328726881, 0.11428987298364679, 0.1099926172868616, 0.10878754739959007, 0.11317589381089987, 0.9418085781453367, 0.9796918466184629, 0.9584649193887105, 0.9441563505509194, 0.9753585166081005, 0.9559891378341095, 0.9378717638387545, 0.9418632782848045, 0.972228680741536, 0.7394515591587749, 0.6840557684262929, 0.7366859055411739, 0.7310403892572566, 0.7015608419794052, 0.730282585413498, 0.7586940169713974, 0.7432396395515748, 0.705681337763689, 0.8477087973286521, 0.8643204172429598, 0.877160906506322, 0.9069839957641302, 0.4553261506609785, 0.8706097985720678, 0.8590174096847338, 0.6842567031843052, 0.8868105965990827, 0.20206242199130797, 0.2563663487700859, 0.2503151374420173, 0.2575744612279378, 0.20744010783660916, 0.19628913264820336, 0.23453246284317442, 0.1771086170554389, 0.23714013895039077, 0.24202938461674328, 0.42284758726611493, 0.11342668123629829, 0.6262970167977926, 0.5925818917037857, 0.20420553327247049, 0.18395691085938903, 0.4575221059867899, 0.20425885335035987, 0.07463456554916814, 0.07471073095746161, 0.0018135425703269537, 0.16333221667236197, 0.10480734697821537, 0.11317664862571619, 0.21242134970957482, 0.08237512597859242, 0.23608937467683833, 0.12040048452447627, 0.2330344923760146, 0.18649321677774477, 0.1586909346594646, 0.15029621053976316, 0.06726081975172327, 0.23605533542379176, 0.22653574830063672, 0.17410110290497305, 0.23007878962212858, 0.07890823919123979, 0.1388889100468399, 0.1796716450264274, 0.11009776235561242, 0.16537380426437798, 0.18450285090035412, 0.1356408869097251, 0.13416831282950648, 0.4073664545657678, 0.35695275054111575, 0.2959173535171954, 0.5271263637462111, 0.35137306428324966, 0.35575245470559935, 0.32838814181581133, 0.32156906568196164, 0.1550191473073188, 0.7488353604053359, 0.6833555792640957, 0.8093551701036045, 0.6003877204000626, 0.5723917806738145, 0.5783132922536479, 0.7037141543411978, 0.5589653915241336, 0.6020919234069846, 0.09203437964572625, 0.08912678996947487, 0.09024705059699734, 0.08991553528150653, 0.1028258277192543, 0.10938922563200615, 0.09560580794850071, 0.08173546651833208, 0.08935732755283665, 0.1559524455447936, 0.14771267282822376, 0.15127882010170413, 0.17977744647546534, 0.18242576478804096, 0.1912885718294498, 0.19721705160845127, 0.20593144650625306, 0.2589401324417345, 0.5333791121857168, 0.5367101408492194, 0.4003819508198646, 0.6280669224361607, 0.5592024972871851, 0.6514911419538947, 0.5873193357078499, 0.644608913776068, 0.5959808934180795, 0.34950786008212886, 0.26058338650751756, 0.3913117688387534, 0.4197235900198678, 0.20922431919625917, 0.3481227749982222, 0.5505361706817021, 0.6023894046477135, 0.5336387581888304, 0.1981841706573212, 0.21710605662450078, 0.19331922153840964, 0.19167949530963002, 0.20192135449640702, 0.20480570159735, 0.18180687258624206, 0.18768804440710274, 0.19263785767650454, 0.22140390671111865, 0.2086413660375862, 0.21524320888809723, 0.4224138585871028, 0.22468882068586182, 0.18353673727081965, 0.20254817794696078, 0.620708273996521, 0.23490668406856163, 0.18484384403786658, 0.20070857920815333, 0.1526399785893544, 0.1879768654025794, 0.19585157267810493, 0.16702702701208982, 0.13208129851238393, 0.1622317549537976, 0.15843370474430307, 0.1666452401986206, 0.10702807163025774, 0.1643409584540486, 0.12190306213418534, 0.16093581507715649, 0.16880438426857325, 0.21187924264966418, 0.15586481977925448, 0.11325308019667013, 0.19631660534359363, 0.18375101518523174, 0.17976440033171004, 0.1778873776927672, 0.185401751083483, 0.1811816430021358, 0.20747328943318222, 0.2105948694837907, 0.1892243965730258, 0.08311392012498997, 0.07806811922827606, 0.08931366688594555, 0.07921681205460318, 0.0847669355716284, 0.07801629735165205, 0.07596641680893823, 0.06941047286740631, 0.08164779668600708]}, "mutation_prompt": null}
{"id": "3f77fe39-34db-4cfa-a004-88f63970305f", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "e49dafbe-0990-4440-b3c7-5fd9f0e0429c", "solution": "import numpy as np\n\nclass EnhancedDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8 + 0.2 * np.random.rand()  # dynamic mutation factor for enhanced adaptability\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with dynamic mutation factor\n                F = self.mutation_factor * np.random.normal(0.5, 1.1)  # dynamic scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Multi-stage local search\n                if np.random.rand() < 0.15:  # 15% chance for extended local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n                    else:\n                        finer_vector = local_vector + np.random.normal(0, 0.05, self.dim)\n                        finer_vector = np.clip(finer_vector, self.bounds[0], self.bounds[1])\n                        finer_fitness = func(finer_vector)\n                        evaluations += 1\n                        if finer_fitness < local_fitness:\n                            self.population[i] = finer_vector\n                            self.fitness[i] = finer_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedDynamicDifferentialEvolution", "description": "A refined Differential Evolution with dynamic parameter adjustments and multi-stage local search for enhanced adaptability and convergence.", "configspace": "", "generation": 22, "fitness": 0.32034736123923196, "feedback": "The algorithm EnhancedDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.25.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.799847097530734, 0.8161556877773167, 0.7835164100214773, 0.8355359504916183, 0.838042917487828, 0.8107310266589907, 0.8142789009065918, 0.8168593563451186, 0.8342014943958955, 0.6703933921516532, 0.5226390211191985, 0.6010307880300552, 0.6190966006293289, 0.5789951625145047, 0.5838377337801182, 0.576626978864172, 0.551798734759243, 0.5979918988640763, 0.11960855931638559, 0.13359764473787505, 0.12508402938323893, 0.115183775289868, 0.1354670827013431, 0.14575086611496701, 0.1288903229122207, 0.14414393406006132, 0.11696766140104298, 0.09440739819726385, 0.1068391483265776, 0.1119076911257918, 0.1177689443218527, 0.1013104814911363, 0.10048783901763403, 0.11066201902071848, 0.11911938173508474, 0.10076126298288424, 0.9609908517419916, 0.9375761353900907, 0.9503713548757825, 0.9732948527945442, 0.9543069755556601, 0.9842714092214904, 0.9938308569982995, 0.9450162995678826, 0.9351755152308617, 0.40813938387879267, 0.4340051304377949, 0.48959552648570703, 0.41221914900728107, 0.45201128337206564, 0.43078923088670407, 0.41066194290047564, 0.37339365309194006, 0.41104697884916863, 0.6820059338594902, 0.6763063995779741, 0.6270897246769362, 0.6677571885398899, 0.8135304734710513, 0.6384022883647966, 0.7710951139681744, 0.49941226811808936, 0.5991005941069072, 0.29554713545289146, 0.13028154019105675, 0.2805750291501734, 0.12884865387725586, 0.3319203384321402, 0.2629198488429, 0.13281028327987643, 0.12196752268376199, 0.25853450393545685, 0.16011024390171735, 0.1773664235398401, 0.11892403101836557, 0.2408338232020263, 0.23905727552906542, 0.20318013351424025, 0.36308125996834184, 0.26564340024812083, 0.2276118989852146, 0.10469563375591806, 0.058059439578960204, 0.08134385047526083, 0.09388702549638783, 0.22984035952047988, 0.06194193709723461, 0.05627892102487764, 0.021212964207076745, 0.19600492882821674, 0.13888117236910513, 0.1729167768136145, 0.18153729351264702, 0.1780473463713783, 0.19238325583734872, 0.10619052476840496, 0.13767070199986242, 0.25931036130340857, 0.10400498380821332, 0.03789532781635607, 0.06920628876596147, 0.13905901346594074, 0.15986674090973996, 0.07521263012623824, 0.13377164920997842, 0.19373542985969028, 0.14945290188057225, 0.14945240247910352, 0.21144109343295858, 0.2121568001560108, 0.2882968274494432, 0.2978773309370877, 0.22273512680718577, 0.2750855753328929, 0.2815474916498715, 0.2613679118453559, 0.18825686782266315, 0.7112235488224203, 0.5520339730038375, 0.6459094749658982, 0.5766099576013428, 0.503223065978704, 0.5924238122781628, 0.65154573186967, 0.6334638206535277, 0.5882157383016997, 0.11076106273076403, 0.09469467518575381, 0.12104986159861619, 0.10523750799529041, 0.09115417453485275, 0.09123242419970923, 0.08431771905407492, 0.10613485660669375, 0.09335765542848184, 0.18446870294180695, 0.1532275640216143, 0.14895577767407453, 0.1433764313190422, 0.2111375987904237, 0.13856135412098325, 0.2525659703811117, 0.2025640362401563, 0.2761454829194323, 0.331078712088934, 0.3890622981141364, 0.3988174643483454, 0.3445808677258405, 0.33767410366393, 0.36123830492220177, 0.4385827261141163, 0.34454750918269406, 0.33557301667088435, 0.25963290433304054, 0.28226088149507456, 0.2544452053909313, 0.25025182186606376, 0.2347721791131403, 0.2944130194217509, 0.29488725325381915, 0.28615044671092915, 0.2813713325863215, 0.1908771813378528, 0.1766862849396008, 0.18752658732683947, 0.18797102135106603, 0.1865418943249978, 0.18084702232506833, 0.2022719292730113, 0.17659441709881651, 0.22823825793018138, 0.3858924821787564, 0.2129320770723806, 0.20579459286727997, 0.21761854819616155, 0.20472147073458058, 0.2012872101288643, 0.6123286328860336, 0.20641009144773992, 0.19513422033214445, 0.8831603127300275, 0.196566751562536, 0.839678888362609, 0.11727071850289217, 0.13073184029768947, 0.16267873282305167, 0.15078416701798014, 0.6887487384971196, 0.14460609132478808, 0.6655541365223383, 0.16741320596179343, 0.2024483929907892, 0.16155265476478997, 0.15175755819876957, 0.6178361338433156, 0.21089813424195059, 0.2099407768472421, 0.21065193873514731, 0.19608665822641258, 0.18438692014228852, 0.1856325317236468, 0.18965350238372436, 0.21593195834614898, 0.1987232087138986, 0.2111306336890767, 0.20004661060760787, 0.1905858808519586, 0.07811607214098437, 0.07545413081075636, 0.07515501105616862, 0.0805614222358414, 0.07320374821646491, 0.08291926124200377, 0.07570916910125669, 0.07634675880672259, 0.07972948628104715]}, "mutation_prompt": null}
{"id": "ab047e3a-2bb6-4e93-9d03-93f97d52c235", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "f6afe347-5858-4936-813d-df23ec8796b9", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "257ca8ec-d5cc-404e-9b06-c9af26a14fb5", "solution": "import numpy as np\n\nclass SelfTuningCompactDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # dynamically adjusted population size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # self-tuning mutation factor\n        self.crossover_rate = 0.85  # adjusted crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.2)  # enhanced scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with enhanced strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Elitist local search\n                if np.random.rand() < 0.15:\n                    elite_vector = self.population[np.argmin(self.fitness)]\n                    local_vector = elite_vector + np.random.normal(0, 0.05, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Dynamically scale population size\n            if evaluations % (self.budget // 10) == 0:\n                self.pop_size = max(4 * self.dim, self.pop_size - 1)\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "SelfTuningCompactDifferentialEvolution", "description": "A novel self-tuning compact Differential Evolution with adaptive mutation and crossover, enhanced by local elitism and dynamic population scaling.", "configspace": "", "generation": 25, "fitness": 0.3876979566324718, "feedback": "The algorithm SelfTuningCompactDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.904438969314098, 0.9201397066752129, 0.8969646014202517, 0.8919862749102518, 0.8934823057288019, 0.9043404837828097, 0.8960384334091456, 0.8979791032127952, 0.9194418446232532, 0.772795609281161, 0.7288563801361918, 0.748861546509332, 0.7546945580034241, 0.7644993803005693, 0.7513200110806626, 0.7117343762239401, 0.7432070214823466, 0.7562269221156518, 0.0839887670708318, 0.11345940385128728, 0.0938622029297298, 0.187581823304387, 0.11870770499011019, 0.06894199906458709, 0.08353679886956855, 0.11911692327600998, 0.14710276283178814, 0.09711963486252584, 0.034301361323880175, 0.14690007175810638, 0.10181757619644827, 0.13357036565864544, 0.07101913258576098, 0.10027432165058758, 0.08082666278722683, 0.05784523746304515, 0.9525103798926663, 0.9902526346471192, 0.9767207706980298, 0.9843125676231123, 0.9793226257099934, 0.9691572176879183, 0.9656021682483482, 0.9727611632909814, 0.9772246458098092, 0.701369483396716, 0.7498392531837591, 0.7073285818253406, 0.752295149108576, 0.6970791661909943, 0.6982326983851689, 0.7305531817944145, 0.6984753718903272, 0.7465650056110184, 0.8022329130563156, 0.09925940446962811, 0.14087376155375408, 0.2150614438937909, 0.5045813129527822, 0.2474581405175662, 0.13045749946510166, 0.130787649778627, 0.15007267928480195, 0.7253963954418393, 0.6809496317395043, 0.49596257236121066, 0.13589080546564858, 0.49623456542688227, 0.46468619278341516, 0.49526506407281035, 0.13091909417329717, 0.5053351767113963, 0.5467206237001732, 0.5019765919364818, 0.5714350366762186, 0.5076108039127819, 0.6755261210158903, 0.5328443746181386, 0.6569448754920715, 0.6004097898244174, 0.5308275739874548, 0.4098625386626028, 0.2707813422167399, 0.18945935401745995, 0.380918871072945, 0.14027567621598425, 0.163201420019634, 0.384860146261629, 0.27590871203512835, 0.5316462380164629, 0.4689672789941921, 0.14648406427149074, 0.31141803826803094, 0.21014366042004007, 0.14261017558441202, 0.41957561102577934, 0.4684855281883189, 0.17982443843344498, 0.5504382489782427, 0.14201109480795227, 0.10995644521384496, 0.08551351607805535, 0.15685747883693024, 0.27118118301537253, 0.15174709777238116, 0.12954251770059055, 0.3045543337999912, 0.1045786081405482, 0.43390475511776494, 0.33411852697833, 0.4018612088271396, 0.38266053099342057, 0.48293050589019426, 0.45940983995348117, 0.4171251092601679, 0.3885707654972076, 0.459601894508436, 0.7923615962931592, 0.7798213821484618, 0.8158092758198495, 0.808061431122134, 0.8018781940604338, 0.8087851009851961, 0.7831777616803242, 0.8327453530819844, 0.8318236705138035, 0.11930017816804228, 0.07133489900613299, 0.07313421952056309, 0.09558203830002909, 0.07770901301790911, 0.09821867773918058, 0.08062251753735872, 0.09407876207657395, 0.11378559186254444, 0.29688576209509954, 0.28157871656813616, 0.24119594510685183, 0.7295259281386648, 0.6213894115309537, 0.17904207394022453, 0.7687733268684335, 0.2431799495702337, 0.2044181362473877, 0.5508207325160045, 0.5546552120312009, 0.1925600163013239, 0.5491664639177796, 0.15483364484805973, 0.29035622727845734, 0.22649694441580248, 0.20333366507693829, 0.6147810628944717, 0.2872490322472392, 0.2696165350722255, 0.29105070079938666, 0.3947562129050265, 0.2776423976566724, 0.24819915898673595, 0.17555960029946405, 0.28073306003266496, 0.4655914818839756, 0.2305723248196776, 0.21664815079256972, 0.21149232766142867, 0.19834023430932157, 0.21370591578590126, 0.2360882269260156, 0.2639105868134296, 0.20265848148010424, 0.2183643779982133, 0.1722109085224014, 0.19593563569185612, 0.214066530533374, 0.23133230781052516, 0.17007060164292742, 0.19362238414440858, 0.19928493386536772, 0.20152845698253596, 0.17194829700101166, 0.148356630319895, 0.13714104184980402, 0.1539326418600263, 0.17250409703833014, 0.20131330201358433, 0.20122014856638581, 0.9259262697421958, 0.1696863607418856, 0.9511148359845729, 0.11283863762751967, 0.15708145266765294, 0.15498878153025508, 0.21149015583848307, 0.21279828723527494, 0.21257484845879648, 0.21263068873790503, 0.12742208653670928, 0.8321061065456695, 0.18393570449033136, 0.17831424936924434, 0.1861962567051053, 0.2443904232981129, 0.19199225759660576, 0.1789400148030016, 0.17679497396343324, 0.1901665649649572, 0.18179061950857367, 0.08703275985715098, 0.11403343544904798, 0.08293931688611933, 0.09467679945095009, 0.0840884866059789, 0.10021985367517117, 0.09251807776034215, 0.09250151151405239, 0.09041001541155225]}, "mutation_prompt": null}
{"id": "a9a526d0-59d6-4784-b64c-e211450cc573", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "ca5457b8-a378-4168-9bcf-e8a2b576c9f7", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "46722033-ea65-4bc0-ae1d-d6eaa2812705", "solution": "import numpy as np\n\nclass StochasticCompactDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # population size to balance exploration and exploitation\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # slightly lower mutation factor for stability\n        self.crossover_rate = 0.85  # dynamic crossover rate for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            diversity_metric = np.std(self.population, axis=0).mean()\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with dynamic factor influenced by diversity\n                F = self.mutation_factor * (1 + np.random.uniform(-0.1, 0.1) * diversity_metric)\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover influenced by diversity\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Enhanced local search with diversity influence\n                if np.random.rand() < 0.2:  # increased chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1 * diversity_metric, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "StochasticCompactDifferentialEvolution", "description": "A stochastic compact Differential Evolution with dynamic crossover and mutation influenced by adaptive population diversity metrics.", "configspace": "", "generation": 28, "fitness": 0.24682632279207126, "feedback": "The algorithm StochasticCompactDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.24.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.7004142792079331, 0.6714160409447227, 0.6755823783215973, 0.7137655043473212, 0.7298321922406305, 0.7318645825152487, 0.6995732005476998, 0.722918785666701, 0.6738427975067576, 0.7093940558925647, 0.7243055015392572, 0.7132470369845949, 0.7303207761647481, 0.6973386149092002, 0.696947559918097, 0.7107572737726684, 0.6984789332093684, 0.7083331740622952, 0.12337666834730132, 0.09690956288751129, 0.10491146945913699, 0.08985987584821598, 0.08690072262505111, 0.08325993348074112, 0.09779347851599851, 0.08880196290787612, 0.08152616927257095, 0.0831562537813888, 0.08057378416789851, 0.07691295864200942, 0.07836210864223225, 0.07427434007582523, 0.0718709616079215, 0.0827362466869237, 0.07191249903877284, 0.07933475007725865, 0.9727815910410065, 0.9656896437844124, 0.9591791811029511, 0.9603429229000231, 0.9407846855305801, 0.9664383741596049, 0.9907014090014683, 0.9613605004681753, 0.9781889240583694, 0.1955970216905104, 0.19283422079248747, 0.19204182604721043, 0.17482839376897663, 0.2754340010656484, 0.1702896210275392, 0.1825045492619558, 0.22647395311973073, 0.2750108833045011, 0.5220455244982045, 0.27364147891196244, 0.39749336340923047, 0.5728871972518542, 0.5586844424872768, 0.5699549767293106, 0.4142421815852697, 0.27582857478030787, 0.4980146334397264, 0.17763389368772786, 0.20551590328425695, 0.21432698399901573, 0.17644339572584378, 0.15767027640535303, 0.19191947665032427, 0.17409705265560094, 0.16780159648742776, 0.19214993238100664, 0.15199913253509678, 0.15969577279432923, 0.1484514896402872, 0.10487102795101344, 0.10975891662817872, 0.14258609457283544, 0.1464534176143628, 0.13006295719733663, 0.16394803935260183, 0.007051180998847273, 9.999999999998899e-05, 9.999999999998899e-05, 0.010218408645921606, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005817805797682096, 0.000334486497846731, 9.999999999998899e-05, 0.08934206365484298, 0.07717813582109889, 0.08337508396137949, 0.05995688738960303, 0.0666938677867227, 0.04667109794369484, 0.08618342933470036, 0.08387042085538488, 0.08661527465247598, 0.007890352748096352, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034941315741251477, 0.009654662682039405, 0.005445783368368429, 0.11832292154880475, 0.13190834518314898, 0.17034490302199845, 0.11171768577746077, 0.11752549875773999, 0.13636116475708682, 0.08363974600226287, 0.09930254560499052, 0.13400795133146715, 0.48486701733425097, 0.4708592816267728, 0.4519308658918606, 0.45877376539184755, 0.5065145401208083, 0.4996207620951353, 0.4685672226567452, 0.4388765984754812, 0.4815508869214926, 0.0877896268944709, 0.08516338012246583, 0.08253691072114377, 0.07518756674089055, 0.09012215930756262, 0.07873031750724435, 0.07780644548162674, 0.06321151379710754, 0.09406663796286863, 0.15654255208306567, 0.2899674116751829, 0.17283804198140407, 0.19852416908183868, 0.14561235448810017, 0.1837855853169782, 0.1753236260081319, 0.16660520456019112, 0.22185538399656735, 0.23249535053379466, 0.22145558613434302, 0.23525785860651438, 0.22755758600683074, 0.21812621530451848, 0.22065954493061102, 0.2817212357799145, 0.2602958866308077, 0.26198770556993267, 0.16270314084596282, 0.18630476841981258, 0.1550792679627928, 0.14887751454508236, 0.15124226661949303, 0.1503644000374903, 0.16627739911155404, 0.17764772307848775, 0.20485579250541452, 0.188651469314151, 0.1831622259216178, 0.1818573964029203, 0.19370258496181758, 0.18388840689414743, 0.17745458342705933, 0.18848426415919806, 0.17811824669212784, 0.16084213656960056, 0.17561877666481074, 0.17391256335831407, 0.18107935707414002, 0.1637668916594699, 0.18240695873606094, 0.1731539223750258, 0.17851340175102381, 0.17610821446649427, 0.16970919756019498, 0.15076766235723482, 0.16718559641495156, 0.5970413672323848, 0.18312742279247207, 0.1870561476263931, 0.18357814623249435, 0.18434803844073244, 0.17046074003229827, 0.23561588430018698, 0.16034514645956788, 0.16761073769949486, 0.16263464164594166, 0.18202855546260766, 0.2168836644514932, 0.1668226981430837, 0.20477145874649794, 0.20958165306796184, 0.153918625194979, 0.18179788186187307, 0.18136717990690054, 0.19926105304192854, 0.1857919346735203, 0.24821399930835175, 0.19231422590586977, 0.19017881950230164, 0.181704193350254, 0.22457270360576864, 0.05652406220632333, 0.06781269339862317, 0.05938888644175955, 0.06546761332051465, 0.059416929072684255, 0.06387594495521187, 0.07348170253841835, 0.07405261100700644, 0.07676175475973324]}, "mutation_prompt": null}
{"id": "cd0d8544-ca87-49dd-afc4-8052ae6406d0", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "fd09648d-47cf-4d64-a42e-52adddbbc5c8", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "e6d3b3da-b21d-428e-8363-ba095329ed20", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "a6bd95a2-618b-4dcf-a2e9-b15cf0fba1f2", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "88579b54-67b1-4701-951c-218f9c718ff4", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "91436634-619b-460a-825f-d005810684a9", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "cacdea94-2362-4ff4-af11-a4c7418dc6dd", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Adaptive mutation with probabilistic scaling\n                F = self.mutation_factor * np.random.uniform(0.4, 1.2)  # probabilistic scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search with adjusted probability\n                if np.random.rand() < 0.15:  # 15% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.08, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search, adaptive parameter control, and probabilistic strategy refinement for improved convergence efficiency.", "configspace": "", "generation": 35, "fitness": 0.4219338679000187, "feedback": "The algorithm CompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8633646896474113, 0.8439271056224997, 0.8599603259235733, 0.8727324226771759, 0.8759962330982053, 0.8718279251401511, 0.875783298558088, 0.8722985243494015, 0.8584202140674269, 0.7930579614165411, 0.784706212326115, 0.783341066605717, 0.8016903918077058, 0.7817832965492829, 0.7712451341654281, 0.7865791229004038, 0.7772253855119935, 0.7808272625805017, 0.09174475156169226, 0.09604318951022417, 0.10032048673086646, 0.10130561673225114, 0.1260879043316323, 0.09461944708235515, 0.09192750837422647, 0.09361406495090341, 0.09893649401437854, 0.08895812378393042, 0.09690677942254988, 0.08405512376610891, 0.11083210974342272, 0.09501821175978276, 0.09225054281626743, 0.08893291650548985, 0.11722567445682142, 0.10414070051621838, 0.9893971890395584, 0.9455291538794475, 0.9442722837090143, 0.9731751763441242, 0.9376017688534377, 0.9419729239092905, 0.968200306514306, 0.9752167710614343, 0.9706493453680636, 0.6215425173394352, 0.644478648475867, 0.659037528235624, 0.6364161173362839, 0.5954397291176583, 0.6564643441243114, 0.6384691072475761, 0.6722448817822614, 0.674708542229721, 0.7343487350628122, 0.7550643794970918, 0.8819094082485108, 0.8783636115612288, 0.8434714797069824, 0.8643545160237802, 0.8505971032061796, 0.8205124153418367, 0.8321242672106377, 0.4853500680612477, 0.3836754271220988, 0.5926206970873178, 0.4579850364385931, 0.5012108481437489, 0.4514947732044219, 0.4004073349218552, 0.5039783250160544, 0.53582944898265, 0.1270137877902291, 0.12288901933958896, 0.6899478873043867, 0.42218611592139554, 0.24267448069662978, 0.6487209477253398, 0.3726177678511412, 0.5701090446899184, 0.31140737032496935, 0.6622655500054672, 0.12633462369350867, 0.44374972078534514, 0.7062727368864383, 0.06560306334193033, 0.35386866430912844, 0.5788087162955026, 0.5685858884271191, 0.5911035904912854, 0.702918568371226, 0.5232423484348141, 0.6055376473845252, 0.6615503989626138, 0.47649881826042917, 0.552786693974237, 0.6834629537580982, 0.6764993782803141, 0.5005809783516554, 0.2910239872504584, 0.10750198291545643, 0.2090063750443485, 0.25830504568431156, 0.2563978796169719, 0.18122424653042124, 0.16707661723851652, 0.24936991466895753, 0.20268217388249044, 0.5269388163602375, 0.4077511225540241, 0.5003673345222135, 0.521771336322185, 0.5217530119587178, 0.4433736992130616, 0.40713984734059927, 0.5718092800157428, 0.5333510573725622, 0.7916056550716876, 0.8271610025911884, 0.8015858923274591, 0.7633645714810794, 0.7861826750565488, 0.8186021823361469, 0.8168263787788979, 0.7848714071903257, 0.7242613419869719, 0.09822511054841776, 0.10734026995712842, 0.0949415910864313, 0.09377673015953825, 0.11174630177854616, 0.08628247649716392, 0.08065976160329624, 0.0846466359601118, 0.08013017474219619, 0.1454867236878703, 0.17500531306240097, 0.24054391372490314, 0.1602222320188914, 0.363783233923914, 0.13745233635990084, 0.6830469199524033, 0.1997592550897671, 0.24419513912290403, 0.5428990591633883, 0.49834856762285606, 0.525102637839127, 0.5467608469505663, 0.5792620160939264, 0.5395647902648604, 0.5634974222205431, 0.5741640946735203, 0.5934124549698206, 0.3899230113440776, 0.3687167115669626, 0.35491612749266277, 0.4327762035293591, 0.3410950441143431, 0.3614941178548624, 0.45830112434152337, 0.3718174958709908, 0.3715668518150518, 0.18758233110217093, 0.19439734353887417, 0.19561998809284953, 0.1867234466653951, 0.19440858078301748, 0.2116240727658577, 0.20221589689907848, 0.1847490564663261, 0.189956672530881, 0.22323896697536416, 0.18463517072001712, 0.19117327803305184, 0.17842555624190937, 0.17678588287519637, 0.1779453045612358, 0.19468688421472102, 0.2063664689068403, 0.1799038210036762, 0.1670702861358102, 0.7626510383643637, 0.1648184072377853, 0.16334974615942588, 0.20230432383724506, 0.16547338996362593, 0.16594705468721038, 0.15045764454101374, 0.1150024709282641, 0.16652463018032815, 0.16761687024112693, 0.8154885592874145, 0.20654350240899622, 0.20045124966880667, 0.12637560151577454, 0.22170391559181346, 0.2300010775548017, 0.15505699729798672, 0.18319602604971752, 0.21199164017819272, 0.1886511907774021, 0.18989152971842072, 0.20717509277680057, 0.19920233067790538, 0.18732226826905685, 0.1921395192580051, 0.17382021896925504, 0.07486423678647736, 0.08003135965744046, 0.07315435549221716, 0.07972148609365082, 0.0778223659573285, 0.08394606971508434, 0.07088796549424004, 0.07848967546816565, 0.07292792470216258]}, "mutation_prompt": null}
{"id": "0e6ec03b-bdd7-43c6-b525-ccf0bf838bb2", "solution": "import numpy as np\n\nclass DynamicCompactDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # slightly increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adjusted mutation factor for balance\n        self.crossover_rate = 0.85  # adjusted crossover rate for adaptability\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation strategy\n                F = self.mutation_factor * np.random.uniform(0.4, 1.2)  # adaptive scaling with wider range\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search with dynamic threshold\n                if np.random.rand() < 0.15:  # slightly increased chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.15, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "DynamicCompactDifferentialEvolution", "description": "Introducing Dynamic Compact Differential Evolution with progressive diversity control and adaptive crossover for robust search capabilities.", "configspace": "", "generation": 36, "fitness": 0.3894765075980842, "feedback": "The algorithm DynamicCompactDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.860250996041453, 0.8544489161178501, 0.8656678121878538, 0.8528839058621398, 0.8532215965740756, 0.8692215339504189, 0.8571473942416195, 0.8684518621093243, 0.837037846421107, 0.7679839741079193, 0.7676455655226386, 0.7506629005137391, 0.791213993127923, 0.7635875135582264, 0.7523444369104271, 0.7504646248031617, 0.7715415524920044, 0.7862777018717224, 0.10247597676759757, 0.10686793829664643, 0.10800230871451044, 0.10560033617965203, 0.1059792806341271, 0.10412637445057904, 0.1108968353505213, 0.11634089071304643, 0.10349279900124142, 0.1019043050442815, 0.08752044706934614, 0.09537213733995109, 0.11344150531387531, 0.09528870232741826, 0.09322152678273488, 0.1121985254302661, 0.09283408531852033, 0.09401481573908954, 0.9539187830216539, 0.9855125155585424, 0.9409315123076079, 0.978033065411443, 0.9396053305515936, 0.9624174067397593, 0.9736847161784041, 0.9670639192257627, 0.9504896123513069, 0.6390286399306816, 0.6184443318035304, 0.5989392256471504, 0.5965073133750403, 0.6072973954862515, 0.5994535603681754, 0.5966246219836866, 0.6296946702337791, 0.6350089677960378, 0.7851541762171869, 0.7736676583261164, 0.5893421810480465, 0.8398904395741766, 0.7852404870363323, 0.771842187367551, 0.8179802741930381, 0.7637750526440822, 0.7651142514422593, 0.4436165993630793, 0.3177711828540175, 0.38901205266381034, 0.2877967344847353, 0.5116201269851508, 0.5240656488331263, 0.3875250109722107, 0.20059763670620823, 0.4535635466526289, 0.51856335718555, 0.14966923918419728, 0.4058695768782258, 0.38371210306091874, 0.23248277752300184, 0.20011107502924175, 0.20689127167108112, 0.3845641846476009, 0.5020730105086574, 0.3112630079667069, 0.3824891068235152, 0.29027225177095717, 0.23668265112219056, 0.2563237655175209, 0.3881475441868627, 0.4699886314358618, 0.3427533332507393, 0.32720543252457124, 0.3642794745772767, 0.3915442199410263, 0.5309244417837615, 0.5959780214394446, 0.4305114002880962, 0.21504985849656488, 0.6066271289231593, 0.6638681953867578, 0.40885467284179167, 0.1095954938303666, 0.14948915358702652, 0.07560005035174311, 0.38533946557868903, 0.20562730475884228, 0.20633908264134027, 0.30246749715475885, 0.16248363601322147, 0.2325427088771358, 0.42167512754872627, 0.3843879173217086, 0.4233740607385851, 0.4368172416252588, 0.4288616918505218, 0.483026764299723, 0.44009375031694953, 0.39492414967013156, 0.42214074422223125, 0.7935509641569041, 0.761495507361708, 0.8095255130676988, 0.7761383073142532, 0.7634035794469829, 0.7587143021726632, 0.7968897630661879, 0.7181442217594711, 0.7616244884702442, 0.0903779181455946, 0.09375679351625565, 0.09570403154032225, 0.09859356810303466, 0.0826774751952899, 0.08616675521395356, 0.10641543859648084, 0.09222317626406384, 0.08378659760742813, 0.1597450005746256, 0.12903165419249762, 0.14184943535772598, 0.2230720654900742, 0.24346121670355036, 0.15384611854557695, 0.1579213161197669, 0.16820135349369125, 0.1566963750161805, 0.5241900730211975, 0.5061901369241821, 0.38429014886386026, 0.50013539438468, 0.4594267318099925, 0.5232108565618031, 0.4949816059956095, 0.5575116919493099, 0.49327724166885367, 0.3564178789317589, 0.3553155441742314, 0.3187704618028294, 0.3247712321552514, 0.27821815056815025, 0.35201574155764714, 0.35592274347906394, 0.43964274583655705, 0.42073552201593634, 0.18182151378807887, 0.18297828290776752, 0.18837159399638537, 0.17215727275406956, 0.18763869972088176, 0.19446755155560258, 0.18865004389338547, 0.1927577255190236, 0.18914520105360488, 0.17873704604824603, 0.19222760921378257, 0.19044995097675932, 0.19384663585220918, 0.1934157421373166, 0.1799357489282587, 0.18558559630093896, 0.18545827837029538, 0.18334720047669262, 0.7170576716789401, 0.8566647466476773, 0.19425017208088668, 0.18319697407760127, 0.19783653969196469, 0.18398656532782154, 0.17570519625767267, 0.1831092877130368, 0.1708309618189756, 0.16342086355494867, 0.2048032293368377, 0.20961904905628304, 0.1603821796409406, 0.19920264942005939, 0.12690735763052585, 0.20966680224074985, 0.1536383881878799, 0.2104000753748525, 0.18959639581636267, 0.18536073158565614, 0.18078720266689852, 0.173941753133098, 0.21028810237885298, 0.18961991568994585, 0.1967626424359108, 0.1837137940769641, 0.1968817573495062, 0.075355382497033, 0.08168836371969646, 0.08131851248316502, 0.08191669284068703, 0.06655637423699023, 0.08473022879452874, 0.0756858241079903, 0.08217145197101416, 0.06949394740438242]}, "mutation_prompt": null}
{"id": "f3359cfa-7c14-486d-be42-7028c06a8c9e", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "123ac643-d703-4d0e-a6ce-856ed9498eee", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # slightly increased population for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted factor for balanced exploration\n        self.crossover_rate = 0.85  # slightly adjusted crossover rate for diverse offspring\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 1.2)  # expanded range for mutation\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Probabilistic crossover strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Probabilistic local search\n                if np.random.rand() < 0.15:  # 15% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)  # smaller perturbation\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ProbabilisticAdaptiveDifferentialEvolution", "description": "A compact Differential Evolution using adaptive strategies with probabilistic crossover and local search enhancements for diverse exploration and rapid convergence.", "configspace": "", "generation": 38, "fitness": 0.3704512914519189, "feedback": "The algorithm ProbabilisticAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.27.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8414251324940721, 0.8371523558684159, 0.8259880705140329, 0.8490432575250428, 0.8452095858389903, 0.849515163636646, 0.8004082027597542, 0.8290785758423964, 0.8198900070780604, 0.7313428590104413, 0.7451599699729493, 0.7368987619850953, 0.7257518581615328, 0.7539979181527597, 0.7371877659799484, 0.7500950604535876, 0.7597686753090043, 0.7271578153215605, 0.10131181971586412, 0.11181287120668637, 0.09480312109702649, 0.10184292422901942, 0.09236759584391929, 0.10022161170071964, 0.09324559704706281, 0.11769700051266296, 0.10142629203117104, 0.10440245161107264, 0.09181921462318676, 0.0994691696821497, 0.09856362871648838, 0.10467563017589399, 0.08973359252210977, 0.09714429347005316, 0.09228390670892239, 0.09257070568385173, 0.9732729581035467, 0.9802568804766699, 0.9495664616235783, 0.9780342453015141, 0.9513801329209581, 0.9899812239040077, 0.9420094583497222, 0.9745532706170327, 0.9346697624909455, 0.5961401660601708, 0.49297041215820614, 0.5362821136628464, 0.5652894103048443, 0.5815099911642811, 0.5096120332516033, 0.580587991840052, 0.5893827557563343, 0.5869976146396532, 0.7794043100556356, 0.7810964485429229, 0.7328192053893705, 0.7510216560226011, 0.7372660518273371, 0.716543942762017, 0.7997897056518426, 0.42758776809729104, 0.7691057751048518, 0.3417370514387752, 0.44440660544676003, 0.5348615655901638, 0.5240850701673403, 0.38603504045550063, 0.4535945095681605, 0.46161897239895333, 0.48961308954194194, 0.43728812476288703, 0.2226611411393543, 0.47768176333855994, 0.395057023743142, 0.4939299609771167, 0.46124400805850996, 0.45205825136450417, 0.34704022429129766, 0.4280430770486884, 0.3638990847624959, 0.34313247272830705, 0.24331072114813168, 0.25268941475916795, 0.2710275418515672, 0.17375229282183846, 0.09120617044416468, 0.20400630842948186, 0.16966869947364305, 0.2654612438074173, 0.15621519297623887, 0.30155605649883066, 0.2722284789118353, 0.3699974598942346, 0.16903824284510083, 0.08571483069364116, 0.4484660525908294, 0.4763575885189444, 0.2708806290317868, 0.21500963357699232, 0.09226693443549538, 0.05127157778092206, 0.11013724588729457, 0.21093745586682844, 0.13366177756935593, 0.2165176185920623, 0.264000609492101, 0.24878208250363731, 0.3819731934835684, 0.36824692538905923, 0.341957317504082, 0.39788285297545223, 0.367400497550484, 0.37233957781004556, 0.39464709215413707, 0.34020077762514744, 0.2410667063282459, 0.7773574598479831, 0.7541383560794201, 0.7380695267096377, 0.7637816953428181, 0.7554529233117616, 0.7426941557314097, 0.731248054853513, 0.7537154931118171, 0.703286356939473, 0.0840162279891099, 0.08842437551413873, 0.09190555036155279, 0.09106336618471378, 0.08644936189571184, 0.09692196978396439, 0.08378920544805446, 0.0937257854999034, 0.10713869831088085, 0.15153671817217418, 0.13157208619763938, 0.27583644681788244, 0.15769358209127482, 0.1552703345774049, 0.1719182002525742, 0.15569662038365828, 0.12308416639645525, 0.14804589394596168, 0.4245297661792823, 0.43020130207227014, 0.4310468831360549, 0.40547875601382455, 0.3982705170125913, 0.4295028975955244, 0.48686789561550337, 0.5327399206628372, 0.39285106042794127, 0.2718899541123482, 0.24797519316548355, 0.2678179765614894, 0.23977979533403004, 0.2602910818387262, 0.22111074315254187, 0.35927196348726287, 0.35153754780467306, 0.33943212418104574, 0.18504421609542865, 0.19260655597884802, 0.17598310427695907, 0.20340980344420745, 0.18623761919661652, 0.18474143956956268, 0.19566181392787663, 0.18359497151804793, 0.20659917137016381, 0.18075431032028388, 0.1809743747996645, 0.18029559736005463, 0.1929895796495844, 0.16801498397027248, 0.1964606208393932, 0.17260194482984148, 0.17574430508115002, 0.19060016315418238, 0.7202807620194795, 0.1680831873315285, 0.16542852145412235, 0.19465621929590105, 0.18621883304909137, 0.2020100838275739, 0.1513124161422169, 0.7837762068518627, 0.6743131009695033, 0.649366176220777, 0.16376994228168373, 0.2020653975186566, 0.19386219904348467, 0.15550449875168215, 0.4156087963803462, 0.2091618307530292, 0.15225982232197788, 0.21121414408209993, 0.19699080773120348, 0.17331168838276267, 0.19044776542856434, 0.18878846576044184, 0.1708572314947796, 0.1870759417223996, 0.21274805508106875, 0.17757593936559735, 0.18568198108266165, 0.07694566635045375, 0.07097260605377398, 0.08414002365116324, 0.0692382563120425, 0.07858767560904634, 0.0844733884079284, 0.07067487475068701, 0.08184214905641785, 0.07603368698580504]}, "mutation_prompt": null}
{"id": "0c8a3f9f-f87c-4002-b272-b5c242446c51", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # slightly increased population size to maintain diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # slightly reduced mutation factor for balance\n        self.crossover_rate = 0.85  # slightly reduced crossover rate for exploration balance\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.6, 1.2)  # adaptive scaling with broader range\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.15:  # slightly increased chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "A novel compact Differential Evolution with adaptive mutation and crossover, incorporating stochastic local search and diversity control for efficient exploration.", "configspace": "", "generation": 39, "fitness": 0.3448758278210356, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8132364274276327, 0.8102622832632217, 0.8119602941843042, 0.8183630138156106, 0.8335765943351918, 0.8193278288474208, 0.8125761860080211, 0.8278150410794975, 0.8199288117502394, 0.7389008246230121, 0.7147408234283936, 0.7090643751206469, 0.7040300378981624, 0.7340191256699891, 0.6892274384597328, 0.6861478730980788, 0.7071536450552341, 0.6776439703458029, 0.09568718648143315, 0.10018761111555885, 0.0848171662203051, 0.09098705691847275, 0.09297829796465762, 0.09300303849763547, 0.09674069211871483, 0.10650590066815091, 0.09928055952523285, 0.08957220878073335, 0.09226122420410587, 0.08579714610277367, 0.08675229614203128, 0.07868911123290567, 0.08642226780327966, 0.09661078532799328, 0.08714649298055266, 0.08676373636849544, 0.9370871767224949, 0.9797615762461066, 0.9367669291695615, 0.952946131973069, 0.9662686558729733, 0.9899574549442274, 0.9432610450543226, 0.9753162634075836, 0.9479462685851908, 0.5842905831820434, 0.46807290878015806, 0.5033914832297633, 0.4783387722751976, 0.47764496781393995, 0.48681872085592026, 0.5984292072315517, 0.5731879031463403, 0.46319444869607085, 0.7366078204582971, 0.7682317522216681, 0.649823172349512, 0.7654514042378764, 0.6196736098079124, 0.752123097693047, 0.7343269192458848, 0.7003128251614548, 0.7334849479502334, 0.41476353811078626, 0.5344189781701382, 0.3500865218128246, 0.45410113914999006, 0.30279449958677196, 0.37370739824270127, 0.3709820835197042, 0.4031889309678469, 0.30656696352222046, 0.2851118901445244, 0.32426207448640165, 0.3315336448663382, 0.45434601517514217, 0.41643810578079987, 0.3929575577293073, 0.37029773561676715, 0.33872397949138244, 0.29128559890883066, 0.24969620979704188, 0.06333945639007421, 0.03928058115799338, 0.3775218900724635, 0.043425276254684064, 0.03426185949290006, 0.2728328854665871, 0.14331626206850434, 0.10808750336504525, 0.17836529511732102, 0.12717576198574954, 0.15968792242450325, 0.19043857353088078, 0.10446954867895342, 0.09319423616086664, 0.39578936334208004, 0.37323007482022397, 0.2736393310195524, 0.09880890532020825, 0.07860504907963828, 0.15764890781027774, 0.27046020748747623, 0.14519721197383006, 0.2029143764353557, 0.16055020070539017, 0.14372615595542226, 0.13343652360323688, 0.360877746331275, 0.2681421149244616, 0.3014609699624706, 0.35442560607394213, 0.32983325313781775, 0.28314891064764447, 0.3057675025140988, 0.2806969082380374, 0.29459686059833157, 0.7365350206020901, 0.7357484866004624, 0.6926043190939387, 0.7029504534049422, 0.7198520253715495, 0.670048181440135, 0.7389696289717307, 0.6895266433791961, 0.7158107583503673, 0.10297604830291307, 0.09604311501741869, 0.08821107081217505, 0.10180622334811973, 0.09207319181076179, 0.08764823473007599, 0.08621716217053343, 0.08572207805989751, 0.08422993904258569, 0.14289644203853846, 0.14288795306392899, 0.15760247022486507, 0.17706916334094114, 0.1781092670990938, 0.1327300615260607, 0.19379139885184138, 0.2448968686397649, 0.16189998594329358, 0.4476783341672974, 0.3136402028682592, 0.34864243875500533, 0.33937766858131546, 0.3824593980564881, 0.36960973421777243, 0.4285010208056451, 0.37149665312267166, 0.35277139066970264, 0.2835633822863428, 0.2204291161095795, 0.24517933197444608, 0.309578308906002, 0.2934875539857855, 0.26472860540143006, 0.24327714706498837, 0.27632273253867967, 0.24099576772098963, 0.1754344888478636, 0.17398482241722701, 0.18883576501435406, 0.16737016959158368, 0.19541653557899175, 0.1894572934914096, 0.20790545775507896, 0.19481258088288456, 0.20015985713401074, 0.18949687425255168, 0.17736117622274306, 0.18573500788247055, 0.18442964107462145, 0.17958084432021992, 0.1839488936182514, 0.17327034035325373, 0.18161333703624438, 0.18060160688596993, 0.16694737347786737, 0.4903523191467911, 0.15260122000163678, 0.18310968839796238, 0.8241293154637066, 0.18441996115617, 0.721139469488741, 0.1844831224909952, 0.15765530159647279, 0.6474727607498851, 0.2020498339404848, 0.1673291605456485, 0.15266687424610303, 0.16354857342633677, 0.12421364423018166, 0.209894446235241, 0.2092241020636748, 0.21206422083539533, 0.18857748193370216, 0.17997181490628478, 0.18279014502859792, 0.18037056565123943, 0.21687261070556163, 0.18853861674122896, 0.18151440230381544, 0.18192285676639053, 0.18077383433503869, 0.06596841861015657, 0.06917690645349461, 0.06856292224261284, 0.0713605959502216, 0.0694251261042127, 0.0729766289008732, 0.06854702708148142, 0.07000211884656415, 0.06800616205711774]}, "mutation_prompt": null}
{"id": "91e97657-cc7a-4c30-9e75-bde6604d0283", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "0b748891-d97b-47aa-89a8-d7cef48f81c4", "solution": "import numpy as np\n\nclass EnhancedCompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # slightly increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # decreased mutation factor for stability\n        self.crossover_rate = 0.85  # slightly reduced crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 0.9)  # more adaptive scaling range\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Enhanced stochastic local search\n                if np.random.rand() < 0.2:  # 20% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)  # reduced noise\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedCompactAdaptiveDifferentialEvolution", "description": "An adaptive compact Differential Evolution with dynamic mutation and crossover rates, and enhanced local search for robust convergence.", "configspace": "", "generation": 41, "fitness": 0.3716385412435613, "feedback": "The algorithm EnhancedCompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8749660129814258, 0.8607572008877937, 0.8628576187103993, 0.88426555874189, 0.8725199615701901, 0.8876026698843013, 0.8681463674118326, 0.8859074153598613, 0.8645129390165225, 0.8049914145002974, 0.7927081866277137, 0.7723495311529535, 0.7948618445674072, 0.7884520588238321, 0.782415837650636, 0.8004590098832739, 0.8161028178109978, 0.7890538357447916, 0.10342740760722713, 0.11586877121433936, 0.12466411028154345, 0.10693521955983509, 0.1427409613516908, 0.12652691229491797, 0.10178848525857431, 0.10103038604546688, 0.12105054805763105, 0.09765043862423883, 0.10077278701734227, 0.10252664111900744, 0.12077488521203328, 0.10542088094913993, 0.10109267094645069, 0.10348899963848346, 0.12654150680231635, 0.11371657011473546, 0.899068001664737, 0.9412188836712825, 0.9579017137495139, 0.9517346058231845, 0.917714298571551, 0.9166339267218186, 0.9655029262196196, 0.9221534548377509, 0.9412301050480624, 0.6508008823862543, 0.6198882936592524, 0.642215212783853, 0.5433592215439207, 0.6428837595659433, 0.6613843285210431, 0.602572215771533, 0.6293883519639232, 0.5330343948455479, 0.8744276981686858, 0.85921677116392, 0.8331053379732813, 0.8853752152595201, 0.8001145161999563, 0.789495687885684, 0.7810643737846027, 0.8512338744611305, 0.8148153774366724, 0.20510313125737245, 0.18952303464100395, 0.20676816772977114, 0.23888979058195892, 0.19054968842199416, 0.18921035622803783, 0.1644214490022038, 0.12826760832956408, 0.15900890403559043, 0.19583670823301147, 0.21365241204454988, 0.19591731947660251, 0.24118353337753884, 0.22521687040709892, 0.17195543836297933, 0.21800071480270267, 0.1987285920397065, 0.18604416288200765, 0.23523790050336024, 0.2534331036436336, 0.5341705311914023, 0.06891740365150567, 0.13413970347576432, 0.33928572331415496, 0.5857094429182835, 0.020076864579147147, 0.11998458751480634, 0.5929329482957026, 0.29113764541844644, 0.08167070459801073, 0.5221445932347041, 0.08543493595695051, 0.18143955759784658, 0.3061212650753393, 0.2869633993246228, 0.5854973465914105, 0.15106008066178167, 0.21148211654379656, 0.2048215826232801, 0.17765334987819859, 0.34773385303594806, 0.15169913716935857, 0.14452568024470458, 0.1545480635339923, 0.21990040324155669, 0.2285140221052343, 0.3183275853731228, 0.378665422952704, 0.43749886775530245, 0.43575582798906953, 0.3680125424403715, 0.3071156227755435, 0.43670751379074113, 0.4548876267261892, 0.8092191616421411, 0.7911339695655405, 0.5640803054170208, 0.77235052832952, 0.8017596760522671, 0.684151213722229, 0.7105351797413411, 0.6041591119471483, 0.6997056269566586, 0.1044528580526054, 0.11932679300469518, 0.08913222619878547, 0.08685922579394223, 0.10467963663358915, 0.10736626607323596, 0.12328724694269444, 0.09429339993100161, 0.11006186203403157, 0.1521468101549912, 0.15654453904744636, 0.14483467658087923, 0.1297743189301469, 0.1366677771761723, 0.13073255369119274, 0.12946052193080704, 0.15374127041453267, 0.13484612691855613, 0.5890287664191043, 0.5887251582741347, 0.5398342055780148, 0.5343007191276116, 0.5299735323549581, 0.5448042368770506, 0.6397784626144725, 0.48541132707717505, 0.6274513619328246, 0.3975882802985321, 0.37088364270055585, 0.3917930822718567, 0.4421821878865858, 0.4033876336191531, 0.3313731484664414, 0.4601227369101967, 0.49094659489228776, 0.4596005638363265, 0.1929406977246273, 0.19570793987828405, 0.18741409313564372, 0.18858973598877538, 0.20168699248358857, 0.2111651883953205, 0.1973154310757761, 0.20131060618586705, 0.19778316871914015, 0.20329491528802257, 0.19675382217406212, 0.198539140064678, 0.20033418313077678, 0.2354302637881739, 0.189028437678482, 0.19278144444144907, 0.20508359164255785, 0.1819238745401015, 0.7512446316552632, 0.8650322273564494, 0.1769269971485231, 0.17600986634351634, 0.18520776947031137, 0.18489750424091922, 0.16796524823021242, 0.14595618489973927, 0.15931536388548717, 0.1547443502988386, 0.20258794386976897, 0.16313270484318732, 0.20807655554408488, 0.1705161447042356, 0.2057849363167753, 0.21028587366844653, 0.15599971518192612, 0.20956581925969697, 0.18005602412983224, 0.187060267536994, 0.17969601622264253, 0.1829773564880054, 0.201743936316365, 0.20320220267648348, 0.17893435161306037, 0.1949567137908057, 0.17708414830620445, 0.0810881726519761, 0.07935371704664862, 0.07853856010357518, 0.07652840777734815, 0.0837641147480428, 0.08400438778506436, 0.08921374955824268, 0.07632869376515106, 0.07860547013662178]}, "mutation_prompt": null}
{"id": "14dd815a-b08a-47d7-80da-97fc5ac7064e", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "f491d13c-efa1-453f-9c16-29885ae6bc23", "solution": "import numpy as np\n\nclass HybridCompactDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        best_solution = self.population[best_idx].copy()\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                if np.random.rand() < 0.15:\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            current_best_idx = np.argmin(self.fitness)\n            if self.fitness[current_best_idx] < self.fitness[best_idx]:\n                best_idx = current_best_idx\n                best_solution = self.population[best_idx].copy()\n\n        return best_solution, self.fitness[best_idx]", "name": "HybridCompactDifferentialEvolution", "description": "A hybrid compact Differential Evolution with adaptive mutation and crossover, incorporating elitist strategy and dynamic local search.", "configspace": "", "generation": 43, "fitness": 0.4225087029172568, "feedback": "The algorithm HybridCompactDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.28.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8548228811178034, 0.8637522918253397, 0.858767236517845, 0.865160570413334, 0.8563444050575276, 0.8871193847282344, 0.8829874879097779, 0.8562379002354704, 0.8713534277562156, 0.8296018005010979, 0.8073672391564511, 0.7957936275168482, 0.7893875713059069, 0.7974518012262946, 0.7659171731144455, 0.7803752145388142, 0.7029390684988852, 0.7886292661936662, 0.10834237833848714, 0.11154961687946086, 0.12166284262290028, 0.10140222851508573, 0.0982258474041009, 0.12573717778465943, 0.12210279126641277, 0.0919289015713326, 0.1287555681116701, 0.08702869704954497, 0.10884137501942293, 0.11249578560408302, 0.09557863454009308, 0.12009015599199102, 0.10185524351083808, 0.08869741312518231, 0.09019862533270351, 0.09209690889143385, 0.9470205489571227, 0.9677518054989754, 0.9677131544772786, 0.932428847641008, 0.9589512026342721, 0.9429282077566332, 0.9583563382976813, 0.9729338390290866, 0.9881370528661865, 0.6535606914996432, 0.6909333066724647, 0.6331879611773195, 0.6413214932196669, 0.7073669782141756, 0.6908801758957994, 0.6996057882314132, 0.6871477497390928, 0.6500594435283409, 0.8231767305309886, 0.6547388367413032, 0.8794446632413129, 0.8150210086697913, 0.8250988424452741, 0.8134749115398902, 0.8062552204405039, 0.8401073303864147, 0.8664790960419861, 0.5430906233540265, 0.2898508642178039, 0.6745065785259565, 0.6159643129089599, 0.46392223173524205, 0.7153151920848826, 0.5385863216902894, 0.48729176523028606, 0.4889670516622131, 0.49397940565059084, 0.28381413675774325, 0.48440043526837573, 0.5650331389548091, 0.36663023863431166, 0.5294810432189591, 0.309293089746271, 0.43662390924736416, 0.4861264050938372, 0.6273975845780355, 0.6125559462213701, 0.26541095113661384, 0.5984460934239768, 0.443073103382458, 0.13219426503563592, 0.40342165718965617, 0.5985523010129341, 0.339147084761645, 0.6508357613284494, 0.5589038221975515, 0.316835408552802, 0.7070426181000822, 0.14497859898923104, 0.6232700829950877, 0.69595114703964, 0.6848314172506508, 0.7037697296172927, 0.2272462621022342, 0.3094641527741001, 0.23383070962898178, 0.22043499714822878, 0.1522573158767374, 0.20986367624131896, 0.2954364351504051, 0.13414221540110594, 0.1611986204085022, 0.5319505067518613, 0.5755013529356949, 0.37969966669795485, 0.4905196784773006, 0.48932043865768704, 0.4664390236380641, 0.42289460257870637, 0.4527894714579692, 0.4402896325955382, 0.8201148922611925, 0.8108659605967385, 0.7938993341923756, 0.8021661717345898, 0.8279241817377725, 0.7905672240259689, 0.8122860531639599, 0.7086840903712854, 0.8091202014303943, 0.09036956458724232, 0.10024031187532745, 0.09396572610806142, 0.09194419111953755, 0.12512477612946782, 0.09781919973424069, 0.09400745973555713, 0.12087455285786441, 0.08674557132439897, 0.19128229583577072, 0.1631801945204444, 0.15529407853009047, 0.19445917896993992, 0.13831582438830992, 0.11811014242497841, 0.16532597582892672, 0.19485952828599518, 0.1353785161909845, 0.47114371530025934, 0.5541754334592166, 0.4936321908843109, 0.4858257832148407, 0.5189806195663438, 0.4863944916792433, 0.5867526079827807, 0.531805980328224, 0.5147804277943612, 0.48036286387155847, 0.3929172850699829, 0.40637088017624934, 0.4550425464391987, 0.3874172676638016, 0.4204002141866173, 0.4089062469671221, 0.44235273959323607, 0.4445505569424387, 0.18881664054999914, 0.22824904700900484, 0.19999799558958298, 0.17710166585587817, 0.19387571200523046, 0.17590841731612383, 0.18956228354488203, 0.19528793301031566, 0.18670819926408389, 0.22634721190614604, 0.20210093627688452, 0.19192583449999312, 0.17939290006539177, 0.2421339482930287, 0.19170832103962465, 0.188780704739951, 0.19634562143882972, 0.1811642419314765, 0.18372745933974877, 0.17221618646261827, 0.15906297431666538, 0.17504539852052003, 0.18671044881337862, 0.19096149615667735, 0.1940128011006318, 0.7983369349188778, 0.1797047660824972, 0.7940865485936174, 0.16886886570900683, 0.16644179355030686, 0.2031324098706062, 0.1977976326566807, 0.17071454399090558, 0.21867356928738113, 0.15453267573450813, 0.15457384569354127, 0.1883164905984238, 0.1863403229027536, 0.1833543706417765, 0.1808379860141628, 0.18027563857067597, 0.1797002838995706, 0.230511850097731, 0.17081430731667857, 0.17536100896058782, 0.08646143061302514, 0.08554623388921445, 0.08123526023834515, 0.07500267798252191, 0.0735027012980527, 0.07618675785410212, 0.07387561722362734, 0.0891597403521146, 0.07919929759388633]}, "mutation_prompt": null}
{"id": "87fda397-6bff-4a77-97c4-433545fc805c", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "90b1a823-e290-4f77-851e-c8bb5b7e3070", "solution": "import numpy as np\n\nclass EnhancedCompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # maintain population size for exploration\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # slightly adjusted mutation factor\n        self.crossover_rate = 0.85  # slightly reduced for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.6, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n                # Strategic diversity injection\n                if np.random.rand() < 0.1:\n                    injection_vector = np.random.uniform(self.bounds[0], self.bounds[1], self.dim)\n                    injection_fitness = func(injection_vector)\n                    evaluations += 1\n                    if injection_fitness < self.fitness[i]:\n                        self.population[i] = injection_vector\n                        self.fitness[i] = injection_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedCompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution with stochastic local search, adaptive scaling, and strategic diversity injection for improved optimization performance.", "configspace": "", "generation": 45, "fitness": 0.41271918310628175, "feedback": "The algorithm EnhancedCompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.887252191968201, 0.8814787331431712, 0.8983324102992948, 0.8841616461978175, 0.891748145596605, 0.8951868725152904, 0.8982290003053219, 0.865856314989599, 0.8656998051069116, 0.8284843151247223, 0.7913421301144464, 0.8249239692333183, 0.7944874763893677, 0.7972987736992962, 0.8087997233391604, 0.8112463907865777, 0.7897542854408821, 0.7820156335794771, 0.10634891649395106, 0.11314384601758976, 0.09824461656602601, 0.11930125069205899, 0.10775641755038157, 0.09928250828213137, 0.4774909538438087, 0.09896312884987235, 0.12025774002026901, 0.0997954455226645, 0.098368441076506, 0.10848698475160468, 0.11125322803193283, 0.11704098846721678, 0.12215818031843062, 0.10788264983765128, 0.11900448390687779, 0.12108910832990516, 0.9439488034286259, 0.9469265281432119, 0.9398188371621378, 0.960349110725826, 0.9818971162069395, 0.9819723725809528, 0.940997255504314, 0.9802998947480109, 0.929357379992141, 0.6892415933478541, 0.6967542163066274, 0.6844809153547651, 0.6911785261596883, 0.6672225107812848, 0.6934243444779233, 0.6671985916187316, 0.6699270961936195, 0.6875842050816106, 0.22940535102051574, 0.815240287147894, 0.8275174819820086, 0.8294080484472875, 0.8456396296897657, 0.8069996853041311, 0.8260195566486366, 0.8451841070284132, 0.7261648584565052, 0.5134823530643358, 0.5011761355425008, 0.5329156088861178, 0.36751892784083684, 0.13022707602743633, 0.25654931174320805, 0.4604747174431485, 0.2591215676781705, 0.543742863881086, 0.23172622892613381, 0.3078689321818998, 0.1987082200403676, 0.25600978606970926, 0.5848468934057502, 0.3084259522056898, 0.39496875373660345, 0.21549558631710974, 0.22855308180384082, 0.13173038628751055, 0.5748242877984125, 0.2526210735044446, 0.4888510878978152, 0.10796406077223109, 0.22421850310611202, 0.183399309885366, 0.3995373389850164, 0.4324610499817805, 0.6343793099357797, 0.6242811333418725, 0.6118015404355035, 0.7036671663425862, 0.16796924115640754, 0.5994681352871578, 0.28360724905404844, 0.7270295727736338, 0.6148196496258223, 0.2549051111217965, 0.14740212986986623, 0.2429307752624773, 0.5867268814532646, 0.2051861770564034, 0.14420140963409955, 0.28277033150290776, 0.1825911999916765, 0.16075773605883603, 0.33726660420362464, 0.4283072134356952, 0.41342679259390136, 0.5396618472888262, 0.3618464923523188, 0.4973462512941451, 0.44936499970437227, 0.39699631201195384, 0.441505811466541, 0.8398389226148123, 0.8257440346287028, 0.8281419006487009, 0.7915871984176022, 0.650173506524479, 0.8186364972789604, 0.8439918063781328, 0.8230959081088052, 0.806376491827373, 0.0953880100972252, 0.12555486663212245, 0.1120145840156549, 0.08429010212504673, 0.10579906930515448, 0.1092886977810178, 0.10115526968427824, 0.08843838775813384, 0.10537500884801487, 0.12558630596262976, 0.14305452208413882, 0.16326102896863903, 0.15810858281653384, 0.16119562031704648, 0.14527997928660297, 0.1479147734427917, 0.18409281028316649, 0.14712313165409685, 0.5245699505382575, 0.495788872814383, 0.5854144229693452, 0.5146110314647412, 0.4960794824641167, 0.48839960645714686, 0.5739229190202347, 0.6272867337295047, 0.564239552296668, 0.48409032210555514, 0.36548847559233344, 0.3466862171118482, 0.416771328261361, 0.35181299292533774, 0.3786480173012816, 0.4441818542744136, 0.405322658583141, 0.45596625109871824, 0.19830440664910798, 0.18278722165272743, 0.20990120826141878, 0.1753956332611002, 0.18897716035535372, 0.2049651012678445, 0.18994075949444134, 0.21511793204566965, 0.18874092671339449, 0.17925434794746564, 0.21134602570882932, 0.18045227367784222, 0.5812046573907224, 0.29398990856016205, 0.23670655461205092, 0.18037919750109455, 0.2257371744028388, 0.22533185968562175, 0.1929934554688999, 0.16558858587590497, 0.1657292044327654, 0.8925394053205309, 0.1745518804170948, 0.19282202454621056, 0.17526354059559413, 0.6885224334349076, 0.6761571084762155, 0.6300811301805134, 0.1695050970448485, 0.16664203779640685, 0.19718260272887778, 0.16710903583492942, 0.19723534549479926, 0.1625576008415357, 0.2101203547943512, 0.21189646670622064, 0.18964601334907005, 0.1805084627781467, 0.1793541635695841, 0.1750083734411655, 0.2098572855716493, 0.18972804381558095, 0.1961143527428464, 0.19450664114344896, 0.19188518598757065, 0.08645818027713559, 0.07397495416750066, 0.07934481721946718, 0.0722514705396563, 0.08087288339855492, 0.07952760088134114, 0.0856995761357584, 0.07899014653732228, 0.07483685452860156]}, "mutation_prompt": null}
{"id": "e19557a4-ba78-4db5-8317-e648b3e6d4b1", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "bf10d408-9c8b-4596-aece-f6c013732c8d", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "ed3b76ff-527e-463e-b57d-6311b7dccd55", "solution": "import numpy as np\n\nclass HybridAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly adjusted mutation factor\n        self.crossover_rate = 0.85  # adjusted crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        best_idx = np.argmin(self.fitness)\n        best_solution = self.population[best_idx].copy()\n        best_fitness = self.fitness[best_idx]\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                F = self.mutation_factor * np.random.uniform(0.5, 1.2)  # broader adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                if np.random.rand() < 0.15:  # 15% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n                # Elitism: Update the best solution found\n                if self.fitness[i] < best_fitness:\n                    best_solution = self.population[i].copy()\n                    best_fitness = self.fitness[i]\n\n        return best_solution, best_fitness", "name": "HybridAdaptiveDifferentialEvolution", "description": "A hybrid Differential Evolution with adaptive mutation and crossover rates, enhanced by probabilistic local search and elitism.", "configspace": "", "generation": 48, "fitness": 0.37912395448140956, "feedback": "The algorithm HybridAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.28.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8664087350524126, 0.8297415732750608, 0.8657072615799358, 0.8626506925595562, 0.8739665787833362, 0.8826863828362714, 0.8707305816626866, 0.8777831848766433, 0.861475343261917, 0.7919679336531208, 0.7740374827119035, 0.7876966037944535, 0.7554808486541011, 0.7636366972290727, 0.7589969665475427, 0.7689272829857899, 0.7769848100140754, 0.7829504286389044, 0.09115101270398862, 0.11006081054513528, 0.12059805371990295, 0.09157139649326496, 0.11304386607580763, 0.09340544715476573, 0.10784967281755597, 0.09073014760342235, 0.10614630464541863, 0.08285670886201368, 0.07930296025106687, 0.09576280613793009, 0.10299212436278393, 0.09939314984798853, 0.09928415584755512, 0.11392545024916712, 0.10283774758734565, 0.09741371945177923, 0.9894001372657365, 0.966491722052116, 0.9434480722444313, 0.9616106048650189, 0.9400094605596868, 0.9183175667147191, 0.9773893961752382, 0.9400813153816823, 0.9529166563073836, 0.5995559128318075, 0.5437073128567183, 0.5477138410169906, 0.5718914357218752, 0.5011557816570922, 0.6115324232224788, 0.5730614194099528, 0.5319510453456353, 0.5637296227873363, 0.7506168781177933, 0.8072655422969809, 0.7569720149647721, 0.7283641247580444, 0.7664205421135171, 0.7641906497357456, 0.7997152483413081, 0.7673845641783275, 0.7015535829794145, 0.5392313666533344, 0.4766706048045197, 0.5337376693979202, 0.3264873914814391, 0.12547468185474586, 0.12885542620804646, 0.518049747202207, 0.557376304755187, 0.5049574547598954, 0.5615737261847397, 0.42171183685921265, 0.501491311003305, 0.4549334587283088, 0.5448124667970544, 0.40530545712149424, 0.5644869758315266, 0.48043353721217785, 0.27284589933023906, 0.30640404932057375, 0.2783653612486907, 0.17974421820358333, 0.22587199235598587, 0.17671381123435725, 0.07052297169859212, 0.2387684734357035, 0.41388425612190105, 0.3862592594681875, 0.26369697621851707, 0.3726703698060667, 0.1922177417479627, 0.23838372691724585, 0.27656650494642243, 0.15673530876804143, 0.5394508866018979, 0.14553089471563274, 0.4513580908012208, 0.10529457668141362, 0.10951082230283882, 0.08918341893633586, 0.25985443917213913, 0.13986538521851233, 0.17255820873868488, 0.20795258191699828, 0.12564378836812196, 0.18936773077986546, 0.44587278354366544, 0.35967377571975845, 0.38224003180180266, 0.45493093950775665, 0.39488158732485423, 0.43280107815211166, 0.3480377083121432, 0.44253672797794397, 0.3943237403830595, 0.8027514771616191, 0.7878510282615314, 0.7414635732674242, 0.751874929557846, 0.7723159368501313, 0.7922906608890827, 0.7412911470340003, 0.7653580836099528, 0.7631097738294392, 0.08394114089525462, 0.08677891790251746, 0.11245122861855616, 0.1038694578698236, 0.12481857533442486, 0.09136256706628121, 0.0901749834470622, 0.09369301103625582, 0.0823232858559253, 0.12662646769992758, 0.1322706796760107, 0.17228482170637094, 0.1867294473418304, 0.14298377380795313, 0.14805902810108906, 0.20920392510561048, 0.22344336485525762, 0.1575396661497982, 0.40347373139354026, 0.46618210105700264, 0.5061798829205058, 0.4566019463019476, 0.43536036142460244, 0.39217421093072646, 0.5152150193537475, 0.46071730423399837, 0.4670510079772138, 0.3085844779915783, 0.3145575286479959, 0.33747436684212917, 0.3262462813060226, 0.36659545447041586, 0.2465049794497738, 0.30972534773260374, 0.3660906880207657, 0.3962052786470486, 0.18483286950248667, 0.19672031856635885, 0.18341604385165422, 0.2074568324584145, 0.1784232019751627, 0.1639225520282136, 0.18397475343645664, 0.1832753285363179, 0.18882822633690977, 0.1914388483229975, 0.17923555702585947, 0.18329449414365595, 0.19658677449959028, 0.20739549531491253, 0.236808742387701, 0.18161998002248503, 0.17212019291665692, 0.17482207190094612, 0.7689679669829458, 0.18397576760570344, 0.16120161765100693, 0.17589643180658443, 0.1668746880759301, 0.17444297935795416, 0.17858875727819468, 0.16513964464680397, 0.16982797194468546, 0.16707681744923086, 0.16883091284921614, 0.16744549740354708, 0.730217350300897, 0.16571982155136722, 0.12663326704756306, 0.7977876232524526, 0.15515001670755357, 0.15587974138511873, 0.1924083115328108, 0.17853321063358651, 0.18117635903118579, 0.18122849531431562, 0.18399303695703562, 0.18257802558809455, 0.18625584504587345, 0.26238489153366973, 0.18962120614430855, 0.0742711143930681, 0.06878256055721155, 0.08353460357918707, 0.0889016509372772, 0.07449544492909976, 0.07669700460373219, 0.08160778379947964, 0.07255517830959912, 0.08340803592936741]}, "mutation_prompt": null}
{"id": "4ef9cea6-3738-465d-814f-07f62cbe86db", "solution": "import numpy as np\n\nclass RefinedCompactDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 3 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adaptive mutation factor for exploration\n        self.crossover_rate = 0.8  # dynamic crossover rate based on success history\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n        success_history = []\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.6, 1.2)  # enhanced adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with dynamic strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    success_history.append(1)\n                else:\n                    success_history.append(0)\n\n                # Adjust crossover rate based on success\n                if len(success_history) > 50:\n                    self.crossover_rate = 0.9 * np.mean(success_history[-50:]) + 0.1\n\n                # Dual-phase stochastic local search\n                if np.random.rand() < 0.15:  # 15% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedCompactDifferentialEvolution", "description": "A refined compact Differential Evolution algorithm incorporating dynamic parameter tuning and a dual-phase local search for enhanced global exploration and local exploitation.", "configspace": "", "generation": 49, "fitness": 0.3008920329940884, "feedback": "The algorithm RefinedCompactDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.28.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8943917667765683, 0.8901515365845586, 0.8859671233138121, 0.8977795958307702, 0.9083393146575643, 0.8920254802965124, 0.8972581756050834, 0.908343595291358, 0.8964199405408754, 0.8394279014146346, 0.8105148587208122, 0.8269066813337753, 0.837957864116532, 0.815625962145341, 0.8123050501550388, 0.8494935058935149, 0.8265035133345779, 0.8074835901522428, 0.7303782816527458, 0.7305167281272412, 0.1870514563199267, 0.7291814104061342, 0.6530839121689718, 0.6843099108643949, 0.7692137930629469, 0.6753910265600116, 0.699425427653559, 0.6534434776526268, 0.638153103717205, 0.6330492163273039, 0.17159681125644166, 0.16334552168376593, 0.17534423632060137, 0.699447549784894, 0.17196050766021143, 0.17911015775835004, 0.9871777966518468, 0.9856319511272754, 0.9685177763595921, 0.9755035092698122, 0.9828602996631028, 0.9677832008581412, 0.9793483343814174, 0.9784423066768709, 0.9765710360918947, 0.3973535115858974, 0.3522953217154876, 0.41101415823226706, 0.404596629895834, 0.450869418547859, 0.3156329748243608, 0.3045762061987167, 0.3428991926226638, 0.28934123125683053, 0.25015791999085346, 0.17744063386790654, 0.18382069861411632, 0.4836745007603087, 0.25761528787113785, 0.2546628133107559, 0.21863208197215345, 0.205197016864472, 0.20039870070409393, 0.1772813531144226, 0.17167732533947289, 0.14305878388163784, 0.2015013775130785, 0.16046155368963022, 0.1741669708840653, 0.1680067461806728, 0.17071504416459338, 0.1592303417548705, 0.12817486618142082, 0.16444763492172332, 0.15909249963506933, 0.14704407667281172, 0.16673042375747305, 0.16155489326473127, 0.1674557633178131, 0.18648442310574542, 0.201941393528147, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008341918540354376, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06029695236450949, 0.07211344350946114, 0.046446167303667574, 0.05872618378807182, 0.05489051533119904, 0.03256482123860982, 0.05665135136944022, 0.09956327404015575, 0.05207811876584423, 0.00024356077877896176, 0.007245118344860746, 0.020791315653102882, 0.034039571144580116, 0.10268634878843164, 0.038830064269737896, 0.029686185158218747, 0.0025540958338664543, 0.034926207353361494, 0.06436290490388397, 0.08950531439931164, 0.09045406049114213, 0.10688785583933402, 0.10247788226901344, 0.09605934106063885, 0.10185602156087281, 0.10496421466728811, 0.13049456596703657, 0.45998676027479257, 0.4600305194125731, 0.49177914446361015, 0.461099133657602, 0.5131296609335013, 0.4688989337523458, 0.49305398988523497, 0.4947756473024648, 0.4801891638348661, 0.09107772344845166, 0.08673907149812854, 0.09844446592669354, 0.10210228426285994, 0.1103077557073937, 0.08491980418319922, 0.1093121225806668, 0.1127135996909574, 0.08424258613613111, 0.15283829989075226, 0.13317191076064205, 0.15990197726045186, 0.1263493174568997, 0.13819231356039363, 0.13805509701124918, 0.17969596369125507, 0.146746658997003, 0.1290823826700569, 0.3274025031533777, 0.2872538027183229, 0.296162950633435, 0.2814334324143646, 0.30889903009594855, 0.3313138536854582, 0.3383198716779082, 0.40617638396247335, 0.3391643166885734, 0.20038967793840923, 0.21361211625271548, 0.19623374197283305, 0.23904900652513372, 0.20168093870616655, 0.1525523444037057, 0.2311601949389115, 0.3101261063276851, 0.19440241955700777, 0.22139519106546213, 0.19022132738115016, 0.1877565791791087, 0.19385272164498846, 0.1800981979140135, 0.20145114824171417, 0.20008894128226629, 0.18196740967418024, 0.17537684966623512, 0.19411010104654414, 0.22911783791192053, 0.2084167599832355, 0.23873164971259087, 0.2179430619533802, 0.2176641095804045, 0.4940619548545826, 0.2651317816021227, 0.19945669494187745, 0.16405999079110956, 0.16948479161648722, 0.1804149494078785, 0.20590096313985684, 0.18156914046699868, 0.1597920816320575, 0.16752139889662243, 0.2592413292000366, 0.1664118486202686, 0.1271632213539029, 0.1817935315269733, 0.16683870299632786, 0.20606274604413888, 0.12513102783969754, 0.17750051908662134, 0.21287701501076706, 0.20541168080760086, 0.3784797486413798, 0.18387927719666475, 0.18671552133279656, 0.18000904349324776, 0.18309589181566877, 0.1838606271577874, 0.19773952656236604, 0.19992169628524048, 0.17030719683022622, 0.17634942043953905, 0.07418284742396031, 0.08638281872234854, 0.07578564275967181, 0.07214807308045879, 0.07365514956055086, 0.07601614264954404, 0.08242437941627412, 0.0764023667726722, 0.0741699065945588]}, "mutation_prompt": null}
{"id": "77bdcd61-e6f1-4556-a35d-34a76f294d40", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "39b8b9da-7e9a-4c43-894e-1c28d82fb4b2", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "f7f4b085-632a-460a-9a06-3f7296dfb2a2", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "2e3816c3-5525-43d3-8e7c-2627d48e65fb", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "638a1078-ff0a-4503-b5cd-589a4ed1dbd8", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "dabb1fa7-b897-4331-b1fe-936bc20ba4bc", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 3 * dim  # dynamically adjusted population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # maintained crossover rate for better mixing\n        self.dynamic_local_search_rate = 0.1 + 0.1 * np.random.rand()  # adaptive local search probability\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.6, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < self.dynamic_local_search_rate:  # adaptive local search rate\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A refined Differential Evolution with dynamic population size and adaptive local search to enhance convergence speed and reliability.", "configspace": "", "generation": 55, "fitness": 0.3744943085467938, "feedback": "The algorithm CompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.9072508591901571, 0.8894422290966155, 0.9161378603994818, 0.9172518266877626, 0.9273124973693917, 0.9091955492168289, 0.8865511425435423, 0.9175749964467516, 0.9164265769178306, 0.8651936644573999, 0.8484662738529573, 0.27828354900022634, 0.8527056947475581, 0.8474319837115605, 0.863510178839359, 0.8629779408936228, 0.8070966823289734, 0.8103799294041399, 0.11253283988559837, 0.11933268207408632, 0.1278285252599437, 0.110138370482595, 0.10802804775288699, 0.0721309635929469, 0.11596603038159758, 0.10923246563878164, 0.11289312716170685, 0.10828189942512112, 0.10731964936787664, 0.09615065130528655, 0.11219537908811494, 0.09443644981224808, 0.23520820234408224, 0.10002371107818964, 0.11199653173512292, 0.09602337553072016, 0.9733050619852891, 0.9644259519830113, 0.9487747275233795, 0.9467472213395313, 0.9610856792285117, 0.9457751972652797, 0.9558534979200168, 0.9744780497442915, 0.9668858885264936, 0.6677294601160302, 0.7136425286930705, 0.7743569260504485, 0.5709194454681794, 0.6820479689758292, 0.6805062095058947, 0.7353180219057636, 0.5750970806113922, 0.5573832181964938, 0.8919612431037407, 0.8890649879452581, 0.8620605653597813, 0.9013632801743723, 0.22904742805116007, 0.905510745889712, 0.8855254439602015, 0.9167503453539032, 0.23749810879370292, 0.1816049871181551, 0.15152202954510718, 0.1718983457869423, 0.2042583561544843, 0.1705994567685415, 0.16125877384852938, 0.835359962969279, 0.15715281602057618, 0.21255736444598716, 0.20055420129411483, 0.1551156068031767, 0.21223071926208226, 0.1875475029034438, 0.12799539227983092, 0.2584584775675922, 0.1865174062313263, 0.20076164448215628, 0.22014367012195912, 0.10183071012654277, 0.33769645394294756, 0.03148377347086462, 0.1192730819880089, 0.04844187033280001, 0.16209610074783942, 0.5601349022568811, 0.031165015055826917, 0.0702560746898887, 0.17113979842103944, 0.16362589195217658, 0.1081812461517988, 0.27410011286582747, 0.21984999991345633, 0.2991613038793647, 0.2537740864278497, 0.3696913632296758, 0.2632372173699138, 0.06346660597316245, 0.08128383607326528, 0.06984755383546526, 0.137726611829323, 0.20826308558149398, 0.3450684513514206, 0.12456623764807206, 0.41196773408676035, 0.2187986753906972, 0.3597808652718094, 0.21940287915652956, 0.3440295973393356, 0.5793335571094977, 0.34055407521436687, 0.3792307628445446, 0.2174422408054435, 0.3563932523137012, 0.3042964484916151, 0.5593204870846071, 0.5272523637633795, 0.4841116956791217, 0.5745337476113903, 0.6366109720900486, 0.7136898908592811, 0.5703750962674572, 0.5310386882048397, 0.6797214693147002, 0.10352575719387458, 0.12551388524561913, 0.13413221212322313, 0.10667113707616027, 0.09597481254637352, 0.10435669983375484, 0.11153909731369771, 0.12792512389077126, 0.09708738132692396, 0.16963303047520817, 0.22880340684218514, 0.250816987927144, 0.201545453178669, 0.4723673049953565, 0.2671222611796491, 0.19422490559925054, 0.30353784842232645, 0.29159925544752197, 0.23129620016781793, 0.5120304201812853, 0.5992220245686756, 0.6853303669496174, 0.5343671947024384, 0.7330433006323736, 0.6796418335478771, 0.6508169329791441, 0.6160344208622822, 0.4339992878261325, 0.47591112311959183, 0.2879983465252812, 0.3302443400734909, 0.5238487789359938, 0.24503716726382685, 0.6671944215878778, 0.40778279616589674, 0.5273120285755217, 0.21452653155071744, 0.18376560461482006, 0.1989892073548255, 0.20713127205695125, 0.19034489780712416, 0.19112475052367417, 0.20702193872244, 0.2150313973247292, 0.19657420406411252, 0.20167663894036936, 0.23050664286622813, 0.20741143444182397, 0.584877694852229, 0.5329813596716484, 0.45276493175667587, 0.22114888315405412, 0.2240625565032408, 0.5962200842198911, 0.16489315753788902, 0.2109761178136701, 0.16532313567968582, 0.1989317918409731, 0.17647778382557588, 0.8698580356277044, 0.11449376508954556, 0.13088704289536968, 0.9226232769918634, 0.23121586093875646, 0.12794678306444363, 0.2718700166634046, 0.16726637502009833, 0.15163534322937178, 0.18060434453411256, 0.15552191539988047, 0.21369883713921223, 0.2128905210478812, 0.18265559047753988, 0.18937897045526464, 0.17622824263579862, 0.20276026360059318, 0.18236173707857095, 0.1925373292381255, 0.17610718140801496, 0.2014743028969438, 0.18395184913713158, 0.081320031552376, 0.08102638601945855, 0.07751234976961474, 0.07766607593936237, 0.09166946624629546, 0.0848430799858817, 0.08443147436503828, 0.08892462772957732, 0.08035478921492212]}, "mutation_prompt": null}
{"id": "e8b9f7a9-eb51-4782-a9ae-67e3e014118d", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "1917d64b-ef79-495e-807f-5cc7210b4965", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 3 * dim  # slightly reduced population size for efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adjusted mutation factor for balance\n        self.crossover_rate = 0.85  # fine-tuned crossover rate for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive multi-strategy\n                F = self.mutation_factor * np.random.uniform(0.5, 1.2)  # adaptive and dynamic scaling\n                if np.random.rand() < 0.5:\n                    mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                else:\n                    mutant_vector = self.population[a] + F * (self.population[b] + self.population[c] - 2 * self.population[i])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Enhanced stochastic local search\n                if np.random.rand() < 0.2:  # 20% chance for enhanced local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A novel compact Differential Evolution variant with adaptive multi-strategy mutation and enhanced local search for robust optimization.", "configspace": "", "generation": 57, "fitness": 0.231645494739451, "feedback": "The algorithm CompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.25.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.6619739779671898, 0.746530776818102, 0.7170387207907722, 0.6586631202481845, 0.720523035100229, 0.8007291750127348, 0.7011518244611985, 0.792750206749631, 0.7139184353162973, 0.707919048424517, 0.736509122771662, 0.7244920150822693, 0.6792811048342055, 0.7564762068856612, 0.7216015338037098, 0.7370292265363394, 0.735366190376405, 0.7428645774209051, 0.0815728177420415, 0.08499310181372388, 0.08597092237785708, 0.07480375717834942, 0.07401741280459484, 0.09559028641566003, 0.0814420305685164, 0.07589166557505356, 0.07723844685940273, 0.06761636896277634, 0.08040795261125366, 0.06611410448536303, 0.0715723550201468, 0.06804310911539069, 0.07179912977910685, 0.0783020620960655, 0.07003948643283597, 0.08396272395158744, 0.9640592403457158, 0.9906170702692849, 0.9618114244794107, 0.9888457682975056, 0.9814733716134912, 0.9594551103432079, 0.9885483829485081, 0.9644185256434648, 0.9764097743034894, 0.13086818833234415, 0.16280438938387598, 0.12165989944354516, 0.12413290724704984, 0.14699632996779133, 0.10752239808713038, 0.13365237158629373, 0.1449605267914592, 0.14070648033490507, 0.2950072587501785, 0.2966786704046722, 0.2689561362778864, 0.2840215855740368, 0.30912433537016315, 0.27895030648342745, 0.252319431916072, 0.3207573078666154, 0.31867214763951845, 0.0876309706683831, 0.19163293945626092, 0.038756868614745366, 0.36974055659291305, 0.196925465751438, 0.08360702350108462, 0.09364985424379302, 0.28220702529045816, 0.13672498867120808, 0.11891869783218845, 0.14704716670540152, 0.1391376095325455, 0.11150235388165419, 0.1099482895315359, 0.18731839445206933, 0.019507842141091913, 0.09509306820956986, 0.18849321658229712, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00019785051580056834, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06389871818914539, 0.06839866995771149, 0.07294154015172882, 0.07839491397608378, 0.054578890206432695, 0.0824189155050894, 0.06163935600283332, 0.0980846347090173, 0.06934920742440476, 9.999999999998899e-05, 9.999999999998899e-05, 0.026075571380188234, 9.999999999998899e-05, 0.035376149758583275, 9.999999999998899e-05, 9.999999999998899e-05, 0.03599610219054428, 0.006535308353678881, 0.04491831401832147, 0.10983448548116415, 0.08955670356304746, 0.11164058539927246, 0.0768777002564851, 0.07023611851082989, 0.1037834816300246, 0.07798833697850316, 0.09397547542197948, 0.4388385778248468, 0.5007930130271222, 0.5409634610256197, 0.5684986086143351, 0.5857681408419192, 0.5442187795230289, 0.566304586442602, 0.5957767337624789, 0.5817754486779809, 0.07973372838272041, 0.08791703150149355, 0.09223222561038458, 0.07404117618263661, 0.07284246686077422, 0.06811135092176734, 0.08795975510408738, 0.08964671566976212, 0.06819456557725734, 0.13782011456311116, 0.15511506673584352, 0.15445572267931784, 0.16420027889771938, 0.1391790725495612, 0.20997659539934632, 0.2394082035011107, 0.15316513335570603, 0.12890042830379933, 0.20694110217704031, 0.22381306538804813, 0.21191211910190244, 0.17358836574284253, 0.18320592391865032, 0.1937710471728511, 0.23711054779720908, 0.25064477414449715, 0.23385136981724475, 0.14866813263439305, 0.13953949235425933, 0.13892039698320946, 0.14940404511004057, 0.13418979225757066, 0.14183183494751517, 0.13895638641437558, 0.1638012833032706, 0.14760925410890102, 0.17701420744082663, 0.17279882443620442, 0.18844036912274043, 0.19444383271994603, 0.15268883122338517, 0.19855902975500972, 0.1805923470503823, 0.18437025226817028, 0.17519486286294417, 0.16312560151619182, 0.17394029661269328, 0.16025929967584585, 0.1796546022504244, 0.16407955813311514, 0.17178782473787435, 0.1737727530883112, 0.17271531664197193, 0.16202862860673117, 0.16882501641610193, 0.2567478677067381, 0.15114595820510335, 0.1593218185876114, 0.16575313898012223, 0.17845011459549098, 0.15698311488083982, 0.165253221138423, 0.182406875567115, 0.16623762969958356, 0.17222471293977415, 0.15612551372175187, 0.15976825309759302, 0.1707055257550113, 0.12166381710096663, 0.208828338365586, 0.1113568271769938, 0.21085189536049465, 0.18877852054640265, 0.17969447297692132, 0.19327725676134277, 0.18156695527382039, 0.2057516980300066, 0.19997034052764462, 0.18699283200447747, 0.18509389051281977, 0.20963776155130964, 0.06253136649614466, 0.05991513246025859, 0.06628084067849471, 0.05793279685092334, 0.061833179579983355, 0.06992908536105913, 0.05460294992126946, 0.06752707139630842, 0.06293398711371923]}, "mutation_prompt": null}
{"id": "f6434208-6c37-4543-a63a-9fe79a7d4846", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "599b9425-e9ce-459a-8463-78c785d2365a", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "1e9ddd8f-a43d-4bbe-9ad0-c255da09bef9", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "2e60fd40-314a-4a08-a559-105544d4f938", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "0de985fd-8e96-4c50-a018-2bd13ab90880", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "757e1440-62e3-4247-bacf-e564690156ca", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "55d1fe54-3f56-4b92-82da-bf34b6b2303e", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # increased population size for better diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.85  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.dynamic_resizing_freq = 0.2  # frequency for resizing population\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.15:  # 15% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Dynamic population resizing\n            if np.random.rand() < self.dynamic_resizing_freq:\n                self.pop_size = max(4 * self.dim, self.pop_size // 2)\n                self.population = self.population[:self.pop_size]\n                self.fitness = self.fitness[:self.pop_size]\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with adaptive parameter control, dynamic population resizing, and stochastic local search for improved convergence and diversity.", "configspace": "", "generation": 64, "fitness": 0.4037281141914298, "feedback": "The algorithm CompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.903505092696444, 0.887104172059427, 0.877093795464242, 0.9065508874478884, 0.8785419623553364, 0.8928208844564035, 0.8896914943485121, 0.8901165987057784, 0.8933578596831276, 0.8135684255007215, 0.8137087131517836, 0.8277846999442615, 0.8098139512649729, 0.8196311241370169, 0.8077195167379193, 0.8279004840460922, 0.8119308592733909, 0.82484706569317, 0.1145617068679261, 0.12468950355224229, 0.09537038294973132, 0.12116080129385387, 0.10902565687540422, 0.09774977196227608, 0.11073101627518644, 0.09748373794532994, 0.2962561086381563, 0.09384874103304397, 0.12392179517712543, 0.1400929409784032, 0.12632647185438595, 0.10922754803733636, 0.11007718174909309, 0.10990826227445105, 0.1070128393721016, 0.10652726932218559, 0.9632933432247927, 0.9741042094356517, 0.9562078523967912, 0.954309019197507, 0.9528771513618892, 0.9801784883845022, 0.951577078436745, 0.9453092842049646, 0.9401662072788374, 0.7309073659173617, 0.6517438297711, 0.6907015903404335, 0.6906359991696086, 0.7012716097124811, 0.6872716635830083, 0.6313187581021444, 0.7375799649259587, 0.7020865548017847, 0.8181447551191671, 0.8050043189900223, 0.8176371038499745, 0.901132006271303, 0.8864116154922173, 0.8542283941216636, 0.8833143820976335, 0.8158311838513141, 0.7451139446187895, 0.601039701242881, 0.12837705761125984, 0.17411067372845523, 0.39796777682983864, 0.17276075008460934, 0.1624354724545568, 0.18925888891794296, 0.2168488769720609, 0.1700769110320609, 0.18252958145761222, 0.22150178039048762, 0.24253829078689215, 0.12867224876413075, 0.1870046030134741, 0.3625305398846622, 0.22381246781658548, 0.19605208568667087, 0.21391537262914528, 0.42306644924635384, 0.3056244070715698, 0.2300879343132085, 0.4097288399684318, 0.08913146000948069, 0.3161368960215065, 0.6033839905471843, 0.23696673500627774, 0.20327601289051367, 0.09284718429827465, 0.39518556669000204, 0.5866011277748024, 0.10034679569572358, 0.06026450382430393, 0.1742899423434432, 0.39080326766206464, 0.5361465385892451, 0.41752139980694114, 0.18205802479316402, 0.1289819701367092, 0.12479835838668385, 0.16887606033381342, 0.16662974200333247, 0.18789634640629393, 0.2322236040805732, 0.19754112006305147, 0.15823984113524292, 0.4264815402680906, 0.5481906794456393, 0.39062566945756727, 0.5187964461154781, 0.6036673698726451, 0.4308873420335828, 0.3986520617266347, 0.19132169004762056, 0.4163804787753521, 0.8355803586452654, 0.6998757848547428, 0.8460634830652317, 0.8042118400995214, 0.8258411346256325, 0.6834394659370073, 0.7556576149301408, 0.7601682344578194, 0.644061615162518, 0.10281919240443316, 0.09163275345501243, 0.0941059109077409, 0.10720923521957904, 0.10125801440608406, 0.08864043375038999, 0.08833401488001602, 0.08970772906160729, 0.09549799269869386, 0.24146343325603836, 0.5622417407696418, 0.14254610830280567, 0.139286420536207, 0.1419277109570679, 0.6607104982719252, 0.16165950248073657, 0.2118314363539725, 0.29286401009568985, 0.5984681719869696, 0.6387965736770234, 0.5008829599168763, 0.5803456178171258, 0.5831260810770322, 0.59317623459019, 0.6412472132740263, 0.6106598865729205, 0.6565246976604262, 0.37233078095125416, 0.41820350003281515, 0.4168520192524088, 0.45995761045893235, 0.2800280328777096, 0.46164850668766433, 0.576232324584097, 0.45368637815520596, 0.4352373139969524, 0.1831167308738212, 0.1963226962735536, 0.20354820346820157, 0.19945115599831997, 0.19067869061902265, 0.20048784827510324, 0.22427377542481852, 0.19177498007958393, 0.19554348587097603, 0.5375924464275614, 0.36968095030490744, 0.1923325320607222, 0.21783398399331733, 0.22232261591761016, 0.7832869726442334, 0.19953590275115207, 0.4061570457878594, 0.19178758614632274, 0.8298885461211123, 0.15783793234173515, 0.1762542468644409, 0.16507065075076244, 0.18738268792801338, 0.18758759292295468, 0.18117025558103728, 0.7783983283857039, 0.15697898991530146, 0.8278352204859821, 0.20020050276361012, 0.12612603278748646, 0.25825874024115114, 0.1674714359906182, 0.20691713618916385, 0.21069074526016462, 0.15560663986053236, 0.2113493763676716, 0.18624590209676017, 0.1938399483943123, 0.188924327728067, 0.18612240524453794, 0.1781285376830023, 0.18667305201264017, 0.19040995593549692, 0.19084646823728313, 0.1863435143674469, 0.08667620439651214, 0.07783024773914671, 0.07298205764643628, 0.0929240703856904, 0.07308319538767682, 0.08388032147409763, 0.06899258250309837, 0.08210620533227653, 0.0893639580281711]}, "mutation_prompt": null}
{"id": "fcdbd22e-8d70-4d66-a1e5-427c3388525a", "solution": "import numpy as np\n\nclass HybridEvolutionaryOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # slightly reduced mutation factor for balance\n        self.crossover_rate = 0.8  # slightly reduced crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.elite_fraction = 0.2  # preserve a fraction of the best individuals\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            elite_count = int(self.elite_fraction * self.pop_size)\n            elite_indices = np.argsort(self.fitness)[:elite_count]\n\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Mutation and crossover influenced by elite individuals\n                if i in elite_indices:\n                    continue\n\n                a, b, c = np.random.choice(elite_indices, 3, replace=True)\n\n                F = self.mutation_factor * np.random.uniform(0.6, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic perturbation\n                if np.random.rand() < 0.2:\n                    perturb_vector = self.population[i] + np.random.normal(0, 0.05, self.dim)\n                    perturb_vector = np.clip(perturb_vector, self.bounds[0], self.bounds[1])\n                    perturb_fitness = func(perturb_vector)\n                    evaluations += 1\n                    if perturb_fitness < self.fitness[i]:\n                        self.population[i] = perturb_vector\n                        self.fitness[i] = perturb_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridEvolutionaryOptimizer", "description": "A hybrid evolutionary algorithm with adaptive parameter tuning, elite preservation, and stochastic perturbations for robust performance across diverse landscapes.", "configspace": "", "generation": 65, "fitness": 0.1989183116305988, "feedback": "The algorithm HybridEvolutionaryOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.19.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.7047859519586287, 0.5362670314670952, 0.526489662679092, 0.5306139221481053, 0.5859676353406598, 0.5234238577176302, 0.6586095732215025, 0.5787618543594487, 0.5355623429798655, 0.003444690506010595, 0.05210911288512743, 0.025994085439261627, 0.12567563529072923, 0.10547876477190399, 9.999999999998899e-05, 0.055737810951504985, 9.999999999998899e-05, 9.999999999998899e-05, 0.08691598347130947, 0.09740501614337349, 0.12820216760467118, 0.14667644367043053, 0.14538317729521677, 0.11311414123854979, 0.11845730835910184, 0.18992048144091256, 0.1456075977612843, 0.08883278874586886, 0.05613555897968803, 0.07064165080443707, 0.08740305944019833, 0.06411144682306402, 9.999999999998899e-05, 0.07572640387839369, 0.09350144913462521, 0.04488483024262879, 0.9591573830341683, 0.965756983853759, 0.6398477154232501, 0.29998374594657984, 0.7531419262532854, 0.941585741058121, 0.5516553056398974, 0.3742596655789814, 0.9688454137393712, 0.3424680951368265, 0.2720054229292591, 0.38246147921583484, 0.31400285733117783, 0.35306048356843345, 0.31254650576202647, 0.2775321201530071, 0.28858108816019057, 0.3355889856216362, 0.2187849862661727, 0.18533565318627787, 0.0672603133741777, 0.18072938003867767, 0.14611811793514806, 0.10691778340462466, 0.7015173032096116, 0.08047511995071999, 0.1888689182695129, 0.18815524667837968, 0.12756585621886807, 0.1426970941846032, 0.1723707455925767, 0.13699770516677312, 0.16677961648286255, 0.15550065346218545, 0.13334401264149542, 0.13386970847803625, 0.14995058568810127, 0.09365450454392943, 0.191061931357018, 0.16350153465024797, 0.15904426098077706, 0.13980266335798586, 0.134544465026034, 0.04793277041762545, 0.11798387736116434, 9.999999999998899e-05, 9.999999999998899e-05, 0.06163976755806688, 0.001994158445300487, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06562057992181547, 0.040177727984005096, 0.16114726995593298, 0.061378122081129916, 0.01615586471581154, 0.0028103648071126086, 0.11205691020960207, 0.08920498646943087, 0.05147422719224071, 0.017512690956845267, 0.04905505535570609, 9.999999999998899e-05, 0.028855714800124943, 0.013910647838100698, 0.043259689308599136, 0.0054948927144118365, 0.03165026251221048, 0.06511594146747213, 0.13117986465225695, 0.04069774463092779, 0.1776997882013842, 0.10198437260786852, 0.146855413309675, 0.02175693686429625, 0.126216951795744, 0.14754926771622445, 0.12042225590408384, 0.5120520115197459, 0.4818975116685398, 0.4364467281812745, 0.44201756312075824, 0.4967362563970632, 0.436314434841757, 0.46576204935540466, 0.4472400861665411, 0.5139418199779295, 0.051666817111943986, 0.05327073510491487, 0.105772624294733, 0.15043727300440313, 0.0412762816333192, 0.10831371388232824, 0.16278038000980888, 0.0939457810481541, 0.08478040217023697, 0.15996967411386198, 0.16543023551750935, 0.15142789211919772, 0.2068415498002213, 0.1596498917457284, 0.10449378975917023, 0.2591379527416381, 0.12427943511011219, 0.13234041838661492, 0.1688037541901185, 0.20665589931447192, 0.14949716495217613, 0.23151154318687728, 0.19469762302643256, 0.1692214303771723, 0.14571942258898485, 0.33580085569125184, 0.1062629020842587, 0.12241816606255684, 0.14695435497276266, 0.10539338400370524, 0.1524926281178448, 0.19664542586688138, 0.1419811887658129, 0.11159584684392043, 0.14077978101282074, 0.10096131437425959, 0.21950062328385112, 0.1648474449913283, 0.13395831895853083, 0.20761152264975147, 0.15765042546597519, 0.23959715407057935, 0.1799590500147098, 0.20594322150580646, 0.1893688925635666, 0.17086887491190306, 0.21207948096175055, 0.17784980279373253, 0.1808683822042042, 0.20100946339938863, 0.20156915326531089, 0.17983417009479508, 0.1928001273330575, 0.20101186940560556, 0.21031944508095313, 0.12698030277120742, 0.15332208359775545, 0.17375230244442696, 0.8310497493312491, 0.20157093556133332, 0.15459283228432452, 0.16849004802638123, 0.10382792130477103, 0.49301091393523366, 0.21484535665474946, 0.07357568145248061, 0.20510089478168858, 0.36313162695320833, 0.16731485474973884, 0.1696120423485874, 0.44524106293164867, 0.4054348853966996, 0.18989157231572218, 0.209576072941695, 0.16512399755841112, 0.1873322679828474, 0.18213168688901038, 0.1987358084073142, 0.20336604086379473, 0.21294861531631204, 0.18973954776650137, 0.09520079866199538, 0.09779057911271449, 0.0655469866380528, 0.06559765442902876, 0.09256230230446072, 0.05741681236079099, 0.07047496482272142, 0.07038789829798064, 0.060250160788395846]}, "mutation_prompt": null}
{"id": "b52f7c2a-6938-4ddb-989b-48245c154568", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "2f27162f-bb99-4146-b33e-29a102dbd0d2", "solution": "import numpy as np\n\nclass EnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # balanced mutation factor\n        self.crossover_rate = 0.85  # moderate crossover rate for improved robustness\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.5)  # increased variability\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)  # narrower local search\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedDifferentialEvolution", "description": "A compact Differential Evolution with adaptive parameter tuning and probabilistic local search for balanced exploration and exploitation.", "configspace": "", "generation": 67, "fitness": 0.35244925238552555, "feedback": "The algorithm EnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.25.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8197320892201181, 0.7994693031928085, 0.8189000326838544, 0.8239342361085613, 0.8151179146813021, 0.8103769983874891, 0.8128849554699501, 0.8332345167655021, 0.8127261466207181, 0.7246637319083361, 0.7009284409659486, 0.6899947938313453, 0.6847805801308114, 0.7018542537203221, 0.6453737609855483, 0.7077602130069753, 0.6632650307881709, 0.6946525132826249, 0.08770247158661737, 0.1075257006881788, 0.10294222408493914, 0.09842753265805326, 0.09366377797386483, 0.08585457944939678, 0.09412097116474383, 0.08843112170489731, 0.09853999929844615, 0.08149199778498861, 0.08643585645584262, 0.0870619323141284, 0.09542930186661325, 0.11267953538046316, 0.09240232574883178, 0.08463864307152746, 0.10520550735095946, 0.08201669530663569, 0.9824309596238029, 0.9547507330513455, 0.9551995520066279, 0.956286585606877, 0.9748244716781207, 0.9485766651056322, 0.9420880218979297, 0.9680468958283724, 0.9213299268242344, 0.526644358128866, 0.42550534300682064, 0.48396979554928476, 0.45878390430509686, 0.4714554249554379, 0.4715500743329657, 0.4766777622654146, 0.5267719406405931, 0.5084591862469656, 0.6825148325280008, 0.7158643133166012, 0.584806260905766, 0.7367538472741653, 0.8003913331492432, 0.8282337003337114, 0.7395109026842364, 0.745250894593626, 0.7152988967587675, 0.4779758421100845, 0.45934321436211134, 0.40599587766708056, 0.420452083778561, 0.3557100969008862, 0.41770967447910523, 0.4039894574965782, 0.40414584127707986, 0.4009875399105389, 0.31980811951978105, 0.4064036614574049, 0.2714033828182574, 0.44053046789964423, 0.4181620889456602, 0.3430035018853713, 0.4261353253588074, 0.32534219689146837, 0.11948256627382214, 0.28012897347969123, 0.33419076444033846, 0.31247745773687097, 0.33542686189999504, 0.26214548239430957, 0.2412037280711733, 0.19327932306767903, 0.3834149301184693, 0.20214674037359814, 0.43889044138108035, 0.2323493147748963, 0.34954176563876393, 0.2767989538699237, 0.2923063011345549, 0.2695878932979856, 0.47474935673002827, 0.46529768539641025, 0.36080875386724987, 0.08197600886725254, 0.1508855262301173, 0.11362729997662413, 0.22225900457696568, 0.17877898338697162, 0.08414041231144043, 0.11961575053451667, 0.14434405654361127, 0.11777816611082015, 0.30525897911327426, 0.29112556652161703, 0.28240234282113275, 0.33246220007084626, 0.30916019234968395, 0.3383604961991369, 0.28382046919653225, 0.283194024926959, 0.30101141710066126, 0.6714485104485304, 0.6581577715237009, 0.6998325208607009, 0.7182558764197291, 0.6949561907685381, 0.7075518337704265, 0.6990233066670952, 0.6765889304539843, 0.6721864071868728, 0.09294243082816434, 0.089385886089965, 0.08776630134471375, 0.08882163349252514, 0.08879617143400265, 0.08614407672593838, 0.08289604418317198, 0.08915370480025464, 0.08802189649638403, 0.23354205099676129, 0.25129976696421086, 0.15032557734133278, 0.1854377179076625, 0.2561138317681988, 0.46083911506605, 0.13565758854581322, 0.1453373516245844, 0.16227036284224794, 0.365566343386593, 0.3623875122450281, 0.3908634992422758, 0.3309721196880685, 0.3186737363019496, 0.37394732930591457, 0.4082546752584494, 0.36876622478109766, 0.3985438096788564, 0.32647686628604455, 0.290697719528648, 0.20850399938041542, 0.275962033895665, 0.25373045462469856, 0.22005830695416906, 0.3057808389520631, 0.2935087400957572, 0.2988525274787921, 0.17330491219482969, 0.17300765951412211, 0.19822377781028178, 0.16914516085931441, 0.20334784796369298, 0.18302545713334972, 0.1885329947695964, 0.18482488098443806, 0.1857942899656012, 0.17532904279218642, 0.1746961791415128, 0.17352237346344157, 0.18031025651251587, 0.1784095438382799, 0.17858459075634214, 0.17633621333341476, 0.17423973337696974, 0.1808304062526851, 0.1713074558099541, 0.17013831938344448, 0.1619466988536633, 0.17790476107278974, 0.19234588388026852, 0.18334321056736624, 0.14738307758837565, 0.1860748532974571, 0.18022033114579206, 0.16112500046419842, 0.47243129438519094, 0.16358513125398144, 0.2087711613329445, 0.17967474902572467, 0.6611672803340705, 0.21082205273144095, 0.21004639246925128, 0.7176435604080488, 0.18276107204877834, 0.1731368916665771, 0.18990049485222105, 0.17798965151659962, 0.19779428776227737, 0.1904929704080197, 0.17666342868175866, 0.23287958520654262, 0.2066821398026789, 0.0643930809559532, 0.07299249335470681, 0.06664666970543842, 0.05936503502226387, 0.07615489807226261, 0.0709860405016538, 0.07353554558376285, 0.06799447255418978, 0.06925079749381091]}, "mutation_prompt": null}
{"id": "9d355e8f-eb5e-4762-aa08-1223c434907a", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "e1ef880c-97ad-415b-b2b5-4b18c5d7ebab", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "bcaeaa5b-28f6-4dd7-a396-72eed0f65cf0", "solution": "import numpy as np\n\nclass EnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly reduced mutation factor for stability\n        self.crossover_rate = np.random.uniform(0.7, 0.9)  # dynamic crossover rate for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 1.2)  # broader adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Dynamic local search\n                if np.random.rand() < 0.15:  # increased chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)  # smaller perturbation\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveDifferentialEvolution", "description": "A further enhanced compact Differential Evolution with adaptive control of crossover and mutation, incorporating dynamic local search and diversity management to improve exploration-exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.35980695796187223, "feedback": "The algorithm EnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.28.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8647236828191943, 0.8674705641880667, 0.8683248867272637, 0.8478473271802638, 0.8915241288999147, 0.8601981575177029, 0.8728130869794594, 0.8485862038158852, 0.8690326209449935, 0.7749744050399179, 0.8022713805484984, 0.8089738356196049, 0.7820377232147446, 0.789312445097528, 0.7936072700243947, 0.7972244247159542, 0.7989312791021019, 0.7955649478433799, 0.09972697472417547, 0.13181052794366865, 0.0947846566349606, 0.09848273793045115, 0.10479486165118346, 0.10363834495761459, 0.10093521775598091, 0.09689328015261778, 0.14334428927856557, 0.146474069206037, 0.0982403891532907, 0.12931216121507716, 0.12323495447747934, 0.09233203734917883, 0.09603029492937531, 0.11319347205362595, 0.09363728118850811, 0.07830300527607847, 0.9753822284864352, 0.9640181692873954, 0.9278821635332487, 0.9707382194380494, 0.9537406941257153, 0.9246541622109818, 0.9329242804184724, 0.9808529139707861, 0.9480948240098662, 0.6212884989756107, 0.627004030918352, 0.6491489958265296, 0.6613262898146599, 0.6612770197511069, 0.6393033012642408, 0.6367783222735877, 0.6380582818233334, 0.6059259579447964, 0.7788215665940468, 0.727296250069086, 0.7805499037921435, 0.8534846065533603, 0.7694996751706539, 0.8046264001440553, 0.8287179895426366, 0.7476951143237376, 0.7897632090685498, 0.36846507659142724, 0.2960121595229469, 0.2969536033173735, 0.36135585302181783, 0.4401062367677345, 0.3709280186648314, 0.3961736818556313, 0.40690599221101487, 0.2211555552606389, 0.21962505820615819, 0.26552673086797474, 0.3741723948086717, 0.5401396672897512, 0.28165323162813993, 0.2846375168969755, 0.49049794954881953, 0.38933209595011387, 0.32862188955479443, 0.06255003513539692, 0.11553762453865002, 0.0855184511589554, 0.06685639966175838, 0.09745517462968678, 0.006890940774029186, 0.17120803092060688, 0.046651790302523644, 0.03751837494329735, 0.15427730061500822, 0.14933115086948623, 0.1129328668063867, 0.18357438710494145, 0.09762324797140187, 0.10356993482754806, 0.4852016308400505, 0.21715571380261112, 0.12549482688411118, 0.10718211661775989, 0.11949016894076725, 0.17974401656929473, 0.1602167275334817, 0.09343912779961361, 0.07660185209537262, 0.16939715950896572, 0.1815689834576769, 0.06063737173907302, 0.33593777266763014, 0.3003352996784181, 0.32407929393285306, 0.4336214581837321, 0.35157899058017883, 0.36507079768453765, 0.28033419702910223, 0.2986302983298825, 0.23126372668584017, 0.7352572077716765, 0.7298843745642873, 0.6553630651950466, 0.7659721961971174, 0.7343652935762677, 0.7396629995225503, 0.7535574462626291, 0.6409448162341724, 0.6241848903351781, 0.08929343775676135, 0.10806259218960201, 0.0947700246968054, 0.09398695404413104, 0.1031722010988424, 0.11055269101573217, 0.10675108091642072, 0.09831119935903132, 0.13234998385749763, 0.12503932786486527, 0.20108099667276447, 0.152701493684552, 0.220505628233731, 0.13588125452872446, 0.20452956625724517, 0.14800801837554078, 0.26814436371383954, 0.28226578994330087, 0.5567214431822456, 0.4397119394228729, 0.4742510988842986, 0.5513710064061679, 0.4385743568440166, 0.5050362375528648, 0.5157056788897079, 0.4824475703348209, 0.49642051251504504, 0.30693171408025777, 0.2551402540994101, 0.3202485116713035, 0.40705569786050977, 0.29637454819877007, 0.30350702618144654, 0.35406298742628883, 0.3476531275299213, 0.3475686828633533, 0.18458165846828134, 0.20461273066994035, 0.1883688488083558, 0.21277026571420987, 0.17834388358514064, 0.17642348923758278, 0.21409618963109334, 0.20571983795225823, 0.2046339577300369, 0.1896910890447271, 0.19134480645560248, 0.6650764506437201, 0.20526848964189348, 0.18146559001662788, 0.19387820929633537, 0.20593541883082866, 0.18415612481033317, 0.18555308237041535, 0.8127469130005094, 0.16130669695885047, 0.18153184161035307, 0.16349685797361457, 0.18654763449963052, 0.1616951172371318, 0.15931156784510436, 0.16704259007314126, 0.1383578926189566, 0.1649110177609775, 0.1990251140077849, 0.20632511023098643, 0.1646301611701667, 0.16424429756622771, 0.16756572243709056, 0.23360917574913187, 0.20971697311004578, 0.15473367838603103, 0.18383128988562047, 0.1772258607896292, 0.22419803145902029, 0.18414518594645812, 0.20346778486154904, 0.18758056888028363, 0.1949161711110744, 0.19256980171170712, 0.2023629236536688, 0.08423486454129614, 0.09124164799249279, 0.09008295633986363, 0.07922169418615865, 0.0704393070128112, 0.07896764756663, 0.09045660004607103, 0.08134954110664461, 0.08173132144506634]}, "mutation_prompt": null}
{"id": "3d6e5e85-3a87-4ab5-a012-8f3a48a352a4", "solution": "import numpy as np\n\nclass CompactDynamicDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adjusted mutation factor for better control\n        self.crossover_rate = 0.85  # adjusted crossover rate for effective recombination\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Dynamic leadership: Use the best individual found so far for mutation\n                best_idx = np.argmin(self.fitness)\n                F = self.mutation_factor * np.random.uniform(0.6, 1.0)  # adaptive mutation\n                mutant_vector = self.population[best_idx] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n            # Stochastic local search with reduced probability\n            if np.random.rand() < 0.08:  # 8% chance for local search\n                local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                local_fitness = func(local_vector)\n                evaluations += 1\n                if local_fitness < trial_fitness:\n                    self.population[i] = local_vector\n                    self.fitness[i] = local_fitness\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactDynamicDifferentialEvolution", "description": "A robust compact Differential Evolution variant incorporating dynamic leadership and adaptive mutation schemes for enhanced global exploration and local exploitation.", "configspace": "", "generation": 71, "fitness": 0.3987974695429046, "feedback": "The algorithm CompactDynamicDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.33.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.954333463219959, 0.9634333375349635, 0.9607691062963063, 0.9645339756829786, 0.9603277212584752, 0.9546801375793516, 0.968221000279669, 0.9646970853752351, 0.9627150940382656, 0.0829329074287265, 0.9318932168023256, 0.9318026043450892, 0.9311273875806308, 0.9459336005218191, 0.920942688852252, 0.9261240539298201, 0.9168674472114583, 0.9304477285996617, 0.09276232170360166, 0.13642681582382699, 0.11143741042900224, 0.11956850993795398, 0.11228650634548609, 0.18779666001861262, 0.09356251428345363, 0.07262232456232431, 0.05745308223895884, 0.09143591768616643, 0.11380296630828868, 0.12642219212036876, 0.1478750421801588, 0.03965874102090805, 0.08390281490135876, 0.16255045905409915, 0.11874625015139006, 0.09700323488549734, 0.9893626003831048, 0.9878308142503265, 0.9915070603197607, 0.9914585009674218, 0.985619870905844, 0.9937056191622178, 0.987959478938748, 0.9956114647659573, 0.9954488551742645, 0.895698723395198, 0.8920033459626979, 0.9109771189901191, 0.9049371695159378, 0.8863652163732821, 0.8996276333207858, 0.8919761517781033, 0.8820003037593498, 0.8532395932176043, 0.23087227527422327, 0.19033269263867136, 0.1844014600192344, 0.1984437273045061, 0.2109300037577042, 0.1947158835324676, 0.16869761388728932, 0.22490466350867977, 0.2395454437704675, 0.1335373120261174, 0.13783582484698675, 0.8953204786158803, 0.8142966684938503, 0.9223932836755729, 0.1170072372019536, 0.8498078600042633, 0.8225548181469702, 0.8504642304536116, 0.853118864138531, 0.09900547793049319, 0.9305408793236393, 0.8942897659012233, 0.1383261840501414, 0.8097912704002415, 0.8348721682037823, 9.999999999998899e-05, 0.8646408770476877, 9.999999999998899e-05, 0.10331061794611773, 0.33594972116211097, 9.999999999998899e-05, 0.04055474328323527, 0.021249625004037043, 0.23054022563944288, 0.08950143668990773, 0.2163409748832098, 0.3478898360007411, 0.15048865661745914, 0.3953788106335794, 0.17135025886157096, 0.1996221354542429, 0.38804337660491095, 0.06502650056477577, 0.12748343002701057, 0.41427246227558534, 0.14211057943095606, 0.46762708376422923, 0.3280831531881161, 0.7272435832882668, 0.4087675734632027, 0.566866448745263, 0.20204230560282277, 0.11174002327600596, 0.36832311662751915, 0.3653342326499722, 0.5603082496347833, 0.4680668430163549, 0.3970857895382486, 0.7227461490177125, 0.5246624150103004, 0.05078554501175314, 0.28313241872458383, 0.378121068050595, 0.7760639019884232, 0.8116558715505614, 0.8015280943296293, 0.7399935226520296, 0.6353794378005533, 0.7905830808131158, 0.8045057217684061, 0.8091073814106738, 0.7755873044366849, 0.06462080798737357, 0.06245073030744264, 0.11800036521221191, 0.08030324543712064, 0.0957342548938992, 0.13491674115800067, 0.1363981524364768, 0.12767045768048302, 0.13459969827560725, 0.1636364866518063, 0.1986481701366326, 0.2325574653348914, 0.20471068468737064, 0.46030023805566334, 0.18023744512804096, 0.24733775784839684, 0.1474828671468229, 0.16241588665718154, 0.3102993312685276, 0.22064259214060933, 0.5496541663348942, 0.2400797556082993, 0.2957121375796553, 0.4372559461922112, 0.18755336885946505, 0.4072217207469565, 0.33605987665009474, 0.36628041082900786, 0.2260226699677621, 0.24232901311736688, 0.4096248978022019, 0.1667648848433686, 0.3094835274499068, 0.22182751163764247, 0.24861478770318624, 0.242364143430011, 0.23029493287597969, 0.1626341865069456, 0.22154970007290453, 0.22095082455371917, 0.240621476900149, 0.21734641777439545, 0.25871960894490664, 0.22748838185354303, 0.2291357417084725, 0.19859761305577528, 0.22812741747401233, 0.21411813431392634, 0.19493125325790217, 0.18489571664115434, 0.17342307720782613, 0.19227672743220858, 0.19471894096172304, 0.20484266701136122, 0.16525240378277883, 0.16618412585014541, 0.15502353179897022, 0.9679778977847415, 0.20214479495426108, 0.2017765221803981, 0.10002640635463345, 0.17009255963319703, 0.11494433174178975, 0.08145235712133148, 0.21380961530382392, 0.07346424621236913, 0.963196266320468, 0.16952244802302507, 0.21325462260970673, 0.2143711296234304, 0.9629010046741152, 0.9553110194732947, 0.18604334012813128, 0.19668200481413234, 0.18442500370689896, 0.17577490486993097, 0.1870922272136627, 0.18307865974349458, 0.18671262246924825, 0.20462819684605504, 0.2032991651822288, 0.10221302471879623, 0.10326003429066366, 0.09223629128519639, 0.15535243378672325, 0.10897411760432207, 0.08508994109190338, 0.15385869128836582, 0.10518545817901681, 0.07333049290060512]}, "mutation_prompt": null}
{"id": "98c40e8f-28c7-4f82-bbaf-edc802fd061e", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "bf28427b-2eb4-4de9-a0aa-9ba9c43578ee", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "7c42420f-cfcd-4271-b7ed-cd5eddec7c91", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "ac813ca6-9fc4-4a32-a751-fa32d4cbfee7", "solution": "import numpy as np\n\nclass EnhancedChaoticDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # Slightly reduced mutation factor for better balance\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                F = self.mutation_factor * np.random.uniform(0.7, 1.1)  # Chaotic mutation factor\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                if np.random.rand() < 0.12:  # 12% chance for chaotic local search\n                    local_vector = trial_vector + np.random.normal(0, 0.12, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedChaoticDifferentialEvolution", "description": "A compact Differential Evolution with enhanced mutation strategy and chaotic local search for robust exploration and exploitation.", "configspace": "", "generation": 75, "fitness": 0.41280551572147667, "feedback": "The algorithm EnhancedChaoticDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.28.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8178848911074474, 0.8425257122571641, 0.842669949592438, 0.8468342955868062, 0.8536099560993982, 0.8707824071773055, 0.8409082063395955, 0.8582850170662495, 0.8290517131268738, 0.747562111434355, 0.7473789657141174, 0.7739626992441468, 0.7410423766967896, 0.7770181617963934, 0.7257541239620173, 0.7769933376407732, 0.7581577686212184, 0.751373225722806, 0.09232413106047554, 0.08206315491695493, 0.09404236844688818, 0.10101754912316552, 0.0991656086141669, 0.09298750559623137, 0.09892379752368763, 0.09068348143380989, 0.08834132604718614, 0.1054976432756144, 0.09057303198909106, 0.0880679051315616, 0.09114833120936239, 0.09329653264207338, 0.10240985880037001, 0.08996462747027723, 0.12260541485704346, 0.10036621652911093, 0.9934205923293896, 0.9366725048543777, 0.948134729323102, 0.9867105510684532, 0.9533720032208455, 0.9355997166966472, 0.9881117379746894, 0.9796350721421938, 0.9581114798618201, 0.6006930111514406, 0.5858682834688783, 0.5199612999611887, 0.591563742652204, 0.5468405823838716, 0.6240666991537426, 0.6154830925817174, 0.5919189862462254, 0.575611612604334, 0.7751925306656511, 0.769634583496836, 0.7702560601991487, 0.8060634711007924, 0.7918041233914044, 0.8226003426720423, 0.7935590362987647, 0.7396186307208423, 0.8031066437072079, 0.5885708226807178, 0.5469127305804895, 0.5124283269570529, 0.5355074932224376, 0.5010529381369582, 0.583182742127071, 0.5599647427260357, 0.6538790063809963, 0.4898999942275204, 0.5325094204137072, 0.41047590184209604, 0.5724668725626914, 0.49791506710187405, 0.5116494626232423, 0.5040736261485552, 0.5307613309758359, 0.45159491066686464, 0.5415277400910881, 0.641264757967418, 0.49458435597823125, 0.4776601157055146, 0.44915841810152246, 0.5300724258770046, 0.3052170866595072, 0.5860185912880332, 0.5156863118286357, 0.5016532860279624, 0.656907180593139, 0.5767273892885932, 0.4420993119940082, 0.6292238167288835, 0.6072109541167833, 0.4399854544799503, 0.6467840374209138, 0.6668374867065086, 0.618433714713486, 0.1404479425929237, 0.194109210892221, 0.08793589748296216, 0.382997566780494, 0.1802628301771403, 0.40393480986720764, 0.22528630578604203, 0.23123817138330072, 0.1235368616661805, 0.44880568863622894, 0.420204405671447, 0.4518766568413596, 0.4276375092524035, 0.4574031994431328, 0.4774502645468377, 0.4201145780768031, 0.46424487424178995, 0.47287367964187577, 0.7848891883942379, 0.7584372419597618, 0.7945500868330967, 0.7633521673090033, 0.788341726497681, 0.7832203559172628, 0.7430195309327599, 0.7486788655594057, 0.7440233792605635, 0.08599243711734039, 0.09675880988885421, 0.09117739437207661, 0.08053405590109886, 0.09166809619379546, 0.07300365843064682, 0.07978588345222748, 0.0972555343726994, 0.08470030450709531, 0.21558323064582696, 0.13787677278681953, 0.24451893021749616, 0.139488444739427, 0.2061201982384021, 0.1537429084056403, 0.1491310443953896, 0.1987161178342709, 0.22830139268947336, 0.42849029157786955, 0.45934974211559065, 0.4256939869575924, 0.379931882733217, 0.411876758113468, 0.43065998400393646, 0.4472790803651796, 0.45548829454966455, 0.477583930939272, 0.29161320846486405, 0.3287230729159214, 0.28949942550797414, 0.2518706816520049, 0.25858811469349197, 0.3052156656161049, 0.4184488382439243, 0.3762491591202862, 0.3213612240074798, 0.17917212552897688, 0.18872410389222238, 0.19507384645367332, 0.17242227993069137, 0.22992385994021902, 0.20164129151138, 0.18743234955425836, 0.18651903457546137, 0.1846160430526047, 0.1826128731254073, 0.17202960089804054, 0.17325787019422567, 0.1761961185263008, 0.1799168234495766, 0.17425985409763, 0.1783454116977231, 0.17483765552368769, 0.1947894227069512, 0.7188305882934819, 0.8667528046991542, 0.16704429117764574, 0.18048503350204048, 0.19163773375127346, 0.18171302443126292, 0.0992769193984454, 0.13967678504689995, 0.1631127446732047, 0.802554449083642, 0.16773460795285722, 0.16813272599686335, 0.2060270792048421, 0.20726099033207612, 0.15742557762814635, 0.21208981095925694, 0.15245996679184104, 0.1270935443819673, 0.18010984725533674, 0.1957893446674912, 0.19627400821491248, 0.17618945344512027, 0.18509798209700146, 0.1687972379892113, 0.18997212976387856, 0.1797085089724917, 0.20196830714151037, 0.07411319066460897, 0.07803035520268697, 0.07015553928552254, 0.07720276365658041, 0.07595618245734626, 0.06944204720705804, 0.07278810510565659, 0.08637541034229346, 0.0770078402736637]}, "mutation_prompt": null}
{"id": "e970d956-b285-4044-a391-938a8e350e4b", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "6d24a46d-5bab-4321-ba19-b9e20cbda35a", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "7b3a2aea-b9f0-466e-8faf-49c41ba1cb1c", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "fce79742-8b08-4752-b949-c0fca021672f", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "37774ead-4afb-4334-b94c-8bb1eb73910a", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # slightly increased population size for diversity (0.15 change)\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # altered mutation factor for exploration-exploitation balance (0.15 change)\n        self.crossover_rate = 0.85  # modified crossover rate for effective recombination\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 1.2)  # altered range for adaptive scaling (0.15 change)\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.12:  # increased chance for local search (0.15 change)\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)  # reduced variance for fine-tuning (0.15 change)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A compact Differential Evolution variant enriched with stochastic local search and dynamic evaluation strategies for robust and efficient convergence.", "configspace": "", "generation": 80, "fitness": 0.4081145525418932, "feedback": "The algorithm CompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.872793590600445, 0.8462433123470215, 0.8613497005175885, 0.8596834843247775, 0.8620713478118058, 0.8623940392975421, 0.8513536470929226, 0.8626932106287117, 0.8625453082308231, 0.767037225557102, 0.7534144382087706, 0.7552598493423344, 0.786124305445558, 0.7838572279953315, 0.778919941152593, 0.7549438265885251, 0.7588711864970493, 0.7718940661002003, 0.11128816728491497, 0.10341379399504624, 0.114142937225991, 0.11101779880616958, 0.09907596439771371, 0.10807236292119182, 0.10019106632330621, 0.0991237633073262, 0.1385623145407464, 0.09739886857939561, 0.0949670049394985, 0.10020791281838426, 0.1393329717330436, 0.09207755342375146, 0.11572239807305829, 0.09438855938457769, 0.0960388013939657, 0.10909806397240995, 0.9335390399422252, 0.9435786111991925, 0.9522033228545209, 0.9309178356427333, 0.964731918683168, 0.962414186494073, 0.9326256597244696, 0.9790714979840662, 0.9716237843744306, 0.6153325913455161, 0.6174366262532751, 0.6089367167524915, 0.6290168774054726, 0.6298497519014408, 0.6144741230196467, 0.6029038983887397, 0.629509311368833, 0.5506208694322197, 0.8122964359190669, 0.2230819993921599, 0.8241829404641312, 0.8015289517596452, 0.8272627636254792, 0.8155242916898902, 0.7977589546781565, 0.7194302997603126, 0.848565983733551, 0.5823191178309712, 0.280959388674199, 0.39410937632456366, 0.5894215294180085, 0.41454580907974337, 0.3338029002219657, 0.4492932830528089, 0.3901786212192049, 0.47322039083036693, 0.4483486880782128, 0.6214507973266359, 0.5242368789215296, 0.24808047158093327, 0.27853002412422034, 0.5221095361533001, 0.3570982548838162, 0.4446514275944452, 0.32934036045370263, 0.4748925433808431, 0.449143167065688, 0.3734585576644961, 0.4387720451603738, 0.3810284977152396, 0.415206829481896, 0.488873442461079, 0.271232571215976, 0.42328781259905257, 0.60493828177084, 0.3306177878465425, 0.49332044195101077, 0.3281549177082931, 0.5309908724625361, 0.5468034658955705, 0.6767713992566871, 0.4756445500388261, 0.5900627759279005, 0.13559521667044971, 0.056840076326734046, 0.09685423270479243, 0.17323341247752067, 0.21745824221069288, 0.13552350509482125, 0.2603774444817121, 0.13812961762458542, 0.15581892854401758, 0.44636928299430323, 0.397082924916602, 0.3718261974253928, 0.47333485501345296, 0.41396746401262297, 0.46249974838075647, 0.33974913882274416, 0.37773494942570474, 0.3956372907471487, 0.8061289518686716, 0.7784673361506244, 0.7820199397003521, 0.8012405939953426, 0.7625136376573483, 0.7764294299841796, 0.8091258460294971, 0.8078660130421982, 0.7711685815855889, 0.10033257839167731, 0.10499435915942845, 0.09509813375575016, 0.0957515996543098, 0.0895194703083747, 0.08320399342521834, 0.09897219860489936, 0.11128070071264096, 0.09022211279971049, 0.36545343188957613, 0.44498608510891857, 0.15075140433942835, 0.16962516077183132, 0.35944674130068943, 0.1529187322413187, 0.18168557582994838, 0.1586719013066964, 0.20988644013392366, 0.48688513737835015, 0.44854302011223524, 0.5231247312510845, 0.48689012212640825, 0.4796249925008853, 0.49815701754351005, 0.541692937754487, 0.5511034591363383, 0.5324656277616546, 0.32017879558478834, 0.37973882269224113, 0.3874743191607908, 0.334677761272162, 0.31938921686331745, 0.36022664521951897, 0.37789010389529043, 0.43947418085404355, 0.3508717857924616, 0.20842259166725863, 0.2674921205941213, 0.19001846526621968, 0.18955955206424813, 0.20328291175580282, 0.19822159649161808, 0.17811455038686141, 0.1932733797775834, 0.21388499939880834, 0.32893386824993653, 0.19274183373961706, 0.2177188029125663, 0.19451506348507686, 0.31111875415172985, 0.21295046398157613, 0.2173870172623693, 0.2116551729996503, 0.1838118918496301, 0.16326970976076405, 0.17469409561576577, 0.15042807420353144, 0.18123002298093127, 0.18798572146806736, 0.15923550684686782, 0.7815990201831956, 0.18368321920759068, 0.7400287534848724, 0.2017156909874579, 0.1662968982410351, 0.16424781916300468, 0.7688944470493131, 0.16715976942158217, 0.6950989833506673, 0.21047497225808687, 0.15530868014415078, 0.21186174249473366, 0.18160882557748592, 0.1842762437531611, 0.1965197418150375, 0.1835188161286806, 0.17559585616530438, 0.23657253762116182, 0.192880452889986, 0.17929830002429314, 0.19661159156536845, 0.08511312087042044, 0.08382363165502338, 0.08197936716956644, 0.08519795834003996, 0.08204300983312018, 0.07790305716840262, 0.08549737142877967, 0.08484520569651721, 0.0700538739085429]}, "mutation_prompt": null}
{"id": "b8ba9330-b866-4685-8633-442b7550b073", "solution": "import numpy as np\n\nclass RefinedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # slightly increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # reduced mutation factor for stability\n        self.crossover_rate = 0.8  # decreased crossover rate for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 1.0)  # adjusted adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search with increased probability\n                if np.random.rand() < 0.15:  # 15% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedDifferentialEvolution", "description": "A refined Differential Evolution algorithm with probabilistic adaptation and local search intensification for robust optimization.", "configspace": "", "generation": 81, "fitness": 0.35677227389803057, "feedback": "The algorithm RefinedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.27.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8687978654566366, 0.8572111608416209, 0.8684374396059515, 0.8639365716511737, 0.8648645753956359, 0.868742523725524, 0.8755858956254606, 0.8750485522471776, 0.8472535497162228, 0.773350488988653, 0.7767698750336629, 0.7937329844503709, 0.7619326357379774, 0.7771452046365809, 0.7869470309037538, 0.7802029769014919, 0.7847563918806596, 0.7482129001862101, 0.1204948924164908, 0.10791600031352866, 0.09247713961821591, 0.11598268128897249, 0.12022448096032656, 0.09297286581333286, 0.11278218169625742, 0.11108572058859367, 0.10209517817984903, 0.09404596144253896, 0.10916789649965974, 0.0928160341987112, 0.10294211823167154, 0.11434236110962426, 0.10500954445904553, 0.09627724553532913, 0.10632736122794062, 0.09829532747172942, 0.9628570069929687, 0.9796251362828451, 0.9585222826493504, 0.9246266621509663, 0.9729979031044537, 0.9046230897511254, 0.936168596812269, 0.9783618922503377, 0.9253968991947891, 0.6589173793838621, 0.6078894709055751, 0.5552343749785715, 0.5746638979953216, 0.5978501788172431, 0.5732734703908249, 0.5928567279632596, 0.6602298274616512, 0.6025924747131828, 0.7915793986658999, 0.754153869040674, 0.7372188973996314, 0.7740868439808325, 0.8183869092676982, 0.7394256173261401, 0.8114318468177046, 0.8481744904268741, 0.7428676665933045, 0.426931601875408, 0.22771152739191702, 0.24719460306930796, 0.37926879664885604, 0.3064062897563986, 0.33158780251555575, 0.1980811831898699, 0.1818374185700884, 0.19095713594577923, 0.208779145282442, 0.3222766092070911, 0.2024619568012771, 0.20281221451422116, 0.21673660600965228, 0.2896663455715388, 0.42426544356039453, 0.28013671086669933, 0.44584120543305206, 0.10896360128543825, 0.07143249429738885, 0.16834212548461747, 0.15138931018085733, 0.14273847856317767, 0.02923297527549895, 0.1623682326758491, 0.20446360625817406, 0.22518173042789302, 0.25242489815101643, 0.17075408916550627, 0.24239490405335673, 0.04927537819552252, 0.13588125017231012, 0.0948326017375497, 0.37842053977185575, 0.30682898626439314, 0.40667072711316565, 0.11368371999249571, 0.0744035843906129, 0.07821170997474403, 0.135468537962238, 0.18730203164155457, 0.18240917813906576, 0.13550645113497262, 0.14429506041916906, 0.09054740786232363, 0.36108239824526367, 0.3236959942223461, 0.24724646885847368, 0.4054728169248729, 0.36603058949435807, 0.398147105464118, 0.3858653330104219, 0.34823051450317166, 0.32511123471732806, 0.7684210333177514, 0.748846389356034, 0.6886972427843581, 0.7623010076883459, 0.7503513796699569, 0.7358989668108804, 0.7857718146236334, 0.7806238098707785, 0.7249523397237425, 0.10928562628345972, 0.09916893035710073, 0.10900571978515416, 0.09484947752951356, 0.0892187253560549, 0.08852320847185124, 0.10168479387955576, 0.10581797976961804, 0.10139967523822957, 0.1556068756616822, 0.15283029957525562, 0.14049332620973054, 0.1688848983754475, 0.15804203793215088, 0.1618570262623411, 0.15011751339064616, 0.26377546976711874, 0.14343060425555942, 0.4629795543834474, 0.4688191860995792, 0.4987865659661681, 0.5511079365095202, 0.4731852521028498, 0.4613070610697527, 0.535334747251966, 0.5648793333783467, 0.47248996434457, 0.3812760891924444, 0.2748192994726264, 0.3527209240682774, 0.33848509209205757, 0.2806812982660033, 0.3340183992851624, 0.3311867844389642, 0.34665284420379516, 0.3387608379380399, 0.2072446007279657, 0.19123168944573699, 0.20572675665775642, 0.18901407499094947, 0.17948282225919832, 0.17523187267957752, 0.20337708883068806, 0.20258957049605741, 0.26934218375134156, 0.19886893577726272, 0.5107995913250205, 0.17953488820816332, 0.2792323515016074, 0.21040208893544743, 0.3374880128737645, 0.19080142724501192, 0.191543194087065, 0.18760891064914587, 0.15146483773034125, 0.16876953243954762, 0.19565252712697434, 0.17776008117596176, 0.18655151885041188, 0.17946791686893016, 0.3955652262022372, 0.18096685840885773, 0.17485226625679118, 0.15897551474274674, 0.16659331907109776, 0.20757760494655253, 0.2545429485334487, 0.21126457857989667, 0.18308789679206505, 0.20673927271701975, 0.21070213738542343, 0.20971038263225017, 0.17576799196670767, 0.1867286088577348, 0.18435137486219544, 0.20945755416724665, 0.1915601554626274, 0.1827938235858062, 0.1808093712450326, 0.17344182794708418, 0.18702329176550347, 0.07520537924868531, 0.07203906854888642, 0.08220597242527894, 0.08039829840955504, 0.07433912833811407, 0.09291608602027668, 0.07831813689597134, 0.08334414884655728, 0.07554403287491718]}, "mutation_prompt": null}
{"id": "ca3ff866-e773-4286-a9af-ae8fbb83b9f2", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "d756d879-7144-42e0-8bc0-384497355863", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "626a5b50-a37b-4b28-b8af-fe7aaa353ab6", "solution": "import numpy as np\n\nclass EnhancedCompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # slightly increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # adjusted for balance between exploration and exploitation\n        self.crossover_rate = 0.85  # slightly decreased for strategy diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 1.2)  # widened range for adaptation\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.15:  # 15% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)  # smaller step size for fine-tuning\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedCompactAdaptiveDifferentialEvolution", "description": "A compact Differential Evolution variant incorporating adaptive parameter tuning, stochastic local search, and diversity maintenance for robust convergence.", "configspace": "", "generation": 84, "fitness": 0.38638257223480227, "feedback": "The algorithm EnhancedCompactAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.27.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8427996339583447, 0.8380487028673895, 0.834065955601233, 0.8601415149959206, 0.8715705873861405, 0.8712222971054393, 0.8558350549552933, 0.8610494305130252, 0.8553864960345472, 0.7770275770546143, 0.7681718765132741, 0.768055611103281, 0.7681475727497424, 0.7557211281638027, 0.7466670643483053, 0.7548016706658702, 0.7768443407086678, 0.7483582479535629, 0.09278112223335833, 0.09235912920193845, 0.1252017296308412, 0.1115290916920576, 0.0894731252069807, 0.12319983718358818, 0.1078174182819488, 0.09635042410142525, 0.09057161399018498, 0.10627127820425719, 0.10311062832556961, 0.0943425061444062, 0.09544740048236366, 0.09075757663281492, 0.08992940648214554, 0.10055179812347725, 0.11128214476707232, 0.10472944087726488, 0.9493414175269258, 0.9855125155585424, 0.9400967564431515, 0.9780422349184804, 0.941524266762657, 0.9899873626671954, 0.9252726782221358, 0.9533061728248481, 0.9643724611594502, 0.6282598039527676, 0.6086165795721152, 0.6037330650063591, 0.6286258235611217, 0.6288377163145022, 0.5806010420452961, 0.5819271748047813, 0.6316379307551181, 0.6027890545141525, 0.7893981253757802, 0.7231728368777461, 0.7905089529755654, 0.8171800790354803, 0.8001572815204213, 0.8271294170234978, 0.8671076814942229, 0.7216734255341192, 0.8081756442847957, 0.26868858094046744, 0.3494029855865425, 0.4098708585266616, 0.24985788495240635, 0.3046957733707605, 0.24488914589728095, 0.12903770757487631, 0.44961452035155935, 0.4772815909020055, 0.32256972056209365, 0.12263580475618585, 0.387246089192664, 0.26519328305510104, 0.3572061442320702, 0.41701982981489105, 0.2009259449668379, 0.37897012244173456, 0.3964090501449087, 0.49537498645387545, 0.25521187912168397, 0.3873517820078355, 0.12722704623677217, 0.38477689401993975, 0.30573647847738594, 0.3752120242864794, 0.32706149281912145, 0.2854133369598443, 0.45440650693320517, 0.2946468908000861, 0.37920366707598396, 0.5248247186970207, 0.2633381340261487, 0.32353671636500825, 0.5410025486556381, 0.5921591251151751, 0.3709659265292595, 0.2246890311779085, 0.10306579487806122, 0.11794214724446905, 0.41705863471910554, 0.2541178225941142, 0.2227633641997323, 0.14771731044052627, 0.25374105366849786, 0.24657873573101474, 0.4097595976470967, 0.3606301628837486, 0.32057105609788106, 0.4445992058344608, 0.4100386708885273, 0.4420035743189632, 0.3766764299064891, 0.38533228907786554, 0.3632067420176106, 0.7942355392744903, 0.7892807064280395, 0.7779141009443832, 0.7662557944590664, 0.6731558826889956, 0.7823662504667215, 0.7938303769158126, 0.7809515794832915, 0.7561465412941204, 0.08694031215642317, 0.08865927975232968, 0.0973219672526402, 0.09454926535089148, 0.08997293862183342, 0.10685977972455696, 0.09481337526864553, 0.10248307097458242, 0.08241316777756424, 0.18274867597067257, 0.14541755397068445, 0.14772120447051307, 0.35814011347297314, 0.213574596450691, 0.16818661808478008, 0.1504244161892908, 0.18534154229530775, 0.24004752591349943, 0.40967914368167335, 0.4294702828938969, 0.470887993176033, 0.5025336588696132, 0.47221769443073003, 0.37557931792965105, 0.4847036909389699, 0.5140174053807631, 0.48229010449838683, 0.3220618916956063, 0.33473206741908357, 0.3429140060048872, 0.37395865069990764, 0.34720147378275346, 0.2613701510604859, 0.41529693821198643, 0.3693431047404112, 0.37346622673630037, 0.19760636638262208, 0.2056467060761935, 0.1945255977205872, 0.19046902064331617, 0.18485407328320125, 0.1935654108883208, 0.21848008892759319, 0.18537920236840277, 0.20069344916561627, 0.18757079264946597, 0.18782882336802054, 0.18789292451248052, 0.20416674164094595, 0.18008365683739846, 0.18315057775418653, 0.1795265105774999, 0.1904854259176897, 0.1884758336421667, 0.1471799037641427, 0.5299162010239665, 0.8370326615903948, 0.18810949454558445, 0.18841807972025826, 0.18610010428905466, 0.11825611507865685, 0.18213307397980127, 0.6785724236014414, 0.15162065500402389, 0.20729139021371734, 0.16382703945387256, 0.7538956554169867, 0.16434140191480417, 0.12293186413271762, 0.20953603723411784, 0.15373755994755278, 0.2116659355371806, 0.18727809303020626, 0.19305661998312296, 0.1925035350241645, 0.19805933320327218, 0.18726255343709586, 0.17356104781956838, 0.1857881558400497, 0.1870436872663893, 0.18359480339855871, 0.08140724971868496, 0.08485778581683079, 0.08946112155385821, 0.07671335315329231, 0.07350312930272263, 0.07962527096407557, 0.07111565551479238, 0.08333900255237348, 0.07795767838335999]}, "mutation_prompt": null}
{"id": "cdd692bd-c8e2-4f2d-99c7-2ea51210c03f", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "0920bfdd-6180-4816-8924-c4d692f9524a", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "88efcf6c-dafc-4a1f-b3e4-23cb3cfebe86", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "c3caff9a-f538-4dab-8a1b-66d6e9322d5b", "solution": "import numpy as np\n\nclass HybridCompactDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.85  # slightly reduced mutation factor for stability\n        self.crossover_rate = 0.95  # increased crossover rate for improved exploration\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.3, 1.2)  # broadened adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Random walk for diversity\n                if np.random.rand() < 0.1:  # 10% chance for a small random walk\n                    walk_vector = trial_vector + np.random.uniform(-0.1, 0.1, self.dim)\n                    walk_vector = np.clip(walk_vector, self.bounds[0], self.bounds[1])\n                    walk_fitness = func(walk_vector)\n                    evaluations += 1\n                    if walk_fitness < trial_fitness:\n                        self.population[i] = walk_vector\n                        self.fitness[i] = walk_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridCompactDifferentialEvolution", "description": "A hybrid compact Differential Evolution integrating adaptive search strategies, elitism, and random walks for robust convergence.", "configspace": "", "generation": 88, "fitness": 0.39796407186214044, "feedback": "The algorithm HybridCompactDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8857631315865263, 0.8849176599120441, 0.8812235235426324, 0.8912183520282464, 0.897655760334006, 0.9041903637268834, 0.8760080362980152, 0.8796819010274995, 0.8969243493390434, 0.8190391039988404, 0.8057911868553965, 0.7847379480333507, 0.8299143624752794, 0.8028767040403401, 0.8324480892374101, 0.839547306535519, 0.8168802240692681, 0.8594525472287192, 0.10630626175732927, 0.133001362288504, 0.12235632261465346, 0.1415335891126719, 0.13380988703212482, 0.1525689022255936, 0.12368947092560467, 0.2810977551621521, 0.10451203955378974, 0.10383473677263788, 0.10380587715768574, 0.14399788161121563, 0.14183461502684003, 0.10262953508920358, 0.13331082751657197, 0.11775709630607067, 0.12787638600066709, 0.12386058096019004, 0.9290749202190043, 0.9438962065295498, 0.9256719195525119, 0.9142223036641643, 0.9579309085165596, 0.9147781487789074, 0.9534419248550563, 0.9194380615475011, 0.8959872916058678, 0.72858465228578, 0.6198526043248035, 0.574357673448394, 0.6977412770684628, 0.6522181837230929, 0.631598553274793, 0.7002900926591296, 0.5522448806852127, 0.6971037578347123, 0.22543619472823384, 0.8858084854222646, 0.8724434259584999, 0.9263676463976664, 0.908872243691745, 0.34125745616601355, 0.889658609941977, 0.9063529309502167, 0.9165906818884555, 0.25985842331106057, 0.2539848739763503, 0.1279959215056271, 0.3451687033544104, 0.5199086006743942, 0.21744543827290774, 0.21819358927986454, 0.21861194209426138, 0.2362226263795878, 0.241573233044858, 0.2122194918144834, 0.1821309578626472, 0.3316862108374794, 0.47972200165299905, 0.24054132160797348, 0.1572540066804231, 0.21188456783576926, 0.1335336048765572, 0.09984268525077622, 0.08650599838045814, 0.08532537052313582, 0.13212056043880116, 0.14802206436969878, 0.14717808051198322, 0.12793416850053196, 0.22793150242872395, 0.39921051914700234, 0.2241789997708603, 0.28318362016124177, 0.18624154365226875, 0.1432464481593928, 0.5246932781869712, 0.1226833549755818, 0.8175897934563164, 0.27047277355489574, 0.17782216753808067, 0.1968627946013306, 0.3308560992126325, 0.39097730190888935, 0.24862098903361618, 0.3173575440541535, 0.2487054469138642, 0.1434325671013328, 0.23195326152978268, 0.08480547177821696, 0.35428983499327193, 0.37778397863070756, 0.45173359409023583, 0.3066508168807981, 0.355627081710322, 0.43681060905865576, 0.2202501537484911, 0.3610404488793397, 0.3560132020989629, 0.6465616348167125, 0.6120136555990574, 0.6818926663324684, 0.700569176452404, 0.5871216230966991, 0.6062424664840204, 0.6227040668208903, 0.6429970285304752, 0.6656922813901776, 0.09154027097481754, 0.11334376744668828, 0.13605438703236172, 0.14021768081587838, 0.12342909255111023, 0.1144055116484265, 0.12849118612996957, 0.09978288325364104, 0.10074344153857384, 0.20624057887591019, 0.6383270660381495, 0.15766206854143872, 0.7526094699090145, 0.4969657228616008, 0.20016244140995465, 0.2001953790096649, 0.1894307794292669, 0.22183927997256325, 0.7163337649027802, 0.6232238158592395, 0.6688663634484409, 0.6975687492514024, 0.5642786384510359, 0.47341313639382987, 0.6981968995116217, 0.5666172683321954, 0.5367797803137815, 0.3175248837645388, 0.27158305770764024, 0.485072199385703, 0.36642198971050266, 0.3404734399703693, 0.3919044057774286, 0.4730440164916747, 0.515334511353964, 0.6093202765039001, 0.1954717987527027, 0.1862823224786132, 0.2056515070994518, 0.21733214056631445, 0.2092647696301908, 0.20724019265087312, 0.2295025390771811, 0.1922298346569482, 0.19402575539214606, 0.22750703669779382, 0.19531526601672045, 0.63781756900122, 0.21841937969324032, 0.20693101387901214, 0.23088799812901972, 0.23306426713406436, 0.2192880593660833, 0.7409069685596547, 0.18739406662163716, 0.8026417119546914, 0.18839395926977387, 0.1709787398158047, 0.19967360588755678, 0.9243863581767089, 0.17112141310857787, 0.13564309614748415, 0.1717639867987284, 0.8606689296295553, 0.21112625686071096, 0.16816369496509453, 0.16541868379051705, 0.868564397910514, 0.0823700518043905, 0.21279490797296952, 0.15509618492567334, 0.8006966581205786, 0.18559178567977808, 0.1879083095415568, 0.2040749340603979, 0.19343473458137983, 0.18336577569728907, 0.1728914498165639, 0.17823512325202917, 0.19777533607252162, 0.1823632795468958, 0.087365867763317, 0.08312925492762757, 0.07962832396550457, 0.0924275343693558, 0.10579339434594259, 0.0850439021736833, 0.07751518986050177, 0.09082105521085304, 0.08248199132887879]}, "mutation_prompt": null}
{"id": "b59acf5c-3cc8-4974-963b-11c804800b87", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "d2382d07-dd92-4afd-931b-5625d09edbb1", "solution": "import numpy as np\n\nclass ProbabilisticAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # slightly decreased mutation factor for balance\n        self.crossover_rate = 0.85  # slightly decreased crossover rate for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with dynamic mutation factor\n                F = self.mutation_factor * np.random.uniform(0.6, 1.0)  # dynamic scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with probabilistic strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Probabilistic local search\n                if np.random.rand() < 0.15:  # 15% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)  # smaller step size\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ProbabilisticAdaptiveDifferentialEvolution", "description": "A novel adaptive compact Differential Evolution with probabilistic local search and dynamic parameter adjustments for enhanced exploration and exploitation.", "configspace": "", "generation": 90, "fitness": 0.398310992001469, "feedback": "The algorithm ProbabilisticAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8793906027111108, 0.8571144359223775, 0.8814123362998907, 0.866826168471447, 0.8802608120289979, 0.8944695052694158, 0.8857943724006738, 0.8768154244897518, 0.8804660012694083, 0.7961916528283828, 0.775221775894947, 0.8034689529525763, 0.812185648427961, 0.8234536694765323, 0.7800415199607549, 0.8094142923311488, 0.8013738337748978, 0.7989088946172871, 0.10917048466284873, 0.10429916998876998, 0.10097794053705988, 0.14274761309586848, 0.1426327864517869, 0.1503452161193396, 0.10283843615940036, 0.12241887730743162, 0.13076640735464773, 0.09710347382432138, 0.10834958648318038, 0.08306305662358704, 0.09349713420605654, 0.09288226916218989, 0.09352159789134673, 0.0980439206501762, 0.09353312420676207, 0.09394810430300715, 0.9490267697425355, 0.9728727046429769, 0.960053803757754, 0.9659103408799424, 0.9488987834025783, 0.9243798285207863, 0.9738456579467026, 0.9258705022488578, 0.9564616992467563, 0.6632750666378637, 0.6516167447166704, 0.6592644036266007, 0.652078806603626, 0.6488693312363505, 0.7000090624837788, 0.6707462254231341, 0.6637856268823688, 0.6464587163744101, 0.8166171783985011, 0.7423260864901435, 0.814204423821669, 0.8728210330215008, 0.8237829231360096, 0.8001291879350659, 0.8601440612582973, 0.8611315794827606, 0.7811935644303967, 0.2686413143999081, 0.30594021040270236, 0.31330169733248103, 0.27819716638703396, 0.6156218002885699, 0.36993432325136233, 0.39095852395880215, 0.19547645686817372, 0.6021142889413025, 0.21003207439373484, 0.19694699601914467, 0.21094529176474475, 0.36445959941695716, 0.544170950339455, 0.3598236940096943, 0.2359932889702694, 0.5934686962395597, 0.4775226477539052, 0.07910178352485076, 0.08051833550116427, 0.21401569990253344, 0.15179333192141953, 0.2503735027932995, 0.11732976748303448, 0.4145756014782873, 0.2812652276286801, 0.17708371338968387, 0.26956646241981974, 0.5997975513665266, 0.2150228923437819, 0.22097926426133663, 0.12177143223309106, 0.11428282404020917, 0.6476063820083351, 0.48013631845330196, 0.6401690148444483, 0.09283845903167909, 0.16694294061357318, 0.10455959788872549, 0.1908074485121336, 0.2626373653598475, 0.4530048147642871, 0.13682747060958012, 0.14851636658150347, 0.15989635471116048, 0.3247978827333302, 0.406360130872357, 0.38066317045386544, 0.39417542090122226, 0.5143832804684375, 0.4774390971062312, 0.5009585996336601, 0.4302043561432757, 0.3013583274789611, 0.8106900543980126, 0.8117934579474555, 0.8165190209387281, 0.8051721568993628, 0.8008029672839632, 0.8077536500365075, 0.8094909550282358, 0.8279006437647933, 0.7885706938430098, 0.0907548953009284, 0.11132710188122819, 0.09495394134679302, 0.09179162789905582, 0.09959286948180723, 0.10896823799873268, 0.08855374033215391, 0.09056054284616699, 0.08716866477076635, 0.2318861765664798, 0.13742940897814626, 0.15741316749636203, 0.16055735406380012, 0.1333165007578344, 0.20830106058696862, 0.1669383312385334, 0.19403380056533204, 0.22475808823193844, 0.5681235809998633, 0.5395248454397141, 0.5398044157722194, 0.5605742729629322, 0.569325622016245, 0.5722365716863016, 0.5467676757478429, 0.5722451980066205, 0.5963347566707735, 0.3779789469573993, 0.3516235557238844, 0.3319790459295301, 0.35427209687405825, 0.21720144097692984, 0.35088008154802786, 0.46744798356232675, 0.38827723504017053, 0.4259629577065247, 0.18434309587198272, 0.18856178380513333, 0.18515909458437585, 0.20323678738454132, 0.20774378354295586, 0.17889351751445082, 0.2108613982144374, 0.2048933571652779, 0.18323390217102276, 0.19751380916796468, 0.18534166182464507, 0.18517443953856216, 0.32585779037741813, 0.18042074073714942, 0.19993298394767411, 0.20348420847273452, 0.1893638560560289, 0.42458729874704737, 0.17138260546551498, 0.8686762155754972, 0.17114095102333926, 0.15199440560139987, 0.7629323514087254, 0.19050081975658384, 0.6970765030549387, 0.18581396462443422, 0.7792561952259776, 0.1644936756203007, 0.2101738255480402, 0.16647866723950688, 0.21694096574366184, 0.21850850521223442, 0.20540043664939422, 0.21067928416940074, 0.20632403069195693, 0.15478769943634196, 0.19182346680717988, 0.17277852940539196, 0.1962992838473323, 0.17602118986059034, 0.1726983632755933, 0.18941035451429422, 0.17612495911420523, 0.18131329434047305, 0.18875450381655579, 0.07253921119060347, 0.07826116402486805, 0.07952956237670028, 0.08765986672503767, 0.07175466848244183, 0.07158487771881106, 0.07820995280615861, 0.08616180392860984, 0.0814927941085265]}, "mutation_prompt": null}
{"id": "bfe119d4-1e3e-48bb-87ed-6a8e37574032", "solution": "import numpy as np\n\nclass EnhancedHybridDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 5 * dim  # increased population size for diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # slightly reduced mutation factor for stability\n        self.crossover_rate = 0.85  # slightly reduced crossover rate for exploration\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 1.2)  # adaptive scaling with wider range\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([\n                    mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] \n                    for j in range(self.dim)\n                ])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Hybrid search: Local/global stochastic search\n                if np.random.rand() < 0.15:  # 15% chance for additional search\n                    search_type = 'local' if np.random.rand() < 0.5 else 'global'\n                    if search_type == 'local':\n                        # Local search\n                        local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)\n                        local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    else:\n                        # Global perturbation\n                        global_vector = np.random.uniform(self.bounds[0], self.bounds[1], self.dim)\n                        local_vector = 0.5 * trial_vector + 0.5 * global_vector\n                        local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridDifferentialEvolution", "description": "Enhanced Differential Evolution with adaptive parameter tuning and hybrid global-local search strategies for efficient convergence in black-box optimization.", "configspace": "", "generation": 91, "fitness": 0.4122858186320029, "feedback": "The algorithm EnhancedHybridDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8840900703213446, 0.8578131992167579, 0.8674957369706314, 0.8681761225859936, 0.8637901514979739, 0.8514292753595619, 0.8718653743229046, 0.86835438578781, 0.8685446786855822, 0.7576688581503234, 0.7523818687723927, 0.7513846046763588, 0.7279719347609135, 0.7810489830265157, 0.7649232812129967, 0.7726528627106117, 0.7594303804002733, 0.7527803478894491, 0.10778806742124358, 0.0993827676321305, 0.12385410235058458, 0.10924210482379493, 0.08815481947216808, 0.11453644601054724, 0.11598347197965142, 0.1007492781456173, 0.3118158709180533, 0.09369165584434191, 0.10966620709188935, 0.10629987390047624, 0.10516033279883141, 0.09290123253568094, 0.12364292799181853, 0.09877284147378773, 0.11565491016388751, 0.12484300761665057, 0.9329234357850806, 0.9861181511669779, 0.9478791900565099, 0.978271709663105, 0.9686065717812355, 0.9512814511556772, 0.979255154256951, 0.9609152955570585, 0.9126299270904108, 0.6170471516903444, 0.6106013586854169, 0.5980497696254867, 0.6160437545589776, 0.5765768263296821, 0.6546431433546817, 0.6900281751005983, 0.6749689280619622, 0.5910561344616344, 0.8313643389693901, 0.7794516865638415, 0.8349702154906612, 0.8095714823780242, 0.8333700352333071, 0.8320506587059048, 0.8286575257596508, 0.7929845015131126, 0.83213092328897, 0.28761590896321787, 0.498664409417092, 0.1841293917595379, 0.2848024542210814, 0.284847053443709, 0.2173223596238535, 0.3930356178731109, 0.456876214332429, 0.31571857519612323, 0.2899772020474318, 0.3768703764413984, 0.4943785776043822, 0.5007547103742802, 0.5687336755419843, 0.43301472024643095, 0.48305258167408494, 0.47028747272776605, 0.4582497551011985, 0.3471719214667477, 0.43465303328428795, 0.3585302351167501, 0.5446461706517449, 0.45926016247349166, 0.4884498784525583, 0.42580047861128634, 0.4429670673542577, 0.5048900403256338, 0.5249104655897168, 0.6067946826091319, 0.5495028018103372, 0.489148914256455, 0.4045403636286906, 0.5977443648875188, 0.6397482434069387, 0.5942539572721028, 0.5680503737291421, 0.15672265160173882, 0.12157208791907848, 0.23505142282213265, 0.3634614245120448, 0.3314301020976722, 0.3558416284061303, 0.21308436287258425, 0.16180995933085685, 0.20309954446405087, 0.4905644088222678, 0.39273674874686637, 0.4380431875187176, 0.439782156043254, 0.4431270156825171, 0.45892113720868144, 0.3659682134933889, 0.3649044643815952, 0.39863870486553343, 0.7941186149960325, 0.7720934990764492, 0.7877385294677612, 0.7779454187763171, 0.7620107624207267, 0.7727085062526915, 0.7952593971782154, 0.7918673333134099, 0.7620479497185174, 0.10431086028324155, 0.11238703582163179, 0.1007721856738637, 0.12856377373505423, 0.10404813372977317, 0.09126419270683761, 0.08526183286513, 0.10911062352851308, 0.08813361691100474, 0.1481104776072767, 0.12127558069065181, 0.14587454535556066, 0.15498217121151792, 0.12926428600456807, 0.13952842800391796, 0.16672459447413368, 0.17880335620330812, 0.1405470225669183, 0.4677775179737832, 0.4640370760468, 0.4997567152774689, 0.5103284097548166, 0.4482605127898148, 0.493346987346588, 0.5275661540301836, 0.4877403165716776, 0.5098546855237568, 0.4144937585533963, 0.4068693415945466, 0.32368822887199444, 0.36837031991334557, 0.39632903091353533, 0.304576569195006, 0.45065045689508654, 0.37724050294361533, 0.44773718551870934, 0.19197231768641942, 0.1920620472469693, 0.2003064206269911, 0.2090662690892836, 0.19674332478887668, 0.21494141525025978, 0.194051741919693, 0.18565076085959165, 0.19299752082917077, 0.2002477466987691, 0.20830644204667137, 0.22284273666832255, 0.19732470484253084, 0.2071128150917867, 0.22167604543717778, 0.19578589408753588, 0.18519569573183436, 0.24203457970203257, 0.6838473490754151, 0.19429218613896693, 0.16111978174449137, 0.1898313406572717, 0.8225532222633452, 0.18629446097408087, 0.643801653618963, 0.17951933425387345, 0.18490267373824687, 0.7773490461871879, 0.2081034013729729, 0.16463150529830894, 0.19900521217314637, 0.16598300186736814, 0.16577995862682726, 0.2109462857688662, 0.2052060567092654, 0.20758205772891636, 0.18948837535915286, 0.1910918736022298, 0.18978443186270844, 0.18125089174796993, 0.19329734585416358, 0.19968622240636114, 0.1834044690942942, 0.1798998898122791, 0.17650247897160987, 0.07144128359919755, 0.07238930327214022, 0.07853080381686395, 0.07911534144888077, 0.07726417160938603, 0.07628449471930454, 0.09234394451676231, 0.07270491451464045, 0.07727012010687362]}, "mutation_prompt": null}
{"id": "8e677b8b-5203-45f0-85be-54084f3565b5", "solution": "import numpy as np\n\nclass DynamicCompactDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # dynamic mutation factor for exploration\n        self.crossover_rate = 0.8  # dynamic crossover rate for effective recombination\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.success_history = []\n\n    def __call__(self, func):\n        evaluations = 0\n\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                F = self.mutation_factor * (1 + 0.2 * np.random.uniform(-0.5, 0.5))  # more adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n                    self.success_history.append((i, trial_fitness))\n\n                if np.random.rand() < 0.15:\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            if self.success_history:\n                last_success = self.success_history[-1]\n                if evaluations % (self.budget // 10) == 0:\n                    self.mutation_factor = 0.8 * (1 + 0.1 * np.random.uniform(-1, 1))\n                    self.crossover_rate = 0.8 + 0.1 * np.random.uniform(-0.5, 0.5)\n\n        return self.population[np.argmin(self.fitness)], self.fitness[np.argmin(self.fitness)]", "name": "DynamicCompactDifferentialEvolution", "description": "A dynamically tuned compact Differential Evolution with feedback-driven adjustment of parameters and probabilistic local search for robust performance across various landscapes.", "configspace": "", "generation": 92, "fitness": 0.297392445418042, "feedback": "The algorithm DynamicCompactDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.7956786127010737, 0.7979252739132867, 0.7865741113161713, 0.8300073202890232, 0.8272296497620876, 0.8505544044061814, 0.8379567603020288, 0.8176267669894569, 0.8204507630525524, 0.7132805226323335, 0.7472134622364675, 0.709729484626301, 0.7062863127487613, 0.7190442753856168, 0.7300760803482824, 0.7048055229683428, 0.7192145848335829, 0.7518037612962353, 0.09486994412066285, 0.09946130001094955, 0.09056972843109556, 0.09801276289377459, 0.08777647679182321, 0.09754283418472043, 0.09299646199314593, 0.10033695865503955, 0.08787439978037526, 0.09979892382415745, 0.08202478277779413, 0.08978373067055834, 0.09744072489513145, 0.08567922682343343, 0.08910469121016362, 0.0875014910529881, 0.08333038531718051, 0.08210790365504017, 0.9679808861146245, 0.9618667454825798, 0.9690482499299602, 0.9858969682729944, 0.9807759485406768, 0.9696122281435682, 0.9863381737591717, 0.9823487587562386, 0.9869086324028666, 0.31402479018906737, 0.3898504804947248, 0.30930042919128486, 0.44739238955361016, 0.37037118022096416, 0.3185304426133533, 0.49574300511071734, 0.4666668062819719, 0.3767845760623887, 0.4686557560121021, 0.632062163648518, 0.5312287498618811, 0.26339423738967604, 0.52357295105603, 0.45249190020131647, 0.2962049480498875, 0.5663250817325938, 0.5115909544863266, 0.3499639076671176, 0.3419618111095598, 0.28476668427877994, 0.3312298852265836, 0.33804317429964803, 0.3869701229619965, 0.3261794647047712, 0.43899407077060015, 0.33055465449310417, 0.20771658207357846, 0.291285695600372, 0.16701451832004222, 0.37385094474285285, 0.31448916070438726, 0.37282079545928115, 0.28001464137390497, 0.1963957185586892, 0.3322009731430522, 0.07868408214277, 0.03324348887150319, 9.999999999998899e-05, 0.03267009602706816, 0.012400444485759388, 0.0034897384569925194, 0.0024804443067536486, 9.999999999998899e-05, 0.0011800441588527555, 0.12013509719585147, 0.09698653326236473, 0.0643014037932973, 0.05860459884065017, 0.06739153602575043, 0.09190856342344378, 0.10273733333040469, 0.08788656536485284, 0.09577043184945999, 0.06465784973176758, 0.010794146493557477, 0.02268246137445018, 0.06747966873669398, 0.006014555080487427, 0.12261244734550325, 0.018691091502181956, 0.020281758906437575, 0.0925108290974227, 0.19858148646999818, 0.23525637056229376, 0.21330673879215578, 0.25885964380574156, 0.275388012195666, 0.23052752171525248, 0.22958922805834414, 0.16322881828825664, 0.14561323104179102, 0.6370784619564227, 0.5591404361242723, 0.6765275679271544, 0.6447302933743957, 0.6322503816886724, 0.6290203575277896, 0.6287189473836579, 0.6361453179239518, 0.6394748313096689, 0.1184138658985383, 0.08361390070338204, 0.07960814312934472, 0.09460470151623468, 0.08158270967775039, 0.09873560898046785, 0.08734683102370278, 0.07232928851750109, 0.07462015901367336, 0.17937306639765938, 0.15953392061843774, 0.13613214257679174, 0.20516280828688105, 0.17272103941406602, 0.1920430210334957, 0.13076133826344538, 0.25096902303443835, 0.1500212235905376, 0.3425612718659361, 0.29272163186103095, 0.28536214575398644, 0.2964670499725365, 0.33829869274738633, 0.2059691882039496, 0.33914310976722417, 0.3964296029327299, 0.4080558749523858, 0.18000148401867588, 0.17963670607585958, 0.2089558077902297, 0.15453442057031264, 0.1337368106667971, 0.15641022015411976, 0.21412125283461558, 0.2006201874922433, 0.21431701380085588, 0.19699317841104536, 0.1905784687407066, 0.20527865354704955, 0.17426424084318037, 0.20885257256252165, 0.17157543298744604, 0.17452683214447318, 0.18891648599193545, 0.1902761393423883, 0.17330160320203813, 0.17049048154872815, 0.16856797172276605, 0.16844649272974055, 0.16676049520654412, 0.16634816203204195, 0.18099983638382833, 0.1824060784350191, 0.16914821442842365, 0.6078530727207638, 0.6896467512088753, 0.5029850929524189, 0.17441257682977462, 0.18331048554841067, 0.16471685132625735, 0.17294606522019362, 0.6758729573731691, 0.18438766477940505, 0.18875468198785728, 0.1662753938280681, 0.16458759286801072, 0.20247780353979294, 0.18054002690962212, 0.19107013995997246, 0.20469752264728847, 0.21074915248353088, 0.20764572072421705, 0.19887806834028265, 0.17476244266712326, 0.17660641491071927, 0.18071041089714668, 0.17853585689588125, 0.19134232199722467, 0.19672942970784557, 0.19153008151286977, 0.18668468339555744, 0.07036199844112323, 0.06840793257067868, 0.06546041504204692, 0.06934028050282959, 0.07019825289769721, 0.0644311019122823, 0.06930362983160032, 0.06722156834021409, 0.0703636722362233]}, "mutation_prompt": null}
{"id": "157b7879-446e-49f8-847b-b4537ee023a2", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "28a5de83-a9a9-40ae-8839-bedf957be69d", "solution": "import numpy as np\n\nclass RefinedCompactDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 3 * dim  # reduced population size for efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # slightly lower mutation factor\n        self.crossover_rate = 0.85  # adjusted crossover rate for diversity\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n        self.diversity_threshold = 0.1  # threshold for diversity control\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive factor and diversity maintenance\n                F = self.mutation_factor * np.random.uniform(0.4, 0.9)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with probabilistic strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Guided local search based on diversity\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    diversity = np.linalg.norm(self.population.std(axis=0))\n                    if diversity < self.diversity_threshold:\n                        local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                        local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                        local_fitness = func(local_vector)\n                        evaluations += 1\n                        if local_fitness < trial_fitness:\n                            self.population[i] = local_vector\n                            self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedCompactDifferentialEvolution", "description": "A refined compact Differential Evolution with probabilistic diversity maintenance and guided local search for balanced exploration and exploitation.", "configspace": "", "generation": 94, "fitness": 0.2990895573038112, "feedback": "The algorithm RefinedCompactDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.26.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8780385500328536, 0.5684365047506077, 0.7834603505925606, 0.6891729020213078, 0.8995764184609637, 0.5380018648735705, 0.9459402079267988, 0.9439353457931422, 0.9184554586086332, 9.999999999998899e-05, 0.8161447229535856, 0.7011353798173896, 0.1594813661239206, 0.10140691628337373, 0.894557059907647, 9.999999999998899e-05, 0.09618846878864495, 0.08463551435727623, 0.18507653495623733, 0.2879646122271786, 0.24823043218250196, 0.16218889792884872, 0.407369493957779, 0.14878711426682745, 0.14283324508357909, 0.15901255968529127, 0.13227534355150128, 0.15890586526606298, 0.08826592239859621, 0.13324797337740624, 0.12471163652217077, 0.13777049209981163, 0.11773475891873497, 0.12201297405678557, 0.164029404343093, 0.14030222525274716, 0.9696035926739387, 0.9166293791749005, 0.9309677077713561, 0.9517780431371089, 0.9218386788123836, 0.9837229379212846, 0.9456149893771963, 0.9344968706159027, 0.9481187850664154, 0.4122666253422591, 0.3957456669681252, 0.42316811204517457, 0.3503265895105303, 0.3250264092125974, 0.36345158906749453, 0.3759934974621053, 0.31395814082370366, 0.31717318637112035, 0.9507497527631451, 0.23006840461796163, 0.19571170012976802, 0.279131923374484, 0.3797135408469028, 0.2204529645754798, 0.3644735534588939, 0.08051965591002519, 0.23773763609333143, 0.1357771825569053, 0.15981454260516403, 0.16999149980796024, 0.16316668735750828, 0.13325145693359208, 0.16962848810955589, 0.24040971835641967, 0.1531253726184576, 0.1456616605547011, 0.15746668530066743, 0.04015630026457839, 0.14587722924138413, 0.2571415258595596, 0.12986512954220675, 0.20253756710241977, 0.19971120632907657, 0.20300591566193904, 0.4337738165592666, 9.999999999998899e-05, 0.06672093482797514, 0.11053512117664921, 0.10896371824460038, 0.06661273359213304, 9.999999999998899e-05, 0.03971908698677251, 0.11218798385573414, 9.999999999998899e-05, 0.16988498994737022, 0.25331634263767777, 0.07415969587589077, 0.11245900271468057, 0.04044811776019053, 0.034942732682973876, 0.1850258310738292, 0.23194917259650538, 0.14458091470785384, 0.15265945265639824, 0.040962307742004156, 0.12136798127332116, 0.1855181509067002, 0.2353254739183922, 0.1331579434883592, 9.999999999998899e-05, 0.19754623797489457, 0.22812667793112174, 0.14565192932796123, 0.16719455271327677, 0.2069397765617893, 0.2869601443097167, 0.3993323377937896, 0.06178455823740514, 0.13734088369343445, 0.11948327437448947, 0.14314667571203277, 0.49844907799508364, 0.5067985580089052, 0.4181676322671639, 0.5286161985565923, 0.6157659232770507, 0.4328659151440375, 0.5202227250749009, 0.6808193413415439, 0.5798591015619361, 0.15372495178236845, 0.1154201517663207, 0.11402540774265635, 0.15156629811019773, 0.13422530770987362, 0.09218775756888575, 0.14188743246018964, 0.10172306915719398, 0.11406222240518815, 0.21285613927130598, 0.1612740727779739, 0.13684360251545225, 0.282677492461305, 0.27425608431415427, 0.2538634694495612, 0.20891860211952484, 0.19319618011990036, 0.1717962002268969, 0.26897503240342346, 0.8169087309013388, 0.3540660310736309, 0.28332153496206725, 0.4133979844473107, 0.5053036122744884, 0.8066937267782575, 0.5951656069571103, 0.2473885559686928, 0.278436391580987, 0.48295880645524003, 0.18169407775628477, 0.273578826891154, 0.4076619867758088, 0.23278299718780227, 0.2428783222188935, 0.4979358753174008, 0.5395314615344109, 0.20398446438197282, 0.21085030343557198, 0.2065241796153986, 0.22707154002372532, 0.2013894324226515, 0.18507227370848445, 0.20072095940123713, 0.19866590871285694, 0.21905653783681656, 0.20912258084888657, 0.2272107930788455, 0.37793197749912755, 0.8122929745009717, 0.21999709547888602, 0.2275729589687212, 0.5486038948699694, 0.21202721846492967, 0.2218455222015585, 0.1708362291723048, 0.13569099074514301, 0.15455197983316338, 0.1722633079844874, 0.19814097854234436, 0.9162773180466672, 0.7545450033168114, 0.9328359749050237, 0.1667951235851347, 0.7914212103810296, 0.16850154903166126, 0.40441654720134956, 0.2100810482438088, 0.16881647466026461, 0.20140086584666694, 0.21007472966820373, 0.15555993907000099, 0.36072847491858306, 0.1780461107061173, 0.18507242794505385, 0.18449780017972517, 0.18342532172888915, 0.18172873142775448, 0.1918401392798612, 0.1810636040601019, 0.18078800147558538, 0.17561868638933065, 0.09044016841146274, 0.09605436538231993, 0.08639698978491994, 0.09021664995384526, 0.08825704919726163, 0.08407188653034114, 0.08795196122820204, 0.0955517343169382, 0.08200273980348594]}, "mutation_prompt": null}
{"id": "8c4b733e-e618-4ad2-bfeb-264f778b5d13", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolutionPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                adaptive_crossover_rate = self.crossover_rate + 0.1 * np.random.randn()\n                adaptive_crossover_rate = np.clip(adaptive_crossover_rate, 0, 1)\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < adaptive_crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                if np.random.rand() < 0.1:\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolutionPlus", "description": "CompactAdaptiveDifferentialEvolutionPlus uses evolutionary strategies augmented with a dynamic crossover mechanism and hybrid local-global exploration techniques for enhanced optimization performance.", "configspace": "", "generation": 95, "fitness": 0.4401612177465769, "feedback": "The algorithm CompactAdaptiveDifferentialEvolutionPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.44 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8683820371856668, 0.8747213629932723, 0.8762745162292572, 0.857958911883746, 0.881736013380173, 0.8809538165882294, 0.8882042633426136, 0.8882710259932549, 0.8318098811150904, 0.7893558985674921, 0.7995797432026068, 0.7742350106802088, 0.8212126171784444, 0.7940305900136759, 0.7910875799051458, 0.8180092887439451, 0.7997190659344183, 0.801787505534926, 0.10378126484635308, 0.10999678509398325, 0.1095106207659694, 0.13981133718974792, 0.12124002367574116, 0.10117199360042473, 0.10864154622016975, 0.11193560673543257, 0.11840885637461795, 0.0917293866128599, 0.10262152157957549, 0.09648457825682744, 0.10938336811639204, 0.10459286689845126, 0.09825363792813113, 0.09355082448786523, 0.0931094368952643, 0.10934051112054333, 0.9589962700741232, 0.94559652100159, 0.9273093854046638, 0.9383724123042017, 0.9644698665359756, 0.9395516328358531, 0.9560180536643915, 0.9857341313504145, 0.9446408300377908, 0.697741804209874, 0.6691247965094596, 0.6227380380194341, 0.6850551989056809, 0.7268035924465152, 0.6730162039273786, 0.6874891152099146, 0.7064049288995913, 0.6846961243852514, 0.8804522677856198, 0.8081518390933236, 0.8727815438199266, 0.8661272180028845, 0.21073627472626155, 0.864135728742928, 0.8540364287860595, 0.879062702248341, 0.8541070595016538, 0.5832053721850732, 0.3662165275605447, 0.6214172323502523, 0.4468035013575675, 0.12861805718635277, 0.5590687430759516, 0.6139723877679413, 0.35251543024790943, 0.6946557159658806, 0.5094844780605327, 0.1782637785542407, 0.4741695871522924, 0.49385942261977145, 0.45883532909222935, 0.457287890323241, 0.37624068924808685, 0.286982022877339, 0.250258889424249, 0.6292240564133647, 0.5163002825981442, 0.7001809775837295, 0.22133703144892813, 0.6609365933888283, 0.5644597412107399, 0.6585855689239895, 0.5696732144224539, 0.6568808728137602, 0.23253453682937175, 0.34235876403038945, 0.7379299105442725, 0.6615927388536733, 0.3813608526932115, 0.6685935909683638, 0.6034041019814345, 0.7305642945692151, 0.5515799797508276, 0.08572312772443635, 0.14645819101268154, 0.12254893072997053, 0.19998491098035687, 0.47225175341909886, 0.2806713874688844, 0.3477274587391952, 0.2542468241580196, 0.15310536892144921, 0.4523143641916074, 0.5662874161008478, 0.5380002014973869, 0.38871123138183217, 0.43304652926586173, 0.5984690672570752, 0.60468447328814, 0.6248328781204244, 0.5457522897035572, 0.781161355560949, 0.8102802163380416, 0.813613224344052, 0.8040087747707853, 0.8335848914739863, 0.8244336748780625, 0.8318611195570931, 0.8143735933467249, 0.8341790430643838, 0.09347975458552427, 0.09067354370295688, 0.09237447920021136, 0.10714340390614341, 0.09133361632178572, 0.08202567271187544, 0.10764239829928335, 0.09091452051801518, 0.10114166098844435, 0.15562679692715953, 0.14880175674858453, 0.16722311709076643, 0.12334794302143837, 0.1573206858147852, 0.14102704675524202, 0.1791082570389323, 0.15416139074428137, 0.417578144030215, 0.5807654829270086, 0.558015955886828, 0.5849110374772181, 0.5825906188698122, 0.4987771075848346, 0.5040466409571012, 0.5515411239609902, 0.6019979857044297, 0.581606321025558, 0.4173094156447954, 0.4222273358215525, 0.4006898098609185, 0.49288305073061467, 0.37738407225082105, 0.4534646439680634, 0.4522373392324651, 0.5041416321132957, 0.477161801896392, 0.17927694129215688, 0.22053321508591994, 0.20965714125506119, 0.17311851607431894, 0.19242585428668368, 0.20107692506321495, 0.18627153808974517, 0.18416032339765742, 0.19727950496093127, 0.1954308280095558, 0.6827266055985455, 0.22025361256837805, 0.324920501696928, 0.21858109963042593, 0.3243555436252421, 0.19246224731465633, 0.17416070437550046, 0.4823058600181255, 0.8624451728598843, 0.8548414980827467, 0.15339791457368535, 0.17370881875151734, 0.17742714757567568, 0.19497296875410508, 0.15838933173856984, 0.1820096941400564, 0.16206121205457236, 0.787487824981179, 0.20976709245545233, 0.20822496007863167, 0.7605394585461189, 0.12894619429646514, 0.2004842440180934, 0.16343819835107498, 0.1552495545510072, 0.15378371220504283, 0.18943194909715388, 0.1931654135607358, 0.20319498568484107, 0.20716010089054493, 0.17684747647705756, 0.19697374378908517, 0.18280123072284082, 0.18957865080034064, 0.17581641583081586, 0.08275935428665637, 0.07060590904826769, 0.08791693437344472, 0.0789597524233786, 0.07443572341571036, 0.07758630771039066, 0.07466284814704793, 0.08312760705899458, 0.07504338059936344]}, "mutation_prompt": null}
{"id": "6f81e1e5-5b3f-487e-b917-55a95d6807bc", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = max(2 * dim, 20)  # Min population size to ensure diversity\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # Slightly reduced to balance exploration and exploitation\n        self.crossover_rate = 0.9\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with enhanced adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.6, 1.2)  # Broader range for adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with modified strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Enhanced stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)  # Reduced step size\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedAdaptiveDifferentialEvolution", "description": "An improved adaptive Differential Evolution algorithm with enhanced stochastic local search and dynamic parameter tuning for robust performance across diverse tasks.", "configspace": "", "generation": 96, "fitness": 0.44868540173191096, "feedback": "The algorithm ImprovedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.29.", "error": "", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8880834213925436, 0.8858825421852776, 0.8672375634705574, 0.8879809832025628, 0.8772444167247556, 0.8928418841640069, 0.8738444464357368, 0.8849496722659862, 0.8594460081398256, 0.7810959731237217, 0.7712970132066308, 0.7615121578203564, 0.7868668650482109, 0.7786400840884738, 0.7834413167990537, 0.7716612539526072, 0.7898701662954478, 0.7723158053861008, 0.10545632087323609, 0.10846944836529038, 0.10545187414314117, 0.09995907761559342, 0.11043815118049094, 0.09713407296642596, 0.10650920604396852, 0.10402538347580426, 0.11337364282001583, 0.08980152998853941, 0.09334107807726799, 0.10119158033565467, 0.1115338823001728, 0.08864275490972073, 0.09341488928328978, 0.10582487819479025, 0.10887137669265845, 0.08254339882047534, 0.9692380412572541, 0.9444447956080531, 0.931864464762383, 0.9791735084416157, 0.9699712797681382, 0.9880498621946114, 0.9651937219466166, 0.9261208777532199, 0.9236369410943158, 0.6075812141759211, 0.6761927862879396, 0.6400553852923965, 0.642010428292656, 0.6118988779507286, 0.698603635758894, 0.6240578039452138, 0.675526343791959, 0.6441693488467993, 0.8425055471522327, 0.8114182239825877, 0.869171782856925, 0.8215290850880005, 0.8607919230357524, 0.8964926714852334, 0.8368718080994653, 0.8337210661068195, 0.8472407382772869, 0.3429168645098585, 0.33339217938725785, 0.4969940537994536, 0.12919619482074962, 0.5352428938849851, 0.6451145004113712, 0.47703775193985043, 0.63265602651759, 0.5558289558940347, 0.49218710324813897, 0.32854017737489294, 0.5424467405153008, 0.48583943555560005, 0.583593112410365, 0.5352185441562025, 0.5799781597952572, 0.12416993319399228, 0.6804042789009973, 0.6845275781449145, 0.5793256834189393, 0.28780839631538424, 0.540496673068957, 0.6065483051229112, 0.6522327629717259, 0.6454718569647131, 0.5958902427912578, 0.685889733063546, 0.3970732679088441, 0.704618042756905, 0.6506789279690184, 0.6886255673161941, 0.5916087983712103, 0.6469814194352825, 0.743702752422273, 0.7422400035569315, 0.7164865255612989, 0.1941446541143902, 0.0964379688015381, 0.3383682945535146, 0.21990192856614255, 0.40626793382291093, 0.1333324264062652, 0.1308656702309594, 0.2064839447099588, 0.14047417627803838, 0.5182484234660274, 0.5395039284350915, 0.4606612609752998, 0.4605301753587473, 0.6057668973758144, 0.5257065984374012, 0.4714489475876138, 0.5390489249721246, 0.5390343945647752, 0.8188969131688772, 0.8239213201218932, 0.805783552704987, 0.7817439586756769, 0.7967805544794032, 0.8076132938704115, 0.8188344537700869, 0.8144530618077782, 0.8007808336564486, 0.09566962639170029, 0.1281428724417638, 0.10261215870981488, 0.15779255579590168, 0.10460930710932026, 0.09152549008854272, 0.10229188977110992, 0.10499579473580356, 0.10034984985678308, 0.14715044486945494, 0.26303525950984186, 0.16876226321226329, 0.6296686984611859, 0.4464403242067245, 0.2221631404468053, 0.1506709710277917, 0.14932934551821142, 0.1257079653957791, 0.49467732012117016, 0.5782766237582713, 0.49105080601876394, 0.43533638679388775, 0.47162469649798, 0.5424652063423943, 0.5555396091125205, 0.5591864645632464, 0.6006271041464656, 0.3896224676144797, 0.4000683828532906, 0.3789302888581929, 0.4102429151982284, 0.4129227133765284, 0.39423465744414166, 0.40495962276103226, 0.3923369476694998, 0.3752497300833436, 0.1912615072290721, 0.20041774186707206, 0.18475352463996497, 0.21390296246812868, 0.176487681136428, 0.1823051883577883, 0.21102734760434472, 0.1954772778565882, 0.20206301986226072, 0.19266848751281596, 0.19385325963406808, 0.2836899033522896, 0.18032405249091732, 0.1878760049703827, 0.3038149359563733, 0.422790333172791, 0.1857594095488575, 0.18384820542044267, 0.164524343193295, 0.8115841513332445, 0.15318408468645794, 0.8612575218069434, 0.18437514433740265, 0.17882884824863865, 0.0996102135829533, 0.7084707064458222, 0.7950797719161454, 0.1720042677983471, 0.16524513042509026, 0.20686742447299655, 0.16602775288795368, 0.14865991851692084, 0.7393423326735703, 0.2083083845706737, 0.8605187581451006, 0.15569967303928534, 0.19284028606720327, 0.18042841756242323, 0.18110642271819632, 0.19397135219105233, 0.17881950014165537, 0.17389248877786845, 0.19550786139497411, 0.24895153610308685, 0.17860385798861222, 0.07706974797472377, 0.07424978021838236, 0.07390022396532625, 0.07603106252102532, 0.0705886599415082, 0.08090614268234209, 0.09607777360711078, 0.07786841462377703, 0.08132985626004552]}, "mutation_prompt": null}
{"id": "10935751-fd75-409c-bcb9-04a2348afd4f", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "623eedb9-3d99-4d21-a29d-bf890f280936", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.pop_size = 4 * dim  # reduced population size for budget efficiency\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.9  # adjusted mutation factor for exploration\n        self.crossover_rate = 0.9  # adjusted crossover rate for better mixing\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.5, 1.0)  # adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search\n                if np.random.rand() < 0.1:  # 10% chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.1, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "An enhanced compact Differential Evolution variant with stochastic local search and adaptive parameter control for improved convergence efficiency.", "configspace": "", "generation": 17, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {"aucs": [0.8833969478134082, 0.8798089980884505, 0.8957162061983521, 0.8807394251531864, 0.8917519818855308, 0.896671292548834, 0.8838027354074058, 0.8867295047435346, 0.9070848574283495, 0.809290287911511, 0.809764526241068, 0.8301021691534205, 0.8222202212813181, 0.799686648136019, 0.8065735655218839, 0.7936308154600495, 0.8009709274328305, 0.8013023402741768, 0.11720235153384051, 0.09984390788363673, 0.10788526107046581, 0.10628252049390519, 0.1655614589280211, 0.1203057421639755, 0.143993988078419, 0.11582645863121599, 0.10645763116400087, 0.09123553787401883, 0.10708373352405653, 0.10735046235489631, 0.09908201982775156, 0.12603441091846113, 0.11587095321660723, 0.12172954746094711, 0.10063967235021776, 0.11444568314535009, 0.9477272986002849, 0.9748592238515518, 0.9485071328816747, 0.9675721937659083, 0.952978319825947, 0.988044241353362, 0.9783281613846959, 0.9503398540461591, 0.9827724123959907, 0.7180811656040905, 0.6843974454765662, 0.6892131173381566, 0.7107142231693344, 0.6530013899171462, 0.7434619292855562, 0.6822273389107999, 0.6903165705455239, 0.7339628363271544, 0.8156924365605457, 0.8421413869717679, 0.3765523591008564, 0.8726676369822826, 0.8500709499682786, 0.8786476619510772, 0.887912633041345, 0.8857946194687601, 0.8760377327866545, 0.6565120521439506, 0.3020226950333015, 0.6212540718741587, 0.42067173716291895, 0.48205961828837673, 0.5408131541592013, 0.5900103290046891, 0.613717743106386, 0.5450107646985302, 0.4254142374977601, 0.17299338612168869, 0.45840746991749415, 0.43893651498182495, 0.2846943783941629, 0.5989273717509898, 0.3694337337094594, 0.6396808352897041, 0.13143399246206078, 0.6880197441487507, 0.2721031365704156, 0.47876271547521887, 0.5268013979169448, 0.23131994220801144, 0.5168160027538975, 0.6795662346713052, 0.6141226317647897, 0.4716485398813326, 0.4730790164441937, 0.7522469986218975, 0.7345529796982109, 0.6449091197899768, 0.4321239250004938, 0.3184023492781253, 0.7534962825111063, 0.7834198570471385, 0.7964562077795314, 0.18821250465889305, 0.14961631011983012, 0.08913793114953628, 0.3301466905054089, 0.5107317463766861, 0.5673864169967686, 0.11831422507577005, 0.20004180218082068, 0.18019218454415586, 0.5935670030731524, 0.5653292680525019, 0.5412910063421632, 0.5694750441116624, 0.591544150630586, 0.4763455993041935, 0.34971410044304607, 0.4440394802477876, 0.5707349537746298, 0.8578459323425813, 0.842771824545532, 0.8220061937096864, 0.8512881417162673, 0.8451969490914372, 0.707115298132194, 0.8143201764465353, 0.8415501449270951, 0.8232434533186268, 0.10640864842582975, 0.11560025603460766, 0.1273411568994285, 0.09317232464486647, 0.08763976355653125, 0.10142121307530982, 0.10129577830623582, 0.10115877142683494, 0.08975163304692291, 0.15195128359248777, 0.16276599030692618, 0.14301606729637895, 0.1424976348545841, 0.20556035459739996, 0.21060680497213835, 0.24958545642350194, 0.12382886230793977, 0.7779069637165246, 0.5760360377243027, 0.6186541829108403, 0.5808600621491407, 0.6228182875568632, 0.6198378713623536, 0.5500756497052561, 0.5377143062488394, 0.6260329667966027, 0.4866076219436193, 0.4817127461564342, 0.4081464765784949, 0.42479436124445935, 0.4267666316609977, 0.39450264687284675, 0.4054547066279297, 0.3812344471090129, 0.5232649205017612, 0.456076280051234, 0.19757244263150786, 0.20849523882209098, 0.18221958571047836, 0.20109425703841777, 0.1880675435666782, 0.1850897081346663, 0.18511636977661894, 0.21695032837338712, 0.18684545180308765, 0.5474573109051012, 0.17574798484565857, 0.24257717248046717, 0.5766937908060338, 0.21913416693471932, 0.31735053977752004, 0.3568723186455929, 0.3723615871470216, 0.20646177791672005, 0.18367688163139861, 0.8140095073063163, 0.18088118830651512, 0.9105523679777178, 0.18790663558209175, 0.1969936316278479, 0.1580903447292772, 0.16480190833188657, 0.190131439800853, 0.1621349043188668, 0.20722299305393, 0.08299893592516983, 0.2014198890110559, 0.1663220103374775, 0.8596803908330979, 0.16730032043995036, 0.2116788036613746, 0.15639384830677938, 0.19870403721712815, 0.19894419962024457, 0.17275336488048632, 0.17919157008102515, 0.18870545395217464, 0.17480387029611288, 0.18145024474078375, 0.1970999753373741, 0.20045216463754856, 0.08263092071439915, 0.07731645602929438, 0.07585117171423628, 0.07260057980520163, 0.08703469699587985, 0.08330487045676704, 0.08797276126826259, 0.08688894016325432, 0.08511399624539195]}, "mutation_prompt": null}
{"id": "a7a43725-7c49-4ea2-b9be-5cbd634c2a9d", "solution": "import numpy as np\n\nclass CompactAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.initial_pop_size = 4 * dim\n        self.pop_size = self.initial_pop_size\n        self.bounds = (-5.0, 5.0)\n        self.mutation_factor = 0.8  # slightly reduced mutation factor\n        self.crossover_rate = 0.85  # adjusted crossover rate\n        self.population = np.random.uniform(self.bounds[0], self.bounds[1], (self.pop_size, self.dim))\n        self.fitness = np.full(self.pop_size, np.inf)\n\n    def __call__(self, func):\n        evaluations = 0\n\n        # Initialize fitness values for the initial population\n        for i in range(self.pop_size):\n            if evaluations >= self.budget:\n                break\n            self.fitness[i] = func(self.population[i])\n            evaluations += 1\n\n        while evaluations < self.budget:\n            for i in range(self.pop_size):\n                if evaluations >= self.budget:\n                    break\n\n                # Select three random individuals from the population, different from i\n                indices = list(range(self.pop_size))\n                indices.remove(i)\n                a, b, c = np.random.choice(indices, 3, replace=False)\n\n                # Mutation with adaptive mutation factor\n                F = self.mutation_factor * np.random.uniform(0.4, 1.0)  # broader adaptive scaling\n                mutant_vector = self.population[a] + F * (self.population[b] - self.population[c])\n                mutant_vector = np.clip(mutant_vector, self.bounds[0], self.bounds[1])\n\n                # Crossover with adaptive strategy\n                random_index = np.random.randint(self.dim)\n                trial_vector = np.array([mutant_vector[j] if np.random.rand() < self.crossover_rate or j == random_index else self.population[i][j] for j in range(self.dim)])\n\n                # Evaluate trial vector\n                trial_fitness = func(trial_vector)\n                evaluations += 1\n\n                # Selection based on fitness evaluation\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial_vector\n                    self.fitness[i] = trial_fitness\n\n                # Stochastic local search with dynamic probability\n                if np.random.rand() < max(0.1, (1 - evaluations / self.budget)):  # dynamic chance for local search\n                    local_vector = trial_vector + np.random.normal(0, 0.05, self.dim)\n                    local_vector = np.clip(local_vector, self.bounds[0], self.bounds[1])\n                    local_fitness = func(local_vector)\n                    evaluations += 1\n                    if local_fitness < trial_fitness:\n                        self.population[i] = local_vector\n                        self.fitness[i] = local_fitness\n\n            if evaluations % (self.budget // 10) == 0:  # Dynamic population resizing\n                self.pop_size = max(2, self.initial_pop_size // ((evaluations // (self.budget // 10)) + 1))\n                self.population = self.population[:self.pop_size]\n                self.fitness = self.fitness[:self.pop_size]\n\n            # Update the best solution found\n            best_idx = np.argmin(self.fitness)\n\n        return self.population[best_idx], self.fitness[best_idx]", "name": "CompactAdaptiveDifferentialEvolution", "description": "A refined Compact Differential Evolution with adaptive selection pressure and dynamic population resizing for enhanced exploration and exploitation balance.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "f82c87b6-4c46-47c6-b2c2-97742713e0d8", "metadata": {}, "mutation_prompt": null}
