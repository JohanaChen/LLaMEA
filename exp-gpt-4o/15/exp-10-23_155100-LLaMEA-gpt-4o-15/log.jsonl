{"id": "372aa440-a37c-404f-98c2-92c37edba226", "solution": "import numpy as np\n\nclass HybridQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f = 0.8  # Differential weight\n        self.cr = 0.9  # Crossover probability\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        return sol + np.cos(theta) * (self.upper_bound - self.lower_bound) / 2\n\n    def mutate(self, target_idx):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + self.f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant):\n        crossover = np.random.rand(self.dim) < self.cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                target = self.population[i]\n                mutant = self.mutate(i)\n                trial = self.crossover(target, mutant)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n                \n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                \n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "HybridQuantumInspiredDifferentialEvolution", "description": "Hybrid Quantum-Inspired Differential Evolution combines quantum superposition principles with differential evolution to enhance exploration and exploitation in high-dimensional search spaces.", "configspace": "", "generation": 0, "fitness": 0.10295321547326644, "feedback": "The algorithm HybridQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.18.", "error": "", "parent_id": null, "metadata": {"aucs": [0.14745792092321808, 0.15093168057460282, 0.13099398004914653, 0.13930769484557437, 0.12888775174748657, 0.13683648807018434, 0.13317426717569159, 0.14228890701074393, 0.15096342812883834, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02571742840982949, 0.03893525259182096, 0.030620208297537865, 0.03455427358681973, 0.031106982699730557, 0.026943653393490585, 0.030908560494712356, 0.029334489149319465, 0.018270122301861536, 0.014521246629269235, 0.023964770206026498, 0.025351992629708886, 0.019865766693310305, 0.029757931781239644, 0.013237351952898657, 0.01469858885516273, 0.018306894261837625, 0.01719359082891403, 0.9434950496478627, 0.9439910990695533, 0.8987323869660632, 0.8630803504801716, 0.9192331518997364, 0.976988118147036, 0.9041932252805426, 0.9627943120307442, 0.9153621282847006, 0.06250897388688514, 0.07170859599965584, 0.04403065774435144, 0.05569439243212748, 0.023097236179937308, 0.05540846028492341, 0.052748007695731736, 0.04881960199395419, 0.068929865445298, 0.10021927427072241, 0.09584134111967724, 0.1419560116084816, 0.09082489478252431, 0.07693875266296435, 0.07295359102092203, 0.07238234309417257, 0.09554028574616769, 0.12982566986930066, 0.00028327582289111586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0008574661516042026, 9.999999999998899e-05, 0.0014861195436566277, 0.0008618030677789434, 9.999999999998899e-05, 0.024579275118543742, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005539427598561297, 0.0033268036246452137, 0.011458575415392636, 0.009345578306217961, 9.999999999998899e-05, 0.025632163196298796, 0.007101468438870717, 0.013682940757423268, 0.0028181408961898136, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0024351116681771146, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19291533752089118, 0.1847894876057098, 0.17168138891812867, 0.15353982771127017, 0.15380214778696677, 0.14631017085558284, 0.18680830757148037, 0.1875475072720526, 0.14888171251422422, 0.036593016404548706, 0.01990708580375755, 0.03639807187780075, 0.03446657444202572, 0.03091936750131985, 0.03107604565442834, 0.020695246972170622, 0.03824122633767291, 0.04953848946700823, 0.1329529554124954, 0.11547081964201023, 0.1220847837347332, 0.0985421675139474, 0.10847072164832139, 0.11167216284005121, 0.11079818510696293, 0.09967781062880421, 0.12819760125122193, 0.12405317828753437, 0.1467265494844645, 0.16120364257448616, 0.14798536393868822, 0.14739343511050262, 0.15285915443653197, 0.14521871098000771, 0.1736473656540689, 0.14683753665709032, 0.08223926429668282, 0.08646674478853034, 0.08390323631898067, 0.12642288025709636, 0.08551606927219368, 0.0991870102958119, 0.09155180906579685, 0.09965274136215663, 0.08835435158085725, 0.1515981708358911, 0.1399624601863554, 0.14519364166725246, 0.12781277997293183, 0.1399764388375352, 0.13177288233254003, 0.15998976031461554, 0.1365811690825065, 0.14258062501200075, 0.054537686280049846, 0.07434357352620113, 0.06955300156671329, 0.06834673061399521, 0.06058802330306756, 0.1384837392364061, 0.08369231806575228, 0.0031859737090100815, 0.09419621550773405, 0.09217813783625584, 0.10356093457022364, 0.10296772917482722, 0.10886670387508202, 0.12075367075600119, 0.11335669007126503, 0.13244779595363254, 0.11607672098612343, 0.14730056105189704, 0.12247602506439725, 0.12324582712739629, 0.10579840974414367, 0.08463775805171558, 0.10826855739921537, 0.09274191497105855, 0.08238810999464463, 0.0845882315676546, 0.08924827150986092, 0.15858877638083946, 0.1642790656312525, 0.16444749860828867, 0.15331080664004693, 0.1579400462856413, 0.1508106788693674, 0.1643236544672938, 0.16420134342224324, 0.1720676278243658, 0.03795884725356424, 0.047240192422273175, 0.046144313246742064, 0.0407126168353692, 0.03695432310329072, 0.0498281487821669, 0.04102685532785566, 0.03787559005523322, 0.049952502417256794]}, "mutation_prompt": null}
{"id": "1aea8aff-f323-4ef7-ad97-c32806b1eab1", "solution": "import numpy as np\n\nclass AdaptiveQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.7  # Min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        return sol + np.cos(theta) * (self.upper_bound - self.lower_bound) / 2\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n                \n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                \n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumDifferentialEvolution", "description": "Adaptive Quantum Differential Evolution enhances exploration-exploitation balance using adaptive mutation and crossover strategies inspired by quantum principles.", "configspace": "", "generation": 1, "fitness": 0.10578629144340873, "feedback": "The algorithm AdaptiveQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.18.", "error": "", "parent_id": "372aa440-a37c-404f-98c2-92c37edba226", "metadata": {"aucs": [0.16743491173747482, 0.14994649835730234, 0.14417048100911178, 0.10999486536377989, 0.11570221847882767, 0.1256833835007154, 0.14974883278492856, 0.1673828256048251, 0.15493308468393718, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.022490252733873284, 0.03426907786279676, 0.028776587072479876, 0.034298024264957316, 0.030904833473320514, 0.026177929240798425, 0.04486332910440127, 0.02212890088440722, 0.048337304377894186, 0.014202212251806068, 0.010531411195151108, 0.011891050886394083, 0.019584109309318087, 0.009093535642266892, 0.012859934068073509, 0.019270581930170172, 0.02636601795472393, 0.015801694776514497, 0.9437924101360992, 0.9271365260363352, 0.9551772009955011, 0.9371411524615652, 0.9430431013342604, 0.9765226656377585, 0.9170921678065472, 0.8955015524109435, 0.9949835699799955, 0.06250897388688514, 0.05995172547009331, 0.04672451529494703, 0.0393148841398846, 0.03878256147746073, 0.043603751591363094, 0.047107602162027584, 0.04715645016523795, 0.03448622148330438, 0.11588259278446877, 0.09821916081494342, 0.07615134610812946, 0.10633320193355844, 0.11383267472847514, 0.06143200163363438, 0.06978972470369049, 0.07499640064976298, 0.08251877357682624, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.039613792329128095, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018066865236083474, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007931999890325114, 9.999999999998899e-05, 0.07026006907214433, 9.999999999998899e-05, 0.03417307100894851, 9.999999999998899e-05, 0.0068752673421936805, 9.999999999998899e-05, 0.010246684451600596, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.14681759439853181, 0.16751870553762238, 0.17062296020576107, 0.1528877182052607, 0.1518759535430596, 0.1408681695984757, 0.16099184883267847, 0.17277783671430202, 0.15394082327688396, 0.030444842184901844, 0.024676306305993934, 0.022191742223096833, 0.032970048643868544, 0.029705664439492074, 0.026055583199442345, 0.04231424262552863, 0.03627722103545916, 0.02675766679738989, 0.13865870647572043, 0.09888200323991059, 0.13519655739734704, 0.1111981307874228, 0.10969628649653318, 0.1092050722559823, 0.11475099475404715, 0.11098035736111467, 0.16151141524288481, 0.13465283816778373, 0.13786996907877203, 0.16121614628359893, 0.1480540737381112, 0.18454766836662506, 0.14476044404741006, 0.13461441880038705, 0.17364192092597353, 0.14554727418188518, 0.08690876708343398, 0.07919949610747268, 0.08524437761617787, 0.07902884666811827, 0.08923612166635098, 0.08811758626523791, 0.11057254092678881, 0.0996617735839731, 0.10276704528633418, 0.1359253659955897, 0.13365910574846107, 0.13846507007741837, 0.19033178322236666, 0.13328669387397718, 0.14275856192255887, 0.12863146485384624, 0.1435085595971417, 0.1424532247597724, 0.08629228568709257, 0.07881654063909149, 0.11871361521672863, 0.08800721256058497, 0.1259717497109628, 0.1012138244725247, 0.12935226531311017, 0.1377178329372235, 0.14427744106039353, 0.10119147811916795, 0.11515015041996379, 0.16387082960956867, 0.14833400532373175, 0.12834634214167295, 0.10387235763320146, 0.1257127092716681, 0.11466677990930652, 0.12800658651644792, 0.16227818206607791, 0.10674223347199807, 0.08891771477516108, 0.09693043710826588, 0.13761196964696842, 0.14442313463008627, 0.09103827972833156, 0.09156769826924249, 0.11997608891645506, 0.17297422206174995, 0.16176246404135441, 0.17894826077905823, 0.16312505280527656, 0.15477370102852128, 0.14846531679381425, 0.15104619227640237, 0.17119819387360935, 0.1569912892461438, 0.03707106753511147, 0.04317219415179352, 0.0407484062467256, 0.029449583605898666, 0.038048826392332535, 0.03521730455344163, 0.04366539818900661, 0.03787707857225342, 0.0330745165601084]}, "mutation_prompt": null}
{"id": "345eb3bd-4be3-423e-9dbb-9b5615252d47", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 9 * dim  # Slightly reduced population size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted differential weight range\n        self.f_max = 0.8\n        self.cr_min = 0.6  # Adjusted crossover probability range\n        self.cr_max = 0.9\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        return sol + np.sin(theta) * (self.upper_bound - self.lower_bound) / 2  # Modified to use sine\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        mask = np.random.rand(self.dim) < cr\n        if not np.any(mask):\n            mask[np.random.randint(0, self.dim)] = True\n        return np.where(mask, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n                \n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n                \n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                \n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages adaptive mutation, crossover, and quantum superposition to dynamically enhance solution search space exploration.", "configspace": "", "generation": 2, "fitness": 0.1031913073726651, "feedback": "The algorithm QuantumInspiredAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.10 with standard deviation 0.18.", "error": "", "parent_id": "1aea8aff-f323-4ef7-ad97-c32806b1eab1", "metadata": {"aucs": [0.14723872103805702, 0.13550054115134713, 0.16470456295926106, 0.15177090298859253, 0.13041587101987973, 0.1386397183675041, 0.11642006913300684, 0.12648838771473947, 0.13677593345723393, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03396216081850145, 0.030251676983383935, 0.023124777449334943, 0.02897731755940025, 0.023097305734022133, 0.02233790080530873, 0.02841108931138603, 0.02974464150697731, 0.028337010652916828, 0.020545983295639392, 0.021948104145936287, 0.011276616438995024, 0.0455548591426328, 0.042761750549995314, 0.007724727506361662, 0.02924039617929175, 0.020783898099231535, 0.02260210748133995, 0.8411971678532613, 0.9193017910157517, 0.9679075739127605, 0.9502906554015095, 0.9089880153157112, 0.9729713618455716, 0.9274890945552573, 0.9705822403445227, 0.9378233354350926, 0.06878948516344063, 0.054492951929158484, 0.04434711911967515, 0.04675250107508944, 0.038672091029918754, 0.04168030888185603, 0.03509391167411924, 0.03556727158122408, 0.044551669801439875, 0.1003022148427084, 0.1206154977687054, 0.0796119983446062, 0.09521724991214509, 0.11186235120302734, 0.10530736750173542, 0.11840255226812801, 0.06587483283933904, 0.09194527384181672, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02828153025571023, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008158024690391508, 0.03573138397640374, 0.019917489217769035, 0.0003340089655337053, 0.010696412750483608, 0.00020041782428359411, 0.02628881032908048, 0.011094269953770941, 0.019225811442305174, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1661552913204245, 0.19213254096431054, 0.1758028992160613, 0.13897359406061627, 0.15230668424479354, 0.16102148478902578, 0.17960904325645044, 0.16702688888046158, 0.16823609883516144, 0.019945523026632883, 0.02099400807928975, 0.027455515258830387, 0.041859172654626464, 0.03953264395927514, 0.03745053147605071, 0.02920737139371954, 0.03718652242088005, 0.02675766679738989, 0.10081949248341249, 0.10055983817648828, 0.1228362638437056, 0.10820652249923135, 0.1265296145909699, 0.11146524683355075, 0.11006472080975183, 0.09400767418299305, 0.11479571469303718, 0.13688670601177821, 0.14885580428084466, 0.16120439481376125, 0.17288864466170617, 0.16403476831427255, 0.15632680101110086, 0.1520866296011667, 0.17363763999786896, 0.13559720678523335, 0.0881048821368009, 0.07340974360457642, 0.08892979712968774, 0.0841012466227683, 0.08723562880020852, 0.09161217342032435, 0.09076099049885966, 0.10568868363621708, 0.08196026725491223, 0.13037552845933353, 0.126029218438508, 0.13488243640862818, 0.1396112065283983, 0.13068014687311225, 0.12765025181268608, 0.12432224163013239, 0.13712171435421605, 0.13221722921108325, 0.11980106527445566, 0.050494544849385425, 0.0987853579853738, 0.08728469051875021, 0.09090060815101009, 0.12346216112150088, 0.13286305135821463, 0.09260635944423068, 0.01928956368353918, 0.10901035951970639, 0.10141694524882627, 0.1114358120307446, 0.13817396594603049, 0.1335145739965028, 0.10634878297730588, 0.1083493178146766, 0.11165541385012179, 0.10907508094941187, 0.14923218925960868, 0.14079084443289014, 0.07886066070069264, 0.10609231872622293, 0.10305168195456915, 0.09369849092501259, 0.0936909770635137, 0.09490186944132706, 0.08476730150566714, 0.17511414022799476, 0.15016615116504362, 0.15231894604799268, 0.15931461921807455, 0.15814797656074042, 0.1614226697352582, 0.15765424561776364, 0.17575922496170693, 0.16385691668662916, 0.031937684816086276, 0.03590960139022026, 0.0360018192116448, 0.038503936818527706, 0.04138630024216361, 0.032448210649453024, 0.031063774777509545, 0.03791052714326382, 0.03419803209739547]}, "mutation_prompt": null}
{"id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages dynamic parameter tuning and quantum superposition to enhance convergence on diverse optimization landscapes.", "configspace": "", "generation": 3, "fitness": 0.16808930370691633, "feedback": "The algorithm QuantumInspiredAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "1aea8aff-f323-4ef7-ad97-c32806b1eab1", "metadata": {"aucs": [0.37716528776936387, 0.3656969431580892, 0.35862226734399305, 0.3642391832626237, 0.39355243764791603, 0.3589330512483563, 0.37086633875181363, 0.3649971923542603, 0.37086866482257896, 0.014718821352867062, 0.0184785818758062, 0.011962931274558275, 0.020694880358807177, 0.007186835177391382, 0.014941605582498463, 0.006566641123293637, 0.0120337215621934, 0.030307155841448163, 0.08291854837121648, 0.0877868355271757, 0.07543241075773455, 0.08565280063431002, 0.0888884761211719, 0.09499014520945204, 0.08316937256283563, 0.08236350731690378, 0.0805993393975255, 0.0728969172388837, 0.06386896549244536, 0.07036330638254873, 0.07743875583476623, 0.06567218789072282, 0.06946934523835901, 0.07536809474251749, 0.0736436667253707, 0.06190950115160698, 0.8443212530650631, 0.81716523749164, 0.8083681459476945, 0.7980116647050872, 0.863110021920818, 0.8793308920336467, 0.8481285640859868, 0.9121310043822779, 0.8531184385572244, 0.1750661074403259, 0.1745035267021945, 0.15447497836192758, 0.1710743257498707, 0.17053067298386937, 0.17528471173855342, 0.1901997373695301, 0.17766133012952012, 0.1664124656990119, 0.21738945213994199, 0.23277709652399825, 0.2045794625255256, 0.23335466265300786, 0.2299007452260986, 0.23081889801453703, 0.21001809663212212, 0.23879591988900017, 0.21983208360670192, 0.1079087271799215, 0.10917774759456911, 0.10589350384784046, 0.12310881995860423, 0.11394446330628127, 0.099707593902288, 0.10606234375695389, 0.11903381322744322, 0.10558197445066964, 0.08314134359980685, 0.10732932159081188, 0.08975453716951864, 0.107657543817953, 0.11206559729542587, 0.10540797846933492, 0.10995513582216354, 0.09730722814212733, 0.09920070312135942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09228011137955294, 0.06428557647080724, 0.06357718140730462, 0.04171258194238814, 0.08645053653670187, 0.049351595203804055, 0.06830857652498123, 0.05869050494999828, 0.057176986088656845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06417458554176703, 0.06082554437825016, 0.045946318759585436, 0.04898242817973897, 0.05344142440921662, 0.06527660286173542, 0.05681814016023001, 0.058765153803503334, 0.06083007082175118, 0.34328304521555664, 0.3475209536739209, 0.35239157337844806, 0.3415847469659036, 0.32726022613291317, 0.35190748531066507, 0.3280524713333386, 0.3396852347226139, 0.34871852419079963, 0.09170151222355694, 0.07911630807449199, 0.07998115827367314, 0.08178348993513918, 0.08597583935427122, 0.0783227024095311, 0.07597332169507809, 0.06914243340540538, 0.06684905681622189, 0.15605084239496392, 0.11983047233785804, 0.12736526791702107, 0.14954423060848587, 0.1388322263070575, 0.12787695055460768, 0.14085306858779822, 0.13272137698046604, 0.11990890785360897, 0.23449892760889057, 0.23096663052950472, 0.22457731348649967, 0.22322911162661407, 0.21613044642033252, 0.21923734266022998, 0.23176491142680522, 0.23816359700026124, 0.23175962952791096, 0.16938785049318683, 0.17698571508953642, 0.15705685724805285, 0.15133829484393901, 0.1646831002230379, 0.16652283735060425, 0.16645135512352405, 0.17266981822622507, 0.18178974703518747, 0.17894906254300513, 0.165136322982809, 0.17767025036455475, 0.16740989923949368, 0.193657821512909, 0.17058008329007368, 0.17980007140007637, 0.16906851983184756, 0.17060180866457486, 0.1778069619766065, 0.1576611299075541, 0.17045509791318803, 0.1713534742915772, 0.19183926661036954, 0.16522960617423832, 0.1761998362308972, 0.16560469434597058, 0.15776253087146597, 0.20554380645176085, 0.21967455573101968, 0.14011720127177818, 0.19120786928668676, 0.1721002248767889, 0.2968887762153172, 0.15989020567510104, 0.15593866204690854, 0.14811021897457577, 0.1692049399224006, 0.17999982746108523, 0.1583296990916404, 0.17761686275298794, 0.16430122877579056, 0.16554386955949163, 0.2121327270047293, 0.2418228858016509, 0.19543677412011806, 0.20859660207124653, 0.17022771429919903, 0.18804754230228404, 0.18193130522670875, 0.17362639957134585, 0.179805204923689, 0.17445127208606304, 0.17325290306822094, 0.1820953606815442, 0.06033320669105957, 0.06571292545815499, 0.07001593125364602, 0.07485357529949399, 0.06673097072308942, 0.07040022597030182, 0.05768720392084814, 0.07070488340186343, 0.0671661796487597]}, "mutation_prompt": null}
{"id": "2bdb21bc-021f-470b-819b-242b9d5f41a6", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages dynamic parameter tuning and quantum superposition to enhance convergence on diverse optimization landscapes.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.37716528776936387, 0.3656969431580892, 0.35862226734399305, 0.3642391832626237, 0.39355243764791603, 0.3589330512483563, 0.37086633875181363, 0.3649971923542603, 0.37086866482257896, 0.014718821352867062, 0.0184785818758062, 0.011962931274558275, 0.020694880358807177, 0.007186835177391382, 0.014941605582498463, 0.006566641123293637, 0.0120337215621934, 0.030307155841448163, 0.08291854837121648, 0.0877868355271757, 0.07543241075773455, 0.08565280063431002, 0.0888884761211719, 0.09499014520945204, 0.08316937256283563, 0.08236350731690378, 0.0805993393975255, 0.0728969172388837, 0.06386896549244536, 0.07036330638254873, 0.07743875583476623, 0.06567218789072282, 0.06946934523835901, 0.07536809474251749, 0.0736436667253707, 0.06190950115160698, 0.8443212530650631, 0.81716523749164, 0.8083681459476945, 0.7980116647050872, 0.863110021920818, 0.8793308920336467, 0.8481285640859868, 0.9121310043822779, 0.8531184385572244, 0.1750661074403259, 0.1745035267021945, 0.15447497836192758, 0.1710743257498707, 0.17053067298386937, 0.17528471173855342, 0.1901997373695301, 0.17766133012952012, 0.1664124656990119, 0.21738945213994199, 0.23277709652399825, 0.2045794625255256, 0.23335466265300786, 0.2299007452260986, 0.23081889801453703, 0.21001809663212212, 0.23879591988900017, 0.21983208360670192, 0.1079087271799215, 0.10917774759456911, 0.10589350384784046, 0.12310881995860423, 0.11394446330628127, 0.099707593902288, 0.10606234375695389, 0.11903381322744322, 0.10558197445066964, 0.08314134359980685, 0.10732932159081188, 0.08975453716951864, 0.107657543817953, 0.11206559729542587, 0.10540797846933492, 0.10995513582216354, 0.09730722814212733, 0.09920070312135942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09228011137955294, 0.06428557647080724, 0.06357718140730462, 0.04171258194238814, 0.08645053653670187, 0.049351595203804055, 0.06830857652498123, 0.05869050494999828, 0.057176986088656845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06417458554176703, 0.06082554437825016, 0.045946318759585436, 0.04898242817973897, 0.05344142440921662, 0.06527660286173542, 0.05681814016023001, 0.058765153803503334, 0.06083007082175118, 0.34328304521555664, 0.3475209536739209, 0.35239157337844806, 0.3415847469659036, 0.32726022613291317, 0.35190748531066507, 0.3280524713333386, 0.3396852347226139, 0.34871852419079963, 0.09170151222355694, 0.07911630807449199, 0.07998115827367314, 0.08178348993513918, 0.08597583935427122, 0.0783227024095311, 0.07597332169507809, 0.06914243340540538, 0.06684905681622189, 0.15605084239496392, 0.11983047233785804, 0.12736526791702107, 0.14954423060848587, 0.1388322263070575, 0.12787695055460768, 0.14085306858779822, 0.13272137698046604, 0.11990890785360897, 0.23449892760889057, 0.23096663052950472, 0.22457731348649967, 0.22322911162661407, 0.21613044642033252, 0.21923734266022998, 0.23176491142680522, 0.23816359700026124, 0.23175962952791096, 0.16938785049318683, 0.17698571508953642, 0.15705685724805285, 0.15133829484393901, 0.1646831002230379, 0.16652283735060425, 0.16645135512352405, 0.17266981822622507, 0.18178974703518747, 0.17894906254300513, 0.165136322982809, 0.17767025036455475, 0.16740989923949368, 0.193657821512909, 0.17058008329007368, 0.17980007140007637, 0.16906851983184756, 0.17060180866457486, 0.1778069619766065, 0.1576611299075541, 0.17045509791318803, 0.1713534742915772, 0.19183926661036954, 0.16522960617423832, 0.1761998362308972, 0.16560469434597058, 0.15776253087146597, 0.20554380645176085, 0.21967455573101968, 0.14011720127177818, 0.19120786928668676, 0.1721002248767889, 0.2968887762153172, 0.15989020567510104, 0.15593866204690854, 0.14811021897457577, 0.1692049399224006, 0.17999982746108523, 0.1583296990916404, 0.17761686275298794, 0.16430122877579056, 0.16554386955949163, 0.2121327270047293, 0.2418228858016509, 0.19543677412011806, 0.20859660207124653, 0.17022771429919903, 0.18804754230228404, 0.18193130522670875, 0.17362639957134585, 0.179805204923689, 0.17445127208606304, 0.17325290306822094, 0.1820953606815442, 0.06033320669105957, 0.06571292545815499, 0.07001593125364602, 0.07485357529949399, 0.06673097072308942, 0.07040022597030182, 0.05768720392084814, 0.07070488340186343, 0.0671661796487597]}, "mutation_prompt": null}
{"id": "b899a1fb-1329-4e44-95f3-cb6ae1f75c2e", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages dynamic parameter tuning and quantum superposition to enhance convergence on diverse optimization landscapes.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.37716528776936387, 0.3656969431580892, 0.35862226734399305, 0.3642391832626237, 0.39355243764791603, 0.3589330512483563, 0.37086633875181363, 0.3649971923542603, 0.37086866482257896, 0.014718821352867062, 0.0184785818758062, 0.011962931274558275, 0.020694880358807177, 0.007186835177391382, 0.014941605582498463, 0.006566641123293637, 0.0120337215621934, 0.030307155841448163, 0.08291854837121648, 0.0877868355271757, 0.07543241075773455, 0.08565280063431002, 0.0888884761211719, 0.09499014520945204, 0.08316937256283563, 0.08236350731690378, 0.0805993393975255, 0.0728969172388837, 0.06386896549244536, 0.07036330638254873, 0.07743875583476623, 0.06567218789072282, 0.06946934523835901, 0.07536809474251749, 0.0736436667253707, 0.06190950115160698, 0.8443212530650631, 0.81716523749164, 0.8083681459476945, 0.7980116647050872, 0.863110021920818, 0.8793308920336467, 0.8481285640859868, 0.9121310043822779, 0.8531184385572244, 0.1750661074403259, 0.1745035267021945, 0.15447497836192758, 0.1710743257498707, 0.17053067298386937, 0.17528471173855342, 0.1901997373695301, 0.17766133012952012, 0.1664124656990119, 0.21738945213994199, 0.23277709652399825, 0.2045794625255256, 0.23335466265300786, 0.2299007452260986, 0.23081889801453703, 0.21001809663212212, 0.23879591988900017, 0.21983208360670192, 0.1079087271799215, 0.10917774759456911, 0.10589350384784046, 0.12310881995860423, 0.11394446330628127, 0.099707593902288, 0.10606234375695389, 0.11903381322744322, 0.10558197445066964, 0.08314134359980685, 0.10732932159081188, 0.08975453716951864, 0.107657543817953, 0.11206559729542587, 0.10540797846933492, 0.10995513582216354, 0.09730722814212733, 0.09920070312135942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09228011137955294, 0.06428557647080724, 0.06357718140730462, 0.04171258194238814, 0.08645053653670187, 0.049351595203804055, 0.06830857652498123, 0.05869050494999828, 0.057176986088656845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06417458554176703, 0.06082554437825016, 0.045946318759585436, 0.04898242817973897, 0.05344142440921662, 0.06527660286173542, 0.05681814016023001, 0.058765153803503334, 0.06083007082175118, 0.34328304521555664, 0.3475209536739209, 0.35239157337844806, 0.3415847469659036, 0.32726022613291317, 0.35190748531066507, 0.3280524713333386, 0.3396852347226139, 0.34871852419079963, 0.09170151222355694, 0.07911630807449199, 0.07998115827367314, 0.08178348993513918, 0.08597583935427122, 0.0783227024095311, 0.07597332169507809, 0.06914243340540538, 0.06684905681622189, 0.15605084239496392, 0.11983047233785804, 0.12736526791702107, 0.14954423060848587, 0.1388322263070575, 0.12787695055460768, 0.14085306858779822, 0.13272137698046604, 0.11990890785360897, 0.23449892760889057, 0.23096663052950472, 0.22457731348649967, 0.22322911162661407, 0.21613044642033252, 0.21923734266022998, 0.23176491142680522, 0.23816359700026124, 0.23175962952791096, 0.16938785049318683, 0.17698571508953642, 0.15705685724805285, 0.15133829484393901, 0.1646831002230379, 0.16652283735060425, 0.16645135512352405, 0.17266981822622507, 0.18178974703518747, 0.17894906254300513, 0.165136322982809, 0.17767025036455475, 0.16740989923949368, 0.193657821512909, 0.17058008329007368, 0.17980007140007637, 0.16906851983184756, 0.17060180866457486, 0.1778069619766065, 0.1576611299075541, 0.17045509791318803, 0.1713534742915772, 0.19183926661036954, 0.16522960617423832, 0.1761998362308972, 0.16560469434597058, 0.15776253087146597, 0.20554380645176085, 0.21967455573101968, 0.14011720127177818, 0.19120786928668676, 0.1721002248767889, 0.2968887762153172, 0.15989020567510104, 0.15593866204690854, 0.14811021897457577, 0.1692049399224006, 0.17999982746108523, 0.1583296990916404, 0.17761686275298794, 0.16430122877579056, 0.16554386955949163, 0.2121327270047293, 0.2418228858016509, 0.19543677412011806, 0.20859660207124653, 0.17022771429919903, 0.18804754230228404, 0.18193130522670875, 0.17362639957134585, 0.179805204923689, 0.17445127208606304, 0.17325290306822094, 0.1820953606815442, 0.06033320669105957, 0.06571292545815499, 0.07001593125364602, 0.07485357529949399, 0.06673097072308942, 0.07040022597030182, 0.05768720392084814, 0.07070488340186343, 0.0671661796487597]}, "mutation_prompt": null}
{"id": "889190b5-4c7f-4b68-ab3a-0347c59fea95", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages dynamic parameter tuning and quantum superposition to enhance convergence on diverse optimization landscapes.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.37716528776936387, 0.3656969431580892, 0.35862226734399305, 0.3642391832626237, 0.39355243764791603, 0.3589330512483563, 0.37086633875181363, 0.3649971923542603, 0.37086866482257896, 0.014718821352867062, 0.0184785818758062, 0.011962931274558275, 0.020694880358807177, 0.007186835177391382, 0.014941605582498463, 0.006566641123293637, 0.0120337215621934, 0.030307155841448163, 0.08291854837121648, 0.0877868355271757, 0.07543241075773455, 0.08565280063431002, 0.0888884761211719, 0.09499014520945204, 0.08316937256283563, 0.08236350731690378, 0.0805993393975255, 0.0728969172388837, 0.06386896549244536, 0.07036330638254873, 0.07743875583476623, 0.06567218789072282, 0.06946934523835901, 0.07536809474251749, 0.0736436667253707, 0.06190950115160698, 0.8443212530650631, 0.81716523749164, 0.8083681459476945, 0.7980116647050872, 0.863110021920818, 0.8793308920336467, 0.8481285640859868, 0.9121310043822779, 0.8531184385572244, 0.1750661074403259, 0.1745035267021945, 0.15447497836192758, 0.1710743257498707, 0.17053067298386937, 0.17528471173855342, 0.1901997373695301, 0.17766133012952012, 0.1664124656990119, 0.21738945213994199, 0.23277709652399825, 0.2045794625255256, 0.23335466265300786, 0.2299007452260986, 0.23081889801453703, 0.21001809663212212, 0.23879591988900017, 0.21983208360670192, 0.1079087271799215, 0.10917774759456911, 0.10589350384784046, 0.12310881995860423, 0.11394446330628127, 0.099707593902288, 0.10606234375695389, 0.11903381322744322, 0.10558197445066964, 0.08314134359980685, 0.10732932159081188, 0.08975453716951864, 0.107657543817953, 0.11206559729542587, 0.10540797846933492, 0.10995513582216354, 0.09730722814212733, 0.09920070312135942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09228011137955294, 0.06428557647080724, 0.06357718140730462, 0.04171258194238814, 0.08645053653670187, 0.049351595203804055, 0.06830857652498123, 0.05869050494999828, 0.057176986088656845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06417458554176703, 0.06082554437825016, 0.045946318759585436, 0.04898242817973897, 0.05344142440921662, 0.06527660286173542, 0.05681814016023001, 0.058765153803503334, 0.06083007082175118, 0.34328304521555664, 0.3475209536739209, 0.35239157337844806, 0.3415847469659036, 0.32726022613291317, 0.35190748531066507, 0.3280524713333386, 0.3396852347226139, 0.34871852419079963, 0.09170151222355694, 0.07911630807449199, 0.07998115827367314, 0.08178348993513918, 0.08597583935427122, 0.0783227024095311, 0.07597332169507809, 0.06914243340540538, 0.06684905681622189, 0.15605084239496392, 0.11983047233785804, 0.12736526791702107, 0.14954423060848587, 0.1388322263070575, 0.12787695055460768, 0.14085306858779822, 0.13272137698046604, 0.11990890785360897, 0.23449892760889057, 0.23096663052950472, 0.22457731348649967, 0.22322911162661407, 0.21613044642033252, 0.21923734266022998, 0.23176491142680522, 0.23816359700026124, 0.23175962952791096, 0.16938785049318683, 0.17698571508953642, 0.15705685724805285, 0.15133829484393901, 0.1646831002230379, 0.16652283735060425, 0.16645135512352405, 0.17266981822622507, 0.18178974703518747, 0.17894906254300513, 0.165136322982809, 0.17767025036455475, 0.16740989923949368, 0.193657821512909, 0.17058008329007368, 0.17980007140007637, 0.16906851983184756, 0.17060180866457486, 0.1778069619766065, 0.1576611299075541, 0.17045509791318803, 0.1713534742915772, 0.19183926661036954, 0.16522960617423832, 0.1761998362308972, 0.16560469434597058, 0.15776253087146597, 0.20554380645176085, 0.21967455573101968, 0.14011720127177818, 0.19120786928668676, 0.1721002248767889, 0.2968887762153172, 0.15989020567510104, 0.15593866204690854, 0.14811021897457577, 0.1692049399224006, 0.17999982746108523, 0.1583296990916404, 0.17761686275298794, 0.16430122877579056, 0.16554386955949163, 0.2121327270047293, 0.2418228858016509, 0.19543677412011806, 0.20859660207124653, 0.17022771429919903, 0.18804754230228404, 0.18193130522670875, 0.17362639957134585, 0.179805204923689, 0.17445127208606304, 0.17325290306822094, 0.1820953606815442, 0.06033320669105957, 0.06571292545815499, 0.07001593125364602, 0.07485357529949399, 0.06673097072308942, 0.07040022597030182, 0.05768720392084814, 0.07070488340186343, 0.0671661796487597]}, "mutation_prompt": null}
{"id": "0475bb9c-ccc5-486e-8d5f-b2479be8a94d", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages dynamic parameter tuning and quantum superposition to enhance convergence on diverse optimization landscapes.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.37716528776936387, 0.3656969431580892, 0.35862226734399305, 0.3642391832626237, 0.39355243764791603, 0.3589330512483563, 0.37086633875181363, 0.3649971923542603, 0.37086866482257896, 0.014718821352867062, 0.0184785818758062, 0.011962931274558275, 0.020694880358807177, 0.007186835177391382, 0.014941605582498463, 0.006566641123293637, 0.0120337215621934, 0.030307155841448163, 0.08291854837121648, 0.0877868355271757, 0.07543241075773455, 0.08565280063431002, 0.0888884761211719, 0.09499014520945204, 0.08316937256283563, 0.08236350731690378, 0.0805993393975255, 0.0728969172388837, 0.06386896549244536, 0.07036330638254873, 0.07743875583476623, 0.06567218789072282, 0.06946934523835901, 0.07536809474251749, 0.0736436667253707, 0.06190950115160698, 0.8443212530650631, 0.81716523749164, 0.8083681459476945, 0.7980116647050872, 0.863110021920818, 0.8793308920336467, 0.8481285640859868, 0.9121310043822779, 0.8531184385572244, 0.1750661074403259, 0.1745035267021945, 0.15447497836192758, 0.1710743257498707, 0.17053067298386937, 0.17528471173855342, 0.1901997373695301, 0.17766133012952012, 0.1664124656990119, 0.21738945213994199, 0.23277709652399825, 0.2045794625255256, 0.23335466265300786, 0.2299007452260986, 0.23081889801453703, 0.21001809663212212, 0.23879591988900017, 0.21983208360670192, 0.1079087271799215, 0.10917774759456911, 0.10589350384784046, 0.12310881995860423, 0.11394446330628127, 0.099707593902288, 0.10606234375695389, 0.11903381322744322, 0.10558197445066964, 0.08314134359980685, 0.10732932159081188, 0.08975453716951864, 0.107657543817953, 0.11206559729542587, 0.10540797846933492, 0.10995513582216354, 0.09730722814212733, 0.09920070312135942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09228011137955294, 0.06428557647080724, 0.06357718140730462, 0.04171258194238814, 0.08645053653670187, 0.049351595203804055, 0.06830857652498123, 0.05869050494999828, 0.057176986088656845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06417458554176703, 0.06082554437825016, 0.045946318759585436, 0.04898242817973897, 0.05344142440921662, 0.06527660286173542, 0.05681814016023001, 0.058765153803503334, 0.06083007082175118, 0.34328304521555664, 0.3475209536739209, 0.35239157337844806, 0.3415847469659036, 0.32726022613291317, 0.35190748531066507, 0.3280524713333386, 0.3396852347226139, 0.34871852419079963, 0.09170151222355694, 0.07911630807449199, 0.07998115827367314, 0.08178348993513918, 0.08597583935427122, 0.0783227024095311, 0.07597332169507809, 0.06914243340540538, 0.06684905681622189, 0.15605084239496392, 0.11983047233785804, 0.12736526791702107, 0.14954423060848587, 0.1388322263070575, 0.12787695055460768, 0.14085306858779822, 0.13272137698046604, 0.11990890785360897, 0.23449892760889057, 0.23096663052950472, 0.22457731348649967, 0.22322911162661407, 0.21613044642033252, 0.21923734266022998, 0.23176491142680522, 0.23816359700026124, 0.23175962952791096, 0.16938785049318683, 0.17698571508953642, 0.15705685724805285, 0.15133829484393901, 0.1646831002230379, 0.16652283735060425, 0.16645135512352405, 0.17266981822622507, 0.18178974703518747, 0.17894906254300513, 0.165136322982809, 0.17767025036455475, 0.16740989923949368, 0.193657821512909, 0.17058008329007368, 0.17980007140007637, 0.16906851983184756, 0.17060180866457486, 0.1778069619766065, 0.1576611299075541, 0.17045509791318803, 0.1713534742915772, 0.19183926661036954, 0.16522960617423832, 0.1761998362308972, 0.16560469434597058, 0.15776253087146597, 0.20554380645176085, 0.21967455573101968, 0.14011720127177818, 0.19120786928668676, 0.1721002248767889, 0.2968887762153172, 0.15989020567510104, 0.15593866204690854, 0.14811021897457577, 0.1692049399224006, 0.17999982746108523, 0.1583296990916404, 0.17761686275298794, 0.16430122877579056, 0.16554386955949163, 0.2121327270047293, 0.2418228858016509, 0.19543677412011806, 0.20859660207124653, 0.17022771429919903, 0.18804754230228404, 0.18193130522670875, 0.17362639957134585, 0.179805204923689, 0.17445127208606304, 0.17325290306822094, 0.1820953606815442, 0.06033320669105957, 0.06571292545815499, 0.07001593125364602, 0.07485357529949399, 0.06673097072308942, 0.07040022597030182, 0.05768720392084814, 0.07070488340186343, 0.0671661796487597]}, "mutation_prompt": null}
{"id": "aa74d314-392b-4ae1-a6b2-4c31446fb86e", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages dynamic parameter tuning and quantum superposition to enhance convergence on diverse optimization landscapes.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.37716528776936387, 0.3656969431580892, 0.35862226734399305, 0.3642391832626237, 0.39355243764791603, 0.3589330512483563, 0.37086633875181363, 0.3649971923542603, 0.37086866482257896, 0.014718821352867062, 0.0184785818758062, 0.011962931274558275, 0.020694880358807177, 0.007186835177391382, 0.014941605582498463, 0.006566641123293637, 0.0120337215621934, 0.030307155841448163, 0.08291854837121648, 0.0877868355271757, 0.07543241075773455, 0.08565280063431002, 0.0888884761211719, 0.09499014520945204, 0.08316937256283563, 0.08236350731690378, 0.0805993393975255, 0.0728969172388837, 0.06386896549244536, 0.07036330638254873, 0.07743875583476623, 0.06567218789072282, 0.06946934523835901, 0.07536809474251749, 0.0736436667253707, 0.06190950115160698, 0.8443212530650631, 0.81716523749164, 0.8083681459476945, 0.7980116647050872, 0.863110021920818, 0.8793308920336467, 0.8481285640859868, 0.9121310043822779, 0.8531184385572244, 0.1750661074403259, 0.1745035267021945, 0.15447497836192758, 0.1710743257498707, 0.17053067298386937, 0.17528471173855342, 0.1901997373695301, 0.17766133012952012, 0.1664124656990119, 0.21738945213994199, 0.23277709652399825, 0.2045794625255256, 0.23335466265300786, 0.2299007452260986, 0.23081889801453703, 0.21001809663212212, 0.23879591988900017, 0.21983208360670192, 0.1079087271799215, 0.10917774759456911, 0.10589350384784046, 0.12310881995860423, 0.11394446330628127, 0.099707593902288, 0.10606234375695389, 0.11903381322744322, 0.10558197445066964, 0.08314134359980685, 0.10732932159081188, 0.08975453716951864, 0.107657543817953, 0.11206559729542587, 0.10540797846933492, 0.10995513582216354, 0.09730722814212733, 0.09920070312135942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09228011137955294, 0.06428557647080724, 0.06357718140730462, 0.04171258194238814, 0.08645053653670187, 0.049351595203804055, 0.06830857652498123, 0.05869050494999828, 0.057176986088656845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06417458554176703, 0.06082554437825016, 0.045946318759585436, 0.04898242817973897, 0.05344142440921662, 0.06527660286173542, 0.05681814016023001, 0.058765153803503334, 0.06083007082175118, 0.34328304521555664, 0.3475209536739209, 0.35239157337844806, 0.3415847469659036, 0.32726022613291317, 0.35190748531066507, 0.3280524713333386, 0.3396852347226139, 0.34871852419079963, 0.09170151222355694, 0.07911630807449199, 0.07998115827367314, 0.08178348993513918, 0.08597583935427122, 0.0783227024095311, 0.07597332169507809, 0.06914243340540538, 0.06684905681622189, 0.15605084239496392, 0.11983047233785804, 0.12736526791702107, 0.14954423060848587, 0.1388322263070575, 0.12787695055460768, 0.14085306858779822, 0.13272137698046604, 0.11990890785360897, 0.23449892760889057, 0.23096663052950472, 0.22457731348649967, 0.22322911162661407, 0.21613044642033252, 0.21923734266022998, 0.23176491142680522, 0.23816359700026124, 0.23175962952791096, 0.16938785049318683, 0.17698571508953642, 0.15705685724805285, 0.15133829484393901, 0.1646831002230379, 0.16652283735060425, 0.16645135512352405, 0.17266981822622507, 0.18178974703518747, 0.17894906254300513, 0.165136322982809, 0.17767025036455475, 0.16740989923949368, 0.193657821512909, 0.17058008329007368, 0.17980007140007637, 0.16906851983184756, 0.17060180866457486, 0.1778069619766065, 0.1576611299075541, 0.17045509791318803, 0.1713534742915772, 0.19183926661036954, 0.16522960617423832, 0.1761998362308972, 0.16560469434597058, 0.15776253087146597, 0.20554380645176085, 0.21967455573101968, 0.14011720127177818, 0.19120786928668676, 0.1721002248767889, 0.2968887762153172, 0.15989020567510104, 0.15593866204690854, 0.14811021897457577, 0.1692049399224006, 0.17999982746108523, 0.1583296990916404, 0.17761686275298794, 0.16430122877579056, 0.16554386955949163, 0.2121327270047293, 0.2418228858016509, 0.19543677412011806, 0.20859660207124653, 0.17022771429919903, 0.18804754230228404, 0.18193130522670875, 0.17362639957134585, 0.179805204923689, 0.17445127208606304, 0.17325290306822094, 0.1820953606815442, 0.06033320669105957, 0.06571292545815499, 0.07001593125364602, 0.07485357529949399, 0.06673097072308942, 0.07040022597030182, 0.05768720392084814, 0.07070488340186343, 0.0671661796487597]}, "mutation_prompt": null}
{"id": "38e5f684-971e-450d-9119-7a5b2b44b4b6", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages dynamic parameter tuning and quantum superposition to enhance convergence on diverse optimization landscapes.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.37716528776936387, 0.3656969431580892, 0.35862226734399305, 0.3642391832626237, 0.39355243764791603, 0.3589330512483563, 0.37086633875181363, 0.3649971923542603, 0.37086866482257896, 0.014718821352867062, 0.0184785818758062, 0.011962931274558275, 0.020694880358807177, 0.007186835177391382, 0.014941605582498463, 0.006566641123293637, 0.0120337215621934, 0.030307155841448163, 0.08291854837121648, 0.0877868355271757, 0.07543241075773455, 0.08565280063431002, 0.0888884761211719, 0.09499014520945204, 0.08316937256283563, 0.08236350731690378, 0.0805993393975255, 0.0728969172388837, 0.06386896549244536, 0.07036330638254873, 0.07743875583476623, 0.06567218789072282, 0.06946934523835901, 0.07536809474251749, 0.0736436667253707, 0.06190950115160698, 0.8443212530650631, 0.81716523749164, 0.8083681459476945, 0.7980116647050872, 0.863110021920818, 0.8793308920336467, 0.8481285640859868, 0.9121310043822779, 0.8531184385572244, 0.1750661074403259, 0.1745035267021945, 0.15447497836192758, 0.1710743257498707, 0.17053067298386937, 0.17528471173855342, 0.1901997373695301, 0.17766133012952012, 0.1664124656990119, 0.21738945213994199, 0.23277709652399825, 0.2045794625255256, 0.23335466265300786, 0.2299007452260986, 0.23081889801453703, 0.21001809663212212, 0.23879591988900017, 0.21983208360670192, 0.1079087271799215, 0.10917774759456911, 0.10589350384784046, 0.12310881995860423, 0.11394446330628127, 0.099707593902288, 0.10606234375695389, 0.11903381322744322, 0.10558197445066964, 0.08314134359980685, 0.10732932159081188, 0.08975453716951864, 0.107657543817953, 0.11206559729542587, 0.10540797846933492, 0.10995513582216354, 0.09730722814212733, 0.09920070312135942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09228011137955294, 0.06428557647080724, 0.06357718140730462, 0.04171258194238814, 0.08645053653670187, 0.049351595203804055, 0.06830857652498123, 0.05869050494999828, 0.057176986088656845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06417458554176703, 0.06082554437825016, 0.045946318759585436, 0.04898242817973897, 0.05344142440921662, 0.06527660286173542, 0.05681814016023001, 0.058765153803503334, 0.06083007082175118, 0.34328304521555664, 0.3475209536739209, 0.35239157337844806, 0.3415847469659036, 0.32726022613291317, 0.35190748531066507, 0.3280524713333386, 0.3396852347226139, 0.34871852419079963, 0.09170151222355694, 0.07911630807449199, 0.07998115827367314, 0.08178348993513918, 0.08597583935427122, 0.0783227024095311, 0.07597332169507809, 0.06914243340540538, 0.06684905681622189, 0.15605084239496392, 0.11983047233785804, 0.12736526791702107, 0.14954423060848587, 0.1388322263070575, 0.12787695055460768, 0.14085306858779822, 0.13272137698046604, 0.11990890785360897, 0.23449892760889057, 0.23096663052950472, 0.22457731348649967, 0.22322911162661407, 0.21613044642033252, 0.21923734266022998, 0.23176491142680522, 0.23816359700026124, 0.23175962952791096, 0.16938785049318683, 0.17698571508953642, 0.15705685724805285, 0.15133829484393901, 0.1646831002230379, 0.16652283735060425, 0.16645135512352405, 0.17266981822622507, 0.18178974703518747, 0.17894906254300513, 0.165136322982809, 0.17767025036455475, 0.16740989923949368, 0.193657821512909, 0.17058008329007368, 0.17980007140007637, 0.16906851983184756, 0.17060180866457486, 0.1778069619766065, 0.1576611299075541, 0.17045509791318803, 0.1713534742915772, 0.19183926661036954, 0.16522960617423832, 0.1761998362308972, 0.16560469434597058, 0.15776253087146597, 0.20554380645176085, 0.21967455573101968, 0.14011720127177818, 0.19120786928668676, 0.1721002248767889, 0.2968887762153172, 0.15989020567510104, 0.15593866204690854, 0.14811021897457577, 0.1692049399224006, 0.17999982746108523, 0.1583296990916404, 0.17761686275298794, 0.16430122877579056, 0.16554386955949163, 0.2121327270047293, 0.2418228858016509, 0.19543677412011806, 0.20859660207124653, 0.17022771429919903, 0.18804754230228404, 0.18193130522670875, 0.17362639957134585, 0.179805204923689, 0.17445127208606304, 0.17325290306822094, 0.1820953606815442, 0.06033320669105957, 0.06571292545815499, 0.07001593125364602, 0.07485357529949399, 0.06673097072308942, 0.07040022597030182, 0.05768720392084814, 0.07070488340186343, 0.0671661796487597]}, "mutation_prompt": null}
{"id": "dfc3106d-4bc5-4ff7-9ffe-4982307d36ae", "solution": "import numpy as np\n\nclass QuantumTurbulenceAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3  # Broadened min differential weight\n        self.f_max = 0.8  # Narrowed max differential weight\n        self.cr_min = 0.5  # Broadened min crossover probability\n        self.cr_max = 0.9  # Narrowed max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_turbulence(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        turbulence_perturbation = (np.random.rand(self.dim) - 0.5) * (self.upper_bound - self.lower_bound) / 8\n        return sol + np.sin(theta) * turbulence_perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_turbulence(trial)  # Apply quantum turbulence\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumTurbulenceAdaptiveDifferentialEvolution", "description": "Quantum-Turbulence Adaptive Differential Evolution incorporates chaotic quantum perturbations to enhance exploration and convergence on complex optimization landscapes.", "configspace": "", "generation": 10, "fitness": 0.16668668610468446, "feedback": "The algorithm QuantumTurbulenceAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.34553354933506564, 0.3306584446276998, 0.3234184286576064, 0.33382014434933693, 0.3252539480625175, 0.35839510117471174, 0.36206700466462827, 0.3237065758664468, 0.34537547081408027, 0.0008723802783162649, 0.0024887234417292348, 0.0001642093271458922, 0.010918793072921873, 9.999999999998899e-05, 0.004535918038640174, 0.007755329409840694, 0.0003724513161718068, 0.008449347146164299, 0.08413511335601764, 0.08853904851231487, 0.08450963803084255, 0.08210820469513203, 0.08749902105714902, 0.09304206248415614, 0.08077663482495301, 0.08568435775578187, 0.07729376346345584, 0.07298047011984676, 0.07182122415369341, 0.07310335678514712, 0.07297832163155527, 0.07248710052286356, 0.07111396865232711, 0.06788337895846341, 0.0693793585961554, 0.08375610254369259, 0.8555860115157206, 0.8383670803428693, 0.9162319641257118, 0.8347791462174486, 0.8924848415964527, 0.8608235906049778, 0.8938196848965404, 0.8240559481959664, 0.8255581625542802, 0.1530696082890598, 0.1513139351363838, 0.16127080661607873, 0.1697107918753361, 0.17711094830653218, 0.18135807407051974, 0.1823206953299772, 0.16968784826325067, 0.1659611270523692, 0.21824616569532407, 0.24400984013040583, 0.19044832322919614, 0.2157958871155412, 0.20962333024400337, 0.20383386122232316, 0.22408640370564137, 0.24132703885564355, 0.19069767195909948, 0.1070236095617636, 0.10298072241662626, 0.10395141768793803, 0.10250462125682547, 0.11006126763012092, 0.09700932298865117, 0.1117891651052878, 0.10472225348946307, 0.10802712887460952, 0.07876242053298299, 0.09970011458284755, 0.08747214044632456, 0.10276307623056236, 0.11602329653026977, 0.09349665913085314, 0.10307803707229524, 0.10680591848640919, 0.09116175975391938, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04738550444231737, 0.05083189441202163, 0.07215505996075877, 0.09314971576536868, 0.026942885119776272, 0.057023494340447956, 0.09508024584379204, 0.09158152760853977, 0.05681718700479266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.041557624377288827, 0.0465584893622899, 0.05204714535968391, 0.06975531198111151, 0.04856185596785112, 0.050780495280755344, 0.04235134507172389, 0.04940755945817876, 0.04873424302128715, 0.32892534888147207, 0.32042187843902825, 0.32188768333582385, 0.3346739395326167, 0.33980598316609945, 0.32874279073286883, 0.3420460486857221, 0.3073584365539781, 0.3178029676499523, 0.07760123384324202, 0.07708721080556247, 0.09016418861917752, 0.0744237134896426, 0.07042936844165759, 0.07793941418052475, 0.09343097275498369, 0.0666627357962345, 0.08087284890578561, 0.12260959328557419, 0.12422111238702549, 0.13485691985499326, 0.15322438814780603, 0.13440078137192746, 0.11961197571861881, 0.13227416109370238, 0.1414998754021093, 0.21267819175210845, 0.22527963094682035, 0.22098598566236993, 0.2340463470131785, 0.2184900242271065, 0.22356995402581892, 0.2117709903591407, 0.23480363528450532, 0.2306068727500309, 0.22665828289758128, 0.16420238652285357, 0.17515754066115918, 0.16286249594085622, 0.15773421041431634, 0.16248985882177935, 0.1785847387706856, 0.16284030298143903, 0.18389780577780834, 0.17336485313233496, 0.21135054003411569, 0.17925308929401906, 0.18847945820112166, 0.1720280896182439, 0.17896172415441447, 0.17236548759605708, 0.1813136460755178, 0.17902606371981056, 0.18453032794417423, 0.17133497621564642, 0.16438825509673916, 0.16539509531270524, 0.16453343388032482, 0.1736982351814298, 0.17017332347332847, 0.17136464197779566, 0.17078122475776547, 0.17012506265552352, 0.1707397466194852, 0.1768757913422525, 0.16514242123093392, 0.16444104381618785, 0.20250028411670806, 0.23844089532959634, 0.15827813807469715, 0.16879931017491745, 0.24969501730708454, 0.25655503509348043, 0.18489991878717027, 0.2118169129847398, 0.24206016722782098, 0.15211113460900882, 0.24227076165565453, 0.19152573692054675, 0.1920531523772644, 0.18287492184732623, 0.17444826368141253, 0.17663015898875167, 0.1696236920485864, 0.17973433613751733, 0.18408434402440776, 0.17926507041878392, 0.18116551348340248, 0.19286091292002705, 0.17025927258337836, 0.06746212493796377, 0.055137012676315655, 0.07273859532122184, 0.07271549526003895, 0.06935440313219643, 0.0782125832882612, 0.08658251252776294, 0.0657261076323441, 0.07073080679887667]}, "mutation_prompt": null}
{"id": "c29443d1-cfbb-4edd-bcbb-4ffc0a6997fb", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages dynamic parameter tuning and quantum superposition to enhance convergence on diverse optimization landscapes.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.37716528776936387, 0.3656969431580892, 0.35862226734399305, 0.3642391832626237, 0.39355243764791603, 0.3589330512483563, 0.37086633875181363, 0.3649971923542603, 0.37086866482257896, 0.014718821352867062, 0.0184785818758062, 0.011962931274558275, 0.020694880358807177, 0.007186835177391382, 0.014941605582498463, 0.006566641123293637, 0.0120337215621934, 0.030307155841448163, 0.08291854837121648, 0.0877868355271757, 0.07543241075773455, 0.08565280063431002, 0.0888884761211719, 0.09499014520945204, 0.08316937256283563, 0.08236350731690378, 0.0805993393975255, 0.0728969172388837, 0.06386896549244536, 0.07036330638254873, 0.07743875583476623, 0.06567218789072282, 0.06946934523835901, 0.07536809474251749, 0.0736436667253707, 0.06190950115160698, 0.8443212530650631, 0.81716523749164, 0.8083681459476945, 0.7980116647050872, 0.863110021920818, 0.8793308920336467, 0.8481285640859868, 0.9121310043822779, 0.8531184385572244, 0.1750661074403259, 0.1745035267021945, 0.15447497836192758, 0.1710743257498707, 0.17053067298386937, 0.17528471173855342, 0.1901997373695301, 0.17766133012952012, 0.1664124656990119, 0.21738945213994199, 0.23277709652399825, 0.2045794625255256, 0.23335466265300786, 0.2299007452260986, 0.23081889801453703, 0.21001809663212212, 0.23879591988900017, 0.21983208360670192, 0.1079087271799215, 0.10917774759456911, 0.10589350384784046, 0.12310881995860423, 0.11394446330628127, 0.099707593902288, 0.10606234375695389, 0.11903381322744322, 0.10558197445066964, 0.08314134359980685, 0.10732932159081188, 0.08975453716951864, 0.107657543817953, 0.11206559729542587, 0.10540797846933492, 0.10995513582216354, 0.09730722814212733, 0.09920070312135942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09228011137955294, 0.06428557647080724, 0.06357718140730462, 0.04171258194238814, 0.08645053653670187, 0.049351595203804055, 0.06830857652498123, 0.05869050494999828, 0.057176986088656845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06417458554176703, 0.06082554437825016, 0.045946318759585436, 0.04898242817973897, 0.05344142440921662, 0.06527660286173542, 0.05681814016023001, 0.058765153803503334, 0.06083007082175118, 0.34328304521555664, 0.3475209536739209, 0.35239157337844806, 0.3415847469659036, 0.32726022613291317, 0.35190748531066507, 0.3280524713333386, 0.3396852347226139, 0.34871852419079963, 0.09170151222355694, 0.07911630807449199, 0.07998115827367314, 0.08178348993513918, 0.08597583935427122, 0.0783227024095311, 0.07597332169507809, 0.06914243340540538, 0.06684905681622189, 0.15605084239496392, 0.11983047233785804, 0.12736526791702107, 0.14954423060848587, 0.1388322263070575, 0.12787695055460768, 0.14085306858779822, 0.13272137698046604, 0.11990890785360897, 0.23449892760889057, 0.23096663052950472, 0.22457731348649967, 0.22322911162661407, 0.21613044642033252, 0.21923734266022998, 0.23176491142680522, 0.23816359700026124, 0.23175962952791096, 0.16938785049318683, 0.17698571508953642, 0.15705685724805285, 0.15133829484393901, 0.1646831002230379, 0.16652283735060425, 0.16645135512352405, 0.17266981822622507, 0.18178974703518747, 0.17894906254300513, 0.165136322982809, 0.17767025036455475, 0.16740989923949368, 0.193657821512909, 0.17058008329007368, 0.17980007140007637, 0.16906851983184756, 0.17060180866457486, 0.1778069619766065, 0.1576611299075541, 0.17045509791318803, 0.1713534742915772, 0.19183926661036954, 0.16522960617423832, 0.1761998362308972, 0.16560469434597058, 0.15776253087146597, 0.20554380645176085, 0.21967455573101968, 0.14011720127177818, 0.19120786928668676, 0.1721002248767889, 0.2968887762153172, 0.15989020567510104, 0.15593866204690854, 0.14811021897457577, 0.1692049399224006, 0.17999982746108523, 0.1583296990916404, 0.17761686275298794, 0.16430122877579056, 0.16554386955949163, 0.2121327270047293, 0.2418228858016509, 0.19543677412011806, 0.20859660207124653, 0.17022771429919903, 0.18804754230228404, 0.18193130522670875, 0.17362639957134585, 0.179805204923689, 0.17445127208606304, 0.17325290306822094, 0.1820953606815442, 0.06033320669105957, 0.06571292545815499, 0.07001593125364602, 0.07485357529949399, 0.06673097072308942, 0.07040022597030182, 0.05768720392084814, 0.07070488340186343, 0.0671661796487597]}, "mutation_prompt": null}
{"id": "820691d6-c170-40b3-bc56-bc4b3476e660", "solution": "import numpy as np\n\nclass MultiStrategyQuantumAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3  # Adjusted min differential weight\n        self.f_max = 0.8  # Max differential weight\n        self.cr_min = 0.5  # Adjusted min crossover probability\n        self.cr_max = 0.9  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 20\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def rand_1_bin(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        return np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n\n    def best_1_bin(self, f):\n        best_idx = np.argmin([func(ind) for ind in self.population])\n        indices = [idx for idx in range(self.population_size) if idx != best_idx]\n        b, c = self.population[np.random.choice(indices, 2, replace=False)]\n        return np.clip(self.population[best_idx] + f * (b - c), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                \n                # Choose mutation strategy\n                if np.random.rand() < 0.5:\n                    mutant = self.rand_1_bin(i, f)\n                else:\n                    mutant = self.best_1_bin(f)\n                \n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "MultiStrategyQuantumAdaptiveDifferentialEvolution", "description": "Multi-strategy Quantum Adaptive Differential Evolution combines adaptive parameters and quantum perturbations with multiple mutation strategies to improve convergence.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'func' is not defined\").", "error": "NameError(\"name 'func' is not defined\")", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {}, "mutation_prompt": null}
{"id": "420d85ee-60bc-4c8b-b7ff-d32939c68b4e", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)  # Apply quantum superposition\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution leverages dynamic parameter tuning and quantum superposition to enhance convergence on diverse optimization landscapes.", "configspace": "", "generation": 4, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.37716528776936387, 0.3656969431580892, 0.35862226734399305, 0.3642391832626237, 0.39355243764791603, 0.3589330512483563, 0.37086633875181363, 0.3649971923542603, 0.37086866482257896, 0.014718821352867062, 0.0184785818758062, 0.011962931274558275, 0.020694880358807177, 0.007186835177391382, 0.014941605582498463, 0.006566641123293637, 0.0120337215621934, 0.030307155841448163, 0.08291854837121648, 0.0877868355271757, 0.07543241075773455, 0.08565280063431002, 0.0888884761211719, 0.09499014520945204, 0.08316937256283563, 0.08236350731690378, 0.0805993393975255, 0.0728969172388837, 0.06386896549244536, 0.07036330638254873, 0.07743875583476623, 0.06567218789072282, 0.06946934523835901, 0.07536809474251749, 0.0736436667253707, 0.06190950115160698, 0.8443212530650631, 0.81716523749164, 0.8083681459476945, 0.7980116647050872, 0.863110021920818, 0.8793308920336467, 0.8481285640859868, 0.9121310043822779, 0.8531184385572244, 0.1750661074403259, 0.1745035267021945, 0.15447497836192758, 0.1710743257498707, 0.17053067298386937, 0.17528471173855342, 0.1901997373695301, 0.17766133012952012, 0.1664124656990119, 0.21738945213994199, 0.23277709652399825, 0.2045794625255256, 0.23335466265300786, 0.2299007452260986, 0.23081889801453703, 0.21001809663212212, 0.23879591988900017, 0.21983208360670192, 0.1079087271799215, 0.10917774759456911, 0.10589350384784046, 0.12310881995860423, 0.11394446330628127, 0.099707593902288, 0.10606234375695389, 0.11903381322744322, 0.10558197445066964, 0.08314134359980685, 0.10732932159081188, 0.08975453716951864, 0.107657543817953, 0.11206559729542587, 0.10540797846933492, 0.10995513582216354, 0.09730722814212733, 0.09920070312135942, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09228011137955294, 0.06428557647080724, 0.06357718140730462, 0.04171258194238814, 0.08645053653670187, 0.049351595203804055, 0.06830857652498123, 0.05869050494999828, 0.057176986088656845, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06417458554176703, 0.06082554437825016, 0.045946318759585436, 0.04898242817973897, 0.05344142440921662, 0.06527660286173542, 0.05681814016023001, 0.058765153803503334, 0.06083007082175118, 0.34328304521555664, 0.3475209536739209, 0.35239157337844806, 0.3415847469659036, 0.32726022613291317, 0.35190748531066507, 0.3280524713333386, 0.3396852347226139, 0.34871852419079963, 0.09170151222355694, 0.07911630807449199, 0.07998115827367314, 0.08178348993513918, 0.08597583935427122, 0.0783227024095311, 0.07597332169507809, 0.06914243340540538, 0.06684905681622189, 0.15605084239496392, 0.11983047233785804, 0.12736526791702107, 0.14954423060848587, 0.1388322263070575, 0.12787695055460768, 0.14085306858779822, 0.13272137698046604, 0.11990890785360897, 0.23449892760889057, 0.23096663052950472, 0.22457731348649967, 0.22322911162661407, 0.21613044642033252, 0.21923734266022998, 0.23176491142680522, 0.23816359700026124, 0.23175962952791096, 0.16938785049318683, 0.17698571508953642, 0.15705685724805285, 0.15133829484393901, 0.1646831002230379, 0.16652283735060425, 0.16645135512352405, 0.17266981822622507, 0.18178974703518747, 0.17894906254300513, 0.165136322982809, 0.17767025036455475, 0.16740989923949368, 0.193657821512909, 0.17058008329007368, 0.17980007140007637, 0.16906851983184756, 0.17060180866457486, 0.1778069619766065, 0.1576611299075541, 0.17045509791318803, 0.1713534742915772, 0.19183926661036954, 0.16522960617423832, 0.1761998362308972, 0.16560469434597058, 0.15776253087146597, 0.20554380645176085, 0.21967455573101968, 0.14011720127177818, 0.19120786928668676, 0.1721002248767889, 0.2968887762153172, 0.15989020567510104, 0.15593866204690854, 0.14811021897457577, 0.1692049399224006, 0.17999982746108523, 0.1583296990916404, 0.17761686275298794, 0.16430122877579056, 0.16554386955949163, 0.2121327270047293, 0.2418228858016509, 0.19543677412011806, 0.20859660207124653, 0.17022771429919903, 0.18804754230228404, 0.18193130522670875, 0.17362639957134585, 0.179805204923689, 0.17445127208606304, 0.17325290306822094, 0.1820953606815442, 0.06033320669105957, 0.06571292545815499, 0.07001593125364602, 0.07485357529949399, 0.06673097072308942, 0.07040022597030182, 0.05768720392084814, 0.07070488340186343, 0.0671661796487597]}, "mutation_prompt": null}
{"id": "ca655e00-e318-42ef-9e3a-e9fb41292c20", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 10)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution with Elite Preservation combines dynamic parameter tuning, quantum superposition, and elite preservation to enhance robustness and convergence.", "configspace": "", "generation": 14, "fitness": 0.17675797273423074, "feedback": "The algorithm QuantumInspiredAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "389ed22a-4b6f-4a7b-830e-ca1d9db2f9dc", "metadata": {"aucs": [0.3730770170504416, 0.3618928502596258, 0.38065308393509123, 0.3821341589384779, 0.38286472449347253, 0.39302566471562994, 0.38517534227270667, 0.3727602090740333, 0.36555073704253005, 0.0024252982230261733, 0.007809886241437969, 0.0002694103830541694, 0.003514235104049801, 0.003781145602659075, 0.015369989668008732, 0.03718947436555209, 0.01498109237347367, 0.009961953562935721, 0.08439100355935303, 0.08804055950512779, 0.07803930253495017, 0.1003298517022504, 0.07638915526284074, 0.08230922237619287, 0.0902076934781626, 0.08625351777176615, 0.10291027147359999, 0.06975656096943295, 0.07891994342210473, 0.07854758390011973, 0.07463723475924366, 0.07069073679794002, 0.07430734814839557, 0.07788456859745152, 0.08605798193485947, 0.08142483321552918, 0.8258432161567696, 0.9163260668055434, 0.9002126239255844, 0.8540631739791784, 0.8827395269762277, 0.8698371998556185, 0.8914924432380432, 0.8964683615927281, 0.7836271604290194, 0.19883778788948714, 0.1916714705779038, 0.19847278565049142, 0.18205624288471467, 0.17704276292835253, 0.17896495778416088, 0.2185215061021396, 0.18026138852513396, 0.1891890011868439, 0.25236756097519697, 0.22489614354653564, 0.22626251301891398, 0.2249506181363985, 0.2502827630648812, 0.2241869583033862, 0.23866271188338983, 0.24255932964702276, 0.23854338944520836, 0.11251568643233545, 0.11518351398987392, 0.10973482519015454, 0.12535482704797718, 0.12130008791988856, 0.11189907892813422, 0.12575935021226337, 0.12267587463663054, 0.11981052495790778, 0.11025011258496509, 0.08565908783490972, 0.11850935835216936, 0.12452540574733684, 0.10342095626179848, 0.1085498718841984, 0.12350378333273948, 0.12503805884002706, 0.12542020583115043, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005623398954567316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008540438079190027, 9.999999999998899e-05, 0.07985892311264775, 0.06358529391157774, 0.07544969986161176, 0.03631275179977822, 0.056583269820254856, 0.04536721724216364, 0.05164470279185096, 0.06717069486254346, 0.07049420038673637, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05635860814138427, 0.06609883468256372, 0.06618012720976862, 0.05828545483650138, 0.0808994998328777, 0.07088594367372192, 0.06094404599025616, 0.05828485269229711, 0.057315864668663785, 0.32078272201591085, 0.3410407784397186, 0.33915174313468743, 0.3462418600580448, 0.35362188133437833, 0.36265287423732384, 0.3335568316870223, 0.3513657215521184, 0.32956588571603374, 0.09066968818562016, 0.0794677426750191, 0.08144406390726366, 0.07829125942420068, 0.08491746296511704, 0.07614511683811709, 0.08261779022571714, 0.08498522964428934, 0.08253676850435365, 0.16026599580398904, 0.1554130581352685, 0.1307595381144554, 0.13423854354385711, 0.12685023619794156, 0.15542625971568214, 0.1408362618989184, 0.1295165855433732, 0.12070878929319118, 0.24189091196026624, 0.22830774333201675, 0.23168736532579925, 0.245233153986958, 0.23413281664311636, 0.22466599457378977, 0.2448433602016893, 0.24677433731648424, 0.24930452429082217, 0.17244401213003935, 0.17114780191310297, 0.20296739841335498, 0.17635996694599687, 0.16522932004414237, 0.16245015237382554, 0.19758053422606858, 0.19048199420664336, 0.17501816518584257, 0.1804172907623468, 0.18946595302589586, 0.18852765093835555, 0.1779166464452635, 0.18083942606458936, 0.16405621724444586, 0.1656307367208263, 0.17437109709277088, 0.17603830871502235, 0.17635215717859032, 0.17779154756167914, 0.1633838747797941, 0.1644417933274026, 0.16819417237116852, 0.16200230383858738, 0.17349662418102485, 0.1662210165924124, 0.16958158763765974, 0.31848211493598366, 0.15012808933458888, 0.229330993381324, 0.2703486929138933, 0.20326648933681746, 0.17078000966439855, 0.21557230252047543, 0.15229774343622537, 0.30163750358416086, 0.23441418909635148, 0.18358381479558117, 0.39603963177042045, 0.27605318226694464, 0.18273658272132265, 0.25809163812590075, 0.19957093130493464, 0.25058168225837685, 0.17086490994846204, 0.16827732232053827, 0.18301789138459856, 0.19241345704915958, 0.16703695036145472, 0.18294550967283107, 0.17852071998883223, 0.18560034744499165, 0.1750948987814025, 0.17756489183958934, 0.05957423593507705, 0.06422878090016582, 0.07028152382166897, 0.06872108710528113, 0.06631475771263262, 0.07345155458415664, 0.07064423436870715, 0.06286090510205689, 0.06366721378442053]}, "mutation_prompt": null}
{"id": "2f0bfa17-b869-4173-8001-7fb872def18e", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 10)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution with Elite Preservation combines dynamic parameter tuning, quantum superposition, and elite preservation to enhance robustness and convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca655e00-e318-42ef-9e3a-e9fb41292c20", "metadata": {"aucs": [0.3730770170504416, 0.3618928502596258, 0.38065308393509123, 0.3821341589384779, 0.38286472449347253, 0.39302566471562994, 0.38517534227270667, 0.3727602090740333, 0.36555073704253005, 0.0024252982230261733, 0.007809886241437969, 0.0002694103830541694, 0.003514235104049801, 0.003781145602659075, 0.015369989668008732, 0.03718947436555209, 0.01498109237347367, 0.009961953562935721, 0.08439100355935303, 0.08804055950512779, 0.07803930253495017, 0.1003298517022504, 0.07638915526284074, 0.08230922237619287, 0.0902076934781626, 0.08625351777176615, 0.10291027147359999, 0.06975656096943295, 0.07891994342210473, 0.07854758390011973, 0.07463723475924366, 0.07069073679794002, 0.07430734814839557, 0.07788456859745152, 0.08605798193485947, 0.08142483321552918, 0.8258432161567696, 0.9163260668055434, 0.9002126239255844, 0.8540631739791784, 0.8827395269762277, 0.8698371998556185, 0.8914924432380432, 0.8964683615927281, 0.7836271604290194, 0.19883778788948714, 0.1916714705779038, 0.19847278565049142, 0.18205624288471467, 0.17704276292835253, 0.17896495778416088, 0.2185215061021396, 0.18026138852513396, 0.1891890011868439, 0.25236756097519697, 0.22489614354653564, 0.22626251301891398, 0.2249506181363985, 0.2502827630648812, 0.2241869583033862, 0.23866271188338983, 0.24255932964702276, 0.23854338944520836, 0.11251568643233545, 0.11518351398987392, 0.10973482519015454, 0.12535482704797718, 0.12130008791988856, 0.11189907892813422, 0.12575935021226337, 0.12267587463663054, 0.11981052495790778, 0.11025011258496509, 0.08565908783490972, 0.11850935835216936, 0.12452540574733684, 0.10342095626179848, 0.1085498718841984, 0.12350378333273948, 0.12503805884002706, 0.12542020583115043, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005623398954567316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008540438079190027, 9.999999999998899e-05, 0.07985892311264775, 0.06358529391157774, 0.07544969986161176, 0.03631275179977822, 0.056583269820254856, 0.04536721724216364, 0.05164470279185096, 0.06717069486254346, 0.07049420038673637, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05635860814138427, 0.06609883468256372, 0.06618012720976862, 0.05828545483650138, 0.0808994998328777, 0.07088594367372192, 0.06094404599025616, 0.05828485269229711, 0.057315864668663785, 0.32078272201591085, 0.3410407784397186, 0.33915174313468743, 0.3462418600580448, 0.35362188133437833, 0.36265287423732384, 0.3335568316870223, 0.3513657215521184, 0.32956588571603374, 0.09066968818562016, 0.0794677426750191, 0.08144406390726366, 0.07829125942420068, 0.08491746296511704, 0.07614511683811709, 0.08261779022571714, 0.08498522964428934, 0.08253676850435365, 0.16026599580398904, 0.1554130581352685, 0.1307595381144554, 0.13423854354385711, 0.12685023619794156, 0.15542625971568214, 0.1408362618989184, 0.1295165855433732, 0.12070878929319118, 0.24189091196026624, 0.22830774333201675, 0.23168736532579925, 0.245233153986958, 0.23413281664311636, 0.22466599457378977, 0.2448433602016893, 0.24677433731648424, 0.24930452429082217, 0.17244401213003935, 0.17114780191310297, 0.20296739841335498, 0.17635996694599687, 0.16522932004414237, 0.16245015237382554, 0.19758053422606858, 0.19048199420664336, 0.17501816518584257, 0.1804172907623468, 0.18946595302589586, 0.18852765093835555, 0.1779166464452635, 0.18083942606458936, 0.16405621724444586, 0.1656307367208263, 0.17437109709277088, 0.17603830871502235, 0.17635215717859032, 0.17779154756167914, 0.1633838747797941, 0.1644417933274026, 0.16819417237116852, 0.16200230383858738, 0.17349662418102485, 0.1662210165924124, 0.16958158763765974, 0.31848211493598366, 0.15012808933458888, 0.229330993381324, 0.2703486929138933, 0.20326648933681746, 0.17078000966439855, 0.21557230252047543, 0.15229774343622537, 0.30163750358416086, 0.23441418909635148, 0.18358381479558117, 0.39603963177042045, 0.27605318226694464, 0.18273658272132265, 0.25809163812590075, 0.19957093130493464, 0.25058168225837685, 0.17086490994846204, 0.16827732232053827, 0.18301789138459856, 0.19241345704915958, 0.16703695036145472, 0.18294550967283107, 0.17852071998883223, 0.18560034744499165, 0.1750948987814025, 0.17756489183958934, 0.05957423593507705, 0.06422878090016582, 0.07028152382166897, 0.06872108710528113, 0.06631475771263262, 0.07345155458415664, 0.07064423436870715, 0.06286090510205689, 0.06366721378442053]}, "mutation_prompt": null}
{"id": "0fb8b2ea-a2f7-4ded-b542-0f5277dfe0ef", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 10)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_superposition(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.quantum_superposition(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDifferentialEvolution", "description": "Quantum-Inspired Adaptive Differential Evolution with Elite Preservation combines dynamic parameter tuning, quantum superposition, and elite preservation to enhance robustness and convergence.", "configspace": "", "generation": 15, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "ca655e00-e318-42ef-9e3a-e9fb41292c20", "metadata": {"aucs": [0.3730770170504416, 0.3618928502596258, 0.38065308393509123, 0.3821341589384779, 0.38286472449347253, 0.39302566471562994, 0.38517534227270667, 0.3727602090740333, 0.36555073704253005, 0.0024252982230261733, 0.007809886241437969, 0.0002694103830541694, 0.003514235104049801, 0.003781145602659075, 0.015369989668008732, 0.03718947436555209, 0.01498109237347367, 0.009961953562935721, 0.08439100355935303, 0.08804055950512779, 0.07803930253495017, 0.1003298517022504, 0.07638915526284074, 0.08230922237619287, 0.0902076934781626, 0.08625351777176615, 0.10291027147359999, 0.06975656096943295, 0.07891994342210473, 0.07854758390011973, 0.07463723475924366, 0.07069073679794002, 0.07430734814839557, 0.07788456859745152, 0.08605798193485947, 0.08142483321552918, 0.8258432161567696, 0.9163260668055434, 0.9002126239255844, 0.8540631739791784, 0.8827395269762277, 0.8698371998556185, 0.8914924432380432, 0.8964683615927281, 0.7836271604290194, 0.19883778788948714, 0.1916714705779038, 0.19847278565049142, 0.18205624288471467, 0.17704276292835253, 0.17896495778416088, 0.2185215061021396, 0.18026138852513396, 0.1891890011868439, 0.25236756097519697, 0.22489614354653564, 0.22626251301891398, 0.2249506181363985, 0.2502827630648812, 0.2241869583033862, 0.23866271188338983, 0.24255932964702276, 0.23854338944520836, 0.11251568643233545, 0.11518351398987392, 0.10973482519015454, 0.12535482704797718, 0.12130008791988856, 0.11189907892813422, 0.12575935021226337, 0.12267587463663054, 0.11981052495790778, 0.11025011258496509, 0.08565908783490972, 0.11850935835216936, 0.12452540574733684, 0.10342095626179848, 0.1085498718841984, 0.12350378333273948, 0.12503805884002706, 0.12542020583115043, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0005623398954567316, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008540438079190027, 9.999999999998899e-05, 0.07985892311264775, 0.06358529391157774, 0.07544969986161176, 0.03631275179977822, 0.056583269820254856, 0.04536721724216364, 0.05164470279185096, 0.06717069486254346, 0.07049420038673637, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05635860814138427, 0.06609883468256372, 0.06618012720976862, 0.05828545483650138, 0.0808994998328777, 0.07088594367372192, 0.06094404599025616, 0.05828485269229711, 0.057315864668663785, 0.32078272201591085, 0.3410407784397186, 0.33915174313468743, 0.3462418600580448, 0.35362188133437833, 0.36265287423732384, 0.3335568316870223, 0.3513657215521184, 0.32956588571603374, 0.09066968818562016, 0.0794677426750191, 0.08144406390726366, 0.07829125942420068, 0.08491746296511704, 0.07614511683811709, 0.08261779022571714, 0.08498522964428934, 0.08253676850435365, 0.16026599580398904, 0.1554130581352685, 0.1307595381144554, 0.13423854354385711, 0.12685023619794156, 0.15542625971568214, 0.1408362618989184, 0.1295165855433732, 0.12070878929319118, 0.24189091196026624, 0.22830774333201675, 0.23168736532579925, 0.245233153986958, 0.23413281664311636, 0.22466599457378977, 0.2448433602016893, 0.24677433731648424, 0.24930452429082217, 0.17244401213003935, 0.17114780191310297, 0.20296739841335498, 0.17635996694599687, 0.16522932004414237, 0.16245015237382554, 0.19758053422606858, 0.19048199420664336, 0.17501816518584257, 0.1804172907623468, 0.18946595302589586, 0.18852765093835555, 0.1779166464452635, 0.18083942606458936, 0.16405621724444586, 0.1656307367208263, 0.17437109709277088, 0.17603830871502235, 0.17635215717859032, 0.17779154756167914, 0.1633838747797941, 0.1644417933274026, 0.16819417237116852, 0.16200230383858738, 0.17349662418102485, 0.1662210165924124, 0.16958158763765974, 0.31848211493598366, 0.15012808933458888, 0.229330993381324, 0.2703486929138933, 0.20326648933681746, 0.17078000966439855, 0.21557230252047543, 0.15229774343622537, 0.30163750358416086, 0.23441418909635148, 0.18358381479558117, 0.39603963177042045, 0.27605318226694464, 0.18273658272132265, 0.25809163812590075, 0.19957093130493464, 0.25058168225837685, 0.17086490994846204, 0.16827732232053827, 0.18301789138459856, 0.19241345704915958, 0.16703695036145472, 0.18294550967283107, 0.17852071998883223, 0.18560034744499165, 0.1750948987814025, 0.17756489183958934, 0.05957423593507705, 0.06422878090016582, 0.07028152382166897, 0.06872108710528113, 0.06631475771263262, 0.07345155458415664, 0.07064423436870715, 0.06286090510205689, 0.06366721378442053]}, "mutation_prompt": null}
{"id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithStochasticPhaseAdjustment:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Adjusted min differential weight\n        self.f_max = 0.8  # Max differential weight\n        self.cr_min = 0.5  # Adjusted min crossover probability\n        self.cr_max = 0.9  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 12)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 15\n        return sol + np.sin(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithStochasticPhaseAdjustment", "description": "Quantum-Inspired Differential Evolution with Stochastic Phase Adjustment leverages quantum principles and stochastic phase shifts to enhance exploration and convergence efficiency.", "configspace": "", "generation": 17, "fitness": 0.17786608977068535, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionWithStochasticPhaseAdjustment got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.18.", "error": "", "parent_id": "ca655e00-e318-42ef-9e3a-e9fb41292c20", "metadata": {"aucs": [0.38515300171629197, 0.3946330122330344, 0.4188626102158075, 0.398100825101119, 0.38758644456160807, 0.39937064354240104, 0.4041405692131137, 0.4000500883590592, 0.3874850530283246, 0.03517558386000952, 0.027990946696763053, 0.01259646788141311, 0.027471254280672652, 0.016177751646101024, 0.032517158041993066, 0.01002104149935601, 0.0360214930865963, 0.034244087437498405, 0.10171503965787831, 0.08717095575839007, 0.09852788355669906, 0.102152867690401, 0.10274003907791263, 0.09186162816945886, 0.08969239945296126, 0.08045246887585178, 0.08464515863038324, 0.07056358166712984, 0.07781052228728036, 0.0778143505694654, 0.08188877748527101, 0.07887799849247568, 0.07168116219631315, 0.09001244805624897, 0.08384314407503535, 0.0743519886714199, 0.8591347275872512, 0.8866745438701547, 0.9458576220857398, 0.8463101994039979, 0.886001599123001, 0.9164391027545294, 0.8453081497669196, 0.82626441798862, 0.8492414089224587, 0.21371524249154206, 0.1952672790637081, 0.1992868940239647, 0.19949671670844404, 0.19019404937554774, 0.19917548930577256, 0.2127635084807299, 0.18413590161460858, 0.19197005279904134, 0.2349429487115059, 0.20534738991078727, 0.2079088994067081, 0.24215970081828053, 0.23620394871224648, 0.23572117154355976, 0.23121848754184382, 0.21195785065698658, 0.20929994623327963, 0.10798141402316674, 0.13144454593393184, 0.12778697470121747, 0.1326162718585756, 0.11429301395316305, 0.09790487983820773, 0.12060068358553655, 0.11314754576707475, 0.13047747538566323, 0.1096593558624136, 0.09081403302933921, 0.10905945349253776, 0.10793419607099164, 0.11286701825728851, 0.12101233871107364, 0.1230663027842207, 0.11303724470485976, 0.1311941355595212, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003723343045896943, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08351748209877785, 0.06136117736466751, 0.07119485989555796, 0.06006427131365111, 0.06384526492265763, 0.05042357462076674, 0.07135339300217769, 0.06391068191842564, 0.05730189071201586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06370725272318234, 0.05386004429832192, 0.06883650279521136, 0.06385392107937893, 0.07144131968095879, 0.07265144244712296, 0.06686594821409031, 0.05046784950705463, 0.06617778048936485, 0.3414979049089413, 0.34367719648396544, 0.348322639708067, 0.3572999215212037, 0.34299757513311424, 0.34622414565299553, 0.3523946864587024, 0.3372712957208174, 0.36867461679995317, 0.07584724041455015, 0.07334730703864112, 0.0865816407983564, 0.08834569892520627, 0.07606377602389491, 0.09460986383412529, 0.07182359024654639, 0.06949660247113065, 0.0925210194237388, 0.13638018262996554, 0.11851152839792956, 0.12268109771355107, 0.11923267921708358, 0.1395262536038464, 0.11493082560372947, 0.16404357471919806, 0.11938467709967804, 0.1467212092844935, 0.24362081466635943, 0.2344144324776153, 0.24552415020316942, 0.24178566784743294, 0.2424805914068272, 0.22123343457852973, 0.2427815136090582, 0.25181155730714033, 0.2407583428023783, 0.1740292781595434, 0.1581646902049828, 0.17656902520006712, 0.14157726977723983, 0.15989044919975626, 0.17032312413023465, 0.17018020090958363, 0.18803381894899285, 0.16862400184247617, 0.2018421912019981, 0.1749402727424062, 0.19074341616889912, 0.18102661870237202, 0.18337599856467157, 0.17243594735750178, 0.17764755591584291, 0.16480588049376843, 0.1770066478233563, 0.17615137371095568, 0.17433882775391463, 0.17709225352192948, 0.1776963823971358, 0.16505583536290558, 0.18316522708976668, 0.17627914836295544, 0.17601385476898634, 0.1739852045612874, 0.26249521646266005, 0.15038350634169328, 0.16084743465606355, 0.28172167179851826, 0.17131376310679536, 0.3383649881427203, 0.13326191081359884, 0.25296896761746746, 0.1489389646481839, 0.16297854349089935, 0.18680253817444403, 0.18170231112752389, 0.30766198523268806, 0.2777242638241403, 0.14278558793666618, 0.24475997809327732, 0.21921091430801942, 0.30691886154788073, 0.1826364612160014, 0.1739614670548002, 0.16855239916722398, 0.17833587411643526, 0.20856679658960253, 0.22241260163938137, 0.1765995160815913, 0.18576120733092172, 0.18243701224349496, 0.0653226892731793, 0.06804187775012893, 0.068598976195819, 0.07131802897725992, 0.06861288190381254, 0.06305231509653053, 0.07214012227234012, 0.06573831371688643, 0.0657791135928879]}, "mutation_prompt": null}
{"id": "757e85c9-5fc9-4284-a2e8-42a66bea3bd5", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithStochasticPhaseAdjustment:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Adjusted min differential weight\n        self.f_max = 0.8  # Max differential weight\n        self.cr_min = 0.5  # Adjusted min crossover probability\n        self.cr_max = 0.9  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 12)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 15\n        return sol + np.sin(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithStochasticPhaseAdjustment", "description": "Quantum-Inspired Differential Evolution with Stochastic Phase Adjustment leverages quantum principles and stochastic phase shifts to enhance exploration and convergence efficiency.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "metadata": {"aucs": [0.38515300171629197, 0.3946330122330344, 0.4188626102158075, 0.398100825101119, 0.38758644456160807, 0.39937064354240104, 0.4041405692131137, 0.4000500883590592, 0.3874850530283246, 0.03517558386000952, 0.027990946696763053, 0.01259646788141311, 0.027471254280672652, 0.016177751646101024, 0.032517158041993066, 0.01002104149935601, 0.0360214930865963, 0.034244087437498405, 0.10171503965787831, 0.08717095575839007, 0.09852788355669906, 0.102152867690401, 0.10274003907791263, 0.09186162816945886, 0.08969239945296126, 0.08045246887585178, 0.08464515863038324, 0.07056358166712984, 0.07781052228728036, 0.0778143505694654, 0.08188877748527101, 0.07887799849247568, 0.07168116219631315, 0.09001244805624897, 0.08384314407503535, 0.0743519886714199, 0.8591347275872512, 0.8866745438701547, 0.9458576220857398, 0.8463101994039979, 0.886001599123001, 0.9164391027545294, 0.8453081497669196, 0.82626441798862, 0.8492414089224587, 0.21371524249154206, 0.1952672790637081, 0.1992868940239647, 0.19949671670844404, 0.19019404937554774, 0.19917548930577256, 0.2127635084807299, 0.18413590161460858, 0.19197005279904134, 0.2349429487115059, 0.20534738991078727, 0.2079088994067081, 0.24215970081828053, 0.23620394871224648, 0.23572117154355976, 0.23121848754184382, 0.21195785065698658, 0.20929994623327963, 0.10798141402316674, 0.13144454593393184, 0.12778697470121747, 0.1326162718585756, 0.11429301395316305, 0.09790487983820773, 0.12060068358553655, 0.11314754576707475, 0.13047747538566323, 0.1096593558624136, 0.09081403302933921, 0.10905945349253776, 0.10793419607099164, 0.11286701825728851, 0.12101233871107364, 0.1230663027842207, 0.11303724470485976, 0.1311941355595212, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003723343045896943, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08351748209877785, 0.06136117736466751, 0.07119485989555796, 0.06006427131365111, 0.06384526492265763, 0.05042357462076674, 0.07135339300217769, 0.06391068191842564, 0.05730189071201586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06370725272318234, 0.05386004429832192, 0.06883650279521136, 0.06385392107937893, 0.07144131968095879, 0.07265144244712296, 0.06686594821409031, 0.05046784950705463, 0.06617778048936485, 0.3414979049089413, 0.34367719648396544, 0.348322639708067, 0.3572999215212037, 0.34299757513311424, 0.34622414565299553, 0.3523946864587024, 0.3372712957208174, 0.36867461679995317, 0.07584724041455015, 0.07334730703864112, 0.0865816407983564, 0.08834569892520627, 0.07606377602389491, 0.09460986383412529, 0.07182359024654639, 0.06949660247113065, 0.0925210194237388, 0.13638018262996554, 0.11851152839792956, 0.12268109771355107, 0.11923267921708358, 0.1395262536038464, 0.11493082560372947, 0.16404357471919806, 0.11938467709967804, 0.1467212092844935, 0.24362081466635943, 0.2344144324776153, 0.24552415020316942, 0.24178566784743294, 0.2424805914068272, 0.22123343457852973, 0.2427815136090582, 0.25181155730714033, 0.2407583428023783, 0.1740292781595434, 0.1581646902049828, 0.17656902520006712, 0.14157726977723983, 0.15989044919975626, 0.17032312413023465, 0.17018020090958363, 0.18803381894899285, 0.16862400184247617, 0.2018421912019981, 0.1749402727424062, 0.19074341616889912, 0.18102661870237202, 0.18337599856467157, 0.17243594735750178, 0.17764755591584291, 0.16480588049376843, 0.1770066478233563, 0.17615137371095568, 0.17433882775391463, 0.17709225352192948, 0.1776963823971358, 0.16505583536290558, 0.18316522708976668, 0.17627914836295544, 0.17601385476898634, 0.1739852045612874, 0.26249521646266005, 0.15038350634169328, 0.16084743465606355, 0.28172167179851826, 0.17131376310679536, 0.3383649881427203, 0.13326191081359884, 0.25296896761746746, 0.1489389646481839, 0.16297854349089935, 0.18680253817444403, 0.18170231112752389, 0.30766198523268806, 0.2777242638241403, 0.14278558793666618, 0.24475997809327732, 0.21921091430801942, 0.30691886154788073, 0.1826364612160014, 0.1739614670548002, 0.16855239916722398, 0.17833587411643526, 0.20856679658960253, 0.22241260163938137, 0.1765995160815913, 0.18576120733092172, 0.18243701224349496, 0.0653226892731793, 0.06804187775012893, 0.068598976195819, 0.07131802897725992, 0.06861288190381254, 0.06305231509653053, 0.07214012227234012, 0.06573831371688643, 0.0657791135928879]}, "mutation_prompt": null}
{"id": "5f03db38-ce26-45cd-8f78-696f2024c45a", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithStochasticPhaseAdjustment:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Adjusted min differential weight\n        self.f_max = 0.8  # Max differential weight\n        self.cr_min = 0.5  # Adjusted min crossover probability\n        self.cr_max = 0.9  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 12)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 15\n        return sol + np.sin(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithStochasticPhaseAdjustment", "description": "Quantum-Inspired Differential Evolution with Stochastic Phase Adjustment leverages quantum principles and stochastic phase shifts to enhance exploration and convergence efficiency.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "metadata": {"aucs": [0.38515300171629197, 0.3946330122330344, 0.4188626102158075, 0.398100825101119, 0.38758644456160807, 0.39937064354240104, 0.4041405692131137, 0.4000500883590592, 0.3874850530283246, 0.03517558386000952, 0.027990946696763053, 0.01259646788141311, 0.027471254280672652, 0.016177751646101024, 0.032517158041993066, 0.01002104149935601, 0.0360214930865963, 0.034244087437498405, 0.10171503965787831, 0.08717095575839007, 0.09852788355669906, 0.102152867690401, 0.10274003907791263, 0.09186162816945886, 0.08969239945296126, 0.08045246887585178, 0.08464515863038324, 0.07056358166712984, 0.07781052228728036, 0.0778143505694654, 0.08188877748527101, 0.07887799849247568, 0.07168116219631315, 0.09001244805624897, 0.08384314407503535, 0.0743519886714199, 0.8591347275872512, 0.8866745438701547, 0.9458576220857398, 0.8463101994039979, 0.886001599123001, 0.9164391027545294, 0.8453081497669196, 0.82626441798862, 0.8492414089224587, 0.21371524249154206, 0.1952672790637081, 0.1992868940239647, 0.19949671670844404, 0.19019404937554774, 0.19917548930577256, 0.2127635084807299, 0.18413590161460858, 0.19197005279904134, 0.2349429487115059, 0.20534738991078727, 0.2079088994067081, 0.24215970081828053, 0.23620394871224648, 0.23572117154355976, 0.23121848754184382, 0.21195785065698658, 0.20929994623327963, 0.10798141402316674, 0.13144454593393184, 0.12778697470121747, 0.1326162718585756, 0.11429301395316305, 0.09790487983820773, 0.12060068358553655, 0.11314754576707475, 0.13047747538566323, 0.1096593558624136, 0.09081403302933921, 0.10905945349253776, 0.10793419607099164, 0.11286701825728851, 0.12101233871107364, 0.1230663027842207, 0.11303724470485976, 0.1311941355595212, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003723343045896943, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08351748209877785, 0.06136117736466751, 0.07119485989555796, 0.06006427131365111, 0.06384526492265763, 0.05042357462076674, 0.07135339300217769, 0.06391068191842564, 0.05730189071201586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06370725272318234, 0.05386004429832192, 0.06883650279521136, 0.06385392107937893, 0.07144131968095879, 0.07265144244712296, 0.06686594821409031, 0.05046784950705463, 0.06617778048936485, 0.3414979049089413, 0.34367719648396544, 0.348322639708067, 0.3572999215212037, 0.34299757513311424, 0.34622414565299553, 0.3523946864587024, 0.3372712957208174, 0.36867461679995317, 0.07584724041455015, 0.07334730703864112, 0.0865816407983564, 0.08834569892520627, 0.07606377602389491, 0.09460986383412529, 0.07182359024654639, 0.06949660247113065, 0.0925210194237388, 0.13638018262996554, 0.11851152839792956, 0.12268109771355107, 0.11923267921708358, 0.1395262536038464, 0.11493082560372947, 0.16404357471919806, 0.11938467709967804, 0.1467212092844935, 0.24362081466635943, 0.2344144324776153, 0.24552415020316942, 0.24178566784743294, 0.2424805914068272, 0.22123343457852973, 0.2427815136090582, 0.25181155730714033, 0.2407583428023783, 0.1740292781595434, 0.1581646902049828, 0.17656902520006712, 0.14157726977723983, 0.15989044919975626, 0.17032312413023465, 0.17018020090958363, 0.18803381894899285, 0.16862400184247617, 0.2018421912019981, 0.1749402727424062, 0.19074341616889912, 0.18102661870237202, 0.18337599856467157, 0.17243594735750178, 0.17764755591584291, 0.16480588049376843, 0.1770066478233563, 0.17615137371095568, 0.17433882775391463, 0.17709225352192948, 0.1776963823971358, 0.16505583536290558, 0.18316522708976668, 0.17627914836295544, 0.17601385476898634, 0.1739852045612874, 0.26249521646266005, 0.15038350634169328, 0.16084743465606355, 0.28172167179851826, 0.17131376310679536, 0.3383649881427203, 0.13326191081359884, 0.25296896761746746, 0.1489389646481839, 0.16297854349089935, 0.18680253817444403, 0.18170231112752389, 0.30766198523268806, 0.2777242638241403, 0.14278558793666618, 0.24475997809327732, 0.21921091430801942, 0.30691886154788073, 0.1826364612160014, 0.1739614670548002, 0.16855239916722398, 0.17833587411643526, 0.20856679658960253, 0.22241260163938137, 0.1765995160815913, 0.18576120733092172, 0.18243701224349496, 0.0653226892731793, 0.06804187775012893, 0.068598976195819, 0.07131802897725992, 0.06861288190381254, 0.06305231509653053, 0.07214012227234012, 0.06573831371688643, 0.0657791135928879]}, "mutation_prompt": null}
{"id": "58cd5067-9523-43f0-aaa7-d05dc83840c1", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim  # Increased population size for better diversity\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.6  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 10)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 20  # Adjusted perturbation scale\n        return sol + np.sin(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumEnhancedAdaptiveDifferentialEvolution", "description": "Quantum-Enhanced Adaptive Differential Evolution integrates quantum-inspired adaptive strategies to dynamically adjust differential weights and crossover rates, improving search space exploration and convergence.", "configspace": "", "generation": 20, "fitness": 0.17654164794780217, "feedback": "The algorithm QuantumEnhancedAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.17.", "error": "", "parent_id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "metadata": {"aucs": [0.38693418824856973, 0.35502057137029164, 0.37877617889802073, 0.3745829770670728, 0.38410052820149976, 0.3944183398362131, 0.4116500302605912, 0.37880808489907725, 0.4011288391922835, 0.04882057314986887, 0.02740060439248848, 0.03568374473345792, 0.017002921321772058, 0.040538773570398035, 0.025527825412450134, 0.017044996385791822, 0.023551981857622195, 0.01611319815486445, 0.09208508749821798, 0.09638226050296672, 0.07993496888473617, 0.0806073556493404, 0.08597302995202283, 0.09723576940131784, 0.07749703671785724, 0.09119445352040079, 0.08758937178596793, 0.08667424799212753, 0.08297157431465352, 0.08507823341281961, 0.08235966999556676, 0.07628436795303717, 0.07902625254153539, 0.07690555656081866, 0.0783824718614956, 0.07722387284579546, 0.8267885193628639, 0.8727312754581121, 0.8504917405611709, 0.8219420583893375, 0.8302803409050266, 0.8594195930393883, 0.8804388352120824, 0.7805126913732523, 0.7846004267024169, 0.1812197528679994, 0.17721961872117697, 0.18540403034966535, 0.1760263019948881, 0.18015568047722186, 0.18125413148818492, 0.19350733509201967, 0.17506906579272197, 0.17530913662183334, 0.24421430625666385, 0.23019047865948628, 0.22747870178332807, 0.20833143301666712, 0.2607276003083592, 0.2223356530364755, 0.23231378637480482, 0.26241515473696886, 0.23841856167838127, 0.12902712883237566, 0.10793525694876949, 0.11042459654288739, 0.14781360838708224, 0.12906182428874058, 0.11418580127883393, 0.11689499118803381, 0.10986626312690173, 0.117869842294403, 0.10662783947677545, 0.11294381876977932, 0.10686894073217679, 0.12604481456652905, 0.11910167364506563, 0.11973113590496376, 0.12390763047199815, 0.1130407725833491, 0.10451865132401361, 0.00322430868175394, 0.001980429909190784, 0.006338718282459244, 0.006539279516651897, 0.0010047759767765063, 0.002510524013588422, 9.999999999998899e-05, 0.0125453612079095, 9.999999999998899e-05, 0.10443198638076867, 0.06378157786802907, 0.05368606056046066, 0.06908349005747627, 0.10473070320522371, 0.05546387838755762, 0.11134533242806988, 0.09190099312681888, 0.08157686274082665, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07073558397430568, 0.06513376673008575, 0.06068453379467975, 0.07234033255826322, 0.0753017427738889, 0.07734386251858938, 0.0750757295812704, 0.07735370437355704, 0.08397147934987659, 0.3383168761548302, 0.3674367733649231, 0.3492204014581395, 0.37149664318442155, 0.351251150941546, 0.3577889147379114, 0.34366290225524443, 0.3385990168861538, 0.3684979027287383, 0.09230252375221004, 0.07488355729895024, 0.08990991002646243, 0.07657679729323885, 0.0730945778628691, 0.08000714227105599, 0.07269402626915966, 0.07679143905236674, 0.08865030428306275, 0.12875907505426876, 0.17590508037979924, 0.1384125024681141, 0.14548434352368844, 0.1461298832157596, 0.12196218562729333, 0.16446033805287985, 0.12434806322367153, 0.17775801807927805, 0.23956462202263606, 0.22728861260720434, 0.2540824510672245, 0.2275410442049528, 0.23590200490394386, 0.23954184582150329, 0.24175175487008593, 0.24334977607520136, 0.26033479861649744, 0.17369942112592418, 0.1615816650694284, 0.1657160997676338, 0.17351168773286174, 0.16198963185808712, 0.15628165780542713, 0.18868704439099182, 0.16676226097139824, 0.18021306093243528, 0.16664596456592318, 0.17052217346753984, 0.19003393242441835, 0.1635337290593032, 0.1817113126333999, 0.1816201588375178, 0.18695140254722886, 0.2045577542060747, 0.18023022103545738, 0.17342433110582312, 0.18063330703163283, 0.17982678803948549, 0.17064508006064716, 0.1824639638626917, 0.1707408648523442, 0.17339357885981133, 0.1709544654348123, 0.16812665641996205, 0.16066995626958358, 0.15922592455762474, 0.38198367827743374, 0.15001958586031838, 0.20800027759690798, 0.2839093529102563, 0.16481214214769968, 0.16088822947150472, 0.2876308563677551, 0.1664295404425984, 0.26042610137221733, 0.1591175364403089, 0.20473348271366232, 0.1809652382181267, 0.22750836964829269, 0.19565920270222936, 0.20238098755657374, 0.19517680276963745, 0.17107301377202477, 0.18330301063050558, 0.16907853458100996, 0.19663317777649758, 0.18691380272470626, 0.17977662768256253, 0.1803150401418845, 0.1759149619294461, 0.1822842507982465, 0.0629954821885631, 0.062206134925477996, 0.06681605749092212, 0.0732480614648432, 0.07792693214986102, 0.06667517832213488, 0.05902654253838213, 0.06494904660227752, 0.06175160498537824]}, "mutation_prompt": null}
{"id": "f32c2002-4e67-4067-a604-39781e38aa24", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithAdaptiveQuantumWalk:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.6  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.4  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 12)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def adaptive_quantum_walk(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = np.random.uniform(0, 1) * ((self.upper_bound - self.lower_bound) / 20) * np.sin(theta)\n        return sol + perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.adaptive_quantum_walk(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithAdaptiveQuantumWalk", "description": "Quantum-Inspired Differential Evolution with Adaptive Quantum Walk leverages quantum principles and adaptive perturbations to boost exploration and convergence efficiency.", "configspace": "", "generation": 21, "fitness": 0.16732543194279081, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionWithAdaptiveQuantumWalk got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.18.", "error": "", "parent_id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "metadata": {"aucs": [0.37354057711012023, 0.36166731207141933, 0.34609276424708624, 0.3641155190058607, 0.34341599186775806, 0.3824211373294045, 0.36094583499657884, 0.36682313627493646, 0.3744269137653038, 0.0013312884422334026, 0.02277427417613831, 0.006060870504095095, 0.012678869770886392, 0.02162699526039269, 0.007355002278661815, 0.020450820231073474, 0.010350373142987701, 0.008438605254921683, 0.08283236605209843, 0.07924655712981954, 0.09801205086347886, 0.07856579233819883, 0.07666540692653712, 0.09329097629422778, 0.09213911276139097, 0.07912356665660847, 0.08694221595631735, 0.07013362775073873, 0.069471525381545, 0.0710606298797708, 0.09320525674433944, 0.08467326509556461, 0.07953012991085451, 0.07642073455443221, 0.06179547355921566, 0.0650115876898677, 0.8609859914406808, 0.8695678637301114, 0.8941253550621225, 0.9247612192290828, 0.8466759906618802, 0.9142689816464393, 0.8962773669690559, 0.874235401158532, 0.9208641990652435, 0.1532535787942828, 0.17491490329793236, 0.15998783663510552, 0.17798511655688998, 0.1591122578879529, 0.17371959202893594, 0.16951804328521503, 0.16719080072340953, 0.16246842325432986, 0.20463938778486068, 0.1956117231236696, 0.2266381334407982, 0.20707384672558915, 0.20532795710463592, 0.1958337250678579, 0.20508867529729846, 0.19941163644636262, 0.22283010851775575, 0.10484870373966004, 0.10324641992230099, 0.07559224723262759, 0.10822750058726482, 0.11128216224563026, 0.09926196731193015, 0.12526140799559105, 0.10440371297425222, 0.10226648510170033, 0.09288907298676308, 0.06440188108840461, 0.04595259519021133, 0.10319962697258311, 0.0985649833740685, 0.10002487204943467, 0.09979268640363514, 0.09276606683538269, 0.08485168981604108, 0.0006775626257385925, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06951356794550123, 0.03519208410054053, 0.06316014053563612, 0.03800921063294305, 0.02478783976870269, 0.08093644433855318, 0.05202320487632062, 0.05936941605576762, 0.052362105850251695, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.055621356295167956, 0.03949598121054054, 0.08089679404979067, 0.055540475164238656, 0.050501681328409154, 0.05494634285766953, 0.053464485626008695, 0.04633998574057385, 0.0528087526078973, 0.3336671823623151, 0.3133342419703301, 0.33647849690646525, 0.3331246700480003, 0.32406183300253955, 0.3270864565452418, 0.33224920304488625, 0.32058342585781807, 0.33829633651467617, 0.07720940477930671, 0.08103162602389347, 0.07998203304781637, 0.0782409557315783, 0.07634196288816497, 0.08546733942163043, 0.06947134693639456, 0.08140707048777351, 0.08195484271717945, 0.11931824935424551, 0.13184068456641795, 0.13981645706133639, 0.12920572715430845, 0.1177491438033097, 0.15499149373484122, 0.11975068014141743, 0.13165551386584562, 0.12589226089876615, 0.22422254393247176, 0.22212459832308418, 0.21401844681833837, 0.2135313970597883, 0.1853823183935207, 0.2140011474273339, 0.23851553161504202, 0.23399018468617883, 0.2331509941991915, 0.16213245850775349, 0.16946873044287736, 0.1627252140347275, 0.1554740728687951, 0.12894424726297893, 0.15949501665575494, 0.15470242694912162, 0.16376243109102018, 0.1694758200806884, 0.17752573321612886, 0.17404551717807148, 0.15692881960055927, 0.1727099740006004, 0.1793047842218155, 0.16896563386071428, 0.1906536980477891, 0.17263335725832207, 0.17550661953376023, 0.17953379018970794, 0.1738007055635049, 0.17793200021772937, 0.1749077400239576, 0.17371815426033643, 0.1681968239441689, 0.16923238066150548, 0.16738265498853766, 0.17521810377261648, 0.23062125385642906, 0.18326339991192275, 0.26405126248514743, 0.15605658690606927, 0.15919314329237388, 0.23374369183110233, 0.17783002736220332, 0.13995133869383136, 0.2016317410297701, 0.23523634868867105, 0.20099424385649123, 0.20974547383730258, 0.15790496150839517, 0.158628717599391, 0.19151520589567794, 0.18923325794363177, 0.2482747148492852, 0.28033909180946714, 0.19547282916158149, 0.18159741052445233, 0.18309038285221013, 0.18581457139388735, 0.19478334305699563, 0.17992380701945754, 0.17873914191775642, 0.1995821909857176, 0.1862161760094022, 0.06382691038244936, 0.0685344370999732, 0.06713894716740909, 0.07133534382317996, 0.05863238751501265, 0.07165442515247356, 0.0657223556359593, 0.06843149957991013, 0.060873779604208034]}, "mutation_prompt": null}
{"id": "429ddcda-5c9a-414f-84b0-0c7f08c05852", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithStochasticPhaseAdjustment:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Adjusted min differential weight\n        self.f_max = 0.8  # Max differential weight\n        self.cr_min = 0.5  # Adjusted min crossover probability\n        self.cr_max = 0.9  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 12)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 15\n        return sol + np.sin(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithStochasticPhaseAdjustment", "description": "Quantum-Inspired Differential Evolution with Stochastic Phase Adjustment leverages quantum principles and stochastic phase shifts to enhance exploration and convergence efficiency.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "metadata": {"aucs": [0.38515300171629197, 0.3946330122330344, 0.4188626102158075, 0.398100825101119, 0.38758644456160807, 0.39937064354240104, 0.4041405692131137, 0.4000500883590592, 0.3874850530283246, 0.03517558386000952, 0.027990946696763053, 0.01259646788141311, 0.027471254280672652, 0.016177751646101024, 0.032517158041993066, 0.01002104149935601, 0.0360214930865963, 0.034244087437498405, 0.10171503965787831, 0.08717095575839007, 0.09852788355669906, 0.102152867690401, 0.10274003907791263, 0.09186162816945886, 0.08969239945296126, 0.08045246887585178, 0.08464515863038324, 0.07056358166712984, 0.07781052228728036, 0.0778143505694654, 0.08188877748527101, 0.07887799849247568, 0.07168116219631315, 0.09001244805624897, 0.08384314407503535, 0.0743519886714199, 0.8591347275872512, 0.8866745438701547, 0.9458576220857398, 0.8463101994039979, 0.886001599123001, 0.9164391027545294, 0.8453081497669196, 0.82626441798862, 0.8492414089224587, 0.21371524249154206, 0.1952672790637081, 0.1992868940239647, 0.19949671670844404, 0.19019404937554774, 0.19917548930577256, 0.2127635084807299, 0.18413590161460858, 0.19197005279904134, 0.2349429487115059, 0.20534738991078727, 0.2079088994067081, 0.24215970081828053, 0.23620394871224648, 0.23572117154355976, 0.23121848754184382, 0.21195785065698658, 0.20929994623327963, 0.10798141402316674, 0.13144454593393184, 0.12778697470121747, 0.1326162718585756, 0.11429301395316305, 0.09790487983820773, 0.12060068358553655, 0.11314754576707475, 0.13047747538566323, 0.1096593558624136, 0.09081403302933921, 0.10905945349253776, 0.10793419607099164, 0.11286701825728851, 0.12101233871107364, 0.1230663027842207, 0.11303724470485976, 0.1311941355595212, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.003723343045896943, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08351748209877785, 0.06136117736466751, 0.07119485989555796, 0.06006427131365111, 0.06384526492265763, 0.05042357462076674, 0.07135339300217769, 0.06391068191842564, 0.05730189071201586, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06370725272318234, 0.05386004429832192, 0.06883650279521136, 0.06385392107937893, 0.07144131968095879, 0.07265144244712296, 0.06686594821409031, 0.05046784950705463, 0.06617778048936485, 0.3414979049089413, 0.34367719648396544, 0.348322639708067, 0.3572999215212037, 0.34299757513311424, 0.34622414565299553, 0.3523946864587024, 0.3372712957208174, 0.36867461679995317, 0.07584724041455015, 0.07334730703864112, 0.0865816407983564, 0.08834569892520627, 0.07606377602389491, 0.09460986383412529, 0.07182359024654639, 0.06949660247113065, 0.0925210194237388, 0.13638018262996554, 0.11851152839792956, 0.12268109771355107, 0.11923267921708358, 0.1395262536038464, 0.11493082560372947, 0.16404357471919806, 0.11938467709967804, 0.1467212092844935, 0.24362081466635943, 0.2344144324776153, 0.24552415020316942, 0.24178566784743294, 0.2424805914068272, 0.22123343457852973, 0.2427815136090582, 0.25181155730714033, 0.2407583428023783, 0.1740292781595434, 0.1581646902049828, 0.17656902520006712, 0.14157726977723983, 0.15989044919975626, 0.17032312413023465, 0.17018020090958363, 0.18803381894899285, 0.16862400184247617, 0.2018421912019981, 0.1749402727424062, 0.19074341616889912, 0.18102661870237202, 0.18337599856467157, 0.17243594735750178, 0.17764755591584291, 0.16480588049376843, 0.1770066478233563, 0.17615137371095568, 0.17433882775391463, 0.17709225352192948, 0.1776963823971358, 0.16505583536290558, 0.18316522708976668, 0.17627914836295544, 0.17601385476898634, 0.1739852045612874, 0.26249521646266005, 0.15038350634169328, 0.16084743465606355, 0.28172167179851826, 0.17131376310679536, 0.3383649881427203, 0.13326191081359884, 0.25296896761746746, 0.1489389646481839, 0.16297854349089935, 0.18680253817444403, 0.18170231112752389, 0.30766198523268806, 0.2777242638241403, 0.14278558793666618, 0.24475997809327732, 0.21921091430801942, 0.30691886154788073, 0.1826364612160014, 0.1739614670548002, 0.16855239916722398, 0.17833587411643526, 0.20856679658960253, 0.22241260163938137, 0.1765995160815913, 0.18576120733092172, 0.18243701224349496, 0.0653226892731793, 0.06804187775012893, 0.068598976195819, 0.07131802897725992, 0.06861288190381254, 0.06305231509653053, 0.07214012227234012, 0.06573831371688643, 0.0657791135928879]}, "mutation_prompt": null}
{"id": "9d96e420-7ff1-47ca-aec9-c76346176a01", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDifferentialEvolutionWithDynamicPhaseControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.4  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 10)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def dynamic_phase_control(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 20\n        return sol + np.sin(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.dynamic_phase_control(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumInspiredDifferentialEvolutionWithDynamicPhaseControl", "description": "Adaptive Quantum-Inspired Differential Evolution with Dynamic Phase Control introduces adaptive scaling and dynamic phase control to improve search efficacy.", "configspace": "", "generation": 23, "fitness": 0.17139205770225546, "feedback": "The algorithm AdaptiveQuantumInspiredDifferentialEvolutionWithDynamicPhaseControl got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "metadata": {"aucs": [0.3840729328789151, 0.3673226542845367, 0.3837268629180449, 0.39807532341924023, 0.4060539059594681, 0.3971157451366857, 0.3982515479497808, 0.38120650681309487, 0.3905678516983775, 0.030368372224469975, 0.026090993270275087, 0.01786555531193257, 0.012465393092365273, 0.025430371909269, 0.02155956802023684, 0.03148977013796972, 0.021182051157065174, 0.02018435297186716, 0.09217556738642763, 0.08482704877465552, 0.09774090758938603, 0.09049437467990828, 0.08889171239181726, 0.08290273959315742, 0.08691808355162123, 0.08854796696825873, 0.08764045073143822, 0.08003472976483605, 0.09047248003683384, 0.0856142024070432, 0.09891512027370886, 0.09382822551593784, 0.08910523501281009, 0.07326095574567082, 0.08302343170751048, 0.07257919433510573, 0.811256494472845, 0.8540552600926339, 0.8333780591405697, 0.8727031672702028, 0.8151718605219992, 0.7796837134097749, 0.867642044170674, 0.8864641736307697, 0.8662498255161246, 0.1904522838336722, 0.18267740100452579, 0.1753094784612953, 0.17743022884148485, 0.18307595682600786, 0.15677420919485796, 0.1729085576914453, 0.1827024668486511, 0.1807842233481275, 0.21798130865370025, 0.236436157885916, 0.22581864011662012, 0.213196505040268, 0.2595444132158542, 0.2364949929150082, 0.22207673954553142, 0.2228778022264254, 0.22830177384853356, 0.11886062940920161, 0.12119273327642222, 0.12004622181132796, 0.12279662630792465, 0.10598678587764987, 0.10463982379603365, 0.10627348763590783, 0.09479041548783262, 0.10670621214562381, 0.10349937962195199, 0.09565485004026453, 0.11843772227235039, 0.10741285708222259, 0.1249667427465242, 0.1168522286539142, 0.09743168552962556, 0.11017516490599721, 0.10688048960259677, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.000523926932930463, 9.999999999998899e-05, 9.999999999998899e-05, 0.0414034805755924, 0.08537715619546582, 0.058356637476152384, 0.04499416572093162, 0.07987359505985858, 0.05692662667456716, 0.05713415638873609, 0.07043374681628933, 0.08690830094475899, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04791136768522042, 0.049731668023111575, 0.06154797591321837, 0.058798613286845436, 0.06146483009317549, 0.05809293206220334, 0.05389516612336487, 0.060503678911729364, 0.06279012745838264, 0.3431854991679901, 0.3591678126678428, 0.349452104614445, 0.3476812714674832, 0.33145164386054293, 0.34997955063908304, 0.336916472615172, 0.33893704351454323, 0.3521744623110531, 0.07404011519879494, 0.06876336157455476, 0.07302234832971921, 0.0749886958308631, 0.07965642536798878, 0.08121521053640168, 0.09279949040133728, 0.0673333809714668, 0.07562531645016901, 0.12204392213244919, 0.1376775227528495, 0.13308381147607595, 0.1455345224004715, 0.1518498882684367, 0.12093593261775315, 0.13079971472846696, 0.13860154546918602, 0.15171782883599205, 0.2184050888725605, 0.23563044345841988, 0.22928868471312003, 0.2204370888870747, 0.23271852325243847, 0.2210004984859194, 0.2411721234037355, 0.24668219010858194, 0.2406436841633608, 0.1561012707696685, 0.15304528818706964, 0.1677450415789985, 0.15037137629534136, 0.14982573137494326, 0.14756113619468614, 0.16092875132346818, 0.17550958944894302, 0.17949920052738255, 0.19020930343010323, 0.16441927097105657, 0.18370069202386963, 0.1575593752919543, 0.17601666375332703, 0.20446908696940658, 0.16929965151684845, 0.1894499995622022, 0.18184249067149683, 0.1741587058924361, 0.17680752329531801, 0.1790307449399674, 0.18316684106604608, 0.17861166879727264, 0.1659806109669355, 0.1692369762573952, 0.18212008566969162, 0.16894310710235316, 0.159080086517716, 0.16990953102296624, 0.3309126591053737, 0.1842117486436069, 0.1792394344781405, 0.21483122660124854, 0.23455603771789169, 0.13745604574926018, 0.1786703789892523, 0.1719949608343182, 0.1534594393132398, 0.17332904523702597, 0.18930285613012932, 0.18141908454892242, 0.1409558303403481, 0.19289542404453375, 0.2621434671262366, 0.18159147811879994, 0.1737453822212337, 0.17643929226097876, 0.17651943810128234, 0.18150380017811252, 0.18357607819522348, 0.18604199783110098, 0.1818403642648957, 0.17348572406500984, 0.1696272219404602, 0.07487749754217943, 0.07534010569864258, 0.0652102621344105, 0.0646231100113539, 0.06983294133818219, 0.06681505603287752, 0.07502957608576744, 0.05894720201334169, 0.0686251439394453]}, "mutation_prompt": null}
{"id": "082e14a5-71d8-4068-a058-ac93079220db", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDifferentialEvolutionWithAdaptiveStochasticPhaseAdjustment:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted min differential weight\n        self.f_max = 0.9  # Max differential weight\n        self.cr_min = 0.4  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Max crossover probability\n        self.elite_count = max(1, self.population_size // 12)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol, eval_count):\n        progress = eval_count / self.budget\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / (10 + 5 * progress)\n        return sol + np.sin(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.stochastic_phase_adjustment(trial, eval_count)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumInspiredDifferentialEvolutionWithAdaptiveStochasticPhaseAdjustment", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Stochastic Phase Adjustment fine-tunes exploration and convergence using dynamic perturbation based on the optimization progress.", "configspace": "", "generation": 24, "fitness": 0.17358357105620167, "feedback": "The algorithm EnhancedQuantumInspiredDifferentialEvolutionWithAdaptiveStochasticPhaseAdjustment got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.17 with standard deviation 0.17.", "error": "", "parent_id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "metadata": {"aucs": [0.36755633074088834, 0.3705315795294507, 0.4218467718287586, 0.38695063694902, 0.3732006695359875, 0.36846086043636483, 0.40004022718616306, 0.3795312674110387, 0.38375544687703855, 0.015589966366008068, 0.015723198821163353, 0.01767505517820811, 0.008462686836024469, 0.014921289223735035, 0.003976721556762319, 0.034082684074516645, 0.03426500032720892, 0.001638447575396329, 0.0853864697635478, 0.08753058520159684, 0.08764814951363664, 0.10340140766732253, 0.07768479931376804, 0.08557217636336445, 0.08193236160539563, 0.08411645523092082, 0.09389836151616382, 0.07237391675699767, 0.07670263629585317, 0.07042284503629614, 0.07491816686238506, 0.08297669465472024, 0.07333582472614675, 0.08157906893452604, 0.07938200844542698, 0.07637964806496966, 0.8687212082810575, 0.9169008293295251, 0.8977735955974492, 0.8912498654524827, 0.8194529259762959, 0.8882067869815414, 0.8505530804229601, 0.8570055534477208, 0.8520407276577721, 0.17208049077836463, 0.21353500007214377, 0.18596385980049934, 0.19147281405271976, 0.18064153994963927, 0.18757918952543473, 0.17487558983549623, 0.21226763123615344, 0.18684801230471515, 0.20337911556207078, 0.22082829111271252, 0.22160272738788067, 0.23729831517406375, 0.25183473020155245, 0.2074028054689676, 0.21580808196081058, 0.21265979185742023, 0.20913164432591047, 0.10527567024334672, 0.10333624935569552, 0.12577708297857992, 0.11189924430265619, 0.12091986661710741, 0.1033713417297758, 0.125458328653149, 0.11599511267704488, 0.1270262794603252, 0.08608350419853028, 0.0791584791941845, 0.12106345676342845, 0.12055071368321169, 0.11955337186119541, 0.11515006630378488, 0.12664021783929724, 0.09030732499712013, 0.11098346395210901, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.005531747365234874, 9.999999999998899e-05, 0.07711730526424165, 0.06748649844610721, 0.0629503693328437, 0.06873769508529681, 0.06793523292739156, 0.06466644339401395, 0.06902579486507743, 0.05633041100621927, 0.09487054711262222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.044142507195191305, 0.05174116212177182, 0.059348799505922534, 0.06812963568054187, 0.05709832218021271, 0.08529076868140706, 0.06286133175225173, 0.06559174321681005, 0.0726449404205125, 0.3399763537976712, 0.3492937034850634, 0.33453127256929827, 0.35201518382125885, 0.3328253461391061, 0.35609693404082576, 0.353311986973457, 0.3664396166466991, 0.3632962648124043, 0.08134184114992205, 0.08488183737684796, 0.07643843543156204, 0.08444516512601363, 0.07048725858902616, 0.0834285626458956, 0.07641316247456231, 0.0796796288294177, 0.08304483702201448, 0.1325402760904566, 0.13563684641556484, 0.13600334247414014, 0.15980173014503485, 0.1343373961319969, 0.1257346058600477, 0.14124418546852535, 0.13262678617281487, 0.1046669571346236, 0.22114807235658163, 0.221051609846172, 0.2533104181328677, 0.23967319313558832, 0.24626244399327746, 0.2272587254538112, 0.25528927053427874, 0.24208291748916577, 0.2337762469783572, 0.17079797550554654, 0.17365787092775753, 0.17088924911683734, 0.16067254051333857, 0.15232439301150857, 0.15425908447179715, 0.16257965868022162, 0.19965497899436946, 0.16575938819363, 0.1607296289754, 0.16194237229851516, 0.17575461047155527, 0.16958127553863234, 0.17536681874986249, 0.17421271616041467, 0.20927724821328308, 0.1651843962382341, 0.18081733026083124, 0.17013072543913055, 0.17817476323334924, 0.18699996915879447, 0.16310115699813554, 0.18276514351965367, 0.18663146482355264, 0.17030753663330556, 0.18932863429150015, 0.1721196563727192, 0.21349990987559386, 0.2865287562419849, 0.1587064584704203, 0.16002497505154456, 0.18024467226105423, 0.19415575890692183, 0.15357240970483688, 0.20351379556841875, 0.2631107166566762, 0.17402526386821904, 0.1921004652266518, 0.2489488823124597, 0.2306574527227686, 0.15432300381040953, 0.16724292616742364, 0.19006763568008422, 0.19440065127872008, 0.19665420291157465, 0.17150694656933196, 0.18192363897618136, 0.19200861985771778, 0.18723930382080056, 0.16987552507650983, 0.16227540573774435, 0.17842650831733575, 0.18602082994013458, 0.17939639570217736, 0.07531551671806558, 0.0704864649041016, 0.06866564831574073, 0.06718628636222856, 0.07025646771400351, 0.0739802489118152, 0.061872845044273705, 0.06942554349853614, 0.06068256389652893]}, "mutation_prompt": null}
{"id": "6eeeb925-1f6f-4ee3-8a53-38c8fc6961c7", "solution": "import numpy as np\n\nclass QuantumEnhancedAdaptiveDifferentialEvolutionWithEntropyPhaseShifts:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Slightly decreased min differential weight for broader exploration\n        self.f_max = 0.9  # Increased max differential weight for stronger exploitation\n        self.cr_min = 0.4  # Slightly decreased min crossover probability\n        self.cr_max = 0.95  # Broader max crossover probability\n        self.elite_count = max(1, self.population_size // 15)  # Adjusted elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def entropy_based_phase_shift(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        entropy = -np.sum(self.population * np.log(self.population + 1e-9), axis=0)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / (entropy + 1e-9)\n        return sol + np.sin(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.entropy_based_phase_shift(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumEnhancedAdaptiveDifferentialEvolutionWithEntropyPhaseShifts", "description": "Quantum-Enhanced Adaptive Differential Evolution with Entropy-Based Phase Shifts uses entropy to guide phase shifts and adaptive mechanisms for robust optimization.", "configspace": "", "generation": 25, "fitness": 0.04365829537174913, "feedback": "The algorithm QuantumEnhancedAdaptiveDifferentialEvolutionWithEntropyPhaseShifts got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.04 with standard deviation 0.05.", "error": "", "parent_id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "metadata": {"aucs": [0.11869729595922507, 0.08108763387163931, 0.09169502728636048, 0.09431231635004056, 0.10750000009520266, 0.11042008850345264, 0.0998473575412605, 0.07431300570909605, 0.06863468668670525, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01467079663371329, 0.005375109906600173, 0.010643411704069683, 0.006592353378601756, 0.006669962766643223, 0.018248263482334326, 0.007792397052521438, 0.010674738340807233, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01959972157639278, 0.0004952459975243739, 9.999999999998899e-05, 0.014763392921912755, 9.999999999998899e-05, 9.999999999998899e-05, 0.045179741609489454, 0.045385788542351646, 0.04287777107098589, 0.053340261193588256, 0.04687545855643349, 0.037428727900089886, 0.0638860334912611, 0.048986754550083944, 0.0392018832149682, 0.06274794416174423, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00031549654350837564, 9.999999999998899e-05, 9.999999999998899e-05, 0.011293333694524565, 9.999999999998899e-05, 0.10027683525177622, 0.08224659834595494, 0.059824388882108726, 0.0667108215001172, 0.07285119553694963, 9.999999999998899e-05, 0.026279303607937843, 0.05931056463008866, 0.00990846602666351, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10888030686047845, 0.15756555760738078, 0.14838054695461433, 0.10279143709805372, 0.10274288241579344, 0.09580441870675127, 0.16112956940342849, 0.09716408355800721, 0.1210557193025883, 9.999999999998899e-05, 9.999999999998899e-05, 0.02198412468535549, 0.03266886175302153, 9.999999999998899e-05, 0.01759993274736349, 9.999999999998899e-05, 9.999999999998899e-05, 0.0267656688986897, 0.08494000004272673, 0.08609370886951495, 0.11842175776965747, 0.09855305120349966, 0.10852972522114013, 0.10798713552628325, 0.08808199726801991, 0.08099219012337167, 0.07726393575557644, 0.09606267484187503, 0.0962505644704219, 0.1613932299901244, 0.13800672315110074, 0.1138073754026484, 0.10444782645124173, 0.12028165949079228, 0.17377774300845283, 0.11383112831101194, 0.05985564337097804, 0.034008147686441226, 0.08398582550377798, 0.056957211629895754, 0.06406947898089654, 0.06342850570876157, 0.0837317855149382, 0.0997711199450243, 0.06412526395900253, 0.11943364695601921, 0.09388200728521401, 0.13345086981233123, 0.1103568689991713, 0.08780202581330288, 0.10896891037713907, 0.12245976138762271, 0.07872931414554718, 0.1261963614278906, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05568623559107733, 0.07466602457976645, 0.08167024703901915, 0.07327841830047488, 0.1207914665021157, 0.06661401029160186, 0.1070176662487543, 0.10511484148144368, 0.0693612576838919, 0.11040265245322212, 0.10267165755511809, 0.06932034027342138, 0.0506857903344724, 0.03738259240699027, 0.05903250263678039, 0.04690376827171172, 0.04019044166964181, 0.04143420019681854, 0.13480174570059533, 0.128372137474824, 0.14763022729669195, 0.11599487746987158, 0.12252259820195399, 0.13233279814316334, 0.14969714796693134, 0.12505228174140337, 0.14689007985489466, 0.013617939348936514, 0.015916393435176368, 0.031393493129599714, 0.027015293023570086, 0.03425093938292756, 0.020045516730027746, 0.016228383701229143, 0.03803354422653826, 0.017643830485487344]}, "mutation_prompt": null}
{"id": "3345e28e-e963-4203-a086-2cf406f0c580", "solution": "import numpy as np\n\nclass QuantumLeveragedAdaptiveEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Modified min differential weight\n        self.f_max = 0.9  # Enhanced max differential weight\n        self.cr_min = 0.4  # Modified min crossover probability\n        self.cr_max = 0.95  # Enhanced max crossover probability\n        self.elite_count = max(2, self.population_size // 10)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 20\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumLeveragedAdaptiveEvolution", "description": "Quantum-Leveraged Adaptive Evolution employs dynamic crossover and mutation strategies, inspired by quantum mechanics, to improve convergence on complex landscapes.", "configspace": "", "generation": 26, "fitness": 0.19343148018281642, "feedback": "The algorithm QuantumLeveragedAdaptiveEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "4333e7e7-3665-4f45-b030-72deb1e0ed6f", "metadata": {"aucs": [0.4314785733225436, 0.4657245002348499, 0.4485489710138141, 0.4601800545214244, 0.45382120999837194, 0.4490466449905228, 0.4466084029528361, 0.4337022238822703, 0.42394488518120765, 0.03503282232648686, 0.04357100877586839, 0.03322832495728634, 0.03401129322391061, 0.050563786770812524, 0.04924250862188784, 0.03961542948340269, 0.04002876765083874, 0.06118044204778872, 0.09388267693945129, 0.11448981998500962, 0.08968440203002359, 0.10491322487194377, 0.09409022498408282, 0.09927479012172302, 0.096463839493247, 0.1039194369525216, 0.09082628759173916, 0.08240736476307176, 0.08564214365258249, 0.07749719902707564, 0.08980285320418335, 0.09033603578837612, 0.09226825604040756, 0.0821339365540582, 0.08688589375180977, 0.08294166592350816, 0.8243306432831541, 0.8837824604449841, 0.8652790953298075, 0.8899130577194972, 0.9263697508433139, 0.9076461062955026, 0.9081419771159133, 0.867642930610788, 0.8902804110476907, 0.20033876906680104, 0.22554218284635486, 0.23063687489340223, 0.21443773229795693, 0.20036192969837274, 0.2303134102937019, 0.23863809927404123, 0.22378544304305914, 0.20211288272947137, 0.25028835311737563, 0.24920707168073464, 0.2502366118431959, 0.26983341222504076, 0.29359975117091686, 0.2625147539556052, 0.2627695614248964, 0.20779733365333053, 0.27643088928339266, 0.14103580770812807, 0.1352687356472545, 0.13603296037650436, 0.13258481997932137, 0.12580442540183034, 0.1437854538218275, 0.1489345187578014, 0.14608894249050752, 0.14254626977854734, 0.11338901202563789, 0.11910606763548581, 0.126946617048304, 0.11462822234021208, 0.12296461827794114, 0.13311727134923002, 0.13848340473174447, 0.13244268791468472, 0.13304701156105259, 0.0028613858479001886, 9.999999999998899e-05, 0.00031844075755949053, 0.004504662441410567, 0.0003085634812368676, 9.999999999998899e-05, 9.999999999998899e-05, 0.00978941018100743, 0.00043533598551825925, 0.08265075240691044, 0.0631993551975435, 0.09552480770598681, 0.08130404015200998, 0.04527891094309966, 0.09178475944176623, 0.07049738765910041, 0.08434056068285878, 0.10173220187069232, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07669213430051147, 0.08537939476844492, 0.08562601951537763, 0.07659606332782354, 0.10582452982123902, 0.1060756733774273, 0.0838469256699893, 0.0783266912678311, 0.07291261174925989, 0.3911490571174613, 0.36089945638279763, 0.38617548767032017, 0.4129481335986275, 0.39195949708698874, 0.39691005516684785, 0.3774072979222335, 0.3630840778552127, 0.3818688866366273, 0.08384375858084836, 0.09085849538516289, 0.08666606380750874, 0.0934274707585071, 0.0824660577097055, 0.08291553811553531, 0.09108296971739294, 0.08845611019467292, 0.07883131900163043, 0.15317787617930756, 0.13399415677136295, 0.1386986908622443, 0.14431507861457227, 0.156396557035272, 0.14354464062728134, 0.1232908709259597, 0.1520581794651238, 0.13227929106847225, 0.2565123300145724, 0.22572478523725426, 0.2552873239890924, 0.2491223985338724, 0.23316893518848147, 0.24989710414056088, 0.29054416089456037, 0.2627916391027648, 0.29247137635036335, 0.2032002640129308, 0.1857243680613817, 0.18706143097047745, 0.1892599069555494, 0.17541114563546156, 0.19168049469690607, 0.20094160180232412, 0.20865144514614709, 0.19877671669733354, 0.1846359212771007, 0.1687294632035209, 0.1723544402097248, 0.19380867215467013, 0.17387403587886074, 0.18219252859544854, 0.2046874099157333, 0.18038419498738134, 0.1685526333227192, 0.18090039737157726, 0.17185135469400614, 0.18670918800814196, 0.18476331278860814, 0.17888278821917503, 0.1787949072338284, 0.20831669819391507, 0.1802888854736917, 0.1780256760158121, 0.3175479584469575, 0.1698233871179755, 0.20350190323087836, 0.41864002663840494, 0.16548538237184207, 0.2950245736120929, 0.3195412285295359, 0.27812624606364766, 0.2540562040104485, 0.3365336121210286, 0.1625186883369859, 0.25455276529747584, 0.1544796833326143, 0.2180004130466613, 0.19956114811169223, 0.3218597320633251, 0.19878816944568833, 0.20041684055617026, 0.1864623629705443, 0.20859729120210824, 0.1759082880266305, 0.17702294908369898, 0.176101061636729, 0.20621028114834894, 0.17380231987126116, 0.1707409481775194, 0.1768123298242612, 0.0728112442705533, 0.07058058103262899, 0.06972424958599932, 0.06762436067622435, 0.06515346423291479, 0.06534778194395019, 0.06704066105352635, 0.0680026613158361, 0.059675049652805345]}, "mutation_prompt": null}
{"id": "3ac0447b-cbfb-4d21-b066-b238f1c3fed5", "solution": "import numpy as np\n\nclass QuantumLeveragedAdaptiveEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Modified min differential weight\n        self.f_max = 0.9  # Enhanced max differential weight\n        self.cr_min = 0.4  # Modified min crossover probability\n        self.cr_max = 0.95  # Enhanced max crossover probability\n        self.elite_count = max(2, self.population_size // 10)  # Elite preservation\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 20\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n                trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumLeveragedAdaptiveEvolution", "description": "Quantum-Leveraged Adaptive Evolution employs dynamic crossover and mutation strategies, inspired by quantum mechanics, to improve convergence on complex landscapes.", "configspace": "", "generation": 27, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3345e28e-e963-4203-a086-2cf406f0c580", "metadata": {"aucs": [0.4314785733225436, 0.4657245002348499, 0.4485489710138141, 0.4601800545214244, 0.45382120999837194, 0.4490466449905228, 0.4466084029528361, 0.4337022238822703, 0.42394488518120765, 0.03503282232648686, 0.04357100877586839, 0.03322832495728634, 0.03401129322391061, 0.050563786770812524, 0.04924250862188784, 0.03961542948340269, 0.04002876765083874, 0.06118044204778872, 0.09388267693945129, 0.11448981998500962, 0.08968440203002359, 0.10491322487194377, 0.09409022498408282, 0.09927479012172302, 0.096463839493247, 0.1039194369525216, 0.09082628759173916, 0.08240736476307176, 0.08564214365258249, 0.07749719902707564, 0.08980285320418335, 0.09033603578837612, 0.09226825604040756, 0.0821339365540582, 0.08688589375180977, 0.08294166592350816, 0.8243306432831541, 0.8837824604449841, 0.8652790953298075, 0.8899130577194972, 0.9263697508433139, 0.9076461062955026, 0.9081419771159133, 0.867642930610788, 0.8902804110476907, 0.20033876906680104, 0.22554218284635486, 0.23063687489340223, 0.21443773229795693, 0.20036192969837274, 0.2303134102937019, 0.23863809927404123, 0.22378544304305914, 0.20211288272947137, 0.25028835311737563, 0.24920707168073464, 0.2502366118431959, 0.26983341222504076, 0.29359975117091686, 0.2625147539556052, 0.2627695614248964, 0.20779733365333053, 0.27643088928339266, 0.14103580770812807, 0.1352687356472545, 0.13603296037650436, 0.13258481997932137, 0.12580442540183034, 0.1437854538218275, 0.1489345187578014, 0.14608894249050752, 0.14254626977854734, 0.11338901202563789, 0.11910606763548581, 0.126946617048304, 0.11462822234021208, 0.12296461827794114, 0.13311727134923002, 0.13848340473174447, 0.13244268791468472, 0.13304701156105259, 0.0028613858479001886, 9.999999999998899e-05, 0.00031844075755949053, 0.004504662441410567, 0.0003085634812368676, 9.999999999998899e-05, 9.999999999998899e-05, 0.00978941018100743, 0.00043533598551825925, 0.08265075240691044, 0.0631993551975435, 0.09552480770598681, 0.08130404015200998, 0.04527891094309966, 0.09178475944176623, 0.07049738765910041, 0.08434056068285878, 0.10173220187069232, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07669213430051147, 0.08537939476844492, 0.08562601951537763, 0.07659606332782354, 0.10582452982123902, 0.1060756733774273, 0.0838469256699893, 0.0783266912678311, 0.07291261174925989, 0.3911490571174613, 0.36089945638279763, 0.38617548767032017, 0.4129481335986275, 0.39195949708698874, 0.39691005516684785, 0.3774072979222335, 0.3630840778552127, 0.3818688866366273, 0.08384375858084836, 0.09085849538516289, 0.08666606380750874, 0.0934274707585071, 0.0824660577097055, 0.08291553811553531, 0.09108296971739294, 0.08845611019467292, 0.07883131900163043, 0.15317787617930756, 0.13399415677136295, 0.1386986908622443, 0.14431507861457227, 0.156396557035272, 0.14354464062728134, 0.1232908709259597, 0.1520581794651238, 0.13227929106847225, 0.2565123300145724, 0.22572478523725426, 0.2552873239890924, 0.2491223985338724, 0.23316893518848147, 0.24989710414056088, 0.29054416089456037, 0.2627916391027648, 0.29247137635036335, 0.2032002640129308, 0.1857243680613817, 0.18706143097047745, 0.1892599069555494, 0.17541114563546156, 0.19168049469690607, 0.20094160180232412, 0.20865144514614709, 0.19877671669733354, 0.1846359212771007, 0.1687294632035209, 0.1723544402097248, 0.19380867215467013, 0.17387403587886074, 0.18219252859544854, 0.2046874099157333, 0.18038419498738134, 0.1685526333227192, 0.18090039737157726, 0.17185135469400614, 0.18670918800814196, 0.18476331278860814, 0.17888278821917503, 0.1787949072338284, 0.20831669819391507, 0.1802888854736917, 0.1780256760158121, 0.3175479584469575, 0.1698233871179755, 0.20350190323087836, 0.41864002663840494, 0.16548538237184207, 0.2950245736120929, 0.3195412285295359, 0.27812624606364766, 0.2540562040104485, 0.3365336121210286, 0.1625186883369859, 0.25455276529747584, 0.1544796833326143, 0.2180004130466613, 0.19956114811169223, 0.3218597320633251, 0.19878816944568833, 0.20041684055617026, 0.1864623629705443, 0.20859729120210824, 0.1759082880266305, 0.17702294908369898, 0.176101061636729, 0.20621028114834894, 0.17380231987126116, 0.1707409481775194, 0.1768123298242612, 0.0728112442705533, 0.07058058103262899, 0.06972424958599932, 0.06762436067622435, 0.06515346423291479, 0.06534778194395019, 0.06704066105352635, 0.0680026613158361, 0.059675049652805345]}, "mutation_prompt": null}
{"id": "3b1532b5-298f-4def-8622-3cbc02218e2c", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Adjusted min differential weight for exploration\n        self.f_max = 0.8  # Adjusted max differential weight for exploitation\n        self.cr_min = 0.4  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Adjusted max crossover probability\n        self.elite_count = max(2, self.population_size // 10)  # Elite preservation\n        self.entropy_threshold = 0.1  # Introduce entropy-based diversity control\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10  # Increased perturbation scale\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))  # Measure of population diversity\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveEvolutionaryAlgorithm", "description": "Quantum-Inspired Adaptive Evolutionary Algorithm leverages adaptive parameter tuning and entropic diversity to enhance convergence speed and precision.", "configspace": "", "generation": 28, "fitness": 0.21095471042884614, "feedback": "The algorithm QuantumInspiredAdaptiveEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.19.", "error": "", "parent_id": "3345e28e-e963-4203-a086-2cf406f0c580", "metadata": {"aucs": [0.422442057991524, 0.4261294804139144, 0.41113458269405134, 0.42302306899096775, 0.4237273688694607, 0.4231144287950481, 0.432880470702669, 0.4131946574606311, 0.4143522345815397, 0.17480412096161546, 0.2011624324172665, 0.20159726951037027, 0.17363974328570364, 0.2011453340610293, 0.21591222152955492, 0.20795347253651675, 0.19268415602220568, 0.21323245850597128, 0.1315616541857797, 0.13321034145424926, 0.12041245793143462, 0.14938256362733904, 0.14205451462368424, 0.11241404973792957, 0.11790174813964438, 0.11712119155973266, 0.12833801435954084, 0.11339173035003292, 0.09959850803548653, 0.10561112632504754, 0.11632067134544599, 0.12870035497854793, 0.11100683392334798, 0.1284388325953536, 0.10645551146657128, 0.10077233485760828, 0.933741807210461, 0.9571910330593778, 0.9505480069525146, 0.9711700923376401, 0.9648437365775029, 0.9491072808743368, 0.929153161539372, 0.9624680476129501, 0.9352370187654854, 0.21736104456233984, 0.2127440230296701, 0.20918139549367376, 0.2306407563654861, 0.20318780544317416, 0.20212277524266142, 0.20456657649491417, 0.2126783750872966, 0.22851946916978794, 0.3116075105580587, 0.4383759714396388, 0.3201364765513708, 0.5074117668434606, 0.4524769425119145, 0.5834107777155096, 0.47111838294445985, 0.2750900935235233, 0.2877380634438951, 0.14839950503590538, 0.12778373801537946, 0.14436599317647347, 0.16848413096685122, 0.1558411413347729, 0.14227985634270224, 0.14239939062380413, 0.13961305803678592, 0.1327779482821808, 0.10636990012122749, 0.10985975321860919, 0.14155865034243453, 0.1330724330165951, 0.11204052037713486, 0.13413191004107516, 0.0968328396995537, 0.11428792426828094, 0.1391488774109586, 0.03077125450472018, 0.016134156238658548, 0.0371494695566158, 0.007975549123042436, 0.01386741572769079, 0.015264072494895808, 0.027564301851612072, 0.020472156603615677, 0.03760595325503868, 0.11966806162234755, 0.07904060813346203, 0.11669512219568146, 0.10964622458439677, 0.09900595742355178, 0.07588308504767716, 0.11417305542275458, 0.18573399393969925, 0.20873284660646496, 0.0053144463004980436, 9.999999999998899e-05, 0.028634148663314818, 0.015352324286592611, 0.003078593213874825, 0.013133378543709884, 0.005349344760134378, 0.009372719754624503, 0.0029253049111450657, 0.11455958951478229, 0.12457357714113282, 0.11224590588874928, 0.10364501940405002, 0.10182760318201745, 0.10271570582740552, 0.11659130594622147, 0.1160019297893643, 0.1109130612786301, 0.3901627991391413, 0.3901728540333673, 0.40585632989195275, 0.3862775207979733, 0.3892531421222145, 0.3829569147166306, 0.38786859214717206, 0.37135487532907163, 0.3743936818943405, 0.09448100307651097, 0.10219532549065957, 0.09816077169736126, 0.07949685843174448, 0.08313750730692004, 0.08571520908875885, 0.09128458907820314, 0.08501856541636477, 0.11539029560091763, 0.12931181857191965, 0.16970327632401372, 0.1339277355823265, 0.18030361769895586, 0.1579810693894076, 0.12859924464755024, 0.1305439663450244, 0.14030248480376684, 0.13298475525118758, 0.25457217252770414, 0.2603228099090984, 0.25849514500931814, 0.24827334929959965, 0.23916862529895733, 0.264196708962949, 0.26654715112948857, 0.28035978879692447, 0.2704366134444973, 0.20244529454112115, 0.19134805575861968, 0.1825810646256406, 0.19942664482543004, 0.17219436962585366, 0.18326206162634007, 0.20590891265906663, 0.20921576073249248, 0.20708592746816634, 0.17707468019202988, 0.19215321038709854, 0.17815543201615125, 0.18841441706108586, 0.18893595424450305, 0.1835754371178493, 0.1843343629115014, 0.17698156851758873, 0.1784486835500726, 0.1891434225327444, 0.19051083292881055, 0.18168873963171972, 0.22863869803193093, 0.17868514449897754, 0.18966199708141362, 0.18727074206000538, 0.17931316513268025, 0.18041745622162486, 0.17826066596591994, 0.1611573381045326, 0.1507097208773408, 0.200826816433881, 0.18416921359266447, 0.14079952732980305, 0.20689851497182477, 0.16232701521030468, 0.19933354905808698, 0.2806850578177965, 0.19371820110637872, 0.1813579005940542, 0.1891445504213387, 0.1856291581767976, 0.17252239167453465, 0.20274025526578854, 0.3821393115908963, 0.2063156843936247, 0.1758660747193822, 0.18659437681803348, 0.1766624305455573, 0.18960710739114384, 0.17825637015767148, 0.19118724086990757, 0.17571651518852616, 0.18936358600134595, 0.17081290602528276, 0.06520344408874768, 0.07042367216457535, 0.07025501627481134, 0.06843861493776005, 0.06971739479045513, 0.0635778892062635, 0.07470175566825688, 0.0739940536815118, 0.08340972405726466]}, "mutation_prompt": null}
{"id": "9cd5ffdf-a053-4762-a7d6-16aa86fe355c", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Adjusted min differential weight for exploration\n        self.f_max = 0.8  # Adjusted max differential weight for exploitation\n        self.cr_min = 0.4  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Adjusted max crossover probability\n        self.elite_count = max(2, self.population_size // 10)  # Elite preservation\n        self.entropy_threshold = 0.1  # Introduce entropy-based diversity control\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10  # Increased perturbation scale\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))  # Measure of population diversity\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveEvolutionaryAlgorithm", "description": "Quantum-Inspired Adaptive Evolutionary Algorithm leverages adaptive parameter tuning and entropic diversity to enhance convergence speed and precision.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b1532b5-298f-4def-8622-3cbc02218e2c", "metadata": {"aucs": [0.422442057991524, 0.4261294804139144, 0.41113458269405134, 0.42302306899096775, 0.4237273688694607, 0.4231144287950481, 0.432880470702669, 0.4131946574606311, 0.4143522345815397, 0.17480412096161546, 0.2011624324172665, 0.20159726951037027, 0.17363974328570364, 0.2011453340610293, 0.21591222152955492, 0.20795347253651675, 0.19268415602220568, 0.21323245850597128, 0.1315616541857797, 0.13321034145424926, 0.12041245793143462, 0.14938256362733904, 0.14205451462368424, 0.11241404973792957, 0.11790174813964438, 0.11712119155973266, 0.12833801435954084, 0.11339173035003292, 0.09959850803548653, 0.10561112632504754, 0.11632067134544599, 0.12870035497854793, 0.11100683392334798, 0.1284388325953536, 0.10645551146657128, 0.10077233485760828, 0.933741807210461, 0.9571910330593778, 0.9505480069525146, 0.9711700923376401, 0.9648437365775029, 0.9491072808743368, 0.929153161539372, 0.9624680476129501, 0.9352370187654854, 0.21736104456233984, 0.2127440230296701, 0.20918139549367376, 0.2306407563654861, 0.20318780544317416, 0.20212277524266142, 0.20456657649491417, 0.2126783750872966, 0.22851946916978794, 0.3116075105580587, 0.4383759714396388, 0.3201364765513708, 0.5074117668434606, 0.4524769425119145, 0.5834107777155096, 0.47111838294445985, 0.2750900935235233, 0.2877380634438951, 0.14839950503590538, 0.12778373801537946, 0.14436599317647347, 0.16848413096685122, 0.1558411413347729, 0.14227985634270224, 0.14239939062380413, 0.13961305803678592, 0.1327779482821808, 0.10636990012122749, 0.10985975321860919, 0.14155865034243453, 0.1330724330165951, 0.11204052037713486, 0.13413191004107516, 0.0968328396995537, 0.11428792426828094, 0.1391488774109586, 0.03077125450472018, 0.016134156238658548, 0.0371494695566158, 0.007975549123042436, 0.01386741572769079, 0.015264072494895808, 0.027564301851612072, 0.020472156603615677, 0.03760595325503868, 0.11966806162234755, 0.07904060813346203, 0.11669512219568146, 0.10964622458439677, 0.09900595742355178, 0.07588308504767716, 0.11417305542275458, 0.18573399393969925, 0.20873284660646496, 0.0053144463004980436, 9.999999999998899e-05, 0.028634148663314818, 0.015352324286592611, 0.003078593213874825, 0.013133378543709884, 0.005349344760134378, 0.009372719754624503, 0.0029253049111450657, 0.11455958951478229, 0.12457357714113282, 0.11224590588874928, 0.10364501940405002, 0.10182760318201745, 0.10271570582740552, 0.11659130594622147, 0.1160019297893643, 0.1109130612786301, 0.3901627991391413, 0.3901728540333673, 0.40585632989195275, 0.3862775207979733, 0.3892531421222145, 0.3829569147166306, 0.38786859214717206, 0.37135487532907163, 0.3743936818943405, 0.09448100307651097, 0.10219532549065957, 0.09816077169736126, 0.07949685843174448, 0.08313750730692004, 0.08571520908875885, 0.09128458907820314, 0.08501856541636477, 0.11539029560091763, 0.12931181857191965, 0.16970327632401372, 0.1339277355823265, 0.18030361769895586, 0.1579810693894076, 0.12859924464755024, 0.1305439663450244, 0.14030248480376684, 0.13298475525118758, 0.25457217252770414, 0.2603228099090984, 0.25849514500931814, 0.24827334929959965, 0.23916862529895733, 0.264196708962949, 0.26654715112948857, 0.28035978879692447, 0.2704366134444973, 0.20244529454112115, 0.19134805575861968, 0.1825810646256406, 0.19942664482543004, 0.17219436962585366, 0.18326206162634007, 0.20590891265906663, 0.20921576073249248, 0.20708592746816634, 0.17707468019202988, 0.19215321038709854, 0.17815543201615125, 0.18841441706108586, 0.18893595424450305, 0.1835754371178493, 0.1843343629115014, 0.17698156851758873, 0.1784486835500726, 0.1891434225327444, 0.19051083292881055, 0.18168873963171972, 0.22863869803193093, 0.17868514449897754, 0.18966199708141362, 0.18727074206000538, 0.17931316513268025, 0.18041745622162486, 0.17826066596591994, 0.1611573381045326, 0.1507097208773408, 0.200826816433881, 0.18416921359266447, 0.14079952732980305, 0.20689851497182477, 0.16232701521030468, 0.19933354905808698, 0.2806850578177965, 0.19371820110637872, 0.1813579005940542, 0.1891445504213387, 0.1856291581767976, 0.17252239167453465, 0.20274025526578854, 0.3821393115908963, 0.2063156843936247, 0.1758660747193822, 0.18659437681803348, 0.1766624305455573, 0.18960710739114384, 0.17825637015767148, 0.19118724086990757, 0.17571651518852616, 0.18936358600134595, 0.17081290602528276, 0.06520344408874768, 0.07042367216457535, 0.07025501627481134, 0.06843861493776005, 0.06971739479045513, 0.0635778892062635, 0.07470175566825688, 0.0739940536815118, 0.08340972405726466]}, "mutation_prompt": null}
{"id": "5aefca9d-0f9e-45f2-b976-58f534d1c0b4", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Adjusted min differential weight for exploration\n        self.f_max = 0.8  # Adjusted max differential weight for exploitation\n        self.cr_min = 0.4  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Adjusted max crossover probability\n        self.elite_count = max(2, self.population_size // 10)  # Elite preservation\n        self.entropy_threshold = 0.1  # Introduce entropy-based diversity control\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10  # Increased perturbation scale\n        return sol + np.cos(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))  # Measure of population diversity\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveEvolutionaryAlgorithm", "description": "Quantum-Inspired Adaptive Evolutionary Algorithm leverages adaptive parameter tuning and entropic diversity to enhance convergence speed and precision.", "configspace": "", "generation": 29, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3b1532b5-298f-4def-8622-3cbc02218e2c", "metadata": {"aucs": [0.422442057991524, 0.4261294804139144, 0.41113458269405134, 0.42302306899096775, 0.4237273688694607, 0.4231144287950481, 0.432880470702669, 0.4131946574606311, 0.4143522345815397, 0.17480412096161546, 0.2011624324172665, 0.20159726951037027, 0.17363974328570364, 0.2011453340610293, 0.21591222152955492, 0.20795347253651675, 0.19268415602220568, 0.21323245850597128, 0.1315616541857797, 0.13321034145424926, 0.12041245793143462, 0.14938256362733904, 0.14205451462368424, 0.11241404973792957, 0.11790174813964438, 0.11712119155973266, 0.12833801435954084, 0.11339173035003292, 0.09959850803548653, 0.10561112632504754, 0.11632067134544599, 0.12870035497854793, 0.11100683392334798, 0.1284388325953536, 0.10645551146657128, 0.10077233485760828, 0.933741807210461, 0.9571910330593778, 0.9505480069525146, 0.9711700923376401, 0.9648437365775029, 0.9491072808743368, 0.929153161539372, 0.9624680476129501, 0.9352370187654854, 0.21736104456233984, 0.2127440230296701, 0.20918139549367376, 0.2306407563654861, 0.20318780544317416, 0.20212277524266142, 0.20456657649491417, 0.2126783750872966, 0.22851946916978794, 0.3116075105580587, 0.4383759714396388, 0.3201364765513708, 0.5074117668434606, 0.4524769425119145, 0.5834107777155096, 0.47111838294445985, 0.2750900935235233, 0.2877380634438951, 0.14839950503590538, 0.12778373801537946, 0.14436599317647347, 0.16848413096685122, 0.1558411413347729, 0.14227985634270224, 0.14239939062380413, 0.13961305803678592, 0.1327779482821808, 0.10636990012122749, 0.10985975321860919, 0.14155865034243453, 0.1330724330165951, 0.11204052037713486, 0.13413191004107516, 0.0968328396995537, 0.11428792426828094, 0.1391488774109586, 0.03077125450472018, 0.016134156238658548, 0.0371494695566158, 0.007975549123042436, 0.01386741572769079, 0.015264072494895808, 0.027564301851612072, 0.020472156603615677, 0.03760595325503868, 0.11966806162234755, 0.07904060813346203, 0.11669512219568146, 0.10964622458439677, 0.09900595742355178, 0.07588308504767716, 0.11417305542275458, 0.18573399393969925, 0.20873284660646496, 0.0053144463004980436, 9.999999999998899e-05, 0.028634148663314818, 0.015352324286592611, 0.003078593213874825, 0.013133378543709884, 0.005349344760134378, 0.009372719754624503, 0.0029253049111450657, 0.11455958951478229, 0.12457357714113282, 0.11224590588874928, 0.10364501940405002, 0.10182760318201745, 0.10271570582740552, 0.11659130594622147, 0.1160019297893643, 0.1109130612786301, 0.3901627991391413, 0.3901728540333673, 0.40585632989195275, 0.3862775207979733, 0.3892531421222145, 0.3829569147166306, 0.38786859214717206, 0.37135487532907163, 0.3743936818943405, 0.09448100307651097, 0.10219532549065957, 0.09816077169736126, 0.07949685843174448, 0.08313750730692004, 0.08571520908875885, 0.09128458907820314, 0.08501856541636477, 0.11539029560091763, 0.12931181857191965, 0.16970327632401372, 0.1339277355823265, 0.18030361769895586, 0.1579810693894076, 0.12859924464755024, 0.1305439663450244, 0.14030248480376684, 0.13298475525118758, 0.25457217252770414, 0.2603228099090984, 0.25849514500931814, 0.24827334929959965, 0.23916862529895733, 0.264196708962949, 0.26654715112948857, 0.28035978879692447, 0.2704366134444973, 0.20244529454112115, 0.19134805575861968, 0.1825810646256406, 0.19942664482543004, 0.17219436962585366, 0.18326206162634007, 0.20590891265906663, 0.20921576073249248, 0.20708592746816634, 0.17707468019202988, 0.19215321038709854, 0.17815543201615125, 0.18841441706108586, 0.18893595424450305, 0.1835754371178493, 0.1843343629115014, 0.17698156851758873, 0.1784486835500726, 0.1891434225327444, 0.19051083292881055, 0.18168873963171972, 0.22863869803193093, 0.17868514449897754, 0.18966199708141362, 0.18727074206000538, 0.17931316513268025, 0.18041745622162486, 0.17826066596591994, 0.1611573381045326, 0.1507097208773408, 0.200826816433881, 0.18416921359266447, 0.14079952732980305, 0.20689851497182477, 0.16232701521030468, 0.19933354905808698, 0.2806850578177965, 0.19371820110637872, 0.1813579005940542, 0.1891445504213387, 0.1856291581767976, 0.17252239167453465, 0.20274025526578854, 0.3821393115908963, 0.2063156843936247, 0.1758660747193822, 0.18659437681803348, 0.1766624305455573, 0.18960710739114384, 0.17825637015767148, 0.19118724086990757, 0.17571651518852616, 0.18936358600134595, 0.17081290602528276, 0.06520344408874768, 0.07042367216457535, 0.07025501627481134, 0.06843861493776005, 0.06971739479045513, 0.0635778892062635, 0.07470175566825688, 0.0739940536815118, 0.08340972405726466]}, "mutation_prompt": null}
{"id": "c9888255-584e-40fe-9ec1-cb4951160ab3", "solution": "import numpy as np\n\nclass QuantumEnhancedEntropicEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Adjusted min differential weight for exploration\n        self.f_max = 0.8  # Adjusted max differential weight for exploitation\n        self.cr_min = 0.4  # Adjusted min crossover probability\n        self.cr_max = 0.95  # Adjusted max crossover probability\n        self.elite_count = max(2, self.population_size // 10)  # Elite preservation\n        self.entropy_threshold = 0.15  # Modified entropy-based diversity control\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 8  # Adjusted perturbation scale\n        return sol + np.sin(theta) * perturbation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        mutant = np.clip(a + f * (b - c), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))  # Measure of population diversity\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumEnhancedEntropicEvolutionaryAlgorithm", "description": "Quantum-Enhanced Entropic Evolutionary Algorithm integrates quantum-inspired adaptation with enhanced entropic diversity control for robust optimization.", "configspace": "", "generation": 31, "fitness": 0.2027414234440729, "feedback": "The algorithm QuantumEnhancedEntropicEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.18.", "error": "", "parent_id": "3b1532b5-298f-4def-8622-3cbc02218e2c", "metadata": {"aucs": [0.39770475066697886, 0.39976786087499094, 0.38428298009853656, 0.40258147246960496, 0.4016936964073765, 0.3955874625839356, 0.39480278491392506, 0.42090715524695266, 0.39304932459666475, 0.16418781979486485, 0.2011624324172665, 0.19073957213361892, 0.17190673444588267, 0.2011453340610293, 0.17510420698207085, 0.20795347253651675, 0.1708691079605773, 0.17315592828972803, 0.13147196655770643, 0.13321034145424926, 0.12041245793143462, 0.14938256362733904, 0.14205451462368424, 0.11241404973792957, 0.11790174813964438, 0.11712119155973266, 0.12833801435954084, 0.11339173035003292, 0.09959850803548653, 0.10561112632504754, 0.11629728628655289, 0.12870035497854793, 0.11100683392334798, 0.1284388325953536, 0.10645551146657128, 0.10077233485760828, 0.933741807210461, 0.9571910330593778, 0.9505480069525146, 0.9711700923376401, 0.9648437365775029, 0.9491072808743368, 0.929153161539372, 0.9624680476129501, 0.9352370187654854, 0.20184080309634223, 0.21626438842107754, 0.20493894951342728, 0.21073234319068535, 0.19597943517987992, 0.20449904646653283, 0.19835530830208337, 0.19838245283363254, 0.21570332396364789, 0.30595799637809473, 0.2746587414322553, 0.2774276647385261, 0.3298058416985201, 0.35953320200090555, 0.30250962817659965, 0.29951009480922475, 0.2657102093134135, 0.2868442914926531, 0.13826187910267762, 0.12516781665600518, 0.12672546136718066, 0.1462489618210786, 0.1435140054255527, 0.14169255890740884, 0.1398811213903658, 0.13076625448691026, 0.12208340571702736, 0.10446548759278262, 0.10588231887191124, 0.13341815284986946, 0.12974470476072564, 0.11296552695102835, 0.13199219529382566, 0.0968328396995537, 0.1051869921649059, 0.1195604969771159, 0.03077125450472018, 0.016134156238658548, 0.0371494695566158, 0.007975549123042436, 0.01386741572769079, 0.015264072494895808, 0.027564301851612072, 0.020472156603615677, 0.03760595325503868, 0.11966806162234755, 0.07904060813346203, 0.11669512219568146, 0.10964622458439677, 0.09900595742355178, 0.07588308504767716, 0.11417305542275458, 0.18573399393969925, 0.20858717116169, 0.0053144463004980436, 9.999999999998899e-05, 0.028634148663314818, 0.015352324286592611, 0.003078593213874825, 0.008684814679498443, 0.005349344760134378, 0.009372719754624503, 0.0029253049111450657, 0.11238499684289605, 0.09957147938261646, 0.10482242417162035, 0.10302293764029746, 0.08833633917381045, 0.09898793512414072, 0.10457304012201696, 0.11363095627727837, 0.10922523939183426, 0.35866032679277016, 0.3829425097675695, 0.4050403828135082, 0.3541798560008286, 0.3623720826660115, 0.3586626577255658, 0.3965634455026372, 0.38350493173937916, 0.36307412963052854, 0.09448100307651097, 0.10219532549065957, 0.09816077169736126, 0.07949685843174448, 0.08313750730692004, 0.08571520908875885, 0.09128458907820314, 0.08501856541636477, 0.11539029560091763, 0.12931181857191965, 0.16970327632401372, 0.1339277355823265, 0.18030361769895586, 0.1579810693894076, 0.12859924464755024, 0.1305439663450244, 0.14030248480376684, 0.13298475525118758, 0.25310801018510676, 0.2544533970704862, 0.25118190416182196, 0.24150716664232186, 0.2323727149617253, 0.2589067131422772, 0.2647640263726967, 0.26217589690039367, 0.2609420568554589, 0.19920453136495875, 0.18326507162032035, 0.1825810646256406, 0.1974851085146504, 0.17219436962585366, 0.18326206162634007, 0.20551957053228065, 0.20430223593230978, 0.20708592746816634, 0.17707468019202988, 0.19215321038709854, 0.17815543201615125, 0.18841441706108586, 0.18893595424450305, 0.1835754371178493, 0.1843343629115014, 0.17698156851758873, 0.1784486835500726, 0.1891434225327444, 0.19051083292881055, 0.18168873963171972, 0.22863869803193093, 0.17868514449897754, 0.18966199708141362, 0.18727074206000538, 0.17931316513268025, 0.18041745622162486, 0.17783818244930916, 0.1612690835872168, 0.15070316308309617, 0.200826816433881, 0.18416921359266447, 0.14077029602894076, 0.20689851497182477, 0.16236545779637457, 0.19933354905808698, 0.2806850578177965, 0.1933234135260261, 0.1812923706178745, 0.1891445504213387, 0.18562317045604226, 0.17251687227733814, 0.20240381241352512, 0.35770835413319524, 0.2059430216609881, 0.1758660747193822, 0.18659437681803348, 0.1766624305455573, 0.18960710739114384, 0.17825637015767148, 0.19118724086990757, 0.17571651518852616, 0.18936358600134595, 0.17081290602528276, 0.06520344408874768, 0.07042367216457535, 0.07025501627481134, 0.06843861493776005, 0.06971739479045513, 0.0635778892062635, 0.07470175566825688, 0.0739940536815118, 0.08340972405726466]}, "mutation_prompt": null}
{"id": "a89149c8-ffc8-420b-9fe5-be6bcde3d60c", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.9  # Slightly increase max differential weight for better exploration\n        self.cr_min = 0.3  # Reduced min crossover probability\n        self.cr_max = 0.95\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.08  # Lower threshold for more diversity\n        self.chaos_control = 1.2  # Introduce chaotic map control parameter\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 8  # Adjusted perturbation scale\n        return sol + np.cos(theta) * perturbation\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x) % 1  # A simple chaotic map for enhanced exploration\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveEvolutionaryAlgorithm", "description": "Quantum-Inspired Adaptive Evolutionary Algorithm with Enhanced Exploration using Chaotic Maps for improved diversity and convergence.", "configspace": "", "generation": 32, "fitness": 0.24581198560293702, "feedback": "The algorithm QuantumInspiredAdaptiveEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "3b1532b5-298f-4def-8622-3cbc02218e2c", "metadata": {"aucs": [0.46447337836932867, 0.4417276291292782, 0.4510511504861281, 0.44049753946694614, 0.4235247677756073, 0.44289362698222723, 0.4388197414499281, 0.45275075678558274, 0.44958790077812905, 0.2565456509105145, 0.2871284334389116, 0.267964261863853, 0.23172574673882718, 0.2354242362035508, 0.2635297925902036, 0.2549502311961317, 0.22746972621001182, 0.25696188343684234, 0.2696462304173236, 0.21875432270282846, 0.16078082505242186, 0.23143338605192154, 0.18355283310150228, 0.161385007597187, 0.2160129392712763, 0.25476738526707354, 0.2571522940826281, 0.1415285850518041, 0.13212687964206948, 0.14130396564361924, 0.16371371120043277, 0.14507621475401833, 0.16910602856395962, 0.11733810096657293, 0.2267298553923367, 0.16078556517244802, 0.8807578898700315, 0.8300671854947617, 0.8718287397416719, 0.9064882487472228, 0.9147915005598835, 0.9032003974468071, 0.8583348969562696, 0.9012940468544722, 0.87895564477267, 0.26829439153302015, 0.2172876091998024, 0.22317997419512747, 0.2356845406152731, 0.23829220442926258, 0.23223348154002432, 0.216806939426342, 0.20223770784104966, 0.1703947815217225, 0.5885661565174379, 0.3354501458729252, 0.6869092040238252, 0.25956872002745146, 0.3397195230997563, 0.19756359511922206, 0.6940221712893018, 0.4627738171806264, 0.33637424321565834, 0.18812066936962302, 0.2555757885873844, 0.14431777568992366, 0.12376837520378414, 0.13034092962669297, 0.17278442023859475, 0.18097162958829793, 0.15144967477436733, 0.25292616403131174, 0.11926651210768413, 0.11375767399669112, 0.17478877133233472, 0.12807243332917062, 0.12317404771394613, 0.14033487529327593, 0.1223868571524035, 0.2151473910801217, 0.17155841975838537, 0.11684170488592549, 0.04651781080111128, 0.009348697267890782, 9.999999999998899e-05, 0.04231804952720308, 0.04247979599170992, 0.04582390218545984, 0.005158206960984568, 0.10331913952999494, 0.11369672428505195, 0.134509659932598, 0.21900442527660913, 0.09627696237040706, 0.1456480266159761, 0.09748900853421416, 0.10677599363510382, 0.12954792873765986, 0.228896476430836, 9.999999999998899e-05, 0.0001849984111768066, 0.04358073360838366, 9.999999999998899e-05, 0.017880414266717493, 0.030537226430701003, 9.999999999998899e-05, 0.06767316722437922, 9.999999999998899e-05, 0.08359909176532143, 0.14083832473170332, 0.1235289809927097, 0.11538453792430214, 0.1136168580866801, 0.09316808010434852, 0.118811108644725, 0.14941342840122984, 0.0770726071848643, 0.4075085700999299, 0.4007148337950258, 0.40469719088131995, 0.398169628167905, 0.39003767397277334, 0.40287043214206497, 0.4401223662975995, 0.4002837112024763, 0.426537314111889, 0.11246943908999552, 0.11971520994811957, 0.13034001472111756, 0.14907173845102895, 0.09300625784415373, 0.12598536420426976, 0.14704750780658038, 0.1444619303489295, 0.13022877154865142, 0.23054220105634526, 0.1656368217492793, 0.26346756440480046, 0.231480049324564, 0.20823223375604227, 0.1632440239602151, 0.20654801660536337, 0.15561929769051897, 0.2261126373261494, 0.31597067660627576, 0.2914276511582661, 0.23218965819612203, 0.32587569358083657, 0.2604086009085418, 0.31706626982640873, 0.2873435828703116, 0.30065430980829444, 0.2982361183454779, 0.2281550581618046, 0.22327766840698882, 0.20788621994031387, 0.17115971073507918, 0.24194212416041272, 0.2643255577014859, 0.20975291207497415, 0.2683834586332129, 0.19400296678526452, 0.19780954109865012, 0.20974432001349996, 0.22436712700513461, 0.17873512374654477, 0.2280340439981735, 0.19909029046463267, 0.22114960103957204, 0.18506792461813582, 0.20880766758290892, 0.23554172901571024, 0.1919869848276713, 0.23315695812303805, 0.2903109717802207, 0.295088218906984, 0.22621597325772935, 0.23020682779630441, 0.19631958101419822, 0.2131585796238452, 0.5124004756379329, 0.16194072123770387, 0.17770186170807067, 0.6127500535553227, 0.15233471838309265, 0.6590091638565672, 0.4383790656356449, 0.16558903623659005, 0.6958534661212983, 0.4379342567923763, 0.2061325513735568, 0.3444489382129442, 0.16485875476331857, 0.20513440297419616, 0.16619142683758414, 0.15144982292262088, 0.40305030136022346, 0.578830238158534, 0.16611656221817916, 0.17101039644685734, 0.19079232344997243, 0.16932706407934417, 0.17971922081308145, 0.16918999564219717, 0.1787873761808687, 0.18534253176663518, 0.20006598011489019, 0.08154702964538152, 0.07992987093680914, 0.089494505663123, 0.08092525228661429, 0.07683620209887254, 0.08231064955509304, 0.07668772071632135, 0.07415701765095384, 0.07467661242647794]}, "mutation_prompt": null}
{"id": "57e4ade3-6d6c-47c0-94cc-346da9a5b3ab", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted for better exploration\n        self.f_max = 0.95\n        self.cr_min = 0.2  # Reduced for more variation\n        self.cr_max = 0.9\n        self.elite_count = max(1, self.population_size // 15)  # More selective elite preservation\n        self.entropy_threshold = 0.1  # Increased threshold for wider diversity\n        self.chaos_control = np.random.uniform(0.8, 1.5)  # Dynamic chaos control parameter\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 6  # Modified perturbation scale\n        return sol + np.sin(theta) * perturbation\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.5) % 1  # Enhanced chaotic map for exploration\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveEvolutionaryAlgorithm", "description": "Quantum-Inspired Evolutionary Algorithm with Adaptive Chaos Control and Dynamic Entropy Management for Diverse and Efficient Search.", "configspace": "", "generation": 33, "fitness": 0.23460744301821168, "feedback": "The algorithm QuantumInspiredAdaptiveEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "a89149c8-ffc8-420b-9fe5-be6bcde3d60c", "metadata": {"aucs": [0.4343938522858495, 0.39779118041196304, 0.4437612236057541, 0.4425208030979454, 0.4351749146566033, 0.4184175943891105, 0.4159554300174153, 0.45564502883271785, 0.4136539637311373, 0.20934498619152442, 0.20524620297982887, 0.2490456269086303, 0.2511845918258443, 0.20053208803393652, 0.23069146988760114, 0.21372465553247555, 0.21583333271100114, 0.20835258661061484, 0.23479787355680037, 0.20850300356283047, 0.20888594378760694, 0.1596934119239951, 0.22685615233586698, 0.20368376119827714, 0.19535921901452324, 0.19215617094307258, 0.16570061546831438, 0.2013147071982746, 0.14327286833890374, 0.1745989042659588, 0.15965226516886089, 0.13115000867212, 0.19117854327106054, 0.1449907502362967, 0.17652213235367942, 0.20352493359478907, 0.8702208443365256, 0.9145261841450907, 0.9183356732211491, 0.8885794392717926, 0.9135722295938369, 0.8911819084722614, 0.9107651656035047, 0.927870105647946, 0.8601738230021213, 0.2445920505401672, 0.21290462278384337, 0.2413958569749448, 0.23264368980774552, 0.22469751371575275, 0.2037800030304724, 0.22770949290370368, 0.19933986731043862, 0.20128725136344006, 0.3187771671109686, 0.5129641079760775, 0.2648343527579431, 0.5359922903443758, 0.32155584938452053, 0.31925140145991493, 0.27125892637888527, 0.2589908932162347, 0.3316461751482318, 0.14723475182363477, 0.19793552972543205, 0.13471332739969222, 0.14521149468263939, 0.12827573350263755, 0.15531382514038994, 0.13576411607794647, 0.15541683524617433, 0.13885182167750354, 0.14863586152663888, 0.1767525303000953, 0.13367931693464763, 0.16657252188432903, 0.15099836446871961, 0.17093709797026735, 0.1665449683416811, 0.12547789584419877, 0.26551724564048096, 0.02196848742204527, 0.048617497250006636, 0.029792278718394072, 0.04473379375917086, 0.012015482099339114, 0.04353041712433281, 0.05357564158559858, 0.009981505194750717, 0.02022084928968304, 0.13246456155633768, 0.19275365584805437, 0.17444881677926438, 0.07307369177379863, 0.10031811829403992, 0.0980667587249121, 0.15433672163695955, 0.14428571524302858, 0.1721852244863783, 9.999999999998899e-05, 0.026883438420167494, 0.04571940060146373, 9.999999999998899e-05, 0.006890892173789909, 9.999999999998899e-05, 0.014014247790288703, 0.017436897356044367, 9.999999999998899e-05, 0.14909568929513095, 0.10674518674124589, 0.09819149744171751, 0.08848157698927261, 0.12061837330779057, 0.13690444854583095, 0.0993262609531339, 0.12159132717099785, 0.10721807632220404, 0.4047282494657839, 0.3972228629339162, 0.4009504979649787, 0.4006451570339531, 0.40000079469789884, 0.37894355633667787, 0.39713768462975463, 0.38040326556086623, 0.40931147264287326, 0.1036243138673737, 0.12096078703148083, 0.1227229167095617, 0.10177855513004719, 0.08984642222353012, 0.10657543575578055, 0.10698264133227764, 0.11901374041947677, 0.09730856600879034, 0.1472637411991944, 0.14316384674976235, 0.14685338610684162, 0.13580954226061748, 0.15537085422143826, 0.14753239990523614, 0.14260568257501582, 0.14285083769493234, 0.18255728853667297, 0.2818687096419443, 0.2671115310970512, 0.280519592004312, 0.2826557403679901, 0.2824795777882919, 0.27238538464699424, 0.302894768544129, 0.32525518069716597, 0.2823074122446195, 0.24281936992070685, 0.2292356570740316, 0.23966619009352186, 0.21128677960090603, 0.20733048922468977, 0.2352869317021209, 0.2058424730562981, 0.23169180159543634, 0.20013727501935896, 0.20677683257946122, 0.1750417724469724, 0.20383831888516968, 0.21625617997404578, 0.19744861505846423, 0.20910048659343916, 0.18261307648373548, 0.21551261445522307, 0.18911670487735033, 0.19144554867230668, 0.20839961877497182, 0.28690946279786367, 0.199706585883638, 0.23839503069580859, 0.2798857195406065, 0.28638777949628746, 0.29622306054217173, 0.2685636816116015, 0.4890048735638999, 0.16704542244527643, 0.5481237240409949, 0.5210848421478191, 0.17060736684591737, 0.47816895270427995, 0.16658183765062073, 0.16517530498342603, 0.5054807016374332, 0.5002023584211828, 0.19458470087927404, 0.6006630710547618, 0.1567650696619608, 0.1615147523073529, 0.18989444428415914, 0.35593931746805585, 0.20451210618950744, 0.41172884634477, 0.18424613734486583, 0.17291799627190063, 0.16825849164080386, 0.17710746293341217, 0.19177591815527417, 0.17326027414463585, 0.1776625988414373, 0.16620086296623682, 0.17597564499809637, 0.07440107328447543, 0.0742200787445263, 0.07286304725703485, 0.07628077771942277, 0.08309497033663871, 0.07092502710696158, 0.07725191943280774, 0.08002424344196335, 0.08542557181375776]}, "mutation_prompt": null}
{"id": "c529465d-f6bc-4703-975f-ef6709585414", "solution": "import numpy as np\n\nclass HybridQuantumInspiredEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.85  # Adjusted for more balanced exploration and exploitation\n        self.cr_min = 0.25\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.1  # Dynamic entropy threshold for adaptive diversity\n        self.chaos_control = 1.3  # Enhanced chaotic control for exploration boost\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 6  # Increased perturbation scale\n        return sol + np.sin(theta) * perturbation\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x * (1 - x)) % 1  # Logistic map for chaotic exploration\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "HybridQuantumInspiredEvolutionaryAlgorithm", "description": "Hybrid Quantum-Inspired Evolutionary Algorithm with Reinforced Mutation and Dynamic Entropy Management for Robust Optimization", "configspace": "", "generation": 34, "fitness": 0.2128937320128696, "feedback": "The algorithm HybridQuantumInspiredEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.16.", "error": "", "parent_id": "a89149c8-ffc8-420b-9fe5-be6bcde3d60c", "metadata": {"aucs": [0.4734789265633329, 0.4239533401448111, 0.44777237938485503, 0.46680653996035915, 0.4777419943000175, 0.4203726060496207, 0.5318532305184, 0.4721316667229246, 0.44341489005132895, 0.2123289214292996, 0.209952065210542, 0.25545968406491226, 0.14728355647133118, 0.166558303639479, 0.11185000974777226, 0.21817377728343512, 0.17336755414059657, 0.23865409018190453, 0.15930453700991254, 0.2414858138564988, 0.21818845609701487, 0.1711281646583389, 0.15101810764819534, 0.1488415980760115, 0.2631964423068457, 0.1337606912308018, 0.24747005515112885, 0.1355865031747331, 0.15141808412361168, 0.12286510759453739, 0.13939839619779415, 0.15214803609472005, 0.17044395531278134, 0.14493803945421446, 0.14265784303393303, 0.14438951691469937, 0.7072686488258343, 0.8592706097347139, 0.8478258817732085, 0.6139304201770142, 0.7751707273163225, 0.7590472122629186, 0.828099282345566, 0.8651297000803169, 0.8507569620355997, 0.28310711670281363, 0.18097114699164663, 0.20861775178660869, 0.2644706774310617, 0.16334283863841847, 0.16929469127272845, 0.18528639995565432, 0.23189774229014481, 0.239743045152356, 0.22321565974059454, 0.3111483230323142, 0.13842607386530859, 0.2672467594592016, 0.23466320253305106, 0.2151404823134725, 0.14207477476198438, 0.2796105586436921, 0.2866987768325391, 0.11955202771940854, 0.14939972515722444, 0.16257786332051072, 0.14925062385703114, 0.11755473102355285, 0.1354237350306603, 0.16448341699034352, 0.24718079704177431, 0.1504153897364756, 0.13129525154556554, 0.1328479163729651, 0.17469399445827238, 0.12189438051645318, 0.21161931320083216, 0.1278373428084102, 0.1728373496799246, 0.12409219027990748, 0.1333193950469327, 9.999999999998899e-05, 0.050296002776062276, 9.999999999998899e-05, 0.025571874834237285, 0.03779292968960013, 0.052433909659997835, 9.999999999998899e-05, 0.07578618344648935, 0.034492679437227336, 0.17799006885631896, 0.0784480203799931, 0.09838306412142761, 0.04099545564257989, 0.05896703403603465, 0.11126548277740334, 0.16989483956777673, 0.09288512451795794, 0.12320341727062167, 9.999999999998899e-05, 0.010549778591302905, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06224341888185392, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07050427214713473, 0.07336264280093596, 0.09461379960371374, 0.11731525417542066, 0.0978090502179868, 0.11346668488795508, 0.12561058760761856, 0.12663845803086138, 0.08048013962890055, 0.37363560621169334, 0.3998415887321346, 0.3973138827072076, 0.40732903654055386, 0.408494741749024, 0.3671836902406521, 0.3696924271646175, 0.37312036396134673, 0.4096801373385559, 0.10273259986835359, 0.12041733887475203, 0.11534785376351142, 0.13998023363986234, 0.0996635280258481, 0.09483508236162574, 0.10116453920688961, 0.1050272683264446, 0.14557853810444554, 0.2986762826329198, 0.135257281686892, 0.19777656504285146, 0.22203369227018754, 0.22362242885762285, 0.27058918074589833, 0.19813265889242226, 0.14890099584044858, 0.23435005293312783, 0.18286065351606184, 0.27190228286494456, 0.2675867502340945, 0.28128834420286053, 0.25880529276287345, 0.27240510806019624, 0.2870992290621459, 0.2973048753312618, 0.29946128683388074, 0.1585675032989755, 0.20511235041999287, 0.18217182075604155, 0.23493799180801178, 0.18926144113506949, 0.23017336763992813, 0.20022186483462678, 0.24815746199232236, 0.21283269757372536, 0.18931240547601147, 0.21016460315388052, 0.21886372289036315, 0.1839058968986288, 0.2013598591589444, 0.21384010663102526, 0.19202929519491563, 0.1887426646164948, 0.2179377732821135, 0.1911848088759288, 0.2167041860086787, 0.2432233900969697, 0.22265175709288387, 0.2219693080074202, 0.236595939021794, 0.3214328831592337, 0.18304120446895544, 0.19196203380114962, 0.423424984150388, 0.1966801198434146, 0.16502018196697266, 0.19302805420524494, 0.1566083920744511, 0.19221348716690068, 0.14448435570614693, 0.16773216213037556, 0.5607290085197276, 0.5948065330365846, 0.20032329300426632, 0.12546030037773015, 0.1661068618633813, 0.16652416775800427, 0.14697967063059791, 0.14676753533960696, 0.13563865411465015, 0.17815978195419924, 0.17967762441041557, 0.1799145327917775, 0.19017759447761595, 0.17603414103623038, 0.17814282065163445, 0.1753048964097137, 0.18377534692546438, 0.19144122101651784, 0.1822214069319441, 0.07553983410199838, 0.07725150024510308, 0.0705367996474473, 0.08075886455639847, 0.07830257810706731, 0.09844227635711578, 0.08046674991242164, 0.07776546656851735, 0.07403119377807366]}, "mutation_prompt": null}
{"id": "23973236-aa8f-4511-a0e9-e66b4f7e90b8", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.95\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.12  # Increased threshold for adaptive exploration\n        self.chaos_control = 1.3  # Slightly increased chaotic map control parameter\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10  # Adjusted perturbation scale\n        return sol + np.cos(theta) * perturbation\n\n    def chaotic_map(self, x):\n        return (np.sin(self.chaos_control * x)) % 1  # Updated chaotic map for enhanced exploration\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveEvolutionaryAlgorithm", "description": "Quantum-Inspired Adaptive Evolutionary Algorithm with Dynamic Entropy-Controlled Exploration for enhanced diversity and convergence.", "configspace": "", "generation": 35, "fitness": 0.23793052770764103, "feedback": "The algorithm QuantumInspiredAdaptiveEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.18.", "error": "", "parent_id": "a89149c8-ffc8-420b-9fe5-be6bcde3d60c", "metadata": {"aucs": [0.47762634398681825, 0.43721932495994675, 0.4359059161205119, 0.4221463681499009, 0.4314758462518835, 0.46868821409161276, 0.43819544626196827, 0.4535622996353249, 0.45282729658029863, 0.23396642955436087, 0.24186328460408946, 0.23089646896001637, 0.19193235233309325, 0.1998405433172482, 0.22375404273897193, 0.22269873362485382, 0.2082407363305443, 0.19866321089961414, 0.19790628738472182, 0.20087394136641445, 0.22884478734485314, 0.21014902556228643, 0.19081827483632008, 0.22744850148334195, 0.15492401742725692, 0.176742338996983, 0.20908594715374362, 0.1776082996318633, 0.18572114881788238, 0.14205053503772902, 0.14483009373512046, 0.1561811407943926, 0.20720390387656584, 0.14134290622990742, 0.19439150053744958, 0.19423663270556868, 0.8968101234032378, 0.895211187990862, 0.902334056823268, 0.8921858110109935, 0.894748131317321, 0.8796398286562916, 0.8658754466312581, 0.9125352718698031, 0.9226393301375365, 0.23334500182422002, 0.2281365971815198, 0.25344510819359045, 0.2413873104384041, 0.2611152172834451, 0.24484030282121771, 0.25571399895820446, 0.2600427788897064, 0.24226979083513933, 0.5937171787003407, 0.33981185728683827, 0.3707350623303066, 0.665824383227483, 0.6828799804157061, 0.3315782406657599, 0.4338221981052146, 0.2991275864879158, 0.34795491553469005, 0.13632577013486047, 0.2056471415829304, 0.14028587059987352, 0.10770299703077657, 0.15801307239160955, 0.17263877847904618, 0.1339479278207757, 0.17892876320720352, 0.2580039881867858, 0.13959459009229302, 0.10894188463510801, 0.18361249986326633, 0.18383062753335266, 0.13261049274003012, 0.1757583291259287, 0.13636558887679273, 0.13326929548435806, 0.14386306653721714, 0.05320234219523845, 0.047846864796947, 0.07305584322144953, 0.038279061636973366, 0.031450142342736354, 0.03343587948946203, 0.04002917480248158, 0.047563264249781745, 0.06818195483764344, 0.15739431751040667, 0.12141717786507855, 0.1256124881686952, 0.11724119168085745, 0.15296400675765143, 0.07631114249365889, 0.1517479301136958, 0.08417011182187617, 0.16545367883049478, 0.03144146901459122, 0.007413329949374603, 0.043085654278974816, 9.999999999998899e-05, 9.999999999998899e-05, 0.03743423645983679, 0.01355962142482059, 0.07212248091089946, 0.04446919088275059, 0.10961685381120556, 0.1055296410776535, 0.1286143445881699, 0.14985092865444094, 0.12803799158794194, 0.08834691840545894, 0.10101111086501546, 0.12180528947361802, 0.07873438866583915, 0.4062629223660512, 0.39760620137286384, 0.42311088476776515, 0.3969925354473488, 0.39539592221573905, 0.3896769262368036, 0.40098982504367253, 0.39923764194530553, 0.3903489486133864, 0.1022640683150623, 0.09966837119178107, 0.11278785253595847, 0.11186808587319486, 0.10158670519243729, 0.12022987463856194, 0.10372183103522692, 0.10172422909586454, 0.08576744485836008, 0.15294230557273425, 0.16051615099560024, 0.19999994578978586, 0.23852384394542514, 0.14907574565353898, 0.13093404147591625, 0.1655774364992889, 0.1643273801557632, 0.17683620760059515, 0.2706467462107054, 0.27579285517891505, 0.28597243530474026, 0.28514547993636286, 0.2725489103751766, 0.2675073000092193, 0.28084856372913947, 0.29410583836230075, 0.2924826997608768, 0.2003192747064536, 0.22878901222692616, 0.21764242819611623, 0.21570973521057213, 0.19760109899862788, 0.21534407286620616, 0.2243457879342695, 0.22848892653670172, 0.22655759533026598, 0.1856965724560249, 0.19000049718605228, 0.20947763487519178, 0.18186275869732782, 0.19245828045677882, 0.21027975595752058, 0.20448134629009573, 0.18081316289738225, 0.19144099088320998, 0.2531698148843391, 0.21553529896878043, 0.24368707736832285, 0.19839934484098154, 0.29297774023603895, 0.21518710656036488, 0.2883767080739975, 0.28967818174534576, 0.2064375521609837, 0.1649972901379313, 0.5804163072319334, 0.17509040845726065, 0.5554360062910015, 0.16716422419662613, 0.18934130591844633, 0.15461951411535213, 0.1768769064373964, 0.6275664083074415, 0.4582635365803117, 0.20447680786384403, 0.4480643297360286, 0.1598432476567152, 0.1663884620491779, 0.3791468746952905, 0.2033840418908267, 0.14631527599871674, 0.1967752957998138, 0.1771609396403857, 0.17976342431807935, 0.18306642094613246, 0.1796186062099001, 0.17527409149891682, 0.18914357942253268, 0.17634302586704875, 0.1813544872640266, 0.19298035035098682, 0.07790283873483828, 0.08292707783765285, 0.08825781858299742, 0.07952722757171615, 0.07946934516121618, 0.10297271151748078, 0.07979290391421923, 0.08953571101561775, 0.08239572225458924]}, "mutation_prompt": null}
{"id": "3b440b0a-98c8-4f2d-9261-a63547ce14e5", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveEvolutionaryAlgorithm:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjust differential weight for better balance\n        self.f_max = 0.95  # Extend max differential weight\n        self.cr_min = 0.25  # Further reduced min crossover probability for diversity\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)  # Adjust elite count for improved selection pressure\n        self.entropy_threshold = 0.1  # Increased threshold for diversity\n        self.chaos_control = 1.0  # Adjusted chaotic map control parameter\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 6  # Adjusted perturbation scale\n        return sol + np.cos(theta) * perturbation\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x * (1 - x))  # Logistic map for enhanced exploration\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveEvolutionaryAlgorithm", "description": "Quantum-Inspired Adaptive Evolutionary Algorithm with Dynamic Scaling and Randomized Reflection for enhanced convergence and robustness.", "configspace": "", "generation": 36, "fitness": 0.21335434695023905, "feedback": "The algorithm QuantumInspiredAdaptiveEvolutionaryAlgorithm got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.17.", "error": "", "parent_id": "a89149c8-ffc8-420b-9fe5-be6bcde3d60c", "metadata": {"aucs": [0.45008371365289, 0.41944751847184714, 0.42761821965842406, 0.44792678227244365, 0.44883070859914365, 0.44271057193520347, 0.42651620564733317, 0.4329493256405118, 0.4185699635151874, 0.13511485347415253, 0.12551382193803962, 0.1602156793099333, 0.07955472327750435, 0.10482393669116796, 0.248282012561866, 0.20437094230619746, 0.05768766699897099, 0.08996522760764214, 0.1275165500681329, 0.15162092718722597, 0.11002866978204351, 0.16875259630162198, 0.17351607464218, 0.15994374825142044, 0.1374471961743986, 0.12624908592514184, 0.19812551770776654, 0.13372200317068927, 0.14980901828558268, 0.166840782722813, 0.13642722504834115, 0.1380162878993424, 0.11939134269316076, 0.11536305693094251, 0.1391119595370054, 0.16156724582322946, 0.6190922667260588, 0.8656538798290683, 0.821719090773134, 0.6416667206185258, 0.848638313392766, 0.6992017235144526, 0.8257325616199171, 0.8685586244185024, 0.6743021414825474, 0.2240453392141536, 0.11783603995225789, 0.20296948777567192, 0.25566139492354334, 0.16672300869859813, 0.16513824386407228, 0.21129732752852748, 0.20969256980600504, 0.24608455698502996, 0.2161193768994495, 0.8174843417733297, 0.1122762805588019, 0.23878289732176183, 0.25941616210123053, 0.27092626730020886, 0.1551391779102309, 0.22346464842482805, 0.3268708276612209, 0.11665099696602743, 0.14239960842790877, 0.14255546031369026, 0.18647424905911825, 0.11867066222139022, 0.23816846633972588, 0.1747066103767595, 0.1477871972869098, 0.149781913578919, 0.11752241570673505, 0.12752369735201485, 0.19161776782861584, 0.12954810812900686, 0.2441022463499798, 0.1304105782683449, 0.13357037946758032, 0.12029225611380079, 0.1357605651277196, 0.04680208874011482, 9.999999999998899e-05, 9.999999999998899e-05, 0.0824409661285943, 0.0030329625948425365, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09580664680132212, 0.17444440472525824, 0.07704504615092123, 0.13983616733473225, 0.0509190388928662, 0.042463527709579285, 0.11346231837980736, 0.09220698099596103, 0.18464323883637646, 0.10131787336644849, 9.999999999998899e-05, 9.999999999998899e-05, 0.04141473778196947, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007192477227363492, 9.999999999998899e-05, 9.999999999998899e-05, 0.03180932421420779, 0.11634917367283137, 0.08961445992353378, 0.11585358950465174, 0.13083824101141328, 0.11027218735233313, 0.08971800077917924, 0.09366737644237422, 0.07006577007567061, 0.3919673634310018, 0.3785054259029321, 0.3883270365728737, 0.37740327589601463, 0.39294981321019673, 0.4050075414821057, 0.36343150170042715, 0.39642702818941555, 0.4085557578728073, 0.10353790201792512, 0.13033563087002753, 0.11116044838473937, 0.09936328330972322, 0.0824550248322361, 0.12412361270213657, 0.14846191814482335, 0.12644956264708795, 0.11423733772611688, 0.24595615311289043, 0.1939655089153558, 0.2146228173478184, 0.18244558544496603, 0.2306094086718966, 0.28241363772466344, 0.18812543323307696, 0.1989160118980423, 0.2477470043538922, 0.28088864616768083, 0.25630701414544843, 0.26058238755259033, 0.29133937200336113, 0.2984527676602803, 0.2760281245607452, 0.2766713214334625, 0.30005406341142427, 0.29587941579960353, 0.12533075181963138, 0.2584050014113406, 0.20502866148918897, 0.20649633245482735, 0.2204905451222512, 0.2305871546900471, 0.20425023398644604, 0.2414528050038851, 0.2051009923727808, 0.20818999546663208, 0.19389419384410744, 0.20248519319270764, 0.2089678814130016, 0.22437190576566324, 0.20850983323318095, 0.2116823391860737, 0.20837542650731633, 0.2047064793055029, 0.1853784912739903, 0.19492147187192455, 0.18153653894786803, 0.3031104732577844, 0.20666092893788857, 0.19294118567533036, 0.20051667084966462, 0.19134924227313643, 0.20426769835494174, 0.14992414305908663, 0.18269768452744117, 0.3646305504130738, 0.5166970321290717, 0.1571625216802064, 0.49630096272332935, 0.13887620333835382, 0.1652864152187109, 0.597726520275583, 0.43852562947896845, 0.20285633338332687, 0.3993099808869002, 0.4828825577694098, 0.16679705179002158, 0.19405118194072424, 0.14081304631510083, 0.1669261053200808, 0.1734992786390439, 0.18554318289679972, 0.17756388804220846, 0.21533676367813648, 0.17518029162259208, 0.1732188065536049, 0.18670142969446002, 0.17778613707850976, 0.19545169278788344, 0.17711299946644044, 0.07975725634803088, 0.08376520020901246, 0.08245545926033115, 0.08594267921737087, 0.08045815771911713, 0.08051248597396898, 0.07727191929599753, 0.07760932699326473, 0.07711128914858123]}, "mutation_prompt": null}
{"id": "3af524a8-f77f-4409-949e-9663fa806962", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Slightly reduced min differential weight for improved stability\n        self.f_max = 0.9\n        self.cr_min = 0.2  # Further reduced min crossover probability for diversity\n        self.cr_max = 0.95\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.05  # Lower threshold for even more diversity\n        self.chaos_control = 1.3  # Adjusted chaotic map control parameter for balance\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 10  # Adjusted perturbation scale\n        return sol + np.sin(theta) * perturbation  # Changed to sine for variety\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1  # Enhanced chaotic map\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Chaotic Control for Enhanced Exploration and Convergence.", "configspace": "", "generation": 37, "fitness": 0.25604576831377546, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "a89149c8-ffc8-420b-9fe5-be6bcde3d60c", "metadata": {"aucs": [0.4830461171077438, 0.446941437006097, 0.5032524581211595, 0.47165793909497167, 0.4776286818967441, 0.4825856600549867, 0.4623176075271961, 0.4587937934594173, 0.4572671725906765, 0.2475999161312592, 0.26614211397073595, 0.276578538259608, 0.258998272221555, 0.2944040758403278, 0.25599780291493957, 0.2937330067916142, 0.26953424756306543, 0.27205250445387696, 0.2051671183598388, 0.2219963299856509, 0.16444801042420476, 0.15970904744959202, 0.16462859733120516, 0.25943892881170627, 0.23426997776863723, 0.15226099679344696, 0.18226326150151728, 0.15395102175822084, 0.13796459353404622, 0.13983137420301972, 0.20857863871987015, 0.16483408695945911, 0.1597468890110797, 0.14110107427983698, 0.20447595815181563, 0.2102640158152046, 0.8508986767449157, 0.8971425600828901, 0.9026640505445788, 0.9116219396679975, 0.9089025550423561, 0.8865020174734185, 0.9130867235307727, 0.9137952340418183, 0.8983340456442083, 0.24990209746148306, 0.23929848881378402, 0.289753890576549, 0.27154274177181115, 0.2528501866147298, 0.29467119055085045, 0.24445295352045626, 0.27305828014326117, 0.22288752329382733, 0.5755046086099189, 0.5131455761004198, 0.3235171992593662, 0.31163072941070147, 0.6713074556833648, 0.7218927521414011, 0.5344208243480333, 0.5709007373942248, 0.2571085456989205, 0.15783915025448136, 0.11986996874915201, 0.14085776405253636, 0.1752654390508731, 0.14025971260322168, 0.22668649824367837, 0.17971605170831795, 0.1351728037878802, 0.2829267470109854, 0.13624939191527297, 0.20271649311324458, 0.16045772102609912, 0.14346606554806207, 0.1754462507693777, 0.14309511457964486, 0.11875739337190538, 0.11919960033993027, 0.16672376158689917, 0.1067243890683498, 0.03552954932621544, 0.06978343162398593, 0.03688730903831561, 0.00014526560880889772, 0.00011964368395167568, 0.05390336172868515, 0.051293149476925426, 0.13168133371035418, 0.14863423456798663, 0.10933951164425493, 0.10456029553426394, 0.11618837230039958, 0.16574328404876992, 0.1584257453022193, 0.11521918010698196, 0.10193200764663068, 0.12568664534527485, 0.035927078295629356, 0.045236699693598115, 0.0430991457315989, 0.05115745837624397, 0.002245429516660624, 0.12776678470256408, 0.026465402233770696, 0.04341861423366444, 0.09406333456977822, 0.13816168854877453, 0.15221863286397075, 0.13325228047824622, 0.1596199941841724, 0.1442870216459674, 0.13143575833615817, 0.12252593954313784, 0.1538109301838425, 0.13068653678018693, 0.42862269656552165, 0.4169176809607108, 0.4286454783480279, 0.4326805448534836, 0.4309223282046686, 0.41107682467073514, 0.43766893893113856, 0.4295306865375773, 0.43042332151698315, 0.10405353375907922, 0.11192043948728625, 0.11505311025545983, 0.11272907445187796, 0.1001032263231253, 0.11698689701128129, 0.11666970475620964, 0.09441183576140089, 0.09262812433961187, 0.2950238657003482, 0.14222852665364794, 0.15509294360876014, 0.1616733897916538, 0.17218929152263396, 0.14826372618399708, 0.16943905957092098, 0.19317261285999465, 0.1525911145754788, 0.306035026764937, 0.3003713943418427, 0.30596368294375864, 0.28706358562853107, 0.28779513843753, 0.31655772955254646, 0.3063184904272521, 0.3357614611269636, 0.29377307670635, 0.22222142529977074, 0.22826240540237241, 0.2346990342048999, 0.22402428225206217, 0.21883922566704883, 0.24816388396916345, 0.2554349250568432, 0.254035243319956, 0.23292513127953096, 0.1915144886778174, 0.17264493912444323, 0.2054018262102394, 0.18533116789354276, 0.21950481870376026, 0.20254282369824195, 0.18041082742495418, 0.19451716671292252, 0.18359394344122482, 0.21563926866439398, 0.22836351529218823, 0.25247846100599036, 0.22515530224689217, 0.19898907403714272, 0.21810578656110702, 0.2602764203354624, 0.23160166013605876, 0.20396550882915954, 0.17615382835101134, 0.19048720485335124, 0.5771185583199869, 0.5257936069736929, 0.594756543590455, 0.651557754736036, 0.16266063053938018, 0.4021668258180544, 0.711718869486831, 0.5122164729946027, 0.20161384297576457, 0.4243978468858477, 0.16032298245564325, 0.3312881070037875, 0.678123059306849, 0.1634046579041356, 0.20392680415102882, 0.14574858234470067, 0.17597617190058623, 0.18056191967040125, 0.17493330429036047, 0.18500274534894345, 0.18667031552581703, 0.19172852177324062, 0.1808016219609032, 0.18078764296980465, 0.17331333605722943, 0.08362202731176516, 0.07702004438990917, 0.0817160987801604, 0.08093010144962931, 0.08002757038743491, 0.06572799772868221, 0.07135023143403474, 0.08547050143742796, 0.07165228866720519]}, "mutation_prompt": null}
{"id": "ba01c2ef-5e41-4862-b39c-d3d5edca8701", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3  # Slightly lower min differential weight for more adaptability\n        self.f_max = 0.9\n        self.cr_min = 0.25  # Increased min crossover probability\n        self.cr_max = 0.95\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.1  # Modified threshold for enhanced diversity control\n        self.chaos_control = 1.2  # Adjusted chaotic map control parameter for better balance\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_phase_adjustment(self, sol):\n        theta = np.random.uniform(0, 2 * np.pi, self.dim)\n        perturbation = (np.random.rand() - 0.5) * (self.upper_bound - self.lower_bound) / 8  # Adjusted perturbation scale\n        return sol + np.cos(theta) * perturbation  # Changed to cosine for different exploration trajectory\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.6) % 1  # Modified chaotic map for improved exploration dynamics\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_phase_adjustment(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Enhanced Entropy-Controlled Diversification for Robust Optimization.", "configspace": "", "generation": 38, "fitness": 0.23883544444489924, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "3af524a8-f77f-4409-949e-9663fa806962", "metadata": {"aucs": [0.4691650198052887, 0.43428844196839733, 0.43412696143190277, 0.45138974924927866, 0.44193644460140136, 0.44791070723234894, 0.4564235138414269, 0.4530912615270144, 0.4261445829663847, 0.18702958654198842, 0.22892986488728395, 0.256242048396075, 0.1992065377975195, 0.2708588161207969, 0.19800602817458757, 0.2538543708765696, 0.21388594181159448, 0.18817638054177, 0.23381245101824666, 0.24534294733862805, 0.24371659871700502, 0.21191015825894988, 0.2081732271030543, 0.22799196349369288, 0.20105890591053643, 0.16918346246930616, 0.21753619506710198, 0.15262969181481567, 0.15925374480324972, 0.1538226619541836, 0.21744637806437994, 0.16129605142305314, 0.13399939813480977, 0.15275347581694187, 0.22155946896864698, 0.1929392960109071, 0.895729415399384, 0.8945135846027881, 0.9196367933718045, 0.8888563661239999, 0.9123122775711543, 0.9151438364997065, 0.8618698633474557, 0.921902854975611, 0.8549823841433628, 0.21880436569646622, 0.20068702114770587, 0.2457693543507412, 0.26946196791346455, 0.26382820932180606, 0.26933314148281606, 0.2506294218132906, 0.21861639062822336, 0.165138968156319, 0.6226708024956911, 0.417366968601418, 0.44112564149432043, 0.2651321218453171, 0.38470455041648643, 0.3472461328635057, 0.33599987287556166, 0.34369467365056394, 0.22144443597922858, 0.12769329516089034, 0.13704005012320464, 0.1395881681576846, 0.2725381483446325, 0.19983471279834675, 0.199635281457051, 0.14202386438771353, 0.14175122370548543, 0.1620650695823922, 0.141104148290368, 0.12803332543057333, 0.1276480213371044, 0.1434631594158764, 0.145551898862186, 0.15170535060304224, 0.1389441504892711, 0.1408101995193629, 0.15846581181023467, 9.999999999998899e-05, 0.03965810470606279, 0.016736797805384063, 0.07606684026228117, 0.0651325069857438, 0.022783209145178618, 0.03250517425303168, 0.005940406396107378, 0.09209520410155003, 0.11470453412859494, 0.14688128069482098, 0.20686055486869037, 0.15843612617800396, 0.09475009402411128, 0.06142817138366319, 0.19431615716004658, 0.15673155500181235, 0.09303714834640997, 0.013099090139893854, 0.05912644225124897, 0.038017696016279134, 0.016607707921895032, 0.023353022272773027, 9.999999999998899e-05, 0.04595852288135105, 0.037981862811637845, 0.03141111023208576, 0.1275054359850486, 0.12391575614969152, 0.09361811283765986, 0.09701937071861921, 0.12978148069607054, 0.12631203496974142, 0.13161091270708747, 0.1355694784646443, 0.08583328285012215, 0.37725888678577935, 0.4070505762936144, 0.3978127892920966, 0.40743555636964457, 0.4269729447967857, 0.3925117433977743, 0.40871382924123123, 0.4005404889657327, 0.397903039418915, 0.13107361736407563, 0.13949512189888102, 0.08386228451087285, 0.11478218670458451, 0.10500396079717611, 0.10158695687619768, 0.09277643961418036, 0.08837082238430194, 0.07497838302088566, 0.1655716857685665, 0.1363221454505532, 0.14950271022815287, 0.15775609423321946, 0.13382947418309832, 0.17453546406540665, 0.1964255783473734, 0.16775002155141083, 0.15647741445793395, 0.29289323504798026, 0.2850103296976315, 0.3185661269789949, 0.29134792951196786, 0.2916050193798998, 0.27002663760816714, 0.28747942604546184, 0.2771760919356405, 0.3050745410163096, 0.22347707128550887, 0.21668044850860357, 0.23193980944912507, 0.2255300512487941, 0.2148466427053446, 0.21919845706960206, 0.21565963463562798, 0.24238675460492065, 0.2018185072208365, 0.19770793652619612, 0.18348187771658886, 0.18954864346497602, 0.24733103068180284, 0.21143201444896054, 0.19647873283098738, 0.1893049481853517, 0.18385559021878584, 0.22610991772838018, 0.28674742453595947, 0.20684079551919754, 0.21348318270401556, 0.1963464888864339, 0.22143315787436124, 0.30237928284366244, 0.32123973924094973, 0.32147081184339443, 0.23105736007552868, 0.18050736975140957, 0.16036057633539547, 0.46854349649874105, 0.5996670270168748, 0.7521068019568349, 0.1657210408324188, 0.1384144079462487, 0.16326653680276837, 0.575662914094915, 0.547651714050521, 0.20575186941130397, 0.31210528826336326, 0.198409515699549, 0.16156360450357166, 0.18803872297191992, 0.19884027079957545, 0.20356274305672428, 0.5585343371181386, 0.1668523387408588, 0.18405041248632847, 0.1625007842926538, 0.18261618930926038, 0.175054349997104, 0.17331062992136448, 0.1905624342449339, 0.19715369716810138, 0.17581111080666612, 0.08372985801145083, 0.07782196074270031, 0.08555046133633037, 0.08336683488688323, 0.08175269004109964, 0.07498608371512983, 0.07831338000177834, 0.0773434971760586, 0.08113036908477245]}, "mutation_prompt": null}
{"id": "8bf430e3-9100-42e7-a1ce-9bf23f6f4eca", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.2\n        self.cr_max = 0.95\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.05\n        self.chaos_control = 1.4  # Adjusted chaotic map control parameter for better exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)  # Simulated gradient using random noise\n        step_size = np.linalg.norm(grad) * 0.01  # Scaled step size\n        return sol - step_size * grad  # Gradient-based perturbation\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1  # Enhanced chaotic map\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Gradient-based Perturbation and Enhanced Chaotic Control for Improved Convergence.", "configspace": "", "generation": 39, "fitness": 0.25866353596271396, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "3af524a8-f77f-4409-949e-9663fa806962", "metadata": {"aucs": [0.5711435650394514, 0.560055581738041, 0.5627031347909882, 0.5530190370054839, 0.5504985326315139, 0.5463844338464043, 0.5583769687885503, 0.5620592955423884, 0.5648692543756277, 0.36238650068913936, 0.2509851922037156, 0.2619267176025266, 0.30887037645383886, 0.2600879851345653, 0.2740211178983545, 0.2692012988138437, 0.24191932889257672, 0.25915720744828963, 0.26467089927633747, 0.25159318690605115, 0.2657811228787248, 0.17192160774704957, 0.25715742921755846, 0.2406058007955636, 0.2705556718659009, 0.2365154096981169, 0.289830992587813, 0.13096711548220685, 0.11242013963274966, 0.23523364196206253, 0.1299426729137002, 0.16508027257967983, 0.14243663998053524, 0.12831794426282928, 0.22948607373537455, 0.13967560930954281, 0.9057977179908786, 0.8826411684134324, 0.9250421754973771, 0.877771305336053, 0.9259797525807697, 0.8766766234856069, 0.848388958551706, 0.9196030398285325, 0.9166339383759333, 0.2562409399380443, 0.2640475573946731, 0.27172239261667097, 0.2786016517270774, 0.27614401730835225, 0.29096758790597455, 0.2687645012109362, 0.3088989185423108, 0.2472426551427771, 0.46411813025198423, 0.6923031206704908, 0.3183446396746319, 0.2551472680671114, 0.2529799891573222, 0.2065095196632587, 0.21545242816973587, 0.5467310975718249, 0.29196515876660967, 0.1095438153402829, 0.11955750991455738, 0.15673119761280374, 0.2656197540739733, 0.19957406088824592, 0.11768063636948622, 0.16946711480086085, 0.12142954439405507, 0.29880637855944026, 0.1427996291179977, 0.17640973250821612, 0.13913701178455706, 0.14859629126610852, 0.1519698402582852, 0.19656893307425738, 0.16572599315737302, 0.11863890413243239, 0.14910161208148875, 0.00873201925654743, 0.06175901713288823, 9.999999999998899e-05, 0.08375966818375724, 0.045588827498272755, 0.0586810939632576, 0.04979647923301023, 0.016014438863847347, 0.019153647781663174, 0.14676039615387249, 0.0788997306352126, 0.07385013340191071, 0.08932152774446622, 0.10109752744333944, 0.1554889839653686, 0.1070460356201216, 0.18940559616444486, 0.22688408539890037, 0.07299186623629261, 0.0505754766015567, 0.05372721979662476, 0.058661217534491716, 0.029426388434288908, 0.05789939671798716, 0.05932960487397687, 0.10239481598772693, 0.061486185705624474, 0.15022276251506705, 0.15443423114496801, 0.10207821021659491, 0.152311471095125, 0.10529794276733351, 0.1384223395680667, 0.12287859757391484, 0.1546397525502391, 0.13733189328482442, 0.42812645993037723, 0.4520363382812618, 0.43489924629186993, 0.4509037827431627, 0.45263054900695554, 0.43880359082441234, 0.4518184459583867, 0.4528871813683012, 0.48024041734783796, 0.24994026428436966, 0.08977617227778356, 0.11808605162475272, 0.13532598588357592, 0.13809705916068138, 0.11587279769845049, 0.09685108728893987, 0.09388741675395973, 0.12330086389567951, 0.2014395460012881, 0.20341744406140494, 0.15235133525571432, 0.1663141289935245, 0.16994673384827697, 0.19511319547812367, 0.2074633583591322, 0.1782165088306289, 0.1817772519832468, 0.28968865199710025, 0.31989741093210555, 0.3231808513505171, 0.34117782214459613, 0.31193613605595705, 0.32089870500481665, 0.3250095158523667, 0.32636528004156184, 0.29927102529672034, 0.19438835574251556, 0.24502140561500452, 0.2326840891960532, 0.24802622570529642, 0.2016081289129812, 0.26539402315079164, 0.1974811539374033, 0.26885998223444274, 0.2677222350661588, 0.20306439311580848, 0.1908053307622064, 0.17849141465810625, 0.208144863099209, 0.20055749574041126, 0.25597317190140023, 0.18762809932643254, 0.1889911974802745, 0.2187799171746294, 0.3327603176789472, 0.20044811877417257, 0.2176119265457206, 0.2299297962368082, 0.30595910727469633, 0.20841397472249168, 0.237133312493647, 0.3326610073900812, 0.1975622208604676, 0.19390883456927743, 0.16283604203819702, 0.37549602481333133, 0.18530770518444073, 0.5597618666037324, 0.6505067667840435, 0.5608780389452424, 0.1655739991973143, 0.788516513801935, 0.48828593128498377, 0.16831607412903782, 0.6073132188319155, 0.1977208114126412, 0.1576700352605792, 0.19202292150770395, 0.4687675895670177, 0.19297381099108835, 0.25551604430673647, 0.18684481655270058, 0.18064928013793347, 0.17150179058727788, 0.17226621755844496, 0.16615975282186368, 0.2124736723016899, 0.16716511687092428, 0.1887554764830094, 0.18594463274818818, 0.08683533788034314, 0.08566107155565883, 0.08136667581007273, 0.08273705063594827, 0.08418227381514676, 0.08627384321728693, 0.07660644622554469, 0.08399163479659477, 0.07910601786719196]}, "mutation_prompt": null}
{"id": "fb9ec83c-a5a6-4342-9b0c-2d42d65b6e33", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.2\n        self.cr_max = 0.95\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.05\n        self.chaos_control = 1.4  # Adjusted chaotic map control parameter for better exploration\n        self.dynamic_resize_factor = 0.05  # New dynamic resizing parameter\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)  # Simulated gradient using random noise\n        step_size = np.linalg.norm(grad) * 0.01  # Scaled step size\n        return sol - step_size * grad  # Gradient-based perturbation\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1  # Enhanced chaotic map\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def dynamic_population_resizing(self):\n        entropy = self.calculate_entropy()\n        if entropy < self.entropy_threshold:\n            new_size = int(self.population_size * (1 - self.dynamic_resize_factor))\n            self.population = self.population[:new_size]\n            self.population_size = new_size\n        elif entropy > self.entropy_threshold:\n            new_size = int(self.population_size * (1 + self.dynamic_resize_factor))\n            additional_individuals = np.random.uniform(self.lower_bound, self.upper_bound, (new_size - self.population_size, self.dim))\n            self.population = np.vstack((self.population, additional_individuals))\n            self.population_size = new_size\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n            self.dynamic_population_resizing()  # Apply dynamic population resizing\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Gradient-based Perturbation, Enhanced Chaotic Control, and Dynamic Population Resizing for Improved Exploration and Exploitation.", "configspace": "", "generation": 40, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 41 is out of bounds for axis 0 with size 40').", "error": "IndexError('index 41 is out of bounds for axis 0 with size 40')", "parent_id": "8bf430e3-9100-42e7-a1ce-9bf23f6f4eca", "metadata": {}, "mutation_prompt": null}
{"id": "d988a932-d118-40ba-9e67-7bf12a63f496", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.35\n        self.f_max = 0.85\n        self.cr_min = 0.25\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.06\n        self.chaos_control = 1.6\n\n    def adaptive_parameters(self, eval_count):\n        # Temporal adaptation based on the evaluation progress\n        f = self.f_min + (self.f_max - self.f_min) * (1 - eval_count / self.budget)\n        cr = self.cr_min + (self.cr_max - self.cr_min) * (eval_count / self.budget)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim) \n        step_size = np.linalg.norm(grad) * 0.02\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * np.sin(x) + 0.5) % 1  # Modified chaotic map for diverse exploration\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters(eval_count)\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Hybrid Quantum-Inspired Differential Evolution with Temporal Parameter Adaptation and Dynamic Gradient Exploitation for Enhanced Solution Exploration.", "configspace": "", "generation": 41, "fitness": 0.21391767109832177, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.21 with standard deviation 0.18.", "error": "", "parent_id": "8bf430e3-9100-42e7-a1ce-9bf23f6f4eca", "metadata": {"aucs": [0.47465879535891076, 0.49434079610488946, 0.4856032959277522, 0.48150433078828325, 0.484503457901326, 0.47120684031902527, 0.4806386349938412, 0.4853867947908137, 0.4862223996264028, 0.24881213253667034, 0.23673962806231574, 0.21033671086824024, 0.2193709079206817, 0.21325283997723166, 0.2714468123458378, 0.21296750756996685, 0.25607938924063733, 0.21999866422040304, 0.22785225901409345, 0.18683853143780493, 0.2279742533290111, 0.2545653360777371, 0.20030784664682888, 0.2391395571491487, 0.2226163874457061, 0.21160480023814754, 0.23056353522167117, 0.1730584070666943, 0.18525014144909335, 0.20897014177461093, 0.22535945832386417, 0.16277836290620595, 0.18690896341698204, 0.2045938864009812, 0.2288868944311061, 0.19642261544992057, 0.9073112098571201, 0.9166561689724111, 0.9208157784157502, 0.8832893396284973, 0.90027596361139, 0.940348841975594, 0.9053369965292812, 0.9026243902704995, 0.9161041910435284, 0.2047606545729559, 0.1975730654174297, 0.22988594280443653, 0.18335598712045398, 0.19647209272276223, 0.21956365832033875, 0.16426795195341237, 0.19521449543735203, 0.19929599386167662, 0.21619351507530105, 0.2017162413846716, 0.21196527619222594, 0.26078891844644636, 0.22907528988526715, 0.39797491420167785, 0.21127077345678547, 0.23855754409738072, 0.19088594913261892, 0.12827460872343832, 0.20368159941394048, 0.13445269915726588, 0.1713322489778749, 0.1491112148593856, 0.12770023518394102, 0.13857940419592318, 0.13844468667546406, 0.14341176404282052, 0.12804226669418373, 0.11811946256215655, 0.11686779801131653, 0.13453130751845255, 0.1578514321215274, 0.13325763514805222, 0.12782748935429977, 0.11457088325444453, 0.09752760599780108, 9.999999999998899e-05, 0.0001637430053027522, 0.0020751760435278044, 0.008245417581715597, 9.999999999998899e-05, 0.0030041057789119696, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06063223097026804, 0.07569699682693265, 0.06446804008437756, 0.030419808455292907, 0.07524747329237602, 0.04508045629754265, 0.10108655123730792, 0.06628723368524247, 0.08054455146964423, 9.999999999998899e-05, 0.020110682508804767, 0.011864495140178732, 0.011396529893319185, 0.00020309298310472457, 9.999999999998899e-05, 0.010077677393499518, 0.001739561716651572, 0.007150797412371901, 0.1134190131682763, 0.0774053026441407, 0.07876778028018994, 0.06519978011458805, 0.08434574889679625, 0.08560758912722666, 0.08583715129571334, 0.08102955187987193, 0.07282952347233496, 0.4125988413613644, 0.41790056415401844, 0.435503019876615, 0.39952869708629646, 0.4082399903911159, 0.4015956098834449, 0.4115952651329998, 0.39304939612905476, 0.40599979798593033, 0.09396072480897533, 0.09941158449771537, 0.08787408573257793, 0.08213156574084224, 0.08276122692938737, 0.08127207120628355, 0.08022404730137456, 0.10716245858914097, 0.08237126088259261, 0.13242285294616463, 0.13337207254549377, 0.17344221823812733, 0.14895582259391427, 0.13116235364709883, 0.14435171035991456, 0.1988168003987334, 0.12614201030805394, 0.13871536061074585, 0.22161326426511918, 0.26778695564913746, 0.22632385690218038, 0.24116868558122628, 0.2640191905377547, 0.25714319378285344, 0.26292153934591733, 0.28338635541939183, 0.2755635842416072, 0.17576433098288302, 0.19887944087806286, 0.1662385834569552, 0.1718464950663633, 0.17762278724952374, 0.17770517569474742, 0.1627822904060291, 0.2060167239250814, 0.1668815296530216, 0.1767013714250374, 0.1895641176521895, 0.1875615227182842, 0.18321538544290839, 0.20891025240324068, 0.16145102215346308, 0.17062468086900084, 0.1958232721266041, 0.18139190541236216, 0.298180193567935, 0.2234632033342111, 0.197732791848381, 0.2181352323839263, 0.21307973085856213, 0.2938027877535495, 0.21776613385016907, 0.2447926113652784, 0.1987854476346539, 0.23544004764978932, 0.1815626570161254, 0.25943574026449956, 0.31869804896093623, 0.2680004555112403, 0.39416086111650206, 0.16632208235334078, 0.22611851061939325, 0.28396644075853017, 0.21914314614761077, 0.20369836318089907, 0.23456990399546562, 0.1987955584539567, 0.1718398486558479, 0.23459725608491122, 0.19929660187227005, 0.2115420453835093, 0.19582622190918342, 0.1714018661718104, 0.18787317001260295, 0.18945519057665128, 0.16828027219453523, 0.17106496918960534, 0.20004555012073277, 0.17439751213606647, 0.17950484217007756, 0.17620572336183016, 0.07706525629391836, 0.07310589441625981, 0.07286733326940942, 0.07135292748474809, 0.08450458741082623, 0.07172212685946688, 0.07421926858842476, 0.08678615123554323, 0.06558060536749577]}, "mutation_prompt": null}
{"id": "95a08c9c-48fc-42d1-ac2c-afb9e1573b44", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.35\n        self.f_max = 0.95\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(3, self.population_size // 8)\n        self.entropy_threshold = 0.07\n        self.chaos_control = 1.6  # Further enhanced chaotic map control parameter for diverse exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)  # Simulated gradient using random noise\n        step_size = np.linalg.norm(grad) * 0.02  # Adjusted scaled step size\n        return sol - step_size * grad  # Gradient-based perturbation\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.05  # Improved chaotic map\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c + np.random.randn(self.dim) * chaos_factor), \n                         self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Mutation Strategies and Improved Chaos Control for Robust Convergence.", "configspace": "", "generation": 42, "fitness": 0.18615365770217276, "feedback": "The algorithm EnhancedQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.18.", "error": "", "parent_id": "8bf430e3-9100-42e7-a1ce-9bf23f6f4eca", "metadata": {"aucs": [0.3967497446249225, 0.3997581117285063, 0.396886897125043, 0.41622764684913127, 0.39491183972916577, 0.42083199152255224, 0.3874024883407957, 0.40896170037588353, 0.40258839217935394, 0.06855359878462497, 0.08432819855699714, 0.06882500980605677, 0.05938480095729792, 0.06962470503382778, 0.08647086781256819, 0.07786239342015433, 0.0678375253572382, 0.08061490507105118, 0.12924152608810668, 0.11197991034958099, 0.11443513532847915, 0.1067072407332158, 0.10434292646543941, 0.1281534968684538, 0.12088533126529166, 0.11142852385552648, 0.10878543915517835, 0.09647498683003652, 0.10787458597434707, 0.09455020457015895, 0.10567455616342936, 0.09940695602837746, 0.11176016175111214, 0.10926669598206318, 0.10090336813404233, 0.0927846336221706, 0.8800171895724822, 0.9360389393591737, 0.9106416471147317, 0.9745168896825845, 0.9484398699703858, 0.9199238211370616, 0.9218683553224605, 0.9358166492276342, 0.9334495694684728, 0.17146506941610606, 0.1630704355581265, 0.17650144255592493, 0.19634747045781553, 0.18689126635247832, 0.20346309465038925, 0.20334072345722876, 0.175733978707035, 0.18858449886921402, 0.21994282336754567, 0.20680471228940855, 0.224501509413228, 0.22525261685824116, 0.2249716832171127, 0.2650628725554629, 0.22100981220765947, 0.25084392102362585, 0.2320184438609817, 0.11478619393510203, 0.1063891509809124, 0.11874426398265625, 0.13028686330457784, 0.09654387920394669, 0.11547673375388678, 0.13633498416742473, 0.12768684280551856, 0.11745435269106963, 0.09643577268178671, 0.12641194889324925, 0.12602436023125574, 0.11359224408758495, 0.1140183995791374, 0.12780994247112698, 0.09253972334732186, 0.10556796627361942, 0.11813618412474591, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.01933733393427628, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.050862278055521126, 0.06814489737686291, 0.05533423869184795, 0.048723430778395804, 0.06664200015511124, 0.05198155386239267, 0.05666602926741271, 0.08904391108997622, 0.07669590025711637, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06117796879537818, 0.05729007337618186, 0.06987800112314924, 0.06299352955902449, 0.06370321152074099, 0.07298827045777179, 0.0566752372078585, 0.068460744875248, 0.08594047960733264, 0.35428476433085976, 0.3491316440436192, 0.3721263043860853, 0.359103779511474, 0.3691166842270025, 0.3612356996056094, 0.37601994952469064, 0.36070314795471903, 0.34646516714262376, 0.09076518399635791, 0.09036488414484611, 0.08597295149610074, 0.07646481703342889, 0.08795150363940085, 0.08031523066816659, 0.0873278291687446, 0.0859819648301996, 0.09585868698335431, 0.12640194714251463, 0.15800047922145244, 0.1499590345641394, 0.12705312546170988, 0.14166484511570254, 0.14115303740262353, 0.15107784253942513, 0.11445431578550036, 0.14292089581161416, 0.22713439184968343, 0.24342515066952797, 0.2433149079548983, 0.2448675793001721, 0.24834923763237138, 0.2480557402961011, 0.23954682929692594, 0.2483523807596586, 0.2558697109931013, 0.18573070929781255, 0.15730887923877124, 0.17283446745074182, 0.16342170806568612, 0.1590855454525798, 0.18304313984632525, 0.16873428255985323, 0.17749308552573506, 0.17619775965467854, 0.17557529672696615, 0.16406334354597052, 0.16189945911737091, 0.18861400418998053, 0.17165368019081884, 0.18888403618238536, 0.1842997708099744, 0.18272485121508897, 0.1781430962449958, 0.18340596433624445, 0.19079346593983093, 0.17890615595900383, 0.17528752848542462, 0.19405694602883117, 0.18240188149782788, 0.2034637603353764, 0.17303683634967149, 0.18140521923831088, 0.20125141133679803, 0.1702281877302707, 0.39084063501020405, 0.17213074704570785, 0.15857843893483858, 0.356668353318471, 0.15493118633936942, 0.21559659809707787, 0.16079375735770152, 0.34770545990841917, 0.17906792978796893, 0.16331274815839047, 0.21891940846510638, 0.1909378546939915, 0.18272966210921948, 0.263628107110472, 0.3455714980311382, 0.19624663309831636, 0.19465962551234084, 0.2019171983885839, 0.18575916928639624, 0.17157814251291326, 0.17646282586029594, 0.17231868604770284, 0.1794958850522278, 0.16980333764805278, 0.18967655671133166, 0.0624393277559846, 0.061740390145654245, 0.07197356351916673, 0.06918317905410476, 0.06677361583710884, 0.07297805158277204, 0.06799203241872387, 0.07221447114450275, 0.06235417206805671]}, "mutation_prompt": null}
{"id": "a655fd5e-74df-402a-b649-c09c5016c02c", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.85\n        self.cr_min = 0.1\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.05\n        self.chaos_control = 1.3  # Slightly adjusted chaotic map control parameter for balance\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.02  # Adjusted scaled step size\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1  # Further enhanced chaotic map\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Enhanced Gradient Learning and Dynamic Chaos Control for Superior Convergence.", "configspace": "", "generation": 43, "fitness": 0.2509889737804221, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "8bf430e3-9100-42e7-a1ce-9bf23f6f4eca", "metadata": {"aucs": [0.5061563109872209, 0.4872412573374908, 0.5102540886816174, 0.5092161204239103, 0.503820868435896, 0.4947612271896513, 0.5147234368354977, 0.5480793246460234, 0.48281066229411207, 0.272718573040046, 0.28966356663988146, 0.27469929490718525, 0.2707537898468363, 0.26681397162348197, 0.30422088379413803, 0.2632174922722358, 0.2838784529678089, 0.2963543132054415, 0.256675626623282, 0.2738805392206336, 0.16254200247204675, 0.16690823163821367, 0.2751669104714779, 0.1706263840184552, 0.27356695104312734, 0.23831152211257645, 0.23491792530916877, 0.13130541798007966, 0.2956275837253335, 0.1461763580286799, 0.16140252240752873, 0.1690637562010101, 0.1434118621956726, 0.12046593658732507, 0.2363373855530163, 0.19311797453764368, 0.9150453637675589, 0.8993052436637666, 0.944988997418952, 0.875369540462245, 0.8758260155037476, 0.9124530481652592, 0.872517135665688, 0.8984275674586828, 0.8957300420955556, 0.25717812179472144, 0.263144792119554, 0.24496525049207052, 0.2723398768312658, 0.15078981490231036, 0.2595567073097669, 0.2574167208121567, 0.18055144840625237, 0.2320049696309946, 0.4670774067740575, 0.46084295952608356, 0.23661167179997655, 0.6181222014414018, 0.5093821243692292, 0.2580391967331994, 0.633242858245475, 0.5007915239593099, 0.20938215038022057, 0.1465836125997716, 0.12366724158576092, 0.14033346794044843, 0.1479996263799207, 0.15094108278534346, 0.23319156031267385, 0.17996856608429568, 0.14540335586583386, 0.1910800479517416, 0.12826741376251138, 0.16036065259704135, 0.2252289617468417, 0.13726977597940226, 0.19923513924590264, 0.1448647837380429, 0.13655508019828289, 0.11494661885903112, 0.14403943860308843, 9.999999999998899e-05, 9.999999999998899e-05, 0.04126201689503939, 0.021580445873251808, 0.03183418537217819, 0.0188847410199795, 9.999999999998899e-05, 9.999999999998899e-05, 0.08017224270548262, 0.10722252320886927, 0.06240990558561921, 0.16317627353386654, 0.07196583571640025, 0.06343592850540003, 0.053918698274591614, 0.13293372822809546, 0.13954935418092118, 0.1577908308702487, 0.014471847382650282, 0.07902080692793201, 0.021597442443043846, 0.0033253228599805507, 0.0716777088603423, 0.04518407476629094, 0.032213095386886326, 0.08487244082040413, 0.03260018508151241, 0.14757334115926735, 0.1440899091224419, 0.11738899015871063, 0.1408096170516292, 0.1018543010488544, 0.15294605672300587, 0.07967733053331993, 0.09826356674844883, 0.09627951326575368, 0.41352731797976383, 0.43092188096569306, 0.47072765950174433, 0.4367452918331093, 0.4349893369048985, 0.4280621426180884, 0.4399825628428523, 0.4338203260307609, 0.43097688820863034, 0.12940724438727136, 0.1477429183348199, 0.12839471272852565, 0.1315297604274832, 0.13147280721541288, 0.1499625266792255, 0.10285463280808849, 0.10625365504763873, 0.1448480685340484, 0.2426974267633475, 0.17449995212658864, 0.17555992879306237, 0.23006693796550048, 0.15599545730478548, 0.18944536635920683, 0.18040667712483704, 0.16030274692434865, 0.18778938891616215, 0.28376412784365224, 0.29780639550998855, 0.2693658459606546, 0.306674036588758, 0.2915613923371899, 0.27600299698604447, 0.3134634975368963, 0.32112948522477514, 0.29673881784603395, 0.2077754006678456, 0.2222558677265739, 0.1850093329774083, 0.1678396969412983, 0.23744692100951448, 0.23265212197705476, 0.2131826940028425, 0.2286639019937282, 0.20631196265965834, 0.20487172874009152, 0.20672959904107158, 0.18196504785759615, 0.20030307196323216, 0.20021483169250665, 0.18454486606591536, 0.18781147061046555, 0.19488721176343682, 0.197654383834318, 0.22654939222077708, 0.22302697242130398, 0.23256543362476334, 0.29315129992108224, 0.2125565816611128, 0.2072279348791337, 0.2338374654124059, 0.1968888842463783, 0.19015480464725432, 0.3832928435264511, 0.5913431606443259, 0.16854390927372065, 0.44193358944020933, 0.6976454409370221, 0.6675519080751411, 0.5948522287600921, 0.16787381878793917, 0.18345652334516493, 0.5384586037118924, 0.27432624149110196, 0.30402169365747056, 0.1885417613811078, 0.1643769044925688, 0.18837776073693935, 0.14567079281492878, 0.17058961262816608, 0.510157148721128, 0.1707800296709353, 0.187367232780826, 0.18137250918602021, 0.18596421274968478, 0.17640625729137516, 0.2330029799625971, 0.19249589703201564, 0.15996709335302584, 0.18689833356711993, 0.08645173171422371, 0.08809769413314683, 0.07102722638388492, 0.0750652006171314, 0.08352251293092228, 0.09979908634968848, 0.08654244572244985, 0.0754230421352533, 0.08054185531725411]}, "mutation_prompt": null}
{"id": "eb29cd6f-649e-46ea-9caf-d5b0ec271bfe", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.2\n        self.cr_max = 0.95\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.05\n        self.chaos_control = 1.4\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.01\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(4, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Gradient-based Perturbation and Enhanced Chaotic Control for Improved Convergence and Dynamic Population Sizing.", "configspace": "", "generation": 44, "fitness": 0.2679594574249854, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "8bf430e3-9100-42e7-a1ce-9bf23f6f4eca", "metadata": {"aucs": [0.5531121901368425, 0.5577698121993251, 0.5674820197101971, 0.5490569454821099, 0.5691193787540556, 0.5548278105453581, 0.5673231689782887, 0.5485622827179699, 0.5539949385103443, 0.24508601495031246, 0.30042162686375073, 0.2494319777766928, 0.2794108566421466, 0.2764136535034013, 0.24746296188988304, 0.29004646602074546, 0.2618469354336822, 0.25115905840764385, 0.17788750123922237, 0.2829888985556319, 0.28906665887997784, 0.26689915399354947, 0.17091733302638823, 0.28710182244685534, 0.25493328791594194, 0.28928591501715495, 0.25348097101755906, 0.1153034096080171, 0.14373488091537656, 0.1655865413677069, 0.27574137859196457, 0.1559293649511212, 0.1248117854527312, 0.11594783140799514, 0.14640073486791483, 0.15610245988900318, 0.8809791408809365, 0.9069408690392022, 0.9267012264600863, 0.8930855114623794, 0.9057746770863142, 0.8982853306577484, 0.9148365793714504, 0.8873189045537799, 0.9066510784128421, 0.271010931643071, 0.23370964268171013, 0.3310714614917084, 0.35345204646796347, 0.21420760915618753, 0.2418304305829514, 0.3011832646934407, 0.3180548345231258, 0.30936742355258984, 0.21635092567603476, 0.312504462674725, 0.13440522039067582, 0.7075113474059385, 0.7541870733477907, 0.701729910084324, 0.5581107096313465, 0.22245944226094994, 0.21523010958846667, 0.28624729574024155, 0.1235429436284734, 0.1846250579694727, 0.16173733638964838, 0.18429878653129494, 0.17310253584641921, 0.24368214061395232, 0.18069160594177303, 0.19322544390200036, 0.13689151185632908, 0.21714240359085224, 0.13576692528614076, 0.14883593769374126, 0.17047838645338487, 0.12549564021522364, 0.1795062514631165, 0.14104504034462206, 0.1468173371545889, 0.08738780541777491, 0.07457139200753715, 0.03662680379569372, 0.02078506881701292, 0.03083239235501256, 9.999999999998899e-05, 0.05096153326836306, 0.01740824226997939, 0.026109149903025042, 0.16150512233343728, 0.19591665185079188, 0.15492613364625285, 0.051707295699680245, 0.17660562491380438, 0.03916284231938849, 0.17229518691846335, 0.12370288028473098, 0.19241538985399187, 0.02899445826843583, 0.0636233265356223, 0.023082855836670246, 0.044197667490547654, 0.047219652366479736, 0.059719959201863126, 0.04822628483713853, 0.02031253897520824, 0.053306743727030925, 0.1480672085886494, 0.13788086074392503, 0.08062058362424396, 0.10764977194530334, 0.15937492832732947, 0.14046515381132485, 0.07657142444161613, 0.09799506565746019, 0.11919131245198133, 0.4466731842514202, 0.4628878865142313, 0.4494934660189063, 0.47568237611711606, 0.4769301986721375, 0.44300218149617643, 0.47370628903958467, 0.46185491165640535, 0.44819879895657444, 0.09793966177579727, 0.1241740245734052, 0.122960518811974, 0.1343235544037381, 0.11986289834097574, 0.150807271993605, 0.07728432053059164, 0.1427778022337043, 0.10037334119677055, 0.16048754137367982, 0.1555897575661891, 0.132778476567319, 0.18316237633655008, 0.20970846633613405, 0.20120731682296722, 0.1655071253635364, 0.21081831732372935, 0.18654009867509658, 0.2765849159904614, 0.3314577191636311, 0.276511344903695, 0.27013486686152144, 0.28355173169862113, 0.3200438191770709, 0.31736835982254497, 0.3293731466076739, 0.31746307243429506, 0.24148641112444702, 0.20884939864241725, 0.24642036367190623, 0.25981154302992493, 0.259534798214321, 0.24876988299943248, 0.22538698428676662, 0.26043952500838463, 0.23665704506691176, 0.1889075341965737, 0.19322672861381218, 0.20413000756239075, 0.20903170902281598, 0.22129706257409132, 0.21759144194392155, 0.20227354051408153, 0.19532315383415422, 0.19223022864902695, 0.3972921538205927, 0.21435921044219353, 0.23744993314325458, 0.2123833566491078, 0.3837410354994054, 0.23828387729231182, 0.19741202214531095, 0.21304675942650675, 0.32930397219763397, 0.20117699216016094, 0.18213607717715918, 0.5153596386697801, 0.7398714672105352, 0.6925982674403495, 0.7516400098630593, 0.1676459341287453, 0.16592467735763095, 0.8070360995941517, 0.6426815827924206, 0.6652799595248369, 0.6473558189223265, 0.5473486352622141, 0.1630341837445889, 0.1550820239180406, 0.16022185030304203, 0.19533553349407262, 0.33727311846080243, 0.1884653312373964, 0.1812940427480091, 0.17451222563484137, 0.17101801965689978, 0.1760144539709243, 0.17489684963943697, 0.18655204726407548, 0.1839362639020763, 0.17842767596175946, 0.0694241704333286, 0.07983278836947305, 0.09015373391566206, 0.08768573486727071, 0.08553715249416927, 0.09658539527450705, 0.07366355045825435, 0.07655558381438021, 0.08157501039928305]}, "mutation_prompt": null}
{"id": "d87b5662-f231-4446-bdea-7744e28c61c1", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.2\n        self.cr_max = 0.95\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.03  # Adjusted for better exploration\n        self.chaos_control = 1.4\n        self.alpha = 1.5  # Lévy flight exponent\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def levy_flight(self):\n        # Lévy flight step\n        u = np.random.normal(0, 1, self.dim)\n        v = np.random.normal(0, 1, self.dim)\n        step = u / np.power(np.abs(v), 1/self.alpha)\n        return step\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.01\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor + self.levy_flight(), self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(4, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Integrated Lévy Flights for Enhanced Exploration and Adaptive Entropy-Controlled Convergence.", "configspace": "", "generation": 45, "fitness": 0.16175371278237347, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.16 with standard deviation 0.18.", "error": "", "parent_id": "eb29cd6f-649e-46ea-9caf-d5b0ec271bfe", "metadata": {"aucs": [0.29468591562690927, 0.2881906937828749, 0.27720197677155234, 0.29829803934894694, 0.30457082903839605, 0.2847869308347942, 0.3441788601590424, 0.30560577386632615, 0.3035972171847735, 9.999999999998899e-05, 0.00013521809360295123, 0.0004448322359854595, 0.01761266177899401, 0.01638059819890858, 0.0008618480702947684, 0.022977950659118895, 0.012340608685393772, 0.011674773198680488, 0.10502211437694697, 0.10445274617828493, 0.10016079529298927, 0.10214254470528483, 0.09306590386006286, 0.09634618034242559, 0.09431097858984083, 0.0952434723561828, 0.10426254720090111, 0.08155967273668963, 0.09350218358684725, 0.07209717310873243, 0.09185570976000779, 0.08101166516222291, 0.08237369091487012, 0.07930348946226162, 0.08088024699283136, 0.08950022807009916, 0.9115443306756902, 0.9187523475789628, 0.9258449931443409, 0.9484081512237251, 0.9404223815874084, 0.9622428791679158, 0.9149685514896573, 0.947589362119783, 0.9368874355381033, 0.1307315118987683, 0.11885414574950193, 0.12463087082217639, 0.1510437425319886, 0.1461980479239059, 0.13193717221541668, 0.13741806475111518, 0.149498806295973, 0.14250248997646542, 0.1779454343703334, 0.16467051586860249, 0.15935255035241913, 0.18280218566720174, 0.19750583928245724, 0.2212252581107056, 0.22815234281897612, 0.18480408941370796, 0.1922653535052854, 0.07406355402935783, 0.0777729427923689, 0.07195408698327588, 0.07050665770968423, 0.08860187565263344, 0.08835067849485878, 0.07530417624388297, 0.06603240262566179, 0.06156419920523426, 0.08877018016195415, 0.08029303566165324, 0.034352974783476764, 0.0858427075860202, 0.0892952674161912, 0.08518890356960307, 0.08974016270408769, 0.07885076531170576, 0.07235638490122331, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0620508025618729, 0.04455930826289256, 0.04660674397132902, 0.035307570034934344, 0.04794849405237056, 0.06039906811650542, 0.06003185126015398, 0.04403768822380283, 0.07086703566615637, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03259379614805602, 0.03175406611455289, 0.028020536604415835, 0.03916811192311109, 0.038611412768137954, 0.025609349866275277, 0.03331910897200363, 0.03187887605924622, 0.02350292607627469, 0.28865707638465643, 0.2757150124602056, 0.31218731238299313, 0.2819528481452821, 0.2868369239801615, 0.35893888971549437, 0.3022862194787336, 0.2851367480549053, 0.27198415567806267, 0.08198196948112546, 0.07314620502600777, 0.0667351305822027, 0.07464065925906327, 0.07409609940610007, 0.08518652842654151, 0.04817353609764974, 0.06549822135500039, 0.0654777898880522, 0.13344274678737988, 0.13839306750670455, 0.1278523121120193, 0.14310699272857497, 0.13565223956073935, 0.1470195468858534, 0.1431015992427137, 0.20401305694926453, 0.16266391623557408, 0.21285436425735793, 0.19716962058567933, 0.19750253492876202, 0.22049135068282943, 0.2055112945390677, 0.21616501535346166, 0.22487498158463182, 0.22104224034263797, 0.22117434355494248, 0.15097974042091644, 0.16016520744297724, 0.1430252831106711, 0.15365269371724366, 0.13322297108554648, 0.1323813790477134, 0.14932536746824954, 0.1559521070179537, 0.15295093845214092, 0.1793057169499369, 0.1685472562429826, 0.1527801983858471, 0.16923263268188016, 0.16358829741385505, 0.2061202654680463, 0.18951637224229934, 0.18136352902029962, 0.21363674157476176, 0.17153983183303156, 0.18186452256109342, 0.18068698758348167, 0.18023627929469077, 0.17538774642143562, 0.16583387874850797, 0.18222668351690818, 0.17336111436978918, 0.17228941394085107, 0.24067225730010655, 0.1759609232841567, 0.17744544439806997, 0.16160350390050493, 0.19123534001075115, 0.17384532699957467, 0.24863158730756973, 0.29390104157070795, 0.17192656910869442, 0.2243822352394148, 0.16642795735048987, 0.15566769795895818, 0.21920127544635837, 0.16232463971932032, 0.16850974490807424, 0.1889300516577116, 0.3413062949465888, 0.21588501426941964, 0.1880202827349996, 0.17720665221336274, 0.18401968359784282, 0.18575061169234275, 0.1997715951133262, 0.18423492846362766, 0.18070134641494895, 0.17207263367854952, 0.18254596402286827, 0.07046545150749173, 0.07358745544292489, 0.07045740420428703, 0.0659919849518823, 0.07206225960652557, 0.05872165541782104, 0.06035424384119037, 0.059438747809621995, 0.06986382242141409]}, "mutation_prompt": null}
{"id": "3a4e5d8d-2689-4164-9940-27aa2550e736", "solution": "import numpy as np\n\nclass ImprovedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.8\n        self.cr_min = 0.25\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.05\n        self.chaos_control_a = 3.9\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.02\n        return sol - step_size * grad\n\n    def logistic_chaotic_map(self, x):\n        return self.chaos_control_a * x * (1 - x)\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.logistic_chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(4, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "ImprovedQuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution enhanced with Adaptive Gradient Perturbation and Logistic Chaos for Accelerated Convergence and Adaptive Population Scaling.", "configspace": "", "generation": 46, "fitness": 0.2629781252662529, "feedback": "The algorithm ImprovedQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "eb29cd6f-649e-46ea-9caf-d5b0ec271bfe", "metadata": {"aucs": [0.5273101789192783, 0.4992281564834091, 0.5068620304592777, 0.5126619659594535, 0.5251652887420835, 0.5319019585447897, 0.5093454793488539, 0.5009833290893467, 0.5085015529676724, 0.2700510561701238, 0.2610557726650794, 0.2634820632806948, 0.27347413589792313, 0.26401000514227724, 0.2936658583899039, 0.2830202466591597, 0.2971145663281326, 0.25133976568845695, 0.1649657411465847, 0.22929311710935119, 0.26395554878180183, 0.1726190903120225, 0.16126659120231668, 0.23959163061196054, 0.20111991176754473, 0.2257208559441869, 0.23833758866846422, 0.16840890267988018, 0.15698012221900515, 0.16655428653455695, 0.14448152714473017, 0.13657540073252517, 0.27777874283233017, 0.1318380814255492, 0.22754956800445125, 0.11871490104867588, 0.8888185101462306, 0.9317375100010632, 0.8974389128342295, 0.8333206388138996, 0.8810333034654358, 0.892978889644916, 0.8845658226243321, 0.8984769766860949, 0.9237882059014708, 0.3053373564752795, 0.25718062391431573, 0.2927032655294882, 0.3247511301245978, 0.27461072395439445, 0.2705097012238026, 0.24832594393187968, 0.28139550429403837, 0.27196596554660046, 0.690952716463058, 0.5307050268976071, 0.5631005560643072, 0.6835418420094048, 0.5984438018919565, 0.7454736789229377, 0.6168746931226471, 0.20601663119721292, 0.5667613211903653, 0.16319815267683002, 0.21774394206961922, 0.1557060869488367, 0.14032464960814484, 0.14618373898714676, 0.2084292614537987, 0.2669368731092986, 0.16845209871409084, 0.16538243864043722, 0.14527914711134382, 0.1501086448916773, 0.11934302343445635, 0.13475023046531964, 0.14294219889177928, 0.16392645235803827, 0.15076654274688994, 0.18486261072885313, 0.19006522629649103, 0.024552789331635405, 0.042137518849471034, 0.04544645277645776, 0.02987729814455342, 0.00015972409759124062, 0.008084356437538576, 0.03688438206375266, 0.06766059015476245, 0.11573360738743288, 0.09985904225208486, 0.15475590488486413, 0.11344345065267059, 0.1014879127078071, 0.10368546873958895, 0.09382359684693675, 0.11924406788350583, 0.18547424591427975, 0.19534621210476033, 0.02580872588853822, 0.07740439417816036, 0.04074104633322839, 0.0031048244496425514, 0.09009098264637505, 0.03581764756451267, 0.0568500346106503, 0.09274209109090514, 0.05929286511754417, 0.09410780287543807, 0.15881137312037952, 0.1440164985888932, 0.12495409122191392, 0.10116485106572726, 0.11455606207067448, 0.08355778499720712, 0.10216519075787889, 0.08303797945653046, 0.4191717357478245, 0.41216603653537154, 0.4696732620141221, 0.4458074902883409, 0.43068138696414615, 0.431606389695967, 0.441418162999376, 0.4380367726459895, 0.4461478453445248, 0.11444507807030391, 0.10699816767752213, 0.0951443690832755, 0.12144367745253626, 0.10745078838755306, 0.10714919965524383, 0.1466789854928633, 0.09285745535471346, 0.11992648377839743, 0.2047328078611106, 0.1362128893409419, 0.15957276568675516, 0.20347230745257472, 0.17618104847317229, 0.14953922386200502, 0.1353555960487367, 0.16078717288453281, 0.15742196404810516, 0.3052967339519439, 0.3251987467239915, 0.27398776570807026, 0.32299738673101097, 0.33097826006542486, 0.31821417656029505, 0.3159459563429806, 0.3211386789293147, 0.3331391836251505, 0.22159076483002604, 0.27312059387896126, 0.22800023822038118, 0.22796530575548646, 0.25475477412711856, 0.25313721896026287, 0.2385462722155176, 0.24787960353767435, 0.2611986693511922, 0.1886348688154199, 0.18376723429087338, 0.20978866046586564, 0.1860068085389618, 0.21791771663976567, 0.20494347901503984, 0.20309783919085345, 0.23038232730264196, 0.20808530023619443, 0.2287317020965084, 0.31906121925575437, 0.21896815935040315, 0.20650552309365688, 0.20508856456200297, 0.21199789023162507, 0.19890920357257313, 0.22607542051437146, 0.18819246973974646, 0.7218838519534018, 0.18211105987640108, 0.18289206912262224, 0.5971956539404915, 0.5709569441518657, 0.6496881676319994, 0.13973836234543235, 0.18104823726246744, 0.7931357166107483, 0.5072397204450362, 0.2019741328460154, 0.4666614753496111, 0.1602284708957593, 0.19496427912004277, 0.4730142505226991, 0.4743171214459545, 0.20410669347360189, 0.14979081110475112, 0.17561921490660204, 0.17005775192044836, 0.16518634972747315, 0.18321800794657195, 0.19494931219418266, 0.17622034931488328, 0.1681365055462879, 0.1874241852881029, 0.17557669551540533, 0.07995146988825708, 0.08382160803963212, 0.07427658458399711, 0.08285768366404733, 0.07654257899670869, 0.08863808710779664, 0.0791355989251068, 0.08462831436499874, 0.08074750403779785]}, "mutation_prompt": null}
{"id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3  # Altered control rate range for diversity\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)  # Adjusted elite count for robustness\n        self.entropy_threshold = 0.02  # Lowered threshold for more frequent perturbation\n        self.chaos_control = 1.5  # Slightly increased chaos factor for exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.02  # Increased step size for more aggressive perturbation\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1  # Adjusted chaotic control function\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))  # Allow more dynamic size reduction\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Hybrid Quantum-Inspired Differential Evolution with Adaptive Entropy-Controlled Perturbation and Dynamic Elite Migration for Enhanced Optimization.", "configspace": "", "generation": 47, "fitness": 0.27000228475535204, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "eb29cd6f-649e-46ea-9caf-d5b0ec271bfe", "metadata": {"aucs": [0.5227151938618669, 0.5335834624822947, 0.5296806276886098, 0.5227615287109967, 0.5539247590631146, 0.5411615028670519, 0.5526231342412417, 0.5553112486383036, 0.50798760813825, 0.3426825672813406, 0.3919198118454956, 0.3544561010578353, 0.3230650730107253, 0.3154682739431398, 0.32664827955430087, 0.3141508453747045, 0.3115687324159794, 0.36609034953014075, 0.16119687889974443, 0.17466173069916568, 0.17428349196491433, 0.17279042506731146, 0.13827573483414513, 0.2595981675155117, 0.2568609430496299, 0.17186694324711205, 0.2626339172439346, 0.168523698221274, 0.11377755774118592, 0.14378459209542105, 0.251843936762825, 0.14767041694869154, 0.15142065906513213, 0.14039841237832884, 0.20196548592864583, 0.13355597968758215, 0.8381504192883328, 0.8873684362174603, 0.8740915751339879, 0.8761523179276379, 0.9085436101766399, 0.9433200498551255, 0.9098255753458766, 0.8967049288690434, 0.9254839271856327, 0.30654545764469554, 0.17837371901099008, 0.28876497394949496, 0.2454807576393333, 0.28119067446674684, 0.22386233509698672, 0.30376578536308574, 0.21089461815747823, 0.18441739722669404, 0.6447814325111048, 0.48893714672591315, 0.6489402796021851, 0.6462839336732639, 0.6693037892335997, 0.5782257779205542, 0.3853047950523095, 0.6020415262941154, 0.6452826420327883, 0.14763636683197767, 0.15552141470430414, 0.15102348838834767, 0.16169706168838816, 0.18750375779170947, 0.1251210125677995, 0.17640822166553716, 0.1381841145496575, 0.28976993379614446, 0.17118676643164144, 0.15756755257335864, 0.18487518067519781, 0.17517864844141118, 0.16034321907755855, 0.15388808359103712, 0.11799577046280552, 0.16019377636452103, 0.17264416316079856, 0.04092565345065091, 0.03094701648550313, 0.03072068441949649, 0.04732946321226972, 0.04465898221365383, 0.051831236732015395, 0.009799904308105067, 0.029256747894464974, 0.08992762058276293, 0.09302125660074123, 0.07576968379603366, 0.11840316751928481, 0.07826512677611919, 0.07429428645045066, 0.057807838094718456, 0.1463143937010225, 0.11838690169579003, 0.09224745130864664, 0.056649756179959376, 0.055674571090328584, 0.08254765185230639, 0.03859757604821612, 0.06289285605429162, 0.011262923293779759, 0.10218520085930394, 0.09127157586239987, 0.08925503272120805, 0.14114089642100425, 0.14493435607656813, 0.12915115968199642, 0.09639028904168723, 0.1572028876539413, 0.19086967797105592, 0.11498437387478166, 0.18173201957189167, 0.1573490607990563, 0.4664099422600607, 0.48038280106271647, 0.5144793820996333, 0.4491726822090967, 0.5049747758401119, 0.47726584331826716, 0.4508892849975704, 0.4605040627795619, 0.4502284953950151, 0.12865407738464818, 0.10972424549097448, 0.10947071791012863, 0.10543651032538759, 0.15773631172670088, 0.09168004499851412, 0.2667744669966554, 0.10505052056810205, 0.11059614753245428, 0.14581246960282046, 0.23058219048602213, 0.20712499171866894, 0.16425284041063493, 0.16476798460809494, 0.19201977272228665, 0.182855539707086, 0.1678034626917002, 0.1810494673564781, 0.3083066275904459, 0.24540348939242418, 0.2649886254595265, 0.3547740389034125, 0.31416525952809504, 0.27419513430105347, 0.32012622610419916, 0.33056071196386705, 0.3000937098193359, 0.22705449559039326, 0.18368561565337282, 0.22415461103203593, 0.26922050678754006, 0.21960498899489544, 0.26714715836925307, 0.22787146683801696, 0.24007305084902641, 0.27515559151341185, 0.18937547537056154, 0.21659920649856212, 0.19418187207838733, 0.2085351307893224, 0.20201112162414714, 0.19425548187222075, 0.198488074375481, 0.27190659787026994, 0.19223558409145647, 0.22796168700714248, 0.22993816749376272, 0.2081676918390466, 0.23330296248232663, 0.19464283274718697, 0.21218720764414312, 0.19258284034563677, 0.21935504706758024, 0.23461367327384364, 0.19633915065900542, 0.6402716820143204, 0.7750622876990304, 0.666121522498273, 0.19381213563210686, 0.38622205194065284, 0.13993915426656223, 0.16720987424361866, 0.7029636304734731, 0.5636408201210403, 0.20793682420251103, 0.40114197180254385, 0.16058346594883055, 0.22825273107574917, 0.5088661726362446, 0.1545412883517976, 0.5241979260456658, 0.7381468168636263, 0.18116779070563305, 0.18634643835397247, 0.1952173511927111, 0.17785760622925118, 0.1979713846958, 0.19225024244063182, 0.18678773612236932, 0.17104189709288298, 0.17269581616071505, 0.07874478631286586, 0.07651969028047223, 0.0888671322899447, 0.09056183121424055, 0.08556913541078992, 0.07665712423013715, 0.08563356846186065, 0.08922374144599887, 0.08582596696521683]}, "mutation_prompt": null}
{"id": "fd5a81d3-f935-477b-8663-cb80bbea1246", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.25  # Slightly lowered control rate range for diversity\n        self.cr_max = 0.85\n        self.elite_count = max(2, self.population_size // 10)  # Adjusted elite count for robustness\n        self.entropy_threshold = 0.03  # Adjusted threshold for more frequent perturbation\n        self.chaos_control = 1.4  # Adjusted chaos factor for exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.015  # Adjusted step size for moderate perturbation\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1  # Adjusted chaotic control function\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))  # Dynamic size reduction\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Entropy-Controlled Perturbation and Dynamic Elite Migration optimized for improved exploration and convergence efficiency.", "configspace": "", "generation": 48, "fitness": 0.2605834792387164, "feedback": "The algorithm EnhancedQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "metadata": {"aucs": [0.5480520546683026, 0.5446036347121854, 0.5296676742073265, 0.5304348783411418, 0.543663100436167, 0.5236160506796326, 0.5272064054062122, 0.545434158073417, 0.5334017618693534, 0.3046431158593019, 0.313224347786736, 0.2899970884990254, 0.3036725166958607, 0.25718466813648777, 0.3013874379788002, 0.30524235521533993, 0.2442579965257462, 0.2983348865896944, 0.25748413019259264, 0.14954082553483983, 0.1759522044777121, 0.26552858950216107, 0.1610041389104626, 0.17028642996801757, 0.2774294646618618, 0.16629670650637984, 0.1644661517142677, 0.11511315715898451, 0.16001337812585403, 0.16440181510079033, 0.12180097715919969, 0.24543924833156006, 0.2821353548421859, 0.16381796089073886, 0.1638529201157748, 0.1314800437159105, 0.9005366295326624, 0.8618967451153742, 0.922338532622644, 0.9008095180489448, 0.8776248982422057, 0.9022039391852728, 0.8975723402124809, 0.9149980986123776, 0.9238874238527178, 0.3252123920350968, 0.18803089313875332, 0.3084179513169766, 0.31303079211391127, 0.26632044092737517, 0.27558486259686055, 0.1710265025605009, 0.26763995105780036, 0.2687194797539202, 0.21699217337120502, 0.6251887227385029, 0.23365293269306098, 0.61720416823859, 0.6127975831601784, 0.7415096814748616, 0.21799277901211267, 0.22412196521189065, 0.548363551153408, 0.1183305815699246, 0.15729399917247266, 0.1506974441741724, 0.1667052295046889, 0.1628119660057078, 0.15591452927220872, 0.1668823607407941, 0.31225158300296063, 0.15187592361242042, 0.13684617008183664, 0.14394109847782233, 0.12453711969145154, 0.1486665211404654, 0.18368815500439228, 0.1718989869780071, 0.12652177632513573, 0.19347650088441948, 0.17965036076902396, 9.999999999998899e-05, 0.04898935958953077, 9.999999999998899e-05, 0.06249288452838864, 0.06220197453733656, 0.027597473672137496, 0.05018396516415646, 0.003402144902958981, 0.009852274237575842, 0.17804653995617192, 0.0977170721130225, 0.179029361690479, 0.056538462551345425, 0.061088984248518496, 0.09799107968505649, 0.13753632999420584, 0.13774621877826287, 0.21728262842585033, 0.021481713722578788, 0.10886214927019278, 0.08132093216572245, 0.03273515681773187, 0.059467491217617297, 0.027245124311951585, 0.0613354692119481, 0.042564113535734416, 0.06018243599166506, 0.17838151286487736, 0.1017752274561824, 0.1347661380947256, 0.13475393011056203, 0.14138621934081563, 0.13867074714849859, 0.1421809005419271, 0.12501394665845833, 0.13155669798178093, 0.468239329329332, 0.46322958604805375, 0.4371360625659727, 0.4737861331706217, 0.43416053141675925, 0.4494667146764546, 0.44456227242315904, 0.5197000586890409, 0.43085582509780795, 0.12077995760402771, 0.14344114211638148, 0.26552541300132504, 0.0873596816158666, 0.13497072526993903, 0.11792326652048446, 0.09686686681309853, 0.12472437520406254, 0.09198072743595853, 0.19880937779839436, 0.1720925543077546, 0.20850283607410813, 0.15658134994631656, 0.16735468380824348, 0.1533775067956853, 0.18761647231007672, 0.21182994914348663, 0.19971462843896814, 0.32900314776075035, 0.2953183742758957, 0.2930374326269922, 0.283257945314185, 0.32364900130443797, 0.33275515500532526, 0.3069446280390902, 0.33775788362339265, 0.32859085716240943, 0.23532445615294184, 0.25615514791475047, 0.2687945698696449, 0.19173349758974578, 0.25540559911350913, 0.23343141633221987, 0.23175904836299244, 0.22752682700451965, 0.29404283429928624, 0.20745434894365344, 0.20793911719705227, 0.18283946876248414, 0.19222382134125038, 0.206809761232279, 0.19946950276417885, 0.18455781953578143, 0.2006288313676492, 0.19652769754511257, 0.19877573128365467, 0.34272989987915403, 0.19757955652354986, 0.19272752757807265, 0.350612934571518, 0.19492157267642518, 0.21367765510677328, 0.227956558461622, 0.2075472997679796, 0.20096569104866835, 0.620574712865388, 0.18768386529505465, 0.5258076417839801, 0.182371536766752, 0.7000910914815307, 0.16007406253309275, 0.6797753638583743, 0.8165494983957302, 0.5192823771742769, 0.2879558978964073, 0.39378111470105603, 0.45828348369997907, 0.19783973698544455, 0.1945535819507198, 0.14670370980314096, 0.15823309846596512, 0.19701776622256983, 0.16966086754330845, 0.17678949763178275, 0.1698138164954216, 0.17349540866480784, 0.18322076752732752, 0.2163544669797438, 0.18922309756268574, 0.18625522702065078, 0.17268913833341337, 0.07816082029029892, 0.08183581041130672, 0.08933819600568571, 0.08179136559190114, 0.07667946592901331, 0.0882756030772387, 0.07233323503102385, 0.0711658431906983, 0.08404015994106317]}, "mutation_prompt": null}
{"id": "b10302a6-21ee-4cbf-90cc-c01454d428a7", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.35  # Slightly decreased for finer exploration\n        self.f_max = 0.85  # Slightly decreased for finer exploration\n        self.cr_min = 0.25  # Altered control rate range for greater diversity\n        self.cr_max = 0.85\n        self.elite_count = max(2, self.population_size // 7)  # Adjusted elite count for robustness\n        self.entropy_threshold = 0.025  # Slightly increased threshold for perturbation balance\n        self.chaos_control = 1.4  # Slightly decreased chaos factor for controlled exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.018  # Reduced step size for more controlled perturbation\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.08) % 0.95  # Adjusted chaotic control for stability\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Perturbation and Dynamic Elite Expansion for Robust Optimization.", "configspace": "", "generation": 49, "fitness": 0.25011861879167857, "feedback": "The algorithm EnhancedQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "metadata": {"aucs": [0.5126458302289415, 0.5317100936544019, 0.5301454291118515, 0.535889553142013, 0.5572637976984136, 0.5577285704415478, 0.5477057527976581, 0.5616924390115314, 0.5336270480183024, 0.35814896417134123, 0.34005970182335843, 0.3252498643522258, 0.31440340027003433, 0.3086613430935269, 0.31767383057893106, 0.38926931215034355, 0.31343485629186996, 0.33120072503688003, 0.1646819947714102, 0.1486932246897117, 0.2785772694608749, 0.2707817876509684, 0.17116775170926302, 0.16771882788798098, 0.2881548675335466, 0.27746144875964296, 0.24662089160650547, 0.165288401328188, 0.14769287291720012, 0.1433061202716288, 0.1341155556867325, 0.1777549706627144, 0.2758872580058146, 0.16246576916595712, 0.16349059504205177, 0.1340316644286893, 0.8961670509514436, 0.898418389543572, 0.8816384311453018, 0.21191226350128278, 0.9003658273772148, 0.9011445191627308, 0.8199330323810872, 0.8895558701954527, 0.8907325000557389, 0.20098241245472914, 0.19051160099097664, 0.20616630836554772, 0.2960762947740566, 0.20089185424719713, 0.2957762751447276, 0.2450702189692302, 0.20756017639578073, 0.29339541951796066, 0.3304427455338639, 0.3164747065313106, 0.3195343536262396, 0.462102190616105, 0.5759785054394934, 0.2334418308526276, 0.20802215166541937, 0.3951854701057992, 0.171517802986352, 0.24571450978950593, 0.2048883105442153, 0.15245601037953327, 0.15336671410229863, 0.18036665534241514, 0.21468176029081165, 0.14574301646474663, 0.16576606561523144, 0.22350117697869887, 0.1684949908555815, 0.12737961899742845, 0.11980270934725445, 0.16757268134623193, 0.13578540110688242, 0.15014916184334692, 0.14911315276289738, 0.1597212881329857, 0.18642915846274744, 9.999999999998899e-05, 0.010136052383503902, 0.003011506527731189, 0.06846308777034305, 0.005196026949884303, 9.999999999998899e-05, 0.04384107743336918, 0.02565096962048996, 0.02308051476987316, 0.0980547800628554, 0.07377917540600543, 0.13501394281239154, 0.07851708033197669, 0.125523288072104, 0.057058582583598416, 0.07669089486541869, 0.1380963456159192, 0.16525274540057977, 0.00792159040050755, 0.06408264180033874, 0.06083150498131762, 0.057614930428979805, 0.05707216298969142, 0.10793655940608082, 0.055758372447683224, 0.028094905852137475, 0.053932993346484936, 0.14919287692826944, 0.05305523294913217, 0.14112038496038037, 0.10898082370098805, 0.12822421645672766, 0.14662028505250801, 0.09685234717793134, 0.09280342443275769, 0.09545842979316144, 0.47450688893078774, 0.4349976621369145, 0.5025938887403683, 0.49152233101147524, 0.4307406077286542, 0.4740577400232606, 0.4225918022180064, 0.4337216476291105, 0.4545958090897706, 0.11733167862996086, 0.12966879091422523, 0.11676787586076898, 0.11604037207560447, 0.11104000152967364, 0.11801812018090296, 0.1347131188978774, 0.12367528868376809, 0.09831684972488908, 0.20690399058976872, 0.17429887945117917, 0.19927190001320283, 0.16473824790005875, 0.14370709859964081, 0.19865561223816186, 0.16786075248201215, 0.3086833571849106, 0.24961658506548046, 0.24833092113357258, 0.31326958770054547, 0.33805894728215347, 0.3588848759241473, 0.33158722175733846, 0.2674019352350241, 0.3364219810051472, 0.3542596844629844, 0.314791908443108, 0.2502640616884074, 0.23667005962193688, 0.2522233439497208, 0.27886175881331454, 0.24547059775581193, 0.24796452738807007, 0.2605565749747123, 0.29144868585160766, 0.19420550645820955, 0.1776643610452282, 0.17764257667926964, 0.18880815127645134, 0.23317739215546274, 0.20589094816033682, 0.1941916183542256, 0.19541803552764403, 0.19289635648123704, 0.21592250154022274, 0.3571305668630309, 0.29183188954750205, 0.21652819738864704, 0.23630373011237626, 0.23155053771917888, 0.21407966790761135, 0.2032561141197643, 0.19063686417412196, 0.22257383676956355, 0.19679428573470037, 0.6582903497672061, 0.19309721209598807, 0.16337004733018168, 0.18841397859293252, 0.6438242428687642, 0.1669408130936425, 0.1684618774961114, 0.844412726807519, 0.4436374511771962, 0.20691227554169989, 0.33611736833375283, 0.6005441487009133, 0.16439881561170255, 0.19524936702965934, 0.25375886538607095, 0.2597077381204299, 0.3786138611374662, 0.17937798494465695, 0.17960755739028833, 0.1886610204147383, 0.16974914347838876, 0.17990294795448059, 0.17571483739907723, 0.18760404400910524, 0.18225353605949401, 0.1861319883348681, 0.07836788334937506, 0.08685640111348836, 0.07232254809346794, 0.08480817227625781, 0.08665068427113676, 0.10049550586938172, 0.08483519279890861, 0.08273800534626152, 0.08473423621791465]}, "mutation_prompt": null}
{"id": "3fcc04c5-d451-475a-a8ae-d35d0b9f840c", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.35  # Slightly adjusted for exploration\n        self.f_max = 0.95  # Increased for exploration\n        self.cr_min = 0.25  # Lowered for increased diversity\n        self.cr_max = 0.85\n        self.elite_count = max(3, self.population_size // 7)  # Adjusted elite count\n        self.entropy_threshold = 0.03  # Adjusted for perturbation\n        self.chaos_control = 1.3  # Modified for exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.015  # Modified step size for perturbation control\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.85) % 1  # Adjusted chaotic control function\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))  # Allow more dynamic size reduction\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Evolutionary Quantum-Inspired Algorithm with Adaptive Perturbation Control and Dynamic Elite Strategy for Robust Optimization.", "configspace": "", "generation": 50, "fitness": 0.25921955185231516, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.19.", "error": "", "parent_id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "metadata": {"aucs": [0.5308645933307037, 0.5707620852994006, 0.5545010685703284, 0.511112449293142, 0.5295217039286861, 0.5490274300221996, 0.5388647569057265, 0.5520320059358329, 0.5277915349706734, 0.3230660606628546, 0.3103033153097169, 0.3485179551846882, 0.321451420852763, 0.2964848142249339, 0.31199424504096573, 0.28820706777293903, 0.3301602424495853, 0.3007708958856098, 0.2756050145911876, 0.1721097024718269, 0.2821258559386307, 0.2530938814147715, 0.2713350665874851, 0.24539899641233454, 0.26429581151301085, 0.27115859444920054, 0.26747080902831954, 0.16015349863703887, 0.12111505846089843, 0.21695598731350407, 0.14778430416081012, 0.1469646737836129, 0.21358593313630303, 0.16212807697408294, 0.1652292344930174, 0.13796872223048717, 0.9256025951720206, 0.9044153457419072, 0.9234963888298395, 0.8921211913606013, 0.9010397213849387, 0.877945233593054, 0.9195722519574014, 0.9129178897428143, 0.8946251480976823, 0.2757774514463497, 0.23679650426634102, 0.25753940742545456, 0.31311337254472205, 0.2067191439642152, 0.27907465084757177, 0.25213973341210527, 0.291896116313627, 0.3093942056860468, 0.3334162328194826, 0.2126935758660039, 0.16330086443468683, 0.565329407949136, 0.3402580684564642, 0.20206131781432002, 0.21669882876528346, 0.6001044039264845, 0.218483474294492, 0.23024044198148952, 0.1434492889217418, 0.20607950046116208, 0.16572381790018298, 0.12996857931910177, 0.33814326651402615, 0.1575775185918259, 0.14232534123390705, 0.19613775855189575, 0.16910815385760836, 0.15470233765727603, 0.16185104953305418, 0.18989129095666868, 0.1293977947171836, 0.16929490201392894, 0.15476043778459114, 0.16274596514134554, 0.14581448295413468, 0.02074249021674912, 9.999999999998899e-05, 9.999999999998899e-05, 0.02672739283249226, 0.0020283029348348025, 0.014935906396426613, 0.0031666551172742086, 0.06819915629468198, 0.03974635678146554, 0.22507489731925423, 0.052266885893249126, 0.13890468439457782, 0.14187744058646645, 0.07919738073637184, 0.12794273542461365, 0.0932280922525015, 0.2099257344352905, 0.21485843627788448, 0.058435211162723544, 0.07585421522129454, 0.07609408188523215, 0.0890756170547915, 0.060694461120974874, 0.10848607834335178, 0.04243643924232254, 0.04691256020262158, 0.07993066492444012, 0.11162383620496674, 0.12330547536219694, 0.1615651471565912, 0.1482447983736802, 0.12134616322681946, 0.14013479344363222, 0.17681179316678175, 0.09013906320915466, 0.08147707308790342, 0.4466220630302431, 0.45166923109872015, 0.4632457931744127, 0.45643172035090407, 0.4539313361463162, 0.48484199314706955, 0.4744915017821415, 0.43626952037915745, 0.4578435775376237, 0.1163498183770757, 0.13065488678076675, 0.12714646467559398, 0.11729542665791726, 0.10936695024843834, 0.10811559174922802, 0.0963227354342695, 0.12357412837130266, 0.12072047417801746, 0.17832670287241692, 0.17795347018591523, 0.2543121624962563, 0.2201866318267225, 0.2059590742195413, 0.14369729567318534, 0.17129776437333621, 0.13584470212401778, 0.21020647997764963, 0.33019096074997456, 0.32325384515358135, 0.3203695795631428, 0.31501140182542353, 0.3378145300694597, 0.31664431307630614, 0.3202285949161735, 0.3197636844925561, 0.3376652236013047, 0.2652747949542824, 0.2596189294468766, 0.26675998817500124, 0.23824240264564855, 0.22528270745066925, 0.23680094375700933, 0.2576240895570636, 0.25797417668141176, 0.25388784926427, 0.21599489171403674, 0.1970651048352513, 0.19325387339765399, 0.21211669463912797, 0.21252148812071647, 0.18261662380466204, 0.21165122736362796, 0.18611184820661886, 0.1956494286903876, 0.23944795277643016, 0.21290584473857221, 0.23066109791492784, 0.20796849301827192, 0.3546163239909913, 0.379239984898631, 0.22797206642091106, 0.21106568643442525, 0.3704545246354576, 0.16737342421464507, 0.6653801380058506, 0.19151795524322057, 0.5368393432675274, 0.1613122469197832, 0.7771009872132343, 0.15495284275061327, 0.16213280199795577, 0.5290085646316987, 0.41587399085189114, 0.20977431755360199, 0.4962080813959421, 0.2644086833197352, 0.16045484228663176, 0.19691814742562963, 0.1933696401103413, 0.35080763386899794, 0.35160736155063754, 0.18063016833067247, 0.18329110361662548, 0.19930391788436885, 0.19052986599603594, 0.16576732496196833, 0.17546746244725908, 0.19859997471295243, 0.1750187561951776, 0.1969210679838448, 0.08832797897728084, 0.08917560906242794, 0.07764297855811275, 0.07380116378602075, 0.07461506436762688, 0.08350034668229, 0.0855878200457395, 0.08990558131526727, 0.08665000299431191]}, "mutation_prompt": null}
{"id": "3eeb992b-098c-4909-9b7e-72a5c39d9e20", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.35  # Slightly broadened mutation factor range\n        self.f_max = 0.95\n        self.cr_min = 0.2  # Increased diversity in crossover rate range\n        self.cr_max = 0.85\n        self.elite_count = max(3, self.population_size // 7)  # Enhanced elite count for better convergence\n        self.entropy_threshold = 0.01  # More frequent perturbation with reduced threshold\n        self.chaos_control = 1.7  # Increased chaos factor for exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.03  # Enhanced step size for aggressive perturbation\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1  # Adjusted chaotic control function for diversity\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))  # Dynamic size reduction\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with Adaptive Chaos-Controlled Perturbation and Dynamic Elite Reinforcement for Robust Optimization.", "configspace": "", "generation": 51, "fitness": 0.26718410262797493, "feedback": "The algorithm EnhancedQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "metadata": {"aucs": [0.549198656043588, 0.5570375923230735, 0.5203231384677447, 0.5453404403389704, 0.5381460343740135, 0.5375065317578379, 0.5562758361821905, 0.5493200352669728, 0.510818171705195, 0.35908192066799427, 0.3618674981858586, 0.3793074987952214, 0.34284070981783965, 0.41794356069113114, 0.39128663686045106, 0.3453101109137485, 0.3657722827506671, 0.35612013638535067, 0.24872161427201567, 0.16510375744822559, 0.1489844734038568, 0.16972717718575792, 0.16834791123250292, 0.32267499170935154, 0.2535917380785643, 0.12306982913674014, 0.33465213315538234, 0.1302780496089827, 0.23987039324979875, 0.15818168029605773, 0.13245287796631366, 0.26329391599236274, 0.14542164272391178, 0.16481411304819193, 0.27228369703785194, 0.2899909016933718, 0.8965470646231711, 0.872696098030936, 0.9464739650458608, 0.9100042434247017, 0.9009058831762444, 0.9387523731087448, 0.964659719649031, 0.8964393161450354, 0.9103267963342029, 0.1749398805294663, 0.20660896666621986, 0.20024478974918247, 0.24263244760677882, 0.2586589582341515, 0.25446098455742416, 0.2653654947659496, 0.23878334696598535, 0.267772432059582, 0.2911940366625594, 0.20897970200468985, 0.2832117274077687, 0.7006945442293353, 0.28271207252792663, 0.3344093249337984, 0.5432222222558649, 0.21234648562234026, 0.7431682903003586, 0.18632727913109082, 0.1475856961107116, 0.1864594414275893, 0.2578188962584852, 0.19657418839374496, 0.11196681208462911, 0.12036693868198112, 0.1251077222963649, 0.190484365686591, 0.1608724360816628, 0.17774794355891632, 0.21909983150406465, 0.13169007851832226, 0.13809676818097083, 0.13789529566989567, 0.16287582018742142, 0.14536283409876083, 0.15678067595752831, 0.071082348889564, 0.034826950147521685, 0.00898095768192253, 0.018364782088646447, 9.999999999998899e-05, 0.018099790985059205, 9.999999999998899e-05, 9.999999999998899e-05, 0.04209397035693618, 0.0957414496410618, 0.05494766402221796, 0.0818549657024501, 0.14786836929153147, 0.03940008344784496, 0.07444969743476226, 0.09478952090273329, 0.14052565477911028, 0.1303397370973831, 0.09981086656293536, 0.16191371889891504, 0.08114925707767884, 0.1010710668400725, 0.10876076571641913, 0.06778958948193448, 0.06683752979987989, 0.06401136246707284, 0.056664265787915835, 0.0990725268103746, 0.0976400241156522, 0.15260181490918712, 0.08716959789666656, 0.17373844330677535, 0.13513490086572366, 0.05544944273590846, 0.2078748353508466, 0.1094744917131264, 0.5212963829141481, 0.458503854364827, 0.5178492796590692, 0.4795818760687296, 0.47429022407857624, 0.4886113131602853, 0.4512814566218277, 0.45387893535454316, 0.42250889173212847, 0.1480552922604098, 0.08903376431400756, 0.12653094592693437, 0.12365694683295059, 0.11685747048813278, 0.1289372197859171, 0.11055197228842795, 0.1060731637925506, 0.1009709526214394, 0.2790697969444055, 0.17472697044928664, 0.1562126737412176, 0.20654322065691533, 0.14884936940386173, 0.14973024787718392, 0.17124930487282908, 0.18625160256439288, 0.17071774776361925, 0.3103899065712711, 0.3569094355754887, 0.283495159610054, 0.33862606029233644, 0.3485484537030282, 0.3403383576866613, 0.3316043315012084, 0.35094741364209403, 0.32877647251104103, 0.23517994480619953, 0.21645836974936505, 0.21746965100588067, 0.23897995044294884, 0.2569918084671221, 0.25844146426176795, 0.23279643814514206, 0.3001087550733974, 0.2719750119168526, 0.23738111891230085, 0.19575147474764976, 0.20041704307454422, 0.1864997322639268, 0.2074582014316635, 0.19279375685482847, 0.19035905668559672, 0.25366264902274094, 0.20541995217397335, 0.20669788581144743, 0.21313692190762112, 0.20202380030503453, 0.2121140606203411, 0.28566470609661077, 0.3873055993542446, 0.2090634726937416, 0.3295465718968382, 0.2377915516814596, 0.662049984254425, 0.5267080850217554, 0.15919107459948756, 0.7964983761430665, 0.16262447560527749, 0.8270961816316718, 0.1681085656772744, 0.7180684123476593, 0.8062959828160308, 0.4107183749153357, 0.2095505187501493, 0.19795835187708521, 0.20099756399141733, 0.19707922185269655, 0.18133916282514917, 0.39842331429103417, 0.4293914062162445, 0.17186678236874342, 0.17017128686702176, 0.1651389665034263, 0.18240724205383674, 0.18281117857813145, 0.20498653435631697, 0.1710417044644863, 0.1979151920624378, 0.1751464143914644, 0.1664251297693008, 0.0811984642613175, 0.08281355218051178, 0.11216919752762566, 0.0780863285118294, 0.0708631048546251, 0.0900242486867312, 0.07133720030615498, 0.08978638426408869, 0.06842046376477706]}, "mutation_prompt": null}
{"id": "17fd69c4-9fb3-49c4-934b-33f950d7ce5a", "solution": "import numpy as np\n\nclass QuantumEnhancedDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Slightly increased lower bound for differential weight\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(3, self.population_size // 8)  # Adjusted elite count for robustness\n        self.entropy_threshold = 0.05  # Altered threshold for entropy control\n        self.chaos_control = 1.4  # Adjusted chaos factor for stability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.01  # Adjusted step size for perturbation\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1  # Modified chaotic control function\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, int(self.initial_population_size * (1 - eval_count / self.budget)))  # More dynamic size reduction\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumEnhancedDifferentialEvolution", "description": "Quantum-Enhanced Differential Evolution with Entropy-Driven Diversity Management and Adaptive Dynamic Population Control.", "configspace": "", "generation": 52, "fitness": 0.2551550362402909, "feedback": "The algorithm QuantumEnhancedDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "metadata": {"aucs": [0.563328608370059, 0.5608501234850548, 0.5920558151794011, 0.53591304104622, 0.5702098372245867, 0.5808293382548493, 0.5540159103843665, 0.5825427008435626, 0.5744962798103268, 0.25291149605212604, 0.2450664658372802, 0.3023310485131676, 0.2623567907623203, 0.26062721700351965, 0.25839402522271215, 0.10510610324847491, 0.25216723298204347, 0.3089525049636467, 0.26314601250852077, 0.2630215065477022, 0.2985583861857588, 0.16601543052916845, 0.25627238483521, 0.312278981848204, 0.1701123230382764, 0.17018436651871127, 0.1684182732264521, 0.15133075511883598, 0.16601979068505113, 0.16134333480768914, 0.14434372911696713, 0.24873694968314553, 0.11693983425162391, 0.1415052637050861, 0.2290751339694308, 0.1408509622662374, 0.9229309328834914, 0.9091665653647901, 0.9155541368963243, 0.9101185365503831, 0.8873370925489021, 0.9120455653918936, 0.9390961516707576, 0.923252252309046, 0.9043600438435284, 0.33536162642875267, 0.2085647926223414, 0.29304960014056247, 0.32831617863350315, 0.26875751227321076, 0.33066714422409405, 0.28584890582535494, 0.22241629879286762, 0.2933414436752274, 0.3139780195699282, 0.2119178073931225, 0.1642603838783685, 0.5047731112751563, 0.20311692163943418, 0.6712871229796493, 0.6186379392733021, 0.5660822777346264, 0.6281384332479005, 0.12265073713885655, 0.14689035025477237, 0.15872678897317638, 0.1876100731912237, 0.11785968781972556, 0.1511153456034553, 0.19608373490038078, 0.13788212250454468, 0.15179449485550156, 0.16610737649782437, 0.1612181377542793, 0.1783325151763132, 0.1338905027873869, 0.15395839744298356, 0.15811252325863512, 0.1337080213794215, 0.15003495085003848, 0.2115748083878045, 0.007721206884534371, 9.999999999998899e-05, 9.999999999998899e-05, 0.028753342450244634, 0.010184931711701761, 0.00879182586750471, 0.06468876948962332, 0.02921259949823818, 9.999999999998899e-05, 0.07920648832097721, 0.07591040099614077, 0.1307751543240736, 0.07578604520230292, 0.14248847948802978, 0.04813905900813065, 0.2833852898209479, 0.17677033179363355, 0.18849240500608344, 0.06360557691726809, 0.0541767301444912, 0.02036262028588265, 0.030121646188023266, 0.027072576027689532, 0.08349794206198746, 0.0686265197722773, 0.05728831533460432, 0.05696792057877009, 0.13456469036577, 0.11517919953066591, 0.13060305805022376, 0.06587590346795003, 0.13760784615375865, 0.17367948047072967, 0.1250110650323133, 0.1038212198872277, 0.11130647070627364, 0.48009758809656433, 0.46265760598908223, 0.4726255192238359, 0.46681251169135185, 0.48097152857093517, 0.4576144009131782, 0.444148529258502, 0.48676085336106556, 0.47914164473443543, 0.14599181319312027, 0.12204607963751946, 0.12642171353409104, 0.09653181333108019, 0.08187956235478777, 0.1217929979264265, 0.1215508086469197, 0.11265791034516537, 0.11807012760967062, 0.13910315916229776, 0.22543195087667756, 0.23913640489642207, 0.23921085835429168, 0.21497915442022797, 0.1461385105657026, 0.2128282345260606, 0.20889457222086438, 0.18289896268106143, 0.3166720481025691, 0.32026391574867474, 0.32101544817434624, 0.2544583684758147, 0.2521289223117651, 0.33682069027356076, 0.31769750089770343, 0.32923687423348236, 0.3462141133112744, 0.21931532387007246, 0.2389660334848167, 0.22572426786684596, 0.20834348807863534, 0.21991159003586835, 0.2566495711200877, 0.2115011011684863, 0.2548868241870912, 0.25616069441109535, 0.2025091448175601, 0.18789320643298746, 0.20651369846058865, 0.1966538233512649, 0.2034100294197485, 0.18798481464905648, 0.20645517310140193, 0.19689281405704784, 0.20120137773243318, 0.23788819793721128, 0.20060163350668758, 0.23914545264924103, 0.35167369059886033, 0.2129144838313095, 0.1812105647247919, 0.21946888459573943, 0.3326598997549163, 0.23293235347961483, 0.17934119228572998, 0.6839051648155345, 0.18305549357701467, 0.19748297287171368, 0.19083487965466817, 0.7656913455763306, 0.1390096886993455, 0.17013491908333123, 0.7732860860939177, 0.5660032517288693, 0.20815645125682125, 0.1988732385795423, 0.16264513046317897, 0.16257611644514558, 0.3312550237895385, 0.1031223237776061, 0.12440540808311851, 0.3149863608119581, 0.1724616174467023, 0.17788125421365586, 0.16227449514106174, 0.17783629181422966, 0.17752635207967726, 0.1929559278191163, 0.1909675577144595, 0.17109189022747529, 0.16971744863087135, 0.08760304073742264, 0.08844519917522287, 0.08197187715994914, 0.07614738041224534, 0.07852418998648969, 0.09849380800133423, 0.09007453103119156, 0.08335792383778773, 0.08081072519987431]}, "mutation_prompt": null}
{"id": "ce9bea9b-ac96-47cb-9357-6a4f8a298d58", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5  # Adjusted mutation factor range for exploration\n        self.f_max = 0.9\n        self.cr_min = 0.2  # Expanded control rate range for diversity\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.03  # Fine-tuned threshold for perturbation\n        self.chaos_control = 2.0  # Increased chaos factor to enhance exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.01  # Reduced step size for controlled perturbation\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1  # Modified chaotic control function\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-Inspired Differential Evolution with Dynamic Entropy-Driven Perturbation and Enhanced Chaotic Exploration for Superior Optimization.", "configspace": "", "generation": 53, "fitness": 0.25972459503032697, "feedback": "The algorithm AdaptiveQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "metadata": {"aucs": [0.5514240286264152, 0.5477039488782603, 0.5602145100348546, 0.5565291629692068, 0.572044720695176, 0.5542545546687478, 0.5441730986741518, 0.554272243568677, 0.547051023520873, 0.320921880853839, 0.29972627483371306, 0.2733181864665042, 0.28762155914527876, 0.33317618192746823, 0.31866778377159477, 0.28605745470257726, 0.3591983645558049, 0.30445320309881885, 0.28885897577805375, 0.25585648582376275, 0.2435617841629194, 0.17167322818048292, 0.2752495173112971, 0.3556437416793611, 0.22660564288744323, 0.16249753757227914, 0.28625797484843185, 0.1387136870128205, 0.16437703311552143, 0.16226469970125923, 0.15871696403689817, 0.16186789618604924, 0.156703843993651, 0.2706590688795444, 0.25051817164214185, 0.15913512622978343, 0.926032309653721, 0.8971454575862832, 0.9536238283291404, 0.8984264535246794, 0.8993753209878278, 0.9450855559650002, 0.9321066705254348, 0.9144390408645442, 0.915275851997165, 0.2535958035309033, 0.31884623304629645, 0.2111650447004415, 0.30100970331834387, 0.23701741933456733, 0.31651711038433417, 0.28104146572874367, 0.21109722959940125, 0.29869865380872485, 0.48297529250786453, 0.2973359611828327, 0.16066297859653766, 0.2705882034547652, 0.2502030248204412, 0.3525655922063131, 0.6424454297734286, 0.6965152743314624, 0.2770512356118845, 0.18980456857205386, 0.17459391580201278, 0.15108821244931825, 0.1590700686904849, 0.14686063565127694, 0.24200368342962197, 0.1590822283867661, 0.3026472823242894, 0.20904259101471112, 0.1430551179768319, 0.1377398444936051, 0.11946237839293239, 0.1386076785939545, 0.13894630632868754, 0.18665727389628506, 0.1625175019267957, 0.15736191149145307, 0.17719304406575143, 0.05294952935482378, 9.999999999998899e-05, 0.05373462397337081, 0.021550267206265517, 0.011597351542973255, 0.011613043451850324, 9.999999999998899e-05, 0.02841827915491013, 0.025633407825408017, 0.07246569337704245, 0.09239076581738404, 0.10738587947648937, 0.05404526596319681, 0.062118108775768954, 0.05863371328662814, 0.13905891669489934, 0.112857724933072, 0.13425609421582307, 0.09813707848456799, 0.05524705685252762, 0.08002066297796451, 0.03296131006896008, 0.04339063574165014, 0.05307469626508132, 0.05803993955535247, 0.07099674588304428, 0.07235551421481579, 0.13127226907961465, 0.13689436214904105, 0.16152954671652264, 0.14968896503880735, 0.14707972262341884, 0.1523389657154829, 0.1314158738841894, 0.12887374865870083, 0.09000064335025415, 0.46239039300415086, 0.44262360475765195, 0.44356068083661526, 0.4634335304002031, 0.45100007187949787, 0.4692471337389008, 0.4762367407521283, 0.43002687156498587, 0.5184330982746166, 0.1172891629550431, 0.09441066638895967, 0.1032627248331408, 0.11788254981362356, 0.11083185445105503, 0.09698858296171253, 0.11694261879627099, 0.11523399310645688, 0.10323584552504039, 0.13513574000542716, 0.15239260717149516, 0.14788654454495698, 0.14965652918264238, 0.15494016418781398, 0.1596572379584863, 0.15810674549475023, 0.16576009387363988, 0.1794071729972504, 0.30392006187106424, 0.3114879483060077, 0.32624845714024886, 0.3034361802804889, 0.29731816099676867, 0.30945152328351866, 0.32287166136587664, 0.34151625893317084, 0.32284249240667373, 0.2522325087475359, 0.23910571404435255, 0.24443306256811492, 0.22805434217205545, 0.20355844507582277, 0.2623637120063069, 0.20350494745965808, 0.21434075014096632, 0.2621331358129332, 0.1905417356042236, 0.1939292564138354, 0.19924492110059577, 0.18177548041151992, 0.1800486003461752, 0.17761725947569518, 0.19511836857699105, 0.18298331761478526, 0.1978402807312285, 0.38782587702210436, 0.20253774878358732, 0.36549032682924254, 0.3280352023427143, 0.2279163029591753, 0.3543770023235908, 0.3387160885140714, 0.3523307131987826, 0.31422516101477327, 0.18431553658623967, 0.4604629704493697, 0.18644026068134312, 0.5936375173082471, 0.15301928213969163, 0.6514689984930568, 0.1541878445525774, 0.16883510349412167, 0.5583111781264118, 0.4692660763849825, 0.20001713187018144, 0.19692785926158207, 0.19797051439625235, 0.18608357275905774, 0.5766520711038592, 0.15707485929202847, 0.498521657960853, 0.39577223360075187, 0.18314140933665735, 0.16937077282779012, 0.18112790416391078, 0.1742311028943584, 0.1913188448451113, 0.16847572663407484, 0.16900133239375426, 0.1788474532692077, 0.21267117334989638, 0.0858628703528711, 0.0854000154740705, 0.0719849880125315, 0.08664612642465364, 0.07292846454120461, 0.07211367830352522, 0.07194265180184534, 0.07398286946129684, 0.07838215747060606]}, "mutation_prompt": null}
{"id": "35544476-9624-4f7d-b057-7e553eb6df55", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.35  # Adjusted for increased exploration\n        self.f_max = 0.85\n        self.cr_min = 0.25  # Broadened crossover rate range\n        self.cr_max = 0.85\n        self.elite_count = max(2, self.population_size // 7)  # More elite members\n        self.entropy_threshold = 0.03  # Slightly increased for dynamic adjustment\n        self.chaos_control = 1.6  # Enhanced chaos factor for exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.015  # Fine-tuned step size\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1  # Modified control for diversity\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Chaotic Perturbation and Enhanced Exploitation for Efficient Global Optimization.", "configspace": "", "generation": 54, "fitness": 0.2570645376279595, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "metadata": {"aucs": [0.5280369817170668, 0.540639195366317, 0.5410171787439819, 0.509407603836564, 0.5378184222649094, 0.5244694811371673, 0.5552627704094487, 0.5508771342640981, 0.5432690323691762, 0.2910989764354269, 0.2915810037158605, 0.27189053961551635, 0.3281568604530587, 0.2813550704773108, 0.291685069681788, 0.29168399234570885, 0.290353887476004, 0.29716813713565615, 0.1710521380204555, 0.27766861629174633, 0.3052032201566319, 0.3012399149877266, 0.1685857226654025, 0.2678067757990018, 0.16727515567946716, 0.30363451535822994, 0.17032725422844053, 0.14838822048066036, 0.13267120463056858, 0.14548307068925026, 0.14608117578623847, 0.22105961236135085, 0.13747787620693874, 0.2296885020960946, 0.16933649839980658, 0.16262817707202104, 0.872003724718946, 0.9096642528892368, 0.9335544847268279, 0.8831340820592384, 0.8982187099517974, 0.949216378728435, 0.8838498582060521, 0.9029670942097354, 0.9081921547796834, 0.22717873619921014, 0.1699148770254042, 0.3184076877991272, 0.231414478486776, 0.23600776212160046, 0.2492308368857321, 0.20769319277106613, 0.2741514046827229, 0.2644769421953689, 0.37676144936793243, 0.6530396975632015, 0.21372522150601092, 0.2638706371856766, 0.24872362894275102, 0.6593716832317285, 0.20604779385057181, 0.3002681493852688, 0.4248586482408365, 0.12755815796666936, 0.2540782887398104, 0.11779089985812785, 0.15604081421008542, 0.17714867349694285, 0.22071240165361028, 0.24086932639382785, 0.14724877818437965, 0.28539071384728054, 0.16468726430033875, 0.15025969371355163, 0.1513325829038955, 0.14555792005986246, 0.14400616985176184, 0.19538231039420484, 0.147902434290895, 0.1549144336201569, 0.16752453342028661, 9.999999999998899e-05, 0.058209599336359164, 9.999999999998899e-05, 0.027140835085207593, 0.019941944184427296, 0.022704196882379124, 9.999999999998899e-05, 0.004091825095617563, 0.046176623076238155, 0.10189278565823656, 0.20297667776561767, 0.1232476708731951, 0.09076829215253435, 0.06425177093136047, 0.13717234407355494, 0.2138811074569057, 0.0997687305518502, 0.174923187974808, 0.05130262583079637, 0.06805481033794092, 0.05767987513632944, 0.05076587595739546, 0.040078979613795696, 0.06472922323690478, 0.05877331992868695, 0.07601374510096015, 0.07600991087362086, 0.10429095172281455, 0.09793040387760943, 0.18135252091781917, 0.1049013049592944, 0.1210065389711874, 0.16875525084866272, 0.11517973469812892, 0.119039191408986, 0.0876213373540159, 0.46331610806660806, 0.4687132311609844, 0.47779839784286426, 0.4648662376295781, 0.4503013486972772, 0.5104641634271667, 0.47838052847793755, 0.4888412303122701, 0.44122263660827554, 0.10413420206587798, 0.11330472269839686, 0.1045609636312822, 0.13511640663639957, 0.14512575460810406, 0.1330040207578348, 0.13636569953189714, 0.12889134408775915, 0.10600172866149282, 0.16597942800039767, 0.17146112214337095, 0.1345939269239036, 0.20996343954776242, 0.22099997233803292, 0.15858517616946033, 0.17153440096422312, 0.19138064201561744, 0.16275376217559534, 0.32426500815495907, 0.33036094730327037, 0.2732909060328077, 0.35241643928232547, 0.31861470528224356, 0.30593423562842104, 0.33703499101610246, 0.3426609564160753, 0.3375990229798217, 0.2651667312507491, 0.26199076827038803, 0.23919124554868787, 0.20446789549367306, 0.24213198399644786, 0.24034166312521366, 0.26276231259331573, 0.2752770266417498, 0.281742515528704, 0.20068231551999716, 0.21210219228437976, 0.23148350518784144, 0.20255084440729398, 0.20514671981537702, 0.21843401633319115, 0.19768288050860294, 0.21371276155978314, 0.2112048388246046, 0.41560460745919203, 0.21214265919990927, 0.2181842838020821, 0.21668215713325678, 0.22957723019151088, 0.21290754161856962, 0.21303933920111118, 0.20478416738467242, 0.20761754001634747, 0.1908456133188925, 0.6674826709996551, 0.18785648624687212, 0.6306608356400274, 0.1882486507663057, 0.17158675137628654, 0.16896006146896891, 0.6423366146956768, 0.713904690444941, 0.27226624013624856, 0.20960598811986786, 0.6303959455489424, 0.1947790807005989, 0.19239727895861436, 0.3175108090288302, 0.155490115598248, 0.30692535829659806, 0.220210075628682, 0.17299925515433823, 0.17455103186552312, 0.18347864024934002, 0.18793262496818075, 0.17418821782839478, 0.20274108779941846, 0.17039442744563038, 0.16714749035106757, 0.18632386769956244, 0.07442616385080925, 0.08845910944071345, 0.07840231986149715, 0.07888095458355182, 0.07895888484996827, 0.10095267651137851, 0.08493181248790771, 0.08941672582410998, 0.077180874875597]}, "mutation_prompt": null}
{"id": "f7eb233a-a3d5-4e04-b43c-cfd10f2cab8d", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3  # Altered control rate range for diversity\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)  # Adjusted elite count for robustness\n        self.entropy_threshold = 0.02  # Lowered threshold for more frequent perturbation\n        self.chaos_control = 1.5  # Slightly increased chaos factor for exploration\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = np.linalg.norm(grad) * 0.02  # Increased step size for more aggressive perturbation\n        return sol - step_size * grad\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1  # Adjusted chaotic control function\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))  # Allow more dynamic size reduction\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Hybrid Quantum-Inspired Differential Evolution with Adaptive Entropy-Controlled Perturbation and Dynamic Elite Migration for Enhanced Optimization.", "configspace": "", "generation": 48, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "metadata": {"aucs": [0.5227151938618669, 0.5335834624822947, 0.5296806276886098, 0.5227615287109967, 0.5539247590631146, 0.5411615028670519, 0.5526231342412417, 0.5553112486383036, 0.50798760813825, 0.3426825672813406, 0.3919198118454956, 0.3544561010578353, 0.3230650730107253, 0.3154682739431398, 0.32664827955430087, 0.3141508453747045, 0.3115687324159794, 0.36609034953014075, 0.16119687889974443, 0.17466173069916568, 0.17428349196491433, 0.17279042506731146, 0.13827573483414513, 0.2595981675155117, 0.2568609430496299, 0.17186694324711205, 0.2626339172439346, 0.168523698221274, 0.11377755774118592, 0.14378459209542105, 0.251843936762825, 0.14767041694869154, 0.15142065906513213, 0.14039841237832884, 0.20196548592864583, 0.13355597968758215, 0.8381504192883328, 0.8873684362174603, 0.8740915751339879, 0.8761523179276379, 0.9085436101766399, 0.9433200498551255, 0.9098255753458766, 0.8967049288690434, 0.9254839271856327, 0.30654545764469554, 0.17837371901099008, 0.28876497394949496, 0.2454807576393333, 0.28119067446674684, 0.22386233509698672, 0.30376578536308574, 0.21089461815747823, 0.18441739722669404, 0.6447814325111048, 0.48893714672591315, 0.6489402796021851, 0.6462839336732639, 0.6693037892335997, 0.5782257779205542, 0.3853047950523095, 0.6020415262941154, 0.6452826420327883, 0.14763636683197767, 0.15552141470430414, 0.15102348838834767, 0.16169706168838816, 0.18750375779170947, 0.1251210125677995, 0.17640822166553716, 0.1381841145496575, 0.28976993379614446, 0.17118676643164144, 0.15756755257335864, 0.18487518067519781, 0.17517864844141118, 0.16034321907755855, 0.15388808359103712, 0.11799577046280552, 0.16019377636452103, 0.17264416316079856, 0.04092565345065091, 0.03094701648550313, 0.03072068441949649, 0.04732946321226972, 0.04465898221365383, 0.051831236732015395, 0.009799904308105067, 0.029256747894464974, 0.08992762058276293, 0.09302125660074123, 0.07576968379603366, 0.11840316751928481, 0.07826512677611919, 0.07429428645045066, 0.057807838094718456, 0.1463143937010225, 0.11838690169579003, 0.09224745130864664, 0.056649756179959376, 0.055674571090328584, 0.08254765185230639, 0.03859757604821612, 0.06289285605429162, 0.011262923293779759, 0.10218520085930394, 0.09127157586239987, 0.08925503272120805, 0.14114089642100425, 0.14493435607656813, 0.12915115968199642, 0.09639028904168723, 0.1572028876539413, 0.19086967797105592, 0.11498437387478166, 0.18173201957189167, 0.1573490607990563, 0.4664099422600607, 0.48038280106271647, 0.5144793820996333, 0.4491726822090967, 0.5049747758401119, 0.47726584331826716, 0.4508892849975704, 0.4605040627795619, 0.4502284953950151, 0.12865407738464818, 0.10972424549097448, 0.10947071791012863, 0.10543651032538759, 0.15773631172670088, 0.09168004499851412, 0.2667744669966554, 0.10505052056810205, 0.11059614753245428, 0.14581246960282046, 0.23058219048602213, 0.20712499171866894, 0.16425284041063493, 0.16476798460809494, 0.19201977272228665, 0.182855539707086, 0.1678034626917002, 0.1810494673564781, 0.3083066275904459, 0.24540348939242418, 0.2649886254595265, 0.3547740389034125, 0.31416525952809504, 0.27419513430105347, 0.32012622610419916, 0.33056071196386705, 0.3000937098193359, 0.22705449559039326, 0.18368561565337282, 0.22415461103203593, 0.26922050678754006, 0.21960498899489544, 0.26714715836925307, 0.22787146683801696, 0.24007305084902641, 0.27515559151341185, 0.18937547537056154, 0.21659920649856212, 0.19418187207838733, 0.2085351307893224, 0.20201112162414714, 0.19425548187222075, 0.198488074375481, 0.27190659787026994, 0.19223558409145647, 0.22796168700714248, 0.22993816749376272, 0.2081676918390466, 0.23330296248232663, 0.19464283274718697, 0.21218720764414312, 0.19258284034563677, 0.21935504706758024, 0.23461367327384364, 0.19633915065900542, 0.6402716820143204, 0.7750622876990304, 0.666121522498273, 0.19381213563210686, 0.38622205194065284, 0.13993915426656223, 0.16720987424361866, 0.7029636304734731, 0.5636408201210403, 0.20793682420251103, 0.40114197180254385, 0.16058346594883055, 0.22825273107574917, 0.5088661726362446, 0.1545412883517976, 0.5241979260456658, 0.7381468168636263, 0.18116779070563305, 0.18634643835397247, 0.1952173511927111, 0.17785760622925118, 0.1979713846958, 0.19225024244063182, 0.18678773612236932, 0.17104189709288298, 0.17269581616071505, 0.07874478631286586, 0.07651969028047223, 0.0888671322899447, 0.09056183121424055, 0.08556913541078992, 0.07665712423013715, 0.08563356846186065, 0.08922374144599887, 0.08582596696521683]}, "mutation_prompt": null}
{"id": "c675a987-3ade-4f73-9b1d-51ba9e0038d1", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.5\n        self.exploration_probability = 0.15  # Introduced probability for changing strategy\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = np.linalg.norm(grad) * 0.03  # Slightly more aggressive perturbation\n            return sol - step_size * grad\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with Probabilistic Dynamic Exploration and Adaptive Perturbation Strategies for Optimized Solution Discovery.", "configspace": "", "generation": 56, "fitness": 0.30527038617777974, "feedback": "The algorithm EnhancedQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "2484f0c7-fde3-4838-9ff7-7fc7fdb9db9b", "metadata": {"aucs": [0.7839729932797509, 0.787291462295582, 0.804939202227249, 0.8038333334600183, 0.7860954094128537, 0.7947723818227571, 0.7938171097068007, 0.8098187915510497, 0.8061019328826888, 0.6461265586179853, 0.6658671276445665, 0.6461968579583984, 0.6235279113985515, 0.6358670012353294, 0.6363367732629142, 0.591206675952269, 0.6063987722973223, 0.6885863834419931, 0.1621045335272947, 0.17482529707086158, 0.17501735687323727, 0.17364380574653027, 0.1385986241558812, 0.5541021058585192, 0.5637712563147048, 0.17249282750301553, 0.6348766667580366, 0.16942383393169147, 0.11386184480221784, 0.14416615009895595, 0.5411080331955183, 0.14871133605276787, 0.15179329586971546, 0.1404620991264257, 0.5092608200755895, 0.13383456300592556, 0.8429702835528822, 0.8873684362174603, 0.8805126935608915, 0.8761523179276379, 0.9085436101766399, 0.9433200498551255, 0.9098255753458766, 0.8967049288690434, 0.9254839271856327, 0.29782617450442306, 0.1784380878237387, 0.26656022567319937, 0.24233210298696806, 0.30833786712146705, 0.2083121418838717, 0.29187927244383904, 0.20660608011211612, 0.17480687389651195, 0.6447814325111048, 0.29146957520514716, 0.6489402796021851, 0.6462839336732639, 0.6693037892335997, 0.4173386080527203, 0.3189012234492685, 0.6020415262941154, 0.6452826420327883, 0.14498430398367745, 0.15772837860364164, 0.1458387600401878, 0.15936113142769193, 0.1899752776717223, 0.12522883781022465, 0.17641767624780147, 0.1341570105109482, 0.3119902291020058, 0.1629948997424282, 0.15296547367567714, 0.17580698153168473, 0.17471083010923716, 0.1558775102953075, 0.14722891375725244, 0.11806791183272891, 0.15532287633775144, 0.1622617353034017, 0.04093677386030026, 0.030827391603262866, 0.030758443534726787, 0.04732946321226972, 0.0447435866882675, 0.05204841903405599, 0.009660820447790486, 0.029245943244188832, 0.09004830875218162, 0.09284538399275477, 0.07577921510400798, 0.11842527317824769, 0.07825828519594247, 0.0741669653891619, 0.05776503667773358, 0.14633467689926094, 0.11858791499046384, 0.09096009019646734, 0.09927868023482156, 0.09942915814934172, 0.10924290044095686, 0.09575673402955309, 0.18699109522816237, 0.06353010711865392, 0.1077722893792541, 0.13360397733114282, 0.09145543487588659, 0.15878002582286577, 0.15308309596013514, 0.13176662736491873, 0.0968901055232474, 0.16916239531094235, 0.2510497186008601, 0.12179260536146763, 0.19702577971723578, 0.1615532828858688, 0.5228338427691809, 0.5126848146142837, 0.5260688066417064, 0.48661050583192356, 0.5890568561158589, 0.5221978852898619, 0.4663588705668914, 0.44319337553335203, 0.4709291017517878, 0.12865596629548803, 0.10981992702243204, 0.10981048730925125, 0.10559003678406953, 0.1577412753055043, 0.09192657347853106, 0.36496800039702415, 0.10488549163523497, 0.11066910521375195, 0.14586204277644987, 0.23477789632104196, 0.226667214240316, 0.16507480021908905, 0.16473213858273705, 0.19204728758797973, 0.1858472779501622, 0.1678532669145154, 0.18265577216096707, 0.33594149895316183, 0.2514207982881057, 0.26967787824837786, 0.42235246240659086, 0.37814390254946617, 0.2743659411577445, 0.42293399752202243, 0.4458066148311933, 0.30508031593381835, 0.22858739024502372, 0.18391367960896243, 0.2470859000865755, 0.2837026341622708, 0.22671858459433014, 0.2931671521015633, 0.22970148734845164, 0.26120647398922103, 0.2919927935566129, 0.18937547537056154, 0.21659920649856212, 0.19418187207838733, 0.20884008810993582, 0.20201112162414714, 0.19425548187222075, 0.198488074375481, 0.27190659787026994, 0.19223558409145647, 0.22823556161192637, 0.23043015984312987, 0.20856649776166614, 0.23391194317590502, 0.19473022117802652, 0.19600807837575263, 0.19270684361035717, 0.21935504706758024, 0.23479061970299275, 0.19634249009710614, 0.6542658852478724, 0.7779554161867809, 0.7154933631680211, 0.19382821186858779, 0.3768730180212807, 0.13994192272149664, 0.16721324033151885, 0.7037913964613851, 0.577486093376795, 0.20795309646117366, 0.37315131039683547, 0.16058583793805048, 0.2273631911734192, 0.5033494953440216, 0.15462911023182802, 0.5440049041687602, 0.7463380627598324, 0.18116779070563305, 0.18634643835397247, 0.1952173511927111, 0.17785760622925118, 0.1979713846958, 0.19225024244063182, 0.18678773612236932, 0.17104189709288298, 0.17269581616071505, 0.07874478631286586, 0.07651969028047223, 0.0888671322899447, 0.09056183121424055, 0.0855797086344583, 0.07665847375062784, 0.08563356846186065, 0.08922374144599887, 0.0858260430237271]}, "mutation_prompt": null}
{"id": "eafdad31-31fe-48ea-8a6d-739919503132", "solution": "import numpy as np\n\nclass RefinedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3  # Adjusted range for mutation factor\n        self.f_max = 0.8\n        self.cr_min = 0.2  # Adjusted range for crossover probability\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.015  # Slightly lowered threshold for triggering perturbation\n        self.chaos_control = 1.4  # Adjusted chaos control factor\n        self.exploration_probability = 0.15  # Maintained exploration probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = np.linalg.norm(grad) * 0.05  # Increased step size for gradient perturbation\n            return sol - step_size * grad\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.85) % 1  # Adjusted map slightly for exploration\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "RefinedQuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Evolutionary Optimization with Adaptive Exploration, Chaotic Maps, and Enhanced Gradient Perturbation Strategies for Efficient Global Search.", "configspace": "", "generation": 57, "fitness": 0.29262797232991594, "feedback": "The algorithm RefinedQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "c675a987-3ade-4f73-9b1d-51ba9e0038d1", "metadata": {"aucs": [0.7954333560841277, 0.7756472944434549, 0.7970852094893134, 0.8036629844598377, 0.7458683304665377, 0.7000539386855855, 0.7944115856766452, 0.7871702663889423, 0.7869873662517674, 0.6193091228225412, 0.6232150094825992, 0.6528567943406756, 0.6493153513144803, 0.6239630587635574, 0.6495852440295387, 0.6397832582474643, 0.6291390319345993, 0.5397458039497918, 0.5547395166762052, 0.13851969128426012, 0.16745395908335958, 0.17021784615106395, 0.5597575686978633, 0.17375074285046688, 0.5595894494117843, 0.16743062796631825, 0.1726229622741977, 0.16049385097548108, 0.1696791145938662, 0.1473684814793058, 0.16844204253507666, 0.16538088433916087, 0.1773483206638301, 0.452103730106576, 0.14772865848283434, 0.16237663292357707, 0.8726346285921317, 0.8764471341098726, 0.8587715020588899, 0.9109481793583996, 0.9089322043815927, 0.9008694800234731, 0.9047205000995101, 0.9415622506736746, 0.9036995567390208, 0.3446489809697031, 0.17470393981134225, 0.2395841760235431, 0.3689025301615926, 0.3000037616680987, 0.40790181700056505, 0.1942930057277349, 0.21681105793093314, 0.2320579290034338, 0.22871205498367497, 0.5911072432587761, 0.20488909999903282, 0.33914785628891264, 0.4643048626129489, 0.4287577854621669, 0.23024780752955798, 0.30282659908620657, 0.26520179614376593, 0.1818330506489929, 0.10236379855799538, 0.1441719568223372, 0.16298611762067283, 0.19007444488916359, 0.2893713206501447, 0.26355809153040144, 0.11940531107206276, 0.11893424280041887, 0.13306005688022182, 0.18812048785789115, 0.14221193999514126, 0.14645965735738486, 0.13328795607356514, 0.13876762894534644, 0.14628273916331236, 0.14732001665775873, 0.12688584268585512, 0.029501986884125975, 0.0007778647919820525, 0.011179725716285227, 0.03346144945632745, 0.11615592715038492, 9.999999999998899e-05, 0.023643110009999746, 9.999999999998899e-05, 9.999999999998899e-05, 0.15144455274383184, 0.05811772583846886, 0.1331747818403044, 0.1784715854831489, 0.08649884834358623, 0.055785901675505234, 0.15174949151521178, 0.0971214843983702, 0.10537051332678204, 0.051799200987677985, 0.06843709915526652, 0.10628068853187866, 0.11065380956734339, 0.2061452687290256, 0.05909198988085396, 0.0709145782528503, 0.13299247393401148, 0.0767754119997539, 0.15928636445049593, 0.19807147167107297, 0.17856623936187366, 0.18145718178867787, 0.06338536665239647, 0.09607770266496662, 0.1733399650804548, 0.2241893833541455, 0.09747667202211052, 0.4961061254284389, 0.46447309730105013, 0.49367273476865625, 0.47137652737574687, 0.4660645596730435, 0.4462631304969784, 0.49400686387069326, 0.4809982994664187, 0.486238253811231, 0.10318022397622084, 0.1311209512889584, 0.09958272604856122, 0.12391231725997331, 0.11962799191331508, 0.30528660387092554, 0.12150551560325806, 0.1304122060748496, 0.07926452509154858, 0.22113476888906902, 0.21268505790293524, 0.2619214586321248, 0.23031515654657553, 0.15666838266964955, 0.2075368201800728, 0.21480546458816052, 0.1632686927953746, 0.17523398424751868, 0.42999438267496126, 0.3186067641224205, 0.3175936918302642, 0.41571787391658144, 0.3417482293573948, 0.2908297594412117, 0.40770016294434785, 0.41138228738179217, 0.27523390146746474, 0.21567016524298943, 0.2635016014581193, 0.2302490923699, 0.19678350392574862, 0.2547532941048153, 0.25013127182433514, 0.21965492412070653, 0.30531091302547986, 0.29398987509509555, 0.22179888430134231, 0.18296026081329153, 0.19187434236137724, 0.1998086972843719, 0.19176970036544505, 0.19957895537302162, 0.197855368951376, 0.19067969776476867, 0.18134883045300465, 0.34456256212361436, 0.6030901763829862, 0.2142392570503927, 0.24053414927909567, 0.23193855130710872, 0.21042166432070886, 0.535994640859206, 0.22857038370438187, 0.19699663513006194, 0.30869561716761607, 0.43746012026296455, 0.6755719695710809, 0.6668401711674777, 0.19239862293296706, 0.46091187149662327, 0.14074547571631524, 0.20199330360594403, 0.6211686654204847, 0.43635640623981176, 0.20796652776871083, 0.28559942491915524, 0.46680211417120754, 0.18081709601737417, 0.19845272251340973, 0.37539203557687406, 0.44813365364890845, 0.15317596750070717, 0.18985416876757621, 0.18573041809059154, 0.1771994319378517, 0.17504142998528116, 0.1750142008168888, 0.1687462642978238, 0.2020642664364184, 0.16629240199572248, 0.17600228118450345, 0.08144177248961348, 0.0832125569396649, 0.09448249304094425, 0.07945737016037058, 0.08435949722377534, 0.10394636817367497, 0.07957670412977713, 0.08695277048635086, 0.07653366501376846]}, "mutation_prompt": null}
{"id": "472cf5a1-8579-4bcb-933c-5efef7cf1437", "solution": "import numpy as np\n\nclass HybridQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.8\n        self.cr_min = 0.2\n        self.cr_max = 0.8\n        self.elite_count = max(3, self.population_size // 10)\n        self.entropy_threshold = 0.01\n        self.chaos_control = 2.0\n        self.exploration_probability = 0.15  # Introduced probability for changing strategy\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_perturbation(self, sol):\n        if np.random.rand() < self.exploration_probability:\n            noise = np.random.normal(0, 0.1, self.dim)\n            return sol + noise\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(5, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_perturbation(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "HybridQuantumInspiredDifferentialEvolution", "description": "Hybrid Quantum-Inspired Differential Evolution with Adaptive Chaotic Maps and Stochastic Perturbation for Enhanced Exploration and Stability.", "configspace": "", "generation": 58, "fitness": 0.28485056248173535, "feedback": "The algorithm HybridQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "c675a987-3ade-4f73-9b1d-51ba9e0038d1", "metadata": {"aucs": [0.7527824279368586, 0.7178378289935361, 0.728556852395607, 0.7331806888065239, 0.7624307245817059, 0.7426182567524056, 0.7572999670737904, 0.7095504449329233, 0.7245757405637797, 0.5684258218081115, 0.5722185137340802, 0.5402903284335854, 0.5468352205643875, 0.5613469696424632, 0.561247077328255, 0.5963167450797987, 0.6076881731565216, 0.5683898261316165, 0.15476184389847147, 0.15643162401820787, 0.5265357762956793, 0.44938140474440724, 0.47605145796568804, 0.4931794043001795, 0.16771617864301114, 0.42745736929743827, 0.16374689361566053, 0.15768655106238916, 0.15897745954288134, 0.1557398966397061, 0.1599745653195943, 0.15452782923312303, 0.15962423589570007, 0.1627246754543339, 0.3714587115859511, 0.3417226022464289, 0.8908847078324938, 0.8818955059480261, 0.8608244399416285, 0.9152173484935049, 0.8725408135631229, 0.8643867101200343, 0.9211707105237726, 0.9074652268309292, 0.8457932355343327, 0.2650551226665858, 0.26725918127448134, 0.3096408493531908, 0.2742682932098326, 0.18421506021442235, 0.29594387185461624, 0.21746007881280172, 0.14662119367253457, 0.20799698416848733, 0.43526789074128847, 0.4617663473427803, 0.20049090395482894, 0.3129435467886795, 0.6223856826627716, 0.6017634659619795, 0.2996484074298562, 0.33501935681755146, 0.6611747211959553, 0.18517341683679112, 0.19559227308222815, 0.15247040760800845, 0.16305096252766182, 0.1763366823728698, 0.15044314120404456, 0.17852657660366678, 0.127429249816723, 0.24188933078940578, 0.14035374882402685, 0.12504858356837834, 0.16261166901123558, 0.13749540048069286, 0.1340595761567367, 0.16300857019996584, 0.11544906538274313, 0.18543168827970447, 0.13823150543446028, 0.03592004958392969, 0.026988758887623976, 0.028080501990244033, 0.006642619649283588, 9.999999999998899e-05, 0.00580194582861604, 0.051603846357223815, 0.002471891661700143, 0.06857833229733101, 0.12146518406686357, 0.0780265776853184, 0.08187824298409574, 0.05982612054962555, 0.07867866576637805, 0.06899401113577153, 0.13252154489292112, 0.18871861792274913, 0.099783872909319, 0.05245972093359397, 0.10495690441852112, 0.08754539434642361, 0.033316228048905994, 0.044172120557004146, 0.06510326169476377, 0.09509318408611545, 0.13660201153770235, 0.051775116630814355, 0.13687714892706593, 0.1156446904989532, 0.12276066137854957, 0.11629910903972196, 0.1634608095499991, 0.16863830664493984, 0.09647456350365613, 0.12604375078603003, 0.09343171798751393, 0.4958911857796944, 0.4812988152352434, 0.473509709752877, 0.4524687180534833, 0.4594627688483449, 0.4449021856518317, 0.4990359720217483, 0.44024025840936887, 0.47611826938800406, 0.09903872711728745, 0.09950716518866831, 0.12129708377289627, 0.10249679970871006, 0.11936931622463831, 0.14433922122212517, 0.10243710742642398, 0.09061522682053691, 0.09767071477611078, 0.15993779772337313, 0.1406014140212266, 0.14556647740386397, 0.1583032221262951, 0.13316530090329037, 0.15963626721477053, 0.1440779109585697, 0.1574586902628694, 0.1466137522812021, 0.27516279902214846, 0.278174537163721, 0.29511139002400977, 0.35783618708361087, 0.32764815567791006, 0.3073316181078637, 0.35123922764158044, 0.38342765723478656, 0.3372943447275948, 0.25179251640457345, 0.24996800561880295, 0.26532965271886555, 0.23209459405841737, 0.2558501605053368, 0.261704254886614, 0.21263013109622042, 0.2524992053563806, 0.2551625461080568, 0.18583750608019645, 0.20023748337389402, 0.19694723331325925, 0.17265758030637113, 0.20462484394223346, 0.19157309683305712, 0.21347743234342464, 0.19511479350627992, 0.19645419597068892, 0.40660643350588244, 0.42209643591464896, 0.35091041814628665, 0.22456707485225735, 0.437583825100332, 0.2090098382668999, 0.3716271958935231, 0.2194866110675564, 0.42574401213029556, 0.7217893646097103, 0.18511967554582665, 0.17618298729128967, 0.4082198577094317, 0.40939452705354085, 0.6124243049692739, 0.5316311169189771, 0.16777175111932496, 0.5691132842007791, 0.3662779513490273, 0.3667188989715483, 0.19375619670785926, 0.163249634327837, 0.26308065480931087, 0.3105096254357981, 0.14687714707376176, 0.3739076867179417, 0.1853636778066844, 0.1885436312276011, 0.1905562902393504, 0.17740872334166813, 0.19449238619455889, 0.1736191439451764, 0.18270322716137566, 0.19407275124771672, 0.1788026386554331, 0.19742479169902505, 0.07575873974806868, 0.08507486324857949, 0.07210587256530576, 0.08232301785700025, 0.08477680222201522, 0.07778123918427171, 0.08445957383792102, 0.07684024848950122, 0.07198906279140282]}, "mutation_prompt": null}
{"id": "e7ce5751-278e-439f-82bd-a1af15a6b7ac", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.5\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_swarming_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            perturbation = np.random.randn(self.dim)\n            step_size = np.linalg.norm(perturbation) * 0.03\n            return sol + step_size * perturbation\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_swarming_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Stochastic Swarming and Adaptive Diversity Preservation for Robust Optimization.", "configspace": "", "generation": 59, "fitness": 0.3040785426487976, "feedback": "The algorithm QuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "c675a987-3ade-4f73-9b1d-51ba9e0038d1", "metadata": {"aucs": [0.7828434623326662, 0.787291462295582, 0.804939202227249, 0.8038333334600183, 0.7860954094128537, 0.7947723818227571, 0.8017828035114749, 0.8103532427394255, 0.8084865337433987, 0.6461265586179853, 0.6658671276445665, 0.6461968579583984, 0.6235279113985515, 0.6358670012353294, 0.6363367732629142, 0.591206675952269, 0.6063987722973223, 0.6885863834419931, 0.1621045335272947, 0.17482529707086158, 0.17501735687323727, 0.17363650686187027, 0.13859253570460472, 0.5541021058585192, 0.5707956174613117, 0.17249282750301553, 0.6471376855884768, 0.16942383393169147, 0.11386184480221784, 0.14416615009895595, 0.4471007633999312, 0.14871133605276787, 0.15179329586971546, 0.1404620991264257, 0.48463483679113073, 0.13383456300592556, 0.842520178561964, 0.8873684362174603, 0.8805126935608915, 0.8761523179276379, 0.9085436101766399, 0.9433200498551255, 0.9098255753458766, 0.8967049288690434, 0.9254839271856327, 0.29358746739036, 0.1704348873035818, 0.26516339465813066, 0.2395047632788675, 0.298590158517279, 0.23664679463651594, 0.28919736389860196, 0.2098163431347212, 0.19437135171578113, 0.6447814325111048, 0.27938703826772215, 0.6489402796021851, 0.6462839336732639, 0.6693037892335997, 0.34885689448444146, 0.3189012234492685, 0.6020415262941154, 0.6452826420327883, 0.14320447914600276, 0.15772837860364164, 0.1410308116474991, 0.15944300281492974, 0.18904732421709602, 0.12522883781022465, 0.17434497847020136, 0.14456614306019078, 0.30640020945126767, 0.1643148517006352, 0.15851463357865214, 0.17320577495589118, 0.17471083010923716, 0.14700179077666486, 0.1496856913723723, 0.11835344588681251, 0.1554305290062843, 0.16635489848320684, 0.04093677386030026, 0.030827391603262866, 0.030758716861401636, 0.04732946321226972, 0.0447435866882675, 0.05204841903405599, 0.009660820447790486, 0.029245943244188832, 0.09004830875218162, 0.09284538399275477, 0.07577921510400798, 0.11845874865062433, 0.07825828519594247, 0.0741669653891619, 0.05777872624091651, 0.14633467689926094, 0.11832675612140087, 0.09096009019646734, 0.09927868023482156, 0.09942915814934172, 0.10924290044095686, 0.0970005163236306, 0.18699109522816237, 0.06422728202149286, 0.1077722893792541, 0.13360397733114282, 0.09145543487588659, 0.15878002582286577, 0.15308309596013514, 0.13176662736491873, 0.0968901055232474, 0.16916239531094235, 0.2510497186008601, 0.12185489151847395, 0.19702577971723578, 0.1615532828858688, 0.5228338427691809, 0.5126848146142837, 0.5260688066417064, 0.4921306660097693, 0.5890568561158589, 0.5221978852898619, 0.4985905268697123, 0.4518564938898898, 0.4709291017517878, 0.12865596629548803, 0.10981992702243204, 0.10979957141640029, 0.10553899840125558, 0.1577412753055043, 0.09192889191204134, 0.36496800039702415, 0.10483987109881743, 0.11066910521375195, 0.14582661106498995, 0.23477789632104196, 0.22521039078125682, 0.16507480021908905, 0.16473213858273705, 0.19204728758797973, 0.1858472779501622, 0.1678532669145154, 0.18265577216096707, 0.33594149895316183, 0.2514207982881057, 0.26967787824837786, 0.44363173756900665, 0.37814390254946617, 0.2743659411577445, 0.3249362625243585, 0.4458066148311933, 0.30508031593381835, 0.22858739024502372, 0.18391367960896243, 0.2470859000865755, 0.2837026341622708, 0.22671858459433014, 0.29973247756071075, 0.22970148734845164, 0.2607528455350663, 0.2919927935566129, 0.18937547537056154, 0.21659920649856212, 0.19418187207838733, 0.20884008810993582, 0.20201112162414714, 0.19425548187222075, 0.198488074375481, 0.27190659787026994, 0.19223558409145647, 0.22829135238195641, 0.23043015984312987, 0.20856971963047455, 0.2338714151685548, 0.19473022117802652, 0.19600812849248883, 0.19271534368887988, 0.21935504706758024, 0.23479061970299275, 0.19634257765260366, 0.6604033475136861, 0.7779554161867809, 0.6170833967737743, 0.19382821186858779, 0.36054632120759944, 0.13994189851062477, 0.16721327684559617, 0.7365064321605979, 0.5652452721921204, 0.20795309646117366, 0.3948529602138705, 0.16058582454490056, 0.22511709182988848, 0.48936338613442754, 0.15457797837183063, 0.5440049041687602, 0.7463380627598324, 0.18116779070563305, 0.18634643835397247, 0.1952173511927111, 0.17785760622925118, 0.1979713846958, 0.19225024244063182, 0.18678773612236932, 0.17104189709288298, 0.17269581616071505, 0.07874478631286586, 0.07651969028047223, 0.0888671322899447, 0.09056183121424055, 0.0855797086344583, 0.07665847375062784, 0.08563356846186065, 0.08922374144599887, 0.0858260430237271]}, "mutation_prompt": null}
{"id": "d387ec1c-b363-4654-acee-ac8b2bdbd769", "solution": "import numpy as np\n\nclass AdaptiveQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.5\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = np.linalg.norm(grad) * 0.02\n            return sol - step_size * grad\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Chaotic Control and Dynamic Entropy-Based Exploration for Enhanced Global Optimization.", "configspace": "", "generation": 60, "fitness": 0.30357158436346227, "feedback": "The algorithm AdaptiveQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "c675a987-3ade-4f73-9b1d-51ba9e0038d1", "metadata": {"aucs": [0.7919634868185291, 0.7880582366560099, 0.804939202227249, 0.8016321694063039, 0.7930178650504018, 0.7947723818227571, 0.7990090532295759, 0.8031596112211584, 0.8030037660635401, 0.6461265586179853, 0.6658671276445665, 0.6461968579583984, 0.6235279113985515, 0.6358670012353294, 0.6363367732629142, 0.591206675952269, 0.6063987722973223, 0.6885863834419931, 0.1621045335272947, 0.17482529707086158, 0.17501748133976702, 0.17363524272187714, 0.1385978766892615, 0.5541021058585192, 0.5637712563147048, 0.17249282750301553, 0.6031375806516049, 0.16942383393169147, 0.11386184480221784, 0.14416615009895595, 0.4715299890371907, 0.14871133605276787, 0.15179329586971546, 0.1404620991264257, 0.34682823335913504, 0.13383456300592556, 0.8429702835528822, 0.8873684362174603, 0.8805126935608915, 0.8761523179276379, 0.9085436101766399, 0.9433200498551255, 0.9098255753458766, 0.8967049288690434, 0.9254839271856327, 0.284224883440811, 0.17761747089429447, 0.2668950719687253, 0.2537186546826099, 0.2977729653548987, 0.21963342397934704, 0.29973666443600955, 0.20507949324281094, 0.18717598495922372, 0.6447814325111048, 0.2901782563218014, 0.6489402796021851, 0.6462839336732639, 0.6693037892335997, 0.34885689448444146, 0.3189012234492685, 0.6020415262941154, 0.6452826420327883, 0.14157731650787753, 0.15772837860364164, 0.1435347175723347, 0.1627540598334284, 0.18992273831343787, 0.12523206678988807, 0.17530483071271918, 0.13282758624495383, 0.3163519748412431, 0.16158797220411203, 0.15170897596512856, 0.1734883010720638, 0.17471083010923716, 0.14973363499899428, 0.15087750732118022, 0.11806791183272891, 0.1549827053662306, 0.1631627989088098, 0.04093677386030026, 0.030827391603262866, 0.030754922302213883, 0.04740670141569481, 0.0447435866882675, 0.05204841903405599, 0.009660820447790486, 0.029245943244188832, 0.09004830875218162, 0.0929785848796415, 0.07577921510400798, 0.11927995307328565, 0.07825828519594247, 0.0741669653891619, 0.057763277336189134, 0.14633467689926094, 0.11861840343462193, 0.09096692009637486, 0.09927868023482156, 0.09942915814934172, 0.10924290044095686, 0.09774351437848638, 0.18699109522816237, 0.06367381531981553, 0.1077722893792541, 0.13360397733114282, 0.09145543487588659, 0.15878002582286577, 0.15308309596013514, 0.13176662736491873, 0.0968901055232474, 0.16916239531094235, 0.2510497186008601, 0.1219325259639703, 0.19702577971723578, 0.1615532828858688, 0.5173671531472508, 0.5126848146142837, 0.5260688066417064, 0.4802110051841526, 0.5890568561158589, 0.5221978852898619, 0.4635862854849002, 0.439061200127681, 0.48357851347686276, 0.12865596629548803, 0.10981992702243204, 0.10980038085495414, 0.10586891302682344, 0.1577412753055043, 0.0919341890549813, 0.36496800039702415, 0.10492596607515481, 0.11066910521375195, 0.1458459588513077, 0.23477789632104196, 0.2265065775829419, 0.16507480021908905, 0.16473213858273705, 0.19204728758797973, 0.18587160089661003, 0.1678532669145154, 0.18265577216096707, 0.33594149895316183, 0.2514207982881057, 0.26967787824837786, 0.4338730943424498, 0.3730860395736697, 0.2743659411577445, 0.4203380606353848, 0.45308725080179624, 0.30620579225474454, 0.22858739024502372, 0.18391367960896243, 0.2470859000865755, 0.2837026341622708, 0.22671858459433014, 0.2961156048092842, 0.22970148734845164, 0.25806271484572096, 0.2919927935566129, 0.18937547537056154, 0.21659920649856212, 0.19418187207838733, 0.20884008810993582, 0.20201112162414714, 0.19425548187222075, 0.198488074375481, 0.27190659787026994, 0.19223558409145647, 0.22840920372034657, 0.23043015984312987, 0.2085717439761694, 0.23391829088996174, 0.19473022117802652, 0.1960067421451377, 0.19270506992211323, 0.21935504706758024, 0.23479061970299275, 0.19634262061370256, 0.6717279595729766, 0.7779554161867809, 0.7029987201882337, 0.19382821186858779, 0.36933206509091354, 0.13994187878807385, 0.16721327925213358, 0.6874309991073664, 0.5614062055611515, 0.20795309646117366, 0.37688861512365, 0.16058582635815855, 0.22588358903013384, 0.48565689833036263, 0.15455425597396166, 0.5331439940577057, 0.7463380627598324, 0.18116779070563305, 0.18634643835397247, 0.1952173511927111, 0.17785760622925118, 0.1979713846958, 0.19225024244063182, 0.18678773612236932, 0.17104189709288298, 0.17269581616071505, 0.07874478631286586, 0.07651969028047223, 0.0888671322899447, 0.09056183121424055, 0.0855797086344583, 0.07665880426975213, 0.08563356846186065, 0.08922374144599887, 0.0858260430237271]}, "mutation_prompt": null}
{"id": "54256130-f422-4dd2-87dd-01f48ff433fb", "solution": "import numpy as np\n\nclass AdaptiveQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.2  # Adjusted chaos control for stability\n        self.exploration_probability = 0.15\n        \n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = np.linalg.norm(grad) * 0.02  # Adjusted step size for controlled exploration\n            return sol - step_size * grad\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumDifferentialEvolution", "description": "Quantum-Inspired Differential Evolution with Adaptive Chaos Control and Dynamic Population Reduction for Enhanced Global Search.", "configspace": "", "generation": 61, "fitness": 0.3005709539568989, "feedback": "The algorithm AdaptiveQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "c675a987-3ade-4f73-9b1d-51ba9e0038d1", "metadata": {"aucs": [0.8006918358606296, 0.7797017431213896, 0.7892167679503024, 0.7603291620304056, 0.7580352746702721, 0.6779738640086042, 0.7839494295729392, 0.7932353424715578, 0.7988472132247504, 0.6336531037590575, 0.6509182398927162, 0.616488941539252, 0.595391401425783, 0.6380233343275492, 0.6395497510306204, 0.6794360159283026, 0.611552702558831, 0.6464264679960244, 0.5062815512900638, 0.5238410029520719, 0.5467570064569962, 0.1667048552464636, 0.164854253567153, 0.51035130296126, 0.16342923097696216, 0.16524316670623707, 0.5884929665958111, 0.37035113234042916, 0.431118581746212, 0.13977171587835058, 0.16259879869414218, 0.15801238345069146, 0.5312550972194685, 0.11193766427349816, 0.14518548056191471, 0.12182863347289863, 0.929463635718383, 0.858594964996194, 0.9153417569577513, 0.9201064850699611, 0.9166958152913709, 0.9077700257408701, 0.9289672956532188, 0.9097586290195498, 0.9175468921575101, 0.3919791715522788, 0.29454661705673035, 0.27687869682290944, 0.3338577286469365, 0.22454112183206065, 0.18498577575357644, 0.3256196693100101, 0.21262982180655055, 0.2770088561531573, 0.21707487389915525, 0.2578470523316536, 0.29161169220358585, 0.6940815194122064, 0.633792252618695, 0.35058025275232385, 0.6414114479322404, 0.46907671466585954, 0.1833513390185334, 0.20527355852923845, 0.15199812523490042, 0.14933937917832685, 0.16151696036139618, 0.1448496786899799, 0.16396665796359156, 0.1576197987907053, 0.12226167985366587, 0.15491250478328134, 0.1429755850749943, 0.1371293754787406, 0.12082642708086444, 0.14117232410819291, 0.12693721352796727, 0.12879829132398302, 0.13499441895541864, 0.146265316035752, 0.13900741483127355, 0.008428196411655375, 9.999999999998899e-05, 0.027193071543647473, 0.02231733013059889, 0.0034033953029324326, 9.999999999998899e-05, 9.999999999998899e-05, 0.044893216641175626, 0.0371755666225827, 0.14875155729784495, 0.08607495741403981, 0.1893285971103612, 0.12546251966923883, 0.10856028030373688, 0.05541424091322966, 0.13043919752693944, 0.08504306872900202, 0.1705019166861652, 0.10123467362676197, 0.09591662138771795, 0.15043832994688777, 0.06356388878738106, 0.061741563888726314, 0.08293224508423025, 0.17164592914035692, 0.05176270704482233, 0.07276190315712516, 0.11960122523627092, 0.14816127032789395, 0.13155770203797512, 0.18799631373907266, 0.13152177208637383, 0.18745044297295954, 0.1471145748502125, 0.1274706288727231, 0.13619589160402246, 0.5632899866208514, 0.4711251282633053, 0.5144641028967272, 0.4720888188481799, 0.4857781597530988, 0.4852186343790382, 0.495331647474761, 0.48016950810676284, 0.43581581244505774, 0.12636765124840654, 0.11503149175744476, 0.11872690443438627, 0.12140107104052045, 0.09624310841322181, 0.12725190923683116, 0.1266533325128023, 0.13475813897112743, 0.12328999222041981, 0.15361969320881785, 0.20120439207510354, 0.19017336010634944, 0.2111047081944043, 0.21791117470459231, 0.23931024528781786, 0.3573923633244699, 0.21292360375624408, 0.17380386110769708, 0.3396211549892687, 0.28951543910246647, 0.3117751361345268, 0.35184034872831327, 0.3818014142694397, 0.38750968991792456, 0.3778888435218609, 0.4338191057787212, 0.3872776592891499, 0.26496866860515733, 0.23418678283101768, 0.2756642263507584, 0.28898150685067425, 0.21859999678382114, 0.24138934559307146, 0.204091819436085, 0.2548388830137652, 0.25005200206903666, 0.1827694052259008, 0.2057221761951492, 0.21721964139711591, 0.200209189766821, 0.19577762656451103, 0.20676261646252847, 0.1853312583112845, 0.18769442741334907, 0.1772586131757795, 0.23305889694230464, 0.5118882134139549, 0.201149501358325, 0.19203987533431655, 0.20444952853005383, 0.19327696037576214, 0.2142781187071383, 0.5175176167152149, 0.24024625849235492, 0.19189330007083205, 0.16806746544960283, 0.7018484099910404, 0.38262043290105907, 0.18571535399210026, 0.1549772490925061, 0.7487956075772432, 0.19517125491632237, 0.7583353590274833, 0.719385171071542, 0.20622282744737375, 0.5054208589145065, 0.4774764347866832, 0.16545678743734593, 0.16035388968046538, 0.14983459669354726, 0.27733637934012445, 0.5561397403716895, 0.18511336349454655, 0.2017560260539264, 0.17088450998912363, 0.18058786180386976, 0.1788523065044878, 0.1853328115379772, 0.18252147693452503, 0.17333978467369704, 0.1690029383002304, 0.07696841848624969, 0.08049483589159068, 0.07422339090038987, 0.08627837610133415, 0.08289510770718644, 0.07799595789592617, 0.07995427718185655, 0.07069880852167065, 0.08169890988492656]}, "mutation_prompt": null}
{"id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithEntropyControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.015  # Slightly adjusted threshold\n        self.chaos_control = 2.0  # Enhanced chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.04  # Modified step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithEntropyControl", "description": "Quantum-Inspired Differential Evolution with Entropy-Controlled Strategy Adaptation and Enhanced Chaotic Perturbation for Robust Optimization.", "configspace": "", "generation": 62, "fitness": 0.30852928961769915, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionWithEntropyControl got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "c675a987-3ade-4f73-9b1d-51ba9e0038d1", "metadata": {"aucs": [0.7922522924961742, 0.7690350606772647, 0.8031403899625889, 0.7957845439381013, 0.7956471144361177, 0.8033311407386862, 0.8101676548964717, 0.7804087280451011, 0.7940753459138208, 0.6348523670709436, 0.6441845389842025, 0.6352963322493521, 0.6297602691644406, 0.6558262194412381, 0.6612702137187714, 0.648864664755244, 0.6503750403084434, 0.6475001722207399, 0.16968651966794335, 0.5879001235073871, 0.16730592063791572, 0.5493256783145221, 0.17134504260033667, 0.4845311449987034, 0.15040867236857225, 0.3747799855430274, 0.1669871977500108, 0.13778486725585792, 0.4939330167115247, 0.15792272363452486, 0.13925050262847583, 0.13457142603375816, 0.13581838133904567, 0.06960092578155841, 0.13874130304994103, 0.11477344411244084, 0.8884390192186858, 0.8895150430316745, 0.913226809428475, 0.8876223285032266, 0.8710629818404427, 0.9011941716248566, 0.9262781285984454, 0.8679321437770038, 0.8635282495653958, 0.3312420249919342, 0.19361494522475642, 0.28169748022663466, 0.31945289558704015, 0.17504152098977244, 0.24458088368760322, 0.1438980394069227, 0.27691258246358363, 0.18712540266397248, 0.22429977137391388, 0.7361260466673702, 0.4609217464410391, 0.27205854638947535, 0.7371367604460608, 0.6571405452204439, 0.21481656248792202, 0.6842031088906828, 0.6245914867918848, 0.16845298414109766, 0.33780964595326246, 0.16634781517098052, 0.15869371143006195, 0.2736619824602877, 0.1385732928517569, 0.2296888211219985, 0.17034978887934848, 0.16474533425740812, 0.12646717539127406, 0.13614392735163294, 0.13215891829515136, 0.14363444118324065, 0.17896662518437934, 0.13988086332613425, 0.18990507781484423, 0.15857157347780937, 0.15868240316173599, 0.10168478158699779, 0.056079789688006865, 0.001108364764976777, 0.04733269107061655, 0.032981846308814955, 0.03041287504702339, 0.011208114023757099, 0.03226123640498557, 0.011331592153251635, 0.22756215612264974, 0.10335675637690633, 0.16022894559533618, 0.14850135991311963, 0.14113957391244525, 0.07249244267584831, 0.16997140806798394, 0.1146882068296674, 0.10199717624272431, 0.08588385813816946, 0.19234312594157899, 0.10253650120160995, 0.24839313401863217, 0.05902097813769902, 0.1441439319530755, 0.15415345137690417, 0.11775149063185653, 0.09674384178901141, 0.17069304382107386, 0.08318162335811707, 0.14914078423727495, 0.18061366070202745, 0.150910402383707, 0.16372769446566804, 0.11189400127351656, 0.1499471305528235, 0.137173161715761, 0.5249020564861804, 0.5153375945476848, 0.4531213486281356, 0.48477740928500057, 0.46071722156913186, 0.5399091730084192, 0.4548095253428853, 0.48996780207730906, 0.5779001168163072, 0.11689766291726755, 0.12513742422780738, 0.10222223241323458, 0.11506670038189515, 0.10021427255641424, 0.14983660998818382, 0.12143919072066833, 0.11622618637004456, 0.1209348271066969, 0.1623697722089268, 0.1873814796166876, 0.21898470410654336, 0.19083866898748925, 0.16503622998123302, 0.18556137288328223, 0.2539048011307057, 0.17921552896567605, 0.17472516207420452, 0.23256260024280706, 0.3327120625019234, 0.3876963942422883, 0.4114984493327313, 0.31997186129649646, 0.3619586321398611, 0.40514236199731624, 0.40599937352271054, 0.4489382226499471, 0.20390183707922616, 0.22968748346194945, 0.22752587080479902, 0.18649710983031376, 0.2631830524588803, 0.2270740626197023, 0.2592934759802791, 0.29183450779316, 0.32985678825030174, 0.19855587163036703, 0.185054170212947, 0.20559347553283147, 0.21701332883807245, 0.20473318756440295, 0.19665966968403037, 0.1860864711190453, 0.20036706720123898, 0.20755123891955118, 0.1917369462868761, 0.23486520431825886, 0.21552560379549068, 0.5137984848375383, 0.5899593496876383, 0.20457282201367, 0.19786169160548495, 0.22696167200024486, 0.45267690514016756, 0.1694303759749709, 0.18137839488526641, 0.7728604130105748, 0.7215372859484801, 0.6089734634456835, 0.7056146738944722, 0.7458294859500558, 0.1679095787481838, 0.5255694918600025, 0.37323380260449124, 0.20866427352573558, 0.20043603456433934, 0.22875119874181438, 0.20207431508328733, 0.19909317897498335, 0.5579274561546783, 0.5283422288296784, 0.39146791511462076, 0.1830616880838305, 0.1776524908448237, 0.17189286212176336, 0.17863288060747795, 0.1835405018015578, 0.1754309206337049, 0.19792200204570765, 0.17054842613638155, 0.1813914312904762, 0.07931295772569169, 0.09545477000007285, 0.09784109179964684, 0.08261764124675997, 0.08597191750211952, 0.07858661478211137, 0.09262617781769256, 0.08969525021460045, 0.08328728003823838]}, "mutation_prompt": null}
{"id": "ebf906ed-9e05-4cd3-8d79-d9e7ec0fea7f", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted for more exploration\n        self.f_max = 0.8  # Narrowed range to stabilize mutations\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02  # Slightly increased threshold\n        self.chaos_control = 2.5  # Further enhanced chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05  # Increased step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.6) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionEnhanced", "description": "Quantum-Inspired Differential Evolution with Enhanced Adaptive Strategy and Chaotic Dynamics for Balanced Exploration-Exploitation.", "configspace": "", "generation": 63, "fitness": 0.30688896525826664, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.8088633555204714, 0.7938208703797263, 0.7910232039360683, 0.7854325158235469, 0.7800268578782854, 0.7687955271595405, 0.7923944724406198, 0.7879099802487045, 0.7948017732960809, 0.6320301151915033, 0.6075656829119906, 0.6367587289361054, 0.6217956863222086, 0.5624321441921061, 0.6595081152107631, 0.5567322402374237, 0.5968947456373923, 0.6086446453552117, 0.5328673590859445, 0.5394312663757096, 0.16269186854819673, 0.5660430264814038, 0.16496092464150802, 0.14100707215473174, 0.15373543859774963, 0.16618654550154355, 0.15899295056966078, 0.13677027596285984, 0.17033144376137954, 0.1387671400987771, 0.12465344718699345, 0.5864607762542084, 0.5098623090055165, 0.4513756459272089, 0.17340135653292033, 0.13799106612664602, 0.8951637983264328, 0.9066347363352106, 0.9206322756970335, 0.8350257549721256, 0.8726014813997462, 0.9388398138962407, 0.9195065233817059, 0.8865236586517704, 0.8821644254917315, 0.3677852676066924, 0.34013493573889164, 0.299839685020727, 0.29985391573713527, 0.18658694229242445, 0.196366725579058, 0.34979274579269737, 0.25613529628484144, 0.2454720179129668, 0.3944372958036987, 0.3471755437550714, 0.21320266693886358, 0.7286198057452273, 0.19843490914389472, 0.7187703450496409, 0.23258627304219182, 0.6791145509552834, 0.7186235130673632, 0.1407702419960256, 0.11663831883234865, 0.17532058539701245, 0.36286670499323037, 0.11736340413977053, 0.16636770199956918, 0.1734074058705617, 0.18923100051784614, 0.3494867794471348, 0.13581102286269853, 0.12097559161296834, 0.14994653682562986, 0.13587707586931863, 0.15968739900681483, 0.14610670262888903, 0.16494552052908185, 0.1327322193945487, 0.1351778612049297, 0.09316655695767462, 0.05110314806023364, 0.09300325705196355, 0.04099549990092455, 0.052905113912567914, 0.02932507907700943, 0.0501127747796245, 0.030104503702316432, 0.11025082853718982, 0.07994309988424719, 0.12606273120449696, 0.2853060271292699, 0.06292224203526076, 0.08592324909344784, 0.13798825307943585, 0.2090415587486384, 0.17618545149483522, 0.23046733117932283, 0.08080552886679637, 0.12450977780526451, 0.11670373113044663, 0.07951698272656327, 0.08162300081644602, 0.07594790739652402, 0.14748137994749144, 0.1333965662141834, 0.09147151822472843, 0.2215180837299363, 0.1824103599585294, 0.20864454552905576, 0.2442898249097476, 0.17050914362385827, 0.16705362050615946, 0.0930788003803249, 0.10533221130991421, 0.1151011854884566, 0.532858599197484, 0.4832014775402549, 0.5176535600192615, 0.5577107944701252, 0.515449653888889, 0.5557150334381561, 0.5861123289045557, 0.5244763185491024, 0.41663884245308114, 0.10002029309572646, 0.12325276222451453, 0.14162548614826098, 0.1455428267872536, 0.10783127016801064, 0.10553081466089187, 0.13355511648141294, 0.11605953360657184, 0.10805232034652867, 0.21421731533191135, 0.180605699606035, 0.19631455983927615, 0.15598177931223123, 0.18608557524473945, 0.14600856161625964, 0.1860764475541249, 0.18728681823985893, 0.29360750641585964, 0.38252532767991765, 0.330730810581756, 0.3294811945822028, 0.33782900110086234, 0.370190998394368, 0.3796570782725932, 0.40327511527030946, 0.43970401618042865, 0.3188191077821628, 0.2316592910150851, 0.2851757984194103, 0.20641542918799416, 0.27612108532749, 0.23529840567292737, 0.33544783165721903, 0.30218027670428205, 0.23870950634808996, 0.2821684408128997, 0.21057091381483561, 0.19904777007262997, 0.1900500110731067, 0.22685150787574448, 0.22392192770629327, 0.19335970173870576, 0.1937255581405659, 0.20331597077893448, 0.22103858633307327, 0.22990868931239505, 0.19537016419314546, 0.6372688655095625, 0.21249615043585912, 0.22724755116480444, 0.2373231042802596, 0.21213912975920524, 0.21601642611824334, 0.21425492227937815, 0.15995665315735408, 0.16386623671248113, 0.7963128460307078, 0.6810568884771884, 0.18806384277801447, 0.6520252193462858, 0.46736519200128523, 0.1626622754032545, 0.8365856293833625, 0.3951550045901656, 0.20940764088655361, 0.445612752290791, 0.163821078241412, 0.3614898688660114, 0.19130944428272656, 0.2702593102319556, 0.184475555722317, 0.2415400194411118, 0.17111820400392586, 0.1804840593415321, 0.1910355250732878, 0.18621564683458647, 0.18166861986605198, 0.16962285528941756, 0.17915461972626656, 0.16678514530384114, 0.1722541651944861, 0.10253064316183313, 0.08742860870055336, 0.08731222163236907, 0.08041536723750176, 0.10050638383835753, 0.0886114113361085, 0.0862542881752868, 0.07593985672623349, 0.07504803115321845]}, "mutation_prompt": null}
{"id": "a448f755-24bc-47a9-b941-a2af125f65d1", "solution": "import numpy as np\n\nclass EntropyRegulatedQuantumEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02  # Adjusted threshold\n        self.chaos_control = 1.8  # Adjusted chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05  # Adjusted step size\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.6) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        selected = np.random.choice(indices, 3, replace=False)\n        a, b, c = self.population[selected]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EntropyRegulatedQuantumEvolution", "description": "Entropy-Regulated Quantum Evolution with Dynamic Topology and Stochastic Adaptive Control for Enhanced Optimization.", "configspace": "", "generation": 64, "fitness": 0.2937781906205902, "feedback": "The algorithm EntropyRegulatedQuantumEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7796174281828795, 0.7707579279077972, 0.784502173276057, 0.7751874303375591, 0.8076872073347932, 0.8014317693506061, 0.8003177059154364, 0.7752536657290032, 0.8041129683437687, 0.6356723249434252, 0.6461426552291136, 0.5865789953591617, 0.6262387019352166, 0.6121405433719928, 0.3580238738236079, 0.669755379556064, 0.5922567004274248, 0.6539716182281596, 0.1664905975516312, 0.17370299452843463, 0.17301458428189653, 0.14859281482113362, 0.576606047798504, 0.1739901452116781, 0.6026265306038996, 0.1731729557637387, 0.2997835008149937, 0.13352789664153497, 0.1665133022703119, 0.16484124352115537, 0.48745734899161686, 0.17317500975780276, 0.11597079982864711, 0.16529011486606981, 0.14300956711545953, 0.16069908012424416, 0.8940006894786378, 0.9188376994618408, 0.9206423671767865, 0.9042935282250052, 0.9040313278752573, 0.9433390105576415, 0.8977397942937952, 0.8637635678060738, 0.9013895330352429, 0.3053616355526436, 0.20670868150455712, 0.2628040140666329, 0.3768247405816183, 0.2492614119142329, 0.240089377366984, 0.24630481439493357, 0.2836012372822725, 0.31636430860128495, 0.218962889016038, 0.6684240100406131, 0.22958859612834115, 0.3439004649401656, 0.6083799624408255, 0.3043609459898803, 0.1712663579018905, 0.7096209626429177, 0.7368947966348853, 0.22412747272573852, 0.1183741074925696, 0.153090138900579, 0.16122565368348074, 0.11627639525905054, 0.1743746152609027, 0.26982572141072336, 0.14485960290632915, 0.16708641429362137, 0.16760273413371418, 0.11920795905702142, 0.1358101597671888, 0.19221394327058972, 0.16052418453679562, 0.1671442740822453, 0.2064886864640565, 0.1608264621120381, 0.1407075202002609, 9.999999999998899e-05, 0.06055219194422157, 0.005605653489869078, 0.03927891539233752, 0.02502775271488722, 0.007082666695492845, 0.023826915834479934, 0.025366064375075603, 0.08855936504707773, 0.07779925426806045, 0.11300900100577416, 0.11926222419838872, 0.07021370842562213, 0.04619142524498587, 0.10134114219688795, 0.12007051883464814, 0.09700881793390359, 0.12199266151744614, 0.09836572612258221, 0.04805576233871267, 0.12066080348309238, 0.056818701881944045, 0.07033068055583824, 0.06933881600016212, 0.06930330637419024, 0.09821572914152821, 0.16253073325548395, 0.0968824124686144, 0.1383415384829575, 0.21282839564392408, 0.15746379501380836, 0.0924505511535153, 0.23568668293327433, 0.2005506037326844, 0.10880319080930223, 0.21479195332132794, 0.481655968746621, 0.499793719316147, 0.4967585633179983, 0.5269112594855435, 0.465096066838827, 0.5010821408756437, 0.47841585946227083, 0.46287207250944506, 0.47954256362771375, 0.14504114641166055, 0.11782187990228343, 0.12770132811572243, 0.1562443281482132, 0.11759133440557756, 0.16559157246804113, 0.08478807652260167, 0.11137170016673514, 0.0898576071470849, 0.16108905452862787, 0.18557810883946413, 0.17000869610077896, 0.14424978031988178, 0.1444278120848954, 0.15624957311411558, 0.16771183864348893, 0.2359347174225671, 0.20645444628671528, 0.2819776703821697, 0.36134596293630294, 0.29689448370696836, 0.37813516466060804, 0.3642303382229406, 0.34573521158473797, 0.39079811128193187, 0.44409183614626224, 0.43121864735717286, 0.277508201901266, 0.25138328615647065, 0.2557189935724802, 0.2548235201223994, 0.2630619256090764, 0.2056654939021182, 0.25780991288602995, 0.28452889837509765, 0.23825264187603035, 0.19660674580047066, 0.20227243855137855, 0.19867662377633788, 0.19136930466376545, 0.21248338184784687, 0.22353336445858296, 0.20422692950722, 0.20318968302687113, 0.20597745873001272, 0.21422010980902628, 0.41168501374497035, 0.22927468840068732, 0.1902056894734977, 0.19582912383021445, 0.4774257126723729, 0.2337276920556719, 0.2098507312150899, 0.5637167681310664, 0.1632731060365672, 0.1589775801123645, 0.1779225303533314, 0.22099611733972302, 0.19095033068818457, 0.6585256688121907, 0.15790582440424517, 0.6068523729161002, 0.6435103199708652, 0.3718668941432055, 0.6322205461391668, 0.2041818227247807, 0.6177957362391382, 0.18990692490879957, 0.1994988705908065, 0.19824549447399165, 0.551989407361289, 0.13288166375243693, 0.1914475467831026, 0.17708362931614263, 0.19530767945835914, 0.17892011490936388, 0.17412087836758894, 0.18351402428191643, 0.19555089114932844, 0.1840119273916213, 0.18622165357600695, 0.09457037617147124, 0.09180972334014537, 0.08535482629592228, 0.08727766705220819, 0.0864797187228653, 0.12013480531594956, 0.07891984987911038, 0.07467678473822648, 0.08754885510232913]}, "mutation_prompt": null}
{"id": "d2a1975a-536f-43b3-9d6f-1b4f455b180e", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithEntropyControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.015  # Slightly adjusted threshold\n        self.chaos_control = 2.0  # Enhanced chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.04  # Modified step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithEntropyControl", "description": "Quantum-Inspired Differential Evolution with Entropy-Controlled Strategy Adaptation and Enhanced Chaotic Perturbation for Robust Optimization.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7922522924961742, 0.7690350606772647, 0.8031403899625889, 0.7957845439381013, 0.7956471144361177, 0.8033311407386862, 0.8101676548964717, 0.7804087280451011, 0.7940753459138208, 0.6348523670709436, 0.6441845389842025, 0.6352963322493521, 0.6297602691644406, 0.6558262194412381, 0.6612702137187714, 0.648864664755244, 0.6503750403084434, 0.6475001722207399, 0.16968651966794335, 0.5879001235073871, 0.16730592063791572, 0.5493256783145221, 0.17134504260033667, 0.4845311449987034, 0.15040867236857225, 0.3747799855430274, 0.1669871977500108, 0.13778486725585792, 0.4939330167115247, 0.15792272363452486, 0.13925050262847583, 0.13457142603375816, 0.13581838133904567, 0.06960092578155841, 0.13874130304994103, 0.11477344411244084, 0.8884390192186858, 0.8895150430316745, 0.913226809428475, 0.8876223285032266, 0.8710629818404427, 0.9011941716248566, 0.9262781285984454, 0.8679321437770038, 0.8635282495653958, 0.3312420249919342, 0.19361494522475642, 0.28169748022663466, 0.31945289558704015, 0.17504152098977244, 0.24458088368760322, 0.1438980394069227, 0.27691258246358363, 0.18712540266397248, 0.22429977137391388, 0.7361260466673702, 0.4609217464410391, 0.27205854638947535, 0.7371367604460608, 0.6571405452204439, 0.21481656248792202, 0.6842031088906828, 0.6245914867918848, 0.16845298414109766, 0.33780964595326246, 0.16634781517098052, 0.15869371143006195, 0.2736619824602877, 0.1385732928517569, 0.2296888211219985, 0.17034978887934848, 0.16474533425740812, 0.12646717539127406, 0.13614392735163294, 0.13215891829515136, 0.14363444118324065, 0.17896662518437934, 0.13988086332613425, 0.18990507781484423, 0.15857157347780937, 0.15868240316173599, 0.10168478158699779, 0.056079789688006865, 0.001108364764976777, 0.04733269107061655, 0.032981846308814955, 0.03041287504702339, 0.011208114023757099, 0.03226123640498557, 0.011331592153251635, 0.22756215612264974, 0.10335675637690633, 0.16022894559533618, 0.14850135991311963, 0.14113957391244525, 0.07249244267584831, 0.16997140806798394, 0.1146882068296674, 0.10199717624272431, 0.08588385813816946, 0.19234312594157899, 0.10253650120160995, 0.24839313401863217, 0.05902097813769902, 0.1441439319530755, 0.15415345137690417, 0.11775149063185653, 0.09674384178901141, 0.17069304382107386, 0.08318162335811707, 0.14914078423727495, 0.18061366070202745, 0.150910402383707, 0.16372769446566804, 0.11189400127351656, 0.1499471305528235, 0.137173161715761, 0.5249020564861804, 0.5153375945476848, 0.4531213486281356, 0.48477740928500057, 0.46071722156913186, 0.5399091730084192, 0.4548095253428853, 0.48996780207730906, 0.5779001168163072, 0.11689766291726755, 0.12513742422780738, 0.10222223241323458, 0.11506670038189515, 0.10021427255641424, 0.14983660998818382, 0.12143919072066833, 0.11622618637004456, 0.1209348271066969, 0.1623697722089268, 0.1873814796166876, 0.21898470410654336, 0.19083866898748925, 0.16503622998123302, 0.18556137288328223, 0.2539048011307057, 0.17921552896567605, 0.17472516207420452, 0.23256260024280706, 0.3327120625019234, 0.3876963942422883, 0.4114984493327313, 0.31997186129649646, 0.3619586321398611, 0.40514236199731624, 0.40599937352271054, 0.4489382226499471, 0.20390183707922616, 0.22968748346194945, 0.22752587080479902, 0.18649710983031376, 0.2631830524588803, 0.2270740626197023, 0.2592934759802791, 0.29183450779316, 0.32985678825030174, 0.19855587163036703, 0.185054170212947, 0.20559347553283147, 0.21701332883807245, 0.20473318756440295, 0.19665966968403037, 0.1860864711190453, 0.20036706720123898, 0.20755123891955118, 0.1917369462868761, 0.23486520431825886, 0.21552560379549068, 0.5137984848375383, 0.5899593496876383, 0.20457282201367, 0.19786169160548495, 0.22696167200024486, 0.45267690514016756, 0.1694303759749709, 0.18137839488526641, 0.7728604130105748, 0.7215372859484801, 0.6089734634456835, 0.7056146738944722, 0.7458294859500558, 0.1679095787481838, 0.5255694918600025, 0.37323380260449124, 0.20866427352573558, 0.20043603456433934, 0.22875119874181438, 0.20207431508328733, 0.19909317897498335, 0.5579274561546783, 0.5283422288296784, 0.39146791511462076, 0.1830616880838305, 0.1776524908448237, 0.17189286212176336, 0.17863288060747795, 0.1835405018015578, 0.1754309206337049, 0.19792200204570765, 0.17054842613638155, 0.1813914312904762, 0.07931295772569169, 0.09545477000007285, 0.09784109179964684, 0.08261764124675997, 0.08597191750211952, 0.07858661478211137, 0.09262617781769256, 0.08969525021460045, 0.08328728003823838]}, "mutation_prompt": null}
{"id": "03bd2769-a2b9-494e-a4f1-883443e0bc04", "solution": "import numpy as np\n\nclass EnhancedQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.2\n        self.f_max = 0.85\n        self.cr_min = 0.2\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.9\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumDifferentialEvolution", "description": "Enhanced Quantum-Enhanced Differential Evolution with Adaptive Chaos Mapping and Dynamic Population Control for Versatile Optimization.", "configspace": "", "generation": 66, "fitness": 0.2895813827462018, "feedback": "The algorithm EnhancedQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7799258491709439, 0.7871742737985533, 0.7967749604109673, 0.7838499140345954, 0.7389810209560919, 0.7919527921861567, 0.7666282690997911, 0.800084903632349, 0.8033451275788253, 0.47396688011571375, 0.6735219969193093, 0.5350369210772354, 0.5935050389655141, 0.6510024832171365, 0.5425125501001472, 0.6353021015009453, 0.6395605607480179, 0.6542392220965831, 0.5927718469379052, 0.16826017418211414, 0.6318214178402939, 0.1623773670963523, 0.40637634705729153, 0.1278004572159478, 0.5474218314229904, 0.6467546265117278, 0.4215314774253258, 0.14902049493941816, 0.5637590540461761, 0.14749381248418014, 0.1726992781861909, 0.1512687337423999, 0.1306948521019312, 0.16540358861656845, 0.16978145312097948, 0.16703509054260268, 0.8696284988472727, 0.8918439539334224, 0.8952113493475768, 0.8473432734691351, 0.870260152142777, 0.8912050041611813, 0.9243381916885449, 0.9112538107147683, 0.9071895118695171, 0.25579400052661216, 0.17877772415154392, 0.2126587228809762, 0.28170806700685624, 0.1283493000732817, 0.3034149681862146, 0.19957532106121623, 0.21818927204168725, 0.2296974479292594, 0.21478169030151373, 0.21854831426083599, 0.6250912951840766, 0.2640216493287876, 0.32697765443964955, 0.2554858868321348, 0.15240444040388867, 0.17063406393842984, 0.6960501189876214, 0.21612814925177115, 0.24572018337084356, 0.14180179208768662, 0.11704772018840381, 0.14616574489714607, 0.21442220053713146, 0.24578365931946855, 0.16286060520667967, 0.1490408288738121, 0.16134526819980166, 0.4261049780788909, 0.23023791244697867, 0.1305836543869323, 0.1332183574809358, 0.13171282824493646, 0.21350863214796212, 0.21430420431904662, 0.12642725384455988, 0.08530674929457005, 0.06923877685869462, 0.005553082931264219, 0.08261109292422641, 0.03321553134513511, 0.007445433257354139, 0.016376563207137762, 9.999999999998899e-05, 0.026126794438893874, 0.14898795845055957, 0.11733059823359948, 0.11001982299315438, 0.04710978943070099, 0.09413296770977031, 0.04761587505300047, 0.13574397129634996, 0.25313054078466846, 0.22499464581721673, 0.09410723514713193, 0.07147034787975859, 0.1556322531237665, 0.06404544044977667, 0.198606179839929, 0.05373793205544919, 0.11112107463957976, 0.11144500267365731, 0.1150429030952137, 0.13309821181735715, 0.08920737388015154, 0.12449878569476192, 0.09082333077284455, 0.06511287316386893, 0.10122768822309025, 0.16739254053067454, 0.19978992360547743, 0.10349777501406476, 0.5603031580822031, 0.5080318686945478, 0.44831056052975826, 0.45478405111383446, 0.49562940921576815, 0.44410521298274863, 0.5147341152465459, 0.5065405547436432, 0.478498379951527, 0.0877159961727979, 0.12183532150800036, 0.11439140608211962, 0.12318678643277214, 0.1321070576659884, 0.11857592529529226, 0.10267080023915442, 0.13507550892068176, 0.14067888851949029, 0.26615461617048175, 0.23725724276995497, 0.18354956551020718, 0.2790763040270534, 0.12891737566436368, 0.19910262097714193, 0.16880450738982888, 0.19377761003467042, 0.23855350030564915, 0.3395026335790873, 0.3834857044027479, 0.3969082151529477, 0.43284085521568805, 0.24346712579792718, 0.3441506980083232, 0.36611743667246, 0.4478074413573909, 0.31578972993162147, 0.22222236273633178, 0.279337372793403, 0.22415561009235296, 0.2219401992022183, 0.2830802419718581, 0.27424108735746233, 0.20458522537490664, 0.22757577649685656, 0.33806251233469975, 0.19038843674972472, 0.20442696037845032, 0.17804204900240006, 0.19434102052361724, 0.22020680060832887, 0.19435789332851916, 0.20655782406045498, 0.21943865004141694, 0.18285279255991072, 0.21391975445647937, 0.20020229450058047, 0.23618369718419685, 0.21220323571137922, 0.21236433935397103, 0.4246583835377472, 0.18185649803655657, 0.22837194002162964, 0.1967428537086171, 0.16509975503266194, 0.1735092048667991, 0.1904114689198848, 0.19344456547321265, 0.18939487637079477, 0.8539340562976172, 0.1404347119084337, 0.16357348021536655, 0.8484547529883912, 0.45169256004975933, 0.2048289614853832, 0.3759348708430441, 0.16026829854574898, 0.3998311965630851, 0.582861189559487, 0.16673166962940666, 0.15663249406167268, 0.10898979843696666, 0.17532829000820804, 0.17615790114477137, 0.16510155876583887, 0.18935490925795717, 0.17411462010565792, 0.1855055384770289, 0.18761242877764983, 0.18901932876937977, 0.19246530674186235, 0.07146452120964641, 0.08314857698566558, 0.074696389749493, 0.0810073124627152, 0.07726059595819257, 0.07813874416546118, 0.07443849174913053, 0.07833551742799993, 0.07426524238284182]}, "mutation_prompt": null}
{"id": "050035ad-73d3-4a8a-8b5e-730eb82eddae", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithEnhancedStochasticEntropy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.25  # Slightly reduced to enhance exploration\n        self.f_max = 0.8   # Slightly reduced to enhance exploration\n        self.cr_min = 0.35 # Slightly increased to enhance exploitation\n        self.cr_max = 0.85 # Slightly reduced to balance exploration\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.012  # Adjusted threshold for better convergence\n        self.chaos_control = 3.0  # Further enhanced chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            perturbation = np.random.randn(self.dim)\n            step_size = 0.05  # Adjusted step size for stochastic perturbation\n            return np.clip(sol + step_size * perturbation, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * np.sin(np.pi * x) + 0.8) % 1.0  # Used sine for chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithEnhancedStochasticEntropy", "description": "Quantum-Inspired Differential Evolution with Enhanced Stochastic Entropy-Control and Adaptive Chaotic Perturbation for Global Optimization.", "configspace": "", "generation": 67, "fitness": 0.3061955696398858, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionWithEnhancedStochasticEntropy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.8007727890839133, 0.8062330666367947, 0.7896550923476403, 0.7735663079373036, 0.8157710842270196, 0.7655185514105414, 0.5179639775865943, 0.749979724153381, 0.8219047154085803, 0.625925686790455, 0.6125915668738562, 0.6479324097184529, 0.621155000405566, 0.6112316227275536, 0.6397837799346434, 0.6371487792958401, 0.6493997041379111, 0.6628196879671697, 0.1467315302989054, 0.1681591262319937, 0.5288936273820068, 0.5948522453727798, 0.4915100163001851, 0.17029574550733884, 0.5024482372601444, 0.17073795443864814, 0.524073661926734, 0.09291571179377334, 0.16544127059519065, 0.12969924061821092, 0.482504044871786, 0.3768140302961176, 0.5518056855900683, 0.11293483535721116, 0.3946061949013445, 0.14848462680830365, 0.9019426071841375, 0.8619723330284839, 0.9149075558774318, 0.901229350037641, 0.8698639025385528, 0.8900169745074328, 0.9472895220256329, 0.8890483910927767, 0.8866428704131893, 0.37292687302692906, 0.1776840528251521, 0.27797881128210455, 0.36001296229816093, 0.29347718069209106, 0.38332947137017637, 0.19242649156989367, 0.19532566674353613, 0.2972835271491443, 0.21900425551230351, 0.48690804040341873, 0.13701131579370662, 0.26069103296534735, 0.7179935730307714, 0.21218190520145352, 0.5682484495985864, 0.33707413792406404, 0.22303581353518065, 0.16711591158814576, 0.12161303946264468, 0.1448726057387838, 0.18318652072903419, 0.13428616481459, 0.13666296192665772, 0.1597243099095691, 0.14994396272541266, 0.13695533506709656, 0.14101290316840842, 0.13687245359454714, 0.12064427088629093, 0.12458709661937395, 0.14466163729414927, 0.1743602422664401, 0.14111672145714638, 0.13910616893310113, 0.13750414519490473, 9.999999999998899e-05, 0.04280935999439994, 9.999999999998899e-05, 0.07504717668207528, 0.08357441233537011, 0.025958952135795355, 0.0066815479757764695, 0.054375603006174944, 0.046231991035420084, 0.04066764752102081, 0.10843386783278397, 0.17756503032229443, 0.08320985870426945, 0.05405235765675365, 0.052706539468101665, 0.12407363300044638, 0.13305897586803161, 0.1562755630726782, 0.05516320148381182, 0.09967551415188991, 0.1349165417782453, 0.0652499609614835, 0.06584573654202397, 0.10772149128163966, 0.14119568736994748, 0.1790394720001912, 0.16053041766116383, 0.05724413902565284, 0.10571410040794438, 0.17301880890884347, 0.20433124146984705, 0.2536995124758784, 0.20646751767308025, 0.14344883046720447, 0.15517734830287522, 0.12652590204489356, 0.5439020548566963, 0.4624422384794631, 0.5363712107413156, 0.5469950491641731, 0.4786484338044471, 0.4923575597280817, 0.46579005174772636, 0.43806083988058353, 0.5094587839130968, 0.11007182739768506, 0.1583082283291305, 0.119498984556765, 0.11880961768328302, 0.09488674470435876, 0.12414097282254277, 0.100594201822789, 0.1521494647024394, 0.11357246330481907, 0.17410106288040483, 0.19700883692547477, 0.19372215561214612, 0.13762986442364977, 0.1767108809646295, 0.20448337071497624, 0.23483388340625666, 0.20960276716544324, 0.20764730284573085, 0.3728530321017679, 0.35042049815253784, 0.32348334635335607, 0.32159692540732, 0.35917637405370617, 0.36610534080547474, 0.27156113952705296, 0.4337135471440785, 0.2953614577223722, 0.23788191799826364, 0.246838993650076, 0.2591090436296736, 0.28121282566868344, 0.2369905296553, 0.2407101928778358, 0.23209176060891035, 0.19593812453700266, 0.2850133290675876, 0.18854450213530316, 0.20548497033767832, 0.21731840606179986, 0.19249004456059382, 0.18595500607224236, 0.1981150977763807, 0.20188896563645087, 0.20662276740809749, 0.18522132219557108, 0.5949435877447358, 0.1983082359094338, 0.5974470586460117, 0.4431519948082725, 0.5342598344965153, 0.4675275661492022, 0.22609723645288826, 0.21765750643548765, 0.6071527097035287, 0.163795670673213, 0.7229690365569602, 0.19146073618804405, 0.6432834073461853, 0.5312793118569307, 0.7664358156781066, 0.13987601881696787, 0.16578829483850788, 0.7625325166496861, 0.6509803772088096, 0.20881422081348033, 0.19529728456144502, 0.1574245581765692, 0.16293956459812542, 0.46062833078691834, 0.3500212333633508, 0.20216092050385837, 0.659268101418421, 0.1926102742520347, 0.17039492981888138, 0.16495957144819162, 0.17844384539135283, 0.18652963109740528, 0.1830429657734577, 0.169490750444804, 0.17753401340405395, 0.20240100027900565, 0.08139380758150205, 0.07758031634822071, 0.07118579096204836, 0.09048995644295665, 0.08022377604760733, 0.07560177236740928, 0.07983221274678176, 0.08756199118479668, 0.08208420070438283]}, "mutation_prompt": null}
{"id": "4852cfb7-4f0a-4926-b45f-eb46ab94c7cf", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithEntropyControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted minimum scaling factor for mutation\n        self.f_max = 0.8  # Adjusted maximum scaling factor for mutation\n        self.cr_min = 0.4  # Adjusted minimum crossover probability\n        self.cr_max = 0.8  # Adjusted maximum crossover probability\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.015  # Slightly adjusted threshold\n        self.chaos_control = 2.3  # Enhanced chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.045  # Modified step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithEntropyControl", "description": "Quantum-Inspired Differential Evolution with Enhanced Adaptive Parameters and Dynamic Chaos Control for Robust and Efficient Optimization.", "configspace": "", "generation": 68, "fitness": 0.3012688795153926, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionWithEntropyControl got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7945545933146237, 0.8079010459552208, 0.79328765534474, 0.7992069249967919, 0.7692895433752777, 0.7575738464776073, 0.798204582058235, 0.7982156953099893, 0.7040178686769876, 0.6533370407069606, 0.6254300928561055, 0.6798426224584337, 0.6315967187682636, 0.6608308987973641, 0.6503969653654842, 0.5946517659970163, 0.6726874568134886, 0.6543583976644162, 0.5826847140201008, 0.1498234123042519, 0.49177623548256666, 0.5314988681559946, 0.5832384251630799, 0.15137766330309, 0.4915025132447651, 0.6619692651247133, 0.1697313482936006, 0.5291495449499263, 0.12188825279080429, 0.167806997206834, 0.14568778512973057, 0.1643376150261633, 0.14765075104498993, 0.1697250804971454, 0.16349440664071813, 0.14431913501010274, 0.9008368078623105, 0.9398060885840807, 0.9185114828665444, 0.8623937921356433, 0.8911395307206934, 0.917272641790457, 0.9473154310476757, 0.9397696077131305, 0.9192893743743766, 0.22817187446465592, 0.27263018537666983, 0.2943824997718031, 0.25222451548356317, 0.39557322260610106, 0.3235919232738276, 0.21821378526501423, 0.31007661187820934, 0.1586031440104434, 0.6705096286305858, 0.2094556299333511, 0.3111245745407316, 0.765085885835171, 0.7394653615067991, 0.36580480605479393, 0.23108348026278924, 0.16843275416407, 0.21242247325832897, 0.16084279674570645, 0.2047216242976524, 0.153232927166559, 0.19804635708462526, 0.2498152607733234, 0.20665159712373182, 0.25933398061451973, 0.18296266230468627, 0.16326068949084316, 0.1337067915620077, 0.14608674056989146, 0.2548580220972818, 0.14763505118403897, 0.15102068249475453, 0.15272924993217896, 0.11359231003777148, 0.12819221294204675, 0.1688861195517367, 0.027494649962125917, 0.07172533275488235, 0.08439712280676992, 0.0434644393479694, 0.03360910196061284, 0.03445151987071404, 9.999999999998899e-05, 9.999999999998899e-05, 0.04941747189633461, 0.14862727270189513, 0.1288615582442988, 0.19932244786234177, 0.12614524137583738, 0.11494685515453673, 0.09943642790122464, 0.11127713472008949, 0.1910650663917941, 0.1381613862506048, 0.030832870880822538, 0.13709367518440574, 0.13434176993645852, 0.06038353278525033, 0.08157447910738647, 0.13793188072465057, 0.08373689395549622, 0.10735849586715229, 0.062006668533992504, 0.11083637841706018, 0.20325052757380913, 0.13546889606668044, 0.08315784448026531, 0.18467608936547986, 0.1305474634264725, 0.1456599964366131, 0.1601602288092968, 0.07616655040394615, 0.4814977700464316, 0.4460720157496856, 0.5718055503140256, 0.4992049663290179, 0.46896325869126343, 0.45251604917782917, 0.512154209610949, 0.4950967554349378, 0.49362959438296394, 0.12082716186787879, 0.1292240447283144, 0.11435519623461476, 0.11616296100369183, 0.11917485103990022, 0.13073516315998646, 0.13062596421418893, 0.10724439498384886, 0.09634886766839335, 0.17713757353158022, 0.18287256404926888, 0.22528142901123704, 0.1627886021855356, 0.195345930886607, 0.1557363457158797, 0.2707841779624055, 0.24169052721696038, 0.12905665332173522, 0.3990912544099159, 0.3101543966847238, 0.38208839348987345, 0.312859422475819, 0.38075343527485694, 0.32964721242093453, 0.33253164163145355, 0.3922772257619215, 0.36095682493871617, 0.24066501864339718, 0.23104663699254324, 0.18662433428371605, 0.2654413422029772, 0.27577513149191935, 0.30751936847158, 0.22114511823651684, 0.30240950542620926, 0.28187052653032374, 0.1961486577930076, 0.1821249699511326, 0.19834345332544867, 0.19592255169008643, 0.18385600131620627, 0.18731612351052596, 0.21692654218438923, 0.18020332515520765, 0.1847324285421189, 0.22676367778081996, 0.23030798940524277, 0.21149640842713935, 0.21617651648622926, 0.2333342696608799, 0.20428004569771496, 0.23070537295940685, 0.21672574978584147, 0.5723941184044581, 0.18183718407904437, 0.17863111589104264, 0.18178684910499077, 0.1935937098342434, 0.6808066855910286, 0.7037111085571601, 0.14093350909012603, 0.15735382561962397, 0.7908955108099809, 0.48210239821427314, 0.47584056237134575, 0.2002998673215639, 0.39181608326395356, 0.20212753907233016, 0.6809756894904779, 0.20339105993344386, 0.1638442995113233, 0.2700591921440778, 0.1718630401503266, 0.18453686614970666, 0.1622897152756072, 0.1820214926393302, 0.19213998482198058, 0.18225999873319365, 0.18083622612816974, 0.17181763610316558, 0.18870914322633037, 0.08623323214521827, 0.07585523370865865, 0.07974324376233966, 0.07779531008396134, 0.0876295680685375, 0.10543405979354736, 0.07690695888368448, 0.08897935798611256, 0.07247795893449038]}, "mutation_prompt": null}
{"id": "0a38d42a-eb8f-4e2f-8ea0-302d015496b9", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Slightly altered for exploration focus\n        self.f_max = 0.8\n        self.cr_min = 0.2  # Broadened exploration scope\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.025  # More entropy tolerance\n        self.chaos_control = 2.5  # Enhanced chaotic dynamics\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05  # Slightly increased perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * np.sin(np.pi * x)) % 1.0  # Sinusoidal chaos enhancement\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-Inspired Differential Evolution with Controlled Entropy and Chaotic Perturbation to Efficiently Balance Exploration and Exploitation.", "configspace": "", "generation": 69, "fitness": 0.2970801314821572, "feedback": "The algorithm AdaptiveQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.6658938007174884, 0.8012086930231489, 0.8125271188434753, 0.7990461235714538, 0.7886792202351018, 0.789529051944965, 0.8060310493079385, 0.7719625299812318, 0.8040631831101975, 0.673380803842677, 0.6533707936856827, 0.6091508932801087, 0.6090618602901383, 0.6507161273284179, 0.6841611943274952, 0.6800183491281542, 0.617971953096707, 0.6700791519306435, 0.1586560856980297, 0.14872177031346256, 0.15134706449345192, 0.1490073114675231, 0.5605816385016775, 0.5775192312605224, 0.6033711713344679, 0.583942965089931, 0.16290558931924992, 0.13751184792317905, 0.15098950665868816, 0.16270116181581817, 0.1455101977998936, 0.15232042060029394, 0.14250183187062526, 0.43459250288153906, 0.5469339615288176, 0.13273148965357107, 0.8382752474069405, 0.8978308485222664, 0.9263091767651078, 0.8714803701900357, 0.9371830399330776, 0.9108007343902864, 0.8929607797793027, 0.9415953735074845, 0.9136047382114343, 0.28360097238326765, 0.09649933679161127, 0.2178492932970808, 0.33225712110353756, 0.21725774513956253, 0.15835194423430532, 0.18772960890170876, 0.2403144411319562, 0.2812357432578396, 0.22808290478146032, 0.23236926152211468, 0.614620776601368, 0.24264936366612078, 0.2583090443782208, 0.7561359992369442, 0.1716182005485809, 0.22159602059729178, 0.22693154425439754, 0.12725535479075045, 0.16301831000847522, 0.16665823665370494, 0.19134308015248658, 0.11882218117371923, 0.1592873313491031, 0.24816014475541792, 0.25941274381605806, 0.18722674240629644, 0.13837473910129194, 0.12136313038031987, 0.13296004250071658, 0.13396892124432103, 0.12244126733566918, 0.1454266529588334, 0.16506307669861686, 0.12761750368994562, 0.15421985128489046, 0.07519536566554474, 0.028208594570507728, 0.05069097416347579, 0.017813460965700134, 0.05536219884807192, 0.00021639162848119398, 9.999999999998899e-05, 0.04311937658964016, 0.12839916832213893, 0.09260165220617489, 0.062212253113758775, 0.13198832782423264, 0.0994736811739565, 0.06390201306118526, 0.06505984145770183, 0.17837329354723808, 0.1542368014559523, 0.1269233746242584, 0.0945633727409868, 0.08540509635609672, 0.2145814803229238, 0.10260071852743369, 0.11091724959341098, 0.08524751435995181, 0.1578160003254565, 0.16271215948230988, 0.12637256325224588, 0.14994514962971717, 0.162643627563269, 0.17560261388703657, 0.17410555312537146, 0.10812329687405198, 0.1332846557806322, 0.15313690989510564, 0.17169678944073563, 0.0821463769450047, 0.5054941583805115, 0.4973709071847726, 0.5107528983816516, 0.553554890566463, 0.4850121003771991, 0.47990650041274385, 0.539163148082185, 0.4661474568678303, 0.6200734872204927, 0.13166595813001458, 0.12986562407630464, 0.1248344719442186, 0.13543530936121806, 0.11485521679191957, 0.13009203236342015, 0.1254456574288877, 0.14168158587966317, 0.12349398618956753, 0.23395534402695262, 0.13219173633504855, 0.16962602725543385, 0.15834154934361455, 0.1793591629386021, 0.15748884017300313, 0.16544875032782547, 0.1705826735678655, 0.18229727701045984, 0.27686205977140954, 0.3693433899001324, 0.36310723368717834, 0.505274729866276, 0.29111832491050493, 0.41516165167610297, 0.31037516081482697, 0.4109384467999737, 0.36592903725099535, 0.1990671335236568, 0.28698383961968343, 0.2942332411754156, 0.23848462124358039, 0.24464292542475263, 0.268851981302509, 0.3037641497235001, 0.2567833511446467, 0.24783171016448824, 0.19573544498472717, 0.21477942446157972, 0.1835460375238971, 0.20627996026537698, 0.20212167258050884, 0.21025456140769083, 0.18528727080600538, 0.18750527999218725, 0.21280362153242993, 0.1986516180732193, 0.21279294941490867, 0.202706172113452, 0.4544419012466735, 0.5255966309604272, 0.5094558938617222, 0.1993118547551701, 0.2375046842323162, 0.4636959761629784, 0.1864112197526585, 0.18079804973747837, 0.16883883888379714, 0.6607782210630475, 0.20030066276075942, 0.7586653386692317, 0.13993187932573115, 0.16694326155316197, 0.8267620279310317, 0.5463964340722656, 0.19664531598150592, 0.2010612738939962, 0.48592129707084664, 0.16215844083433406, 0.5926033352797683, 0.2067862746223159, 0.15916817633508273, 0.3979721082940536, 0.18235997709644947, 0.1766360411086183, 0.17423195377098089, 0.18071207862266114, 0.1754901073174766, 0.19790546913805862, 0.1808390983710979, 0.17964377351874683, 0.18321327073413196, 0.07827783546082834, 0.08015739383519394, 0.07327335410210745, 0.07932294479354973, 0.0814093636324662, 0.0777583848750808, 0.07929661164535007, 0.07692780205917138, 0.08480560700070006]}, "mutation_prompt": null}
{"id": "390c31cb-24a2-4486-9cd8-5f631ec57309", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithEntropyControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.015  # Slightly adjusted threshold\n        self.chaos_control = 2.0  # Enhanced chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.04  # Modified step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithEntropyControl", "description": "Quantum-Inspired Differential Evolution with Entropy-Controlled Strategy Adaptation and Enhanced Chaotic Perturbation for Robust Optimization.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7922522924961742, 0.7690350606772647, 0.8031403899625889, 0.7957845439381013, 0.7956471144361177, 0.8033311407386862, 0.8101676548964717, 0.7804087280451011, 0.7940753459138208, 0.6348523670709436, 0.6441845389842025, 0.6352963322493521, 0.6297602691644406, 0.6558262194412381, 0.6612702137187714, 0.648864664755244, 0.6503750403084434, 0.6475001722207399, 0.16968651966794335, 0.5879001235073871, 0.16730592063791572, 0.5493256783145221, 0.17134504260033667, 0.4845311449987034, 0.15040867236857225, 0.3747799855430274, 0.1669871977500108, 0.13778486725585792, 0.4939330167115247, 0.15792272363452486, 0.13925050262847583, 0.13457142603375816, 0.13581838133904567, 0.06960092578155841, 0.13874130304994103, 0.11477344411244084, 0.8884390192186858, 0.8895150430316745, 0.913226809428475, 0.8876223285032266, 0.8710629818404427, 0.9011941716248566, 0.9262781285984454, 0.8679321437770038, 0.8635282495653958, 0.3312420249919342, 0.19361494522475642, 0.28169748022663466, 0.31945289558704015, 0.17504152098977244, 0.24458088368760322, 0.1438980394069227, 0.27691258246358363, 0.18712540266397248, 0.22429977137391388, 0.7361260466673702, 0.4609217464410391, 0.27205854638947535, 0.7371367604460608, 0.6571405452204439, 0.21481656248792202, 0.6842031088906828, 0.6245914867918848, 0.16845298414109766, 0.33780964595326246, 0.16634781517098052, 0.15869371143006195, 0.2736619824602877, 0.1385732928517569, 0.2296888211219985, 0.17034978887934848, 0.16474533425740812, 0.12646717539127406, 0.13614392735163294, 0.13215891829515136, 0.14363444118324065, 0.17896662518437934, 0.13988086332613425, 0.18990507781484423, 0.15857157347780937, 0.15868240316173599, 0.10168478158699779, 0.056079789688006865, 0.001108364764976777, 0.04733269107061655, 0.032981846308814955, 0.03041287504702339, 0.011208114023757099, 0.03226123640498557, 0.011331592153251635, 0.22756215612264974, 0.10335675637690633, 0.16022894559533618, 0.14850135991311963, 0.14113957391244525, 0.07249244267584831, 0.16997140806798394, 0.1146882068296674, 0.10199717624272431, 0.08588385813816946, 0.19234312594157899, 0.10253650120160995, 0.24839313401863217, 0.05902097813769902, 0.1441439319530755, 0.15415345137690417, 0.11775149063185653, 0.09674384178901141, 0.17069304382107386, 0.08318162335811707, 0.14914078423727495, 0.18061366070202745, 0.150910402383707, 0.16372769446566804, 0.11189400127351656, 0.1499471305528235, 0.137173161715761, 0.5249020564861804, 0.5153375945476848, 0.4531213486281356, 0.48477740928500057, 0.46071722156913186, 0.5399091730084192, 0.4548095253428853, 0.48996780207730906, 0.5779001168163072, 0.11689766291726755, 0.12513742422780738, 0.10222223241323458, 0.11506670038189515, 0.10021427255641424, 0.14983660998818382, 0.12143919072066833, 0.11622618637004456, 0.1209348271066969, 0.1623697722089268, 0.1873814796166876, 0.21898470410654336, 0.19083866898748925, 0.16503622998123302, 0.18556137288328223, 0.2539048011307057, 0.17921552896567605, 0.17472516207420452, 0.23256260024280706, 0.3327120625019234, 0.3876963942422883, 0.4114984493327313, 0.31997186129649646, 0.3619586321398611, 0.40514236199731624, 0.40599937352271054, 0.4489382226499471, 0.20390183707922616, 0.22968748346194945, 0.22752587080479902, 0.18649710983031376, 0.2631830524588803, 0.2270740626197023, 0.2592934759802791, 0.29183450779316, 0.32985678825030174, 0.19855587163036703, 0.185054170212947, 0.20559347553283147, 0.21701332883807245, 0.20473318756440295, 0.19665966968403037, 0.1860864711190453, 0.20036706720123898, 0.20755123891955118, 0.1917369462868761, 0.23486520431825886, 0.21552560379549068, 0.5137984848375383, 0.5899593496876383, 0.20457282201367, 0.19786169160548495, 0.22696167200024486, 0.45267690514016756, 0.1694303759749709, 0.18137839488526641, 0.7728604130105748, 0.7215372859484801, 0.6089734634456835, 0.7056146738944722, 0.7458294859500558, 0.1679095787481838, 0.5255694918600025, 0.37323380260449124, 0.20866427352573558, 0.20043603456433934, 0.22875119874181438, 0.20207431508328733, 0.19909317897498335, 0.5579274561546783, 0.5283422288296784, 0.39146791511462076, 0.1830616880838305, 0.1776524908448237, 0.17189286212176336, 0.17863288060747795, 0.1835405018015578, 0.1754309206337049, 0.19792200204570765, 0.17054842613638155, 0.1813914312904762, 0.07931295772569169, 0.09545477000007285, 0.09784109179964684, 0.08261764124675997, 0.08597191750211952, 0.07858661478211137, 0.09262617781769256, 0.08969525021460045, 0.08328728003823838]}, "mutation_prompt": null}
{"id": "b3e6bced-1e07-4b29-80da-e40e3feff2d5", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.015\n        self.chaos_control = 2.0\n        self.exploration_probability = 0.15\n        self.memory = []\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.04\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def update_memory(self, trial):\n        self.memory.append(trial)\n        if len(self.memory) > 5:  # Keep memory size manageable\n            self.memory.pop(0)\n\n    def memory_based_mutation(self):\n        if self.memory:\n            memory_candidate = self.memory[np.random.randint(len(self.memory))]\n            return np.clip(memory_candidate + np.random.randn(self.dim) * 0.1, self.lower_bound, self.upper_bound)\n        return None\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n\n                # Introduce memory-based mutation occasionally\n                if np.random.rand() < self.exploration_probability:\n                    memory_mutant = self.memory_based_mutation()\n                    if memory_mutant is not None:\n                        mutant = memory_mutant\n\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                self.update_memory(trial)\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with Dynamic Memory Mechanism and Adaptive Mutation for Improved Robustness and Diversity.", "configspace": "", "generation": 71, "fitness": 0.29551650928258305, "feedback": "The algorithm EnhancedQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7985929908230663, 0.7850310018635194, 0.7377416996415991, 0.7828926828056612, 0.7702040607950016, 0.7778188427038164, 0.7879239493867861, 0.7576100817898475, 0.8039392534230807, 0.6082951631397888, 0.6255492400011533, 0.5862682315495888, 0.5888770247072723, 0.572048881319777, 0.33297742890899407, 0.6558159746771501, 0.6228102839309834, 0.5876223601971309, 0.17038040792645892, 0.41852692466204233, 0.16846519310664676, 0.1333393239930698, 0.43073757001202007, 0.5278972103810937, 0.5335336611788033, 0.17186434540944573, 0.5612716909436117, 0.11032210343391158, 0.1498757314155862, 0.16094728031751182, 0.14936984161322509, 0.4533393347738782, 0.5188015176972833, 0.16074149170546392, 0.12126209908164798, 0.08977429193559672, 0.9293308430465348, 0.9256726582954133, 0.9189010169061567, 0.934440418889744, 0.8936335136995918, 0.8853040307738043, 0.883097832158653, 0.9198104663152461, 0.9174977000166482, 0.3047397781536876, 0.2947524265519269, 0.22894670218006852, 0.2948185925804513, 0.33053445875101806, 0.36811609157809466, 0.18801197763212918, 0.22473445423374783, 0.29916831755668305, 0.39446214048712847, 0.21853647548227817, 0.1751233163981376, 0.5579580578545351, 0.6682430410456773, 0.7519567440603768, 0.3079547242099909, 0.7792735432828571, 0.22935459968247274, 0.14710146851165462, 0.1506317557375738, 0.11933527931081767, 0.17932766962559799, 0.12164147512660761, 0.2409687706632685, 0.12208441838995188, 0.15017991553987775, 0.15770212778281256, 0.17730615576508757, 0.146341620226198, 0.20305508803835592, 0.1706060953432239, 0.1635941587606876, 0.1423460097895728, 0.18210876713008417, 0.17128431295101398, 0.11278928330080285, 0.05242986376693004, 9.999999999998899e-05, 9.999999999998899e-05, 0.024620360648362483, 0.011241189909811822, 0.01496758776620788, 0.02124590378195257, 0.030218295804540718, 0.030798210361141942, 0.16273399352218332, 0.08784400317595575, 0.1057638441833535, 0.06632394808896303, 0.0949580640649057, 0.04153705436813104, 0.142667422910272, 0.12645341313428704, 0.19740630680691462, 0.10153064608161333, 0.024586323120972753, 0.1309156511050099, 0.13923880767757657, 0.06575004268043905, 0.06301648741745158, 0.12421214267232572, 0.10160279326319555, 0.16119430313129435, 0.08716404079934759, 0.08665930192464111, 0.17478334329405676, 0.1193161462529222, 0.13815495371723352, 0.09410518988061523, 0.059274980325893956, 0.10953520453880561, 0.13818396001007982, 0.47445974941986047, 0.4894434054425635, 0.4713224408617751, 0.47299814162679277, 0.48577966850554677, 0.4874696370878425, 0.5751272430500072, 0.504036885334816, 0.47453798825181925, 0.11837310016565283, 0.1052885248478862, 0.12100496868288502, 0.1195549701810007, 0.13565279163639754, 0.12224467764170988, 0.10179206993113443, 0.11334331411726417, 0.10258275663403404, 0.16940670958649717, 0.17823304168394005, 0.16745444968363732, 0.20790833973030687, 0.14958801013774392, 0.1664267784872624, 0.23992345082074806, 0.21122911965914792, 0.1649248276976497, 0.3895496835368435, 0.3556903936423863, 0.3897047960573371, 0.36242481387930237, 0.28882879440308384, 0.2977864041612124, 0.4269945480940933, 0.45819681930507816, 0.36714807014801554, 0.25066527411202655, 0.22290402145001387, 0.27465308622851137, 0.304314608675732, 0.2983575256115871, 0.2873546324696812, 0.2628269601341363, 0.30787680212386925, 0.22731579043657602, 0.17842910654627575, 0.20446933334968076, 0.19660109091221178, 0.20070364090902537, 0.19634667061377964, 0.2032675418037101, 0.21288473844682443, 0.22307009006738243, 0.21304711199712012, 0.6462434853293959, 0.20140588606268794, 0.2039437991301083, 0.20651865902317734, 0.23864500421802004, 0.21648782820930434, 0.23060781596565116, 0.20935184873692303, 0.20866875859176326, 0.181693475390452, 0.18576796135249718, 0.5360802759859954, 0.1628471198170358, 0.19225008269656396, 0.7917196356329069, 0.6816308902218009, 0.6033776586272617, 0.4210962803857212, 0.16423333550748243, 0.20344104675464647, 0.5348971276702121, 0.44635274764945254, 0.30485059493023614, 0.20084094824529053, 0.3673571159352148, 0.1512047089667078, 0.2351249976833597, 0.17361001923340735, 0.16969009517528943, 0.1825084154266119, 0.17347146131238256, 0.17744373935693825, 0.17694367388694843, 0.1845585286943746, 0.1825053818150495, 0.18591325035740114, 0.08587326717220967, 0.07350875053929573, 0.08853798060188334, 0.08668290861573202, 0.07512629119427072, 0.07859837435221884, 0.08833825312948596, 0.08048818928798829, 0.0837276808900117]}, "mutation_prompt": null}
{"id": "15692e21-c194-4e89-b126-e273e61ad46b", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithAdaptivePerturbation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 9)  # Altered elite count\n        self.entropy_threshold = 0.015\n        self.chaos_control = 1.95  # Reduced chaos factor\n        self.exploration_probability = 0.2  # Increased probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.03  # Reduced step size\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1.0  # Modified chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithAdaptivePerturbation", "description": "Quantum-Inspired Differential Evolution with Entropy-Controlled Strategy and Adaptive Perturbation for Enhanced Optimization.", "configspace": "", "generation": 72, "fitness": 0.29255420901146123, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionWithAdaptivePerturbation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7844577863829718, 0.7671932890441303, 0.8154469191793214, 0.80437796184508, 0.7686401094031433, 0.7959884635579046, 0.7771138579388635, 0.7787524085747574, 0.7788563285014932, 0.6166684647225766, 0.5922918404462414, 0.21836952316985925, 0.5726757130023353, 0.5812327161392635, 0.636053645285678, 0.6099265236822875, 0.630091578967789, 0.6763100290556133, 0.16762520275033255, 0.5386231868689095, 0.16633992154987098, 0.12517145059125234, 0.49388626306284944, 0.4955319457787525, 0.17250340167208666, 0.16830823218691693, 0.33884984257122297, 0.16378075759197475, 0.40846579417479933, 0.1333148897327041, 0.4373626862149079, 0.14147330980842943, 0.14714413361930145, 0.12904413205091825, 0.16624147668978295, 0.15806501902295333, 0.9007409177472175, 0.9178739700730533, 0.8479803529725712, 0.8830370150834007, 0.9058700261902204, 0.9085244448569243, 0.9044742546627265, 0.8725995517041545, 0.9039012571376804, 0.2830195279523122, 0.3062172152689233, 0.31891835353987474, 0.2101194473949448, 0.17379971106512204, 0.1624262571758065, 0.15856709466026953, 0.20344871042011414, 0.2631893285137037, 0.2287918377035758, 0.2280981649500512, 0.21583417933155058, 0.777289549450093, 0.32151019130713854, 0.20837195754112037, 0.3376816371643586, 0.21774562171046807, 0.2215694757610499, 0.24131543658313004, 0.11448532162995884, 0.1855121557017434, 0.17154488213992936, 0.1870551462619583, 0.17088003745672864, 0.14226158644888542, 0.20786808234306686, 0.19177075187316972, 0.13482864581111065, 0.20063163345043844, 0.15028718105275307, 0.14453820331371847, 0.1504066980262906, 0.13360819211404018, 0.16602915894063097, 0.15687398248397988, 0.24905567982533394, 0.09121533891835021, 0.11224255092827373, 0.008152532775512866, 0.0678905231548046, 0.027957694749122908, 0.02470356048279465, 0.05197365238642759, 0.0631252928900663, 9.999999999998899e-05, 0.11510605806270591, 0.1183365932102397, 0.13012738542810642, 0.11413628934399589, 0.12495665627356067, 0.05175760090384407, 0.2583418862876147, 0.06736542496819364, 0.16643127686569337, 0.03601667740530834, 0.09987240756410376, 0.17642999578970286, 0.13517569407214758, 0.08527243246884064, 0.06276229186909332, 0.17464774377092995, 0.07464744016053737, 0.1165574059440676, 0.18957471643340762, 0.13997571528650954, 0.13993178209284163, 0.04296797250470341, 0.20716209265859753, 0.12811920585872283, 0.09809756394527924, 0.06195064991702748, 0.106818636334985, 0.5637311103705072, 0.5658141138584288, 0.4736438190766966, 0.5272024645505169, 0.5316120483972722, 0.4508412095900496, 0.5131860923966324, 0.5035294629666008, 0.4853718524038375, 0.12112311658467356, 0.10152643990702692, 0.11783464661515497, 0.09370012244006176, 0.1085349399282044, 0.13647327134435183, 0.1216033709922898, 0.12628541874886445, 0.10219035921883801, 0.165176265430378, 0.2746320592803906, 0.20476492363074217, 0.2054217742308515, 0.16479512467773016, 0.19458202197377394, 0.22231995518308756, 0.24747357343266196, 0.1740994377852787, 0.2779182879733739, 0.35150887512214124, 0.332725566256838, 0.23001586580764977, 0.3813990553224207, 0.36033895848691044, 0.413413577694108, 0.368281442623949, 0.42446530816518, 0.2270893771930621, 0.2598066323019439, 0.28343419914162005, 0.25674465954697345, 0.21796556720313787, 0.2541703130583375, 0.25601073188618484, 0.2784281209105056, 0.2643519138832131, 0.18586699913157922, 0.23669261853769563, 0.19810598781999644, 0.18314026554287488, 0.20145490911684505, 0.20812405907781006, 0.195554556925566, 0.21090948528999254, 0.2013444468579022, 0.20201925576828628, 0.5847544171197795, 0.4604622295929034, 0.19673218361313138, 0.6193306765148465, 0.1975583566786897, 0.23134312879057395, 0.20944211854303207, 0.19282540498169987, 0.19886495869013787, 0.17848582009288838, 0.1821835563255031, 0.6724507770789605, 0.5858561907864384, 0.5317363108145513, 0.5567307127602849, 0.6733117090226803, 0.8377520826684242, 0.6701848304913252, 0.20877086036896797, 0.160050055903176, 0.1928006506107287, 0.16331818385601382, 0.4457175801719272, 0.19596097625430253, 0.14632288324852494, 0.20173624699572568, 0.18491587483800165, 0.19207372379830356, 0.1658024018743659, 0.2056780744100941, 0.17268488945705918, 0.18227744240236, 0.17036868475810574, 0.18600232820780294, 0.16993322448972925, 0.07698028045983751, 0.08351892814118433, 0.08850126850879081, 0.0789010394157671, 0.08387498541154204, 0.07299289989816393, 0.07081119349457188, 0.06911441345000657, 0.0772121864850358]}, "mutation_prompt": null}
{"id": "161f9cea-b87c-4af0-adfa-3cb86e82a82a", "solution": "import numpy as np\n\nclass AdaptiveQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted minimum F\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.8  # Adjusted maximum CR\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02  # Adjusted entropy threshold\n        self.chaos_control = 2.2  # Enhanced chaos factor\n        self.exploration_probability = 0.2  # Increased exploration probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05  # Adjusted step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.75) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "AdaptiveQuantumInspiredDifferentialEvolution", "description": "Adaptive Quantum-Inspired Differential Evolution with Entropy-Controlled Strategy and Enhanced Chaotic Perturbation for Diverse Optimization.", "configspace": "", "generation": 73, "fitness": 0.2992688983627839, "feedback": "The algorithm AdaptiveQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7767834926468443, 0.7863626545869078, 0.7835478400533453, 0.7879525193247642, 0.7925829274620284, 0.796710160564797, 0.7741542963788344, 0.7693252294981783, 0.7716773067533654, 0.6111523111911523, 0.6248947516408985, 0.6536594295853332, 0.6369791924420973, 0.6193312246248248, 0.6311619788149868, 0.6090423346043514, 0.6039893190173777, 0.6672573266974176, 0.4782524484766787, 0.5107671541179395, 0.16832460624546586, 0.45229052202874764, 0.17270252726215474, 0.5439894715209, 0.46649751548427143, 0.5018926383868372, 0.5262365708244845, 0.3608496829661475, 0.13984380435861277, 0.436176146345837, 0.1663684673031185, 0.42729928944787776, 0.1646975715975434, 0.3193073984493693, 0.1653217365820172, 0.3601700238983623, 0.9144692964465525, 0.8785540706360461, 0.9074995989224139, 0.9170950147496976, 0.9636337023713977, 0.9038767805207554, 0.9355598025048069, 0.9200837276465266, 0.9431075757196311, 0.315019727752038, 0.284053320759984, 0.32069234112163225, 0.2520256172980312, 0.27678406378744536, 0.3394196075885043, 0.29627514144859557, 0.18446176172930118, 0.2887494902384836, 0.27513095621113326, 0.31098148986124485, 0.21512317378619872, 0.26605504160308735, 0.5068904187288206, 0.266032314651902, 0.5222644786026329, 0.22094816400973893, 0.690193637920173, 0.20484161940680023, 0.10920796251736065, 0.17014723481723337, 0.2199524191819513, 0.11657681583616109, 0.16052342323077684, 0.25587630207538326, 0.15402347220242696, 0.16728917800091425, 0.009281172007892025, 0.13391908944499697, 0.14922848324144067, 0.13191352609485985, 0.17084325211111795, 0.17569930301097358, 0.18762627584734526, 0.14785881914695342, 0.1581487839609339, 0.05444083546608913, 0.015061365961127726, 0.007545337753659065, 0.02544359943677521, 0.03309951740927897, 0.05100795730349439, 0.026798082894082698, 0.0389083870448792, 0.0385887639066923, 0.13254304845653964, 0.08423834042387401, 0.11399468268379476, 0.13965977261112206, 0.057540082936984094, 0.09104673188206758, 0.12447810717796892, 0.08961485434409755, 0.21742067487789762, 0.040745880028584924, 0.0694411172008429, 0.0858354283623699, 0.08228219121153102, 0.03158051006577589, 0.05463347126827034, 0.05913286894772973, 0.05851693580967399, 0.13045900122394816, 0.12072637690303678, 0.14294707117926375, 0.1680414463055644, 0.06234107049508841, 0.18677804999903036, 0.16325642272327, 0.13052786318391685, 0.09708124884775493, 0.07557375132360544, 0.5673376147494882, 0.4928139751857039, 0.5353713432080929, 0.4938538529624833, 0.5371847889984764, 0.48326847932091377, 0.49801172340283195, 0.5024541385763517, 0.5577236816861719, 0.11238906634441115, 0.09767017652231991, 0.1133075279565452, 0.09818938038045599, 0.09731943899629225, 0.10975985194623716, 0.1157057460081482, 0.11401056275945443, 0.11711068019572735, 0.13840787888408757, 0.16103062245345845, 0.1505769848415568, 0.14603660945466324, 0.19557473992205077, 0.153644894573702, 0.16836204322234138, 0.17660061848599218, 0.13044205013900645, 0.2919607662461501, 0.36345245698993434, 0.405158343053472, 0.35509591313269173, 0.39755404598733735, 0.3346054166066499, 0.3804676288196367, 0.38881895956247603, 0.37083742629060723, 0.27109471272331076, 0.23589354793508177, 0.2300869716789713, 0.213842516225919, 0.2822875504327673, 0.2249214030575034, 0.23994770522804099, 0.28479396141579005, 0.241545476966618, 0.21232644006352852, 0.19930891509979454, 0.17559985685173196, 0.19000899192493648, 0.19715728743649286, 0.18051827599738768, 0.20706207840208068, 0.179848816537448, 0.18896679752876677, 0.31487220235702396, 0.5222359998459545, 0.20350823958507813, 0.43757528494307485, 0.22659019330286312, 0.623138600780373, 0.2279314131273853, 0.47559086126430294, 0.20834904592541503, 0.16198282281776955, 0.18051368333275752, 0.6807400454421133, 0.19517259087090566, 0.16650601334807236, 0.17079020342042928, 0.15838932324812305, 0.6622674501197314, 0.59766659591513, 0.49635674824703935, 0.20802941129012154, 0.4762669645423151, 0.2059797460857299, 0.16091672980145444, 0.5056967269167311, 0.15854736630677524, 0.1509419336095349, 0.30150554808222696, 0.17050218699547293, 0.16819488791123827, 0.17668589004381607, 0.20820954964921068, 0.19447285819475524, 0.1711976160208284, 0.17226824601981394, 0.1851753810141158, 0.18613535107026624, 0.08334445719697181, 0.08351291268152505, 0.08173439823692241, 0.08376205975542139, 0.08898812656450861, 0.07402694144120958, 0.07514094896821955, 0.08065149796589999, 0.07587609114474902]}, "mutation_prompt": null}
{"id": "4253a93a-47a2-490b-a60a-cb69ffec8a42", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithEntropyControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.015  # Slightly adjusted threshold\n        self.chaos_control = 2.0  # Enhanced chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.04  # Modified step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithEntropyControl", "description": "Quantum-Inspired Differential Evolution with Entropy-Controlled Strategy Adaptation and Enhanced Chaotic Perturbation for Robust Optimization.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7922522924961742, 0.7690350606772647, 0.8031403899625889, 0.7957845439381013, 0.7956471144361177, 0.8033311407386862, 0.8101676548964717, 0.7804087280451011, 0.7940753459138208, 0.6348523670709436, 0.6441845389842025, 0.6352963322493521, 0.6297602691644406, 0.6558262194412381, 0.6612702137187714, 0.648864664755244, 0.6503750403084434, 0.6475001722207399, 0.16968651966794335, 0.5879001235073871, 0.16730592063791572, 0.5493256783145221, 0.17134504260033667, 0.4845311449987034, 0.15040867236857225, 0.3747799855430274, 0.1669871977500108, 0.13778486725585792, 0.4939330167115247, 0.15792272363452486, 0.13925050262847583, 0.13457142603375816, 0.13581838133904567, 0.06960092578155841, 0.13874130304994103, 0.11477344411244084, 0.8884390192186858, 0.8895150430316745, 0.913226809428475, 0.8876223285032266, 0.8710629818404427, 0.9011941716248566, 0.9262781285984454, 0.8679321437770038, 0.8635282495653958, 0.3312420249919342, 0.19361494522475642, 0.28169748022663466, 0.31945289558704015, 0.17504152098977244, 0.24458088368760322, 0.1438980394069227, 0.27691258246358363, 0.18712540266397248, 0.22429977137391388, 0.7361260466673702, 0.4609217464410391, 0.27205854638947535, 0.7371367604460608, 0.6571405452204439, 0.21481656248792202, 0.6842031088906828, 0.6245914867918848, 0.16845298414109766, 0.33780964595326246, 0.16634781517098052, 0.15869371143006195, 0.2736619824602877, 0.1385732928517569, 0.2296888211219985, 0.17034978887934848, 0.16474533425740812, 0.12646717539127406, 0.13614392735163294, 0.13215891829515136, 0.14363444118324065, 0.17896662518437934, 0.13988086332613425, 0.18990507781484423, 0.15857157347780937, 0.15868240316173599, 0.10168478158699779, 0.056079789688006865, 0.001108364764976777, 0.04733269107061655, 0.032981846308814955, 0.03041287504702339, 0.011208114023757099, 0.03226123640498557, 0.011331592153251635, 0.22756215612264974, 0.10335675637690633, 0.16022894559533618, 0.14850135991311963, 0.14113957391244525, 0.07249244267584831, 0.16997140806798394, 0.1146882068296674, 0.10199717624272431, 0.08588385813816946, 0.19234312594157899, 0.10253650120160995, 0.24839313401863217, 0.05902097813769902, 0.1441439319530755, 0.15415345137690417, 0.11775149063185653, 0.09674384178901141, 0.17069304382107386, 0.08318162335811707, 0.14914078423727495, 0.18061366070202745, 0.150910402383707, 0.16372769446566804, 0.11189400127351656, 0.1499471305528235, 0.137173161715761, 0.5249020564861804, 0.5153375945476848, 0.4531213486281356, 0.48477740928500057, 0.46071722156913186, 0.5399091730084192, 0.4548095253428853, 0.48996780207730906, 0.5779001168163072, 0.11689766291726755, 0.12513742422780738, 0.10222223241323458, 0.11506670038189515, 0.10021427255641424, 0.14983660998818382, 0.12143919072066833, 0.11622618637004456, 0.1209348271066969, 0.1623697722089268, 0.1873814796166876, 0.21898470410654336, 0.19083866898748925, 0.16503622998123302, 0.18556137288328223, 0.2539048011307057, 0.17921552896567605, 0.17472516207420452, 0.23256260024280706, 0.3327120625019234, 0.3876963942422883, 0.4114984493327313, 0.31997186129649646, 0.3619586321398611, 0.40514236199731624, 0.40599937352271054, 0.4489382226499471, 0.20390183707922616, 0.22968748346194945, 0.22752587080479902, 0.18649710983031376, 0.2631830524588803, 0.2270740626197023, 0.2592934759802791, 0.29183450779316, 0.32985678825030174, 0.19855587163036703, 0.185054170212947, 0.20559347553283147, 0.21701332883807245, 0.20473318756440295, 0.19665966968403037, 0.1860864711190453, 0.20036706720123898, 0.20755123891955118, 0.1917369462868761, 0.23486520431825886, 0.21552560379549068, 0.5137984848375383, 0.5899593496876383, 0.20457282201367, 0.19786169160548495, 0.22696167200024486, 0.45267690514016756, 0.1694303759749709, 0.18137839488526641, 0.7728604130105748, 0.7215372859484801, 0.6089734634456835, 0.7056146738944722, 0.7458294859500558, 0.1679095787481838, 0.5255694918600025, 0.37323380260449124, 0.20866427352573558, 0.20043603456433934, 0.22875119874181438, 0.20207431508328733, 0.19909317897498335, 0.5579274561546783, 0.5283422288296784, 0.39146791511462076, 0.1830616880838305, 0.1776524908448237, 0.17189286212176336, 0.17863288060747795, 0.1835405018015578, 0.1754309206337049, 0.19792200204570765, 0.17054842613638155, 0.1813914312904762, 0.07931295772569169, 0.09545477000007285, 0.09784109179964684, 0.08261764124675997, 0.08597191750211952, 0.07858661478211137, 0.09262617781769256, 0.08969525021460045, 0.08328728003823838]}, "mutation_prompt": null}
{"id": "8cfc86db-0e76-4fa7-888a-82dfce54ffa2", "solution": "import numpy as np\n\nclass EnhancedQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.2\n        self.f_max = 0.8\n        self.cr_min = 0.4\n        self.cr_max = 0.9\n        self.entropy_threshold = 0.02\n        self.chaos_control = 2.5\n        self.exploration_probability = 0.2\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:max(3, self.population_size // 10)]\n            elites = self.population[elite_indices]\n            self.population[:len(elites)] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution using Population Diversity and Adaptive Chaotic Perturbations for Robust Optimization.", "configspace": "", "generation": 75, "fitness": 0.2808363006454325, "feedback": "The algorithm EnhancedQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7724301798826418, 0.7633179423574471, 0.7673704979224802, 0.7296324492397732, 0.7698925472043865, 0.7531077799809025, 0.775903226491178, 0.7721715206766743, 0.7249341697064108, 0.5247990800801752, 0.5813665978577407, 0.5486395725106111, 0.5743080692621292, 0.5741122932035483, 0.6295490435365094, 0.5687956737637543, 0.5552684433726581, 0.5980835620954215, 0.15461081011955535, 0.48593239872248173, 0.13594857484881828, 0.5343889591096203, 0.16802322350369847, 0.49168641356197607, 0.16721618662129656, 0.45269399014855194, 0.17043997604344474, 0.15934118240323492, 0.15920595140942984, 0.12833626344215865, 0.2117092472105464, 0.11185471059876706, 0.13942843004252514, 0.16314964814712707, 0.11501748878130369, 0.14251307174574324, 0.8563989065503663, 0.88328090825423, 0.8016625816545094, 0.9150376624356957, 0.8335116418494775, 0.8205834667283041, 0.9104784137114628, 0.8602440449002213, 0.829658352036176, 0.29966984465445345, 0.2990866882836738, 0.21586602339060768, 0.20357241165208761, 0.12885591043013012, 0.2650053475209926, 0.1150161066986557, 0.17188588536135596, 0.32283185794394575, 0.31302996202085887, 0.34203477672585336, 0.7522107014965682, 0.6768575548486488, 0.31552223940351487, 0.3323789680162931, 0.22854299765870734, 0.7283489400972222, 0.6892971571381463, 0.18247142302648167, 0.21050514825770317, 0.17958008702885164, 0.13729962517355976, 0.2177506219067974, 0.10996525726966755, 0.21587052930920847, 0.2033514573629832, 0.1665878162908957, 0.14137825056081432, 0.14208100711131444, 0.1448256486840972, 0.12747926705851986, 0.15542062955652203, 0.15029334601014177, 0.14864914956325825, 0.157126270621197, 0.18143559709667012, 9.999999999998899e-05, 0.046166521404931715, 0.06530459314147519, 0.02957397539506834, 0.05367104212748841, 0.005955156215211921, 0.16894020816284594, 9.999999999998899e-05, 9.999999999998899e-05, 0.1513454621484116, 0.05935872368570183, 0.09171001668676704, 0.0533718694505918, 0.15878138901475336, 0.14842490263583696, 0.10525181829478802, 0.17415837056817984, 0.12225650796182308, 0.09103404624528522, 0.09484816555675846, 0.11159110231778613, 0.0638564252865117, 0.10005756481824957, 0.07714096540066584, 0.10118759343982708, 0.06656910187455611, 0.1724928275120754, 0.1497517507943532, 0.15947348389627625, 0.18298827227326242, 0.07648640686932706, 0.09760066579138038, 0.22127834806545865, 0.1261061230868803, 0.07947296937676018, 0.1518550818876101, 0.5586901600194972, 0.4018827736828302, 0.5069734954370919, 0.4853574274802306, 0.4190754351057635, 0.4917853351623235, 0.49569973940434664, 0.45857736626795065, 0.530844166285319, 0.15001339610336384, 0.11822085312034591, 0.08265049438127736, 0.11987046948344504, 0.11138513902164504, 0.12639252962485847, 0.13272851797487106, 0.13266845764829072, 0.10113962134125654, 0.24447592589380407, 0.15743890279051553, 0.21722436620999608, 0.2383437452767747, 0.1627207792659825, 0.18098558576848633, 0.1424894903612467, 0.20088400498090497, 0.22508438746105364, 0.25652923777159653, 0.3056521713028737, 0.36175858954115014, 0.2957885913556768, 0.324570795593332, 0.3865660887118707, 0.40084461232762547, 0.43059434031102606, 0.34022853256563435, 0.21406681787423731, 0.2710726576821604, 0.2525578759549102, 0.21237441815981362, 0.2835964508108375, 0.18765387762225938, 0.2086225190303257, 0.27409792084721807, 0.24627258346415715, 0.19310705847154064, 0.221166017398857, 0.19144778211891456, 0.18313024241006448, 0.20985505692518513, 0.1910754189775039, 0.2096114374157131, 0.21870640751138237, 0.19203941725386742, 0.22827205242116844, 0.200654425432356, 0.21353564102199263, 0.20870371283413391, 0.1971284974460703, 0.20871852265288682, 0.2082625498552061, 0.2097220691418472, 0.21177977868613485, 0.5469775472675016, 0.1761845023593338, 0.18229401673022205, 0.18094661773031795, 0.46890026981083077, 0.20923816902169257, 0.14752209178926257, 0.7465438325848845, 0.7432365209911467, 0.487019581724248, 0.20096769891189692, 0.20189348701788257, 0.1625607675270465, 0.19600745278214016, 0.19565015891201654, 0.20149746430125914, 0.15157215079980202, 0.2027367289220685, 0.17479339768871138, 0.17633885499002422, 0.18273279254353614, 0.1662290569346485, 0.1678855421105, 0.17555951723646301, 0.19845757448577384, 0.19879395976100211, 0.1735980086476222, 0.08146928941860077, 0.0749544964076867, 0.08285507945000425, 0.0907051771359838, 0.08818782492799415, 0.08038514714126743, 0.09244620509663615, 0.08154608076718373, 0.11210603068877212]}, "mutation_prompt": null}
{"id": "4dcaa8da-855e-47fe-bb24-1418d964c230", "solution": "import numpy as np\n\nclass HybridQuantumDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.8\n        self.cr_min = 0.2\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02  # Adjusted entropy threshold\n        self.chaos_control = 2.4  # Enhanced chaos control\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05  # Adjusted step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.85) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "HybridQuantumDifferentialEvolution", "description": "Hybrid Quantum-Inspired Differential Evolution with Adaptive Entropy and Chaotic Dynamics for Enhanced Convergence.", "configspace": "", "generation": 76, "fitness": 0.29374735408074276, "feedback": "The algorithm HybridQuantumDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.8038329672037057, 0.7853781161619968, 0.7890881729050899, 0.7825623935970152, 0.7918180328370957, 0.740425369042325, 0.789903981038743, 0.8128989470254954, 0.7894651994653343, 0.6539612194982645, 0.6736885705592693, 0.6209178798159365, 0.6242055413464178, 0.5889293836681779, 0.6468669735911434, 0.6361334726891489, 0.5947850733553671, 0.6331873001119805, 0.6225327287100948, 0.537142361644187, 0.1619122893281134, 0.16856963864815877, 0.5747672814132271, 0.5509319730209616, 0.5607755411527302, 0.1727505054146925, 0.5943406352099296, 0.16367963901237048, 0.16046340490593136, 0.14512263584413487, 0.16888287915246347, 0.16019304131857737, 0.1478171223792869, 0.11349629859465515, 0.16484940320746633, 0.1448880961607456, 0.8784882105803944, 0.8840863446674379, 0.9205346364040006, 0.8978954371599767, 0.8792280121523379, 0.9229919566127217, 0.9063747138494943, 0.953437082574863, 0.9099441955299522, 0.3210396367280933, 0.2319754135320049, 0.1532100059996936, 0.3064331311171662, 0.21370969442421472, 0.3719783474324777, 0.2818326418358089, 0.24853425783667382, 0.2812831876448211, 0.4361023667660776, 0.2063066931584443, 0.23017155819827362, 0.2617416669583664, 0.34420005366921236, 0.19944489864591586, 0.20677787005157233, 0.31040238446336843, 0.6035486539802074, 0.21179232166008655, 0.17015721335939793, 0.15027246158185903, 0.14929292242789982, 0.14418090047487808, 0.19393125475743633, 0.21234609965845197, 0.14852175794454503, 0.131584133285917, 0.13698121020129583, 0.1523734439432206, 0.14691857500916028, 0.14749492216862414, 0.14287875411955175, 0.15136390716206538, 0.1140191876655976, 0.18724743525166732, 0.13574549756667043, 0.0010894175727257371, 0.06456372030858837, 0.00981744160017084, 0.041891197788746504, 0.06538044805949395, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06041496443648264, 0.10130269090929667, 0.10594193311876476, 0.09823359229742623, 0.07090281122449471, 0.13869681006564372, 0.06510425964970712, 0.1535140824388742, 0.08671690619034567, 0.18208534657402042, 0.11426340253212797, 0.025309826852479844, 0.13924390537617115, 0.0840353800320871, 0.05038555427853242, 0.07111811275925484, 0.21869278051429764, 0.06480152191123911, 0.04820866065808582, 0.10994055910951905, 0.07663944785902554, 0.21133674964980254, 0.18060908609057458, 0.14427524070749098, 0.18093502000753703, 0.15869319288756412, 0.1074256097709716, 0.07602219855753733, 0.5582002229316634, 0.4818436075955119, 0.5272524445294806, 0.48370386049551894, 0.47323652761622115, 0.47697402387009236, 0.5451571464741645, 0.4516795295654539, 0.4609350118103599, 0.11863906593513984, 0.10125035723732778, 0.26395567394724373, 0.12069054049424799, 0.11599009772368207, 0.12123371310741837, 0.10626006365893703, 0.12147278218016233, 0.08707916743100685, 0.17583972484818844, 0.22750659542893548, 0.17899664942063387, 0.16726571765583742, 0.1471721049513024, 0.15109313554559833, 0.1479134770879026, 0.1703704102617516, 0.1671348183971435, 0.3083856790402517, 0.2728489655822748, 0.3494514868951941, 0.3936306658398835, 0.35434689806171205, 0.4495651361606282, 0.40757194168505007, 0.4087271361803271, 0.35754539835152577, 0.2064358308553491, 0.18584077809635424, 0.28061229036586566, 0.22864547138452862, 0.2595955881316693, 0.20096032546083986, 0.24368774875553867, 0.28944505552455335, 0.24371797725807776, 0.21988984993370986, 0.20288471395530283, 0.22986130444368524, 0.22424257795374258, 0.20038489415292615, 0.20683256711970666, 0.20520235224107175, 0.1973195672457133, 0.20286422148666183, 0.372221710564675, 0.2136240394613913, 0.225261238372657, 0.5254727826182359, 0.20511656699602743, 0.21641651811073737, 0.21351499079157854, 0.23768749789937949, 0.22609270021020866, 0.1792176022928461, 0.6493382614993897, 0.1801357387587985, 0.6427254786283227, 0.5599361599972664, 0.5511187649074215, 0.6935009478527592, 0.2657541924100536, 0.5502521317745009, 0.46905155784791863, 0.20602763515886036, 0.23974676839405773, 0.19379442920311984, 0.20047335255960042, 0.19584761664704864, 0.15606402205020298, 0.3430422138217929, 0.3413633434867779, 0.1732741808799767, 0.16312916022196555, 0.19671970574153197, 0.18532623163063322, 0.1828591994015797, 0.18214205484561774, 0.1840041599132356, 0.17629771799916505, 0.1779756610715585, 0.07789202198373513, 0.08566128022136399, 0.08175754801898782, 0.08481004100581935, 0.08061373694788765, 0.08240086029836324, 0.08018064028721561, 0.07684476556688369, 0.07756736969501399]}, "mutation_prompt": null}
{"id": "2e943501-3d94-4128-ba8f-53470406cac3", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithEntropyControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.8\n        self.cr_min = 0.2\n        self.cr_max = 0.85\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02  # Adjusted threshold\n        self.chaos_control = 2.5  # Enhanced chaos factor\n        self.exploration_probability = 0.2\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.03  # Modified step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.6) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithEntropyControl", "description": "Quantum-Inspired Differential Evolution with Adaptive Entropy-Controlled Strategy and Enhanced Stochastic Perturbation for Effective Global Optimization.", "configspace": "", "generation": 77, "fitness": 0.29712423283390393, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionWithEntropyControl got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7940139951184924, 0.7578247940436262, 0.7814454361617377, 0.7941686386906974, 0.7498024523207367, 0.7888650934660534, 0.7902409086718579, 0.7776713629142373, 0.7672166082091776, 0.6167779743249127, 0.6239236216697308, 0.6648299271432112, 0.6296304104482471, 0.6491108438235493, 0.603271633424129, 0.6305550086300596, 0.6097704505537537, 0.6229403499253642, 0.16240160112350988, 0.5675167452304826, 0.5084655938036385, 0.17016292811061906, 0.17005220694270717, 0.1615481244219572, 0.17390995925689423, 0.17201741811688476, 0.48636650004873905, 0.1318338190543562, 0.4673030483032672, 0.16792997283471378, 0.1605474962192711, 0.16150648859453054, 0.14438210489682846, 0.4435430112773393, 0.16137164121727787, 0.16101379616508804, 0.9422696020849229, 0.8853511368452213, 0.9154223488196971, 0.8983300151842489, 0.9375012351984184, 0.8827193711099808, 0.917520452739115, 0.9201649731228723, 0.9246900848633149, 0.2936306314893321, 0.3338039609460167, 0.19850012074949241, 0.3244006726608504, 0.29837473497873, 0.30095202797357845, 0.2204865360371645, 0.17980883878830334, 0.3447734256931536, 0.47938438857137544, 0.2162474850171363, 0.2099141067131245, 0.6869322845131057, 0.3491526266225865, 0.32359068580218786, 0.6380923291956035, 0.6725600478093777, 0.7982124483135091, 0.1439325950310737, 0.15397391093253665, 0.14050052892784037, 0.13946941797858803, 0.20704253487584534, 0.20781476021754963, 0.17959492308393965, 0.1663112716087286, 0.18162098214372446, 0.18649342648945655, 0.18415315382390474, 0.16436226355080508, 0.14939016667815508, 0.17053027865914028, 0.19027961166671958, 0.15041052177529513, 0.1698358683902199, 0.1802860267504106, 0.12169685688538667, 0.04649565692957003, 0.08101281024254492, 0.029131392473214723, 0.02669115675145528, 0.015671073878913866, 0.0720889449999651, 0.06724215787056986, 0.07175749711056345, 0.0952122999780255, 0.13757539448365863, 0.12609584631985704, 0.11141561503993869, 0.14229211276665787, 0.0631863954251477, 0.10269336378998906, 0.13307039743075677, 0.13879936329551834, 0.10836465392473837, 0.16533114853759123, 0.20858707870413085, 0.0696669974085502, 0.09485324786503369, 0.12569675547117454, 0.17356532437714844, 0.12406136299048542, 0.11844035300577038, 0.11367011501714386, 0.06227977325708345, 0.10308190261244998, 0.05024232755044855, 0.15358357184013638, 0.22600499032287658, 0.0926159583782219, 0.16394877198045799, 0.1839553127236886, 0.453456626446506, 0.4965435222146849, 0.5453637363519407, 0.507164507421228, 0.505957447578671, 0.4589742013371342, 0.5460479941271719, 0.5190155613030021, 0.528822032216349, 0.10098997624508155, 0.11627448863302015, 0.10542468060723442, 0.11187632918427393, 0.12353319987275446, 0.11934775480808457, 0.0911822931864803, 0.11594624498332684, 0.10964756229898343, 0.164734818801185, 0.15337637884248156, 0.16918805790070224, 0.1917713405713123, 0.1573678595932011, 0.15071442724950435, 0.15707206791191197, 0.1821663091616762, 0.17917098235731832, 0.3543598922537897, 0.33010196030422745, 0.28515256418920043, 0.313438031482963, 0.380580928532227, 0.316646566494201, 0.31719633636578415, 0.3861668511462695, 0.3718796535923218, 0.2194740293987113, 0.19400513440316147, 0.23207440605869112, 0.2132492870046091, 0.20766000549942154, 0.23729598083369297, 0.278808590802586, 0.26825962137180714, 0.2155870682538693, 0.19636694918995168, 0.20933408409137333, 0.20342743747214798, 0.1961870085678783, 0.20766811618076264, 0.18656987789705792, 0.20497072868823685, 0.21967061177600666, 0.19926769531648114, 0.21662180729544733, 0.5240721388063411, 0.24789361650496522, 0.3584417745369872, 0.2414487573515457, 0.40147587553112973, 0.48589683630982194, 0.22438789005782112, 0.21051907071203324, 0.14480811596308463, 0.5299050523670585, 0.19382674954753287, 0.3793374978214531, 0.34198262995733064, 0.7378580594314037, 0.13870023872695347, 0.1652497981418639, 0.8104492571795415, 0.7154761057125365, 0.2086909134385616, 0.19286385253483185, 0.20464677388842412, 0.19316356457300987, 0.16604934383018022, 0.1576202315635623, 0.16442053838639548, 0.1946265305284096, 0.16858424719010034, 0.17152312940266978, 0.17046356331122792, 0.1657788862518642, 0.1922711071214105, 0.18057786419590705, 0.1820218356842933, 0.19027230004801, 0.1669782512925314, 0.08125256549084459, 0.07955183351148121, 0.08813652295889096, 0.07879524016323192, 0.08391079189388406, 0.08297369682990141, 0.08254177066450352, 0.07845741260689887, 0.0749816732118308]}, "mutation_prompt": null}
{"id": "c1c19edc-82b9-49b0-a08d-432e193a26a5", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithEntropyControl:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.015  # Slightly adjusted threshold\n        self.chaos_control = 2.0  # Enhanced chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.04  # Modified step size for perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1.0  # Adjusted chaotic behavior\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithEntropyControl", "description": "Quantum-Inspired Differential Evolution with Entropy-Controlled Strategy Adaptation and Enhanced Chaotic Perturbation for Robust Optimization.", "configspace": "", "generation": 63, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7922522924961742, 0.7690350606772647, 0.8031403899625889, 0.7957845439381013, 0.7956471144361177, 0.8033311407386862, 0.8101676548964717, 0.7804087280451011, 0.7940753459138208, 0.6348523670709436, 0.6441845389842025, 0.6352963322493521, 0.6297602691644406, 0.6558262194412381, 0.6612702137187714, 0.648864664755244, 0.6503750403084434, 0.6475001722207399, 0.16968651966794335, 0.5879001235073871, 0.16730592063791572, 0.5493256783145221, 0.17134504260033667, 0.4845311449987034, 0.15040867236857225, 0.3747799855430274, 0.1669871977500108, 0.13778486725585792, 0.4939330167115247, 0.15792272363452486, 0.13925050262847583, 0.13457142603375816, 0.13581838133904567, 0.06960092578155841, 0.13874130304994103, 0.11477344411244084, 0.8884390192186858, 0.8895150430316745, 0.913226809428475, 0.8876223285032266, 0.8710629818404427, 0.9011941716248566, 0.9262781285984454, 0.8679321437770038, 0.8635282495653958, 0.3312420249919342, 0.19361494522475642, 0.28169748022663466, 0.31945289558704015, 0.17504152098977244, 0.24458088368760322, 0.1438980394069227, 0.27691258246358363, 0.18712540266397248, 0.22429977137391388, 0.7361260466673702, 0.4609217464410391, 0.27205854638947535, 0.7371367604460608, 0.6571405452204439, 0.21481656248792202, 0.6842031088906828, 0.6245914867918848, 0.16845298414109766, 0.33780964595326246, 0.16634781517098052, 0.15869371143006195, 0.2736619824602877, 0.1385732928517569, 0.2296888211219985, 0.17034978887934848, 0.16474533425740812, 0.12646717539127406, 0.13614392735163294, 0.13215891829515136, 0.14363444118324065, 0.17896662518437934, 0.13988086332613425, 0.18990507781484423, 0.15857157347780937, 0.15868240316173599, 0.10168478158699779, 0.056079789688006865, 0.001108364764976777, 0.04733269107061655, 0.032981846308814955, 0.03041287504702339, 0.011208114023757099, 0.03226123640498557, 0.011331592153251635, 0.22756215612264974, 0.10335675637690633, 0.16022894559533618, 0.14850135991311963, 0.14113957391244525, 0.07249244267584831, 0.16997140806798394, 0.1146882068296674, 0.10199717624272431, 0.08588385813816946, 0.19234312594157899, 0.10253650120160995, 0.24839313401863217, 0.05902097813769902, 0.1441439319530755, 0.15415345137690417, 0.11775149063185653, 0.09674384178901141, 0.17069304382107386, 0.08318162335811707, 0.14914078423727495, 0.18061366070202745, 0.150910402383707, 0.16372769446566804, 0.11189400127351656, 0.1499471305528235, 0.137173161715761, 0.5249020564861804, 0.5153375945476848, 0.4531213486281356, 0.48477740928500057, 0.46071722156913186, 0.5399091730084192, 0.4548095253428853, 0.48996780207730906, 0.5779001168163072, 0.11689766291726755, 0.12513742422780738, 0.10222223241323458, 0.11506670038189515, 0.10021427255641424, 0.14983660998818382, 0.12143919072066833, 0.11622618637004456, 0.1209348271066969, 0.1623697722089268, 0.1873814796166876, 0.21898470410654336, 0.19083866898748925, 0.16503622998123302, 0.18556137288328223, 0.2539048011307057, 0.17921552896567605, 0.17472516207420452, 0.23256260024280706, 0.3327120625019234, 0.3876963942422883, 0.4114984493327313, 0.31997186129649646, 0.3619586321398611, 0.40514236199731624, 0.40599937352271054, 0.4489382226499471, 0.20390183707922616, 0.22968748346194945, 0.22752587080479902, 0.18649710983031376, 0.2631830524588803, 0.2270740626197023, 0.2592934759802791, 0.29183450779316, 0.32985678825030174, 0.19855587163036703, 0.185054170212947, 0.20559347553283147, 0.21701332883807245, 0.20473318756440295, 0.19665966968403037, 0.1860864711190453, 0.20036706720123898, 0.20755123891955118, 0.1917369462868761, 0.23486520431825886, 0.21552560379549068, 0.5137984848375383, 0.5899593496876383, 0.20457282201367, 0.19786169160548495, 0.22696167200024486, 0.45267690514016756, 0.1694303759749709, 0.18137839488526641, 0.7728604130105748, 0.7215372859484801, 0.6089734634456835, 0.7056146738944722, 0.7458294859500558, 0.1679095787481838, 0.5255694918600025, 0.37323380260449124, 0.20866427352573558, 0.20043603456433934, 0.22875119874181438, 0.20207431508328733, 0.19909317897498335, 0.5579274561546783, 0.5283422288296784, 0.39146791511462076, 0.1830616880838305, 0.1776524908448237, 0.17189286212176336, 0.17863288060747795, 0.1835405018015578, 0.1754309206337049, 0.19792200204570765, 0.17054842613638155, 0.1813914312904762, 0.07931295772569169, 0.09545477000007285, 0.09784109179964684, 0.08261764124675997, 0.08597191750211952, 0.07858661478211137, 0.09262617781769256, 0.08969525021460045, 0.08328728003823838]}, "mutation_prompt": null}
{"id": "6c8102ac-66bf-4dc8-9b15-542dedee7ecd", "solution": "import numpy as np\n\nclass EnhancedQuantumInspiredDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.8\n        self.cr_min = 0.2\n        self.cr_max = 0.85\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02  # Adjusted threshold for stochastic adaptation\n        self.chaos_control = 2.5  # Enhanced chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05  # Modified step size for more aggressive perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1.0  # Adjusted chaotic behavior for dynamic adaptation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EnhancedQuantumInspiredDifferentialEvolution", "description": "Enhanced Quantum-Inspired Differential Evolution with Stochastic Entropy-Based Adaptation and Dynamic Chaotic Perturbation for Improved Robustness.", "configspace": "", "generation": 79, "fitness": 0.3058187950402299, "feedback": "The algorithm EnhancedQuantumInspiredDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7992271884849345, 0.7657711085012265, 0.8082166315268056, 0.8032217428896102, 0.7808062488373329, 0.8177188869816029, 0.7801998798413673, 0.7561415811406084, 0.7663500461241823, 0.6201233017142893, 0.6280380384696114, 0.6528971988459054, 0.5912645644476386, 0.6537795361880314, 0.6695975137874325, 0.6550019827769081, 0.641839591212924, 0.6760690025139009, 0.17271220221986228, 0.5806076948312375, 0.4913494460474228, 0.524511423711921, 0.5862812339085437, 0.594969301449333, 0.17173199922657734, 0.6064835077554647, 0.5989129172850055, 0.11543829739296418, 0.3359018708070901, 0.16310206318423337, 0.13708067086937226, 0.11771829439461778, 0.17108563771938656, 0.16095500220978298, 0.4828405888499756, 0.10667526523003967, 0.8798086358286732, 0.8927372719580335, 0.8649825539723363, 0.8621319523400999, 0.938619628031368, 0.8904667745600278, 0.9666224969955997, 0.9043822539974468, 0.8954338601176599, 0.3082750636800514, 0.27620994607915117, 0.20097599744619543, 0.2902841996020854, 0.2489511866146462, 0.3145368449429319, 0.2822026575223733, 0.36004046975806636, 0.2670009721333231, 0.21946440862999417, 0.7299776913584175, 0.2038792729909572, 0.7038806683732761, 0.573587235074314, 0.5225148894092244, 0.741084635731909, 0.20564095141066352, 0.6299169508134261, 0.25962908890456804, 0.15337492482221893, 0.21101593405056573, 0.24945881766393296, 0.16838368269064818, 0.17236069231871898, 0.2825506782779983, 0.2080808112654815, 0.1442422327534003, 0.18003527703523958, 0.1210575145960876, 0.19335706029542588, 0.1595329449579176, 0.13938605282440897, 0.1460329455326711, 0.1489167220981028, 0.20286424750785148, 0.17682692818243761, 9.999999999998899e-05, 0.04288745299700314, 0.056986410554973554, 0.04245853023233159, 0.04914605329361588, 9.999999999998899e-05, 0.02902415810330017, 0.06902136973903072, 0.0407156094376282, 0.07075940780861911, 0.10862989615801288, 0.17454361487456738, 0.06330736624630684, 0.07370479675286512, 0.05008372705146469, 0.16280994757212142, 0.16551327715344955, 0.11355989226709484, 0.08929911534494439, 0.07607070662789972, 0.06973780814398911, 0.11236679771652924, 0.08706508416378256, 0.08019266697262062, 0.2282770523335107, 0.06720263540654015, 0.09397739225259705, 0.10112726957903884, 0.05358163079744227, 0.1972355337457169, 0.10251169406228366, 0.14252866343514647, 0.20356573437002978, 0.1309576782752203, 0.1092933305196675, 0.10298448378725866, 0.5121504851341745, 0.416165916118431, 0.48732085904340716, 0.4890151358042002, 0.4646310340076437, 0.5079741837035613, 0.5340343756886416, 0.5462222679221845, 0.5749307311128604, 0.09768672666724254, 0.10260251293242673, 0.19574045125315986, 0.11714942891273128, 0.10795453627520002, 0.12571376258702804, 0.131591263313814, 0.10529156812375129, 0.14470244989754155, 0.15921285323383805, 0.16939586632679837, 0.18378741034135915, 0.18188616146992442, 0.1614658305557758, 0.17552258932821674, 0.24882644310702573, 0.1283704071577917, 0.20050161882011786, 0.27129085505345474, 0.29519876330067907, 0.27952639265609935, 0.4383201920211399, 0.33677658004207134, 0.34158466011871047, 0.3402721311872875, 0.3985537245166444, 0.39446977728667987, 0.25112789374204647, 0.31731470349355206, 0.25162233952247004, 0.23040614548171734, 0.20493061735904883, 0.2054600175017457, 0.20301869801015682, 0.2741723195284508, 0.25990965357408113, 0.21783843486252008, 0.20954698840784836, 0.1947598772430983, 0.21020273849908577, 0.20540272083245958, 0.192038978847469, 0.19804895567144565, 0.20371773874815613, 0.19439966110182505, 0.5292384567439158, 0.22001136032471968, 0.27164636918711005, 0.5719211227511709, 0.20929233162472316, 0.21091420922024595, 0.2272785557489977, 0.22304173388082615, 0.23108918939035716, 0.358760689413818, 0.1850097214649853, 0.17306364413250963, 0.6804493883834393, 0.18710133476872703, 0.6940704679560166, 0.32343698313688185, 0.1667059774134404, 0.7330962744884002, 0.4980506361262026, 0.20264165723406768, 0.1986600642212134, 0.2018958889593403, 0.40426454869990325, 0.19843196104447003, 0.16069258509462503, 0.14849622014124875, 0.2524907673195097, 0.1736139719992409, 0.19144785549385035, 0.1827746160326461, 0.18069714969607176, 0.17485202677741762, 0.17296212512588938, 0.18346955751060467, 0.1899976088194011, 0.17985020808936392, 0.08137132236126798, 0.07467791584894845, 0.08780999652467414, 0.08950142124842919, 0.07751653965652094, 0.08238175960799121, 0.0864791978008339, 0.0767820486896138, 0.0824995667835785]}, "mutation_prompt": null}
{"id": "a3dae054-fd2d-4785-b096-b9ba083be5aa", "solution": "import numpy as np\n\nclass QuantumInspiredDifferentialEvolutionWithAdaptiveLearning:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.3\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02  # Adjusted threshold for enhanced exploration\n        self.chaos_control = 2.5  # More aggressive chaos factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05  # Increased step size for more significant perturbation\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.5) % 1.0  # Modified chaotic behavior for better diversity\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def update_population_diversity(self):\n        diversity = np.var(self.population, axis=0)\n        if np.mean(diversity) < self.entropy_threshold:\n            perturbation = np.random.uniform(-0.1, 0.1, self.population.shape)\n            self.population = np.clip(self.population + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n                    self.update_population_diversity()\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredDifferentialEvolutionWithAdaptiveLearning", "description": "Quantum-Inspired Differential Evolution with Adaptive Learning and Enhanced Entropy-Control for Superior Robust Optimization.", "configspace": "", "generation": 80, "fitness": 0.2623330800350032, "feedback": "The algorithm QuantumInspiredDifferentialEvolutionWithAdaptiveLearning got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.5320582423223001, 0.5242161894806947, 0.5060328486966288, 0.5390566503946137, 0.5057016559536881, 0.5098405985749064, 0.5265308600091223, 0.513000668281417, 0.5122154583886738, 0.3164187345609838, 0.32318464989864526, 0.3279330364170825, 0.31085039110997326, 0.3165283102062374, 0.33843956506498085, 0.3073560146510277, 0.32246428736157484, 0.36237371847461286, 0.16507815317657992, 0.2507354361170756, 0.1660643412377365, 0.16466288575499477, 0.22376636479674472, 0.23004989280177068, 0.24893452362626822, 0.1458975886586984, 0.24785946269384762, 0.14672636110249715, 0.15970750720327465, 0.15681278107013152, 0.1569189785983166, 0.1474905277063051, 0.16109508424668384, 0.228214823915866, 0.21526574919093688, 0.11452902890382488, 0.895563356622129, 0.8975991702357348, 0.9082339593932004, 0.9133422539441413, 0.9234732292616846, 0.851074377829299, 0.9275089560402204, 0.8778887627367935, 0.8941121987000247, 0.28466253214476456, 0.14050057568084062, 0.1985775655692057, 0.2814629779505543, 0.2722892278913207, 0.2979535355611552, 0.30853948520701624, 0.20847981056708864, 0.3435531808912562, 0.6511354726705351, 0.21987172617367756, 0.5064696781179487, 0.7092490985001996, 0.20419087260716884, 0.20148848833955835, 0.21886822488000401, 0.7012313043230776, 0.7177407382975007, 0.3823999688655999, 0.2288812203818209, 0.16721194680797158, 0.12241485609996983, 0.16552402675581102, 0.18965293131450278, 0.1554053671115424, 0.2030281209481012, 0.23105867790857648, 0.1826596911073063, 0.18402386438269025, 0.14253832599282013, 0.15875876677224898, 0.1852641455062044, 0.1539186405957509, 0.23056472176132659, 0.1672862484966079, 0.19486294792125614, 0.09590955416524827, 9.999999999998899e-05, 0.011239944892369347, 0.08673361627205523, 0.039674151199390106, 0.012460284973938696, 0.026211462757447457, 0.042119852041502925, 0.11149249050805687, 0.11594154475136675, 0.14200284382075157, 0.1696717938091693, 0.15468340969891592, 0.02920383897300194, 0.10341610230736309, 0.12884478701892077, 0.13701808883202737, 0.05748639934536748, 0.05669355158476297, 0.08909327094369168, 0.03289293579658148, 0.0505893980731551, 0.06402459885792489, 0.04869362696375956, 0.05837251731081683, 0.05468619826798071, 0.0872499820865078, 0.1801611241250184, 0.18443540672310832, 0.17964326202034298, 0.17818004077146543, 0.10550052504432783, 0.14935096095608857, 0.14303522032281102, 0.1275638697487519, 0.16961530236028155, 0.4783794914289793, 0.4949353377416512, 0.5077018378539748, 0.4922548510500213, 0.5011289990119443, 0.47701336084570434, 0.5181174176708794, 0.47591203197331833, 0.49310803276275594, 0.08900975873709738, 0.0985990305808998, 0.10792592334239048, 0.09750999352230938, 0.12191554560256479, 0.1218815386540637, 0.10387676351963071, 0.11571168842658153, 0.1115541308072805, 0.1822607990460151, 0.20190869957298463, 0.17430555524404534, 0.13351293267726816, 0.2620387977699291, 0.19243932821895837, 0.1845788815345648, 0.152942705543905, 0.15719143078135112, 0.3255041514125292, 0.303419823379004, 0.3117631613990539, 0.3310735292080611, 0.3228468633210003, 0.3370833755169209, 0.3221227512486661, 0.3284923909599239, 0.29921896623405275, 0.24264076159941916, 0.27210932665272225, 0.2288165383855869, 0.2647283822964642, 0.2310842603276435, 0.2305757104438192, 0.21824844910515673, 0.2714866030698915, 0.2637209674049972, 0.21347271298814996, 0.20374502464969968, 0.1894697809833401, 0.1895940339192027, 0.21622585662718674, 0.1978719242892274, 0.18936312202347427, 0.17201765102820232, 0.22216429502938329, 0.2262736873207395, 0.20944462156552723, 0.2135638166404369, 0.22795980732171162, 0.30087259720676407, 0.23479832217085972, 0.28863723787443574, 0.23725921346055712, 0.2167931306296127, 0.16443720092305847, 0.16947293064028413, 0.16637459420280487, 0.5677585220742033, 0.6313374793234343, 0.668540997377929, 0.13921341543810595, 0.5101163009721796, 0.7880069225511912, 0.43563218678893134, 0.20917122371170205, 0.19557685608726783, 0.19465241699476787, 0.16257453587485216, 0.26764316714806724, 0.27853257022321654, 0.19488973909158358, 0.16158186438935596, 0.17602985505604807, 0.19374009852455154, 0.16717778886771562, 0.17161825732307845, 0.1817113653413709, 0.18711732767426825, 0.16852371319082393, 0.1696357310343699, 0.16843462893775996, 0.07398309852060136, 0.08976386086300991, 0.07998629165536708, 0.08431996264300357, 0.08140491101854208, 0.07198560002818433, 0.08120846768627821, 0.08413984801805696, 0.07695528891104297]}, "mutation_prompt": null}
{"id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.8\n        self.cr_min = 0.4\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.8\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Entropy-Based Population Control for Superior Black Box Optimization.", "configspace": "", "generation": 81, "fitness": 0.3117818149495886, "feedback": "The algorithm QuantumDrivenAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "986ca61e-d9c3-4be1-ab6b-831d4a1a0441", "metadata": {"aucs": [0.7875570887957954, 0.8012369783702157, 0.790229314707716, 0.7759888544727105, 0.7983763223558435, 0.786606269775392, 0.7971737039945818, 0.7973006304607254, 0.7773713089017079, 0.6238077507755002, 0.6189638395101797, 0.6519258651023577, 0.5918748303661052, 0.6740265357201265, 0.6462934198202925, 0.6054178862530957, 0.6267824103693449, 0.6742032984384149, 0.578246238908315, 0.5919051477964409, 0.14358442872360266, 0.17000830683740698, 0.14574384339761914, 0.5114875546675158, 0.17327001713889767, 0.5774741839196031, 0.40078012228802307, 0.14681259335109043, 0.3563806660780806, 0.5374244981550524, 0.3043496342744131, 0.10660014549337271, 0.16458826704797302, 0.1711773884911003, 0.12969057969149766, 0.42664870911754316, 0.9046066867595931, 0.873323940512408, 0.928883032130513, 0.9101174869387189, 0.8983840967670834, 0.920113054620013, 0.9211677375484819, 0.9215252721108967, 0.9371786747003521, 0.263373379090044, 0.2519517937870409, 0.28587729682872487, 0.21820963245657143, 0.25145655477071127, 0.4391199487929286, 0.34367094919120267, 0.3503457851853068, 0.22061390893298982, 0.6807929509488166, 0.18785067966599978, 0.3168624745077755, 0.2621170530733681, 0.6922345401187078, 0.6119349343732355, 0.6208830144096191, 0.7485072740535852, 0.22048145263579, 0.132740195409915, 0.14214976737983798, 0.1609740952613955, 0.16563974418094018, 0.16082873979896617, 0.11590992778826259, 0.29409274595933044, 0.122827403339696, 0.2550914092232459, 0.13742259519670275, 0.1416496079412709, 0.12011331839207051, 0.1521644653179437, 0.13433190974240583, 0.144089947069586, 0.15662395062511603, 0.14834177149628636, 0.14778893947317884, 0.005537750312516465, 0.028525114936939433, 9.999999999998899e-05, 0.016465851730348313, 0.04536367590690882, 0.05062104160270997, 9.999999999998899e-05, 0.02346088440243621, 0.05624800873838354, 0.07463630431052914, 0.21700236417538, 0.10653859963216239, 0.051846779101924256, 0.10575462186813878, 0.1225143582898145, 0.14049482655226198, 0.09656464560913058, 0.070413251572924, 0.06781885631052997, 0.06461412206044292, 0.07387236038971601, 0.0684500745322193, 0.05559405470900547, 0.1501560167571946, 0.09016818909848012, 0.09270222322477217, 0.08515653805577872, 0.19098430921669263, 0.13368713198068072, 0.13771360798759447, 0.19598476814990096, 0.22608182173851654, 0.1934219439469662, 0.08092341986380303, 0.09574026606065622, 0.11566406678114394, 0.4746209324713785, 0.5125836536185344, 0.5821262107959416, 0.4440006477710099, 0.5145815458439121, 0.5372714355267592, 0.49567839678456405, 0.485847061040912, 0.4963827523715847, 0.12399050478230889, 0.14957260262955274, 0.09302494714036069, 0.12077693256652278, 0.12275473415297455, 0.12097998908000229, 0.1123689149654078, 0.11469148334533896, 0.09720832618246256, 0.16994188600378024, 0.1741762228105863, 0.17543960883485255, 0.206317321830515, 0.17557899350523798, 0.27025798070458906, 0.21535387363294034, 0.17733573296335747, 0.12513902288292733, 0.42549971908098694, 0.38437241736452965, 0.3660657992489921, 0.3827889166649552, 0.3827883083937399, 0.31750414425973505, 0.3701297429348642, 0.40926982319482463, 0.40632249800239084, 0.2839871442395635, 0.26610776217181753, 0.26833124537577313, 0.3067597006974858, 0.20645276879625796, 0.31794122381811485, 0.2696646633760226, 0.30117875555666507, 0.21322483424456595, 0.21007431061530335, 0.1885400332192706, 0.19712554320770315, 0.2393766836229576, 0.2033789603532129, 0.19827285535948025, 0.18162842747845676, 0.1885634068731462, 0.22211102476005784, 0.5556062874678702, 0.5942144248856054, 0.33363868407152075, 0.48209415242470555, 0.2287008714810621, 0.5869102283821646, 0.21968381442141738, 0.3990965704765309, 0.5092141612263197, 0.17970262050875085, 0.48829664241454174, 0.182813782454319, 0.19245822148515135, 0.6140182301710304, 0.8074085046874806, 0.14119388075529682, 0.17359534240606134, 0.6670811533106582, 0.6487956226485414, 0.32004868367195805, 0.3631932282897594, 0.19652519771090637, 0.20195748778766798, 0.19850931324153465, 0.1479954999280273, 0.4782713430801522, 0.25235796440585123, 0.170301495503849, 0.1783611013880394, 0.17219393011840622, 0.18012871379618423, 0.17164981985195737, 0.1835762814299935, 0.19258732900267062, 0.19777852953488584, 0.18332472377506415, 0.07827584601829862, 0.09252202927940378, 0.0838115639853797, 0.0751927510091267, 0.08275591260439974, 0.10256960911355728, 0.08408332258894191, 0.07422167071623675, 0.07609843676979311]}, "mutation_prompt": null}
{"id": "3a2ea1cc-219f-4c27-82fc-30e55f03f674", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.4\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.9\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold * (1 + 0.5 * eval_count / self.budget):\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Time-Varying Entropy-Based Population Control for Superior Black Box Optimization.", "configspace": "", "generation": 82, "fitness": 0.30204222104837414, "feedback": "The algorithm QuantumDrivenAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7918860163771576, 0.7872761639065972, 0.8079461416765641, 0.7758263596134661, 0.7794314708662511, 0.7768907738660976, 0.7721527215523242, 0.7757481121123909, 0.788154291067289, 0.6500844646901318, 0.6232367287542728, 0.6284126446812661, 0.6466407330092017, 0.6181555009599307, 0.6298999509250871, 0.6427579479693668, 0.6519973207820602, 0.6872698994701576, 0.16599404631844905, 0.5121390537720383, 0.5134080571032056, 0.5814456553117849, 0.5654807833583149, 0.46728369673374814, 0.16566921761232156, 0.43422673996058014, 0.1690622692401399, 0.14497643906453217, 0.3954411756209609, 0.13258882982507003, 0.1491241348382698, 0.11586024874076228, 0.16956803385265162, 0.14673743330526723, 0.14590961360384413, 0.12776554308696064, 0.9333904500500971, 0.9338415736014276, 0.9206536263505756, 0.8561392090757947, 0.8695322087753088, 0.9205138336296648, 0.891529693502115, 0.9314737824629763, 0.9440302253093807, 0.37763695095946814, 0.35959092796502423, 0.27183614204629714, 0.3129108299529908, 0.27778303503442203, 0.3153196915080053, 0.18409577685268064, 0.2938027057370789, 0.2389619206121414, 0.3453525876925414, 0.20898612906253788, 0.21212311144065266, 0.35628192106329626, 0.20479520383145877, 0.3178341992981628, 0.579522040200994, 0.7499059164573575, 0.29597527024113934, 0.16954391232296262, 0.20108746776418351, 0.16346268229499694, 0.21340767899557223, 0.11962388342873476, 0.13837482343158558, 0.1974558712573723, 0.20411866843158433, 0.14836859123234625, 0.12632043977983543, 0.1554493919848393, 0.19990158379129996, 0.13841027486942714, 0.13981028144276464, 0.19575874655935033, 0.1230873794316878, 0.1508200322673291, 0.2009577140597245, 0.09498351197946597, 9.999999999998899e-05, 9.999999999998899e-05, 0.01709197133607543, 0.00017924991857631856, 0.03191281258345424, 0.03384141088711079, 0.09275546759789521, 0.07541408267326566, 0.11645818779809802, 0.08211042355734188, 0.11997539523164191, 0.17890799926327905, 0.07015201803514537, 0.11427362070409486, 0.1337441326739408, 0.24028588905371084, 0.11275130181137849, 0.03986691973156353, 0.07354755524955725, 0.09863312712486838, 0.10328305842008789, 0.05916753328085689, 0.09165085817917729, 0.08286034645513807, 0.11247914809018822, 0.12478668249665292, 0.19506088706392188, 0.14364638947176522, 0.13863468135026236, 0.15260822049160794, 0.18933423887199896, 0.2141899669602778, 0.16920104480001952, 0.15097075443813157, 0.17285176525938517, 0.550619249969724, 0.56170531870548, 0.4686277173312732, 0.5328062828504183, 0.476850734280428, 0.5085763072778411, 0.5512084612090978, 0.4994532167954069, 0.5062512501228269, 0.13578968695282256, 0.1112545067684616, 0.10663592240459951, 0.13500549671488515, 0.11705780358029172, 0.10237474373097744, 0.11401902371212658, 0.12807963325578708, 0.1233637070133291, 0.1658386253708346, 0.14671945795702834, 0.16175371859291077, 0.17613003385439008, 0.154290548675993, 0.15355745386487818, 0.1668433099107971, 0.1647228383693613, 0.22089756985684794, 0.2754076721978881, 0.31699097095459394, 0.46243231902898674, 0.2821032972115638, 0.260034656373087, 0.35377925958514, 0.41994657257531665, 0.436377120855738, 0.5082765632818558, 0.21876926077603376, 0.2364610106393571, 0.24489728670331312, 0.29849054117296314, 0.28576652364067023, 0.25966692010048587, 0.2880028464126242, 0.2491522068182821, 0.2682814127243388, 0.19494814432427887, 0.21036752946570714, 0.20448288060479525, 0.18400121257391888, 0.19369074671565467, 0.1924515920447788, 0.1896200306698954, 0.1904184053898389, 0.18689257361982858, 0.6214796725899723, 0.23368030865230938, 0.2096252317366213, 0.20482959663667255, 0.20647692266213158, 0.23840199894844427, 0.2342271640780137, 0.5363594078543327, 0.22480479723421387, 0.19153261595715043, 0.7449831360385708, 0.19190767390030605, 0.664550613634281, 0.5921747104684574, 0.16799150186641587, 0.14047285715914914, 0.16797946974458533, 0.7862721160826003, 0.6689418076632364, 0.2108082214562238, 0.29921363600661643, 0.16721896148991622, 0.20633738112598843, 0.20084846516493082, 0.451951306145679, 0.3608263520780741, 0.39407101844450376, 0.1802571103737025, 0.181272120295638, 0.1719383690346964, 0.17552513676935688, 0.17916852357458102, 0.1862115029085034, 0.1709745694092919, 0.1651166321381976, 0.1828890486268253, 0.06778954099927437, 0.07423657899313751, 0.10103378186171608, 0.09242999884056857, 0.0807425021003303, 0.14922863902494465, 0.09565777351513771, 0.07541856363158461, 0.08708298141454385]}, "mutation_prompt": null}
{"id": "58a84bfc-c998-4752-81cd-fdf46b0f2b7c", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.01\n        self.chaos_control = 2.0\n        self.exploration_probability = 0.2\n        self.memory_reset_interval = self.budget // 5\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.1\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * np.sin(np.pi * x)) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def memory_reset(self):\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            if eval_count % self.memory_reset_interval == 0:\n                self.memory_reset()\n\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Periodic Memory Resetting for Robust Black Box Optimization.", "configspace": "", "generation": 83, "fitness": 0.30496433987742966, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7717202192318431, 0.7625337364339475, 0.7801987116760358, 0.7524017691837678, 0.7892032908750853, 0.749685368584021, 0.8001016706819872, 0.7743253573515159, 0.7737693918324722, 0.641292987801733, 0.608092625030733, 0.6064557579329537, 0.6344719622651851, 0.6229082280620368, 0.6447355345959755, 0.6272594856603182, 0.5935502976891498, 0.5993743715955858, 0.4962938374012398, 0.4650467197862872, 0.4869060272695921, 0.15804509251462928, 0.5209749818210219, 0.16206591072642385, 0.3912201793607294, 0.46471708402941736, 0.16076370777635896, 0.1545249186608868, 0.4165995059365193, 0.15137702593393876, 0.1572767830158015, 0.1297090234223568, 0.15748746059318697, 0.1553691863540122, 0.13870992493486844, 0.13591875716208957, 0.9203678772783556, 0.8917817241318373, 0.9146541817114552, 0.8476052332311022, 0.9026720493608424, 0.9390624437979734, 0.9614219354156857, 0.9284036280632052, 0.9409982583248848, 0.3544049562939945, 0.3092422403343852, 0.32972875560002934, 0.33306752857468946, 0.2320008865340989, 0.32764880872820545, 0.31220172481608155, 0.2402946135788383, 0.20435895162132467, 0.5203482005110576, 0.606790503403909, 0.18263960591780815, 0.6506065610297369, 0.48342376328048653, 0.3391014565763738, 0.7155254606316763, 0.22454198094590117, 0.2770040843223929, 0.1485240389640714, 0.18610856337605797, 0.11923615104159513, 0.1751978888621365, 0.15751131171642807, 0.1633777302086361, 0.34775269667663977, 0.1541509147071285, 0.16758272083154535, 0.1692367265306539, 0.12921612016357087, 0.18381220222772066, 0.16344367057177356, 0.17331903377682922, 0.1458880655163055, 0.11944666588875674, 0.14590362551982616, 0.15404673313405215, 0.052480683501823666, 0.02499612259283457, 9.999999999998899e-05, 0.035760407690273, 0.015267681603329364, 0.006532910005836445, 0.08614297342131738, 0.06414903412968775, 0.06932276518593372, 0.22915666056961814, 0.11544085538341164, 0.17582761599539387, 0.09606812109927465, 0.07867063855257161, 0.07079610002023529, 0.12033773129381475, 0.11073494899483571, 0.09855363141167528, 0.07280708003311864, 0.10799078530443584, 0.10741706223698799, 0.06413052214793347, 0.060316291255969934, 0.18574335685534493, 0.061329113455756534, 0.1048652856372182, 0.11573232735027472, 0.10414544990059005, 0.1278176942642445, 0.14742593900822465, 0.1456199075262874, 0.1757296055648283, 0.18157129964173002, 0.13611411020092168, 0.12062691392664204, 0.12391071259812303, 0.5449300209791684, 0.5783200957884882, 0.49610123856913657, 0.5050085267923909, 0.54684875162496, 0.4989065791651297, 0.4954908579398962, 0.5387594749061301, 0.5285397243481185, 0.1197927424422871, 0.12326570232287581, 0.13682855506308222, 0.10862295177155357, 0.11823988703041466, 0.11055034190761837, 0.09041464947817113, 0.10402139770199215, 0.10854183972397191, 0.1529595986780079, 0.17653691748046607, 0.18939959908164683, 0.15751250948951334, 0.18519640671558513, 0.18311517284216738, 0.20481636612057974, 0.15076148019469693, 0.22813568677142548, 0.40620862881825126, 0.33739259593925564, 0.4203930056817179, 0.3854509489138842, 0.32857435203881213, 0.31783920349169836, 0.4215241174018566, 0.4171042900116525, 0.3446929143251761, 0.22070736923682466, 0.21276434461474703, 0.26073425231275305, 0.28763604264831844, 0.310599373954614, 0.2342614282869715, 0.27627303954708626, 0.27451214857611217, 0.2046721352618387, 0.21259456199127358, 0.19549129732387516, 0.2424545644223629, 0.19629605108928916, 0.1893719715448896, 0.17668844517114835, 0.17842136730280256, 0.19301308562334885, 0.21178443175308326, 0.5638863283390272, 0.5478830290201948, 0.21006182659008021, 0.5122238062630784, 0.379941965850491, 0.22896795133393988, 0.20457486878616482, 0.42747892588185166, 0.5422498174702127, 0.7651218602320592, 0.18011328689801265, 0.7815026971768089, 0.1910736076836801, 0.7388487389649679, 0.7623566014327834, 0.1724478182036655, 0.1549952930326839, 0.13711236619792033, 0.15849218365140638, 0.39905329091230834, 0.36570797777235675, 0.19612574375729297, 0.16325566188275642, 0.20218255981061306, 0.19685973841291848, 0.2642548690598048, 0.3585427990176264, 0.1769491565474185, 0.16218058149259318, 0.1706698153807129, 0.18948643915321495, 0.17621597641979148, 0.17484272891460184, 0.18684507779482862, 0.16688313549325307, 0.17979497042874426, 0.07434911903600117, 0.0770840545705681, 0.08561849857508408, 0.07707007857233095, 0.09425947275445234, 0.07906086367337484, 0.07747102634854819, 0.07853079355008175, 0.07822546369710703]}, "mutation_prompt": null}
{"id": "4d22463f-6b4e-43dd-a982-42a190a9359f", "solution": "import numpy as np\nfrom concurrent.futures import ThreadPoolExecutor\n\nclass ParallelQuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.4\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.8\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def evaluate_individual(self, i, fitness, func, eval_count):\n        f, cr = self.adaptive_parameters()\n        target = self.population[i]\n        mutant = self.mutate(i, f)\n        trial = self.crossover(target, mutant, cr)\n\n        if self.calculate_entropy() < self.entropy_threshold:\n            trial = self.gradient_based_perturbation(trial, func)\n\n        trial_fitness = func(trial)\n        eval_count += 1\n        if trial_fitness < self.best_fitness:\n            self.best_solution = trial\n            self.best_fitness = trial_fitness\n\n        if trial_fitness < func(target):\n            self.population[i] = trial\n            fitness[i] = trial_fitness\n\n        return eval_count\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            with ThreadPoolExecutor(max_workers=4) as executor:\n                futures = [executor.submit(self.evaluate_individual, i, fitness, func, eval_count) for i in range(self.population_size)]\n                \n                for future in futures:\n                    eval_count += future.result()\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "ParallelQuantumDrivenAdaptiveDE", "description": "Parallel Quantum-Driven Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Dynamic Elite Promotion for Efficient Global Optimization.", "configspace": "", "generation": 84, "fitness": 0.06166642925890905, "feedback": "The algorithm ParallelQuantumDrivenAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.06 with standard deviation 0.06.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.16527723393889138, 0.1265355407751747, 0.12477431570820297, 0.1467092453956469, 0.17071422936121905, 0.13685551550005948, 0.14049986164697326, 0.1971487601379811, 0.08962168439185247, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.033081499297435535, 0.024900649244463224, 0.021142366544386615, 0.032057249805950594, 0.023750863606507133, 0.04617008431164282, 0.03412897244993873, 0.023200872176698972, 0.02861063059301927, 0.00720795660433593, 0.025583900570235185, 0.026361583969873426, 0.01948606084277249, 0.000394175836776256, 0.01822309561370783, 0.0, 0.01081915731336991, 0.0039498706183583865, 0.09048528221751617, 0.07447285328319975, 0.112831679443678, 0.0822114817248939, 0.055155094855970255, 0.10044957267834176, 0.08509784484056804, 0.11403112500903678, 0.11550269068371621, 0.062470085573301914, 0.062025817383444704, 0.0, 0.041634118566952205, 0.00022516113068327126, 0.045009373318697365, 0.0, 0.03320362870613103, 0.022876961600257317, 0.104634036918416, 0.04090612374837854, 0.05963546282012888, 0.09538810045589174, 0.06711306322012445, 0.043560754052563655, 0.06225470436775726, 0.11824979613772957, 0.04078757527481791, 0.0, 0.0, 0.008822901887815315, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.15830260329540013, 0.17388212845494122, 0.1482781002062129, 0.12184344445610151, 0.1157213799535679, 0.14845584178614568, 0.16093893451328423, 0.16511144786652798, 0.14375484256173243, 0.025965602378623553, 0.03655566593838355, 0.021861643147580434, 0.032488677008887135, 0.024952059867529686, 0.03647563820175037, 0.035475492781358975, 0.01953368211184392, 0.026668589376636964, 0.10066346863794184, 0.08594064619296804, 0.11809069290348673, 0.09844654998246005, 0.10837946529105269, 0.09400339197732921, 0.08793466624573643, 0.08768425096673804, 0.11333415578616057, 0.14284666792364065, 0.11758577847051332, 0.14338037877219467, 0.19748440506292497, 0.12552919118691697, 0.1718763483899156, 0.12877465532090826, 0.17357884474486385, 0.1419418594090588, 0.0801959091195813, 0.08979113956410223, 0.07918156065716919, 0.071390153711552, 0.06397779769986833, 0.08289579753652465, 0.0835689717382857, 0.09956278816150788, 0.07830900693725984, 0.11926200957550226, 0.14897332421515874, 0.13331190092223766, 0.10502345152717552, 0.18773769465902956, 0.11834267810857457, 0.13134724555705724, 0.11074874751675146, 0.1261176175567823, 0.02370720722355768, 0.15181011790873256, 0.1488780591719293, 0.16719629192759344, 0.14429769297348138, 0.0, 0.0, 0.0, 0.17859586753938073, 0.1166045963968172, 0.07454747614146928, 0.09187680843041657, 0.1270426405000007, 0.12067181084725875, 0.09846371168097834, 0.11155478722520329, 0.09628778822206618, 0.08590478017080239, 0.11021732916660254, 0.10246044116126674, 0.07555061081057379, 0.10783738666411757, 0.12679107012517, 0.06494791895332541, 0.056769442350758426, 0.07449573870145654, 0.09281392047041315, 0.13470241546160056, 0.1366860017538567, 0.1475120547524018, 0.1351428429236119, 0.13088647802971154, 0.14992696794329818, 0.16613305653440236, 0.15237349262224276, 0.16797406499122447, 0.017505579633524615, 0.023117903461956857, 0.03714119342025257, 0.029380083326860817, 0.041054622987698575, 0.02123346491072775, 0.021826268111997726, 0.03369389197678774, 0.06461519022790185]}, "mutation_prompt": null}
{"id": "e3f65f6e-4242-48c4-9037-339b69bbb537", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.8\n        self.cr_min = 0.4\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.8\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Entropy-Based Population Control for Superior Black Box Optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7875570887957954, 0.8012369783702157, 0.790229314707716, 0.7759888544727105, 0.7983763223558435, 0.786606269775392, 0.7971737039945818, 0.7973006304607254, 0.7773713089017079, 0.6238077507755002, 0.6189638395101797, 0.6519258651023577, 0.5918748303661052, 0.6740265357201265, 0.6462934198202925, 0.6054178862530957, 0.6267824103693449, 0.6742032984384149, 0.578246238908315, 0.5919051477964409, 0.14358442872360266, 0.17000830683740698, 0.14574384339761914, 0.5114875546675158, 0.17327001713889767, 0.5774741839196031, 0.40078012228802307, 0.14681259335109043, 0.3563806660780806, 0.5374244981550524, 0.3043496342744131, 0.10660014549337271, 0.16458826704797302, 0.1711773884911003, 0.12969057969149766, 0.42664870911754316, 0.9046066867595931, 0.873323940512408, 0.928883032130513, 0.9101174869387189, 0.8983840967670834, 0.920113054620013, 0.9211677375484819, 0.9215252721108967, 0.9371786747003521, 0.263373379090044, 0.2519517937870409, 0.28587729682872487, 0.21820963245657143, 0.25145655477071127, 0.4391199487929286, 0.34367094919120267, 0.3503457851853068, 0.22061390893298982, 0.6807929509488166, 0.18785067966599978, 0.3168624745077755, 0.2621170530733681, 0.6922345401187078, 0.6119349343732355, 0.6208830144096191, 0.7485072740535852, 0.22048145263579, 0.132740195409915, 0.14214976737983798, 0.1609740952613955, 0.16563974418094018, 0.16082873979896617, 0.11590992778826259, 0.29409274595933044, 0.122827403339696, 0.2550914092232459, 0.13742259519670275, 0.1416496079412709, 0.12011331839207051, 0.1521644653179437, 0.13433190974240583, 0.144089947069586, 0.15662395062511603, 0.14834177149628636, 0.14778893947317884, 0.005537750312516465, 0.028525114936939433, 9.999999999998899e-05, 0.016465851730348313, 0.04536367590690882, 0.05062104160270997, 9.999999999998899e-05, 0.02346088440243621, 0.05624800873838354, 0.07463630431052914, 0.21700236417538, 0.10653859963216239, 0.051846779101924256, 0.10575462186813878, 0.1225143582898145, 0.14049482655226198, 0.09656464560913058, 0.070413251572924, 0.06781885631052997, 0.06461412206044292, 0.07387236038971601, 0.0684500745322193, 0.05559405470900547, 0.1501560167571946, 0.09016818909848012, 0.09270222322477217, 0.08515653805577872, 0.19098430921669263, 0.13368713198068072, 0.13771360798759447, 0.19598476814990096, 0.22608182173851654, 0.1934219439469662, 0.08092341986380303, 0.09574026606065622, 0.11566406678114394, 0.4746209324713785, 0.5125836536185344, 0.5821262107959416, 0.4440006477710099, 0.5145815458439121, 0.5372714355267592, 0.49567839678456405, 0.485847061040912, 0.4963827523715847, 0.12399050478230889, 0.14957260262955274, 0.09302494714036069, 0.12077693256652278, 0.12275473415297455, 0.12097998908000229, 0.1123689149654078, 0.11469148334533896, 0.09720832618246256, 0.16994188600378024, 0.1741762228105863, 0.17543960883485255, 0.206317321830515, 0.17557899350523798, 0.27025798070458906, 0.21535387363294034, 0.17733573296335747, 0.12513902288292733, 0.42549971908098694, 0.38437241736452965, 0.3660657992489921, 0.3827889166649552, 0.3827883083937399, 0.31750414425973505, 0.3701297429348642, 0.40926982319482463, 0.40632249800239084, 0.2839871442395635, 0.26610776217181753, 0.26833124537577313, 0.3067597006974858, 0.20645276879625796, 0.31794122381811485, 0.2696646633760226, 0.30117875555666507, 0.21322483424456595, 0.21007431061530335, 0.1885400332192706, 0.19712554320770315, 0.2393766836229576, 0.2033789603532129, 0.19827285535948025, 0.18162842747845676, 0.1885634068731462, 0.22211102476005784, 0.5556062874678702, 0.5942144248856054, 0.33363868407152075, 0.48209415242470555, 0.2287008714810621, 0.5869102283821646, 0.21968381442141738, 0.3990965704765309, 0.5092141612263197, 0.17970262050875085, 0.48829664241454174, 0.182813782454319, 0.19245822148515135, 0.6140182301710304, 0.8074085046874806, 0.14119388075529682, 0.17359534240606134, 0.6670811533106582, 0.6487956226485414, 0.32004868367195805, 0.3631932282897594, 0.19652519771090637, 0.20195748778766798, 0.19850931324153465, 0.1479954999280273, 0.4782713430801522, 0.25235796440585123, 0.170301495503849, 0.1783611013880394, 0.17219393011840622, 0.18012871379618423, 0.17164981985195737, 0.1835762814299935, 0.19258732900267062, 0.19777852953488584, 0.18332472377506415, 0.07827584601829862, 0.09252202927940378, 0.0838115639853797, 0.0751927510091267, 0.08275591260439974, 0.10256960911355728, 0.08408332258894191, 0.07422167071623675, 0.07609843676979311]}, "mutation_prompt": null}
{"id": "bd5f5239-08f8-4fa0-b9ab-081067b0c551", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.01\n        self.chaos_control = 1.6\n        self.exploration_probability = 0.2\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def hybrid_local_search(self, sol, func):\n        grad = np.random.randn(self.dim)\n        step_size = 0.1\n        return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.6) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, int(self.initial_population_size * (1 - eval_count / self.budget)))\n            self.population_size = dynamic_population_size\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.hybrid_local_search(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Entropy-Based Population Control, incorporating Hybrid Local Search for Superior Black Box Optimization.", "configspace": "", "generation": 86, "fitness": 0.2640688796459423, "feedback": "The algorithm QuantumDrivenAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.5028949454951948, 0.5301445852951171, 0.5367213715665627, 0.5330234559288396, 0.5381090358020418, 0.5631053998805935, 0.5410542310506259, 0.5577760115802297, 0.5521490079029558, 0.36349358453385494, 0.4113831895348211, 0.3805971015627715, 0.36117382179476576, 0.31798781738545545, 0.39336443937620524, 0.3798103810954161, 0.3591819214657005, 0.3546690320208129, 0.1581938902778517, 0.1479625869845218, 0.17231320906644632, 0.14338991967988535, 0.16777037024503627, 0.16743728070805242, 0.24558140162559838, 0.27768068583674443, 0.1706016484829419, 0.1427555778723718, 0.14366969957632192, 0.14490745584862574, 0.21748322336906767, 0.15207165256756694, 0.15814233712849146, 0.16087759168054305, 0.15871412030579013, 0.15011780508764438, 0.8977593122630141, 0.9067175335905968, 0.9304393918098781, 0.8894687025737897, 0.9221324372115592, 0.9191581785822114, 0.9359128793876191, 0.8722532109677793, 0.8978855675735417, 0.3163422403128755, 0.2869335672663944, 0.1438671747602912, 0.2681313272678353, 0.21171583452427034, 0.2637685117799936, 0.19641885539585913, 0.30649928584786734, 0.31156785441498647, 0.322944039744381, 0.24329949654153327, 0.31613092345118554, 0.27173492679228906, 0.4948710734558919, 0.6842398163800472, 0.6241259485373687, 0.27758485568436353, 0.6803376078009489, 0.14231449794548878, 0.19541806372213721, 0.15199400732663504, 0.16710226113080895, 0.11156415004785336, 0.1677841119415565, 0.14515671795154372, 0.24250884691783658, 0.1409167767226832, 0.1609463797852737, 0.1346839562410851, 0.15723281340009654, 0.14008900636669008, 0.14305153091207978, 0.15658017622042097, 0.18963756503627827, 0.17131688613664187, 0.15260670941170906, 9.999999999998899e-05, 0.04999099523265249, 0.0015499835336584278, 0.03893123341211702, 0.06555057227090177, 0.02142167863096056, 0.0005843030901265811, 0.05006653854147769, 0.03916385926899113, 0.09884526045904818, 0.09721370668293605, 0.08239761143263657, 0.0766993677049912, 0.12252820558873168, 0.05376238944359191, 0.14972681012150146, 0.23086978503236955, 0.16482756042392044, 0.12662240278355563, 0.03603363575758445, 0.07283343218372595, 0.05898097569328109, 0.04670797020902917, 0.11650790630876495, 0.0705642528509004, 0.10098576801929449, 0.12726762795504742, 0.11970173376461335, 0.17908420330714248, 0.1615351392865093, 0.10203116159794556, 0.1776380338955469, 0.1514752233553387, 0.13031742194775975, 0.16006319024398252, 0.129026542667518, 0.46273033528521634, 0.49806094465566, 0.460876847762161, 0.4622819589836188, 0.47905725951921896, 0.49443498779401773, 0.4752349026141597, 0.45560730184803, 0.42347061731282276, 0.11407671090871752, 0.1555255912032355, 0.11503864240745865, 0.12682866542709548, 0.12208153062380245, 0.1365626621466004, 0.10783426772583649, 0.13431941206683407, 0.1502042128013671, 0.1986688326408932, 0.22001019535868804, 0.2757230172714449, 0.17050000063433113, 0.20623098273166363, 0.17810658008913705, 0.1897987994037046, 0.17387941715072086, 0.1913165208491061, 0.3190866167213763, 0.33202234266750696, 0.32382524678587, 0.33954409605452307, 0.3369855838889202, 0.3253902224165508, 0.3185543829068799, 0.3300871472329441, 0.3552893022307191, 0.2970294924663577, 0.2711807935162731, 0.20297207775923598, 0.2282385487534213, 0.17985515885682002, 0.23917625542111087, 0.26230709762526916, 0.25463124850207974, 0.27033693068619224, 0.20224524506319586, 0.1830718928962487, 0.19085033589354883, 0.1910201268524222, 0.19445777013176735, 0.19583147994843053, 0.17468276460988652, 0.18625394155174757, 0.20913144832187136, 0.31226971743962917, 0.22040630305245756, 0.20346814507709854, 0.4004590833908128, 0.3690042965205147, 0.190144903840068, 0.1893910984167333, 0.23394187941924416, 0.20193205956414417, 0.17569705730346774, 0.18802662832288208, 0.7529723709731879, 0.6049845042128832, 0.1872206171526506, 0.5880744271178303, 0.1407321315010378, 0.53641899968549, 0.7854137252216619, 0.5979997661490482, 0.20446142615613816, 0.2963715051082785, 0.19959957523604144, 0.1874359536922099, 0.4055855942310478, 0.15890196338610296, 0.19240569378074857, 0.14554726517881023, 0.17187797586044506, 0.1780375878218936, 0.18485215659381604, 0.1807023929453071, 0.1807858665636951, 0.1812617086892706, 0.17961827567161692, 0.17168102709536492, 0.17874128497085218, 0.07205401301484304, 0.0838805886596048, 0.07419772597490915, 0.08723416706504417, 0.08132322253396729, 0.10694413594871566, 0.07815414727216796, 0.08021875152050184, 0.07486625376577227]}, "mutation_prompt": null}
{"id": "a9646c8b-acf9-4708-a599-9337d280e10e", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 8)\n        self.entropy_threshold = 0.03\n        self.chaos_control = 1.6\n        self.exploration_probability = 0.2\n        self.archive = []\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_perturbation(self, sol):\n        if np.random.rand() < self.exploration_probability:\n            perturb = np.random.uniform(-0.05, 0.05, self.dim)\n            return np.clip(sol + perturb, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_perturbation(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    self.archive.append(trial)\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumInspiredAdaptiveDE", "description": "Quantum-Inspired Adaptive Differential Evolution with Dynamic Archive and Stochastic Perturbation for Enhanced Black Box Optimization.", "configspace": "", "generation": 87, "fitness": 0.3035249813741232, "feedback": "The algorithm QuantumInspiredAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7951435430156589, 0.758603155471531, 0.783684544248755, 0.7949945322864647, 0.795511821095411, 0.7974226160902524, 0.7790599794347676, 0.7750616864751874, 0.788236541716657, 0.6638845034093284, 0.6698539899798039, 0.6309904515705295, 0.6597808887336107, 0.6613108793215996, 0.6613871602566821, 0.6277601238304418, 0.6366548479606841, 0.6334451769523091, 0.563438439602683, 0.5185066142191552, 0.4816946468407305, 0.17117748347321426, 0.571881485456798, 0.5542114599038717, 0.17225720413131584, 0.16966130026399473, 0.17111509103655176, 0.14697636923901314, 0.3230074820836326, 0.13451657633337455, 0.12278180051595733, 0.5713053534982105, 0.17348865656286794, 0.1406484494582746, 0.13554049725429285, 0.21682873878620945, 0.8837828837622979, 0.9194660844368889, 0.9000027230285383, 0.9010344053521454, 0.824706354994373, 0.9022641214243261, 0.9041467407904269, 0.8414477648182135, 0.8579463895104014, 0.22951254661522102, 0.18796720979575032, 0.21854054516976362, 0.3985589676244612, 0.24334499118537078, 0.36652382748769763, 0.22132833764036008, 0.289901018705086, 0.28041707322001086, 0.3559852051449287, 0.3470470206400811, 0.28371835693557923, 0.2725929167743403, 0.27004157448395394, 0.2648607949474113, 0.6277252311291939, 0.6954530177350244, 0.22486302675439995, 0.16886033623379115, 0.2978120188421184, 0.14033593645988807, 0.2153241802553334, 0.15565904418369936, 0.27192961009517824, 0.15831513758631643, 0.3028253720153735, 0.17324986350000127, 0.11447819504479961, 0.28122413703768734, 0.13013369598748903, 0.14350027318784886, 0.1378946037138118, 0.18042341790338978, 0.15570852372111044, 0.15866225883895457, 0.1481583865502213, 0.041995590232416946, 0.08728965157985835, 0.04659487303851817, 0.07602306790258628, 0.023168412829297824, 0.04324366679093106, 9.999999999998899e-05, 0.03204857473107281, 0.11770677349862257, 0.10335788237204346, 0.14251449147257678, 0.08618319898041116, 0.06553878286284232, 0.08231568357852814, 0.11893739858736152, 0.08193695173983362, 0.18160713613476354, 0.14872347664794505, 0.04981490312773584, 0.0341345715291429, 0.17636656095980507, 0.17976218542465816, 0.2231344305070142, 0.11910757956994078, 0.0640691148258078, 0.09231528101378261, 0.058105279668208665, 0.07648407300797988, 0.16660798216862227, 0.18427838671703667, 0.12213863519555057, 0.15047583740256465, 0.09349900103465136, 0.21865853153435166, 0.09315127444015803, 0.1373107175378182, 0.5183130960875661, 0.49014935015348626, 0.5637896849109185, 0.5543017727107726, 0.48273440881353713, 0.5171096352215825, 0.49900557550235847, 0.48612110281154897, 0.48872459453724026, 0.13338801841675973, 0.12428910578161034, 0.12881651260437632, 0.10543678624532804, 0.10786044753173885, 0.1285567064629991, 0.15879056314042805, 0.12201388201983665, 0.11690517925772415, 0.2090845921486303, 0.19466585492326216, 0.15234320494786224, 0.18928892338526448, 0.32390269488462675, 0.15802528946180605, 0.21045496085553828, 0.19967542547735562, 0.2260678494602102, 0.3126783128087882, 0.2636601916660709, 0.3925324242195566, 0.41328430837158214, 0.39361264823040154, 0.30906782100167196, 0.29569568951261627, 0.4028053408619723, 0.40657961420314537, 0.2801164018010702, 0.26188585099662554, 0.2080178500188946, 0.2553401691877911, 0.24681860999884442, 0.2783375248103913, 0.18416936197234024, 0.31103009708358365, 0.29430657853885456, 0.20612146910257123, 0.21343573692441542, 0.21484836607871283, 0.18722475820984097, 0.19597906561265488, 0.20991561222115218, 0.20514005715729866, 0.21083686315493022, 0.21824482686675983, 0.21772851476784083, 0.21520979724322342, 0.21557994839720473, 0.23962040829529319, 0.22863099382596264, 0.20099329413325617, 0.18832274460097098, 0.2235489082785337, 0.23984326551371615, 0.4879307242088051, 0.2038096561593743, 0.14538685214940195, 0.19612340685878527, 0.7436866281632255, 0.8464407072965765, 0.17191875760955277, 0.15402259779681748, 0.8082621069888443, 0.5252195260660653, 0.20547821471699468, 0.4167921793844688, 0.16401377323768374, 0.4582414384906247, 0.14896059891264635, 0.16268414479266213, 0.6990673059870411, 0.6864818358335747, 0.21973407577568937, 0.18268706324460948, 0.17615120414089647, 0.17783953137069786, 0.18113243212000563, 0.17411573748631004, 0.18680295626997845, 0.17862901484683713, 0.18251590448182264, 0.07545885018140885, 0.07891656977347361, 0.0815757091975644, 0.08945078319187105, 0.0816918562057275, 0.07467029477152087, 0.08507712179569604, 0.07962697208148362, 0.08162263138145232]}, "mutation_prompt": null}
{"id": "d5cb0605-b42e-482e-84b5-fc1ed5ffb7c6", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.9\n        self.exploration_probability = 0.2\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.1\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        additional_explore = self.population[np.random.choice(indices)]\n        return np.clip(mutant + 0.5 * (additional_explore - a), self.lower_bound, self.upper_bound)\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution enhanced with Modified Mutation Strategy and Diversity Boosting for Improved Black Box Optimization.", "configspace": "", "generation": 88, "fitness": 0.2504197018402683, "feedback": "The algorithm QuantumDrivenAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.19.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.8361077674411779, 0.8229426739571046, 0.8559772028768418, 0.856702197105272, 0.7859626121091158, 0.8276224113940662, 0.8348573463969889, 0.8372550747456167, 0.8350364017124335, 0.3589096526563954, 0.26242825300775796, 0.5465520392553243, 0.5758483562098002, 0.25605244687535667, 0.051914616886500564, 0.08799056071313693, 0.7010988421399171, 9.999999999998899e-05, 0.15427237173871655, 0.5143489897845475, 0.11602625354543439, 0.2956608579795472, 0.13492178723592152, 0.14241458887472602, 0.1348669058433234, 0.1705587493362184, 0.37084374042743395, 0.10639528172553747, 0.10408963164318086, 0.09540484723585674, 0.14654191145940498, 0.125570958929745, 0.1093289192443021, 0.14079278523923822, 0.11759626050591865, 0.11884173865497538, 0.3717722692257276, 0.7657081049578377, 0.13567748433033344, 0.7160749841107868, 0.3685315236521973, 0.3752430144045432, 0.5671808333177919, 0.4709005437795116, 0.5372026891756991, 0.17012493869177925, 0.1619625404233357, 0.16223509419362003, 0.28854068197761573, 0.20595978263059123, 0.22063466243802676, 0.2220266747761208, 0.12632978026598563, 0.15272136073250475, 0.21907345025125902, 0.27928138635486066, 0.20214299554937232, 0.2825831124630609, 0.24431378676525917, 0.35834159169971813, 0.16461809708538622, 0.22169698375267266, 0.2307160653901752, 0.27896250955584057, 0.3713950749918785, 0.1417256736257827, 0.17422724510559107, 0.29261767740422295, 0.13609016411985286, 0.1627475829422943, 0.1730804601380851, 0.2602969670613715, 0.1404572917930318, 0.13152959606232684, 0.12669988464381676, 0.12736392199038915, 0.15166355372564466, 0.19663541293584053, 0.16352405948871052, 0.12298294476647187, 0.12241572449322613, 0.006209604445839845, 0.001106474621892839, 9.999999999998899e-05, 0.0020480972319435464, 0.037281327127896446, 0.005060058146707291, 0.05373496106741005, 0.04925248890521039, 0.11697633537486818, 0.1465204967192718, 0.10501019518897925, 0.09708868596473308, 0.06562987853979851, 0.16141407001197072, 0.05961155037713506, 0.148091476072702, 0.20749533650398366, 0.16662420435449599, 0.23176408478021548, 0.14892709939994475, 0.15699394854701676, 0.08555026554592804, 0.12777756858157385, 0.22943829674812766, 0.11051080240691413, 0.10211618783546039, 0.12520647917430783, 0.2029147059288514, 0.16214756091055826, 0.21615769764330106, 0.11456364819687992, 0.20657518391649732, 0.16383120224132164, 0.12010477033471911, 0.294660425377695, 0.15710835976540616, 0.5039583933607044, 0.5129806702083758, 0.45180535572077296, 0.49578259231956556, 0.5978163515434346, 0.5288072269362766, 0.437104707552182, 0.5392530501324585, 0.44537275056534475, 0.1334767080556457, 0.1358589742164169, 0.08414103296540965, 0.12321856522663821, 0.09937424144971863, 0.10538294355444355, 0.12978507022018515, 0.15021490852878328, 0.11035313778347877, 0.15112847778103133, 0.16101217217478792, 0.13396030769049705, 0.13546461267930987, 0.1462803988450494, 0.2103872321454221, 0.2519308273837051, 0.12913134146735084, 0.1437262249219553, 0.2553394927418893, 0.36402458910268964, 0.2672803373129774, 0.4037067160881669, 0.4438478568984848, 0.37477127524897846, 0.3546470979595979, 0.39099574576219964, 0.24327005027264637, 0.21708996881922726, 0.27177193534611077, 0.2254913172840809, 0.25293433435614265, 0.2557178228353717, 0.2971572067221695, 0.2344175369107535, 0.2611164752526568, 0.21198281290350096, 0.20543589254176198, 0.2229639262951406, 0.21963387080209984, 0.20745431017927496, 0.22507996003856112, 0.2131898933123182, 0.20713245870637742, 0.21826624191333088, 0.21027185389208836, 0.2097026975116082, 0.186895163722419, 0.5691900934604075, 0.2044841435097996, 0.20803697079047156, 0.21081163563226946, 0.19112094020349057, 0.20509886889109963, 0.21410968590985202, 0.1834477273785886, 0.1821795804895474, 0.1818823821903367, 0.5955682963631674, 0.24816578199947992, 0.19562600529427732, 0.6312484855895635, 0.3833825708275105, 0.1604341190126174, 0.4742194507083569, 0.20821585533131504, 0.3290937490127459, 0.7407235109429701, 0.26444857833863844, 0.20133090582193602, 0.161955901301151, 0.5221808737934187, 0.2483298435712733, 0.16616914739078315, 0.18278942727406056, 0.17866922837784438, 0.16751528432445617, 0.1725957317520782, 0.18559965328185868, 0.17868503866630292, 0.19026112198006184, 0.19996809048211617, 0.08286913571227728, 0.0814133523452294, 0.0896968017851214, 0.08385444692175481, 0.07271357185308969, 0.0751539713154219, 0.081407382631134, 0.08123863336329373, 0.09202376539867141]}, "mutation_prompt": null}
{"id": "f8fc71d7-eb27-4d92-b3bd-82c7fa3b6350", "solution": "import numpy as np\n\nclass EntropyControlledAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.01\n        self.chaos_control = 1.9\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def quantum_inspired_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            quantum_factor = np.random.normal(0, 1, self.dim)\n            step_size = 0.1\n            return np.clip(sol + step_size * quantum_factor, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.6) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.quantum_inspired_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "EntropyControlledAdaptiveDE", "description": "Entropy-Controlled Adaptive Differential Evolution with Quantum-Inspired Chaotic Perturbations for Enhanced Convergence and Robust Optimization.", "configspace": "", "generation": 89, "fitness": 0.3035729229533806, "feedback": "The algorithm EntropyControlledAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7081316638921193, 0.7652886554261328, 0.7744352336647388, 0.7630575829970951, 0.7990288886784156, 0.7799292608100994, 0.7799225099544261, 0.7731266860326773, 0.7753694822478349, 0.6158078588567382, 0.6099031276590183, 0.6299697936921231, 0.6529664592451725, 0.6307080165065524, 0.6330744499093979, 0.6280206124110288, 0.6446082510297444, 0.6681177801840652, 0.45522059197024356, 0.4762487805438276, 0.5027342633159714, 0.5085983342785015, 0.5136949362172587, 0.14355882797575903, 0.16444550928897228, 0.4240053248222089, 0.5613222223530068, 0.14298511586303453, 0.1409553878064893, 0.13103249579521548, 0.13543046880671483, 0.44787088970617506, 0.16345196673983486, 0.1467598652195018, 0.16987363188000926, 0.15618678654959495, 0.9231451614232256, 0.9303743279921988, 0.9202344682341077, 0.8761896009935815, 0.9096773017676446, 0.9042678381892646, 0.923972775003886, 0.8820626671432701, 0.9237201596727348, 0.320175827591774, 0.22757813367345914, 0.2866396919335942, 0.3593937404536005, 0.33792812086095525, 0.26488553525199554, 0.24649642999046195, 0.24079810038350868, 0.2629929133226817, 0.21559608464740654, 0.21581062865384504, 0.36142283241416895, 0.25229105247920147, 0.7119034520572408, 0.2113677413947317, 0.2934401123549769, 0.6126875970674097, 0.3489467246687443, 0.14534064107120825, 0.11394664442652525, 0.17118379930855443, 0.11597302244579255, 0.17991676539380042, 0.14760363239214713, 0.20862318423841952, 0.2641119540813729, 0.2097734150574191, 0.14298976868522661, 0.13075766042053505, 0.15405074716858302, 0.14601810103322987, 0.17291181803875022, 0.15681934159724753, 0.19248792034290507, 0.22595189777608216, 0.19611492233529138, 9.999999999998899e-05, 0.051273206770974133, 0.09503127375542386, 0.015435011947755983, 0.06708134302790114, 0.03034588511323999, 0.0018226886479253412, 0.07487428200904778, 0.05238587022372798, 0.07862476563899568, 0.11361181040861923, 0.2328621375768687, 0.030657384945842248, 0.07948701330198149, 0.11048110401716205, 0.11314932243991804, 0.10685228452314599, 0.198677087795887, 0.11311265930680969, 0.13157006208202404, 0.135839938855276, 0.05981881694252933, 0.11426235405385865, 0.10951776447947614, 0.059329331925702, 0.10074381893378614, 0.07381407225938308, 0.2094619589803859, 0.14176020191163663, 0.23166171763373322, 0.18545452191097966, 0.1408359249869876, 0.2379404802202345, 0.07447677605623959, 0.1757157866034882, 0.15050455750875902, 0.5620013155211747, 0.47810287349463265, 0.5569555484715916, 0.5266548839142013, 0.4603971900397168, 0.44822228237476747, 0.46683019957849303, 0.508145036992319, 0.4896226642965037, 0.09494040364767808, 0.11423326399193434, 0.12845466554573792, 0.1050746756331078, 0.10213295609643158, 0.12563645708729088, 0.11746773612235795, 0.09908001426834179, 0.1334140178620612, 0.31139904344071034, 0.21238941118988564, 0.18682694078220452, 0.18371092827297797, 0.17973066159257656, 0.23722024733526736, 0.20213680609552076, 0.15439419610490535, 0.2284095813993614, 0.33182284999252165, 0.3194773632801652, 0.3177472865424883, 0.309819222794223, 0.35425994454671383, 0.3623870339942339, 0.4032337133980983, 0.3972839107930346, 0.41901990780979836, 0.20628282104227824, 0.2108895377297817, 0.2805094341014347, 0.30714915568438694, 0.27709210055089806, 0.2586796637149792, 0.26921312902654393, 0.2582435104248961, 0.27738561661665395, 0.18645090035992784, 0.21030061094440045, 0.213134405211014, 0.20848813423476054, 0.22680374645467738, 0.2168080196487, 0.20552917407066973, 0.19490449439554636, 0.1884710119618288, 0.2146536274458556, 0.19396390722094936, 0.538898635059192, 0.5949526122093165, 0.5566312584002762, 0.22631341221426304, 0.5843516088634216, 0.2001217092933174, 0.21604459361405004, 0.20044950088928215, 0.19667431135434066, 0.668098654679768, 0.166832288997945, 0.1938051842577485, 0.4539161774095034, 0.14011673586693973, 0.599482643571406, 0.80648479995119, 0.45424377103063784, 0.20596608173042263, 0.3809712292130758, 0.48037726732738906, 0.15740976629016845, 0.14719906186392018, 0.2074882593019537, 0.560614972245961, 0.10433090515945098, 0.18492698342923708, 0.17696857682165812, 0.16844836859516343, 0.1803370470573893, 0.18781730725362855, 0.1732417018978143, 0.17316647341850966, 0.19290127277624725, 0.17324435198110388, 0.08674366677901146, 0.08503633699173263, 0.08408107318019609, 0.08963834544929505, 0.08089680599436577, 0.08247759111761266, 0.07951383630902509, 0.06873600928474932, 0.07522274909715343]}, "mutation_prompt": null}
{"id": "af6e312a-18c2-4975-94a1-32e8df81d960", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.9\n        self.exploration_probability = 0.18\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def velocity_based_perturbation(self, sol, velocity):\n        if np.random.rand() < self.exploration_probability:\n            step_size = 0.1\n            return np.clip(sol + step_size * velocity, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n        velocity = np.zeros((self.population_size, self.dim))\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n            velocity = velocity[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                trial = self.velocity_based_perturbation(trial, velocity[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n                    velocity[i] = trial - target\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive DE with Stochastic Evaluation Thresholds and Velocity-Based Perturbation for Diverse Search Dynamics.", "configspace": "", "generation": 90, "fitness": 0.3040621711170651, "feedback": "The algorithm QuantumDrivenAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7748084990093045, 0.7871109021214686, 0.7959090499985912, 0.778184231233103, 0.7582799089593888, 0.7776002308259793, 0.7701546963682439, 0.7943942284919208, 0.7720919346546837, 0.6517118376884294, 0.6703967750062994, 0.6118991273732073, 0.6324240385135657, 0.6366446316902368, 0.6585139746406001, 0.6077425635793507, 0.6445426012507318, 0.6057129597150417, 0.5277360477184191, 0.48707993154808893, 0.5393214473825556, 0.5158979375000514, 0.44100096355297624, 0.4706687414385554, 0.6161647076271577, 0.48295990834609515, 0.4886406157157476, 0.14373838559747054, 0.14040800068821535, 0.49907607411437604, 0.16418403100802792, 0.4409696278023172, 0.13561066825694357, 0.10979465543346756, 0.14843168828642062, 0.4211035684301825, 0.9184033102602729, 0.9254948047734765, 0.9183460608328986, 0.9053555599046479, 0.9075700335403929, 0.9139776552706012, 0.895969681377314, 0.9077134551656075, 0.9086718933835893, 0.30871361849868517, 0.1845104332664359, 0.36644595043456185, 0.3518570252858628, 0.23651237444551165, 0.25070261029263585, 0.2053215688511244, 0.2111679056306014, 0.3746444596012257, 0.3843317135098453, 0.22933126500912082, 0.5201480082120311, 0.6037761873010219, 0.20188884628783754, 0.3320668973888299, 0.5670066161385794, 0.6510079490882326, 0.5545773638260867, 0.3079675786860241, 0.11635521002957472, 0.15253330230424866, 0.15261540228889103, 0.15277638650923198, 0.10192238299733636, 0.1717792828988346, 0.17253301228519335, 0.26359041907193514, 0.16215728694885534, 0.1443776897424881, 0.1433563419179763, 0.177591137594861, 0.13044725769987786, 0.13168469413600747, 0.16625144107921697, 0.10655254315099938, 0.13002626816730356, 0.052556502549151674, 9.999999999998899e-05, 0.030163985603502974, 9.999999999998899e-05, 0.005256478663251629, 0.007777221659498568, 0.07992972804089782, 0.00932594442759005, 0.024619884930995095, 0.12950114551085135, 0.15548478172150904, 0.09935384655015078, 0.08344832716189832, 0.14533352130781985, 0.10616814052276624, 0.1012066553073635, 0.07557085108996053, 0.1097450484933804, 0.04950857714030976, 0.12077937922696458, 0.07482995588764263, 0.08557392031583655, 0.026636181974632245, 0.049885154540099785, 0.06699698477418792, 0.08273785052952298, 0.05502098154035606, 0.16337971462499734, 0.15701831036227665, 0.13846244645935035, 0.17254605582868665, 0.14729898285477483, 0.18392627901851277, 0.09417939207111636, 0.1512047072072552, 0.12844767173921923, 0.5100195959608627, 0.5378688147883098, 0.5104072730404372, 0.4976343640736409, 0.5082881605241512, 0.43339325530487527, 0.45603129448761126, 0.46999077606652695, 0.5444026420938588, 0.12146640580572454, 0.13457768986310348, 0.09455872207907556, 0.09711317956285037, 0.13500173106865132, 0.10633326383407216, 0.10051822659163667, 0.10012575190192641, 0.11180584879083255, 0.18754972493741473, 0.18050076494726053, 0.12869315930273828, 0.15007884695580653, 0.1787701318347139, 0.15361440390797565, 0.2076407849294878, 0.15398264339881285, 0.13452675121925772, 0.366050668117495, 0.3263334994338867, 0.35483531558246906, 0.3314639250431405, 0.397505424767275, 0.30219932403170513, 0.3309512828234049, 0.42563438138957166, 0.4393197548301725, 0.22802629937611507, 0.2254334640829031, 0.18783981601163446, 0.22369394396311915, 0.21100220454143193, 0.22094681695842278, 0.2120664025848833, 0.30859854255463015, 0.25295365285519245, 0.19006541769586138, 0.21425082505834936, 0.1879629703046447, 0.20238755176818135, 0.2091418106862496, 0.18838609274635898, 0.19188968240938242, 0.1988002358817792, 0.18533695832928, 0.47019589744398727, 0.21729848436359667, 0.1972933743429388, 0.4956029977905285, 0.5438831212915516, 0.2271603413941703, 0.20887341301361273, 0.22838222950997167, 0.20651359359438515, 0.180568716408382, 0.1814082839015645, 0.41251095596363585, 0.7950268579324431, 0.4590426934802656, 0.6764622604646211, 0.7507026336277662, 0.18709318117329943, 0.16159322146766264, 0.5403218706838444, 0.1973183998761605, 0.33768690718270766, 0.16045170169576028, 0.16046093068474598, 0.1760705890153973, 0.31692458228860365, 0.19398735781554455, 0.25140423611650353, 0.1885151424787297, 0.17994770193649878, 0.18730510952900092, 0.18840955264775572, 0.17179993490514678, 0.19265274859208292, 0.17847176619348715, 0.1866995107127567, 0.17265346653352232, 0.08247087690782173, 0.07566356216534764, 0.07520846600540321, 0.08043054612666312, 0.07626083367972059, 0.09868675911423175, 0.07465743977009365, 0.10658533203814968, 0.08378622203741437]}, "mutation_prompt": null}
{"id": "5f793cff-56f3-4862-a2c6-c10fbc885677", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDER:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        # Slightly adjusted parameter ranges for better adaptive behavior\n        self.f_min = 0.4\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.03  # Adjusted threshold for entropy control\n        self.chaos_control = 2.0  # Adjusted chaos control factor\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.1  # Increased step size for perturbation\n            return np.clip(sol - step_size * grad / np.linalg.norm(grad), self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, int(self.initial_population_size * (1 - eval_count / self.budget)))\n            self.population_size = dynamic_population_size\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDER", "description": "Quantum-Driven Adaptive Differential Evolution Refined with Dynamic Diversity Control and Enhanced Search Intensification for Improved Black Box Optimization.", "configspace": "", "generation": 91, "fitness": 0.30584662495493187, "feedback": "The algorithm QuantumDrivenAdaptiveDER got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7871520299752692, 0.7711373087268176, 0.7902182913697245, 0.7895141930382941, 0.7895918340306275, 0.7823480023257161, 0.7809571516746754, 0.7802277445283785, 0.8055156568592532, 0.6342632690741772, 0.5984844610073536, 0.6138894705816282, 0.6186307548284067, 0.6221425390140898, 0.6580025019915301, 0.6256646500417893, 0.6094935322814725, 0.6518185218316422, 0.521851211016133, 0.5573983763975222, 0.16761609192094673, 0.5295772220376767, 0.1637299404471001, 0.17113494682498842, 0.16412033544634486, 0.5010243403529575, 0.1446962075334739, 0.1476872369140363, 0.46737273894652676, 0.14250498184371485, 0.1394140655127778, 0.13151462550994053, 0.15937655907585302, 0.46430184073813674, 0.12371759002711225, 0.1671068364612669, 0.8857263791191751, 0.9183228494809236, 0.8749395549794967, 0.8776981807206495, 0.9019874603105996, 0.9241407724466083, 0.9241634638077793, 0.9007388234761446, 0.9154479136485285, 0.3460499603284639, 0.14597906422333107, 0.2632426619446897, 0.38223007150122035, 0.24517267238406193, 0.39808366162266506, 0.2406459237610704, 0.19183471454073486, 0.24289057311683449, 0.3237605275343113, 0.21717259074639905, 0.6445620608338138, 0.2560380544396006, 0.6621794493886515, 0.3218541599330479, 0.5095445963807549, 0.5392383110145105, 0.6535889634374581, 0.12037681089947072, 0.18203118776726612, 0.16070642353487452, 0.1316613957515006, 0.2233744490303755, 0.12185983588653981, 0.18102857566583663, 0.14306926548836252, 0.25649671160773324, 0.13806624618878194, 0.14361667798771793, 0.13141224207742086, 0.1358930001718276, 0.1896682638522461, 0.14567859017485174, 0.12781315282727557, 0.1526633413654387, 0.14770808449866413, 0.12654072878386013, 0.05905030731675032, 0.13594841676185754, 0.004663919134662131, 0.023575176869345515, 0.006663879897383818, 0.010124878276508542, 0.06826478959750093, 9.999999999998899e-05, 0.10372050000226862, 0.15945118357750476, 0.08703618784780409, 0.09435511494690707, 0.10473090036777044, 0.03801489668747349, 0.1152628691570513, 0.1511005001870459, 0.2171714162331867, 0.11852116656536726, 0.059357919259257375, 0.24427079348347225, 0.1160200719653327, 0.06355243657206922, 0.19235844859010287, 0.11385906380953925, 0.07150190263305978, 0.0763145297338872, 0.1348011460043783, 0.13954741841923568, 0.201759761246873, 0.2051645471203658, 0.1310511608549919, 0.19098371215145615, 0.07730608861066612, 0.21641393100611417, 0.09331627675694731, 0.5770510366019859, 0.551950816343133, 0.4562910756397719, 0.5433559424435102, 0.5297822636898779, 0.4139834101597051, 0.44870033407859233, 0.5007248809252273, 0.5334925479904886, 0.12253694335646137, 0.1288931383037043, 0.1252389388555255, 0.137653893885348, 0.11922160261880999, 0.15356926191441256, 0.113685200669432, 0.10484119165470951, 0.08140392324803647, 0.18868570165360443, 0.16126236817977513, 0.13480394442919208, 0.3008840202895732, 0.152916107548005, 0.13952369050793445, 0.175023682414569, 0.17749874883665184, 0.1677120078733647, 0.41573331382032186, 0.372510381428272, 0.3561429461192407, 0.3383489663738889, 0.31726034272348, 0.3442703735150623, 0.387045546067044, 0.42921366660336246, 0.4004879746111243, 0.18562854564751374, 0.30729259572773937, 0.188459035537073, 0.24466273440188957, 0.23032807731946725, 0.26092538828175615, 0.2865697898874453, 0.308811515346436, 0.2746712219907713, 0.20561289777857006, 0.24574008364170552, 0.191251273325995, 0.18060900185175033, 0.18949376891443792, 0.19815443799414567, 0.18932430640875364, 0.18330700675381373, 0.21544381635185872, 0.6445643579109118, 0.5877785770132873, 0.6036944755215163, 0.6025307499881768, 0.2080166039027579, 0.2145309048768037, 0.1928253773485007, 0.49116141816460124, 0.21755318669110424, 0.19596677939236384, 0.15926057223354584, 0.18726151750306885, 0.4139695906228088, 0.16036855857153864, 0.773445571367243, 0.1400658342035449, 0.1637941701469463, 0.8221408312643503, 0.6313202274052161, 0.20928381976633148, 0.5604817961783277, 0.3284661483831387, 0.16402562468978155, 0.190255521054846, 0.41956755067039564, 0.19812393135077677, 0.5060707920550345, 0.17430426589140136, 0.18460270564609904, 0.18545366898699756, 0.16273736047691456, 0.18147014306811315, 0.1842776816926518, 0.19699256098771523, 0.17724510905720003, 0.16919053598137357, 0.0734918394498767, 0.066494284640361, 0.08066568573339572, 0.07780330330867313, 0.08227894297816563, 0.09209023113272707, 0.08072438320413966, 0.08345047605601064, 0.0696568706491677]}, "mutation_prompt": null}
{"id": "92ff054b-fab3-43cf-ae00-f753f2aa9b23", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.8\n        self.cr_min = 0.4\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.8\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Entropy-Based Population Control for Superior Black Box Optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7875570887957954, 0.8012369783702157, 0.790229314707716, 0.7759888544727105, 0.7983763223558435, 0.786606269775392, 0.7971737039945818, 0.7973006304607254, 0.7773713089017079, 0.6238077507755002, 0.6189638395101797, 0.6519258651023577, 0.5918748303661052, 0.6740265357201265, 0.6462934198202925, 0.6054178862530957, 0.6267824103693449, 0.6742032984384149, 0.578246238908315, 0.5919051477964409, 0.14358442872360266, 0.17000830683740698, 0.14574384339761914, 0.5114875546675158, 0.17327001713889767, 0.5774741839196031, 0.40078012228802307, 0.14681259335109043, 0.3563806660780806, 0.5374244981550524, 0.3043496342744131, 0.10660014549337271, 0.16458826704797302, 0.1711773884911003, 0.12969057969149766, 0.42664870911754316, 0.9046066867595931, 0.873323940512408, 0.928883032130513, 0.9101174869387189, 0.8983840967670834, 0.920113054620013, 0.9211677375484819, 0.9215252721108967, 0.9371786747003521, 0.263373379090044, 0.2519517937870409, 0.28587729682872487, 0.21820963245657143, 0.25145655477071127, 0.4391199487929286, 0.34367094919120267, 0.3503457851853068, 0.22061390893298982, 0.6807929509488166, 0.18785067966599978, 0.3168624745077755, 0.2621170530733681, 0.6922345401187078, 0.6119349343732355, 0.6208830144096191, 0.7485072740535852, 0.22048145263579, 0.132740195409915, 0.14214976737983798, 0.1609740952613955, 0.16563974418094018, 0.16082873979896617, 0.11590992778826259, 0.29409274595933044, 0.122827403339696, 0.2550914092232459, 0.13742259519670275, 0.1416496079412709, 0.12011331839207051, 0.1521644653179437, 0.13433190974240583, 0.144089947069586, 0.15662395062511603, 0.14834177149628636, 0.14778893947317884, 0.005537750312516465, 0.028525114936939433, 9.999999999998899e-05, 0.016465851730348313, 0.04536367590690882, 0.05062104160270997, 9.999999999998899e-05, 0.02346088440243621, 0.05624800873838354, 0.07463630431052914, 0.21700236417538, 0.10653859963216239, 0.051846779101924256, 0.10575462186813878, 0.1225143582898145, 0.14049482655226198, 0.09656464560913058, 0.070413251572924, 0.06781885631052997, 0.06461412206044292, 0.07387236038971601, 0.0684500745322193, 0.05559405470900547, 0.1501560167571946, 0.09016818909848012, 0.09270222322477217, 0.08515653805577872, 0.19098430921669263, 0.13368713198068072, 0.13771360798759447, 0.19598476814990096, 0.22608182173851654, 0.1934219439469662, 0.08092341986380303, 0.09574026606065622, 0.11566406678114394, 0.4746209324713785, 0.5125836536185344, 0.5821262107959416, 0.4440006477710099, 0.5145815458439121, 0.5372714355267592, 0.49567839678456405, 0.485847061040912, 0.4963827523715847, 0.12399050478230889, 0.14957260262955274, 0.09302494714036069, 0.12077693256652278, 0.12275473415297455, 0.12097998908000229, 0.1123689149654078, 0.11469148334533896, 0.09720832618246256, 0.16994188600378024, 0.1741762228105863, 0.17543960883485255, 0.206317321830515, 0.17557899350523798, 0.27025798070458906, 0.21535387363294034, 0.17733573296335747, 0.12513902288292733, 0.42549971908098694, 0.38437241736452965, 0.3660657992489921, 0.3827889166649552, 0.3827883083937399, 0.31750414425973505, 0.3701297429348642, 0.40926982319482463, 0.40632249800239084, 0.2839871442395635, 0.26610776217181753, 0.26833124537577313, 0.3067597006974858, 0.20645276879625796, 0.31794122381811485, 0.2696646633760226, 0.30117875555666507, 0.21322483424456595, 0.21007431061530335, 0.1885400332192706, 0.19712554320770315, 0.2393766836229576, 0.2033789603532129, 0.19827285535948025, 0.18162842747845676, 0.1885634068731462, 0.22211102476005784, 0.5556062874678702, 0.5942144248856054, 0.33363868407152075, 0.48209415242470555, 0.2287008714810621, 0.5869102283821646, 0.21968381442141738, 0.3990965704765309, 0.5092141612263197, 0.17970262050875085, 0.48829664241454174, 0.182813782454319, 0.19245822148515135, 0.6140182301710304, 0.8074085046874806, 0.14119388075529682, 0.17359534240606134, 0.6670811533106582, 0.6487956226485414, 0.32004868367195805, 0.3631932282897594, 0.19652519771090637, 0.20195748778766798, 0.19850931324153465, 0.1479954999280273, 0.4782713430801522, 0.25235796440585123, 0.170301495503849, 0.1783611013880394, 0.17219393011840622, 0.18012871379618423, 0.17164981985195737, 0.1835762814299935, 0.19258732900267062, 0.19777852953488584, 0.18332472377506415, 0.07827584601829862, 0.09252202927940378, 0.0838115639853797, 0.0751927510091267, 0.08275591260439974, 0.10256960911355728, 0.08408332258894191, 0.07422167071623675, 0.07609843676979311]}, "mutation_prompt": null}
{"id": "c203ed30-b06a-4fe1-b02d-6bac518289e9", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.4  # Adjusted mutation factor minimum\n        self.f_max = 0.9  # Adjusted mutation factor maximum\n        self.cr_min = 0.2  # Adjusted crossover rate minimum\n        self.cr_max = 0.9  # Adjusted crossover rate maximum\n        self.elite_count = max(3, self.population_size // 8)  # Updated elite count\n        self.entropy_threshold = 0.01  # Tweaked entropy threshold\n        self.chaos_control = 2.0  # Altered chaos control\n        self.exploration_probability = 0.1  # Modified exploration probability\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.1  # Adjusted step size\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1.0  # Updated chaotic map calculation\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Enhanced Adaptive Parameters and Entropy-Based Population Control for Improved Black Box Optimization.", "configspace": "", "generation": 93, "fitness": 0.2978624939894021, "feedback": "The algorithm QuantumDrivenAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.790174390899081, 0.7819912568935881, 0.805902671850449, 0.7677412947184435, 0.7951029269920726, 0.7842681486457344, 0.7833498750810126, 0.7798451242715947, 0.7847957168676477, 0.5919635692911747, 0.619543217982126, 0.6635202027845667, 0.6204383432872167, 0.6312575033989869, 0.6438590675257987, 0.6022091706516275, 0.6435422061020182, 0.6519462170125037, 0.539493902817676, 0.5195711077765947, 0.6014813810478532, 0.5561148277475638, 0.16957240381129046, 0.1732483690496821, 0.14863277565847333, 0.16562773166475675, 0.4813614169319518, 0.15922588717552733, 0.16620613816981988, 0.14305065210989865, 0.14232113579494288, 0.1260509102237316, 0.17046480288576227, 0.14372747627493276, 0.49645281025373966, 0.14140187893417044, 0.8610953025957814, 0.8888858855820845, 0.9185295941471603, 0.9058014661486344, 0.9285191767800695, 0.9291650291762849, 0.904721819062358, 0.9473704833311316, 0.93177132133034, 0.29608498506069014, 0.18378123529800605, 0.346946297253915, 0.22317623950433652, 0.1660889349934188, 0.20662353017605462, 0.2912150169155766, 0.1927808265684785, 0.23885926746788277, 0.6711467727515688, 0.3052185623280135, 0.5264667843717774, 0.20695334504937213, 0.554097008696735, 0.2008345389723487, 0.3251890969226512, 0.3179979825025441, 0.2217583394357734, 0.17108038473228027, 0.12022536662065109, 0.162039293740868, 0.3029418863616573, 0.140034646887915, 0.11279638724243812, 0.22703510519800285, 0.19353276755040727, 0.178927615149178, 0.17893090703711112, 0.1305501816310305, 0.16162811681416456, 0.13508762065888846, 0.13518439751936073, 0.17577851664680288, 0.15952200807794548, 0.13645758158335464, 0.13444326419856156, 0.03646552114280499, 9.999999999998899e-05, 9.999999999998899e-05, 0.06484847528614868, 0.0006503326650887375, 0.08973746653193593, 0.025906451247406093, 0.052727086665536826, 0.027356809057845766, 0.19196572124586586, 0.1406334567878028, 0.18521201036595392, 0.05382384794617534, 0.11841359226526116, 0.11738135449068432, 0.08411666625391956, 0.10783000228435646, 0.17331513292351952, 0.034674455432352036, 0.1311232790662783, 0.12366696981636394, 0.07181472433915403, 0.15884813765851336, 0.10359722504438873, 0.08019362144331665, 0.14713998704687514, 0.05935408574352463, 0.12602868731330963, 0.28005512632582485, 0.18718390010246155, 0.17801317012253315, 0.15025831217306207, 0.1879449908449906, 0.10711060167971842, 0.17176718512634392, 0.10236538605074275, 0.49227612317512515, 0.503262365716119, 0.5080429349968532, 0.5414131844573755, 0.45894036472412847, 0.5506644353412035, 0.4737318933578091, 0.44302169439729355, 0.5170786776152735, 0.11224125570956844, 0.11667356681392516, 0.0908902144046011, 0.12498844616470783, 0.1318297949794116, 0.1314622938991562, 0.12342044825994303, 0.1199114381849602, 0.1161338423670919, 0.22409703052993013, 0.19302218489031397, 0.16989258733903045, 0.1628275623937605, 0.15766544937152727, 0.14352960407893844, 0.2808332934713621, 0.1603952273121413, 0.18180759640127553, 0.3570720645981704, 0.29858381945264056, 0.3823229909751489, 0.37858055869856044, 0.37142381465558916, 0.3599261917349128, 0.3559238862015408, 0.4308562870738556, 0.47345467345209935, 0.1877027860918583, 0.27278048289883117, 0.266149608963417, 0.23012641920674215, 0.21174230955121687, 0.22831177126016855, 0.2302348282164539, 0.2967400846095164, 0.3317599907142812, 0.1965226080986302, 0.20917884770939776, 0.18596122529184855, 0.19807847429736414, 0.20273567186630326, 0.19547683001085625, 0.18655190112402908, 0.25250416001309994, 0.19587564046668782, 0.20865226497557654, 0.19576954272889358, 0.3919958175960576, 0.20733686244750293, 0.5185489018338124, 0.22901774501406968, 0.21032977457317037, 0.20916668796887328, 0.2135176963719323, 0.14561766905073692, 0.20485918776215373, 0.186939356670084, 0.7142622902928073, 0.186479887828632, 0.7777138309308704, 0.16222361738001856, 0.16123470047206778, 0.7908021944297587, 0.37995164387295355, 0.2098625608590825, 0.2025754480010471, 0.19637621052958287, 0.16349185579290348, 0.4803705154650506, 0.6562696094007192, 0.29697925737986486, 0.667105882477026, 0.1821819662643328, 0.16928206134615242, 0.17766769940286153, 0.18856754890284055, 0.1843896724653713, 0.17831371795396622, 0.1834797757602481, 0.19482302318998035, 0.18005673255132237, 0.08818720053278462, 0.0735653497343095, 0.08083932791460613, 0.07823813093815357, 0.08004425028461082, 0.07936137414178535, 0.07557727902109201, 0.077932752226205, 0.07725321424126053]}, "mutation_prompt": null}
{"id": "645e652c-570e-4470-80c7-4191872820dd", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.8\n        self.cr_min = 0.4\n        self.cr_max = 0.9\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.03\n        self.chaos_control = 1.9\n        self.exploration_probability = 0.18\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def stochastic_tunneling(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            noise = np.random.normal(scale=0.1, size=self.dim)\n            return np.clip(sol + noise, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.8) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.stochastic_tunneling(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution featuring Dynamic Stochastic Tunneling and Entropy-Driven Population Control for Enhanced Black Box Optimization Performance.", "configspace": "", "generation": 94, "fitness": 0.30247896634429844, "feedback": "The algorithm QuantumDrivenAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.798171704624697, 0.7900417384590404, 0.7791937415645368, 0.785257809308676, 0.7851343281486127, 0.8070846427939846, 0.776974975154098, 0.7687421282288429, 0.8005354937460236, 0.648691774640167, 0.6541116581014439, 0.5136863893695971, 0.6480727972361614, 0.6565650726222734, 0.13687427446496458, 0.10517695022421047, 0.6466985403556365, 0.684400508618959, 0.5279467970267235, 0.16791396259472535, 0.5287879126827331, 0.1599727147264708, 0.5776569922717318, 0.14029415838612258, 0.5768406616399915, 0.1713901274044518, 0.5499318914828297, 0.11551093195767603, 0.16069207807907182, 0.16147813617983142, 0.14572719778407695, 0.13836605554345405, 0.13407949562617683, 0.09518025498558713, 0.14112347225654864, 0.1655304044299497, 0.8803960314670815, 0.8764324045213191, 0.9286655668670563, 0.8544087800102294, 0.9645190215437338, 0.9225893087284145, 0.8692886400660793, 0.9100636981977854, 0.9175750478582726, 0.33424755220275104, 0.24308665458971068, 0.268852232158001, 0.4091936965808318, 0.12637036466515728, 0.3045983188876966, 0.23523541113496416, 0.25678816626825396, 0.16728841646011583, 0.20628948971664152, 0.6316255972744571, 0.6797652930951352, 0.7891193947712556, 0.6635882344761574, 0.20679854955952992, 0.3015699820600699, 0.7829845013260138, 0.7541946387352266, 0.16390297287778466, 0.22554520239894615, 0.17761953039736678, 0.19163689556364472, 0.28859334796767355, 0.3314655778632879, 0.1846127461289191, 0.12349919861587311, 0.2694819274934396, 0.1272013381210112, 0.14072909628393604, 0.22231641082949405, 0.19206472570249256, 0.1541007869272245, 0.14470076050511815, 0.11277256348306874, 0.13410807832619265, 0.18858378496012673, 0.05847638284122991, 0.037815525109774484, 9.999999999998899e-05, 0.07884740473195129, 0.07524167983788388, 0.053769594120902875, 0.013157186284512679, 0.030934919863200072, 0.09543166264063674, 0.19511354641854006, 0.17030259296026728, 0.13382859467152752, 0.13432126203781047, 0.09191522274892361, 0.012573355052628021, 0.19690292990056235, 0.19372960360141955, 0.16303611477022828, 0.06474462069450582, 0.16457361468727572, 0.028832785203478317, 0.06430044127040291, 0.08445776195349664, 0.13782713588843942, 0.0876026019070354, 0.1036118175412355, 0.18232985196395757, 0.19866331862642506, 0.0842235483788083, 0.11803563483382717, 0.18135407963140548, 0.2251850379818492, 0.2268275652584244, 0.14269512893207625, 0.1351544805485433, 0.07612923252934811, 0.5231016002753799, 0.4674984842422525, 0.4910418136907617, 0.49326144185116716, 0.4756498050305359, 0.49141663591283824, 0.5058022305555887, 0.5015044616246793, 0.5824240354983259, 0.10641636797728804, 0.11104546376781144, 0.1333747433512884, 0.13324719298766596, 0.1119840852173597, 0.1528750348328134, 0.16058564529880093, 0.13257607066678634, 0.14801650128619182, 0.17985078183790315, 0.16524639377387718, 0.19430433671702807, 0.20173925494707035, 0.13990864572848716, 0.1736095028550544, 0.2260774838482852, 0.1785054179898654, 0.1641351885671074, 0.36733264475595695, 0.391883536544099, 0.4156611980387068, 0.3695315811927471, 0.3917189129062443, 0.3116235955485325, 0.44482642465163735, 0.45161794545385014, 0.4404953449865616, 0.23489245861994412, 0.26261309087517515, 0.25241505267813036, 0.28820241236847954, 0.2151801630541177, 0.29649257133677154, 0.3113983453270437, 0.34275983606784344, 0.343649295941153, 0.19236479477644475, 0.21021611873359447, 0.19073422786287741, 0.19352948706349105, 0.19613858073255697, 0.20235695173590684, 0.1882947392745683, 0.2040095569348931, 0.20607896044166585, 0.5281027181367848, 0.22604636159319713, 0.2324911269465897, 0.49610775622470893, 0.41733823075948884, 0.23964522556969114, 0.23530129587716864, 0.22516016845075548, 0.23148989971280198, 0.18807927830467386, 0.19039329143064287, 0.18295260242935585, 0.19557027381723113, 0.16783942303292498, 0.8043374655766231, 0.1725020393505451, 0.16573280906835575, 0.6009600212184768, 0.7500366262107528, 0.2066880887747936, 0.2055318871835765, 0.20024650083538176, 0.2036827618545658, 0.5695676638777618, 0.16329043218711248, 0.19810676252759596, 0.32740039013405, 0.20702108520210794, 0.18667731671521093, 0.1823891192661684, 0.1902393843237381, 0.1929683741843895, 0.16779895236401643, 0.184035754848476, 0.20297200867245224, 0.17100850401703827, 0.08109501458562318, 0.07401661116806213, 0.08854581631870917, 0.07651796664038424, 0.07502789659397258, 0.0817979520160883, 0.08351833741964076, 0.074836716121366, 0.08481842478004886]}, "mutation_prompt": null}
{"id": "516415a4-ad80-4fb9-93dc-8b03c07097e1", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.8\n        self.cr_min = 0.4\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.8\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Entropy-Based Population Control for Superior Black Box Optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7875570887957954, 0.8012369783702157, 0.790229314707716, 0.7759888544727105, 0.7983763223558435, 0.786606269775392, 0.7971737039945818, 0.7973006304607254, 0.7773713089017079, 0.6238077507755002, 0.6189638395101797, 0.6519258651023577, 0.5918748303661052, 0.6740265357201265, 0.6462934198202925, 0.6054178862530957, 0.6267824103693449, 0.6742032984384149, 0.578246238908315, 0.5919051477964409, 0.14358442872360266, 0.17000830683740698, 0.14574384339761914, 0.5114875546675158, 0.17327001713889767, 0.5774741839196031, 0.40078012228802307, 0.14681259335109043, 0.3563806660780806, 0.5374244981550524, 0.3043496342744131, 0.10660014549337271, 0.16458826704797302, 0.1711773884911003, 0.12969057969149766, 0.42664870911754316, 0.9046066867595931, 0.873323940512408, 0.928883032130513, 0.9101174869387189, 0.8983840967670834, 0.920113054620013, 0.9211677375484819, 0.9215252721108967, 0.9371786747003521, 0.263373379090044, 0.2519517937870409, 0.28587729682872487, 0.21820963245657143, 0.25145655477071127, 0.4391199487929286, 0.34367094919120267, 0.3503457851853068, 0.22061390893298982, 0.6807929509488166, 0.18785067966599978, 0.3168624745077755, 0.2621170530733681, 0.6922345401187078, 0.6119349343732355, 0.6208830144096191, 0.7485072740535852, 0.22048145263579, 0.132740195409915, 0.14214976737983798, 0.1609740952613955, 0.16563974418094018, 0.16082873979896617, 0.11590992778826259, 0.29409274595933044, 0.122827403339696, 0.2550914092232459, 0.13742259519670275, 0.1416496079412709, 0.12011331839207051, 0.1521644653179437, 0.13433190974240583, 0.144089947069586, 0.15662395062511603, 0.14834177149628636, 0.14778893947317884, 0.005537750312516465, 0.028525114936939433, 9.999999999998899e-05, 0.016465851730348313, 0.04536367590690882, 0.05062104160270997, 9.999999999998899e-05, 0.02346088440243621, 0.05624800873838354, 0.07463630431052914, 0.21700236417538, 0.10653859963216239, 0.051846779101924256, 0.10575462186813878, 0.1225143582898145, 0.14049482655226198, 0.09656464560913058, 0.070413251572924, 0.06781885631052997, 0.06461412206044292, 0.07387236038971601, 0.0684500745322193, 0.05559405470900547, 0.1501560167571946, 0.09016818909848012, 0.09270222322477217, 0.08515653805577872, 0.19098430921669263, 0.13368713198068072, 0.13771360798759447, 0.19598476814990096, 0.22608182173851654, 0.1934219439469662, 0.08092341986380303, 0.09574026606065622, 0.11566406678114394, 0.4746209324713785, 0.5125836536185344, 0.5821262107959416, 0.4440006477710099, 0.5145815458439121, 0.5372714355267592, 0.49567839678456405, 0.485847061040912, 0.4963827523715847, 0.12399050478230889, 0.14957260262955274, 0.09302494714036069, 0.12077693256652278, 0.12275473415297455, 0.12097998908000229, 0.1123689149654078, 0.11469148334533896, 0.09720832618246256, 0.16994188600378024, 0.1741762228105863, 0.17543960883485255, 0.206317321830515, 0.17557899350523798, 0.27025798070458906, 0.21535387363294034, 0.17733573296335747, 0.12513902288292733, 0.42549971908098694, 0.38437241736452965, 0.3660657992489921, 0.3827889166649552, 0.3827883083937399, 0.31750414425973505, 0.3701297429348642, 0.40926982319482463, 0.40632249800239084, 0.2839871442395635, 0.26610776217181753, 0.26833124537577313, 0.3067597006974858, 0.20645276879625796, 0.31794122381811485, 0.2696646633760226, 0.30117875555666507, 0.21322483424456595, 0.21007431061530335, 0.1885400332192706, 0.19712554320770315, 0.2393766836229576, 0.2033789603532129, 0.19827285535948025, 0.18162842747845676, 0.1885634068731462, 0.22211102476005784, 0.5556062874678702, 0.5942144248856054, 0.33363868407152075, 0.48209415242470555, 0.2287008714810621, 0.5869102283821646, 0.21968381442141738, 0.3990965704765309, 0.5092141612263197, 0.17970262050875085, 0.48829664241454174, 0.182813782454319, 0.19245822148515135, 0.6140182301710304, 0.8074085046874806, 0.14119388075529682, 0.17359534240606134, 0.6670811533106582, 0.6487956226485414, 0.32004868367195805, 0.3631932282897594, 0.19652519771090637, 0.20195748778766798, 0.19850931324153465, 0.1479954999280273, 0.4782713430801522, 0.25235796440585123, 0.170301495503849, 0.1783611013880394, 0.17219393011840622, 0.18012871379618423, 0.17164981985195737, 0.1835762814299935, 0.19258732900267062, 0.19777852953488584, 0.18332472377506415, 0.07827584601829862, 0.09252202927940378, 0.0838115639853797, 0.0751927510091267, 0.08275591260439974, 0.10256960911355728, 0.08408332258894191, 0.07422167071623675, 0.07609843676979311]}, "mutation_prompt": null}
{"id": "1606aa46-a36e-4b07-bebf-a16083c3a204", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.8\n        self.cr_min = 0.4\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.8\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Entropy-Based Population Control for Superior Black Box Optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7875570887957954, 0.8012369783702157, 0.790229314707716, 0.7759888544727105, 0.7983763223558435, 0.786606269775392, 0.7971737039945818, 0.7973006304607254, 0.7773713089017079, 0.6238077507755002, 0.6189638395101797, 0.6519258651023577, 0.5918748303661052, 0.6740265357201265, 0.6462934198202925, 0.6054178862530957, 0.6267824103693449, 0.6742032984384149, 0.578246238908315, 0.5919051477964409, 0.14358442872360266, 0.17000830683740698, 0.14574384339761914, 0.5114875546675158, 0.17327001713889767, 0.5774741839196031, 0.40078012228802307, 0.14681259335109043, 0.3563806660780806, 0.5374244981550524, 0.3043496342744131, 0.10660014549337271, 0.16458826704797302, 0.1711773884911003, 0.12969057969149766, 0.42664870911754316, 0.9046066867595931, 0.873323940512408, 0.928883032130513, 0.9101174869387189, 0.8983840967670834, 0.920113054620013, 0.9211677375484819, 0.9215252721108967, 0.9371786747003521, 0.263373379090044, 0.2519517937870409, 0.28587729682872487, 0.21820963245657143, 0.25145655477071127, 0.4391199487929286, 0.34367094919120267, 0.3503457851853068, 0.22061390893298982, 0.6807929509488166, 0.18785067966599978, 0.3168624745077755, 0.2621170530733681, 0.6922345401187078, 0.6119349343732355, 0.6208830144096191, 0.7485072740535852, 0.22048145263579, 0.132740195409915, 0.14214976737983798, 0.1609740952613955, 0.16563974418094018, 0.16082873979896617, 0.11590992778826259, 0.29409274595933044, 0.122827403339696, 0.2550914092232459, 0.13742259519670275, 0.1416496079412709, 0.12011331839207051, 0.1521644653179437, 0.13433190974240583, 0.144089947069586, 0.15662395062511603, 0.14834177149628636, 0.14778893947317884, 0.005537750312516465, 0.028525114936939433, 9.999999999998899e-05, 0.016465851730348313, 0.04536367590690882, 0.05062104160270997, 9.999999999998899e-05, 0.02346088440243621, 0.05624800873838354, 0.07463630431052914, 0.21700236417538, 0.10653859963216239, 0.051846779101924256, 0.10575462186813878, 0.1225143582898145, 0.14049482655226198, 0.09656464560913058, 0.070413251572924, 0.06781885631052997, 0.06461412206044292, 0.07387236038971601, 0.0684500745322193, 0.05559405470900547, 0.1501560167571946, 0.09016818909848012, 0.09270222322477217, 0.08515653805577872, 0.19098430921669263, 0.13368713198068072, 0.13771360798759447, 0.19598476814990096, 0.22608182173851654, 0.1934219439469662, 0.08092341986380303, 0.09574026606065622, 0.11566406678114394, 0.4746209324713785, 0.5125836536185344, 0.5821262107959416, 0.4440006477710099, 0.5145815458439121, 0.5372714355267592, 0.49567839678456405, 0.485847061040912, 0.4963827523715847, 0.12399050478230889, 0.14957260262955274, 0.09302494714036069, 0.12077693256652278, 0.12275473415297455, 0.12097998908000229, 0.1123689149654078, 0.11469148334533896, 0.09720832618246256, 0.16994188600378024, 0.1741762228105863, 0.17543960883485255, 0.206317321830515, 0.17557899350523798, 0.27025798070458906, 0.21535387363294034, 0.17733573296335747, 0.12513902288292733, 0.42549971908098694, 0.38437241736452965, 0.3660657992489921, 0.3827889166649552, 0.3827883083937399, 0.31750414425973505, 0.3701297429348642, 0.40926982319482463, 0.40632249800239084, 0.2839871442395635, 0.26610776217181753, 0.26833124537577313, 0.3067597006974858, 0.20645276879625796, 0.31794122381811485, 0.2696646633760226, 0.30117875555666507, 0.21322483424456595, 0.21007431061530335, 0.1885400332192706, 0.19712554320770315, 0.2393766836229576, 0.2033789603532129, 0.19827285535948025, 0.18162842747845676, 0.1885634068731462, 0.22211102476005784, 0.5556062874678702, 0.5942144248856054, 0.33363868407152075, 0.48209415242470555, 0.2287008714810621, 0.5869102283821646, 0.21968381442141738, 0.3990965704765309, 0.5092141612263197, 0.17970262050875085, 0.48829664241454174, 0.182813782454319, 0.19245822148515135, 0.6140182301710304, 0.8074085046874806, 0.14119388075529682, 0.17359534240606134, 0.6670811533106582, 0.6487956226485414, 0.32004868367195805, 0.3631932282897594, 0.19652519771090637, 0.20195748778766798, 0.19850931324153465, 0.1479954999280273, 0.4782713430801522, 0.25235796440585123, 0.170301495503849, 0.1783611013880394, 0.17219393011840622, 0.18012871379618423, 0.17164981985195737, 0.1835762814299935, 0.19258732900267062, 0.19777852953488584, 0.18332472377506415, 0.07827584601829862, 0.09252202927940378, 0.0838115639853797, 0.0751927510091267, 0.08275591260439974, 0.10256960911355728, 0.08408332258894191, 0.07422167071623675, 0.07609843676979311]}, "mutation_prompt": null}
{"id": "46b8583d-b209-4ca7-b21b-142adcad8474", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.8\n        self.cr_min = 0.4\n        self.cr_max = 0.8\n        self.elite_count = max(2, self.population_size // 10)\n        self.entropy_threshold = 0.02\n        self.chaos_control = 1.8\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            return np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Enhanced Chaotic Perturbation and Entropy-Based Population Control for Superior Black Box Optimization.", "configspace": "", "generation": 82, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7875570887957954, 0.8012369783702157, 0.790229314707716, 0.7759888544727105, 0.7983763223558435, 0.786606269775392, 0.7971737039945818, 0.7973006304607254, 0.7773713089017079, 0.6238077507755002, 0.6189638395101797, 0.6519258651023577, 0.5918748303661052, 0.6740265357201265, 0.6462934198202925, 0.6054178862530957, 0.6267824103693449, 0.6742032984384149, 0.578246238908315, 0.5919051477964409, 0.14358442872360266, 0.17000830683740698, 0.14574384339761914, 0.5114875546675158, 0.17327001713889767, 0.5774741839196031, 0.40078012228802307, 0.14681259335109043, 0.3563806660780806, 0.5374244981550524, 0.3043496342744131, 0.10660014549337271, 0.16458826704797302, 0.1711773884911003, 0.12969057969149766, 0.42664870911754316, 0.9046066867595931, 0.873323940512408, 0.928883032130513, 0.9101174869387189, 0.8983840967670834, 0.920113054620013, 0.9211677375484819, 0.9215252721108967, 0.9371786747003521, 0.263373379090044, 0.2519517937870409, 0.28587729682872487, 0.21820963245657143, 0.25145655477071127, 0.4391199487929286, 0.34367094919120267, 0.3503457851853068, 0.22061390893298982, 0.6807929509488166, 0.18785067966599978, 0.3168624745077755, 0.2621170530733681, 0.6922345401187078, 0.6119349343732355, 0.6208830144096191, 0.7485072740535852, 0.22048145263579, 0.132740195409915, 0.14214976737983798, 0.1609740952613955, 0.16563974418094018, 0.16082873979896617, 0.11590992778826259, 0.29409274595933044, 0.122827403339696, 0.2550914092232459, 0.13742259519670275, 0.1416496079412709, 0.12011331839207051, 0.1521644653179437, 0.13433190974240583, 0.144089947069586, 0.15662395062511603, 0.14834177149628636, 0.14778893947317884, 0.005537750312516465, 0.028525114936939433, 9.999999999998899e-05, 0.016465851730348313, 0.04536367590690882, 0.05062104160270997, 9.999999999998899e-05, 0.02346088440243621, 0.05624800873838354, 0.07463630431052914, 0.21700236417538, 0.10653859963216239, 0.051846779101924256, 0.10575462186813878, 0.1225143582898145, 0.14049482655226198, 0.09656464560913058, 0.070413251572924, 0.06781885631052997, 0.06461412206044292, 0.07387236038971601, 0.0684500745322193, 0.05559405470900547, 0.1501560167571946, 0.09016818909848012, 0.09270222322477217, 0.08515653805577872, 0.19098430921669263, 0.13368713198068072, 0.13771360798759447, 0.19598476814990096, 0.22608182173851654, 0.1934219439469662, 0.08092341986380303, 0.09574026606065622, 0.11566406678114394, 0.4746209324713785, 0.5125836536185344, 0.5821262107959416, 0.4440006477710099, 0.5145815458439121, 0.5372714355267592, 0.49567839678456405, 0.485847061040912, 0.4963827523715847, 0.12399050478230889, 0.14957260262955274, 0.09302494714036069, 0.12077693256652278, 0.12275473415297455, 0.12097998908000229, 0.1123689149654078, 0.11469148334533896, 0.09720832618246256, 0.16994188600378024, 0.1741762228105863, 0.17543960883485255, 0.206317321830515, 0.17557899350523798, 0.27025798070458906, 0.21535387363294034, 0.17733573296335747, 0.12513902288292733, 0.42549971908098694, 0.38437241736452965, 0.3660657992489921, 0.3827889166649552, 0.3827883083937399, 0.31750414425973505, 0.3701297429348642, 0.40926982319482463, 0.40632249800239084, 0.2839871442395635, 0.26610776217181753, 0.26833124537577313, 0.3067597006974858, 0.20645276879625796, 0.31794122381811485, 0.2696646633760226, 0.30117875555666507, 0.21322483424456595, 0.21007431061530335, 0.1885400332192706, 0.19712554320770315, 0.2393766836229576, 0.2033789603532129, 0.19827285535948025, 0.18162842747845676, 0.1885634068731462, 0.22211102476005784, 0.5556062874678702, 0.5942144248856054, 0.33363868407152075, 0.48209415242470555, 0.2287008714810621, 0.5869102283821646, 0.21968381442141738, 0.3990965704765309, 0.5092141612263197, 0.17970262050875085, 0.48829664241454174, 0.182813782454319, 0.19245822148515135, 0.6140182301710304, 0.8074085046874806, 0.14119388075529682, 0.17359534240606134, 0.6670811533106582, 0.6487956226485414, 0.32004868367195805, 0.3631932282897594, 0.19652519771090637, 0.20195748778766798, 0.19850931324153465, 0.1479954999280273, 0.4782713430801522, 0.25235796440585123, 0.170301495503849, 0.1783611013880394, 0.17219393011840622, 0.18012871379618423, 0.17164981985195737, 0.1835762814299935, 0.19258732900267062, 0.19777852953488584, 0.18332472377506415, 0.07827584601829862, 0.09252202927940378, 0.0838115639853797, 0.0751927510091267, 0.08275591260439974, 0.10256960911355728, 0.08408332258894191, 0.07422167071623675, 0.07609843676979311]}, "mutation_prompt": null}
{"id": "b7daf42d-7d6a-4897-93aa-00dded320e79", "solution": "import numpy as np\n\nclass QuantumDrivenAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 8 * dim\n        self.population_size = self.initial_population_size\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.8\n        self.cr_min = 0.4\n        self.cr_max = 0.9  # Adjusted for greater diversity\n        self.elite_count = max(3, self.population_size // 8)  # Enhanced elite selection\n        self.entropy_threshold = 0.03  # Adjusted threshold for entropy\n        self.chaos_control = 1.9  # Slightly adjusted chaos control\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def gradient_based_perturbation(self, sol, func):\n        if np.random.rand() < self.exploration_probability:\n            grad = np.random.randn(self.dim)\n            step_size = 0.05\n            perturbed = np.clip(sol - step_size * grad, self.lower_bound, self.upper_bound)\n            return np.clip(perturbed + 0.01 * (self.best_solution - perturbed), self.lower_bound, self.upper_bound)  # Multi-layered perturbation\n        return sol\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.7) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            dynamic_population_size = max(6, self.initial_population_size * (1 - eval_count / self.budget))\n            self.population_size = int(dynamic_population_size)\n            self.population = self.population[:self.population_size]\n            fitness = fitness[:self.population_size]\n\n            for i in range(self.population_size):\n                f, cr = self.adaptive_parameters()\n                target = self.population[i]\n                mutant = self.mutate(i, f)\n                trial = self.crossover(target, mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.gradient_based_perturbation(trial, func)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if trial_fitness < func(target):\n                    self.population[i] = trial\n                    fitness[i] = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            elite_indices = np.argsort(fitness)[:self.elite_count]\n            elites = self.population[elite_indices]\n            self.population[:self.elite_count] = elites\n\n        return self.best_solution, self.best_fitness", "name": "QuantumDrivenAdaptiveDE", "description": "Quantum-Driven Adaptive Differential Evolution with Multi-Layered Gradient Perturbation and Enhanced Elite Selection for Superior Black Box Optimization.", "configspace": "", "generation": 98, "fitness": 0.27957136506685343, "feedback": "The algorithm QuantumDrivenAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {"aucs": [0.7728479683681296, 0.7948692744638889, 0.7921110623491292, 0.7738721014141301, 0.7764286618790804, 0.7974494050896002, 0.7912871267726576, 0.8216178853820096, 0.7963285225579093, 0.679507698259543, 0.6485069390107405, 0.5506490435081535, 0.5508703685782538, 0.6758450343115895, 0.6625664923212412, 0.6118964121297104, 0.6501350338696112, 0.6699130833509349, 0.1619065861693474, 0.1738387784693317, 0.4387380879358851, 0.16920257648767, 0.1628752514977021, 0.1321180532975733, 0.16447633532363637, 0.16941220700055692, 0.1649876188533166, 0.14408016233787235, 0.4436367012349459, 0.15003693224618075, 0.13887376033745857, 0.1475395897391012, 0.16780881176196494, 0.16348233497643128, 0.1177672448195135, 0.11430148265539064, 0.9054902502367529, 0.8724451779484442, 0.8972322039554907, 0.85109270712433, 0.9237208423825141, 0.8964379416844561, 0.9269143974793156, 0.9539312633998446, 0.9174350812609124, 0.33832733480308363, 0.3058547750377034, 0.414627530096071, 0.33445040079075994, 0.2518779644548229, 0.40046642838626934, 0.3862181520404666, 0.225015458840631, 0.23544985525283557, 0.2175014389011043, 0.33196402199407704, 0.2284653592099165, 0.2589940734159025, 0.2045464254790591, 0.2628394745056788, 0.3331322515112689, 0.2340850507644876, 0.7866060064670459, 0.1599068029084394, 0.18085969979903405, 0.15926892748264454, 0.11314315254798968, 0.1543407056252759, 0.14017250991875885, 0.14704651257571566, 0.17188884060320708, 0.19203370590170576, 0.18975139947044262, 0.13772850270441162, 0.1352718204878025, 0.128790104883292, 0.211262045049587, 0.22206007352416424, 0.12775540873441715, 0.17839951716355096, 0.15414269198474162, 0.03291369806537392, 0.06440126497839627, 0.06061491853013068, 0.059363617835439086, 0.03909256174935094, 0.006519514454114361, 0.018307729002362993, 0.0035556531696423477, 0.02210904234438471, 0.22653572915732179, 0.08105730666181876, 0.13208448376644888, 0.03246098889159443, 0.012847506907568973, 0.05630738086300913, 0.12614931152495534, 0.09649855148374076, 0.1254055372407613, 0.07257671424963241, 0.14521009351972802, 0.037433964144327536, 0.06404324859703447, 0.06908189698491585, 0.11979846668165683, 0.1221321426026849, 0.09069670992083811, 0.12447338141259623, 0.10743825383839267, 0.04357665874285144, 0.1681187664585423, 0.12633102404203322, 0.17892571432310234, 0.14639713753838624, 0.07969690144257036, 0.17649480297524112, 0.12941327143878967, 0.46402765266058466, 0.4693309543423526, 0.5656426941179181, 0.519326773082511, 0.49314472025558087, 0.5291028572751924, 0.502869136212113, 0.5130729307815813, 0.5259874890210969, 0.13315734654025402, 0.10625818072214555, 0.09475987541220443, 0.09784947885934303, 0.10568972895316309, 0.13174070968519846, 0.11391802741441426, 0.12411866733902821, 0.11850604869916992, 0.19528159438003045, 0.15217186186983922, 0.1914205800624318, 0.16753230069521974, 0.2107298150150606, 0.15512601186763264, 0.22156533208073448, 0.24454660065357448, 0.20448142090865162, 0.40742771201352057, 0.35753530619763474, 0.3596276596266851, 0.359523533644343, 0.413356285626686, 0.40368682114487286, 0.4569105490488482, 0.2908610267553806, 0.3131608782398446, 0.12683169423728502, 0.2626298411989022, 0.2852742417399655, 0.29073074504889096, 0.2891275939781617, 0.23606118957951627, 0.30540790091514936, 0.3155794175281825, 0.24371275367167278, 0.20462149498457893, 0.21377184911240776, 0.18775713152037832, 0.2139147206787756, 0.19922458609742288, 0.21523984105476446, 0.1948321153601118, 0.2075767625435635, 0.1855931381629382, 0.233310392312032, 0.2065840396048637, 0.20293333578658546, 0.20579417751162377, 0.20964409953762753, 0.18652745482990118, 0.19296713143438637, 0.19728843899141646, 0.4691166268567991, 0.1718452680341256, 0.18026752062320517, 0.1942406713709729, 0.19408948961985995, 0.16825617228889567, 0.19614151856742834, 0.14125215633312815, 0.6350408201875504, 0.81441630179093, 0.40715767208250964, 0.20972098211118873, 0.3377363252836795, 0.16455883858130183, 0.20866373660398718, 0.1980940961683607, 0.1545426286199214, 0.20266318245880166, 0.3234221370216136, 0.17376872542502064, 0.17572879851291823, 0.1938945501782693, 0.17423109773303735, 0.17820450727393022, 0.16143846355212554, 0.17760557835655377, 0.17050938531290072, 0.17876387203552258, 0.08886180975252078, 0.0866885101342989, 0.0844371772233159, 0.08547609611960438, 0.07392936145486562, 0.10657475935018557, 0.07995352100392561, 0.0708626298341225, 0.09008235486865757]}, "mutation_prompt": null}
{"id": "f96faec9-384d-433e-885f-3738afb2d297", "solution": "import numpy as np\n\nclass QuantumParticleSwarmDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, dim))\n        self.velocities = np.random.uniform(-1, 1, (self.population_size, dim))\n        self.best_personal_positions = np.copy(self.population)\n        self.best_personal_fitness = np.full(self.population_size, np.inf)\n        self.best_solution = None\n        self.best_fitness = float('inf')\n        self.f_min = 0.5\n        self.f_max = 0.9\n        self.cr_min = 0.3\n        self.cr_max = 0.9\n        self.inertia_weight = 0.5\n        self.cognitive_component = 1.5\n        self.social_component = 1.5\n        self.entropy_threshold = 0.02\n        self.chaos_control = 2.1\n        self.exploration_probability = 0.15\n\n    def adaptive_parameters(self):\n        f = np.random.uniform(self.f_min, self.f_max)\n        cr = np.random.uniform(self.cr_min, self.cr_max)\n        return f, cr\n\n    def chaotic_map(self, x):\n        return (self.chaos_control * x + 0.9) % 1.0\n\n    def mutate(self, target_idx, f):\n        indices = [idx for idx in range(self.population_size) if idx != target_idx]\n        a, b, c = self.population[np.random.choice(indices, 3, replace=False)]\n        chaos_factor = self.chaotic_map(np.random.rand())\n        mutant = np.clip(a + f * (b - c) * chaos_factor, self.lower_bound, self.upper_bound)\n        return mutant\n\n    def crossover(self, target, mutant, cr):\n        crossover = np.random.rand(self.dim) < cr\n        if not np.any(crossover):\n            crossover[np.random.randint(0, self.dim)] = True\n        return np.where(crossover, mutant, target)\n\n    def update_velocity(self, idx):\n        inertia = self.inertia_weight * self.velocities[idx]\n        cognitive = self.cognitive_component * np.random.rand(self.dim) * (self.best_personal_positions[idx] - self.population[idx])\n        social = self.social_component * np.random.rand(self.dim) * (self.best_solution - self.population[idx])\n        self.velocities[idx] = inertia + cognitive + social\n\n    def calculate_entropy(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        fitness = np.full(self.population_size, np.inf)\n\n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                self.update_velocity(i)\n                self.population[i] = np.clip(self.population[i] + self.velocities[i], self.lower_bound, self.upper_bound)\n\n                f, cr = self.adaptive_parameters()\n                mutant = self.mutate(i, f)\n                trial = self.crossover(self.population[i], mutant, cr)\n\n                if self.calculate_entropy() < self.entropy_threshold:\n                    trial = self.population[i] + self.chaotic_map(np.random.randn(self.dim))\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if trial_fitness < self.best_personal_fitness[i]:\n                    self.best_personal_positions[i] = trial\n                    self.best_personal_fitness[i] = trial_fitness\n\n                if trial_fitness < self.best_fitness:\n                    self.best_solution = trial\n                    self.best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n        return self.best_solution, self.best_fitness", "name": "QuantumParticleSwarmDE", "description": "Particle Swarm-Inspired Quantum Differential Evolution with Chaotic Adaptive Parameters for Enhanced Global Search.", "configspace": "", "generation": 99, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "b4ed971e-a2a0-472a-9bcb-a1b1f503806f", "metadata": {}, "mutation_prompt": null}
