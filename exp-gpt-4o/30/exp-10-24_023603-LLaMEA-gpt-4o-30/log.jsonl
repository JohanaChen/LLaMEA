{"id": "03238acb-95b1-45cb-9150-30ce442d55f5", "solution": "import numpy as np\n\nclass AMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"])\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"])\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_memory(F, self.cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AMDE", "description": "A novel Adaptive Memory-Based Differential Evolution (AMDE) algorithm incorporating adaptive memory of successful strategies to improve convergence and exploration.", "configspace": "", "generation": 0, "fitness": 0.3881610139501735, "feedback": "The algorithm AMDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.26.", "error": "", "parent_id": null, "metadata": {"aucs": [0.8115500630055854, 0.8030371915120872, 0.8236132102889899, 0.8295752000165022, 0.8115681813055129, 0.8191526329420882, 0.8123283348737662, 0.8076847606139985, 0.8206596387107614, 0.6642973379833338, 0.6640755633942357, 0.6835421191567106, 0.665682257565863, 0.6730416792268539, 0.6543221905965906, 0.6774389869779706, 0.6613196571948083, 0.6479197620046944, 0.10677071759504142, 0.1080923565239924, 0.13554782840820956, 0.13749347300221182, 0.11949278428502697, 0.11188568485511718, 0.11108592750728985, 0.12182523958442837, 0.12574858177849035, 0.08935078555914167, 0.09792139755365714, 0.11652790325605289, 0.10784367232134118, 0.10116032624688653, 0.09860010624020255, 0.10209213141328566, 0.10448160819359331, 0.1204943296122698, 0.9262934070784081, 0.9140850777174927, 0.9094047583168681, 0.8033305902854314, 0.9392146679393096, 0.944081729088408, 0.9104611076610913, 0.9130909574642111, 0.9454552275767137, 0.48317040918996645, 0.4892869459211795, 0.5255738888385427, 0.46097786624327086, 0.4944876662930493, 0.5443389311637407, 0.48228919749452903, 0.49014832957046617, 0.4576804569268955, 0.7757543938976739, 0.7675024925166722, 0.7571656500575393, 0.8161255412238769, 0.7772039833666851, 0.7358436393087185, 0.7681123629755248, 0.7841879475655216, 0.7742001808849447, 0.20416951507008518, 0.2678423363633903, 0.20132988751390357, 0.1939181466030514, 0.1835225304586311, 0.22323484068628663, 0.2523098777748771, 0.39129113963333906, 0.30800699981537494, 0.29355754518229993, 0.21649566290841638, 0.18025328969310794, 0.31778092741063313, 0.24851553071619237, 0.4092403744299843, 0.18835094367315608, 0.19521126015478474, 0.17318804494649154, 0.48267437989996353, 0.44932567552194036, 0.4255680433841166, 0.46077221331204277, 0.3622205036929246, 0.4249610973391945, 0.4329010314136008, 0.42583866749156873, 0.4317407831389328, 0.5691586321222184, 0.5841265606874193, 0.6128056373856061, 0.5052953845641596, 0.5360352425460094, 0.6098520910866504, 0.625003224300633, 0.6304491620004309, 0.5962534516966507, 0.1340762360906299, 0.08289273224468707, 0.14390780423494054, 0.32771099777439716, 0.17662405327673225, 0.2104568486550329, 0.2267797398841115, 0.24524871034009432, 0.23779720330419873, 0.34409870511065777, 0.32284796390849013, 0.33574287830237526, 0.33540603728787566, 0.3329576966108805, 0.3148112467729627, 0.36199120346929337, 0.3387380288318209, 0.3401176674225078, 0.7293304482093885, 0.7040238362655575, 0.7369095523436611, 0.7120980518932297, 0.7014516475511581, 0.7119330851400771, 0.7171993726366986, 0.7231683148501018, 0.7313298309450622, 0.10788563856928557, 0.10138667536092383, 0.09775742103389073, 0.11498265021010667, 0.09330058781380923, 0.10817634619220895, 0.10134166830227931, 0.09933463552275934, 0.10958521611742122, 0.1354851141788287, 0.14098782387380993, 0.1524127347187232, 0.14385405151326613, 0.21708964750592252, 0.1623845603640539, 0.29954594030810067, 0.1298781603402427, 0.12661437324070557, 0.4385415278300935, 0.43371812634821283, 0.4120065423623517, 0.4133734721449511, 0.412150761860823, 0.4215924794934863, 0.44387745954321967, 0.4901816366616193, 0.4639847899741417, 0.3405419270519575, 0.3304375120070011, 0.38348272478993173, 0.3076797383751395, 0.3479892635229197, 0.30716626221003307, 0.33415150092590296, 0.3730429010687232, 0.33319583176188294, 0.18304942078735875, 0.196309878469488, 0.20393141687966265, 0.18663824625004577, 0.2038907321337341, 0.2110471318921916, 0.21320493504789173, 0.19481226426459586, 0.21105399049952056, 0.2680842674940558, 0.20574377516068976, 0.18366019524208643, 0.19195350310661574, 0.33554830220833354, 0.2034837757650193, 0.18912127502333342, 0.19116290122244117, 0.18297132585082265, 0.7336076935002311, 0.14704264063745687, 0.7728263306927248, 0.6939487202129796, 0.1615988108045081, 0.17789326045592535, 0.6623752878388777, 0.17650164592702167, 0.6612361335370914, 0.16318429415618996, 0.7480789144349956, 0.2030212864578671, 0.7201427912133928, 0.5949411191948639, 0.6288879066993356, 0.20361602949518032, 0.7917051173010317, 0.15407765191403655, 0.18481838665884598, 0.18718203069013462, 0.1920440451807709, 0.18942506748445576, 0.1835470837323876, 0.19465840946629098, 0.18632628875556834, 0.2054447165642277, 0.18342881063556815, 0.07939980852653494, 0.08299944699872086, 0.07142870737390472, 0.08909994222987971, 0.0723743447747831, 0.07670402732812309, 0.08859915557387432, 0.0887049860977549, 0.07758152444732025]}, "mutation_prompt": null}
{"id": "ee9c33aa-405d-4c18-b2b0-848805d76c51", "solution": "import numpy as np\n\nclass AMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"])\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"])\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_memory(F, self.cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AMDE", "description": "A novel Adaptive Memory-Based Differential Evolution (AMDE) algorithm incorporating adaptive memory of successful strategies to improve convergence and exploration.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.8115500630055854, 0.8030371915120872, 0.8236132102889899, 0.8295752000165022, 0.8115681813055129, 0.8191526329420882, 0.8123283348737662, 0.8076847606139985, 0.8206596387107614, 0.6642973379833338, 0.6640755633942357, 0.6835421191567106, 0.665682257565863, 0.6730416792268539, 0.6543221905965906, 0.6774389869779706, 0.6613196571948083, 0.6479197620046944, 0.10677071759504142, 0.1080923565239924, 0.13554782840820956, 0.13749347300221182, 0.11949278428502697, 0.11188568485511718, 0.11108592750728985, 0.12182523958442837, 0.12574858177849035, 0.08935078555914167, 0.09792139755365714, 0.11652790325605289, 0.10784367232134118, 0.10116032624688653, 0.09860010624020255, 0.10209213141328566, 0.10448160819359331, 0.1204943296122698, 0.9262934070784081, 0.9140850777174927, 0.9094047583168681, 0.8033305902854314, 0.9392146679393096, 0.944081729088408, 0.9104611076610913, 0.9130909574642111, 0.9454552275767137, 0.48317040918996645, 0.4892869459211795, 0.5255738888385427, 0.46097786624327086, 0.4944876662930493, 0.5443389311637407, 0.48228919749452903, 0.49014832957046617, 0.4576804569268955, 0.7757543938976739, 0.7675024925166722, 0.7571656500575393, 0.8161255412238769, 0.7772039833666851, 0.7358436393087185, 0.7681123629755248, 0.7841879475655216, 0.7742001808849447, 0.20416951507008518, 0.2678423363633903, 0.20132988751390357, 0.1939181466030514, 0.1835225304586311, 0.22323484068628663, 0.2523098777748771, 0.39129113963333906, 0.30800699981537494, 0.29355754518229993, 0.21649566290841638, 0.18025328969310794, 0.31778092741063313, 0.24851553071619237, 0.4092403744299843, 0.18835094367315608, 0.19521126015478474, 0.17318804494649154, 0.48267437989996353, 0.44932567552194036, 0.4255680433841166, 0.46077221331204277, 0.3622205036929246, 0.4249610973391945, 0.4329010314136008, 0.42583866749156873, 0.4317407831389328, 0.5691586321222184, 0.5841265606874193, 0.6128056373856061, 0.5052953845641596, 0.5360352425460094, 0.6098520910866504, 0.625003224300633, 0.6304491620004309, 0.5962534516966507, 0.1340762360906299, 0.08289273224468707, 0.14390780423494054, 0.32771099777439716, 0.17662405327673225, 0.2104568486550329, 0.2267797398841115, 0.24524871034009432, 0.23779720330419873, 0.34409870511065777, 0.32284796390849013, 0.33574287830237526, 0.33540603728787566, 0.3329576966108805, 0.3148112467729627, 0.36199120346929337, 0.3387380288318209, 0.3401176674225078, 0.7293304482093885, 0.7040238362655575, 0.7369095523436611, 0.7120980518932297, 0.7014516475511581, 0.7119330851400771, 0.7171993726366986, 0.7231683148501018, 0.7313298309450622, 0.10788563856928557, 0.10138667536092383, 0.09775742103389073, 0.11498265021010667, 0.09330058781380923, 0.10817634619220895, 0.10134166830227931, 0.09933463552275934, 0.10958521611742122, 0.1354851141788287, 0.14098782387380993, 0.1524127347187232, 0.14385405151326613, 0.21708964750592252, 0.1623845603640539, 0.29954594030810067, 0.1298781603402427, 0.12661437324070557, 0.4385415278300935, 0.43371812634821283, 0.4120065423623517, 0.4133734721449511, 0.412150761860823, 0.4215924794934863, 0.44387745954321967, 0.4901816366616193, 0.4639847899741417, 0.3405419270519575, 0.3304375120070011, 0.38348272478993173, 0.3076797383751395, 0.3479892635229197, 0.30716626221003307, 0.33415150092590296, 0.3730429010687232, 0.33319583176188294, 0.18304942078735875, 0.196309878469488, 0.20393141687966265, 0.18663824625004577, 0.2038907321337341, 0.2110471318921916, 0.21320493504789173, 0.19481226426459586, 0.21105399049952056, 0.2680842674940558, 0.20574377516068976, 0.18366019524208643, 0.19195350310661574, 0.33554830220833354, 0.2034837757650193, 0.18912127502333342, 0.19116290122244117, 0.18297132585082265, 0.7336076935002311, 0.14704264063745687, 0.7728263306927248, 0.6939487202129796, 0.1615988108045081, 0.17789326045592535, 0.6623752878388777, 0.17650164592702167, 0.6612361335370914, 0.16318429415618996, 0.7480789144349956, 0.2030212864578671, 0.7201427912133928, 0.5949411191948639, 0.6288879066993356, 0.20361602949518032, 0.7917051173010317, 0.15407765191403655, 0.18481838665884598, 0.18718203069013462, 0.1920440451807709, 0.18942506748445576, 0.1835470837323876, 0.19465840946629098, 0.18632628875556834, 0.2054447165642277, 0.18342881063556815, 0.07939980852653494, 0.08299944699872086, 0.07142870737390472, 0.08909994222987971, 0.0723743447747831, 0.07670402732812309, 0.08859915557387432, 0.0887049860977549, 0.07758152444732025]}, "mutation_prompt": null}
{"id": "48198588-3dd6-4582-a8e3-c2d746f47e78", "solution": "import numpy as np\n\nclass DMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # slight reduction in population size for faster evaluations\n        self.memory_size = 10  # increased memory size to store more successful strategies\n        self.cross_prob = 0.8  # slightly reduced crossover probability for diversity\n        self.F = np.random.uniform(0.4, 0.9)  # dynamic F value for mutation diversity\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.random.uniform(0.4, 0.9, self.memory_size),  # diverse initial F values\n            \"CR\": np.random.uniform(0.7, 1.0, self.memory_size)  # diverse initial CR values\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation with diverse F values\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"])\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover with dynamic CR\n                CR = np.random.choice(self.memory[\"CR\"])\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "DMDE", "description": "A Dynamic Memory-Based Differential Evolution (DMDE) algorithm with adaptive strategy selection and mutation diversity for enhanced exploration and convergence.", "configspace": "", "generation": 2, "fitness": 0.342659522768308, "feedback": "The algorithm DMDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.8497458660643948, 0.817860429908205, 0.569469232239673, 0.8628121387598268, 0.8210224718433801, 0.616858338882783, 0.8635200889701001, 0.8079293512259622, 0.6467181998042233, 0.8055296935711125, 0.6611518701414579, 0.42985078849527303, 0.15112794628129322, 0.6611982753919295, 0.42160119220778514, 0.775715790636462, 0.674592442589974, 0.371997503172093, 0.20365914303040966, 0.13522748758941927, 0.09959814715096005, 0.42598544834264296, 0.1200915865515122, 0.09757295559734536, 0.1301118665566834, 0.1397007900772702, 0.09141830065156942, 0.1359426120415972, 0.15601769966654322, 0.08458255131937764, 0.12113596245463887, 0.11344653691877316, 0.09332541247060966, 0.10695941071477844, 0.11543266926862783, 0.08439366209809573, 0.7996157202046448, 0.9531812330623635, 0.9703952905727945, 0.7639652600277821, 0.9687650269557675, 0.9635261931497955, 0.9360413276322836, 0.9553474741559533, 0.9772612590944143, 0.12520564420402513, 0.45605950972734755, 0.3048249647084451, 0.16047149915240388, 0.45277817116645025, 0.29588579893568123, 0.17096090194922453, 0.42352781046694876, 0.34000850574008745, 0.8945688499906077, 0.647589838727149, 0.5587752264209305, 0.8881823463576334, 0.6503654795897056, 0.6213159895477474, 0.896576914331148, 0.7294252562109793, 0.5707388163650187, 0.15402538656794007, 0.254256611651855, 0.20615461648766242, 0.20047010606344173, 0.19439491020961364, 0.2565219741136854, 0.2556980462116455, 0.2074064010155554, 0.2660023198068243, 0.18215950929355618, 0.16016581314976464, 0.405079781897728, 0.23730214500340174, 0.2201010254127621, 0.2600767252809779, 0.19512191700958736, 0.21173711799721118, 0.2321642859322286, 0.2467093234570633, 0.02134371052419015, 0.17558831702560196, 0.2583535581374611, 0.11405884975620373, 0.2147485845454673, 0.7161467640198322, 0.1441804817791481, 0.20892776560778625, 0.6344858302263139, 0.2474993806531064, 0.3201425182673481, 0.7806990677968517, 0.2521888233747325, 0.34222848151112917, 0.7980728536696743, 0.30099084589561287, 0.3508974309672802, 0.05639555441674948, 0.04805308912305628, 0.041065067454414406, 0.16686285045510663, 0.07672178382840955, 0.0421439848157239, 0.20948365081005826, 0.0002036166310978027, 0.06749026095022959, 0.3688929474982492, 0.17676822747796794, 0.22134566627091024, 0.6115760023076354, 0.21537292425829724, 0.19834356958353772, 0.3202460298144467, 0.19743465435603358, 0.20758010169522123, 0.4896484130793831, 0.5862580003073385, 0.527197140272341, 0.5376852471236914, 0.6023017184806103, 0.5151865475969624, 0.7292139196011618, 0.5699330979980788, 0.5229522101670346, 0.11752571360178632, 0.09353994810646604, 0.10100692716307491, 0.10413401871497541, 0.08903021510346987, 0.09203145769961463, 0.14325029483405438, 0.10049109922536703, 0.08088279175728164, 0.17475342935681804, 0.14756397064739069, 0.1814857403912693, 0.27694062619314586, 0.15813159580535763, 0.1714450509640939, 0.17192867871281703, 0.14248809614735614, 0.13031851691522844, 0.6371125020811541, 0.3674837054993504, 0.2812653692592261, 0.6039460774382296, 0.3692418521149583, 0.27267321902944963, 0.6197741602905452, 0.4153056979540325, 0.28803751012591283, 0.3077000890865391, 0.24468726235170535, 0.21740000398956105, 0.5529297241621766, 0.27217821303850864, 0.20884164851255782, 0.4570824004954456, 0.283454972386906, 0.2454049277975151, 0.1925625941625282, 0.19713181157528514, 0.1904693491421673, 0.23551139060805937, 0.1857457895354384, 0.1853033706958488, 0.21271313828068428, 0.1802731557133619, 0.16518481696175624, 0.6185568027099568, 0.2405043388255902, 0.1811000121784303, 0.2039628516403461, 0.20622619329839742, 0.1754013747676203, 0.21473955691285196, 0.21431805731093867, 0.17745358947791423, 0.19524967746392252, 0.5611778690584504, 0.630752700988799, 0.7965495047350123, 0.5821868555929417, 0.17104136201117948, 0.8976322480160508, 0.5355783400347309, 0.1833531900479577, 0.20483597427518552, 0.6513498587038646, 0.5695988788010506, 0.8215780398777199, 0.17830633060139844, 0.187392826522098, 0.20746189612245303, 0.692400264886083, 0.2060414389442914, 0.17847737589283297, 0.19516701545652348, 0.19596213381073246, 0.17927046357280518, 0.18406428564114008, 0.1765006973245592, 0.18676607330026385, 0.18250373250663698, 0.17899544927205113, 0.08186489286368692, 0.0726820575986159, 0.06814206985151683, 0.08651452012372807, 0.08802167356632473, 0.07623862253358349, 0.08462125302888801, 0.0925419656035309, 0.06388795074529408]}, "mutation_prompt": null}
{"id": "718adf3d-5d41-477f-a6ce-dc51c1454155", "solution": "import numpy as np\n\nclass HMPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.velocity = np.random.uniform(-1, 1, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        \n        self.personal_best = np.copy(self.population)\n        self.personal_best_fitness = np.full(self.population_size, np.inf)\n        \n        self.global_best = None\n        self.global_best_fitness = np.inf\n        \n        self.memory = {\n            \"c1\": np.full(self.memory_size, 1.49618),\n            \"c2\": np.full(self.memory_size, 1.49618),\n            \"w\": np.full(self.memory_size, 0.7298)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, c1, c2, w):\n        self.memory[\"c1\"][self.memory_index] = c1\n        self.memory[\"c2\"][self.memory_index] = c2\n        self.memory[\"w\"][self.memory_index] = w\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                r1, r2 = np.random.rand(self.dim), np.random.rand(self.dim)\n                c1 = np.random.choice(self.memory[\"c1\"])\n                c2 = np.random.choice(self.memory[\"c2\"])\n                w = np.random.choice(self.memory[\"w\"])\n\n                self.velocity[i] = (w * self.velocity[i] +\n                                    c1 * r1 * (self.personal_best[i] - self.population[i]) +\n                                    c2 * r2 * (self.global_best - self.population[i]))\n                \n                self.population[i] += self.velocity[i]\n                self.population[i] = np.clip(self.population[i], self.lower_bound, self.upper_bound)\n\n                trial_fitness = func(self.population[i])\n                eval_count += 1\n\n                if trial_fitness < self.personal_best_fitness[i]:\n                    self.personal_best[i] = self.population[i]\n                    self.personal_best_fitness[i] = trial_fitness\n                    \n                if trial_fitness < self.global_best_fitness:\n                    self.global_best = self.population[i]\n                    self.global_best_fitness = trial_fitness\n\n                if eval_count >= self.budget:\n                    break\n\n            self.update_memory(c1, c2, w)\n        \n        return self.global_best, self.global_best_fitness", "name": "HMPSO", "description": "Hybrid Memory-Based Particle Swarm Optimization (HMPSO) combining swarm intelligence with adaptive memory to enhance exploration and exploitation.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "An exception occurred: TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\").", "error": "TypeError(\"unsupported operand type(s) for -: 'NoneType' and 'float'\")", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {}, "mutation_prompt": null}
{"id": "3ab1b31b-9ab1-4bc4-b6f5-1066a08bdadc", "solution": "import numpy as np\n\nclass EAMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Dynamic Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"]) * (0.5 + np.random.rand() * 0.5)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                cross_prob = np.random.choice(self.memory[\"CR\"]) * (0.6 + np.random.rand() * 0.4)\n                cross_points = np.random.rand(self.dim) < cross_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_memory(F, cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EAMDE", "description": "Enhanced Adaptive Memory-Based Differential Evolution (EAMDE) using dynamic crossover and mutation scaling to improve exploration and exploitation balance.", "configspace": "", "generation": 4, "fitness": 0.13253255734878008, "feedback": "The algorithm EAMDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.08.", "error": "", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.30415721303286514, 0.2889774122320973, 0.2502441524744098, 0.2703626526635763, 0.32826315717720167, 0.2829426387817514, 0.2865732657454316, 0.2803192993995808, 0.2560166168892083, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.014335379009241644, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11413461479706344, 0.08725883659111788, 0.12305946839333826, 0.1335400709941854, 0.12947408246756353, 0.10804236578783366, 0.0818817814895978, 0.0864176654395522, 0.11215782446589961, 0.08995650217883666, 0.07153928405237753, 0.09695146853860914, 0.11146315104476012, 0.07193235016679156, 0.12962127818570424, 0.07905168761825132, 0.07274379671833975, 0.09770771543263823, 0.12481676101681682, 0.14577856711995796, 0.16677082868551185, 0.14127111705848094, 0.17022209929147303, 0.16498257013720885, 0.13857537571881806, 0.1713555351226933, 0.16936681984009916, 0.14633930675769302, 0.0773974555558612, 0.12056689405759913, 0.09485636318712587, 0.08152190554707517, 0.08775984609633347, 0.12663652373293022, 0.11161712243516109, 0.16389248147023805, 0.1699375321711326, 0.19483507537130007, 0.15479718607542714, 0.16373653877360816, 0.2261727482374727, 0.18835328757779635, 0.15034653614505677, 0.2039031592477083, 0.18012414863865833, 0.1234984523459709, 0.07509679489532572, 0.08458017975728382, 0.09294264684843456, 0.03884002226831618, 0.09629791878176752, 0.10502378747260555, 0.06959607195945738, 0.12750197048783352, 0.10285089844841189, 0.11374217038847678, 0.08093499907549062, 0.12548612176085716, 0.12518252139334585, 0.10922439930118566, 0.10795605548337539, 0.11551934861917945, 0.11285758503214693, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0693859333828839, 0.05793970530398529, 0.06819172466165835, 0.052168762828601944, 0.03895626633833149, 0.06229190026519771, 0.09131913410284598, 0.05783176937091539, 0.11889875897436686, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02587394280708455, 0.020805355508616286, 0.02921209000761049, 0.03881828344992588, 0.055991520344903956, 0.04464358233897603, 0.05453784555510588, 0.059626464885377706, 0.02104717689786162, 0.2252428352754211, 0.2926476032886932, 0.3082576578599876, 0.25298275516905544, 0.27816719055270733, 0.22951477791155062, 0.29437495249572176, 0.2523396277896446, 0.27038542415645617, 0.0741928419830663, 0.0842026846994437, 0.09340754045073751, 0.07390703286413247, 0.07201859610170647, 0.09385166196201244, 0.08833649732174798, 0.08051897812331865, 0.06918372867430245, 0.17555945296652553, 0.17245076917548974, 0.15335988951164203, 0.20996170980524842, 0.1417152206523148, 0.17601153034202632, 0.14988223945719514, 0.14208038818715174, 0.14220800264585265, 0.22148552597832327, 0.2176111983644129, 0.2236431964621881, 0.2133892730375193, 0.20307388135334759, 0.20030063009551646, 0.2111233204854892, 0.19398233535522302, 0.18937107285009058, 0.19647004568747228, 0.13736662142356448, 0.15805173579164966, 0.157211626543871, 0.14051167215151894, 0.1464999377089804, 0.1752680365751692, 0.13587509692061417, 0.12778997792310653, 0.1825004472807118, 0.17989608856105643, 0.20386012074951598, 0.19233738847589266, 0.19055373347878124, 0.1910673370216538, 0.2116944664051501, 0.20461666163350223, 0.17935746430642963, 0.20453863724584886, 0.1808042096816539, 0.181287702657012, 0.19666865921564192, 0.16153174592883135, 0.1787843646568099, 0.18808309200642692, 0.17424963282831818, 0.1998972828365656, 0.18125157435920236, 0.2162226404126344, 0.1940103601189952, 0.1912545832670528, 0.16880241042859945, 0.28594759229390687, 0.22757518285812461, 0.18703839741537132, 0.235060482453326, 0.2530543152781328, 0.1962891135674315, 0.21405378104367545, 0.24659463471627618, 0.1816298823350192, 0.16209112819753446, 0.17221364379383375, 0.2647321008396535, 0.2441570199253934, 0.19807476170137228, 0.17883881305722238, 0.2343420677549477, 0.1845818613252983, 0.18500646594430925, 0.17992798941782728, 0.18933439434407984, 0.18363287108047843, 0.17605836384189422, 0.08416994164959579, 0.07296394419257946, 0.07956201909726757, 0.0744411974397583, 0.07896544170935704, 0.07567123814684096, 0.06705413644246405, 0.07386310180896671, 0.06871744779628808]}, "mutation_prompt": null}
{"id": "05b7f6c5-4b78-480b-9b77-b79021d1df1c", "solution": "import numpy as np\n\nclass SADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        self.success_rates = np.zeros(self.memory_size)\n        \n    def update_memory(self, F, CR, success):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.success_rates[self.memory_index] = success\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def select_parameters(self):\n        probabilities = self.success_rates / np.sum(self.success_rates)\n        if np.sum(probabilities) > 0:\n            index = np.random.choice(self.memory_size, p=probabilities)\n        else:\n            index = np.random.randint(self.memory_size)\n        return self.memory[\"F\"][index], self.memory[\"CR\"][index]\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F, CR = self.select_parameters()\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    success = 1.0\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                else:\n                    success = 0.0\n                \n                self.update_memory(F, CR, success)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "SADE", "description": "A Self-Adaptive Differential Evolution (SADE) algorithm that dynamically adjusts strategy parameters using feedback from the search process to improve optimization performance.", "configspace": "", "generation": 5, "fitness": 0.3792422477782526, "feedback": "The algorithm SADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.25.", "error": "", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.8075714599654259, 0.8010195814270603, 0.8326775413008487, 0.7966642908033188, 0.8193199630109156, 0.8063065615352258, 0.8006903037008407, 0.8107387798482691, 0.820945320449164, 0.6729315917502923, 0.690507120161976, 0.6678471310242486, 0.6642630840374217, 0.6746960525984389, 0.6711765083680181, 0.667888300820109, 0.6880122111009997, 0.645549915096894, 0.10952325534534668, 0.11531792967070653, 0.1117258703691476, 0.11969363973665481, 0.1168321451720209, 0.11751723043991258, 0.10838844073980236, 0.118011697667877, 0.12313787993701131, 0.10018972046670149, 0.10615213205510177, 0.10687798727569098, 0.10416432007276977, 0.1003521201746258, 0.09978936879543221, 0.12165945156363756, 0.10937756582080727, 0.12436890788079003, 0.9509980862589339, 0.9306219465548868, 0.8027138509035809, 0.8951125554075975, 0.938142400058741, 0.9250155694583879, 0.9216515297198487, 0.83706217966162, 0.8215352317528735, 0.5541534310777706, 0.48011818666231354, 0.4899533114453718, 0.4863276348549672, 0.48867069726662526, 0.4912474247494275, 0.4521812264070192, 0.49765419950586387, 0.538088561115757, 0.7466746929006782, 0.7702962413337052, 0.7928040001976636, 0.8182949743729835, 0.8444438420822991, 0.77165950575135, 0.7722582415013239, 0.7932481565172824, 0.7905551387150143, 0.2240804281132489, 0.20570278759007565, 0.16975797305952, 0.19994210555586223, 0.2846203433581562, 0.17898618296463065, 0.2663645700108568, 0.27417423129983587, 0.22471398300749523, 0.2539162808695652, 0.26270162613620507, 0.2709351688087853, 0.2249538165045747, 0.22712910347433812, 0.1888345104000596, 0.24699566035322684, 0.20457230564068296, 0.23565660304278846, 0.46954699301999303, 0.45089296037833204, 0.4408039918701475, 0.42121181301766075, 0.39230462024413404, 0.3942823211781843, 0.4738786977589411, 0.42208387309562845, 0.4675922663736941, 0.579946025304518, 0.5718094716854458, 0.5884725237490755, 0.561914906204081, 0.5083421003712651, 0.5620280782218287, 0.5805003882695363, 0.5794776040939494, 0.5925903171712251, 0.17412570465400856, 0.20240543410666711, 0.12703506060315484, 0.21582194443341962, 0.26982299804592236, 0.31844544961346477, 0.13677789088597514, 0.2771986162629628, 0.1994802505522162, 0.3272591002024484, 0.3301518759538583, 0.3200965453702018, 0.3545157493091906, 0.3446988435997931, 0.3128001993498115, 0.3583422171413516, 0.35122837464678214, 0.3353789623562532, 0.7317686507287486, 0.7114144673911876, 0.7467441230534961, 0.7228610005134174, 0.7026583446263286, 0.7068085364186205, 0.7060697453680542, 0.7071507027265419, 0.7314881653279135, 0.10085552468127934, 0.09817468485634451, 0.10406090107502663, 0.10132450280779592, 0.11016368944385302, 0.09209796541279447, 0.10928215265976937, 0.1051759972102494, 0.10304359056667722, 0.20451338863449164, 0.1365722669375713, 0.18815070279173185, 0.12908857497927362, 0.1572962175212469, 0.14454987961670107, 0.14262223328458745, 0.16968416488481197, 0.14028044374950444, 0.4371597298961054, 0.42037932182174587, 0.4480657942101036, 0.41067739925429125, 0.42157658692631916, 0.46499279270766114, 0.4714607502763932, 0.4505891236035152, 0.4228578196293178, 0.3428218880539333, 0.33204006600476055, 0.296045262569129, 0.3511543454458673, 0.3310612770428517, 0.30018834380447346, 0.3408249289077512, 0.3448582100322076, 0.31490713498312684, 0.19954748257814525, 0.19831377917489112, 0.2186976319131717, 0.19027397795795564, 0.22253207160285593, 0.19346217545081634, 0.2095836936915153, 0.1850879515384085, 0.18513793030318826, 0.1849004629276767, 0.2506805268442114, 0.19591303974684293, 0.26978847729448097, 0.18295975440349443, 0.18926049484972685, 0.20435028917667675, 0.1890196380968997, 0.19240712364988255, 0.18016864697775303, 0.1830474397365902, 0.7624739738927527, 0.18665423958384908, 0.6463461780913264, 0.6204869613740133, 0.5557974512396084, 0.18034197856690048, 0.7192772690038128, 0.723661645561806, 0.20558997847797933, 0.20566284730054163, 0.1631537517383047, 0.6939608793605884, 0.3198792127150184, 0.2096925700853014, 0.20654685223193814, 0.2062983152392771, 0.1893009202470728, 0.1964067580597484, 0.18142446290276637, 0.20028273200059288, 0.20640024189861306, 0.1846302176264012, 0.2004553316708093, 0.18269250307024287, 0.1899364327555173, 0.07957124008159722, 0.07891634853810958, 0.08149687326205823, 0.08015786814116876, 0.08512382537546015, 0.08078192034892329, 0.09477767477684407, 0.08138338793012045, 0.07539865089832076]}, "mutation_prompt": null}
{"id": "d21339bb-7882-4b9a-b50e-429eaea3a4d3", "solution": "import numpy as np\n\nclass EMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"])\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"])\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    # Introduce adaptive update for cross_prob\n                    new_CR = self.cross_prob + 0.1 * (1 - self.cross_prob) * (np.random.rand() - 0.5)\n                    self.memory[\"CR\"][self.memory_index] = new_CR\n                    self.update_memory(F, new_CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EMDE", "description": "An Enhanced Memory-Based Differential Evolution (EMDE) algorithm that adaptively updates strategy parameters to balance exploration and exploitation.", "configspace": "", "generation": 6, "fitness": 0.3797573296721441, "feedback": "The algorithm EMDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.38 with standard deviation 0.26.", "error": "", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.7872460646126137, 0.8184001532669234, 0.8076100305058851, 0.8436216967871596, 0.7940579014597481, 0.8188727845056847, 0.8125517245437474, 0.8112713070210034, 0.8026125831867064, 0.6649662215834306, 0.672671279148872, 0.6567640412734045, 0.6822199235431025, 0.6642139275191115, 0.6666928620905441, 0.672369244518504, 0.6785222986570403, 0.678538587155366, 0.11969994929491601, 0.10995988150649849, 0.11355079907872201, 0.12201134385104906, 0.11614256359008301, 0.10291320264662684, 0.13346688011765218, 0.11001654302827213, 0.11897331540053713, 0.10347110184646424, 0.10691615181982306, 0.10645825747003723, 0.1059649999236304, 0.11232641302172375, 0.11298448567976904, 0.10875252865019591, 0.10246038606381136, 0.10805995878014474, 0.8236861268635565, 0.8921477419249952, 0.9303796271223452, 0.9277369398265836, 0.8260309373694792, 0.8001037964402313, 0.9349110697947212, 0.8852351992044074, 0.9712181535800493, 0.4806855036713905, 0.4977450407976056, 0.48660358499526535, 0.5158748581723345, 0.5122009272453047, 0.46647778719863187, 0.5554428834282372, 0.48481925624961353, 0.5460360122390455, 0.7790334999453125, 0.803953654502876, 0.7422425373432695, 0.7812394318432152, 0.8178931694346505, 0.7711268427332352, 0.8077846715947339, 0.831464855304814, 0.7810038508348127, 0.23966087546958748, 0.20860459292904177, 0.45584317133211094, 0.18722567760541287, 0.23905807910870402, 0.20712933719803373, 0.2395143954228851, 0.2711626690631638, 0.1813871158008845, 0.19770715589169852, 0.19848908867232806, 0.20938853510644662, 0.3326076151345445, 0.507749680394342, 0.341832303303376, 0.19272799995504086, 0.26402969373091567, 0.16726810626616806, 0.41380605142415805, 0.47635337646044595, 0.4935921164870236, 0.436762412872856, 0.444194030148243, 0.45444769806988694, 0.47378142276373425, 0.45016112859711477, 0.43165136491383704, 0.5563691567449172, 0.5855559834872208, 0.5959037834293179, 0.5738442675833254, 0.5673248405628365, 0.5351190002606566, 0.6035747422312966, 0.6134901017260984, 0.5962028424662895, 0.10811399310621406, 0.08239764785092252, 0.06989592801417244, 0.12751186454685537, 0.23937892140523287, 0.12180170200725038, 0.16277200363554023, 0.23612697806129224, 0.19473563534044114, 0.3571355197458719, 0.3339524371777809, 0.3472982900351551, 0.37501694696403653, 0.3351942389879946, 0.34324415079851445, 0.32869276183391904, 0.33310433806404194, 0.3299416090556747, 0.7209748219475588, 0.6915284551049644, 0.7575526814182614, 0.7129574704119289, 0.7183995083541524, 0.7350643555998617, 0.7440487029034344, 0.7048915507837747, 0.7296084872212791, 0.11619926823339188, 0.1297616470612113, 0.09673777695129737, 0.09205155831437406, 0.1042576936388998, 0.10286634605977052, 0.09756741727802054, 0.10994287482844034, 0.09853653821336172, 0.14659676030118496, 0.14537538372739167, 0.15148281722221968, 0.17995531598466663, 0.13538437029043182, 0.1437557074453485, 0.17080289697626416, 0.16997901635479284, 0.13589440609419268, 0.4035193347511201, 0.43029838334113923, 0.45481262721721927, 0.4459591201090354, 0.4139881595486311, 0.456406661009495, 0.4437696762783039, 0.4442722687120696, 0.4100569918579451, 0.36724415370050245, 0.3274593700698978, 0.3490273171613084, 0.3275582065401883, 0.3177786505305603, 0.34362737624768736, 0.3423832979141318, 0.32593268720462265, 0.35109882376293633, 0.19930713133544864, 0.20168905315568386, 0.19177344843001076, 0.19085988692562628, 0.1904708406923743, 0.18667121386655627, 0.218004380613532, 0.22383279770046938, 0.1981079874299907, 0.30502623629981074, 0.18852532466716698, 0.1950753972085819, 0.1952329717971225, 0.1888961365391758, 0.20798380503631064, 0.20609845369571167, 0.20751304465497566, 0.19848919191057346, 0.730467223926143, 0.5856754636367428, 0.15311460702429835, 0.15667702799532857, 0.6777572948470734, 0.188028345683817, 0.20143377602808588, 0.7911545881890262, 0.1595977193566872, 0.20590060379720976, 0.20455133842095996, 0.6311524036830507, 0.5930715709978569, 0.19900816582691327, 0.17910155561170682, 0.2092742595167516, 0.20889946347373867, 0.6505900647775638, 0.19335545748552074, 0.19558557180738845, 0.1927931969828932, 0.1984912776182528, 0.17908571970014087, 0.1860058677076868, 0.18914062686216127, 0.1820010256479645, 0.18469345515932212, 0.08667902234066538, 0.08361686554360426, 0.0766503958889505, 0.08387260753422032, 0.08185440630647267, 0.08156854863854346, 0.08549135572990418, 0.08285407370820197, 0.07721929303751063]}, "mutation_prompt": null}
{"id": "a553494e-b2e7-4b7f-ae9c-cf8a0eb53b98", "solution": "import numpy as np\n\nclass EAMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation with dynamic scaling factor strategy\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"]) * np.random.uniform(0.5, 1.0)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover with adaptive crossover probability\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"]) * np.random.uniform(0.8, 1.0)\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_memory(F, self.cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EAMDE", "description": "Enhanced Adaptive Memory-Based Differential Evolution (EAMDE) leveraging adaptive parameter tuning and dynamic population strategies for improved exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.07851208262998484, "feedback": "The algorithm EAMDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.2339630493044832, 0.24321360816648896, 0.23937661145419575, 0.10467234125791092, 0.33232987485378584, 0.15365277438054892, 0.1851825808528712, 0.17135610170329296, 0.16733656525244045, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05978242687651858, 0.06087356490116547, 0.04385683091978043, 0.05626646673545088, 0.06820519743123188, 0.04332477361293752, 0.06686997261294036, 0.05607087396856403, 0.04367688298597028, 0.03074726938385597, 0.045232613239705066, 0.04862421140421469, 0.05249345664053939, 0.03679035154331445, 0.032027530629507917, 0.03099891557304635, 0.03754267455683802, 0.0256718126365324, 0.09244321768505559, 0.0865946757411612, 0.10531290617873712, 0.10234457167295763, 0.07218143829521018, 0.1227645996188228, 0.07352028142618217, 0.07471627865053254, 0.11844019067536227, 0.05531711763398184, 0.019207351312659382, 0.008685284076449529, 0.054220776574163354, 9.999999999998899e-05, 0.036010657357623654, 0.04978963647701262, 0.037142482899647056, 0.06321035933197494, 0.09235527155599721, 0.10448618203185545, 0.06688433998884102, 0.1189661216494956, 0.10787533816095107, 0.1233381573546749, 0.10461907149500516, 0.07941147060375076, 0.08577984367742886, 9.999999999998899e-05, 9.999999999998899e-05, 0.007763407913856657, 9.999999999998899e-05, 0.013266645496168517, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009794439651676812, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0004295627889221443, 0.02529597764749647, 9.999999999998899e-05, 0.0019618912646570674, 0.011772607256412493, 0.07389919101986597, 9.999999999998899e-05, 0.04481627924727727, 0.056970506747964444, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.135345757922389, 0.1406105986665258, 0.17899277248234613, 0.18435516513484151, 0.22227890811057716, 0.13400408868607083, 0.17085863305378446, 0.20576623671530747, 0.21859051757915104, 0.03757608729268214, 0.04290873475299872, 0.03576361792016891, 0.024262227759089927, 0.019674320983297355, 0.05765303021869206, 0.031070794879180186, 0.03127536613585635, 0.05193865153411714, 0.09865582398106743, 0.10483168640069673, 0.16874522449098528, 0.0848233808609119, 0.09874891249450957, 0.09197819241316263, 0.10562933828058307, 0.09112880519856503, 0.1071761962325336, 0.14854751837674918, 0.17811942691749227, 0.1381039560733952, 0.19077139892122663, 0.15221592892892677, 0.16397732433744894, 0.1502270939756809, 0.20113774624735292, 0.19188072633720654, 0.09115766227532818, 0.11840768812817426, 0.09292016065032627, 0.14740319021440262, 0.0841287303348397, 0.13094464780875092, 0.09660257174411602, 0.11658210325074614, 0.13457166296339806, 0.1851183865422944, 0.12336809683900052, 0.15359416231987855, 0.13796347383703633, 0.15318354493095143, 0.18075118361827813, 0.13319549860793523, 0.1451814948148702, 0.19915009950461904, 9.999999999998899e-05, 0.1511324385175078, 0.15222336920851398, 0.14260532581196295, 0.1639438167423175, 0.046765207624042904, 0.15436878635621543, 0.09914988991365703, 0.08955325434307049, 0.1032193793769256, 0.11967688573766411, 0.14661528301695326, 0.1170547010607983, 0.16278124630054847, 0.07183222167573788, 0.11286532914787673, 0.16663226983720103, 0.1120837644021263, 0.13194473713130028, 0.07241046149608332, 0.09751388667925509, 0.08066906788466877, 0.15525703751382347, 0.08404071133528634, 0.07764797338261431, 0.22105037484522372, 0.09917714212915785, 0.19543008286443941, 0.16618822298386682, 0.17194514948362938, 0.16660814901175713, 0.14255602232128406, 0.1921412532760629, 0.1491553449086297, 0.1677811576704098, 0.1573795973596256, 0.07412533717158365, 0.06544862383844452, 0.06301741053424625, 0.06841862500962959, 0.054182236873807965, 0.08230742143279601, 0.039415901725365576, 0.042767880560304006, 0.03645085686183169]}, "mutation_prompt": null}
{"id": "eda44786-7c36-46c2-9b2d-776713159251", "solution": "import numpy as np\n\nclass DSAMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.1  # Small perturbation for local search\n        self.switch_prob = 0.5  # Probability to switch strategy\n\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Strategy selection\n                if np.random.rand() < self.switch_prob:\n                    # Global Mutation\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"])\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    # Local Mutation\n                    a = self.population[np.random.randint(self.population_size)]\n                    noise = self.epsilon * np.random.uniform(-1, 1, self.dim)\n                    mutant = np.clip(a + noise, self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"])\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_memory(F, self.cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "DSAMDE", "description": "A Dual-Strategy Adaptive Memory Differential Evolution (DSAMDE) algorithm that alternates between local and global search strategies based on adaptive metrics to enhance exploration and exploitation.", "configspace": "", "generation": 8, "fitness": 0.3396297671883668, "feedback": "The algorithm DSAMDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.24.", "error": "", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.765827339528397, 0.7677732638685577, 0.7438564832693817, 0.7593517950325451, 0.7536141044444211, 0.761527677130458, 0.7821970979726397, 0.7553833923589051, 0.7728849490537778, 0.4519223113371741, 0.44387357011516493, 0.5117835896242169, 0.4617533916346426, 0.4060388895574404, 0.42931124054599035, 0.4691168847111481, 0.4334561126353449, 0.41921203389030315, 0.19864616766079535, 0.1608280681872577, 0.16493725049926067, 0.2455084248300854, 0.17289340476404946, 0.15346307834732398, 0.3012886611090265, 0.16109839577827678, 0.17206228252393452, 0.1661971616628236, 0.11136786363936046, 0.13474737979446694, 0.14470856638708884, 0.15106874811357907, 0.0703263481414117, 0.12885779383786644, 0.13761083009518493, 0.13527655521116844, 0.8697331786034976, 0.8962623278916322, 0.9117884750603114, 0.9098445233913849, 0.9024464380847781, 0.8569493434049436, 0.9066238741918041, 0.8904575427683012, 0.9178502885943922, 0.299035222743096, 0.3698905743059895, 0.22608707830394992, 0.3400808748044387, 0.34521101798616094, 0.40578281428890806, 0.3550948229286759, 0.3259828398091057, 0.37354228395894173, 0.7938160487790299, 0.7859159407191907, 0.16731582306255133, 0.7911878083937004, 0.7330890437243021, 0.8488601934186544, 0.820595201917791, 0.8367544187718952, 0.8279248911988143, 0.1800417505496421, 0.21341405194515295, 0.24622717825557616, 0.1787152652733648, 0.20120935887083358, 0.17048478248964072, 0.18223321011800375, 0.12277235823350241, 0.21617881243603598, 0.38733413038675824, 0.21481767999386103, 0.12876181616804572, 0.1906379517526785, 0.18488631919571707, 0.22038775390683496, 0.23821882182481136, 0.2372771381789618, 0.2306206623137408, 0.23631186584821218, 0.24757649180173968, 0.11043030629396566, 0.16215723018041117, 0.22921060750312594, 0.10761313483268786, 0.2512388126710544, 0.22798891249758024, 0.17232519300364824, 0.33668703768598274, 0.3722881676835088, 0.36537601618609483, 0.34286701956851906, 0.33015583407369875, 0.4184485139109311, 0.3580106093195138, 0.35943514544720023, 0.36060225390305134, 0.06951393714077037, 0.09014129604288901, 0.0850133225712627, 0.10547973040364178, 0.11474924389427121, 0.13443602529041598, 0.06468719413138313, 0.11221865900874128, 0.07920319781499607, 0.2462818585892168, 0.22392583576707492, 0.23895205526310714, 0.2744294932176674, 0.23342748226739773, 0.22587662675941933, 0.21226807896157973, 0.22954265044696387, 0.23049204924063127, 0.6380057303266142, 0.6038272812606706, 0.6240103251665992, 0.616883348242931, 0.6145075215018102, 0.6091676829113805, 0.6113987241090159, 0.6240102601050852, 0.6175560395342395, 0.07249647306556894, 0.10901733932575042, 0.1790523089446555, 0.13889033444939047, 0.1284011185763293, 0.14684039585147768, 0.1373960841663755, 0.14874846899410044, 0.13594741281739975, 0.3448257793229096, 0.2088622250072253, 0.4481387870782748, 0.21625989313975602, 0.43527106301947516, 0.455465354747018, 0.21239872462835796, 0.31092984205155916, 0.2865263237146741, 0.36061772760162514, 0.3805048554697825, 0.376312066611186, 0.36472366575093074, 0.37866555436517646, 0.37934993613179735, 0.36753982006263763, 0.36528518517266917, 0.41640887086674605, 0.31717476950733026, 0.30991596197336324, 0.31142603570421923, 0.3233306872402084, 0.2684548271379724, 0.2982988595983317, 0.2781095615973208, 0.26402802581283646, 0.3093581872574934, 0.24312715631918358, 0.212499282948461, 0.22357336795099236, 0.2202724519936563, 0.22630226676956577, 0.22490316194388937, 0.2259554868650191, 0.23004417954483747, 0.21494549391132545, 0.20513270191459654, 0.24532099558828657, 0.23666981954248734, 0.24512582788054438, 0.21563291961597875, 0.19976103812698864, 0.21709874357825987, 0.21626463869157697, 0.24520636630419645, 0.18383493762222858, 0.8881273180186647, 0.7992532850187625, 0.8530590987642086, 0.8573763517387851, 0.16596632183451732, 0.1424754921790009, 0.8676909019057414, 0.12942710075207253, 0.21104331076509797, 0.2093350134828712, 0.1676270317980041, 0.6494631655070169, 0.2088208125347647, 0.19565106809603205, 0.20813086259914637, 0.8299991809983206, 0.21038263043616912, 0.18346575090238626, 0.19311049070462927, 0.18572943468744663, 0.19047955073896672, 0.20826603733819626, 0.20114893621894614, 0.18209028980565745, 0.19878284067476115, 0.19921371931139165, 0.09006001883512327, 0.08860731008269851, 0.09044686066456487, 0.08040515202982701, 0.08537269293246885, 0.10331100541226457, 0.08717215366028086, 0.11222974221142212, 0.09882357349944937]}, "mutation_prompt": null}
{"id": "ac76a660-e8cd-4c32-a67e-c94bdf2be569", "solution": "import numpy as np\n\nclass AMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"])\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"])\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_memory(F, self.cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AMDE", "description": "A novel Adaptive Memory-Based Differential Evolution (AMDE) algorithm incorporating adaptive memory of successful strategies to improve convergence and exploration.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.8115500630055854, 0.8030371915120872, 0.8236132102889899, 0.8295752000165022, 0.8115681813055129, 0.8191526329420882, 0.8123283348737662, 0.8076847606139985, 0.8206596387107614, 0.6642973379833338, 0.6640755633942357, 0.6835421191567106, 0.665682257565863, 0.6730416792268539, 0.6543221905965906, 0.6774389869779706, 0.6613196571948083, 0.6479197620046944, 0.10677071759504142, 0.1080923565239924, 0.13554782840820956, 0.13749347300221182, 0.11949278428502697, 0.11188568485511718, 0.11108592750728985, 0.12182523958442837, 0.12574858177849035, 0.08935078555914167, 0.09792139755365714, 0.11652790325605289, 0.10784367232134118, 0.10116032624688653, 0.09860010624020255, 0.10209213141328566, 0.10448160819359331, 0.1204943296122698, 0.9262934070784081, 0.9140850777174927, 0.9094047583168681, 0.8033305902854314, 0.9392146679393096, 0.944081729088408, 0.9104611076610913, 0.9130909574642111, 0.9454552275767137, 0.48317040918996645, 0.4892869459211795, 0.5255738888385427, 0.46097786624327086, 0.4944876662930493, 0.5443389311637407, 0.48228919749452903, 0.49014832957046617, 0.4576804569268955, 0.7757543938976739, 0.7675024925166722, 0.7571656500575393, 0.8161255412238769, 0.7772039833666851, 0.7358436393087185, 0.7681123629755248, 0.7841879475655216, 0.7742001808849447, 0.20416951507008518, 0.2678423363633903, 0.20132988751390357, 0.1939181466030514, 0.1835225304586311, 0.22323484068628663, 0.2523098777748771, 0.39129113963333906, 0.30800699981537494, 0.29355754518229993, 0.21649566290841638, 0.18025328969310794, 0.31778092741063313, 0.24851553071619237, 0.4092403744299843, 0.18835094367315608, 0.19521126015478474, 0.17318804494649154, 0.48267437989996353, 0.44932567552194036, 0.4255680433841166, 0.46077221331204277, 0.3622205036929246, 0.4249610973391945, 0.4329010314136008, 0.42583866749156873, 0.4317407831389328, 0.5691586321222184, 0.5841265606874193, 0.6128056373856061, 0.5052953845641596, 0.5360352425460094, 0.6098520910866504, 0.625003224300633, 0.6304491620004309, 0.5962534516966507, 0.1340762360906299, 0.08289273224468707, 0.14390780423494054, 0.32771099777439716, 0.17662405327673225, 0.2104568486550329, 0.2267797398841115, 0.24524871034009432, 0.23779720330419873, 0.34409870511065777, 0.32284796390849013, 0.33574287830237526, 0.33540603728787566, 0.3329576966108805, 0.3148112467729627, 0.36199120346929337, 0.3387380288318209, 0.3401176674225078, 0.7293304482093885, 0.7040238362655575, 0.7369095523436611, 0.7120980518932297, 0.7014516475511581, 0.7119330851400771, 0.7171993726366986, 0.7231683148501018, 0.7313298309450622, 0.10788563856928557, 0.10138667536092383, 0.09775742103389073, 0.11498265021010667, 0.09330058781380923, 0.10817634619220895, 0.10134166830227931, 0.09933463552275934, 0.10958521611742122, 0.1354851141788287, 0.14098782387380993, 0.1524127347187232, 0.14385405151326613, 0.21708964750592252, 0.1623845603640539, 0.29954594030810067, 0.1298781603402427, 0.12661437324070557, 0.4385415278300935, 0.43371812634821283, 0.4120065423623517, 0.4133734721449511, 0.412150761860823, 0.4215924794934863, 0.44387745954321967, 0.4901816366616193, 0.4639847899741417, 0.3405419270519575, 0.3304375120070011, 0.38348272478993173, 0.3076797383751395, 0.3479892635229197, 0.30716626221003307, 0.33415150092590296, 0.3730429010687232, 0.33319583176188294, 0.18304942078735875, 0.196309878469488, 0.20393141687966265, 0.18663824625004577, 0.2038907321337341, 0.2110471318921916, 0.21320493504789173, 0.19481226426459586, 0.21105399049952056, 0.2680842674940558, 0.20574377516068976, 0.18366019524208643, 0.19195350310661574, 0.33554830220833354, 0.2034837757650193, 0.18912127502333342, 0.19116290122244117, 0.18297132585082265, 0.7336076935002311, 0.14704264063745687, 0.7728263306927248, 0.6939487202129796, 0.1615988108045081, 0.17789326045592535, 0.6623752878388777, 0.17650164592702167, 0.6612361335370914, 0.16318429415618996, 0.7480789144349956, 0.2030212864578671, 0.7201427912133928, 0.5949411191948639, 0.6288879066993356, 0.20361602949518032, 0.7917051173010317, 0.15407765191403655, 0.18481838665884598, 0.18718203069013462, 0.1920440451807709, 0.18942506748445576, 0.1835470837323876, 0.19465840946629098, 0.18632628875556834, 0.2054447165642277, 0.18342881063556815, 0.07939980852653494, 0.08299944699872086, 0.07142870737390472, 0.08909994222987971, 0.0723743447747831, 0.07670402732812309, 0.08859915557387432, 0.0887049860977549, 0.07758152444732025]}, "mutation_prompt": null}
{"id": "503b9e91-a725-4b93-a0c4-ca92a340c479", "solution": "import numpy as np\n\nclass DPCDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob_base = 0.7\n        self.F_base = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F_base),\n            \"CR\": np.full(self.memory_size, self.cross_prob_base)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        adaptive_rate = 0.1\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"]) + np.random.uniform(-adaptive_rate, adaptive_rate)\n                F = np.clip(F, 0.1, 0.9)\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_prob = np.random.choice(self.memory[\"CR\"]) + np.random.uniform(-adaptive_rate, adaptive_rate)\n                cross_prob = np.clip(cross_prob, 0.5, 1.0)\n                cross_points = np.random.rand(self.dim) < cross_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_memory(F, cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "DPCDE", "description": "A Dynamic Parameter Control Differential Evolution (DPCDE) leveraging adaptive and dynamic parameter tuning for improved exploration and convergence.", "configspace": "", "generation": 10, "fitness": 0.3443285042735614, "feedback": "The algorithm DPCDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.25.", "error": "", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.8453396121650375, 0.8396752644314032, 0.8322938044751287, 0.8185976599701131, 0.8292341663390096, 0.8588594128294709, 0.8471815499853441, 0.8495158762351642, 0.831709537863089, 0.7008079457453205, 0.7451328364521019, 0.7492237540441521, 0.7414279744819627, 0.7157070896383595, 0.746135720788609, 0.7472683984688739, 0.6729735871319069, 0.7092485668155317, 0.17365407342610284, 0.22480444033870528, 0.1821146579184112, 0.6312885495876097, 0.4790075483688725, 0.5773883438521894, 0.6239915730979926, 0.5674613261826638, 0.5971405571012482, 0.13614721828765264, 0.16916263308960167, 0.15097424014035732, 0.13607764817926382, 0.1473486690837863, 0.5074944412778765, 0.15092762136116766, 0.27736501977039585, 0.17858965604988952, 0.9693762133155253, 0.9266474865521849, 0.9443479345777992, 0.9616895685817674, 0.9526559938404632, 0.8919489437562614, 0.964935405826228, 0.8639538323078736, 0.8906139309994969, 0.22357931844123746, 0.2773697733749523, 0.30350297215566424, 0.1884996971136471, 0.21990359655810932, 0.2566035747073111, 0.1313984100754949, 0.3016566036355153, 0.27997191352279427, 0.3453113074814155, 0.32701642909251183, 0.25007539930455824, 0.2584959766135775, 0.883012886683333, 0.27148096123062926, 0.8112404024192046, 0.35238217626895385, 0.8421619468432516, 0.1555152737946648, 0.16496785229520405, 0.12400536649451865, 0.1215379648544469, 0.18514617030520464, 0.015399100881632544, 0.46469387862167677, 0.19962166034945616, 0.18370575417397028, 0.14309715576475301, 0.11964040598591053, 0.13112852397639985, 0.13158272324454123, 0.1497602391994819, 0.14308532743233315, 0.13455752361690554, 0.14336327718069186, 0.14782024597951093, 0.20533557370045208, 0.29405672979543573, 0.2339954355793855, 0.016336081035809413, 0.09819237316688345, 0.220594741161242, 0.04228655403294668, 0.045980504520262366, 0.11645016714683643, 0.6045870339235778, 0.22436386219175475, 0.24007277706076546, 0.1479305234480629, 0.46601676859742025, 0.3347875846739662, 0.6420536358290887, 0.19950711791664255, 0.25730080636465236, 0.13482443856344162, 0.07589728273285035, 0.1023833636867123, 0.10694859162156567, 0.08293945298355698, 0.2167767241452987, 0.1509799540326512, 0.07873275395375945, 0.15653111998402747, 0.1676937527997845, 0.3005328752815605, 0.1473933900455464, 0.31355660840596, 0.2739592266632811, 0.2567613462529831, 0.1916033568692781, 0.3331851550700039, 0.24920083337147592, 0.5486493855741927, 0.6455901133741189, 0.5629559263090262, 0.4863587765836328, 0.4969129153784816, 0.7096689871074573, 0.5047474296510852, 0.7372867643212218, 0.6356128281627578, 0.1313676458638231, 0.13077933192230107, 0.1065648119496917, 0.14844576665826348, 0.13394552545103722, 0.1281731925304661, 0.13742438504348542, 0.12555998585851214, 0.132763820176513, 0.19236012114404188, 0.2106320208925968, 0.18500260833028148, 0.21246224360821164, 0.12724289456488802, 0.23107342925360042, 0.3105132781665113, 0.3564868965842741, 0.13860209216525166, 0.45682313440020317, 0.2621409550492907, 0.41842207993642744, 0.5414848883853416, 0.494686476415913, 0.5452569021096658, 0.4129485237656386, 0.4855787839329929, 0.4102108642578315, 0.2079783008021978, 0.3066812292340565, 0.3263281883034095, 0.3827560496472182, 0.33831554531460184, 0.2791516616631393, 0.36609599168522255, 0.4068946515467833, 0.43825656751264963, 0.20638393808136768, 0.20225357399357535, 0.20514176353451608, 0.20279845806063845, 0.2033527624443795, 0.20265012658958315, 0.20078849948668476, 0.19496054914432748, 0.23320282178566976, 0.6718005032986911, 0.215604903343927, 0.6456867579926704, 0.6714150294951007, 0.7542360122578029, 0.2435764179766533, 0.21210985396548931, 0.22881552472618782, 0.24130845434564396, 0.1693899174346648, 0.16686792611087986, 0.18492479356572866, 0.18973546114984396, 0.4211344851696175, 0.650691070242813, 0.7744159101654907, 0.18554789089835444, 0.20906277970896292, 0.3143654998735118, 0.16396260511390992, 0.15113532633802684, 0.17571895474394894, 0.16336916627451015, 0.5694454735959991, 0.2084085005464068, 0.3127377068867295, 0.1671649968774498, 0.1819280692308095, 0.17403552961197133, 0.18025190185854068, 0.1896067065924787, 0.18353520144050006, 0.2037352620927395, 0.19091683584426078, 0.17802606644468144, 0.18678347150188257, 0.09188331026274721, 0.0824413449783169, 0.09416617381263437, 0.08835486055818653, 0.08960141793507514, 0.07585916872368781, 0.0847363051133696, 0.08176812507926112, 0.08648821518570604]}, "mutation_prompt": null}
{"id": "33818853-4b68-48c4-b885-14f124c619a2", "solution": "import numpy as np\n\nclass AMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        \n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"])\n                mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"])\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    self.update_memory(F, self.cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AMDE", "description": "A novel Adaptive Memory-Based Differential Evolution (AMDE) algorithm incorporating adaptive memory of successful strategies to improve convergence and exploration.", "configspace": "", "generation": 1, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.8115500630055854, 0.8030371915120872, 0.8236132102889899, 0.8295752000165022, 0.8115681813055129, 0.8191526329420882, 0.8123283348737662, 0.8076847606139985, 0.8206596387107614, 0.6642973379833338, 0.6640755633942357, 0.6835421191567106, 0.665682257565863, 0.6730416792268539, 0.6543221905965906, 0.6774389869779706, 0.6613196571948083, 0.6479197620046944, 0.10677071759504142, 0.1080923565239924, 0.13554782840820956, 0.13749347300221182, 0.11949278428502697, 0.11188568485511718, 0.11108592750728985, 0.12182523958442837, 0.12574858177849035, 0.08935078555914167, 0.09792139755365714, 0.11652790325605289, 0.10784367232134118, 0.10116032624688653, 0.09860010624020255, 0.10209213141328566, 0.10448160819359331, 0.1204943296122698, 0.9262934070784081, 0.9140850777174927, 0.9094047583168681, 0.8033305902854314, 0.9392146679393096, 0.944081729088408, 0.9104611076610913, 0.9130909574642111, 0.9454552275767137, 0.48317040918996645, 0.4892869459211795, 0.5255738888385427, 0.46097786624327086, 0.4944876662930493, 0.5443389311637407, 0.48228919749452903, 0.49014832957046617, 0.4576804569268955, 0.7757543938976739, 0.7675024925166722, 0.7571656500575393, 0.8161255412238769, 0.7772039833666851, 0.7358436393087185, 0.7681123629755248, 0.7841879475655216, 0.7742001808849447, 0.20416951507008518, 0.2678423363633903, 0.20132988751390357, 0.1939181466030514, 0.1835225304586311, 0.22323484068628663, 0.2523098777748771, 0.39129113963333906, 0.30800699981537494, 0.29355754518229993, 0.21649566290841638, 0.18025328969310794, 0.31778092741063313, 0.24851553071619237, 0.4092403744299843, 0.18835094367315608, 0.19521126015478474, 0.17318804494649154, 0.48267437989996353, 0.44932567552194036, 0.4255680433841166, 0.46077221331204277, 0.3622205036929246, 0.4249610973391945, 0.4329010314136008, 0.42583866749156873, 0.4317407831389328, 0.5691586321222184, 0.5841265606874193, 0.6128056373856061, 0.5052953845641596, 0.5360352425460094, 0.6098520910866504, 0.625003224300633, 0.6304491620004309, 0.5962534516966507, 0.1340762360906299, 0.08289273224468707, 0.14390780423494054, 0.32771099777439716, 0.17662405327673225, 0.2104568486550329, 0.2267797398841115, 0.24524871034009432, 0.23779720330419873, 0.34409870511065777, 0.32284796390849013, 0.33574287830237526, 0.33540603728787566, 0.3329576966108805, 0.3148112467729627, 0.36199120346929337, 0.3387380288318209, 0.3401176674225078, 0.7293304482093885, 0.7040238362655575, 0.7369095523436611, 0.7120980518932297, 0.7014516475511581, 0.7119330851400771, 0.7171993726366986, 0.7231683148501018, 0.7313298309450622, 0.10788563856928557, 0.10138667536092383, 0.09775742103389073, 0.11498265021010667, 0.09330058781380923, 0.10817634619220895, 0.10134166830227931, 0.09933463552275934, 0.10958521611742122, 0.1354851141788287, 0.14098782387380993, 0.1524127347187232, 0.14385405151326613, 0.21708964750592252, 0.1623845603640539, 0.29954594030810067, 0.1298781603402427, 0.12661437324070557, 0.4385415278300935, 0.43371812634821283, 0.4120065423623517, 0.4133734721449511, 0.412150761860823, 0.4215924794934863, 0.44387745954321967, 0.4901816366616193, 0.4639847899741417, 0.3405419270519575, 0.3304375120070011, 0.38348272478993173, 0.3076797383751395, 0.3479892635229197, 0.30716626221003307, 0.33415150092590296, 0.3730429010687232, 0.33319583176188294, 0.18304942078735875, 0.196309878469488, 0.20393141687966265, 0.18663824625004577, 0.2038907321337341, 0.2110471318921916, 0.21320493504789173, 0.19481226426459586, 0.21105399049952056, 0.2680842674940558, 0.20574377516068976, 0.18366019524208643, 0.19195350310661574, 0.33554830220833354, 0.2034837757650193, 0.18912127502333342, 0.19116290122244117, 0.18297132585082265, 0.7336076935002311, 0.14704264063745687, 0.7728263306927248, 0.6939487202129796, 0.1615988108045081, 0.17789326045592535, 0.6623752878388777, 0.17650164592702167, 0.6612361335370914, 0.16318429415618996, 0.7480789144349956, 0.2030212864578671, 0.7201427912133928, 0.5949411191948639, 0.6288879066993356, 0.20361602949518032, 0.7917051173010317, 0.15407765191403655, 0.18481838665884598, 0.18718203069013462, 0.1920440451807709, 0.18942506748445576, 0.1835470837323876, 0.19465840946629098, 0.18632628875556834, 0.2054447165642277, 0.18342881063556815, 0.07939980852653494, 0.08299944699872086, 0.07142870737390472, 0.08909994222987971, 0.0723743447747831, 0.07670402732812309, 0.08859915557387432, 0.0887049860977549, 0.07758152444732025]}, "mutation_prompt": null}
{"id": "c117328c-ec67-4e5e-976b-23e425abf773", "solution": "import numpy as np\n\nclass PADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"])\n                    mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"])\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"])\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if np.random.rand() < 0.5:  # Probabilistically update memory with successful params\n                        self.update_memory(F, self.cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "PADE", "description": "A Probabilistic Adaptive Differential Evolution (PADE) leveraging stochastic adjustments and successful strategies for enhanced exploration and convergence.", "configspace": "", "generation": 12, "fitness": 0.41266319476990804, "feedback": "The algorithm PADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "03238acb-95b1-45cb-9150-30ce442d55f5", "metadata": {"aucs": [0.8465999661754587, 0.8420025646561652, 0.8584958415291646, 0.8474746637586593, 0.8426794758442523, 0.8568671169955323, 0.8539494947760615, 0.8455308154198837, 0.8463378772783352, 0.7403978224648038, 0.7401404378926625, 0.739833874751817, 0.7182963605159458, 0.7162278903577368, 0.7251391415161683, 0.7339636240989464, 0.7422577614042021, 0.7330216682648574, 0.13826334718275024, 0.13032140491157007, 0.1372918213393014, 0.1324246463684372, 0.1228889193214705, 0.13286973537691626, 0.12167441300823045, 0.1344643420224435, 0.14851000514669865, 0.11593977576342152, 0.11260208705939345, 0.11941314129102609, 0.11745364133736524, 0.10584727667449312, 0.11883098082401633, 0.12035307720395882, 0.10914468882584283, 0.1187713732925455, 0.823509992604055, 0.8913882809635248, 0.8386538525864433, 0.7413254915258013, 0.6905803594204413, 0.9034042518038008, 0.9939695164766668, 0.9658182244864203, 0.8837731473137481, 0.36969131562574586, 0.5551422257647356, 0.45717631656827684, 0.25985638241129405, 0.4947087457349947, 0.4282621584826115, 0.3229615688199181, 0.38818398638847484, 0.34917010831116646, 0.7103282996174929, 0.8181125108838605, 0.8155114485398345, 0.8407506066645087, 0.85619834897327, 0.8335243496302774, 0.8325962666101271, 0.8451248659385489, 0.8332931295107517, 0.1610763189583806, 0.16461586203763146, 0.24494761528246412, 0.18854574850219252, 0.21311197557435502, 0.20336787385069344, 0.18753898369802013, 0.25736668212607783, 0.16710072703264445, 0.28346656818643046, 0.22938277040217214, 0.21167862691987083, 0.1544415517771367, 0.184769747986, 0.18840561235745545, 0.20390845405572167, 0.27169855079737093, 0.19247868474799068, 0.5597646212981717, 0.41964683495193544, 0.5705344569496271, 0.5776089887593696, 0.5605128350115443, 0.5374781983629342, 0.5697804716898875, 0.5816840233868021, 0.6237686104710505, 0.6800257969034472, 0.6506875265404487, 0.7059974024207396, 0.6704402521433186, 0.6490861692909684, 0.6568619640567306, 0.6623184887098538, 0.6647599421619252, 0.6545356056380961, 0.2682149404766756, 0.1633395783070919, 0.29132967784785524, 0.2618799799338388, 0.39483243263359447, 0.2279708803350705, 0.19290011703595977, 0.155917388859108, 0.18514959304775613, 0.4593558860468605, 0.47973238263452944, 0.43138704943569584, 0.4648363392876589, 0.28881826605463823, 0.4595727025859253, 0.3886514053366634, 0.4002748589815034, 0.44275877741777414, 0.782092467821836, 0.7800296133140306, 0.782029994236044, 0.7563277422313124, 0.7823987658574572, 0.8018818625818275, 0.7720809475846747, 0.7878697146480825, 0.7793298085263065, 0.12291179303825595, 0.11439873797895195, 0.1398567457734794, 0.11022354447653526, 0.1068529322005024, 0.1177494973434865, 0.11806332571803124, 0.11911698300116591, 0.09511145997722814, 0.1358213929416201, 0.11989739724369608, 0.14810450991520951, 0.15201974118196793, 0.13097690028135134, 0.14173921325992722, 0.1371049382311197, 0.1414179041793826, 0.14243984282100242, 0.47718125306246606, 0.5230669537206238, 0.49577998674074086, 0.4994549159552055, 0.5825525978604692, 0.5374640789821472, 0.534618774783741, 0.572050415423933, 0.5348506834868414, 0.3716630304518276, 0.43768208553958554, 0.38006210049287037, 0.3999905642640337, 0.4162039836788942, 0.39164316055989457, 0.3825053599586027, 0.4030118461411808, 0.395868988868571, 0.21690638427946618, 0.21825602389442855, 0.20655935474540277, 0.20874135203502509, 0.20230240164660018, 0.21132331819611283, 0.20061326639515975, 0.1979853787893826, 0.20738172244755115, 0.19393249961444736, 0.19576585512403533, 0.2116301733995315, 0.19109001253503544, 0.19324164361130192, 0.1912893106589013, 0.20507202650927592, 0.20453657636324518, 0.20127829129768693, 0.19658426422374276, 0.18349233207571647, 0.18184824876389627, 0.772955518996771, 0.1918223735677419, 0.7618690703148261, 0.7627611214338477, 0.7978301415161095, 0.6469829484828102, 0.7790537235506776, 0.8258325962193807, 0.6964334841191724, 0.7270638753920943, 0.44037688404672626, 0.20366281932451913, 0.20859431531199457, 0.8565434207569652, 0.20354939545496553, 0.1884355512161685, 0.1914354650012885, 0.2000046528773206, 0.1931802439442718, 0.19946456042185012, 0.2014694740955134, 0.1891813680080877, 0.1889925004100258, 0.19843932823833543, 0.08352516259238851, 0.09033311004270894, 0.07982562800288617, 0.08080913302898662, 0.09018416498433346, 0.09096305522931547, 0.08304019740473068, 0.07762090808228872, 0.09007125968397744]}, "mutation_prompt": null}
{"id": "91b837ce-5b37-4add-ad9a-75eaea8e11d1", "solution": "import numpy as np\n\nclass PADEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F_base = 0.5\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F_base),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation with dynamic probability\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"])\n                    mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"])\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Adaptive Crossover\n                adaptive_CR = np.random.rand() * 0.2 + np.random.choice(self.memory[\"CR\"])  # Slightly randomize CR\n                cross_points = np.random.rand(self.dim) < adaptive_CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if np.random.rand() < 0.5:  # Probabilistically update memory with successful params\n                        self.update_memory(F, adaptive_CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "PADEPlus", "description": "A Probabilistic Adaptive Differential Evolution (PADE+) integrating randomized exploration strategies and adaptive update rules for improved solution quality and convergence efficiency.", "configspace": "", "generation": 13, "fitness": 0.40957887259367576, "feedback": "The algorithm PADEPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.29.", "error": "", "parent_id": "c117328c-ec67-4e5e-976b-23e425abf773", "metadata": {"aucs": [0.8647185591638278, 0.8636202849077053, 0.8678835594220258, 0.8791820366642308, 0.489057214091832, 0.860405364832165, 0.8599815239824832, 0.8611233646645426, 0.36012372737261844, 0.7230120447163002, 0.21067209765791817, 0.7584035863768337, 0.7408222267532115, 0.7717045858847994, 0.7335115848843908, 0.7052317484989803, 0.7726705475554514, 0.7381500142397737, 0.11494564830036758, 0.11482700441581295, 0.0863266891892086, 0.11923620294250836, 0.10723671177152372, 0.13591541133997276, 0.10539442182222969, 0.11608358283997566, 0.291413065400312, 0.10096189873631789, 0.11402394381375747, 0.09107084295939916, 0.09475098914279623, 0.10103831388224227, 0.10798256572009579, 0.1288927836453878, 0.1212170177610733, 0.10389463497075613, 0.08364090808604019, 0.08913595532214735, 0.07433486668513911, 0.07324398871798243, 0.09437735242293743, 0.10287376764601863, 0.07132915935935558, 0.38669325007295974, 0.9797255387947734, 0.0675330371662567, 0.26057289837947195, 0.21659492742542086, 0.17069048608253234, 0.30355248125591683, 0.15776727626595743, 0.187342975782663, 0.18157812037129362, 0.14988345644258028, 0.8758855268709913, 0.8847657076015991, 0.8598139656068265, 0.8876558832182714, 0.8830869860765984, 0.8405524318682347, 0.8665896077274942, 0.8777057527431142, 0.8799294614521017, 0.352019790424713, 0.16365217010013855, 0.179478589751642, 0.19447327306390305, 0.4442959771433408, 0.1487039809384072, 0.236337603146493, 0.2680423761438079, 0.15573727849599983, 0.17113899821234935, 0.1437826709268316, 0.21264579915776294, 0.19414482610312833, 0.18725608477882683, 0.2617604022773409, 0.2121132572186455, 0.20013543993421035, 0.2814741889759149, 0.735965920420532, 0.7400126688040267, 0.7528716375358853, 0.758229891032587, 0.737649505893051, 0.7134667374515326, 0.7559874248835489, 0.7282900675779509, 0.7497179898365269, 0.784577281064851, 0.7977520312724287, 0.816057001953544, 0.7901228324369207, 0.8035255934188467, 0.8090264634609192, 0.8009683935088775, 0.8078244203076603, 0.8029074739155484, 0.09129900695812154, 0.15863203897901335, 0.21802679111398737, 0.664045559651927, 0.6535845645729281, 0.29538411612453885, 0.2445702179296212, 0.2498273273186954, 0.14515378516397337, 0.6519011237228843, 0.6471568638308682, 0.6367561111429869, 0.6430533409377069, 0.6377634264518268, 0.6515145081908351, 9.999999999998899e-05, 0.6168834124049771, 0.6223945676549063, 0.7416131877056025, 0.8318414500700589, 0.836196619040838, 0.8210162689014305, 0.8235293169353157, 0.8271396338671744, 0.8630839890009754, 0.8426975338808683, 0.8441158886287052, 0.13570199329962396, 0.11760055847400597, 0.11545327492231572, 0.12340599097606952, 0.10509879454547677, 0.29936043994018113, 0.14472383207252493, 0.12167934812106052, 0.14542243659711473, 0.16440801100291558, 0.22558470250160922, 0.5476807752410328, 0.17779577407016878, 0.13662657030557623, 0.15544308463738488, 0.1660716647139301, 0.3209777485388472, 0.20010633569410707, 0.5523950069514605, 0.5841809424513696, 0.5792907881401121, 0.611774260733757, 0.5748198891100522, 0.6224955596539357, 0.6207534790280894, 0.5693173618352738, 0.5404347086966907, 0.5375584890210828, 0.5405456803140323, 0.48292356401052006, 0.5488709026017934, 0.5166189397443287, 0.5783689650987548, 0.5246993398566949, 0.5014215700985956, 0.5445708310842207, 0.23575043953106023, 0.2089676192703629, 0.21218280151257973, 0.2210275711881602, 0.19953319875472875, 0.20539800941232267, 0.21485977212515728, 0.19678592876864853, 0.21994091831897877, 0.19737908334346288, 0.1992855255315441, 0.38547780459011716, 0.20689788646447838, 0.23156683599263006, 0.3582532411478069, 0.19511391120107924, 0.21815884787599327, 0.21084335343929184, 0.1663492287358167, 0.8951982431066218, 0.17949293745259698, 0.380492998929605, 0.16490063573306157, 0.8021659051166796, 0.4309611005575166, 0.48497842328957863, 0.8260023028706841, 0.8253494340025446, 0.20900507533268275, 0.08242006902088361, 0.1674941516739189, 0.20372980590018464, 0.8611993260598725, 0.8291540394639634, 0.6621245995691287, 0.20870888334045568, 0.21438684082303838, 0.18462809103779865, 0.1920375833071185, 0.21222688192570927, 0.20084742633999608, 0.20787272427843706, 0.23184073096998137, 0.20543179040668524, 0.21140212692439286, 0.08647163781929557, 0.08579960792618291, 0.09141711421199283, 0.0867298176251754, 0.0900821573989733, 0.09229281068304862, 0.09447479817662097, 0.08817123363669177, 0.08782332251694702]}, "mutation_prompt": null}
{"id": "bd0c6c9c-7a86-482d-ad1b-c418065c170b", "solution": "import numpy as np\n\nclass AQIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def quantum_mutation(self, base, a, b, c, F):\n        # Quantum-inspired mutation strategy\n        u = np.random.uniform(size=self.dim)\n        return np.clip(base + F * (a - b) + u * (b - c), self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                base, a, b = self.population[indices]\n                F = np.random.choice(self.memory[\"F\"])\n\n                if np.random.rand() < 0.3:\n                    mutant = self.quantum_mutation(base, a, b, self.population[i], F)\n                else:\n                    mutant = np.clip(base + F * (a - b), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"])\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if np.random.rand() < 0.5:  # Probabilistically update memory with successful params\n                        self.update_memory(F, self.cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AQIDE", "description": "Adaptive Quantum-inspired Differential Evolution (AQIDE) utilizing quantum-based mutation strategies and dynamic parameter tuning for improved optimization performance.", "configspace": "", "generation": 14, "fitness": 0.3589778180025923, "feedback": "The algorithm AQIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.25.", "error": "", "parent_id": "c117328c-ec67-4e5e-976b-23e425abf773", "metadata": {"aucs": [0.7979444226641391, 0.7970470662639595, 0.7986052025145041, 0.8097757944894795, 0.818272970282272, 0.8110807182987179, 0.8060175805152687, 0.7866558890277753, 0.8070359340327714, 0.6478202559320788, 0.638824253784066, 0.6302514826283501, 0.6437364668569254, 0.662057262444228, 0.65633335507382, 0.6551400494770991, 0.6591975067139806, 0.667728912444681, 0.11013626632531437, 0.12466355864420042, 0.11306921941699188, 0.11397175045484287, 0.1309090404556733, 0.1251019791820851, 0.14004342731607433, 0.10236391076512719, 0.10674631254376676, 0.09371653890089204, 0.09561332249343957, 0.11933942487913629, 0.11080624957294671, 0.11105362213727188, 0.11144676487787075, 0.11123501425861537, 0.09550808510749864, 0.10870131417065154, 0.9275663835439348, 0.8787627408357835, 0.896381464412422, 0.95279480733189, 0.8879173461253766, 0.9411260713319004, 0.9031793647728587, 0.9616775181854804, 0.881263901686336, 0.4696154896449636, 0.45324577893235884, 0.5013602314646608, 0.47568845512699864, 0.4793342381393745, 0.5085246539645367, 0.4585840047721734, 0.5029994754652054, 0.48437476144176494, 0.7675077898251955, 0.745718394185951, 0.745772884463101, 0.7572107148838109, 0.7290601142442623, 0.7384560037805634, 0.722770362486924, 0.7496424946855873, 0.7594240739207655, 0.26038370340304506, 0.2381480136068379, 0.18072041559580343, 0.21999500481148593, 0.2172975264181679, 0.2251117895336726, 0.27971871042007324, 0.3125965109358344, 0.23623561411955052, 0.19695952966238162, 0.19988105578477622, 0.33213735432945457, 0.2264583079072433, 0.20951273480134436, 0.26667078196730776, 0.18891317994083556, 0.25725979609771843, 0.349980648088693, 0.28704945312741503, 0.3144366305984869, 0.32819525084415513, 0.25919943053604644, 0.25516410316968974, 0.2777472601397193, 0.22167955564183472, 0.28097627968091377, 0.2560334317763242, 0.4331860017713842, 0.3860572366752397, 0.3754830989184945, 0.3876880055992842, 0.42202848456246433, 0.3597882097074696, 0.4725160436372192, 0.480409994475684, 0.43702242381435774, 0.14715279488800648, 0.13665235532982445, 0.124403362126558, 0.22472825282924613, 0.15014514578777272, 0.144561300662286, 0.1626125583101491, 0.12818821322597485, 0.09895280489878644, 0.2468419797660154, 0.24360789822788365, 0.2594112753287182, 0.2716952320056868, 0.28802406226149835, 0.27455845910598, 0.2609567930768526, 0.258658284677609, 0.27288924575668694, 0.6582772610513767, 0.6873097079025196, 0.6492163514899546, 0.6929700933453427, 0.6577570504769863, 0.6528078260878272, 0.6440887800789996, 0.6552630777744812, 0.6599854833640577, 0.10042119857368548, 0.10411244668977049, 0.0987765178516411, 0.09049012896144137, 0.09965262687222964, 0.0994814889934389, 0.09239413364944338, 0.10445139146688975, 0.08880067016699145, 0.15532974856257864, 0.1464801813904233, 0.15108440229483966, 0.14995463482952365, 0.15381459896450833, 0.19698193784450846, 0.15559655588674248, 0.13406603649486737, 0.15588438076486022, 0.37702873805831283, 0.4050180814448294, 0.39884823308574147, 0.3769391424370453, 0.39098152907237227, 0.4185269086835075, 0.39638070535248104, 0.42831052913759826, 0.4083021642644108, 0.30458705615392956, 0.29853857621732227, 0.30946655258546885, 0.26098606938127555, 0.26732850113799855, 0.26547410795533477, 0.3374118141398197, 0.3092162035257564, 0.3123764762863309, 0.19897274063269454, 0.192794461940492, 0.18731078791940015, 0.21059286177987369, 0.20436299612332687, 0.19140474999138146, 0.1890562087611921, 0.19857882505857372, 0.20948546012168556, 0.2358554618725215, 0.19999155099725485, 0.19976573147568477, 0.19500496298076997, 0.20041129198596153, 0.19296548594416119, 0.20109603014275534, 0.19864409925625426, 0.17541568704402166, 0.5291952825942539, 0.7045281189002777, 0.16372959487153016, 0.18269849160833862, 0.6107092872794492, 0.17933313512451765, 0.5985114934027309, 0.7228094213695091, 0.6185743931908654, 0.20103365846008214, 0.20486727579700426, 0.19289944129819236, 0.6482370617738988, 0.6966312426260963, 0.5477299248858033, 0.2048851131058571, 0.6642419135206735, 0.6250602708015993, 0.18695379699647718, 0.1820986318802147, 0.17640348857312438, 0.19223847040928121, 0.1789360518454789, 0.20041270680949685, 0.19067255470302236, 0.1902482114722498, 0.21056931366801013, 0.08433984730329847, 0.07506580757158932, 0.07628153661070813, 0.09539346520842096, 0.07827794856820325, 0.08285065855819629, 0.07415192699008477, 0.07769589997010384, 0.08347172106719081]}, "mutation_prompt": null}
{"id": "e7e4ad35-616c-4d53-b1c1-6b871d46526b", "solution": "import numpy as np\n\nclass EPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def adapt_population_size(self, eval_count):\n        if eval_count > self.budget * 0.3 and eval_count < self.budget * 0.7:\n            self.population_size = int(self.initial_population_size * 0.8)\n        elif eval_count >= self.budget * 0.7:\n            self.population_size = int(self.initial_population_size * 0.6)\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            self.adapt_population_size(eval_count)\n            for i in range(self.population_size):\n                # Dynamic mutation scaling\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + 0.5 * np.tanh(eval_count / self.budget - 0.5))\n                    mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + 0.5 * np.tanh(eval_count / self.budget - 0.5))\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_points = np.random.rand(self.dim) < np.random.choice(self.memory[\"CR\"])\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if np.random.rand() < 0.5:  # Probabilistically update memory with successful params\n                        self.update_memory(F, self.cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EPADE", "description": "An Enhanced Probabilistic Adaptive Differential Evolution (EPADE) introducing adaptive population resizing and dynamic mutation scaling for improved exploration and exploitation balance.", "configspace": "", "generation": 15, "fitness": 0.08122816639553693, "feedback": "The algorithm EPADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.08 with standard deviation 0.07.", "error": "", "parent_id": "c117328c-ec67-4e5e-976b-23e425abf773", "metadata": {"aucs": [0.22496181157212958, 0.12828742308312358, 0.1850275536977447, 0.16878011593740994, 0.1167109442572637, 0.1564446621187746, 0.19332526070609923, 0.17144933250249939, 0.18082162193861473, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05197645066858336, 0.07392446438753031, 0.03227752510240389, 0.04303574696758261, 0.039311573617844986, 0.06764246537654994, 0.03597381387170029, 0.058990154034183284, 0.04430656144652312, 0.04406157414279732, 0.07098051544241046, 0.02549197339554954, 0.045202629246925086, 0.08630400938984861, 0.03940178832627428, 0.01753825774812845, 0.05381879671342782, 0.051036247789472466, 0.0706636891794502, 0.06888785753518423, 0.04719773823081819, 0.10851543896813842, 0.042492386090097534, 0.0677205128527687, 0.11373543762749483, 0.048159558522054446, 0.06342464477046905, 0.0264685562320659, 0.03082842924936635, 0.030776745005056783, 0.030165475908857653, 0.02602349501893264, 0.04765774595153105, 0.043202910908793246, 9.999999999998899e-05, 0.1094120270490121, 0.14418903977029496, 0.19972755827890298, 0.06922742415195404, 0.1283290067602313, 0.21080325540978195, 0.10550078766995064, 0.1345218908001512, 0.20230639078449542, 0.029130376975830763, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0013125547267113236, 0.027298518405484695, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05881220698079759, 9.999999999998899e-05, 0.0366861769899397, 0.026999500294438428, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033159762731235554, 0.024741293595171743, 9.999999999998899e-05, 0.18099313156145325, 0.03998689161846647, 0.022718722707967598, 0.031853281848361226, 0.04935879114007802, 0.019984588687909643, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.007743297190895615, 0.07195481454259933, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.1859887394933748, 0.18800703462050528, 0.23511324411611778, 0.14230017967198694, 0.1491146980903264, 0.1490144064520762, 0.2307425073022682, 0.13023854744388685, 0.21849446546778495, 0.02059548133109823, 0.047123683768954816, 0.048456724908603976, 0.044113739194981516, 0.023620718227503112, 0.0381803567084511, 0.02574189647473213, 0.01587996306015338, 0.0639079866331198, 0.11894620652658028, 0.09014006086705217, 0.09824874206604328, 0.1039779699546447, 0.16658209384261768, 0.12202928538599156, 0.07683061076163245, 0.10886034177271009, 0.10234988332495831, 0.15037359310676202, 0.17166148446113816, 0.1532462436214801, 0.1865306773763783, 0.16014114469319862, 0.18568251755259602, 0.12514108725386652, 0.16091344031086374, 0.1598393734927971, 0.08901847728036505, 0.09033307304083538, 0.05981470964141422, 0.1178476077798668, 0.10477970650391522, 0.1499480221200158, 0.08850970774981726, 0.08653628562320215, 0.09730451690858066, 0.1873376520678407, 0.13794321355751182, 0.15196829870973083, 0.19646287698911236, 0.18437764515177402, 0.197517735776645, 0.175089933388339, 0.16695558900061402, 0.15421530117954918, 0.16868215786208451, 0.1592957150838452, 0.1623165751711747, 0.14945767195032056, 0.135953429458897, 0.03620942978131114, 0.14285430362761942, 0.14938502683095134, 0.13044342212231952, 0.1612194398229302, 0.1376186742016311, 0.11332099402100015, 0.10276680529844884, 0.14053477171534245, 0.20244870555143457, 0.104672976111856, 0.12582542013857312, 0.10113563172963436, 0.06241459215266765, 0.13985461485648487, 0.06972230588816075, 0.07333529967832875, 0.053562281785436205, 0.20670518732513365, 0.1446436281965694, 0.07657325608591758, 0.06396768699837008, 0.18865982178226737, 0.18662843494718584, 0.19002416619167417, 0.1773719978518209, 0.16708197887199128, 0.20040032230962246, 0.16582364652474135, 0.22312269979242505, 0.20048597591462858, 0.07031145396375726, 0.06351939634066184, 0.043467046282082644, 0.04910377419791989, 0.0364823919505185, 0.044574946632233825, 0.045784684263120656, 0.051898616629765804, 0.04687791553215881]}, "mutation_prompt": null}
{"id": "323732a7-af7c-44bd-82b3-6e152738402e", "solution": "import numpy as np\n\nclass SMS_DE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.memory_size = 6\n        self.cross_prob = 0.85\n        self.F = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                strategy_choice = np.random.rand()\n                if strategy_choice < 0.3:\n                    indices = np.random.choice(self.population_size, 5, replace=False)\n                    a, b, c, d, e = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"])\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                elif strategy_choice < 0.6:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"])\n                    mutant = np.clip(a + F * (b - c) + F * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"])\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                cross_prob = np.random.choice(self.memory[\"CR\"])\n                cross_points = np.random.rand(self.dim) < cross_prob\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if np.random.rand() < 0.6:\n                        self.update_memory(F, cross_prob)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "SMS_DE", "description": "A Stochastic Multi-Strategy Differential Evolution (SMS-DE) combining adaptive parameter selection and multiple mutation strategies for robust performance.", "configspace": "", "generation": 16, "fitness": 0.3475096005149936, "feedback": "The algorithm SMS_DE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.24.", "error": "", "parent_id": "c117328c-ec67-4e5e-976b-23e425abf773", "metadata": {"aucs": [0.8059252989283859, 0.7995056256345265, 0.7959677447610626, 0.7979313176992573, 0.8114792155439781, 0.7949020057094476, 0.7981955105886258, 0.7890400331329882, 0.7914100604238772, 0.6557792318843843, 0.6414387890110802, 0.6293390742969425, 0.641983074360404, 0.6167728377146923, 0.6360913774851424, 0.6528602753207594, 0.6340982932390772, 0.6473649910272109, 0.12098297964919658, 0.1284253303582925, 0.11555755073758467, 0.13334970464853046, 0.13789012081938723, 0.12417609395053963, 0.12154190001374043, 0.12971855211775385, 0.11684678556223349, 0.11363655930024508, 0.11117582261248882, 0.11235130599835719, 0.10595344190945943, 0.11630226158238854, 0.11111366810601397, 0.11030144754621773, 0.12059313435490071, 0.11348127856900214, 0.8289629436357016, 0.882972506003534, 0.852089720910846, 0.930240724157579, 0.914202512171735, 0.9625312931249356, 0.8673361202524448, 0.9052182108884458, 0.7802839321820985, 0.42700005846556877, 0.4445065400773768, 0.431852088878383, 0.43912961393265415, 0.4415822536997779, 0.4343391943375894, 0.38359282162163044, 0.39922047157236806, 0.4228860093717882, 0.6943746065453753, 0.7423757087908389, 0.6959766814273438, 0.7759229257313602, 0.7275586497296014, 0.7578834733117332, 0.7704876310212461, 0.7119538461533259, 0.7309253070791532, 0.19790966525173304, 0.32906779217979176, 0.1943849225186749, 0.1884395665518619, 0.16201109624874022, 0.16443469459364002, 0.20928540389645756, 0.17589731384828777, 0.21263900889197862, 0.1930416738054237, 0.2663259463985601, 0.1778025182182431, 0.29210628532498495, 0.22166940387015877, 0.27625564846320305, 0.19573458732670534, 0.17946765996103464, 0.22653891836410744, 0.3353827272348151, 0.26944539674732104, 0.31383250260110773, 0.3019013220045408, 0.25481759313039465, 0.2691763099303064, 0.3234244618911706, 0.3006081910291869, 0.28029114305647695, 0.4099579741080558, 0.4210311071739048, 0.4720765358184983, 0.39792676845146857, 0.4077307540973335, 0.431296457451937, 0.4664966400073012, 0.4495152506746767, 0.4693633315126552, 0.10727983771679306, 0.12156276408603572, 0.10717767780652354, 0.12924579756347032, 0.178242827433984, 0.20775216320957846, 0.10753855788427158, 0.18827431560450802, 0.17241315680042935, 0.243731692640346, 0.2549243216566227, 0.26174879419571984, 0.2928296537839633, 0.2875218037854028, 0.26295000576917693, 0.260077313309638, 0.2592438235413015, 0.26684286322779904, 0.6756951191406022, 0.6571555344086497, 0.6536050938059592, 0.6431039008230643, 0.6476590156326851, 0.6717153664800227, 0.6843908574349986, 0.6629129654821618, 0.6715516778919265, 0.11625924062791748, 0.09418769100174473, 0.10186662241790123, 0.10243954819369938, 0.09197845993051124, 0.10008472290797288, 0.11309857432488479, 0.09989340700418525, 0.10327221289066602, 0.1437089216549743, 0.141400454043497, 0.16288306586434154, 0.13842430783779258, 0.14327861413335208, 0.13499534217504638, 0.13082307531519877, 0.13837805030517758, 0.14239021190729528, 0.38839005131919935, 0.36170536121516783, 0.38585309953817637, 0.3941303482294969, 0.38128311945024806, 0.3987558781076306, 0.4314858382617216, 0.43260571248138946, 0.4190261574588696, 0.3014876797346404, 0.29993022866377284, 0.2796397208104089, 0.27775606578080125, 0.27245019604709675, 0.28577034966191095, 0.30638864531347665, 0.29618600495114356, 0.32041008360330736, 0.2076742175562959, 0.20604747233828857, 0.18320206083771962, 0.19426951073462118, 0.19377000069721462, 0.1955405416333793, 0.19775633179031016, 0.20582889740631194, 0.20590944731632677, 0.19237272210817757, 0.18830628908019087, 0.1900928713487362, 0.184888264640655, 0.19304732793001844, 0.18596468172210867, 0.19519130030033904, 0.18612084844482757, 0.18464669392940436, 0.7495303875054765, 0.6656099451455333, 0.49801285320857247, 0.29842430714809065, 0.5869489994593114, 0.6091237735316692, 0.48470241279212467, 0.3642225768701024, 0.5490439606683158, 0.510810372503027, 0.16482749269016272, 0.20036074574448104, 0.19073869767005291, 0.21624659600737783, 0.3774229805208935, 0.20720898418723988, 0.20588905339662678, 0.20458444995480207, 0.20279242647271134, 0.1844239200406581, 0.1825836803390697, 0.1883500169124923, 0.18595773944013905, 0.19157892330460558, 0.1912430371801087, 0.19460410773770787, 0.20358482930729904, 0.0819798455722075, 0.08545364115824106, 0.0960152156444063, 0.08654070699064087, 0.0858861127287539, 0.08518628568731601, 0.08587872410024755, 0.08335189962761635, 0.08638545358801242]}, "mutation_prompt": null}
{"id": "e98c760b-6f76-4e3f-9c59-acc9355463e8", "solution": "import numpy as np\n\nclass EPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EPADE", "description": "An Enhanced Probabilistic Adaptive Differential Evolution (EPADE) which improves exploration by incorporating adaptive scaling factors and crossover probabilities based on success history.", "configspace": "", "generation": 17, "fitness": 0.4305253742852397, "feedback": "The algorithm EPADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "c117328c-ec67-4e5e-976b-23e425abf773", "metadata": {"aucs": [0.8473411173338607, 0.8424847278093095, 0.8514323973161205, 0.8474561612267253, 0.8476484249947891, 0.8459344406378949, 0.8542990015638718, 0.8560407067140258, 0.8229961912870417, 0.7142066214059749, 0.7203218400325001, 0.680750054302572, 0.6885088769697183, 0.7148424696020972, 0.7134797761519611, 0.6962245009145857, 0.6976390966799291, 0.7009210210035046, 0.12346408404148845, 0.12823477801189287, 0.12415312067911255, 0.1470819043431869, 0.1177137449566692, 0.12016366554202795, 0.12970746137461042, 0.15026744242407053, 0.11014748116903117, 0.1055007825250881, 0.09909035979500114, 0.11151302113443251, 0.10473704604930367, 0.10699096857898827, 0.103673466584557, 0.0951313765424664, 0.1009212698938764, 0.10857504091456194, 0.9683712158648653, 0.3625324686294191, 0.4674090117615134, 0.7796397090314533, 0.672015006872621, 0.41746906051620425, 0.740385652524641, 0.9421799974635144, 0.8602913235427663, 0.5683035569668556, 0.45371979010735264, 0.4584872031440663, 0.5586207758662555, 0.44069584227524505, 0.5103108089365074, 0.526239571206893, 0.5399849712025409, 0.49649334869506945, 0.8486973069075174, 0.7936015307984934, 0.824477468189255, 0.8581377751024042, 0.8615129840788375, 0.854794909063028, 0.8277002829411629, 0.8426171696911428, 0.8475622447786616, 0.3212212286146714, 0.5662885125485588, 0.2756256361148701, 0.5496212894608843, 0.25521356134425766, 0.2228066619565765, 0.3217430574258857, 0.2693800141687751, 0.3470521880620002, 0.20643664876736612, 0.25442358471408677, 0.3219907722678471, 0.26849018565182414, 0.32167019930218355, 0.5418231780062037, 0.3796316918634739, 0.3921203214915895, 0.3464922400087387, 0.621152488065297, 0.6343795067779393, 0.6168764312475498, 0.5862332031185332, 0.5837401508463395, 0.5808044901212818, 0.6298285744173956, 0.6200625907631183, 0.6544553734125858, 0.7016783554082933, 0.6902824591136012, 0.7015859853790127, 0.6998149556485314, 0.675750151353558, 0.684681127702665, 0.7108731516806169, 0.7028883206155412, 0.6993462230583718, 0.11500800199755745, 0.21581675657830157, 0.32236888136644704, 0.48164482556199895, 0.22841171713597286, 0.5184061849152228, 0.31395578552557446, 0.20551040755610162, 0.299605023363236, 0.5043149777250229, 0.4845269249867735, 0.5205633575744353, 0.5102324628162576, 0.5381045120460433, 0.5201045655493493, 0.4854099099458504, 0.5202867179850184, 0.5264598463126953, 0.8181686228285869, 0.8061375246335923, 0.7880593447345791, 0.8064011930357902, 0.784868399795397, 0.7958242822839742, 0.8022120925765824, 0.7787237052130354, 0.7924868961559033, 0.11698809307822233, 0.1158000980170707, 0.09776015197316701, 0.1190157740213652, 0.10902930053943505, 0.09800499642985527, 0.10034299635590127, 0.11666120285968551, 0.11891389485039472, 0.1493026449965642, 0.13924129128645202, 0.1454368374036381, 0.16643632130818864, 0.14718637882793772, 0.1639571918955296, 0.1401904792326203, 0.14170686205232652, 0.1307079272515439, 0.5003480640347173, 0.4733505520792922, 0.45864643835885743, 0.45727939168113385, 0.4808765585533914, 0.5127995967883155, 0.48364124027410627, 0.5400189972452448, 0.4983683378218938, 0.41377130981013777, 0.37754362785775397, 0.38398534718351707, 0.3849962521929905, 0.4264626231328029, 0.4414516780772191, 0.41757215703086925, 0.4516291438952469, 0.4455564809614164, 0.19378150155027796, 0.20446783451716433, 0.2087071106672097, 0.19988702665856517, 0.19478741640059893, 0.22702258222982474, 0.22814152058949155, 0.2019481050404649, 0.20907904010478362, 0.18571096056356662, 0.23298466427130682, 0.325047792550787, 0.1895192560294141, 0.1979272237463645, 0.28098297242242776, 0.23196712472152425, 0.1920421067786816, 0.2001347110715438, 0.191601600786239, 0.7919679220078322, 0.16856065347727345, 0.7334682213340848, 0.755499577853773, 0.7408004332653337, 0.802584759085986, 0.6200258380350885, 0.8232701872573105, 0.20619533403244916, 0.6956814636878395, 0.6434388816969296, 0.7447768804638148, 0.20617932333568856, 0.16243612770462545, 0.20058599357233853, 0.7405796405611951, 0.14958840882616564, 0.18640380231615117, 0.19381571340786863, 0.18572960977299657, 0.17946465683074186, 0.19232667984318463, 0.189452103604418, 0.18282205638482985, 0.20068854219637056, 0.18282974216905845, 0.08672204013937257, 0.08110198006826252, 0.08189161534423839, 0.08533709942067658, 0.09049713762255562, 0.08381514630117215, 0.09143318159153424, 0.08144512010448468, 0.0794213248726292]}, "mutation_prompt": null}
{"id": "2ea08ded-d348-46e0-a2a6-487ec9e06e4e", "solution": "import numpy as np\n\nclass EPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EPADE", "description": "An Enhanced Probabilistic Adaptive Differential Evolution (EPADE) which improves exploration by incorporating adaptive scaling factors and crossover probabilities based on success history.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e98c760b-6f76-4e3f-9c59-acc9355463e8", "metadata": {"aucs": [0.8473411173338607, 0.8424847278093095, 0.8514323973161205, 0.8474561612267253, 0.8476484249947891, 0.8459344406378949, 0.8542990015638718, 0.8560407067140258, 0.8229961912870417, 0.7142066214059749, 0.7203218400325001, 0.680750054302572, 0.6885088769697183, 0.7148424696020972, 0.7134797761519611, 0.6962245009145857, 0.6976390966799291, 0.7009210210035046, 0.12346408404148845, 0.12823477801189287, 0.12415312067911255, 0.1470819043431869, 0.1177137449566692, 0.12016366554202795, 0.12970746137461042, 0.15026744242407053, 0.11014748116903117, 0.1055007825250881, 0.09909035979500114, 0.11151302113443251, 0.10473704604930367, 0.10699096857898827, 0.103673466584557, 0.0951313765424664, 0.1009212698938764, 0.10857504091456194, 0.9683712158648653, 0.3625324686294191, 0.4674090117615134, 0.7796397090314533, 0.672015006872621, 0.41746906051620425, 0.740385652524641, 0.9421799974635144, 0.8602913235427663, 0.5683035569668556, 0.45371979010735264, 0.4584872031440663, 0.5586207758662555, 0.44069584227524505, 0.5103108089365074, 0.526239571206893, 0.5399849712025409, 0.49649334869506945, 0.8486973069075174, 0.7936015307984934, 0.824477468189255, 0.8581377751024042, 0.8615129840788375, 0.854794909063028, 0.8277002829411629, 0.8426171696911428, 0.8475622447786616, 0.3212212286146714, 0.5662885125485588, 0.2756256361148701, 0.5496212894608843, 0.25521356134425766, 0.2228066619565765, 0.3217430574258857, 0.2693800141687751, 0.3470521880620002, 0.20643664876736612, 0.25442358471408677, 0.3219907722678471, 0.26849018565182414, 0.32167019930218355, 0.5418231780062037, 0.3796316918634739, 0.3921203214915895, 0.3464922400087387, 0.621152488065297, 0.6343795067779393, 0.6168764312475498, 0.5862332031185332, 0.5837401508463395, 0.5808044901212818, 0.6298285744173956, 0.6200625907631183, 0.6544553734125858, 0.7016783554082933, 0.6902824591136012, 0.7015859853790127, 0.6998149556485314, 0.675750151353558, 0.684681127702665, 0.7108731516806169, 0.7028883206155412, 0.6993462230583718, 0.11500800199755745, 0.21581675657830157, 0.32236888136644704, 0.48164482556199895, 0.22841171713597286, 0.5184061849152228, 0.31395578552557446, 0.20551040755610162, 0.299605023363236, 0.5043149777250229, 0.4845269249867735, 0.5205633575744353, 0.5102324628162576, 0.5381045120460433, 0.5201045655493493, 0.4854099099458504, 0.5202867179850184, 0.5264598463126953, 0.8181686228285869, 0.8061375246335923, 0.7880593447345791, 0.8064011930357902, 0.784868399795397, 0.7958242822839742, 0.8022120925765824, 0.7787237052130354, 0.7924868961559033, 0.11698809307822233, 0.1158000980170707, 0.09776015197316701, 0.1190157740213652, 0.10902930053943505, 0.09800499642985527, 0.10034299635590127, 0.11666120285968551, 0.11891389485039472, 0.1493026449965642, 0.13924129128645202, 0.1454368374036381, 0.16643632130818864, 0.14718637882793772, 0.1639571918955296, 0.1401904792326203, 0.14170686205232652, 0.1307079272515439, 0.5003480640347173, 0.4733505520792922, 0.45864643835885743, 0.45727939168113385, 0.4808765585533914, 0.5127995967883155, 0.48364124027410627, 0.5400189972452448, 0.4983683378218938, 0.41377130981013777, 0.37754362785775397, 0.38398534718351707, 0.3849962521929905, 0.4264626231328029, 0.4414516780772191, 0.41757215703086925, 0.4516291438952469, 0.4455564809614164, 0.19378150155027796, 0.20446783451716433, 0.2087071106672097, 0.19988702665856517, 0.19478741640059893, 0.22702258222982474, 0.22814152058949155, 0.2019481050404649, 0.20907904010478362, 0.18571096056356662, 0.23298466427130682, 0.325047792550787, 0.1895192560294141, 0.1979272237463645, 0.28098297242242776, 0.23196712472152425, 0.1920421067786816, 0.2001347110715438, 0.191601600786239, 0.7919679220078322, 0.16856065347727345, 0.7334682213340848, 0.755499577853773, 0.7408004332653337, 0.802584759085986, 0.6200258380350885, 0.8232701872573105, 0.20619533403244916, 0.6956814636878395, 0.6434388816969296, 0.7447768804638148, 0.20617932333568856, 0.16243612770462545, 0.20058599357233853, 0.7405796405611951, 0.14958840882616564, 0.18640380231615117, 0.19381571340786863, 0.18572960977299657, 0.17946465683074186, 0.19232667984318463, 0.189452103604418, 0.18282205638482985, 0.20068854219637056, 0.18282974216905845, 0.08672204013937257, 0.08110198006826252, 0.08189161534423839, 0.08533709942067658, 0.09049713762255562, 0.08381514630117215, 0.09143318159153424, 0.08144512010448468, 0.0794213248726292]}, "mutation_prompt": null}
{"id": "8721f5ee-727d-4367-8f7e-40f7fabfaa49", "solution": "import numpy as np\n\nclass PMEADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_mutation(self, a, b, c):\n        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n        return np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n    def enhanced_mutation(self, a, b, c, d):\n        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n        return np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    mutant = self.enhanced_mutation(a, b, c, d)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    mutant = self.dynamic_mutation(a, b, c)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "PMEADE", "description": "A Probabilistic Memory-Enhanced Adaptive Differential Evolution (PMEADE) that optimizes exploration using dynamic memory updates with environmental feedback and adaptive scaling factors.", "configspace": "", "generation": 19, "fitness": -Infinity, "feedback": "An exception occurred: NameError(\"name 'F' is not defined\").", "error": "NameError(\"name 'F' is not defined\")", "parent_id": "e98c760b-6f76-4e3f-9c59-acc9355463e8", "metadata": {}, "mutation_prompt": null}
{"id": "8c7f31a0-03f9-473d-8db5-ed2c4d260cd4", "solution": "import numpy as np\n\nclass EMPDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def local_search(self, best_individual):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        new_solution = np.clip(best_individual + perturbation, self.lower_bound, self.upper_bound)\n        return new_solution\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        best_individual = None\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_individual = trial\n                        self.update_memory(F, CR)\n\n            # Local search\n            if best_individual is not None:\n                local_solution = self.local_search(best_individual)\n                local_fitness = func(local_solution)\n                eval_count += 1\n\n                if local_fitness < best_fitness:\n                    best_fitness = local_fitness\n                    best_individual = local_solution\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EMPDE", "description": "An Enhanced Memetic Probabilistic Adaptive Differential Evolution (EMPDE) which integrates local search mechanisms with adaptive parameters to enhance both exploration and exploitation capabilities.", "configspace": "", "generation": 20, "fitness": 0.42568743533891407, "feedback": "The algorithm EMPDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "e98c760b-6f76-4e3f-9c59-acc9355463e8", "metadata": {"aucs": [0.8380836268991376, 0.8415980769250194, 0.8480294527088279, 0.83347434867912, 0.8520019837587605, 0.8527916725100407, 0.8364628813612633, 0.8367288843375669, 0.8126954552830554, 0.7237933429128453, 0.7200200337661244, 0.6786724227562295, 0.7097998756160036, 0.7183170554311781, 0.7027230772107419, 0.6926365832950101, 0.6667034709570328, 0.702037795716284, 0.12289172308747309, 0.1384533116665, 0.1222543269613332, 0.13269210215922012, 0.12536664924706653, 0.13765492115582634, 0.1589132024364882, 0.1251496157720703, 0.11950595654913376, 0.1230210762157854, 0.1072932403137754, 0.11978133374825761, 0.11896767198939029, 0.12369099566000419, 0.10825516434891835, 0.11485462982493522, 0.11497532733042193, 0.11952539317492283, 0.8399283570429039, 0.832281042899253, 0.920235829438331, 0.8907629589087459, 0.8588494934241296, 0.7293181450205488, 0.7964006096037667, 0.867948532562164, 0.827538674107692, 0.4869662223331255, 0.4568636208011332, 0.4200647290532735, 0.5430292327255617, 0.4060757309272274, 0.49049642488770406, 0.5491449130863786, 0.42339252949642536, 0.4396399736596631, 0.8476628689070351, 0.79815077431621, 0.796955839768093, 0.8396778601246394, 0.8199688698277288, 0.8574563014982287, 0.811133908448314, 0.8093606007274624, 0.8448161683116626, 0.2535690565205322, 0.29337320045487847, 0.4650249426396844, 0.22058708943300376, 0.20416715321932466, 0.4724807591205866, 0.38268868182480875, 0.40800912368451503, 0.33571961223648006, 0.31912776274429866, 0.5772401770535802, 0.3583513624165007, 0.6824592181515436, 0.45211911442475716, 0.23298553725977622, 0.23698341725533711, 0.3832185632509021, 0.2870534128519986, 0.5707101236033416, 0.6285987434853175, 0.6535606216405361, 0.6603837414066317, 0.6143244227139782, 0.6114437197691462, 0.6041549132913709, 0.6224516287880995, 0.5985385561753378, 0.7352611047696287, 0.678585531164329, 0.7230661050160401, 0.6752261906202366, 0.6693048895662081, 0.6852373279221957, 0.719040006380524, 0.6948593908231944, 0.706952785144245, 0.2759329904506439, 0.2672088122615536, 0.14126025134042264, 0.49479294980397326, 0.4591497881265697, 0.2219237038942814, 0.28446290207344305, 0.236990703114636, 0.22960197460944431, 0.4893668215149498, 0.5027364172480552, 0.49538195650094696, 0.4828245811604992, 0.525534809537219, 0.5194765854671122, 0.4963886072033147, 0.5076334751944345, 0.48626853102045076, 0.7866402154551193, 0.7959504404184112, 0.7942071916531234, 0.7971814493428766, 0.7801221265094879, 0.7952904304752868, 0.8045916286538565, 0.7816530583554406, 0.7988363529371558, 0.10828426188079043, 0.12469225764597358, 0.10149311025115892, 0.1327107928811334, 0.11955383053626978, 0.11630932451058018, 0.136498816326737, 0.11783619632431508, 0.12136943685503065, 0.20128871579655316, 0.14180048386200705, 0.1627879765427731, 0.19706431545748737, 0.1855170312641592, 0.1347487387026607, 0.14860747329449953, 0.18123796431575256, 0.16922642173578584, 0.47853420806440405, 0.46020324966817383, 0.4772031719340898, 0.46912656631208327, 0.46215903540022174, 0.49719076806618845, 0.4901954083783263, 0.4917868040271488, 0.5065564641019646, 0.3931363288857451, 0.3881886044048144, 0.3951647868668494, 0.36568819804573527, 0.39281593503572654, 0.430386515476166, 0.40567441894998013, 0.33838574325418525, 0.4324108391280054, 0.1952355768667139, 0.20167912870703408, 0.20525077753984067, 0.21599787576759422, 0.21806088211229568, 0.19506004418046574, 0.20999171790607352, 0.24570278766169817, 0.20301784754356345, 0.19275629624851776, 0.23980130409863154, 0.20259278848976336, 0.21807488906413697, 0.19043697583090702, 0.20618049211629208, 0.2157584617680427, 0.21159142366862282, 0.2150211538991077, 0.8243308268096605, 0.8210139486853206, 0.18555586712752303, 0.19276444066915588, 0.189165941040765, 0.6518219240773419, 0.7563615314156374, 0.5309175600923186, 0.7457839919628015, 0.20544309353736412, 0.2075389135129616, 0.2069839826791584, 0.16517156172582614, 0.2076948910609664, 0.16589545727192634, 0.2010068249795901, 0.7829400041581766, 0.2242211703949316, 0.20071012220743223, 0.1881885470870629, 0.18252573614088774, 0.18371515960425344, 0.17831210618061155, 0.18406621456329963, 0.19337929782417596, 0.1855161710987796, 0.18233834691713857, 0.10049462836652256, 0.0782074138295813, 0.08471265275850326, 0.07696980638174533, 0.08321483984493283, 0.08693531504264862, 0.08592308421191741, 0.08614300544360287, 0.09227340202940104]}, "mutation_prompt": null}
{"id": "79bcb0d9-e21c-4b4e-9003-398f428b430e", "solution": "import numpy as np\n\nclass EPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                # Mutation\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EPADE", "description": "An Enhanced Probabilistic Adaptive Differential Evolution (EPADE) which improves exploration by incorporating adaptive scaling factors and crossover probabilities based on success history.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "e98c760b-6f76-4e3f-9c59-acc9355463e8", "metadata": {"aucs": [0.8473411173338607, 0.8424847278093095, 0.8514323973161205, 0.8474561612267253, 0.8476484249947891, 0.8459344406378949, 0.8542990015638718, 0.8560407067140258, 0.8229961912870417, 0.7142066214059749, 0.7203218400325001, 0.680750054302572, 0.6885088769697183, 0.7148424696020972, 0.7134797761519611, 0.6962245009145857, 0.6976390966799291, 0.7009210210035046, 0.12346408404148845, 0.12823477801189287, 0.12415312067911255, 0.1470819043431869, 0.1177137449566692, 0.12016366554202795, 0.12970746137461042, 0.15026744242407053, 0.11014748116903117, 0.1055007825250881, 0.09909035979500114, 0.11151302113443251, 0.10473704604930367, 0.10699096857898827, 0.103673466584557, 0.0951313765424664, 0.1009212698938764, 0.10857504091456194, 0.9683712158648653, 0.3625324686294191, 0.4674090117615134, 0.7796397090314533, 0.672015006872621, 0.41746906051620425, 0.740385652524641, 0.9421799974635144, 0.8602913235427663, 0.5683035569668556, 0.45371979010735264, 0.4584872031440663, 0.5586207758662555, 0.44069584227524505, 0.5103108089365074, 0.526239571206893, 0.5399849712025409, 0.49649334869506945, 0.8486973069075174, 0.7936015307984934, 0.824477468189255, 0.8581377751024042, 0.8615129840788375, 0.854794909063028, 0.8277002829411629, 0.8426171696911428, 0.8475622447786616, 0.3212212286146714, 0.5662885125485588, 0.2756256361148701, 0.5496212894608843, 0.25521356134425766, 0.2228066619565765, 0.3217430574258857, 0.2693800141687751, 0.3470521880620002, 0.20643664876736612, 0.25442358471408677, 0.3219907722678471, 0.26849018565182414, 0.32167019930218355, 0.5418231780062037, 0.3796316918634739, 0.3921203214915895, 0.3464922400087387, 0.621152488065297, 0.6343795067779393, 0.6168764312475498, 0.5862332031185332, 0.5837401508463395, 0.5808044901212818, 0.6298285744173956, 0.6200625907631183, 0.6544553734125858, 0.7016783554082933, 0.6902824591136012, 0.7015859853790127, 0.6998149556485314, 0.675750151353558, 0.684681127702665, 0.7108731516806169, 0.7028883206155412, 0.6993462230583718, 0.11500800199755745, 0.21581675657830157, 0.32236888136644704, 0.48164482556199895, 0.22841171713597286, 0.5184061849152228, 0.31395578552557446, 0.20551040755610162, 0.299605023363236, 0.5043149777250229, 0.4845269249867735, 0.5205633575744353, 0.5102324628162576, 0.5381045120460433, 0.5201045655493493, 0.4854099099458504, 0.5202867179850184, 0.5264598463126953, 0.8181686228285869, 0.8061375246335923, 0.7880593447345791, 0.8064011930357902, 0.784868399795397, 0.7958242822839742, 0.8022120925765824, 0.7787237052130354, 0.7924868961559033, 0.11698809307822233, 0.1158000980170707, 0.09776015197316701, 0.1190157740213652, 0.10902930053943505, 0.09800499642985527, 0.10034299635590127, 0.11666120285968551, 0.11891389485039472, 0.1493026449965642, 0.13924129128645202, 0.1454368374036381, 0.16643632130818864, 0.14718637882793772, 0.1639571918955296, 0.1401904792326203, 0.14170686205232652, 0.1307079272515439, 0.5003480640347173, 0.4733505520792922, 0.45864643835885743, 0.45727939168113385, 0.4808765585533914, 0.5127995967883155, 0.48364124027410627, 0.5400189972452448, 0.4983683378218938, 0.41377130981013777, 0.37754362785775397, 0.38398534718351707, 0.3849962521929905, 0.4264626231328029, 0.4414516780772191, 0.41757215703086925, 0.4516291438952469, 0.4455564809614164, 0.19378150155027796, 0.20446783451716433, 0.2087071106672097, 0.19988702665856517, 0.19478741640059893, 0.22702258222982474, 0.22814152058949155, 0.2019481050404649, 0.20907904010478362, 0.18571096056356662, 0.23298466427130682, 0.325047792550787, 0.1895192560294141, 0.1979272237463645, 0.28098297242242776, 0.23196712472152425, 0.1920421067786816, 0.2001347110715438, 0.191601600786239, 0.7919679220078322, 0.16856065347727345, 0.7334682213340848, 0.755499577853773, 0.7408004332653337, 0.802584759085986, 0.6200258380350885, 0.8232701872573105, 0.20619533403244916, 0.6956814636878395, 0.6434388816969296, 0.7447768804638148, 0.20617932333568856, 0.16243612770462545, 0.20058599357233853, 0.7405796405611951, 0.14958840882616564, 0.18640380231615117, 0.19381571340786863, 0.18572960977299657, 0.17946465683074186, 0.19232667984318463, 0.189452103604418, 0.18282205638482985, 0.20068854219637056, 0.18282974216905845, 0.08672204013937257, 0.08110198006826252, 0.08189161534423839, 0.08533709942067658, 0.09049713762255562, 0.08381514630117215, 0.09143318159153424, 0.08144512010448468, 0.0794213248726292]}, "mutation_prompt": null}
{"id": "580a8ce9-f803-446a-a752-4c9beef8f1e2", "solution": "import numpy as np\n\nclass EPADE_DMU:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR, success):\n        if success:\n            self.memory[\"F\"][self.memory_index] = F\n            self.memory[\"CR\"][self.memory_index] = CR\n        else:\n            self.memory[\"F\"][self.memory_index] = (self.memory[\"F\"][self.memory_index] + F) / 2\n            self.memory[\"CR\"][self.memory_index] = (self.memory[\"CR\"][self.memory_index] + CR) / 2\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                if np.random.rand() < 0.3:\n                    indices = np.random.choice(self.population_size, 4, replace=False)\n                    a, b, c, d = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - a), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 3, replace=False)\n                    a, b, c = self.population[indices]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    success = trial_fitness < best_fitness\n                    if success:\n                        best_fitness = trial_fitness\n                    self.update_memory(F, CR, success)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EPADE_DMU", "description": "An Enhanced Probabilistic Adaptive Differential Evolution with Dynamic Memory Update (EPADE-DMU) which introduces a dynamic memory update strategy to adaptively enhance exploration and exploitation balance.", "configspace": "", "generation": 22, "fitness": 0.2679968676354086, "feedback": "The algorithm EPADE_DMU got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.19.", "error": "", "parent_id": "e98c760b-6f76-4e3f-9c59-acc9355463e8", "metadata": {"aucs": [0.5149134029419682, 0.4873208995913545, 0.5046372670158519, 0.5061927031429123, 0.49341156848789947, 0.5576932950168483, 0.49476502031695624, 0.4888904360670101, 0.42068640904610544, 0.19172538071983736, 0.20052362303144355, 0.19541007829360457, 0.246884319632527, 0.2321894185484641, 0.22641721581987917, 0.17556653668041344, 0.1909412927870482, 0.1575188186887384, 0.09033174728922078, 0.08548446730181769, 0.09346414156698957, 0.09364188622072012, 0.09328479059743366, 0.09471879828231544, 0.0941289000427259, 0.10936625680715228, 0.09824574032508371, 0.08247644816189204, 0.07925023150367327, 0.08732475091929448, 0.07868831148315525, 0.08947075774288771, 0.0790599246951681, 0.0850602240452335, 0.10111406399868461, 0.0786281610193138, 0.7474974110252645, 0.8048742449339452, 0.6426418713666691, 0.6859581340192094, 0.8161767110815656, 0.8466953836914157, 0.7336494910686328, 0.7217930213549435, 0.5806147630920608, 0.24124656642180087, 0.2400483945290387, 0.2600517072267511, 0.2639341839510946, 0.22369761425654044, 0.25069782139367747, 0.2577115171248966, 0.25994896739086815, 0.24101328048834791, 0.5514416277318526, 0.5758620407416233, 0.5402099519587676, 0.6678936665484999, 0.6904567933374834, 0.6269704033962231, 0.5711122439138674, 0.7298196272065547, 0.4896537254597171, 0.20284373709827164, 0.188511378386105, 0.2023124542941881, 0.21754410899697318, 0.18981711612373675, 0.19480249347768563, 0.19959329840582185, 0.18789523074908465, 0.19167429471005126, 0.25366247163681177, 0.19116498868756437, 0.19098382597152397, 0.22267618828236269, 0.2107422686224376, 0.23761735494910285, 0.17357420654908473, 0.23339953047573125, 0.18189812535556826, 0.1746076606507766, 0.1559703173734568, 0.20436637322461015, 0.19488022148653084, 0.14393450436095756, 0.17721272209778238, 0.2077267453686703, 0.1849731648701216, 0.21421768805325236, 0.3226099414603658, 0.38865602930796994, 0.35252076713117886, 0.36873098480938715, 0.37680505898570105, 0.33907252796248644, 0.3583466517600853, 0.3561475860440072, 0.3517655760178976, 0.01972355533591197, 0.035113690442159506, 0.03932850873107452, 0.011224664213305369, 0.019343828736311353, 0.02712628473981782, 0.011647181573323562, 0.023541916572568544, 0.04191478447864205, 0.1362549892688345, 0.1476965039056014, 0.15388678348979756, 0.13155042575115872, 0.12237806763044068, 0.1697507255084285, 0.16389780681922583, 0.16459100462127185, 0.1692111389107822, 0.45566157416034203, 0.43782428392843276, 0.4589646598249405, 0.4160828950323494, 0.4386234652339627, 0.4287323069012636, 0.4730643775686266, 0.4352573603297497, 0.45134160241491017, 0.08545288087676706, 0.09500683170453916, 0.1066704587698254, 0.09314945067609604, 0.09260213878111556, 0.0979188567742949, 0.09766960173275585, 0.09746539459317716, 0.08727214368951064, 0.15959193892590628, 0.1312391634560519, 0.13710709827365186, 0.15671972957900726, 0.17956906182414112, 0.12057180323992778, 0.17041647252994585, 0.1479051093265974, 0.14085992209014564, 0.2853057185067037, 0.2886959470644693, 0.30221372456426154, 0.26918698514720807, 0.2833464685942365, 0.2974170630980477, 0.2855208570964448, 0.2817140080074194, 0.27805774245035864, 0.2242995751815361, 0.23705550950718457, 0.23408566038406675, 0.2293553662491381, 0.21589448245082243, 0.2279912686470611, 0.24195454309987274, 0.27017569067583225, 0.2443216563741213, 0.18740520215434076, 0.20345558603044145, 0.19200697831637992, 0.19323872590518532, 0.20277150570999025, 0.20303409515409854, 0.20918847274263253, 0.18748917490624872, 0.19534748202901342, 0.17765521940199758, 0.1793657446119974, 0.18441966875258453, 0.17510531770213178, 0.18376926807292016, 0.18173778522307216, 0.18036731244679938, 0.18111820849142946, 0.17500032989703307, 0.6185249441187404, 0.6504161724553779, 0.6279383170394317, 0.591547645317942, 0.6690090063681142, 0.688819381662762, 0.3478726558080911, 0.5751691479265493, 0.5133890134645831, 0.2069010474745131, 0.7089920016825441, 0.7291373776017673, 0.6258928449024833, 0.20026953972843053, 0.608405994571771, 0.16613494364818182, 0.15436402195128773, 0.2021103593252337, 0.18352558889225912, 0.21302045809796533, 0.18676082619120848, 0.19540651694956912, 0.19506815059741978, 0.2032993615786407, 0.18384939367583442, 0.18607573240091235, 0.18874565933784504, 0.07116228474072117, 0.07404635492776346, 0.08009744191980395, 0.08103123535978907, 0.07377341406025573, 0.08098909750640082, 0.07813961014434878, 0.07972926462896923, 0.07336176929669469]}, "mutation_prompt": null}
{"id": "0757240e-422b-454b-828b-801adccd388f", "solution": "import numpy as np\n\nclass PADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F_base = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F_base),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                F_dynamic = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                indices = np.random.choice(self.population_size, 3, replace=False)\n                a, b, c = self.population[indices]\n                if np.random.rand() < 0.5:\n                    indices_extra = np.random.choice(self.population_size, 1, replace=False)\n                    d = self.population[indices_extra]\n                    mutant = np.clip(a + F_dynamic * (b - c) + F_dynamic * (d - a), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + F_dynamic * (b - c), self.lower_bound, self.upper_bound)\n\n                CR_dynamic = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR_dynamic\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F_dynamic, CR_dynamic)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "PADE", "description": "A Probabilistic Adaptive Differential Evolution (PADE) utilizing dynamic memory for self-adaptation of strategies to enhance convergence through stochastic local search.", "configspace": "", "generation": 23, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('setting an array element with a sequence.').", "error": "ValueError('setting an array element with a sequence.')", "parent_id": "e98c760b-6f76-4e3f-9c59-acc9355463e8", "metadata": {}, "mutation_prompt": null}
{"id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 24, "fitness": 0.5333773547149697, "feedback": "The algorithm RefinedEPADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.30.", "error": "", "parent_id": "e98c760b-6f76-4e3f-9c59-acc9355463e8", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "7ed48e27-becb-454a-ba0b-c921b174a95d", "solution": "import numpy as np\n\nclass AdaptiveHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.initial_cross_prob = 0.9\n        self.initial_F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\"F\": np.full(self.memory_size, self.initial_F), \"CR\": np.full(self.memory_size, self.initial_cross_prob)}\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Hybrid mutation with crowding distance to maintain diversity\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.rand() * self.epsilon)\n                    crowding_distance = np.sum(np.abs(self.population[i] - self.population), axis=1).mean()\n                    mutant = np.clip(a + F * (b - c + d - e) * crowding_distance, self.lower_bound, self.upper_bound)\n                else:\n                    # Adaptive learning strategy with dynamic parameter adjustment\n                    local_best = np.argmin(self.fitness[indices])\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.rand() * self.epsilon)\n                    mutant = np.clip(a + F * (b - self.population[indices[local_best]]), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) * (1 + np.random.rand() * self.epsilon)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveHybridDE", "description": "An Adaptive Hybrid Differential Evolution (AHDE) algorithm leveraging dynamic parameter adaption, mixed mutation strategies, and crowding distance to enhance convergence speed and diversity.", "configspace": "", "generation": 25, "fitness": 0.26272692476085585, "feedback": "The algorithm AdaptiveHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.20.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.5472300575237821, 0.6055225531518584, 0.5464861556977381, 0.4999468720225225, 0.47243446144614143, 0.45168282535357684, 0.5303682839880335, 0.4663892030203478, 0.4362435686366486, 0.25255218521137757, 0.29008139523672827, 0.21990148185364755, 0.10473448959138298, 0.36331508733330875, 0.4858364542913076, 0.09639515186870862, 0.3048080172422827, 0.27914269560513094, 0.13748781613328798, 0.12104528383248947, 0.13390954805763777, 0.1676498203632636, 0.1396168047975116, 0.15330500567148442, 0.162357130911437, 0.16259606194117682, 0.16216950305190636, 0.08882447475885036, 0.1005029223945123, 0.107268317972676, 0.0950586918211529, 0.10529430852447186, 0.11378302126222661, 0.1093618197356333, 0.10081105480353636, 0.08678799347443822, 0.9525784929160591, 0.9632256849015347, 0.9721562614023713, 0.9732771491799508, 0.9355595537710027, 0.9516412145352703, 0.9247822912436645, 0.9012449575835839, 0.9996036561313602, 0.13498506589824355, 0.134837832090679, 0.14264987106258487, 0.16248808507534573, 0.17240869020554495, 0.15523456704249106, 0.1534985768385868, 0.13889774359769125, 0.12574496399378454, 0.364494703201232, 0.21991640736346696, 0.22337207264011982, 0.7579478273183619, 0.8272382084353873, 0.787611559905135, 0.2850475510078949, 0.3526156816205992, 0.35593410952682925, 0.17161688665575692, 0.14914308227836315, 0.15262859116409833, 0.18321598772840175, 0.27587433547790063, 0.13013148057295387, 0.14152368702994245, 0.15356527049022262, 0.15092478160783407, 0.13852623578527767, 0.12827990127214595, 0.1680898800111439, 0.2252869045492767, 0.11967973573086854, 0.14310504007586566, 0.21918365117970884, 0.12892229486044648, 0.2033963845947785, 0.0799003165675869, 0.09276930848194587, 0.15143575634226147, 0.058852792340274185, 0.12799551882032778, 0.1608053252378837, 0.17036929679441715, 0.14999640136874037, 0.085530533504387, 0.2120423825495349, 0.2315176366134779, 0.27103625676988474, 0.20153405979416217, 0.24227296270277043, 0.2607664135626311, 0.22137691266154436, 0.4011047162296141, 0.1743511487713788, 0.0795582072860096, 0.1983367073296557, 0.05824706167275617, 0.13197935688188422, 0.08508391185483155, 0.17124261102011373, 0.11056692392892709, 0.036403862022700406, 0.17978459470954644, 0.3321059944506882, 0.15972765583356663, 0.26970250212738023, 0.15114077808052828, 0.17087255203695095, 0.1827950343604655, 0.1543406743374961, 0.19354795831048477, 0.14644209640385675, 0.5337739027015693, 0.5564960635040912, 0.631705551944342, 0.4635742660492509, 0.41375673645658806, 0.5197715958566136, 0.5485944399340941, 0.41356071060961364, 0.4147412177851737, 0.13681344928824057, 0.11888777664878203, 0.14652845768310452, 0.08219671085479818, 0.13335644725508877, 0.14691520838212435, 0.11265254009496017, 0.13325646252453482, 0.12465261177112497, 0.1382268219530306, 0.1649345137197552, 0.09887458321003595, 0.15298659284264338, 0.22605655068185204, 0.15684302561755792, 0.19204164484144992, 0.15607858342056202, 0.18337791830706895, 0.39934327878624254, 0.2934240457530418, 0.354324716645673, 0.38504502591351597, 0.3746272904165179, 0.39605690346292544, 0.38194049662845875, 0.2919803978330242, 0.37298040041477065, 0.21347317880060535, 0.19449607773244126, 0.3165365333844111, 0.3101112895169085, 0.31959067503806415, 0.327151307672536, 0.22880704639672944, 0.2866551592067428, 0.3118648809968676, 0.20883408050626762, 0.22125698260035276, 0.21482276440191495, 0.2188370394080036, 0.25917011525149825, 0.20634614832133935, 0.22152445084363126, 0.2158013024682608, 0.20628199820834991, 0.22849009012195742, 0.1866619803118672, 0.2152261067700132, 0.19169724015029654, 0.27463179165238794, 0.2712754769972261, 0.25902735531521126, 0.20453861151552888, 0.19298965162508896, 0.1730597053534586, 0.17233108402572594, 0.17423371807548793, 0.16139119493020737, 0.16077155678924204, 0.34385903268490836, 0.1630949360035695, 0.45463307773900186, 0.7000604815080231, 0.12130168037431888, 0.2762454249564529, 0.20672674225440946, 0.6720213052251959, 0.31306620758641024, 0.43124986875614646, 0.1852367403253793, 0.20280619167075742, 0.18873225803879468, 0.19205608613333314, 0.1765716929528649, 0.18168629584159657, 0.19996103875512927, 0.16761703019224206, 0.15852515606233486, 0.21379329112729384, 0.16797848685891092, 0.17350785086824505, 0.11480415312761305, 0.07961263955535636, 0.08696983840601902, 0.09256632038982227, 0.08960936542915676, 0.07771720379802938, 0.07522898530261612, 0.1069177627639607, 0.07807141957947128]}, "mutation_prompt": null}
{"id": "dd9680f7-3a4b-4018-bdce-c58bad04a4b0", "solution": "import numpy as np\n\nclass DivEvo:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.base_F = 0.5\n        self.epsilon = 0.02  # Modified epsilon for diversity\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.base_F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Dynamic scaling with neighborhood influence for exploration\n                    F = np.random.choice(self.memory[\"F\"]) + (0.5 + 0.5 * np.random.rand()) * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Exploitation strategy with adaptive scaling\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + (0.4 + 0.6 * np.random.rand()) * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "DivEvo", "description": "A DivEvo algorithm utilizing dynamic scaling factors and neighborhood information with balanced exploration-exploitation trade-off for improved convergence.", "configspace": "", "generation": 26, "fitness": 0.4765897508636204, "feedback": "The algorithm DivEvo got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.48 with standard deviation 0.29.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.8974748671459816, 0.8826755355711676, 0.8631188898196311, 0.8651700300613205, 0.8995205683229718, 0.8698450434638137, 0.8790338001548288, 0.830718560331245, 0.8298718656769096, 0.7107410372069061, 0.6917817510949074, 0.7724558214465673, 0.7705436529477568, 0.6747257827785643, 0.6882619648833285, 0.7442159710862353, 0.703725832862679, 0.6849364106701256, 0.13079069689269984, 0.1427215111283484, 0.15904930665055528, 0.34159712113072127, 0.13350380165544795, 0.12042916008988536, 0.14013556024448304, 0.48356403091038935, 0.13235157525632457, 0.12466735444331933, 0.1201857519482552, 0.11475041755578042, 0.09828707372858536, 0.11944703741640039, 0.11177360225303179, 0.11633838571540911, 0.10626598941633036, 0.13115559652849296, 0.9863796572821536, 0.9925086963519524, 0.9853478452775691, 0.9831965845762156, 0.9628515688257024, 0.9834351710451917, 0.9763298027080611, 0.9776821481819281, 0.9915259306127243, 0.5887066313561999, 0.6565036335307758, 0.561128705888933, 0.6547800891151905, 0.6620348824437028, 0.597119778835494, 0.5912604401208439, 0.5982923413084474, 0.6405495928243652, 0.8914735419883972, 0.8774914272826959, 0.9064798497368367, 0.916002493988988, 0.9068190414361169, 0.8604879801450555, 0.8643394283797959, 0.8754686590382058, 0.9130380622276988, 0.4626055631897529, 0.5183147561283894, 0.6142016317617238, 0.37628167954855185, 0.13486437010006302, 0.12982420204110734, 0.5257757837790287, 0.5899579458532711, 0.5361081356888104, 0.3629857532405629, 0.607769956488154, 0.5699678768297258, 0.6281678895521488, 0.5575347370255663, 0.5252747694095542, 0.48631297492756553, 0.4691896095911491, 0.5902771539043572, 0.7273784034482074, 0.7049804284307251, 0.7170275869681773, 0.7239082700186943, 0.7240342125388355, 0.62233066774806, 0.7127714507459774, 0.6725200516926043, 0.6697885424772392, 0.792955898932379, 0.7583019042942436, 0.7834762449638819, 0.7651545897186066, 0.7721617173073402, 0.7806998392853373, 0.5338509398593254, 0.807836890373069, 0.7886714760186455, 0.4224584248982731, 0.5087761212557254, 0.464664996304366, 0.5356403406224333, 0.3771042369995278, 0.5311230663531903, 0.3817787564253461, 0.3716779350691177, 0.36629789303347415, 0.46925842046964295, 0.43096012140855267, 0.509722892226697, 0.5090641450405549, 0.4641549535171513, 0.4928363683861615, 0.41773417641418475, 0.541049893219077, 0.5059633332326671, 0.8305017955022503, 0.8614848013781965, 0.8335859429163355, 0.848490232929791, 0.8472308214992436, 0.8108675351684309, 0.8747258173124632, 0.8407966754736094, 0.8400952562771444, 0.11194852871614058, 0.16242761082155355, 0.15887571965037184, 0.12234883551312103, 0.11901606772779816, 0.43900177532912943, 0.12018498381756049, 0.14287434492153095, 0.13220991154950368, 0.13831850880431973, 0.1324408738867946, 0.14150263048967449, 0.2705628055077208, 0.18066624796803665, 0.1797900536340714, 0.4426645059856922, 0.25908835581473855, 0.26155978967908955, 0.5466215499765279, 0.5694052792378845, 0.5990444243791808, 0.5362388599744005, 0.6001053425929139, 0.6053073848388805, 0.5387959184457873, 0.5277939215451231, 0.5501290423433454, 0.5194160088591314, 0.5655105488017479, 0.5058299180282164, 0.5092492051065098, 0.2219202131856639, 0.5494070995838081, 0.5033478869043213, 0.44780581445623935, 0.4780630987791532, 0.21127325197440738, 0.20732515166556476, 0.19669293164594015, 0.2353594752765128, 0.22945633021308387, 0.20331772728683217, 0.24532927089277456, 0.19811364978320678, 0.2198283110566167, 0.19320691967076364, 0.23486209081315335, 0.21582514586192347, 0.21530535226377934, 0.2308962488569759, 0.2219824705151222, 0.45925175299299525, 0.21266948516515516, 0.6348156358843038, 0.18533409125325795, 0.16670657953048662, 0.1948741210021221, 0.1766542734453025, 0.16677444524415586, 0.14779964116323185, 0.9006021538987204, 0.16265862740546, 0.16067462144576616, 0.2081491210069154, 0.16841747093276005, 0.8714171034797114, 0.21018060312856301, 0.12711286982963466, 0.16825165319844504, 0.8466203811097548, 0.8923759429897888, 0.2097391173626001, 0.19458128504823569, 0.17249563378932575, 0.19584880926599402, 0.16220791521964706, 0.1742376130626675, 0.18087222827676286, 0.1801033676100524, 0.187310121797713, 0.17888676235799283, 0.08318128977577288, 0.07935073582613239, 0.10450855661815572, 0.0919148907979992, 0.08652525862407856, 0.08615485404136147, 0.07883111347168692, 0.08021439736320668, 0.0884600672806568]}, "mutation_prompt": null}
{"id": "6a6fc899-ee6f-4186-95a9-f36fe8372e2a", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "d158ff6a-97ed-42bf-9a08-7d11ad55296c", "solution": "import numpy as np\n\nclass RefinedEPADE_Adaptive:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 10\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_parameter_adjustment(self, current_fitness, trial_fitness):\n        if trial_fitness < current_fitness:\n            return np.clip(trial_fitness / current_fitness, 0.1, 1.0)\n        else:\n            return np.clip(current_fitness / trial_fitness, 0.1, 1.0)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.uniform(-self.epsilon, self.epsilon)\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best_idx = indices[np.argmin(self.fitness[indices])]\n                    a = self.population[local_best_idx]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.uniform(-self.epsilon, self.epsilon)\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.uniform(-self.epsilon, self.epsilon)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    adaptive_factor = self.dynamic_parameter_adjustment(self.fitness[i], trial_fitness)\n                    F = F * adaptive_factor\n                    CR = CR * adaptive_factor\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE_Adaptive", "description": "A Refined EPADE variant with adaptive F and CR update mechanisms using a dynamic memory strategy for enhanced convergence across diverse landscapes.", "configspace": "", "generation": 28, "fitness": 0.5215392480941211, "feedback": "The algorithm RefinedEPADE_Adaptive got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.30.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9054534669327149, 0.9101350796395582, 0.89870966817481, 0.9108124610523152, 0.9083829421409797, 0.9118202129592334, 0.900697425136992, 0.9076453726478555, 0.8983111884495075, 0.8362319777845583, 0.8291274600897823, 0.8312866360461904, 0.8116635588904576, 0.8300052565723737, 0.8406854826969452, 0.8206279642460304, 0.8326573622101543, 0.8187600808730509, 0.5270711508491436, 0.16682879262761596, 0.15830222138171268, 0.17420227341273165, 0.1612274861317734, 0.1545118686418302, 0.6934100576935258, 0.17806371849081715, 0.14774740142374976, 0.14455585016805872, 0.14353038371830829, 0.14743151103393615, 0.13920088225468608, 0.14100154799944353, 0.14145378295443223, 0.13780472803319987, 0.1175776855998365, 0.12586734172948622, 0.9901003204924409, 0.9886411898587388, 0.9648269476117982, 0.9949533844267473, 0.9895925879723837, 0.9659857742319751, 0.9913895829120033, 0.9772952433568807, 0.9894553041136431, 0.7397590513051819, 0.7469280442063, 0.7428733405437575, 0.7408763684868367, 0.7501501768289057, 0.7475963496513601, 0.73468073461353, 0.7554981432956013, 0.7435995270577789, 0.8975067927873137, 0.877998737383635, 0.8969988440342138, 0.21267884415600113, 0.21321963308033032, 0.9017383730111229, 0.8959591242768546, 0.8999820647377899, 0.904632498225634, 0.6346274970993746, 0.5494677551579976, 0.6331627183110603, 0.1306603467189994, 0.610360646136592, 0.6651892490990219, 0.6190356860805998, 0.6034198420857029, 0.6325177912574876, 0.5385341422114895, 0.53853831653153, 0.6527861997113014, 0.6949595936231892, 0.6119456119242825, 0.5489528670723394, 0.6718557384469073, 0.5827753840393233, 0.6623431562946933, 0.7154154467635325, 0.5149371806047043, 0.7499759396250185, 0.7385002987590459, 0.6402847313114455, 0.6130367667923993, 0.7463388869831381, 0.6871809157231331, 0.6613407901489052, 0.7861641699568059, 0.742024485144753, 0.7799762617504495, 0.76910447646063, 0.7871792372924774, 0.7772240981911478, 0.7763247522172289, 0.8266539932393184, 0.7996380429105171, 0.21013672132937578, 0.16232584042910292, 0.17854315939127663, 0.5185754307315221, 0.6666020229365175, 0.6490034063147603, 0.4495125148542862, 0.41032121498307317, 0.20132481981112438, 0.5876690003975, 0.6353595392193025, 0.6560928221952718, 0.6841703305474598, 0.6426873643964197, 0.7113377641997706, 0.6700623957109807, 0.6580390351757088, 0.6155727212449704, 0.8491667325060954, 0.8568159801842556, 0.8516859913718805, 0.8770173770485891, 0.8656985357769797, 0.8412845518286234, 0.871537543021214, 0.8624664611561793, 0.8781366198342846, 0.12494366768323073, 0.1463819524258415, 0.14825240208411183, 0.35094687943213243, 0.1483725835023626, 0.13114746112344366, 0.4771608792969356, 0.1399110385063761, 0.13258123663224886, 0.19220946054128463, 0.1854790784767496, 0.1890397409427781, 0.21437081210806042, 0.20175722873673052, 0.25573964346755484, 0.1624368505242072, 0.2402591599675421, 0.21841662900882675, 0.7345273538494171, 0.7363706107682841, 0.7533280491434808, 0.7420894591397835, 0.7166503407737703, 0.6827422943563749, 0.7378967676094823, 0.7189862421161375, 0.6309106409879357, 0.5884274867168298, 0.4915469400498337, 0.5096145347350827, 0.5959192265321236, 0.6396944227284757, 0.5772708062886158, 0.5241428222996989, 0.6792830024923757, 0.533961849796269, 0.2176661271223832, 0.1893420887521412, 0.24057414527079757, 0.2162675711294011, 0.2150954719032806, 0.2088337779247822, 0.21863431573642023, 0.2148095387478145, 0.20780633685411032, 0.6672140554681267, 0.21742391407531436, 0.7140728751717987, 0.21703489933049724, 0.21293968603160995, 0.24189797888571052, 0.23432370361868649, 0.23530077506973035, 0.5733822396056771, 0.16304842510556883, 0.9292152466159989, 0.1565768744001682, 0.18686686509488037, 0.16531167195755225, 0.9105734565268092, 0.16618745538782265, 0.1837304864643874, 0.146018577820766, 0.21050348425880472, 0.8956668053741756, 0.8573371419971529, 0.9071569865649578, 0.15475795506637702, 0.835912010631843, 0.15436575540766806, 0.12862928719784672, 0.20729082211231653, 0.1925351437136228, 0.1792759142788165, 0.1900612208975334, 0.1832175011367898, 0.1879888598913413, 0.19131076953248782, 0.18237801890016003, 0.20671834005409906, 0.2007520524648987, 0.08893272092680204, 0.09347370889702467, 0.0973300157746888, 0.10252164129737207, 0.12554797951686103, 0.08315575921902252, 0.0934715991174726, 0.09419987595865531, 0.09376992760513003]}, "mutation_prompt": null}
{"id": "794dcc16-8d19-4865-bfbf-1b1f0020bbc4", "solution": "import numpy as np\n\nclass AdaptiveHypermutationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Probabilistic neighborhood influence with adjusted hypermutation\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    # Dynamic local learning with hypermutation\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (self.population[i] - a)), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveHypermutationDE", "description": "An Adaptive Hypermutation DE leveraging probabilistic neighborhood effects and dynamic crossover rates for improved exploration and exploitation balance.", "configspace": "", "generation": 29, "fitness": 0.5110753394792434, "feedback": "The algorithm AdaptiveHypermutationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.8974507547650713, 0.8882899888312129, 0.8889112736431862, 0.879986601033923, 0.8974752381890057, 0.8965980023290862, 0.8931017421323606, 0.8960063911082026, 0.8926769387810924, 0.8141528805775194, 0.8011334887221491, 0.7809379674275547, 0.8217469103165146, 0.8047541014654408, 0.8013130261802903, 0.7894040325201196, 0.7735671170789137, 0.789277656694724, 0.15765508834179565, 0.13747163722896893, 0.1576093609792535, 0.15093171377896764, 0.22112768917070702, 0.12894034545182642, 0.12903552346782177, 0.13028162724820236, 0.14565218131403834, 0.13791653518786262, 0.12695647629033624, 0.11797312490517575, 0.1245708323629997, 0.1473999583156338, 0.12720592332608682, 0.12026374736659795, 0.11822532482316184, 0.10613979823745334, 0.9233831521977285, 0.9115051036185634, 0.8790422749290748, 0.9572995986000029, 0.8939259640950096, 0.9181144655508692, 0.9806682703253969, 0.966479680426691, 0.9299320294099943, 0.7223582275911367, 0.6960658610134642, 0.7225148271472461, 0.7227822277851232, 0.7065633025694926, 0.715903302708321, 0.6386411944527626, 0.7299441036719937, 0.7013503998072774, 0.8997701013361543, 0.8930398601794527, 0.9140236160976007, 0.9098554342205434, 0.8888270385696361, 0.902160847128129, 0.8831746878679727, 0.8832122342345304, 0.899978116042007, 0.66122838666802, 0.5299325596648501, 0.5604752486148217, 0.49225437506717773, 0.5618822404719458, 0.5819155154794482, 0.3774389157470185, 0.4901416009234256, 0.5608478392066939, 0.5124797204768767, 0.6061448019254703, 0.7061591949014441, 0.5534538982319223, 0.6579050987750863, 0.6487146222615023, 0.6488322932006615, 0.624419692801788, 0.5733220541846064, 0.6905962838774851, 0.7479648001634536, 0.735876389036455, 0.7420003641911566, 0.7383793448833929, 0.7233029913548863, 0.7550813746835743, 0.7565690333389898, 0.7393146952865801, 0.8058170449564616, 0.78833962302937, 0.816092829799652, 0.7557678792459621, 0.782375950641599, 0.768946947391295, 0.8079842539172268, 0.8084751834024287, 0.8166835299536257, 0.5018348754347157, 0.4883356340937116, 0.21304971272185502, 0.7095102365435606, 0.49620033348820325, 0.6941321041240092, 0.2779214962615423, 0.20250706270856578, 0.35734632941582045, 0.6266961295766893, 0.6444099128234622, 0.6733464043693101, 0.6414610535923997, 0.6885907567706173, 0.6729832553051112, 0.6810566699845382, 0.6844261807238651, 0.7026009878199393, 0.866322053742364, 0.8728090795798195, 0.8642237016332717, 0.8669023190634968, 0.8731567701982259, 0.8813280674415697, 0.8828828066995502, 0.8487757066948154, 0.8398417821080771, 0.1410004111484826, 0.1410405608193882, 0.14894681345521565, 0.15741411987835963, 0.12046596584100266, 0.10783450807993233, 0.12564519121310858, 0.13996832847430274, 0.13719112551699875, 0.148691270313842, 0.13865315008433154, 0.15269384133820818, 0.1519312917967447, 0.1528169352106783, 0.13873313171980406, 0.2823181039889331, 0.15056713755248807, 0.16291310233580514, 0.7188142264538843, 0.647440222391648, 0.6787815706499478, 0.6910876801441463, 0.6750911216037694, 0.6910202779503626, 0.7082427969569356, 0.7135335557442419, 0.6857330834374379, 0.5957347395948204, 0.6097186855412993, 0.598234395405806, 0.5779902798065919, 0.5974026630323286, 0.6137420599576187, 0.6311834068224769, 0.622315498931852, 0.6023145500015915, 0.22134273892233614, 0.23900748860177468, 0.2644406338652524, 0.21333840961667405, 0.22612464622085005, 0.20684156938908127, 0.23082579550570204, 0.20225440994792387, 0.24249955278532376, 0.2433896865477584, 0.2278672875216925, 0.4152681653525012, 0.4047765925120823, 0.21606275466569191, 0.205762621600033, 0.19108969340670012, 0.2495052911847907, 0.4175035428817503, 0.18662589225783577, 0.18686788325628456, 0.1859919669177128, 0.17384108453346092, 0.16409377167026962, 0.19729566196441284, 0.5273179644890452, 0.8079617857779786, 0.15814756867376467, 0.20952517464428255, 0.21210837936412408, 0.6632882710989859, 0.8022427237459274, 0.20960572390109233, 0.21061760841609012, 0.7550276907335494, 0.7553875830505481, 0.15548355488963206, 0.17982427850113836, 0.19733042119681654, 0.19173217805691345, 0.1855973177790442, 0.1971940990442056, 0.18581682122875953, 0.19797751447115297, 0.1799260559891147, 0.18785519659476635, 0.09117301666734334, 0.09589159252279877, 0.08651303165240987, 0.08807221753465089, 0.0845360944228778, 0.08751244741283914, 0.08713499849056172, 0.08466609270876502, 0.08455805829024043]}, "mutation_prompt": null}
{"id": "38670c04-e9f3-4188-a934-b3ffff4ae85e", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "edc5f0ac-139a-425e-a3c1-cb1f64bd6ffd", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "2ecaa065-d602-44e6-b46e-f4980bf44f0c", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "a49e2854-acc5-4b9e-a6fa-7c0ce0ad6a16", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "aab5652b-082a-4127-9c43-0331f35dd0c4", "solution": "import numpy as np\n\nclass QuantumEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Quantum-inspired mutation strategy\n                    F = np.random.choice(self.memory[\"F\"]) + np.sin(np.random.rand() * np.pi) * self.epsilon\n                    q_mutant = np.clip(a * np.cos(F) + np.sin(F) * (b - c), self.lower_bound, self.upper_bound)\n                    mutant = 0.5 * (q_mutant + np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound))\n                else:\n                    # Hybrid local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    hybrid_mutant = np.clip(a + F * (b - c) + 0.1 * (d - e), self.lower_bound, self.upper_bound)\n                    mutant = 0.5 * (hybrid_mutant + a)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "QuantumEPADE", "description": "Enhanced Quantum-inspired Differential Evolution with Adaptive Memory and Hybrid Mutation Strategies.", "configspace": "", "generation": 34, "fitness": 0.27569021100409047, "feedback": "The algorithm QuantumEPADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9488319265917362, 0.9370820932676118, 0.8189559391100787, 0.7662894090612359, 0.5795367624747509, 0.9414813193351037, 0.7890462198528243, 0.31255002199453097, 0.5673420088268257, 0.10310896701793537, 0.539525374649398, 0.445662342323375, 0.6060623156525393, 0.04641488129575677, 0.10756613318545882, 0.19429018280193844, 0.03256233131028641, 0.07598144556570552, 0.08090201004445752, 0.16041915671235762, 0.1186198753683646, 0.18976461491631202, 0.16128078588111094, 0.11893080763653874, 0.14465390083732144, 0.14254133737896357, 0.13299025729668723, 0.11163750513028159, 0.08248899974349422, 0.11026761259153806, 0.11157056662602427, 0.12323755194842922, 0.10737938440749384, 0.09276798807742925, 0.14401811348420157, 0.08622256388208027, 0.8540878662643083, 0.9134936910069766, 0.9045813727640701, 0.9229375536933392, 0.8926300747354249, 0.9357467401478036, 0.9052854477168886, 0.7615219179766637, 0.9212334783061609, 0.2069573306801299, 0.18371860592749822, 0.4804042894271193, 0.26537517480818296, 0.2881274044655534, 0.24325916892587107, 0.17085106417248785, 0.2048287358882782, 0.43711722831412303, 0.23024063658322502, 0.36959297519473744, 0.39986514829637476, 0.19085178182338147, 0.21531100174365136, 0.21478722935384176, 0.23665681407372408, 0.2294604451843154, 0.2501146741659248, 0.18306363394389158, 0.16818286443346264, 0.3777542724835746, 0.06731825016518922, 0.19845101090516282, 0.16260926029289224, 0.13378830132414476, 0.1371504016243662, 0.27268542822221553, 0.2393701602666587, 0.1534527516955383, 0.15549999629681555, 0.16366892784249454, 0.2005648036255484, 0.2237553326711924, 0.1542367453736817, 0.13702808262556865, 0.16868498612793714, 0.022905601933564168, 0.18371334831749586, 0.01644380755180097, 0.282328835300803, 0.01140554680317507, 0.059517417357948244, 0.06031580078680421, 0.19161414538911348, 0.06762074364051118, 0.20045493933417435, 0.11946065714795862, 0.28706935542878087, 0.10572965654273725, 0.20472001126548234, 0.2615117859640913, 0.4109652685036811, 0.38103326933007475, 0.11707236735248938, 0.11085710454505393, 0.28392228188198376, 0.12513285934884988, 0.11036865283975572, 0.09591016421065324, 0.13885432017508736, 0.257935521895701, 0.12714265507816036, 0.10848617600288668, 0.13925744847130916, 0.08244050294863936, 0.14132153952740423, 0.12864755588561416, 0.08473258089815228, 0.11276021755904297, 0.09130644509337549, 0.13301719737258832, 0.18701773299669966, 0.5502852726336691, 0.6767688561767359, 0.8398074117131178, 0.5124758884655817, 0.5298030670129892, 0.4232561695060343, 0.47976783588923944, 0.590461649524703, 0.533441201111406, 0.1456269673024002, 0.10883403217787346, 0.14601037596929223, 0.16564925392604546, 0.1453717948667116, 0.13878611160752374, 0.14519106859771092, 0.1339717098568184, 0.1247771951772707, 0.277785468320065, 0.35172451488215506, 0.3337910650577991, 0.4611162900053485, 0.17518141033278045, 0.2175238465603302, 0.25694230550724173, 0.4610952635255662, 0.29012017795709766, 0.34860386293279355, 0.29880052982976735, 0.4627895395377185, 0.3213142853692039, 0.5366681293520671, 0.5011989107149011, 0.2153603158114782, 0.3131951035135291, 0.5189105620564101, 0.2301501996231491, 0.2187977309539767, 0.3153268774993184, 0.23300617640168264, 0.3042622898120535, 0.41638388813085725, 0.20677214613740114, 0.21164847517951824, 0.1962838114029266, 0.23078969921031278, 0.20656692827299117, 0.22982192098520848, 0.2359131175405086, 0.22203580017262214, 0.21358991828659946, 0.23217660658650974, 0.20249846253242398, 0.22135365957489828, 0.21239944075164507, 0.21702258695549903, 0.21273991965853778, 0.19419190636535955, 0.202909437989939, 0.18281885238328832, 0.251888023366139, 0.20431715636412406, 0.2315588990266837, 0.18896706885731474, 0.5307069414357315, 0.17709333252914572, 0.1630693635061614, 0.37033922312827783, 0.7128051568063338, 0.943084050924235, 0.16562785437568706, 0.18571192886417043, 0.7008600615929459, 0.15715335252132956, 0.12821479722408735, 0.1694802325629844, 0.21291661279617757, 0.1694283097776088, 0.15676426725653003, 0.1688458228155547, 0.0947752217133162, 0.21267645152822756, 0.19329412124649226, 0.20394498910551107, 0.18693182811423403, 0.18729598068221753, 0.20600307908987536, 0.19510413828459583, 0.1830427315620583, 0.1890019640082683, 0.0936225960223821, 0.08664778925660832, 0.08756293638686385, 0.08877376860609187, 0.09361453197610226, 0.09142299694602984, 0.08672092552973154, 0.09041308164141848, 0.10625741174147607]}, "mutation_prompt": null}
{"id": "54147f33-ba79-40b8-9250-ea16a6f3678a", "solution": "import numpy as np\n\nclass AdaptiveHybridDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Hybrid mutation strategy with adaptive parameter tuning\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.normal(0, self.epsilon))\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    # Self-organizing local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.normal(0, self.epsilon))\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                \n                # Adaptive Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) * (1 + np.random.normal(0, self.epsilon))\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveHybridDE", "description": "Adaptive Hybrid Differential Evolution with Self-Organizing Memory for dynamic parameter adjustment and efficient exploration.", "configspace": "", "generation": 35, "fitness": 0.5126891218131797, "feedback": "The algorithm AdaptiveHybridDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.885142088041214, 0.8785613457860202, 0.8767239045798674, 0.888326364007509, 0.8893973980690845, 0.8926766371293078, 0.8899229603834257, 0.8905883024654033, 0.9008098883191917, 0.8114208447551047, 0.8165532547538497, 0.8237694090882448, 0.8049895512785898, 0.7810209425266955, 0.8006573912183318, 0.8003990780197112, 0.7949913075675896, 0.8031080037091098, 0.13289431421352715, 0.13424894486683603, 0.15860717250467748, 0.15856361583389222, 0.1240715221978651, 0.13358043726418456, 0.15608141563085942, 0.15289801248278712, 0.12600050836309906, 0.1186285743426071, 0.119931631060479, 0.12329649376942742, 0.12528715126303291, 0.12940231020373139, 0.1264774435021203, 0.12860159625070322, 0.11182237611562684, 0.12325791042811196, 0.9838193160044296, 0.9960770455156683, 0.9764283737413652, 0.9867098099955193, 0.9753098914693172, 0.9799877170495512, 0.9763083933434225, 0.9623151405861021, 0.9797313861613727, 0.7375125585081295, 0.7091175867318705, 0.6992520043545916, 0.734743790825342, 0.732520091958135, 0.7071006324112821, 0.712021656241604, 0.7345458008143154, 0.7211728215094843, 0.8424540465018968, 0.8727037281726135, 0.8760034943152595, 0.857297164373939, 0.8820367162275398, 0.861427132994749, 0.8674648239057983, 0.8988419672072762, 0.902200536105645, 0.6440113335973532, 0.6880858334291036, 0.5844234956130783, 0.5834384889801674, 0.7084198334317519, 0.5106646461322257, 0.39954003667425664, 0.13129507222385817, 0.5259435876261505, 0.6526690945659492, 0.6236387496636471, 0.6110400631761199, 0.6854027051298668, 0.6953939556621498, 0.5919722660520457, 0.6093882438787147, 0.589283934284494, 0.6318588473444497, 0.643899651663721, 0.7203362298002625, 0.6506061984206286, 0.6681238976057895, 0.7340396534583049, 0.6688925914427974, 0.6581534712229139, 0.6760890890829067, 0.7506411066070434, 0.7267425846600405, 0.7557646945095997, 0.7832719977059812, 0.7745328361359753, 0.7509599662544726, 0.7129146965994277, 0.7539879001467684, 0.770084442228463, 0.7340743914942798, 0.4424563209497203, 0.11819206766119494, 0.5207809036540372, 0.2921120751745899, 0.14710539010625256, 0.5716947919261577, 0.2946884215244636, 0.30340389453468053, 0.3299411043250039, 0.5962752285524723, 0.6958120060250312, 0.6158377145732234, 0.6513480314172562, 0.5676167051274612, 0.6575601291464437, 0.6226004156905764, 0.6918034547412707, 0.5167333947639067, 0.8347115998759588, 0.8585391039553066, 0.8522478540796107, 0.8134713166426549, 0.8436590944557187, 0.8190106096690268, 0.8661814394547145, 0.8356843095732225, 0.8647567727716825, 0.11817770009359885, 0.11386294306053191, 0.11258300489688877, 0.11173032719994758, 0.10796973330512816, 0.10594805318728273, 0.11392925729006276, 0.09886970931131822, 0.12863340150524005, 0.1507169918682847, 0.1534821778017329, 0.1570236410091287, 0.18268378040405298, 0.2069829364612834, 0.2528746999256837, 0.2837659434958094, 0.21848458002748572, 0.20896097805266245, 0.6753183004432013, 0.6989130373223174, 0.6638674058714435, 0.6565250668834923, 0.6594349823665306, 0.6383775493094761, 0.667399001809267, 0.6196125158324017, 0.6598203641908981, 0.46059060252378237, 0.5853551844388053, 0.4843179157267624, 0.43885688878096607, 0.5784201247397145, 0.45488656403913763, 0.49487056193625056, 0.5473407027995327, 0.5407332310148193, 0.19483728138274337, 0.20129987677149797, 0.18148320768667692, 0.21636672060996776, 0.20305786304705076, 0.2056345308693962, 0.2021785468062831, 0.198167699493502, 0.20282889016580108, 0.24389895823532926, 0.6859573649607719, 0.5294248959374035, 0.23430448040278373, 0.22484960831844703, 0.26832305883058205, 0.6005645148151602, 0.22891283173103216, 0.2007952140270166, 0.19619545347648448, 0.14642591453674836, 0.16312656753858468, 0.17793259891629698, 0.8041885191027675, 0.8658606333449028, 0.6666031512876691, 0.8555483619587356, 0.8699689071301067, 0.7915997163480639, 0.8433225657431069, 0.736551476732703, 0.8091002915986286, 0.8390626184141581, 0.16856772316940716, 0.21079278129368662, 0.12798875062932824, 0.16791094143306895, 0.18874453553904946, 0.20732752781225505, 0.1751770564014452, 0.1900548405437018, 0.1940813559249882, 0.1880710008073474, 0.21177796195028542, 0.18088865149694888, 0.18624840867309, 0.0838537006661616, 0.08753996210454784, 0.10235356846837762, 0.09062617953991303, 0.08996703246383908, 0.08801945317160076, 0.08764216538614122, 0.08359106470718491, 0.08831000442468029]}, "mutation_prompt": null}
{"id": "1d47b1fd-4dce-48fa-b46e-7be097ff56c2", "solution": "import numpy as np\n\nclass RefinedAEES:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                # Adaptive mutation strategy with crossover adjustment\n                if np.random.rand() < 0.3:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Dynamic crossover strategy\n                CR = np.random.uniform(0.5, 1.0)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedAEES", "description": "A Refined Adaptive Evolutionary Strategy algorithm with adaptive crossover probability and neighborhood based mutation to enhance exploration and exploitation balance.", "configspace": "", "generation": 36, "fitness": 0.4492991407751149, "feedback": "The algorithm RefinedAEES got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.27.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.8688222478414114, 0.8691182266670665, 0.8747405020209065, 0.8760719297693662, 0.8753569768782405, 0.8852719414524235, 0.885019141398221, 0.8803252895136322, 0.870723036064142, 0.7667475730548794, 0.7695964089697085, 0.7580368296730748, 0.7718404540821909, 0.7696267665151959, 0.754461209472401, 0.7733239373202563, 0.7379438586119306, 0.7668446086817735, 0.46578062549103627, 0.4750182048524605, 0.4882804272107988, 0.46266194132615335, 0.4912232452112434, 0.5335170430246302, 0.32784023243944893, 0.41397396864336733, 0.17288474908585594, 0.13985300577243265, 0.13109838194549706, 0.16016710784662413, 0.12636103868194992, 0.14516934363897616, 0.14465818547934228, 0.16940824688475764, 0.13261345857047713, 0.14570672172517551, 0.9776237175309854, 0.9730621434352836, 0.972082708563266, 0.9730940446466806, 0.9854463725016767, 0.96346253712845, 0.9642641833199984, 0.9767183447699515, 0.9824521424662378, 0.6303838486883631, 0.6108541805971655, 0.6309921020028205, 0.5800848818191779, 0.6603231073808051, 0.6118660857658687, 0.5735797593209048, 0.5471119846795047, 0.5982780523318821, 0.8498097867118767, 0.8096440638142544, 0.8435282548607542, 0.8412552227888649, 0.8508583679553684, 0.8153725219620639, 0.866600960394273, 0.8120015687380778, 0.8325273566280181, 0.49475499248707866, 0.30053754340441374, 0.43335646173060427, 0.4068012984106988, 0.4671517461178438, 0.13235050714796748, 0.46941756545363544, 0.498036102312735, 0.45244545743276987, 0.38148680737800944, 0.1182667226395997, 0.36004615090469827, 0.4089114247182999, 0.4010008822896659, 0.42938092482640045, 0.3165227091710471, 0.12935094905849198, 0.4121669894458867, 0.4041716700120189, 0.48264551571682035, 0.3298299326551135, 0.40855620165023276, 0.4741233946215958, 0.36840199022026465, 0.4563699061025188, 0.42800524675693175, 0.3758359646013456, 0.4985134656780391, 0.581580187900298, 0.5803221073232911, 0.5288087693189449, 0.5948976892802829, 0.5102636093113192, 0.5437168617597581, 0.6187011655185154, 0.6090120229624044, 0.1654421157115572, 0.28977473560369105, 0.27032249229251193, 0.21765468323758197, 0.17418129129413062, 0.20422753156867035, 0.24490014701440688, 0.21311290209716716, 0.27261252975360917, 0.35267914267449585, 0.3684436941053816, 0.36398896854587237, 0.3814872903580796, 0.3751071982210482, 0.331841455182292, 0.35491542889065475, 0.3743835086034979, 0.33870473944282575, 0.7452295103659745, 0.7890860702442573, 0.761951915380261, 0.759663783798926, 0.7567817333879239, 0.7360075280213447, 0.7890139602893392, 0.7796619150311779, 0.7568776508059287, 0.13107091485104372, 0.12204193888887549, 0.12201763106910835, 0.10643306467812585, 0.12611620815982372, 0.1256155668513086, 0.1203962830631905, 0.1129191205331106, 0.13937602352942435, 0.266693871845308, 0.14980019707323622, 0.20119885518310643, 0.1910028920717799, 0.18097435084995372, 0.15667418887698714, 0.1377872125432199, 0.1877565642446012, 0.1747393365492217, 0.5427995259562512, 0.527737188991811, 0.4925419847902168, 0.5800085467346268, 0.522782972518238, 0.5785533208737682, 0.5508485916558764, 0.6239352881544744, 0.5974020758391543, 0.3740978229596491, 0.38880698677710035, 0.38487895926445126, 0.4454027196960888, 0.4287543856106968, 0.3906574424161231, 0.41937227587671777, 0.45206797557007816, 0.4139135077282188, 0.1968454925584311, 0.22600670390609334, 0.19224685210582304, 0.18740317707711074, 0.2097099625897607, 0.18975252037724144, 0.2101153624562364, 0.19945717917922823, 0.20377747637646815, 0.22534102782213994, 0.6330331136108387, 0.35285807326791097, 0.2138529554789823, 0.20923300989057791, 0.4881325677907522, 0.6635452482965074, 0.2107236709841933, 0.40946511620011294, 0.802378468602492, 0.18403023661491247, 0.17080402457453125, 0.8697676363306022, 0.16320502544545035, 0.19579908728052842, 0.8316499651859789, 0.8716879607581814, 0.7265193662732872, 0.7358547601941007, 0.21384699738448965, 0.20999778312367945, 0.16599405874117623, 0.7788370758863796, 0.7128549617877477, 0.7711556817244347, 0.1533735468961024, 0.15427357227927696, 0.18760444514167007, 0.20309089614959797, 0.191221150130215, 0.17109429873281512, 0.20424715212613742, 0.18547064702036464, 0.18637110386618716, 0.18090508533088245, 0.18027837728317497, 0.09823766737365835, 0.09074168679147931, 0.0809552165312285, 0.08818114581469672, 0.08492104189150251, 0.0820573513224725, 0.07578131268663979, 0.07873049138471921, 0.09085980165887453]}, "mutation_prompt": null}
{"id": "c1d06dda-3b0a-4fed-b2de-918a5aedcb98", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "aaa1bbe0-5e11-4ab9-9285-bac1730c30fc", "solution": "import numpy as np\n\nclass AdaptiveNIDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n\n                if np.random.rand() < 0.3:\n                    # Adaptive mutation strategy incorporating dynamic parameter tuning\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.normal(0, self.epsilon)\n                    mutant = np.clip(a + F * (b - c + 0.5 * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    # Enhanced local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.normal(0, self.epsilon)\n                    mutant = np.clip(a + F * (b - c + 0.3 * (d - e)), self.lower_bound, self.upper_bound)\n                \n                # Crossover with dynamic probability adjustment\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.normal(0, self.epsilon)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveNIDE", "description": "Adaptive Neighborhood-Inspired Differential Evolution with Dynamic Parameter Tuning for Enhanced Exploration and Exploitation Balance.", "configspace": "", "generation": 38, "fitness": 0.5103033543882071, "feedback": "The algorithm AdaptiveNIDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9060263023243313, 0.9088763202721624, 0.9073500275071356, 0.9015118772641849, 0.9093521357207195, 0.916818145087657, 0.9132616537396694, 0.9060367581872213, 0.8970917313554334, 0.8225080527630283, 0.8246471009524214, 0.7600213675345373, 0.8271046679917415, 0.794939967730923, 0.8414418340749024, 0.8523314476795171, 0.8217338856170981, 0.8313276572922979, 0.15379515841221436, 0.4102188179486499, 0.12309860644870207, 0.13703783962879024, 0.34899171724384537, 0.12250297294389478, 0.5127571319709839, 0.12517640142949382, 0.17739867804084475, 0.11191593048962967, 0.12473312566370864, 0.1102916470851234, 0.1279045006704762, 0.11808326706450423, 0.10535828117110013, 0.1040876012050469, 0.10848804800156353, 0.12342979892323835, 0.9798405332034016, 0.9467849452120253, 0.9789597708358514, 0.9753512591138661, 0.9637220485119027, 0.9841232511195399, 0.9714139014385331, 0.9446740323396207, 0.9849314578809468, 0.7292566355321227, 0.7346469266084413, 0.7126545216774255, 0.7519303883089948, 0.7137972732121121, 0.635851740759068, 0.7215058310255521, 0.7656108361732614, 0.7963732570514317, 0.9021402353449725, 0.8627969999087926, 0.24951700514560438, 0.7085082244527099, 0.9191237217161714, 0.9030326617005431, 0.8731517390457144, 0.9018536058637203, 0.890636445528811, 0.5458571735689435, 0.48824018721128104, 0.1975740915878238, 0.64649399213848, 0.3483348171863059, 0.6678581697533861, 0.7411865479538631, 0.585899734082584, 0.2992528307870195, 0.4907026033864955, 0.6303026038236179, 0.13049532271061803, 0.5750678197961607, 0.7434824493985153, 0.6218078839801012, 0.3848969761008404, 0.6840460201930417, 0.4526765125720369, 0.7982309824393872, 0.7406694728955345, 0.7272765729744354, 0.7168409855816622, 0.6947812565338336, 0.7283040344991907, 0.7269467975012301, 0.7338566882598998, 0.7022849588305234, 0.7714164931556833, 0.7222997250512022, 0.79064092094555, 0.734235006785123, 0.7807883314743008, 0.8021547801620847, 0.7909602151674012, 0.8126822851750922, 0.8178622642213887, 0.25501954490445156, 0.19141549649571754, 0.46564314789012073, 0.7118505011940551, 0.7250381308238165, 0.4254641325088918, 0.337457148530802, 0.31253570294104405, 0.347826661355889, 0.4367255246032892, 0.5340205593314917, 0.667446892532943, 0.7427413368078551, 0.6836219953525489, 0.6863765668802788, 0.5401735296182766, 0.5047912797503182, 0.7441726848291224, 0.8713149965995147, 0.8642046873868673, 0.8322214443480204, 0.8581780425222674, 0.8858012049377794, 0.8610184600168667, 0.8676482527967772, 0.8423046227989536, 0.8393927098881152, 0.15239340608376295, 0.09416961481161579, 0.10626637587836629, 0.1388878391067967, 0.10064788558701698, 0.09855232681831583, 0.10833456624769988, 0.12846845093225967, 0.12326035908800492, 0.16278982886637527, 0.18574937234332267, 0.3913136399104644, 0.1340127025392227, 0.7841140816628442, 0.2069713544863392, 0.22789663736035726, 0.19474638150032586, 0.22773390878581312, 0.7173515500302963, 0.643166471346559, 0.7081814011304092, 0.6561529859317438, 0.6682393715276695, 0.6228337169081886, 0.7256138327931707, 0.7457602999987998, 0.7574741449695417, 0.5447018287511043, 0.6112625402969118, 0.5062477259126481, 0.5894607746968303, 0.5466798149863877, 0.5742059193853299, 0.6144985607773362, 0.5145478135908508, 0.6889542995566744, 0.2269800876188499, 0.20061625206009592, 0.189878957419639, 0.19801144336637666, 0.23547876328806483, 0.20772686494049442, 0.20551689638741388, 0.22046414293219274, 0.21119118863607778, 0.23313353643572032, 0.22888644334162223, 0.21375154045417344, 0.2264392276840308, 0.5403076644137326, 0.4561005308621747, 0.23705191738025722, 0.42989712894550625, 0.5413149661213394, 0.1836727567951677, 0.926712069240339, 0.15179312817777846, 0.17805736760177404, 0.16223285269352616, 0.16737958652225038, 0.16540738323126203, 0.8700187331305655, 0.19760285010115997, 0.2065830134809602, 0.21064377490010433, 0.1264260595554011, 0.20455993334889433, 0.20774219357879642, 0.8567884410304596, 0.2134258005334515, 0.814009375849755, 0.8727506824485993, 0.19486474887263416, 0.17773467264388232, 0.17157740794758813, 0.188826948921479, 0.18184128045340886, 0.18274363097134794, 0.20183597801635023, 0.1893253698852143, 0.1910196865187066, 0.08140616884878804, 0.08339566814037136, 0.08930520743822057, 0.09416742531474542, 0.08035999362919644, 0.07928896729824009, 0.08541394093453969, 0.09159317996523064, 0.08997646126676462]}, "mutation_prompt": null}
{"id": "ee21e4ac-fd32-493d-b1f1-d175f33a8c19", "solution": "import numpy as np\n\nclass AdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Adaptive mutation strategy with memory-enhanced influences\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Dynamic local learning strategy\n                    local_best_idx = np.argmin(self.fitness[indices[:3]])\n                    a = self.population[indices[local_best_idx]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveDE", "description": "An Adaptive Differential Evolution algorithm with dynamic crossover strategies and memory-enhanced mutation for efficient exploration and exploitation.", "configspace": "", "generation": 39, "fitness": 0.5145832248741387, "feedback": "The algorithm AdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.29.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.8908617724681552, 0.8879707655041574, 0.8784322079921838, 0.8918433633702337, 0.8788832045458456, 0.8874827801399964, 0.8908140378318028, 0.8881190876916744, 0.8859339831150214, 0.7913250343443892, 0.7937361229805873, 0.7966657047037327, 0.7979276922785465, 0.8014462185886277, 0.7843885771778473, 0.8102425708595051, 0.7860056978706702, 0.7616718014437553, 0.16224088023994776, 0.17367784524477425, 0.17758999549374277, 0.1519786063613967, 0.13286106251922447, 0.16687052470035302, 0.17835748902869653, 0.16470376450043, 0.5853741018883722, 0.13042615910575095, 0.15061808043376146, 0.1225037824862818, 0.1077714422606123, 0.12623241086623604, 0.12117305824475966, 0.122862674015071, 0.1466327489015533, 0.13146723990318265, 0.9852742014313047, 0.9767260114017804, 0.969065934101691, 0.9798715037427745, 0.9634884743506746, 0.9867265445585195, 0.9921338911470535, 0.9677691844864504, 0.981947490828934, 0.6154636458045195, 0.5814074170984961, 0.6715041093896555, 0.721909989842209, 0.6548985701724425, 0.6563303371974367, 0.6283601658729151, 0.6768378236580292, 0.6732518102446049, 0.8715745693315731, 0.24201431254560157, 0.9095331275633766, 0.8878365203919809, 0.9065008496018646, 0.9108376958586515, 0.8975983329033961, 0.8477310646804637, 0.9137672036429463, 0.47791335867219864, 0.5204056100743515, 0.130362717193511, 0.4657643693754058, 0.5981564708211409, 0.6367969560072163, 0.6896115078675343, 0.6806141262590033, 0.5939457453021961, 0.5885089030828441, 0.49755196816905256, 0.5330260685103895, 0.4541988683951641, 0.448519087880656, 0.4793255843106109, 0.5352285114487201, 0.6571616107994378, 0.7492942552561439, 0.7561917442381576, 0.6354521224290988, 0.7259678625277414, 0.7119227238953627, 0.7151324892007623, 0.615349040117914, 0.7614889046757243, 0.7211815770096014, 0.5935208985338596, 0.8238199512123968, 0.7533247866737971, 0.8162556500296086, 0.7756872670329347, 0.6671232097458981, 0.7832229894804121, 0.7729524077280774, 0.7913142928252812, 0.768981257895918, 0.5109633438300749, 0.2553002579651841, 0.5299283290535228, 0.3012062172107317, 0.6505776111083741, 0.2532209765679383, 0.2364657184731752, 0.3610097939541369, 0.3846504207051967, 0.6534662795993553, 0.6542677276737773, 0.6813301928052922, 0.662312957240716, 0.6449043332885416, 0.6735647622546832, 0.5821682072081393, 0.6719061959895962, 0.6357721768055767, 0.8611380716856176, 0.8595152090506316, 0.8350498292750849, 0.8625440567908316, 0.8612640319627242, 0.8527987638250053, 0.8483029681679257, 0.826624836691042, 0.8561946871859124, 0.13694708690674506, 0.15213266877358367, 0.15013399764743296, 0.2799441238949597, 0.1763857142461277, 0.1422978071934745, 0.14218140367419796, 0.14537748549521912, 0.13592945724294203, 0.18249488336920028, 0.17079005783656453, 0.16748024233875225, 0.37751557989993056, 0.6152333030398216, 0.18725494779584706, 0.1533691017595209, 0.20652040545348926, 0.21490436337612007, 0.6919432365611483, 0.6539472519547738, 0.5895052855492293, 0.702008193313763, 0.6877593510642241, 0.707165557929198, 0.6900078951999211, 0.6690229805216925, 0.6898632923257166, 0.4914525912411908, 0.5488188025485122, 0.5619255934756504, 0.6337217283371495, 0.5920713780611604, 0.6427280324576754, 0.5051866328848786, 0.6241782946596462, 0.48699865767112804, 0.21846500294811688, 0.23464895461416968, 0.19313023885868885, 0.22596721141971843, 0.22307704037164522, 0.21400400506870176, 0.24172563111427392, 0.21721254767308673, 0.2172677342561794, 0.20477920578144926, 0.6607867706537532, 0.18248921738376145, 0.21395183118636263, 0.23800434953167848, 0.18736793845387634, 0.22885249605494007, 0.21216691278904054, 0.23787896086865024, 0.1854474785814324, 0.8859284296962421, 0.1517427174202336, 0.8585057033981156, 0.8285661503129979, 0.16766375170613868, 0.7801799394915324, 0.8555511868257687, 0.8591706303625753, 0.16765177416600274, 0.8491616201352543, 0.8379948171668073, 0.16902718970477304, 0.19813847952928765, 0.16771594787066135, 0.1525714557787693, 0.870191281734817, 0.2101581776017779, 0.1782468208663659, 0.19853112974532428, 0.1823382320610093, 0.17469084595455697, 0.19198207559142255, 0.1822423625935865, 0.1830868680348532, 0.1884343696177082, 0.18187974791660633, 0.09966776357260843, 0.08620404954664851, 0.08976106961094699, 0.10109235595751054, 0.0799177593329694, 0.099999090155233, 0.09478342723411315, 0.09147555097483151, 0.1341267658386579]}, "mutation_prompt": null}
{"id": "ab31c187-67fd-430e-98b9-f0782bdebb39", "solution": "import numpy as np\n\nclass ImprovedRefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F_base = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F_base),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Adaptive mutation strategy with enhanced memory utilization\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.uniform(-self.epsilon, self.epsilon)\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Diversified local learning strategy\n                    local_best_idx = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best_idx]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.uniform(-self.epsilon, self.epsilon)\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover with adaptive learning\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.uniform(-self.epsilon, self.epsilon)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedRefinedEPADE", "description": "An Improved RefinedEPADE employing adaptive differential evolution strategies with diversified mutation schemes and memory-based learning for robust optimization.", "configspace": "", "generation": 40, "fitness": 0.5160354135951286, "feedback": "The algorithm ImprovedRefinedEPADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.30.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9138169955363511, 0.9013418500455109, 0.9013971614884682, 0.9089561598061465, 0.9037492816802124, 0.9150495271927983, 0.9045813328535939, 0.9010255335886669, 0.8858236513704161, 0.8241370094536538, 0.8339292281852628, 0.845957789864097, 0.8291389823312337, 0.8432341930266289, 0.8176248837526994, 0.8029185903391682, 0.8204421825601261, 0.8312729656921442, 0.16205231385909424, 0.4902554163748165, 0.1507386379170761, 0.49170358940095804, 0.11719026005362576, 0.16017193966267862, 0.5689300601323546, 0.16766533515091175, 0.15608477462789472, 0.1080837322831596, 0.12126039802063604, 0.1428950904777877, 0.11458846376594267, 0.14569545981843546, 0.12320333536654393, 0.13703662103956415, 0.14627273221044235, 0.10765654666886637, 0.9727561626274802, 0.9892032622424215, 0.9670113620032326, 0.9510736061300483, 0.9428841570401068, 0.9884293554602287, 0.9869068416022378, 0.9614718730029562, 0.9842661520544328, 0.7537189984324935, 0.7769190947770024, 0.7297373881995831, 0.7662115865489701, 0.7526943318279982, 0.7438286201362283, 0.7298166485999114, 0.764864195089688, 0.7554433390131955, 0.9005284957207501, 0.8963182529572133, 0.913577979417246, 0.8821549038687351, 0.923965193051578, 0.884584219653157, 0.8621441437283798, 0.8989836764023257, 0.893852947796988, 0.5790079479505261, 0.5355914713256078, 0.5984574678802186, 0.6277904495108726, 0.13492166669589278, 0.5588068743906894, 0.47993555744787764, 0.31182103627853064, 0.5399028334928069, 0.5049550547435397, 0.6471561494825242, 0.7165361453782682, 0.13350400357958625, 0.649769279962231, 0.627709536521017, 0.5734000548142191, 0.5594079572281359, 0.41515151752614743, 0.738106773971378, 0.676128726595649, 0.5384915513732411, 0.7192112514578316, 0.5920033635053861, 0.6865038353770146, 0.7355183179598795, 0.7073881098643783, 0.7197263590234286, 0.7971972877328055, 0.7668184602881583, 0.7552910041770629, 0.7690124281006456, 0.7515781960635136, 0.759325034417246, 0.6906519556869781, 0.7956783226139834, 0.8112031938513604, 0.19115479484750775, 0.3819364846766886, 0.42383169792884534, 0.5766841597584806, 0.693791274152747, 0.6038034402923235, 0.27618834906826817, 0.3918007150941053, 0.13035896081674614, 0.7116181594645505, 0.736088809640694, 0.6171213193878389, 0.6959963846004531, 0.711148371401818, 0.6617674445713371, 0.5409390960702489, 0.7007429452533982, 0.5743001596003586, 0.8569584527654092, 0.8760477805839404, 0.8680720355070923, 0.8724560942737709, 0.857744804661188, 0.8688873248425955, 0.8555328097712406, 0.859407536648393, 0.853812582582624, 0.16952685565079906, 0.13722910428137292, 0.13122783249303993, 0.1435437770869974, 0.13581097206618487, 0.1392207878376357, 0.12219600946484166, 0.12029449166407247, 0.13169485431661998, 0.6191754934245847, 0.24730434173118676, 0.14753297471704485, 0.26400121861377157, 0.28711762268573204, 0.2206721727988893, 0.7434828060430572, 0.49595240914299443, 0.1696843345240433, 0.7048227990763594, 0.5384210150033244, 0.6695846443748672, 0.7029802586385665, 0.7287207625262384, 0.7485110622613986, 0.7114899033513791, 0.6929834295397019, 0.71692260985629, 0.4986937530446315, 0.5716001451677857, 0.6560554282972537, 0.5834188603748237, 0.5623979883160867, 0.596642499526615, 0.5898881435023453, 0.42611593800855385, 0.6637033466771373, 0.20751308886965691, 0.19675042627432948, 0.20459705735645528, 0.22951085266777405, 0.23297098074491318, 0.217266118042291, 0.19424024701266485, 0.2165558237944356, 0.1919291356931303, 0.6469646295299356, 0.24057279699070233, 0.5353278944317492, 0.2412445080920791, 0.6616617101893799, 0.21458896740305644, 0.20587651042866195, 0.2189739269966693, 0.20183379722663908, 0.1723031268569084, 0.166640812477177, 0.1518321483594931, 0.17550493850966287, 0.16859755104210128, 0.17674348619022806, 0.17592899044389743, 0.9097056678968248, 0.17042447728712473, 0.20968339423343785, 0.1689489680751698, 0.7988578222989976, 0.7635383238423817, 0.20771129297377655, 0.7310152500767649, 0.2031965499154591, 0.12804009366507596, 0.21359224160003865, 0.19548408041553544, 0.19983516922972022, 0.1847352148189455, 0.17618910126334286, 0.19160488029171796, 0.19042384930377043, 0.19665358047783787, 0.18063522093638495, 0.2019316048938845, 0.08617807751837647, 0.09319674315059367, 0.09813103842189974, 0.09429613758680211, 0.09064226276242493, 0.08258822080273398, 0.09292898819712658, 0.1069489944731562, 0.10090194091440641]}, "mutation_prompt": null}
{"id": "f0bd6050-50c2-46ba-8fb2-36f82ea793e7", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "5cca912e-9b45-407a-aa79-36e73e729aad", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "9d4f84d0-b3f1-42d0-b4d3-82c8adcd3668", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "8668ad3a-125e-435c-869f-6b5247217ea7", "solution": "import numpy as np\n\nclass ImprovedAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.base_cross_prob = 0.9\n        self.base_F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.base_F),\n            \"CR\": np.full(self.memory_size, self.base_cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def adapt_parameters(self):\n        return (np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon,\n                np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                F, CR = self.adapt_parameters()\n\n                if np.random.rand() > 0.7:\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedAdaptiveDE", "description": "An improved adaptive differential evolution algorithm with dynamic crossover and mutation probabilities to better explore and exploit the search space.", "configspace": "", "generation": 44, "fitness": 0.32836155634631886, "feedback": "The algorithm ImprovedAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.22.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.6894905969711838, 0.7090514882576163, 0.6957942918953683, 0.7383799105918651, 0.7513674077896889, 0.7207008054230398, 0.6937260021884855, 0.7370515930400076, 0.668661813361275, 0.43183679340667225, 0.40634788793967436, 0.5011453888163158, 0.46994536391374486, 0.5094500787274048, 0.48666715289637164, 0.4656500210383623, 0.5229173100784614, 0.43239105587325855, 0.10305814952447034, 0.11716540591197211, 0.11214295051102363, 0.098629710721582, 0.09864108690605677, 0.09841214521735075, 0.10225668304691948, 0.10636224625477231, 0.09118375081895103, 0.09406057405168089, 0.0937074081571474, 0.08896913023332487, 0.09284765265030259, 0.09220585086380939, 0.08488366027975458, 0.11507285849024917, 0.10340300575670791, 0.08718576353573537, 0.8491864815854813, 0.84992272714122, 0.898426384186905, 0.9548341843104928, 0.9292143901685507, 0.8068700862423948, 0.9716010818079005, 0.8485545612166701, 0.9848437959021533, 0.3697817780624729, 0.3765170517254435, 0.34557554125150436, 0.35479887623194584, 0.3281469470186016, 0.33457334281733286, 0.3846037157309059, 0.38136423460618896, 0.3288780495723237, 0.7000195048834962, 0.6534331474355497, 0.6682983786070651, 0.6843898691526307, 0.7143142850791804, 0.684895016932877, 0.697372118464179, 0.6526357007601551, 0.6145401854948292, 0.29171538661052554, 0.32280963722949296, 0.2943558829501757, 0.32940632383126434, 0.30136698628723235, 0.22354273812774494, 0.34439527141096926, 0.3539169381688916, 0.27293300779095553, 0.29774188847752636, 0.2782920758707924, 0.31170854150950567, 0.2682343242390529, 0.28953013602939626, 0.3299771643025632, 0.23668448139897846, 0.2927234861049839, 0.29968525907758414, 0.36856310488504973, 0.26356572029405556, 0.2898822364310737, 0.2849899580854869, 0.3656955530352035, 0.2916832523048878, 0.321002509201866, 0.30871847068954616, 0.2460550733104857, 0.4544316245201768, 0.4136958647556086, 0.4903656168813373, 0.4289122666626727, 0.4135026013981312, 0.4338398797390559, 0.47213866881152766, 0.42835386288318855, 0.45228302676508025, 0.13609308533334175, 0.09187300744276816, 0.10114627745692795, 0.19405471951047115, 0.0995454090513882, 0.1247001489870978, 0.06780768292688011, 0.1096324758449182, 0.06983039361873467, 0.25353063343865523, 0.25553753034963134, 0.23733577712287957, 0.26956755081018935, 0.27107285856194985, 0.24297411159711269, 0.25340475698018117, 0.28781069800195613, 0.2725088044902726, 0.6229821928122539, 0.6024294001386542, 0.6010455081649178, 0.6182683026926292, 0.6259028949799111, 0.6673482888068075, 0.5796163758175865, 0.6083571765142688, 0.6084998753672998, 0.09847718456830767, 0.08635905262055799, 0.08515203327441301, 0.08556705140399423, 0.08502291611808122, 0.10977642126959386, 0.11327415159070786, 0.08892205180968538, 0.07998165369375587, 0.15635088334060487, 0.27346030272928956, 0.14557439967528407, 0.13909758892554547, 0.1538798529978478, 0.1426911275630931, 0.1352781335522657, 0.16451441441538683, 0.1653759319482042, 0.3466873836526765, 0.32714423131754466, 0.3191297492630494, 0.32151448679495775, 0.3160356802648795, 0.3141934392012138, 0.31251606929599496, 0.30443017057310384, 0.33987763219133516, 0.25336664198647885, 0.25312809181724816, 0.24187787076804967, 0.2531787118062925, 0.22644133373644204, 0.248153650197649, 0.26738964482072425, 0.28046013206374865, 0.27050228365539475, 0.18266383416663012, 0.1939088829186859, 0.18434072696746784, 0.18058753317589016, 0.19257884831630845, 0.19300257360226936, 0.188123179115412, 0.19316990426122638, 0.19184334938104763, 0.17471066547064495, 0.1845086353779155, 0.17596558289259268, 0.18353704980201602, 0.20049591318970494, 0.17279879357970263, 0.17568232895714375, 0.17136629871178555, 0.17506468770129746, 0.6918663302442558, 0.1650805084606931, 0.7251275101373361, 0.16393816526267235, 0.16262677073228005, 0.19780520026521686, 0.4408923416553169, 0.6000931275163779, 0.15806373309538413, 0.7359361354141634, 0.20190424736957124, 0.18661699066775883, 0.1897026817368337, 0.5552232819308255, 0.3808196502181499, 0.5298379077815005, 0.20611601723584805, 0.6960316445502137, 0.19356852150921156, 0.1964158770051666, 0.18367338192422777, 0.20217593918727117, 0.17823933711216944, 0.18300598534783907, 0.17815586145990914, 0.19711093147900316, 0.19946785592735983, 0.07916066290076673, 0.07745645194042394, 0.07448181291920808, 0.07525875670842108, 0.07456780553418307, 0.0733757338447173, 0.07965596937418484, 0.07825519739740538, 0.07732751404704563]}, "mutation_prompt": null}
{"id": "ae6556a0-e00d-42d6-b4ea-b43bdf7ebb1e", "solution": "import numpy as np\n\nclass HybridAdaptiveOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 8 * dim  # Adjusted population size\n        self.memory_size = 8\n        self.base_cross_prob = 0.7  # Adjusted base crossover probability\n        self.F = 0.6  # Adjusted base mutation factor\n        self.epsilon = 0.02  # Adjusted epsilon for mutation variability\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.base_cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Use competition-driven adaptive mutation\n                    F = np.random.choice(self.memory[\"F\"]) + 0.5 * (1 - self.fitness[i] / np.max(self.fitness))\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Utilize adaptive local learning\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover strategy\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveOptimizer", "description": "A refined hybrid algorithm integrating adaptive mutation and crossover strategies with competition-driven memory updating for dynamic convergence.", "configspace": "", "generation": 45, "fitness": 0.41493783572590065, "feedback": "The algorithm HybridAdaptiveOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.41 with standard deviation 0.27.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.8549613503303883, 0.8747423364682082, 0.8650372687536916, 0.8518767631928644, 0.8643195949796624, 0.8682735321348719, 0.8795029419870499, 0.8631023032719489, 0.8732026266100603, 0.7428240571912721, 0.7051198232559356, 0.7471631891347652, 0.7367569049170122, 0.3339215994559487, 0.7429932136526942, 0.7890220498017866, 0.6838535015005509, 0.7426942770604213, 0.16262225261840269, 0.36638540711277834, 0.16360749748858783, 0.1560648313688141, 0.16682711445125553, 0.3358352223588881, 0.15282856633182995, 0.48656907643896163, 0.16333986243316156, 0.12906050016181525, 0.13578047766958135, 0.1440828746362709, 0.14887058239865347, 0.13004594125540303, 0.11865384877306828, 0.14604627529908376, 0.12827253839797026, 0.14285249889012175, 0.9855203036827205, 0.9767060372383729, 0.9808505521966985, 0.9915045845423259, 0.9812065682072747, 0.9826324390906318, 0.9944017393325688, 0.9941325057027166, 0.9874674085817782, 0.5696619598641064, 0.4069348039710662, 0.5251439882335311, 0.6034096415690553, 0.5498387719757281, 0.5631508317155608, 0.6072067074577688, 0.5633772308437964, 0.5610575920094133, 0.7410773264767505, 0.7616865548249614, 0.7130379206031692, 0.8127563136700858, 0.7961772261840954, 0.7335728887315283, 0.8156269972705229, 0.7762390866128877, 0.7563038661242348, 0.4978024371173546, 0.367888575499566, 0.4371999961220543, 0.5252063719237587, 0.46159512234963485, 0.5047700076286377, 0.46328539148983217, 0.4613200526822753, 0.43989071670762137, 0.5469237490497796, 0.49346654390782274, 0.39804542771361595, 0.5513102681488521, 0.4026383681939846, 0.3002453236291388, 0.5214697213611109, 0.4114017792105489, 0.3605427375623823, 0.36542837066708067, 0.17654008301796842, 0.33656588066908666, 0.2147843075968967, 0.14697802954657802, 0.2084639033137513, 0.3602135367267455, 0.22491713551895987, 0.21346912699695453, 0.33422152742973976, 0.35503689306233, 0.3117035429181382, 0.3065004742144837, 0.362268804039541, 0.26938526781710703, 0.4819983463704117, 0.4582408147994973, 0.3851661194725631, 0.18230554502468543, 0.13032305010956025, 0.1935706152594493, 0.2114016832683283, 0.15592653766855147, 0.166883870082302, 0.1088743084697289, 0.10753201920984279, 0.12254851590195703, 0.25577235751158167, 0.26426587200274976, 0.3174955622657878, 0.358351898486839, 0.3847160221958684, 0.4265824795785045, 0.19091979465036923, 0.4426215480183223, 0.25173631051226153, 0.8352981013138423, 0.4079247946063973, 0.7903068238251161, 0.742601760596487, 0.7336410524277425, 0.7691114897586196, 0.7328355402530481, 0.686086525059429, 0.7391300793979749, 0.4015203566587706, 0.12180276032722381, 0.11443447099909632, 0.10727641113457353, 0.12016452244013576, 0.09176223763422564, 0.1222210653682354, 0.12464078142777513, 0.11483905440790898, 0.15770883742618802, 0.13131426210031005, 0.14606039500298562, 0.1331240426542366, 0.1556669192382698, 0.13771822821111745, 0.17360751538335406, 0.22666747770962448, 0.1541692856844491, 0.39776735458053136, 0.5067883284574597, 0.4798207792341215, 0.48752777982512296, 0.5213092262432047, 0.4728113485478572, 0.5324821935730242, 0.5963010204464259, 0.5341953112884288, 0.2972900431722273, 0.3305359687239895, 0.252711393561452, 0.32509775762935156, 0.2717441506267947, 0.3249413383808144, 0.3261072100912086, 0.3371331262701348, 0.3486059791883426, 0.21641260230312642, 0.2107292937275016, 0.20618941393106038, 0.19426150813441634, 0.21294396811357308, 0.18914054175088013, 0.21325571087430817, 0.1899116091975842, 0.2511854154724933, 0.3930577975303565, 0.20408132574753146, 0.21619979430753078, 0.5333009323063632, 0.40521035354952173, 0.3554731798105957, 0.2147202173092776, 0.5226355579016995, 0.20626808557418586, 0.7880740728915946, 0.1905079343473024, 0.707498123089984, 0.8821073495175379, 0.12963352556835395, 0.18154799331257354, 0.8417972974248219, 0.6839640952242774, 0.7441102481398092, 0.7338482947927559, 0.5992519828744954, 0.7979939287038115, 0.8018743217884496, 0.1668947122851132, 0.20627893176441814, 0.8034067439609989, 0.21300792329099882, 0.2107694055558208, 0.19215988089318203, 0.18420893181179998, 0.19588245425155448, 0.19895141251789894, 0.16657755780573846, 0.1952542192650586, 0.1930090746190517, 0.18619431562241917, 0.1791167139886085, 0.08624261617320594, 0.0850461567139178, 0.08254524409093045, 0.08112456168380744, 0.08281043246682218, 0.07856337048320361, 0.08161435630934988, 0.08937303194911561, 0.07904159999649274]}, "mutation_prompt": null}
{"id": "3f8cde67-5ce7-4e27-9cdc-cc8754f18568", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "63de2d07-b276-4378-8c91-2635496ccafb", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "5a0883b8-9fa5-42d7-a1ff-a8b3141fb438", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "fd2aecf0-fee0-4f12-b7b5-8edfda151557", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def diversity(self):\n        return np.mean(np.std(self.population, axis=0))\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                diversity_score = self.diversity()\n                adaptive_F = self.F + (0.1 * diversity_score)\n                adaptive_CR = self.cross_prob + (0.1 * (1 - diversity_score))\n\n                if np.random.rand() < 0.3:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * adaptive_F\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * adaptive_F\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * adaptive_CR\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm with adaptive mutation and crossover probabilities influenced by dynamic parameter tuning based on population diversity.", "configspace": "", "generation": 49, "fitness": 0.14993576667108435, "feedback": "The algorithm RefinedEPADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.20.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.20987924506289368, 0.28418566438338555, 0.15666236618898477, 0.42197876463923334, 0.34054568089726256, 0.17460765155342273, 0.2625334731455752, 0.11448861879252892, 0.131850430711566, 9.999999999998899e-05, 9.999999999998899e-05, 0.06123985581173996, 9.999999999998899e-05, 0.05106646664710912, 9.999999999998899e-05, 9.999999999998899e-05, 0.024655914263947087, 9.999999999998899e-05, 0.08087942885535482, 0.029354799120561936, 0.0890831587478289, 0.04596335500036852, 0.09131267176805669, 0.08778642480903132, 0.049085814494324365, 0.08771366005104297, 0.05454994222958953, 0.11021846163935933, 0.0541389067198188, 0.026461706006180252, 0.05861574736643893, 0.03919417701587935, 0.0429674877522751, 0.08861485859855134, 0.08984849812433238, 0.016158739582230575, 0.9947243331603254, 0.994736149689781, 0.9937876917218557, 0.9947745185215437, 0.995042748456103, 0.9800066045185272, 0.9956544849458004, 0.971133780310345, 0.9969541863972046, 0.0976050175882468, 0.2023488207255304, 0.10562450609701013, 0.15794614705014132, 0.10646817500297856, 0.08799452404177077, 0.07434193801112321, 0.11201812615276685, 0.07800511151600076, 0.2799844313317752, 0.13528126698456255, 0.13044344997415525, 0.14407919914702838, 0.32319349423102495, 0.19956936907870104, 0.2744751471157454, 0.23202780909225917, 0.6186659034164347, 0.06734341395820065, 9.999999999998899e-05, 0.05635168088594289, 0.12513880960048096, 0.020610836087156192, 0.016516733266292993, 0.052752352037511274, 0.030839607639936206, 0.08742888130888316, 0.01005583503897911, 0.009773605593905277, 0.009954581140222074, 0.09162612317524432, 0.09482900462025412, 0.10553043653306649, 0.019601209563934074, 0.12694368509706488, 0.046188508962274, 0.07993625690805461, 0.0482208819644695, 9.999999999998899e-05, 0.01834550945227842, 9.999999999998899e-05, 0.007695461249697888, 9.999999999998899e-05, 9.999999999998899e-05, 0.003917110378934607, 0.10291963626887168, 0.006697607891057333, 0.04334973829272459, 0.08219365032833648, 0.06988761239148844, 9.999999999998899e-05, 0.04426377575195495, 0.004878943063686747, 0.022969557136880203, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.026345785736814786, 0.028803856264914995, 0.06249924503704751, 0.03945945355198199, 0.04937331786125465, 9.999999999998899e-05, 0.016146381253043907, 9.999999999998899e-05, 0.03651681049128186, 0.06486431443530472, 0.2332987036798233, 0.26261140978089903, 0.17726305285595623, 0.40302997955998, 0.2297426026898559, 0.15453084910045545, 0.36669307284598696, 0.12349081092833347, 0.2674103699472884, 0.07912152853823995, 0.0643795167876049, 0.08415151436255419, 0.11447477356504054, 0.10381324439036343, 0.0400906607557463, 0.10750605276229586, 0.07070814851778906, 0.04044629061183003, 0.09313454885162209, 0.13273192340676, 0.0933228390130626, 0.12138199706291364, 0.07659030029350467, 0.14023148148308484, 0.16058863769200138, 0.1414668655015564, 0.11047468680739125, 0.23141503755068338, 0.2154016896448312, 0.1605706642659861, 0.31328279026759187, 0.18604776124252786, 0.17575571667674972, 0.24213680443591434, 0.1718617599674711, 0.17961739012695488, 0.1534771229611922, 0.07266633737963635, 0.13605274383317045, 0.2178310289086941, 0.0524306530680988, 0.061821277349673576, 0.16109551662190935, 0.14907639397936168, 0.12726640224422425, 0.17092295383151157, 0.14031143774155896, 0.1626030940808154, 0.15074787080871987, 0.16550061635184243, 0.1820847919490255, 0.1822555894857819, 0.18900819974013383, 0.12225908118802087, 0.17406712487440767, 0.1767385732754907, 0.13427074005127304, 0.16766265661197233, 0.14998457781724372, 0.1195974920409395, 0.18636566075792338, 0.13948540633456596, 0.1846935866141426, 0.1545359594988297, 0.15709196653252, 0.11458783721204313, 0.17308813378539867, 0.12348747061017296, 0.11463691475312954, 0.1896289154455867, 0.14964262719251598, 0.07574973401954266, 0.16155652133049547, 0.16215147988437761, 0.15922253393849806, 0.16364275123844962, 0.16327222800594954, 0.12211533717588663, 0.1835318604377204, 0.19574621534689596, 0.18340334690784243, 0.17433786125378847, 0.161144996163332, 0.19857037371232977, 0.17466990933821103, 0.18186603122110068, 0.17975126901779748, 0.1594975377736022, 0.1830361581243195, 0.20047123231819464, 0.0684945621088835, 0.08530347641995939, 0.059570056061178156, 0.0900101969756466, 0.0497789954030442, 0.054931970053099355, 0.08267746843984991, 0.08544930150346208, 0.0649208514015418]}, "mutation_prompt": null}
{"id": "69077956-7abe-4513-884c-da8ca1f57747", "solution": "import numpy as np\n\nclass AdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy with additional self-adaptive learning\n                    F *= np.random.rand() * 2\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local and dynamic learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemoryDE", "description": "An Adaptive Memory Differential Evolution (AMDE) leveraging dynamic parameter adaptation and self-adaptive mutation strategies for robust optimization.", "configspace": "", "generation": 50, "fitness": 0.3734398867644839, "feedback": "The algorithm AdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.28.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.912459027017574, 0.893739865443148, 0.8997155753737618, 0.7455676607855908, 0.9087287327852979, 0.9205980744047562, 0.9074784792368316, 0.8461759111883487, 0.7621646392335459, 0.5884478505387987, 0.2291184009914986, 0.3412582956646819, 0.4501481666946269, 0.7391041545875272, 0.8163879917605013, 0.540195815473147, 0.7053158944694756, 0.41292852008744474, 0.14599728990406602, 0.5924866880269819, 0.17547648371829616, 0.5042492930120057, 0.15693518703185294, 0.14376305489925767, 0.1600256242449304, 0.1789576943252914, 0.1527232073686159, 0.15392352458414083, 0.12734263980337857, 0.13568468124576816, 0.09508821628062414, 0.10430135232116011, 0.11417520582583274, 0.07039237176494806, 0.13918032247478462, 0.10463367189327222, 0.9827895941730833, 0.9883331332241243, 0.9531114854993322, 0.9866345031263315, 0.9712251800908912, 0.9797538119654424, 0.9846312276349442, 0.9846054830517078, 0.9904714372070544, 0.4918795232713358, 0.21116990384513878, 0.6695916313765604, 0.22744477873387903, 0.1675393198626407, 0.17760308941068237, 0.27367415721568256, 0.3921562270879304, 0.34483386479625344, 0.9014345341135601, 0.22148417600383785, 0.8453057239311944, 0.9092357612639337, 0.22047338305312303, 0.9218880212133722, 0.9037075352529695, 0.9082703235572542, 0.9178673459340072, 0.1832136267512412, 0.31530865786390516, 0.12674724131172166, 0.36726126741550935, 0.2141564219971529, 0.35202566838714333, 0.18883343000764796, 0.12676941508478035, 0.28498532747558203, 0.1464897098954583, 0.244582554691826, 0.3376352737807429, 0.42864898390932193, 0.14625074157628593, 0.4858836473327548, 0.7609190127728644, 0.13821470382468037, 0.4488479172525405, 0.15760619349675964, 0.7804299066039315, 0.40061020693091254, 0.32260781441984443, 0.18163740371446024, 0.6395236837349678, 0.08320415850797658, 0.13696470901864755, 0.425567301376772, 0.5724019070322204, 0.6132876758695607, 0.8307078695890984, 0.13210722582872947, 0.43012460575279543, 0.47261109768098175, 0.6206201564221667, 0.25715107422448236, 0.5988581363382939, 0.1619244249531695, 0.09126702115164931, 0.10974118614723116, 0.131801982083958, 0.28155427900973407, 0.20168061399451065, 0.2929166641768356, 0.2515820497615686, 0.15074597718880867, 0.6412834393785145, 0.07662606819562368, 0.2935192993522785, 0.4153001570350259, 0.2316457188301927, 0.4748565708420185, 0.30466556631977715, 0.3458634986660808, 0.1806978656384094, 0.7804634590951769, 0.630394857368492, 0.8201919941413036, 0.8044502802664854, 0.7269131395374204, 0.8120130694218833, 0.4032876568445237, 0.8019326695069114, 0.7400957944130171, 0.07504965679382913, 0.14569713627343228, 0.11516483234462394, 0.10118293816904078, 0.0715326774563999, 0.17686495539859792, 0.1173494503438347, 0.13000959766057874, 0.13360840758325498, 0.24164597501544993, 0.2511956375593162, 0.23010401624485088, 0.259428501759824, 0.17640672406885882, 0.12398112434020914, 0.24502050627659833, 0.24824799205931924, 0.2698183615305293, 0.389324621882134, 0.48790107331262833, 0.44873105268185587, 0.4974826757901768, 0.33893984560449475, 0.3983318610993376, 0.26894476503532494, 0.3346779885453347, 0.2669978247403474, 0.2637215145994528, 0.3327747718577677, 0.22513953327409997, 0.29196907361894864, 0.2511241094962475, 0.32266514393287204, 0.24493031631944762, 0.41599033035102473, 0.32418145730727865, 0.21844777540332905, 0.28509743195908555, 0.22361696527463615, 0.24363741632351843, 0.2542540864659697, 0.21116377886554505, 0.20893883049507145, 0.2008001272949872, 0.3034597304693061, 0.19392274995644343, 0.21269409469683032, 0.18774628501326174, 0.18365341416719805, 0.22423887773744544, 0.22357733803194602, 0.2388236247308526, 0.20653188083243146, 0.21516833652248046, 0.18717934603038, 0.13660182661457243, 0.17815912621560814, 0.1574850620893532, 0.1645245258771214, 0.16762266561273975, 0.9027170038986966, 0.17677866131849584, 0.1946326345126944, 0.8755863533877304, 0.16877845252686363, 0.07349434379688935, 0.16676323049540365, 0.16749517462251695, 0.826390483347298, 0.21144413044320887, 0.6711470402631053, 0.9010207921871709, 0.17870085542529468, 0.1966679559571216, 0.1910125455392937, 0.18479831081343312, 0.1697902887989079, 0.18067255789153802, 0.2045796587372415, 0.19169711179830928, 0.1936347864915392, 0.08473784688755936, 0.0966271180367494, 0.10690214615984373, 0.09848757787767959, 0.0941741477463729, 0.08645944153118157, 0.09775288800322235, 0.11176721162095549, 0.10262829245238592]}, "mutation_prompt": null}
{"id": "7332c4bc-ee18-40e7-8fcf-cd6a290ce29d", "solution": "import numpy as np\n\nclass RefinedEPADEPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.dynamic_factor = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def resize_population(self, eval_count):\n        if eval_count > 0.5 * self.budget:\n            new_size = int(self.population_size * self.dynamic_factor)\n            self.population = self.population[:new_size]\n            self.fitness = self.fitness[:new_size]\n            self.population_size = new_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.resize_population(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating dynamic mutation\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon * self.dynamic_factor\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy with adaptive factor\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon * self.dynamic_factor\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADEPlus", "description": "A Refined EPADE+ algorithm with dynamic population resizing and mutation strategies to enhance exploration and exploitation balance.", "configspace": "", "generation": 51, "fitness": -Infinity, "feedback": "An exception occurred: ValueError(\"Cannot take a larger sample than population when 'replace=False'\").", "error": "ValueError(\"Cannot take a larger sample than population when 'replace=False'\")", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {}, "mutation_prompt": null}
{"id": "b9a214b2-8ca6-4212-b256-2ec3c5c5dae1", "solution": "import numpy as np\n\nclass HybridEnhancedMutationDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Hybrid dynamic scaling mutation\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.rand() * 0.1)\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    # Periodic adaptation strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.rand() * 0.2)\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) * (1 + np.random.rand() * 0.05)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridEnhancedMutationDE", "description": "Hybrid Enhanced Mutation DE integrating dynamic scaling factors and periodic adaptation for robust exploration and exploitation.", "configspace": "", "generation": 52, "fitness": 0.30839775150008086, "feedback": "The algorithm HybridEnhancedMutationDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.6678534785692243, 0.6205951694361238, 0.4868516267524333, 0.5536875228634093, 0.46905221913368045, 0.5825997089904886, 0.5698733581402518, 0.6757974056248528, 0.5387030356103929, 0.26610833023585323, 0.17223795826482324, 0.2046929278916918, 0.20753075641205854, 0.41777714227265117, 0.128544624265849, 0.18416902860284068, 0.24080300928632647, 0.2814972825519587, 0.10188296511762296, 0.10465861696531009, 0.09567755925200527, 0.11493581750630832, 0.09623601048212638, 0.1006681285892127, 0.10151196156738385, 0.09099363757382184, 0.09359308993354498, 0.09655140708731158, 0.09084191301316658, 0.08856500697019443, 0.10561349522867536, 0.08935900001397457, 0.0954044271354747, 0.09626040426342464, 0.08928907264796093, 0.08303996686575943, 0.9233559654257949, 0.9733671135272262, 0.9924166769186431, 0.9895233199489194, 0.9847338232082908, 0.9556384298300367, 0.9837950697999355, 0.9895928757732891, 0.9685000730420964, 0.2942845793842028, 0.27018623550900556, 0.2340296389367963, 0.2523224992905848, 0.20915679825727806, 0.34451751859795143, 0.23733056682122533, 0.2969544765456603, 0.2866359137469735, 0.8148905889143762, 0.8168716617966315, 0.5236949432443553, 0.515798581084548, 0.8246993248304241, 0.783696206198189, 0.8075738411952785, 0.8152059345390641, 0.6665676527023363, 0.28309494343220865, 0.3383699327970455, 0.3188626803712332, 0.27610661158014405, 0.2480275355470185, 0.12349545810861329, 0.29462372531365777, 0.24169124611631776, 0.2824801165211114, 0.3968359198194644, 0.38606450055648955, 0.1305892524559944, 0.32827877293262886, 0.20048317342242739, 0.24916226324525137, 0.29865831825240663, 0.19245325274747516, 0.24112249256577056, 0.21375472937416795, 0.2566332424897305, 0.1446480343014217, 0.2459574430721322, 0.2923190531830727, 0.28996773777158025, 0.3618195387413077, 0.2773917162937327, 0.2843840169974715, 0.5461431646242376, 0.4863956148818783, 0.43953952133773566, 0.4845516405227366, 0.5081067186376049, 0.22674118215647854, 0.41873651420911095, 0.5154220752670935, 0.3750698205284859, 0.08694789863047392, 0.10573352379225598, 0.07114747215121786, 0.08444287135338369, 0.10388814081711573, 0.035225934259954905, 0.0158637632576476, 0.17975034303528215, 0.13270217438687448, 0.2095960412859016, 0.16363939554911955, 0.33195720241608984, 0.14302281895334112, 0.24380101730887782, 0.13986682422871122, 0.2161104605702855, 0.25856466247196763, 0.22936844366019682, 0.3930400127787852, 0.4631725083024849, 0.5623073829867153, 0.4554496098733878, 0.46456076775917543, 0.5504011442429724, 0.4821163597217025, 0.4120500984511192, 0.5579914284972443, 0.11783750197847365, 0.09386691121747659, 0.11620025910244536, 0.10615255305958693, 0.09868790902926916, 0.09990989053250598, 0.09254315579624217, 0.10011991132638975, 0.0923505542305535, 0.15578000398108505, 0.24790405106623226, 0.1527578697845876, 0.17741008061277042, 0.14345416470045658, 0.14146628120024307, 0.14605606670122162, 0.15962181003310283, 0.35770614484648955, 0.39742624137548854, 0.3438855935089521, 0.31773672366422834, 0.3753657133842184, 0.3609421545233319, 0.3143227049259487, 0.3434698418902845, 0.2835550544474016, 0.3216374800893803, 0.3253300506996024, 0.267776409044589, 0.256759569594865, 0.23236019177446987, 0.20385689340363145, 0.23459388054316166, 0.27886370773789304, 0.23866735637037895, 0.36357826672406257, 0.2028811039232623, 0.21206961590205398, 0.19868194721294685, 0.20508394915556216, 0.18842677979102185, 0.20925883937449885, 0.20414526274234335, 0.1967534924935872, 0.19634564061412974, 0.19416310554803662, 0.18516378336169015, 0.17973950466633526, 0.18047034457852473, 0.18690844367804105, 0.18493950708989082, 0.18417485347761453, 0.24005061575911302, 0.20147715138510325, 0.8043183489717316, 0.1858521087502879, 0.183104608216199, 0.18125959466613073, 0.5418707370598435, 0.5878069265875742, 0.18636939128761865, 0.559918756777765, 0.1468589420375923, 0.7952645993070112, 0.46884356514776315, 0.2050336438801421, 0.7538388172729724, 0.7502119675597251, 0.1670985571385829, 0.2124776470746188, 0.632003396157614, 0.2124240431852833, 0.17973786336702247, 0.19387468943558306, 0.19571808243881084, 0.18219277931286204, 0.17798874205593607, 0.177981661144051, 0.1743743293769996, 0.18488511371100635, 0.19359067148005038, 0.08226662241267257, 0.0714104976156339, 0.08597621640816722, 0.08637538871699146, 0.07836626899046528, 0.08183929541289581, 0.08620269434139716, 0.07913024772613719, 0.06726298023272415]}, "mutation_prompt": null}
{"id": "04920f51-2374-4ee6-a973-8a968a418fb6", "solution": "import numpy as np\n\nclass AdaptiveL_SHADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 18 * dim\n        self.memory_size = 8\n        self.cross_prob = 0.7\n        self.F = 0.7\n        self.epsilon = 0.02\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Dynamic mutation strategy with elite learning influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Elite-guided learning strategy\n                    elite_idx = np.argmin(self.fitness)\n                    a = self.population[elite_idx]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Adaptive crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveL_SHADE", "description": "Adaptive L-SHADE inspired algorithm leveraging dynamic memory and elite learning with improved crossover for robust performance.", "configspace": "", "generation": 53, "fitness": 0.2648853161048875, "feedback": "The algorithm AdaptiveL_SHADE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.6880384932541441, 0.6331835868802292, 0.667896067203976, 0.7086033486545713, 0.6803203490995606, 0.6809110117543369, 0.6639353344348893, 0.6815690110207597, 0.651038437188111, 0.3884407714417557, 0.35601594804518943, 0.34120079685202187, 0.374491643489662, 0.36539505054409027, 0.3596735709729987, 0.34832206008864974, 0.37740555607504955, 0.3896434644175665, 0.13927543413308563, 0.11529214273345045, 0.1133780444750937, 0.09993527069707286, 0.13328571937791966, 0.11918710794320941, 0.13753374186974632, 0.12650733759741628, 0.13419289198474504, 0.11355436377810024, 0.10213901667402936, 0.1206763603714357, 0.10411647420262704, 0.10479755353091624, 0.12276732912638544, 0.11650447632932415, 0.15421622836042426, 0.10108414847553282, 0.992237082722409, 0.9906129971803287, 0.9830708844384887, 0.9833424012821435, 0.9790776772267878, 0.995539388171312, 0.9782469774630572, 0.9798337361019813, 0.9954224945233481, 0.2459260870850256, 0.23547672996575564, 0.2600625318086305, 0.22246087872980846, 0.25225200254142355, 0.25206655747101325, 0.23140377921938693, 0.24120302934294224, 0.23165042609579434, 0.40333715867202435, 0.35848605630237684, 0.3467715977135506, 0.4402634094236648, 0.5322637295948753, 0.4834442694555331, 0.4448249400294001, 0.41011373084470537, 0.478209897880602, 0.2126542987875779, 0.19399091050928752, 0.24123674339041723, 0.21547529916078334, 0.22158543940540554, 0.1823235035329125, 0.15488095968826088, 0.23537963273099483, 0.20638002410527811, 0.17770509044291816, 0.19853290408897206, 0.17622586932593787, 0.10363578265465401, 0.18857037627508533, 0.1988372463519008, 0.21480638657330187, 0.10753841729459523, 0.08615569117195887, 0.04603033942582335, 0.021397200087190815, 0.06453295875405807, 0.03860202925236622, 0.05135748546404084, 0.04424040284151265, 0.09878975793296363, 0.05276584039501997, 0.0530539466378237, 0.1191929257202311, 0.15798401838208265, 0.14068445431705445, 0.16123207623278957, 0.1044057777802947, 0.16741523803356373, 0.2333794179121803, 0.19518776452732833, 0.15332938400226226, 0.025064946772962893, 0.04845397452607414, 0.012983622633234715, 0.02341764464411622, 0.015999767982151192, 0.024909610883800615, 0.025163466059323625, 0.034689843782704566, 0.044973023973162385, 0.12263893447889951, 0.12220738055065927, 0.12833466641283953, 0.1265068467519832, 0.13603501124136042, 0.12581163496998893, 0.148130532558587, 0.11134117393986365, 0.1247792024609311, 0.4334906748641878, 0.4560450736508268, 0.4802478492987853, 0.4687157745754149, 0.47776100009316214, 0.45358666449474494, 0.46749019632246513, 0.46418337796668097, 0.46319575072935004, 0.09067146432803386, 0.09037674982257737, 0.1025738321772911, 0.0920323336994372, 0.08781285799603078, 0.09269950342950362, 0.08650776044423214, 0.08240705762073464, 0.0934135503608623, 0.15326234333880906, 0.12306828273560644, 0.12012676897060415, 0.1411289978598239, 0.15157362722377477, 0.178692536190306, 0.19353820497830976, 0.14737372014317407, 0.14080301558338326, 0.29707302132376323, 0.2848119547638047, 0.29591574671516696, 0.2982541251413633, 0.28987439499443435, 0.2933783990853327, 0.3025862766178551, 0.29144919899679433, 0.31822903398545244, 0.21763197615518104, 0.19458829345805906, 0.22836243147640967, 0.19489392947763273, 0.20267487750480362, 0.20437732097977845, 0.23702342975180946, 0.23240925650722544, 0.22350660242073705, 0.18114196561000773, 0.17902829179379842, 0.17555438717644134, 0.18402058573984104, 0.17919428691383477, 0.1753319560811859, 0.18409914756154855, 0.206150621334951, 0.19322523225925847, 0.2124942271563981, 0.259690547992816, 0.18763531929738997, 0.20440172553240732, 0.1905570892650803, 0.20245331783142273, 0.19364911898700232, 0.21717417453836774, 0.17117341053312007, 0.6926779362113639, 0.6168948202123428, 0.6669487323237333, 0.4599646711811045, 0.1783211604231848, 0.6217572067188324, 0.5793463082819066, 0.5969648024701186, 0.5115290410887359, 0.16396639232887278, 0.1997045511340979, 0.48860093959806716, 0.19519806099441495, 0.14780243328702658, 0.19408715122219122, 0.6352914944635024, 0.1911184412938952, 0.21086105217396955, 0.1776721953694339, 0.18596447746779532, 0.19294798346539366, 0.1799711384473881, 0.18521617077682428, 0.18055549760784362, 0.19214727742904258, 0.19509828122487582, 0.17954933057268385, 0.06751440038791767, 0.06845760704726822, 0.08931367981793015, 0.07331962236392386, 0.06719430327053211, 0.08220319964940048, 0.08068028759321588, 0.0763022720620633, 0.07022524266029762]}, "mutation_prompt": null}
{"id": "1bcd4943-aeee-4073-975d-1a82fc529594", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "5a572d6c-a057-48f9-9e4b-21cb3ae1b3dd", "solution": "import numpy as np\n\nclass RefinedEPADEPlusPlus:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                mutation_prob = np.random.rand()\n                if mutation_prob < 0.3:\n                    # Dynamic neighborhood influenced mutation\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.rand() * self.epsilon)\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                elif mutation_prob < 0.6:\n                    # Adaptive mutation using stochastic selection\n                    selected = np.random.choice(indices, 2, replace=False)\n                    a, b = self.population[selected]\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.rand() * self.epsilon)\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    # Local exploitative strategy with adaptive F\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.rand() * self.epsilon / 2)\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADEPlusPlus", "description": "A Refined EPADE++ algorithm incorporating adaptive differential evolution with dynamic parameter adjustment and stochastic selection for improved exploration and exploitation.", "configspace": "", "generation": 55, "fitness": 0.5120584236095603, "feedback": "The algorithm RefinedEPADEPlusPlus got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.51 with standard deviation 0.30.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.8915582219300121, 0.9067764516318597, 0.8904416955621683, 0.8859954912118293, 0.9075366501456085, 0.9026811071746255, 0.9017081334130972, 0.8860365014401549, 0.8998628799901881, 0.8062716270905332, 0.7818355628539275, 0.7871278967696789, 0.8028582717079763, 0.8140960415985925, 0.7473380578201312, 0.8195813066717301, 0.6918000283120294, 0.7904905746663766, 0.15137021885943924, 0.1399890452210517, 0.16798629769558104, 0.6527605258352247, 0.6394033161196643, 0.16117502314712406, 0.17510892946603385, 0.18048832247773894, 0.14860160627132768, 0.1358009761749679, 0.09135966452915889, 0.14432525139081231, 0.11003617916955533, 0.11079927849132287, 0.1682706961565993, 0.12967930292802266, 0.12669973652147604, 0.13282649281706194, 0.9587939870661677, 0.9325350522027054, 0.9923244709663409, 0.9827552653435129, 0.9748259503131451, 0.9804313202067474, 0.9776476656132861, 0.968072024491731, 0.9582791740845702, 0.5723348667572643, 0.7276379443069205, 0.7184236029649311, 0.7006503560657078, 0.7305390129630727, 0.7025206883445777, 0.7114354296895675, 0.701873100191603, 0.6999757154287274, 0.9118489419285285, 0.2505142141961577, 0.8931405576780914, 0.8962137544326433, 0.908635311460764, 0.8936430779511227, 0.877374140168877, 0.8749214516980699, 0.8961014450489889, 0.7694248884058288, 0.6588670209205822, 0.5832371953171754, 0.6563590998719318, 0.5098063873914458, 0.7270476521076292, 0.44654693970723014, 0.6114784796924988, 0.5929408124973315, 0.7388140476705226, 0.6208725684884732, 0.5478846567430422, 0.5552347506947181, 0.6239345561581656, 0.4615445593587022, 0.5579203733812261, 0.54859968805439, 0.5100663890732293, 0.5755167973446484, 0.6945504393554968, 0.765233557504206, 0.7318393829253613, 0.6913758719151599, 0.503108981252337, 0.760842737516758, 0.6799084957664484, 0.7753737653915055, 0.817522783873947, 0.7994140503639631, 0.8042878424815937, 0.773668961216823, 0.6622945446657837, 0.7320463880654877, 0.8019846483722755, 0.798916078972503, 0.7823216674243691, 0.4102926323054028, 0.48654562334680673, 0.4036668747787663, 0.38329977488205247, 0.23034940418440197, 0.6276416869659756, 0.19460673077175383, 0.4882124883510506, 0.38501783196429207, 0.7090971482131615, 0.7013955343848766, 0.6872569976876588, 0.6956370429464075, 0.6975095602855378, 0.6949864707501244, 0.7100876546683839, 0.6769780183610462, 0.6485083961597672, 0.8425545463044695, 0.8627393646060815, 0.8616101840899993, 0.8543014254649446, 0.8668465511639891, 0.8636331207876635, 0.8680521323900529, 0.8561669381791731, 0.8596300361352691, 0.14232876025527474, 0.122248886349412, 0.1696047552041311, 0.12921225145716786, 0.5219871972655972, 0.09994791540551218, 0.1427173659972375, 0.11357355098058508, 0.13964264756329725, 0.13787601890862933, 0.17408415776955666, 0.16346178372728537, 0.27178289037824066, 0.1528445399672933, 0.1749442520290977, 0.33849423295580017, 0.23153498364318936, 0.17933342695684207, 0.5712988919452389, 0.6969676215979691, 0.7101478963229133, 0.6004367924289337, 0.48407725839976934, 0.6913380170578152, 0.6769076025961563, 0.6423828878212308, 0.6947275676723355, 0.6623764989716245, 0.543553220441177, 0.5948780572410814, 0.616062130172168, 0.5379675804275321, 0.46149201467526535, 0.6213601483278333, 0.6220091119767522, 0.6257292588962025, 0.25109076992670976, 0.1796315188093056, 0.21000807819869127, 0.19291345601792498, 0.18611271073117508, 0.2584493117358797, 0.22337752004973777, 0.2101021197800801, 0.1816302573152624, 0.2033074124581401, 0.6048713180077671, 0.19321582274543792, 0.19695482232526906, 0.7135395968160978, 0.21690726927919735, 0.20590155373258012, 0.21480354110536182, 0.244395909045395, 0.18154084028831996, 0.18543991969291285, 0.19723094677466702, 0.18361739687291623, 0.6663959564299562, 0.19785706188774632, 0.8731689364962033, 0.821537814845832, 0.20636937190410476, 0.12731244479248927, 0.2095946868932742, 0.8948284234147927, 0.16744372072821112, 0.21146945192903344, 0.1656550860560272, 0.21017832305845374, 0.15604361715439063, 0.8226492935958531, 0.18287278810277718, 0.17454070329017835, 0.2123883058414634, 0.1763718106973845, 0.1991701847398123, 0.17116517202170434, 0.16931292137662346, 0.17075433878283763, 0.19165391429172807, 0.0953166602164347, 0.077667383889098, 0.08161260225940992, 0.07620978562248149, 0.09930755417823511, 0.10606930761741773, 0.09694847865022715, 0.10153655101742787, 0.0853054674900473]}, "mutation_prompt": null}
{"id": "86bdb46b-6fbb-48c5-a569-b3a9150b97da", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "7c9a6056-792f-4249-818c-5eee9e300302", "solution": "import numpy as np\n\nclass HybridAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.8\n        self.F = 0.6\n        self.epsilon = 0.02\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                use_neighbor_strategy = np.random.rand() < 0.3\n                \n                if use_neighbor_strategy:\n                    F = np.random.normal(np.mean(self.memory[\"F\"]), 0.1)\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.normal(np.mean(self.memory[\"F\"]), 0.1)\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.normal(np.mean(self.memory[\"CR\"]), 0.1)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveDE", "description": "A hybrid adaptive differential evolution using neighborhood-informed mutation and dynamic crossover rates for diverse exploration and efficient convergence.", "configspace": "", "generation": 57, "fitness": 0.46506615669319507, "feedback": "The algorithm HybridAdaptiveDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.8995748625172281, 0.8974344825966459, 0.8945416122842732, 0.7963168716571716, 0.9105724479299445, 0.8856717352966825, 0.920485455232333, 0.8383070986206953, 0.8874370746562286, 0.6377044964167913, 0.7154058660981732, 0.8317387572516239, 0.7603928727099709, 0.7701520256839216, 0.8537886055306354, 0.7857393248855603, 0.8681421585573106, 0.8038605062959244, 0.6148542769724576, 0.16846745458934642, 0.40568870322616046, 0.7582814220694705, 0.11902100275737626, 0.5880308224956479, 0.5538767305697346, 0.6826981785236899, 0.35462609486580243, 0.16593665034381833, 0.11940889701211321, 0.1277258317915193, 0.4311765331858972, 0.10905622823364625, 0.10984773267513015, 0.12977494517027044, 0.1265783392250701, 0.15448283303835675, 0.9651294899644464, 0.978839130219151, 0.9892028782395471, 0.9856437236216326, 0.9759219667362118, 0.9775096920909552, 0.9853305936128737, 0.9810210162339456, 0.9736649192339781, 0.7447362753991047, 0.6943891669407862, 0.7615241217861355, 0.5991703597470175, 0.7029244042939218, 0.6354146838817235, 0.6968814567970858, 0.5478089919601845, 0.5199626259021402, 0.3602626650816123, 0.8990252213528028, 0.8882855832608657, 0.9108854587532214, 0.8910945391955116, 0.3390469064930176, 0.8605656749301419, 0.8976790769633908, 0.24561371040456093, 0.5663573231060492, 0.5579407027550352, 0.439925114667839, 0.4235892609702471, 0.5347734670079141, 0.24453354885779854, 0.6398762576004744, 0.4392359193342539, 0.6070201093480494, 0.5944879123649311, 0.11893156430698759, 0.5460396332841355, 0.44960974675259824, 0.3995613370968375, 0.6230240824545388, 0.508137322153076, 0.3672138984359097, 0.5709054554936256, 0.2051564631868107, 0.7089504279562091, 0.1786506362161614, 0.5760373186342642, 0.22682182692488206, 0.7283683949787285, 0.4738683679141492, 0.37668358349988196, 0.7586882845928524, 0.3128163442559324, 0.8374823058991341, 0.7912742949333469, 0.38694280633503786, 0.7840038580701508, 0.7160875759842849, 0.6558914249710621, 0.5888787812984686, 0.7129984181782074, 0.2409556408434652, 0.23278882485993413, 0.47978937311875536, 0.18382977148188961, 0.42336063656478407, 0.48764530317360855, 0.18191405685278028, 0.2438861508296788, 0.3225107287287474, 0.36210225257430606, 0.30090271491073817, 0.2913304626629981, 0.6187837528757346, 0.6833957999742815, 0.30779590344645336, 0.35344998350787826, 0.49203605194254585, 0.6934654369272153, 0.7556869579298321, 0.7417566428243239, 0.8792770079026919, 0.7175168563738793, 0.8445246817019207, 0.6595728261764995, 0.7790611211682277, 0.7455592093937511, 0.8363711265156984, 0.10177663770683298, 0.14216768333182683, 0.1375666067456366, 0.13510222082889844, 0.1365822508722624, 0.12890533294348094, 0.10658685516431776, 0.09666011391618501, 0.1711213065164311, 0.14274966322154847, 0.2101596184846789, 0.1566503230513523, 0.14345752629009645, 0.17958965936649984, 0.13889549266831525, 0.13623272695135547, 0.18342642994685077, 0.15752285552975243, 0.3239636773573986, 0.4274977252264758, 0.5340775265716464, 0.5762093922260785, 0.4754061201983576, 0.40021301338816495, 0.43121286604757547, 0.5257308170205486, 0.3971455715279214, 0.2830222598512466, 0.5074772905921072, 0.25006559572266884, 0.4686395133635648, 0.5331440522255739, 0.29138376122435417, 0.41776566054013087, 0.3479568062730929, 0.3354839678025965, 0.20887168991670235, 0.20155107312924503, 0.20647536555170343, 0.21620451267869656, 0.18161952260982905, 0.2179117679579171, 0.20717931704287396, 0.1933798138566294, 0.19725461238348552, 0.4227298189077936, 0.5326192709709525, 0.23648191500069582, 0.7842175736050319, 0.23874460766653816, 0.17146852361711318, 0.6335113036041435, 0.20739562541355094, 0.23416798844689835, 0.15037572692839507, 0.9038219608834559, 0.19378226323286385, 0.16858644721701532, 0.8394282563785057, 0.1648734693277898, 0.8178790126788009, 0.9166597810159596, 0.8384227278902603, 0.2032364309543041, 0.7500265859679844, 0.7490561272913725, 0.16545376863978656, 0.20168385402416666, 0.16633678959799836, 0.21135655827555067, 0.21073507879888553, 0.6935970710380832, 0.19372761917000114, 0.17029104557048524, 0.19045970919848343, 0.19219575256033739, 0.18426297585105844, 0.19724582620379372, 0.18971869078322556, 0.19319985832604025, 0.19150011613520013, 0.0853600339735181, 0.0954663987285358, 0.08347777934226164, 0.0822783662693688, 0.08501630907528235, 0.08664287199345633, 0.09765459897240103, 0.0783124980409029, 0.09446795319389534]}, "mutation_prompt": null}
{"id": "6f45d9c9-55f7-4d08-bcee-326669357f9e", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "1324c68e-23bd-4144-af25-48593011d683", "solution": "import numpy as np\n\nclass AdaptiveCoDEA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 12 * dim\n        self.memory_size = 8\n        self.cross_prob = 0.8\n        self.F = 0.6\n        self.epsilon = 0.02\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Dynamic parameter adjustment with multi-strategy mutation\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Coevolutionary local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveCoDEA", "description": "Adaptive Coevolutionary DEA with dynamic parameter adjustment and multi-strategy mutation for improved diversity and convergence.", "configspace": "", "generation": 59, "fitness": 0.3928520000063236, "feedback": "The algorithm AdaptiveCoDEA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.39 with standard deviation 0.25.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.8151914903039938, 0.8096397810635183, 0.8019204283938373, 0.7982116367491652, 0.8028613008423671, 0.8125365089332914, 0.8002126154664089, 0.7978768679003168, 0.7929627270614032, 0.6661584924559403, 0.6169484539272811, 0.6554614745056477, 0.6260976247554464, 0.6435630886157265, 0.6134793747592431, 0.5689360592778872, 0.6573126312882659, 0.6103025963889726, 0.14446772814710385, 0.13930200567193263, 0.1761958437611938, 0.14458429362279546, 0.145457376119543, 0.3085918130817149, 0.12991049785007058, 0.1492897239268901, 0.12307583818311574, 0.11327615470004893, 0.12497625405887758, 0.11779138252989563, 0.1040257383951122, 0.13111032983985715, 0.11001038307990352, 0.13304111097894789, 0.12900488831989987, 0.1209794896327876, 0.9797320592505376, 0.9871500245582152, 0.9854376826513508, 0.9869770719218446, 0.9736843825523738, 0.9781776997344682, 0.9806040936545497, 0.9913605661320157, 0.9798727893153807, 0.46490917142578747, 0.5286581308919306, 0.5012394012973571, 0.47993320904881587, 0.4794052644070974, 0.4892646392600519, 0.4520568912925038, 0.5100155653082292, 0.4940622232726579, 0.7626639701512408, 0.7929743010326858, 0.7670527063627656, 0.8330295633234126, 0.7696119034764892, 0.7969886396972146, 0.7873196314404369, 0.8050093372722322, 0.770117831673303, 0.3803367294781571, 0.3881559878651839, 0.39005088879227845, 0.430955469947668, 0.4950775436451861, 0.46289646858884426, 0.38799856895445106, 0.4708669464594948, 0.39697972218025, 0.36333752283530085, 0.40726969937869884, 0.37754684428471874, 0.4285029853699398, 0.5399756700216923, 0.43384616488476124, 0.4331908564203357, 0.41398679596700416, 0.4331161432857662, 0.24942798444264414, 0.30626014574406923, 0.45618065998194024, 0.3093459216630542, 0.3792983377160911, 0.3043521448664981, 0.35164665176669385, 0.4010881124854665, 0.35675857863542026, 0.400317170552116, 0.5177563350817396, 0.37997078056460687, 0.4931716275264004, 0.37657084136819674, 0.5146056332749328, 0.49814993979029254, 0.5155006049422708, 0.4895956485833747, 0.17490503467731855, 0.16022847395927386, 0.14568337357602523, 0.2252688160251488, 0.17020726962982047, 0.17889458969270033, 0.1674650582500129, 0.30127070111144616, 0.22587344441178814, 0.2749145826090078, 0.3355786405344382, 0.331768704162933, 0.27144061560358246, 0.3220748167905426, 0.3662567401538357, 0.28848133092794204, 0.2927187728994378, 0.3131640755031786, 0.6872258718168467, 0.7016523963400109, 0.7087973856101888, 0.7018760820499099, 0.69635029245015, 0.6606448595556196, 0.7073450442706053, 0.6843835757765149, 0.7220261401057131, 0.12588079751394254, 0.10062654834838236, 0.09639838663282985, 0.11009281262441295, 0.11467541808652426, 0.10504501706604374, 0.11510384060918133, 0.08996020731353604, 0.1042784823601356, 0.13544257482066968, 0.18081963877037333, 0.16480846755622702, 0.1425442092861553, 0.1532271748741394, 0.1436365568669813, 0.1373874555961192, 0.1430024340151127, 0.148521290823581, 0.4155562432040697, 0.4690537042964641, 0.4097105438627987, 0.43103747488726907, 0.4013773570453051, 0.42441576816700055, 0.4487982746121473, 0.4394129022585641, 0.4573155292714005, 0.34249008503527234, 0.2949723572634705, 0.35495611172778607, 0.35476322168356256, 0.2949493993423089, 0.3446267571049332, 0.342952145015447, 0.3453669456245323, 0.32905798117683405, 0.2412475886611506, 0.20057300793133204, 0.19080382186224565, 0.22668371491257466, 0.22086332116847784, 0.20480312555061064, 0.20022101641451973, 0.21033827008773642, 0.210513479134803, 0.28962184948341707, 0.21267080195364274, 0.19539229279229675, 0.2725090967284143, 0.22919988465752605, 0.35897209269259256, 0.30895236568356754, 0.20360461020112353, 0.21169296315312736, 0.6454372313925971, 0.1733895143974109, 0.18857241685517823, 0.18163607636782575, 0.5656553787538903, 0.19063305928588292, 0.7609857620232867, 0.1815391975733497, 0.8122051064848199, 0.16824397170062566, 0.7280589700420355, 0.7251419375050914, 0.1673657663013901, 0.5972525488685119, 0.16224974419631322, 0.2073022855383957, 0.20749214994237353, 0.8082913007215634, 0.19743680260235308, 0.18498235088809156, 0.20479816227429237, 0.19445661949680304, 0.16995152010108028, 0.18202473315953616, 0.1955906613211924, 0.1929097060249244, 0.19746785709269565, 0.08003556279630686, 0.08317762076347868, 0.08380157903632057, 0.08140331861875638, 0.08632059635972233, 0.08824050330294086, 0.07872629959228927, 0.08329034663776402, 0.08638035470124306]}, "mutation_prompt": null}
{"id": "eb54d0b4-7092-4f71-b8f1-680f138166d8", "solution": "import numpy as np\n\nclass RefinedEPADE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < 0.3:\n                    # Enhanced mutation strategy incorporating neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Local learning strategy\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedEPADE", "description": "A Refined EPADE algorithm utilizing a smarter mutation approach with neighborhood influence and adaptive local learning for enhanced convergence.", "configspace": "", "generation": 25, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9085080376488289, 0.8917279037399196, 0.8958630922655272, 0.9016920771191662, 0.9008639856713503, 0.8969366071573714, 0.9047004793279837, 0.9028877361659027, 0.8794431046446871, 0.8145980067253693, 0.7864164829669802, 0.7914506725063862, 0.7855481389831696, 0.8047852599930359, 0.8217270220195068, 0.824277401433903, 0.821848351986731, 0.7933522159225134, 0.14852024515391204, 0.16989114703245245, 0.14552524303622105, 0.16808713307594392, 0.7151244178058785, 0.1370057628138187, 0.17291049103991607, 0.5896488875208642, 0.16331835393266136, 0.13683946843061567, 0.11037150650050043, 0.12373048955840882, 0.12138902147421415, 0.1221183513283387, 0.13994229404424607, 0.10684768818076973, 0.10809867496970504, 0.14994324201502118, 0.9708853230653957, 0.9892734994530715, 0.9831065718195274, 0.9867173653637027, 0.9530288006202075, 0.9812548867930754, 0.9833205793000277, 0.9634132834149689, 0.9914691421976782, 0.7511179419113773, 0.7376377617137222, 0.7281252731047472, 0.7477066781851165, 0.7594026914092074, 0.7182975516350909, 0.7413992603327044, 0.762412937362562, 0.771812283777427, 0.9266863966458136, 0.8887205388662639, 0.9126175892044011, 0.9192571761174011, 0.8933184288930437, 0.891604976681707, 0.875647768443604, 0.8209147862881918, 0.9028923545318321, 0.7610129417604607, 0.5785220969838827, 0.6071130503535779, 0.7130047503448125, 0.13269539791012108, 0.6510991211413575, 0.6607163542142512, 0.7039651783433506, 0.7119820257486082, 0.6823524656902089, 0.6623805641144618, 0.7334430473604613, 0.7215524897568201, 0.6759825788413929, 0.7628279800751625, 0.13182342756469456, 0.6975984325889494, 0.6552355304016801, 0.7108740257674213, 0.7481792421237219, 0.7495934982167798, 0.7743959398905254, 0.7541837418289887, 0.7436298185596788, 0.7520872755781796, 0.7323196965706464, 0.750156387891177, 0.7931274041728709, 0.8064188918922691, 0.8153941891821609, 0.7977263881976385, 0.7768932725837727, 0.7888978153986925, 0.7739692339631687, 0.8150803091060899, 0.808745600478042, 0.4911930210175509, 0.6212604526326551, 0.5121247164905116, 0.687806750303493, 0.44593486371202695, 0.732071611453833, 0.3013461429801194, 0.324103074190782, 0.2539628009704007, 0.6995850191563944, 0.6792251595412784, 0.6476353931840886, 0.6835846245536906, 0.6739452137922386, 0.6975729857982624, 0.6381788393727756, 0.7307590765632814, 0.6889977794023489, 0.8877945522894146, 0.8782638520336102, 0.8635196287042134, 0.880444801282883, 0.8774019284756444, 0.8679517060141236, 0.8804265436522252, 0.8756450741850943, 0.8732026050711476, 0.1284664789726696, 0.1443439564341079, 0.14910443844839105, 0.14282928257037852, 0.14357810162523588, 0.6286201526496832, 0.16617025471184788, 0.4176828150308781, 0.15919284223981067, 0.1668927109971795, 0.14163302192744998, 0.14919634572551654, 0.20555349456487015, 0.17557556236146554, 0.19288159879025168, 0.16356798890468704, 0.18276698780884992, 0.17521168548072674, 0.7095151466842836, 0.6729373590569487, 0.7102388970039584, 0.5741512038615371, 0.7268062513111774, 0.6831966728846417, 0.627510021095544, 0.563834004118287, 0.7230203167883105, 0.6154827520346242, 0.6334412960349638, 0.6091559429206338, 0.5450496910126632, 0.5706589537793794, 0.6158158138570513, 0.661938274182011, 0.6116350854155543, 0.5949885250173289, 0.19776361292588285, 0.1951125751846018, 0.21519615057817987, 0.27293119003355293, 0.20636909592990327, 0.21714740663629817, 0.2137018177403004, 0.2151501011470247, 0.19996248755953772, 0.23876200416548377, 0.236763701333514, 0.580021200122901, 0.6805972294697555, 0.2423095315255802, 0.6901532744314502, 0.21750905186180391, 0.691198274201174, 0.23145234326915765, 0.1713715102418084, 0.9016084357477919, 0.1693260140611943, 0.17172534086704105, 0.1677966754314426, 0.9025894619065866, 0.1649139737045029, 0.16918265679938704, 0.17058779766371013, 0.8433743261232647, 0.16872106137026954, 0.15277374662178156, 0.21014749244404218, 0.16440227309497335, 0.16801503618221358, 0.8235080513071261, 0.1279487266466558, 0.2103207320610192, 0.1999276520773272, 0.1920394138236554, 0.18571755595812955, 0.19302801347324772, 0.20074082744052457, 0.1764259168449458, 0.21020965160605265, 0.2136810317061778, 0.1910332599511767, 0.09301016095562753, 0.11073112182034384, 0.09345730325795798, 0.08997553489755317, 0.08634804088463166, 0.09056658136624596, 0.07969310524544582, 0.0972233750776248, 0.08574256260912039]}, "mutation_prompt": null}
{"id": "c88be50e-b9bd-4e57-957a-21c3edd0e68c", "solution": "import numpy as np\n\nclass AdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    # Multi-strategy mutation incorporating both local and global search dynamics\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Neighborhood influenced mutation\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                # Crossover\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemoryDE", "description": "An Adaptive Memory Differential Evolution Algorithm leveraging dynamic parameter adaptation and multi-strategy mutation for robust convergence.", "configspace": "", "generation": 61, "fitness": 0.5366413535948242, "feedback": "The algorithm AdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.30.", "error": "", "parent_id": "4bfb43cc-1237-4e10-9c32-b822157c55b4", "metadata": {"aucs": [0.9083250423620939, 0.9022522180063959, 0.9028177430394111, 0.9136536377530252, 0.8988808545885256, 0.9094175616952485, 0.9025314194484194, 0.9031305801285641, 0.9024008435739448, 0.8356726386242086, 0.8145853500060387, 0.7946314401793664, 0.8264268698373318, 0.8181041755352663, 0.782152960698455, 0.8123478563982682, 0.8234403859075596, 0.7732920168644221, 0.16233196709747522, 0.15485883061288697, 0.526464007546224, 0.16354004239202535, 0.1673281988546017, 0.13991805761603648, 0.15931391298197084, 0.17833550852539226, 0.14900876283523035, 0.12546673086392512, 0.13688311074892956, 0.13279660289723938, 0.134386766565449, 0.13644855484352814, 0.14571021905966297, 0.13850582090733565, 0.11978000681984291, 0.14419190899645984, 0.9675945760131096, 0.9843650720328383, 0.9893882521964751, 0.9803234289311937, 0.9806807104583706, 0.9781293335936324, 0.9772579026677607, 0.9790442103432895, 0.9835598140395378, 0.7515525368053643, 0.7300294019026846, 0.7013564948455633, 0.7217923897030187, 0.7316516690353101, 0.737874407047788, 0.6728643094966131, 0.7258766022146999, 0.709591325649771, 0.8961085457914809, 0.884683631784187, 0.9143396186077459, 0.9106174768491055, 0.9075785024144143, 0.9068334548210761, 0.9057195531095658, 0.878948139527529, 0.9088243662205648, 0.7524591192224417, 0.6687712118902294, 0.7726756760321818, 0.6878177759469656, 0.47156117169801925, 0.657329945657183, 0.6970199959758422, 0.6724951844496847, 0.13469717221476674, 0.7452241576181038, 0.6767539849084696, 0.5707655366759511, 0.6398293476545109, 0.6782381067656221, 0.5475421969522596, 0.7288397921135866, 0.6893087088657134, 0.7112553425510362, 0.7661819762285292, 0.7441437208569389, 0.698750054082016, 0.6551453949817783, 0.7478421626913121, 0.7603205784521309, 0.7748695548946558, 0.7169784200070277, 0.7537388998052984, 0.8095538399337804, 0.8206163759715674, 0.8182759157472913, 0.727728682836998, 0.8184762869741837, 0.8143751147295178, 0.8214578922073567, 0.8258775687087956, 0.8037213204916142, 0.6179520443823033, 0.5319805944134364, 0.6026734645842071, 0.6655916283867562, 0.7034344760923199, 0.32837117947601513, 0.4531372780765519, 0.4152345222602801, 0.5719551109927119, 0.7164425093904756, 0.7391972637167084, 0.7228491219483014, 0.707825826998341, 0.6936657331655993, 0.7279126561929294, 0.6702645798203954, 0.7182480722835207, 0.7198743910510974, 0.8677274015030897, 0.8595001002760211, 0.8873446829719196, 0.8759429975826977, 0.8556402105470137, 0.8719772583032037, 0.8746015975302731, 0.8679864219425134, 0.8727686829850584, 0.35633544236863923, 0.15552400516353393, 0.1505085198599927, 0.15995950957464078, 0.16000814617642867, 0.11530527586006434, 0.42142694426735483, 0.14591954826892417, 0.1666938892136255, 0.16753806455477183, 0.15859412315729005, 0.4975323722863082, 0.1525026420548229, 0.6128987148374627, 0.17191027341247622, 0.2672496043707626, 0.15670692118062268, 0.14845765818132717, 0.7062037263120206, 0.49434485251765514, 0.703666305626993, 0.7399071135076507, 0.6923230950890186, 0.7183679350174332, 0.592723061159663, 0.6434221807132988, 0.7173895774174596, 0.6664059963485248, 0.6307962241832137, 0.6719271639891669, 0.6405251976842217, 0.622954335304853, 0.6832793207676209, 0.6042236124663511, 0.5929369520818454, 0.6712164805726141, 0.21813143681188196, 0.20265954313394607, 0.21630446758927013, 0.20762286625555504, 0.2070979436561644, 0.2130798227720584, 0.21830704922486577, 0.22147293363120357, 0.21564658442552387, 0.6410131805744093, 0.21019654217013573, 0.5629485619761588, 0.20881980791722166, 0.46657839287223646, 0.18793084000344595, 0.21976101237890444, 0.23195528219875583, 0.21597157285259017, 0.19761945685262472, 0.8660002107360099, 0.18740349049946403, 0.9011380924029355, 0.8730611052709003, 0.19345588437956673, 0.19780860621366114, 0.16704885297703242, 0.18856420514198757, 0.9194733787584105, 0.21122597722254555, 0.16654305469320974, 0.1686651950557163, 0.20904199003762125, 0.21011044791566458, 0.15556860628624236, 0.12731587703181357, 0.21041124073169293, 0.18552693744787707, 0.1973114551669659, 0.1965762883407216, 0.1922270111059795, 0.200976022154017, 0.18644711021493066, 0.20840675649513984, 0.1944095132228545, 0.19472293744441982, 0.08592872268543306, 0.1036996673389593, 0.08884853177206964, 0.09851184089949017, 0.08664993573954327, 0.08788998084061983, 0.08811658124661803, 0.07984544110352287, 0.08814302048222833]}, "mutation_prompt": null}
{"id": "aa796c2a-2fdb-41a7-a3cc-4b7caa65777b", "solution": "import numpy as np\n\nclass EnhancedDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 6\n        self.cross_prob = 0.8\n        self.F = 0.6\n        self.epsilon = 0.02\n        self.probability = 0.3\n        self.mutation_factor = 0.5\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        best_solution = None\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best_idx = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best_idx]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        best_solution = trial\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedDE", "description": "An Enhanced Differential Evolution Algorithm utilizing adaptive memory with directional exploitation and diversity preservation for improved convergence.", "configspace": "", "generation": 62, "fitness": 0.4482416048642872, "feedback": "The algorithm EnhancedDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.26.", "error": "", "parent_id": "c88be50e-b9bd-4e57-957a-21c3edd0e68c", "metadata": {"aucs": [0.8537724329944942, 0.8330164004385653, 0.8596056058562879, 0.8395711528383603, 0.8375542782405603, 0.8386625936832447, 0.8558467063081021, 0.8434482625939093, 0.8363111671453811, 0.6699328963188227, 0.6868978651191624, 0.7068564411897071, 0.6919816847928112, 0.6671419440948443, 0.6809695937877513, 0.6990835679431777, 0.6982247909342433, 0.6994039342775495, 0.12523498066399752, 0.3072866340769097, 0.3286221221742305, 0.12315613205275111, 0.3426387960663757, 0.16798852573215084, 0.17283294107623892, 0.1610690010710094, 0.21197211851558384, 0.12450519265984372, 0.10264343041599244, 0.15554750183805588, 0.22009414531952953, 0.10983438117241862, 0.11226859647826226, 0.12548558169363133, 0.13032833297573687, 0.156745374488497, 0.9693132846330843, 0.978462647966178, 0.9780799238079935, 0.9807853859956682, 0.9774425884252178, 0.9665462725582931, 0.9816810793904914, 0.9806633877049893, 0.9635824121965066, 0.5459684037718666, 0.6316545927748616, 0.6127076262233428, 0.6293777453875905, 0.5634232091087453, 0.563768798619239, 0.5318914662662801, 0.6119419010641984, 0.5912930359889128, 0.8133591596910619, 0.825909856265577, 0.8088593736865327, 0.8143887231761362, 0.8468663848793175, 0.7832624949157951, 0.829547658285384, 0.7874908208230709, 0.8173704522227563, 0.5169552815835601, 0.4957085161080257, 0.5893133199091335, 0.48265998562767987, 0.3903823936896975, 0.5470953111495759, 0.5321304789911518, 0.4400321207314446, 0.5552403504485116, 0.4836939588110887, 0.5316521547988206, 0.5973120445021394, 0.6059835065914716, 0.6105632737126281, 0.5471736733649836, 0.44218640383985075, 0.6120934763698485, 0.5619374140354676, 0.48035702015027293, 0.48888007672037614, 0.5283640676704306, 0.48415977933618815, 0.5372296177962204, 0.5167928447712067, 0.5063286364979922, 0.507635602079491, 0.44057135075450715, 0.64834074257003, 0.6220916896969906, 0.571614116218973, 0.6407017732978364, 0.610395311496193, 0.5688223448332006, 0.5748847772052912, 0.6440599760253676, 0.5922780713907042, 0.1951909498255473, 0.3582585294219278, 0.21838017225820472, 0.4407557232229494, 0.49061111152043946, 0.2625606709813286, 0.29293258158367885, 0.3372825685479848, 0.3049291395803654, 0.45093681004374697, 0.3720636136358284, 0.4409226900732076, 0.4446427944602699, 0.408606287790401, 0.36925516164936467, 0.44723459099876484, 0.45594556843471945, 0.38474515178775504, 0.7885327953498019, 0.7643588185202823, 0.7651888692227917, 0.768424406394012, 0.8047630959947638, 0.7526269332909064, 0.7651629796962686, 0.7739881034267669, 0.7498869802205368, 0.11788705146620027, 0.13884383743470696, 0.09444987120988768, 0.11980077886065865, 0.1395511783470389, 0.1242600520417746, 0.13647599041224223, 0.1161696414139185, 0.10696276267592475, 0.2009169892399536, 0.26874041004512517, 0.14726971714929082, 0.1492383679816005, 0.17684391610469008, 0.23319930828706914, 0.16219878159073509, 0.1920625649444282, 0.1757084229044782, 0.4926162811620345, 0.5198566330666267, 0.5051032207907811, 0.5175144838087589, 0.4732208804900986, 0.435542870162151, 0.4240281511315499, 0.5106222591270626, 0.4942180925741855, 0.4012714922100411, 0.36904818318053945, 0.41503702922330044, 0.3401356763350054, 0.3760677556123262, 0.37172653616518314, 0.42256237509655625, 0.4520890751786202, 0.36208683691503174, 0.1902444489589178, 0.18771211307173918, 0.19692657179727058, 0.18593313616673035, 0.20962117112674106, 0.20382352314576668, 0.19652641510331548, 0.20281027580213185, 0.19283770431041136, 0.21543450392219898, 0.47196969509060327, 0.2173123084101911, 0.22834640622639024, 0.21184141939841994, 0.5231156635070966, 0.463965446941614, 0.45486080317305866, 0.21015102278648234, 0.8084031909246785, 0.8584719094328935, 0.15221160737728823, 0.7950682914181194, 0.7721781023124649, 0.16748269843883312, 0.18657608063171516, 0.1846315868356896, 0.6802829213224448, 0.7864066415108543, 0.16568718733819954, 0.16611756592047333, 0.16463909168521917, 0.20155944786893576, 0.1666352360743274, 0.21078597573362956, 0.8383081344266766, 0.21126926848234084, 0.16988176166363844, 0.1824391899571257, 0.1760552310766439, 0.18102929923923494, 0.18035573243834535, 0.18680252542186004, 0.17358485479078734, 0.2008866670417765, 0.1762444625428845, 0.0815736837822717, 0.09393989797202995, 0.089258167858697, 0.0803188227238184, 0.07570552232256655, 0.07853043120507264, 0.09061627552113727, 0.08031024412421306, 0.08319648642424105]}, "mutation_prompt": null}
{"id": "94648af9-a32c-4528-a083-cdbf189640b2", "solution": "import numpy as np\n\nclass HybridMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.population_size = 10 * dim\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    # Multi-strategy mutation incorporating both local and global search dynamics\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    # Hybrid mutation integrating random and historical memory influences\n                    hybrid_factor = (b + c) / 2\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (hybrid_factor - e), self.lower_bound, self.upper_bound)\n                \n                # Dynamic Crossover based on fitness improvement\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                # Selection\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridMemoryDE", "description": "A Novel Self-Adaptive Differential Evolution utilizing a Hybrid Memory Update Strategy and Dynamic Crossover for Enhanced Exploration and Exploitation.", "configspace": "", "generation": 63, "fitness": 0.4044384622918755, "feedback": "The algorithm HybridMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.40 with standard deviation 0.25.", "error": "", "parent_id": "c88be50e-b9bd-4e57-957a-21c3edd0e68c", "metadata": {"aucs": [0.8003791339080462, 0.8233235663844499, 0.8013759533101368, 0.80284080627721, 0.7973128262821632, 0.8181156427841733, 0.8181454176349824, 0.8061162777625941, 0.8221162496276155, 0.6206354146303659, 0.6601865261352113, 0.672538658608701, 0.6414398499248896, 0.6695015439761235, 0.6681762411270269, 0.6556940081270077, 0.674715971075466, 0.6647119399432939, 0.11302853690241099, 0.10403950242270021, 0.09994504451968655, 0.11405440314755289, 0.10749026731532774, 0.10575842851114792, 0.12125722040035203, 0.11431278361956942, 0.10734701518306045, 0.0989434208377108, 0.09631105510963245, 0.10974268203490811, 0.09249876317334615, 0.1104456780914046, 0.09043034196241972, 0.09185685189099402, 0.09887084993965267, 0.11000065044611196, 0.5722168194950634, 0.9605713994374446, 0.6496332156677274, 0.9260924757304684, 0.8638442157533557, 0.9559235706949432, 0.7732017808794773, 0.8160144994921905, 0.9538659190894899, 0.43021873256396237, 0.4203619719660213, 0.48519218575364786, 0.5018764151567479, 0.4583836669895791, 0.4612480294620458, 0.3646935033094235, 0.506342000450805, 0.5330524644167364, 0.8165028584674713, 0.7676832805794156, 0.7641557117182388, 0.7940071229319475, 0.8081538800614001, 0.7886922571647761, 0.8039082917680404, 0.8268584971044804, 0.7776618319632225, 0.5774456141680773, 0.45422599770168004, 0.4548374500767609, 0.3103492582892525, 0.36631533852879716, 0.28780169590596716, 0.4837737614187405, 0.41113410726082944, 0.399023455980273, 0.37813008153093874, 0.3284678163625251, 0.49464802971418487, 0.2764331852885411, 0.4127440071297116, 0.42568151101828455, 0.4841179243252117, 0.49583355355218317, 0.30549666443649826, 0.5208398232926177, 0.583583903706909, 0.5396792938252688, 0.5118749655047612, 0.5415111650347425, 0.48914630447883634, 0.5589246760073228, 0.5757529410679089, 0.5672658842273908, 0.6596289211865176, 0.6547615982877609, 0.6687384541606011, 0.6291223240725515, 0.6174090327827068, 0.6300291989820617, 0.6259711660558492, 0.6431738308307688, 0.6504029023356932, 0.11495937457982541, 0.25344644555848284, 0.2338243352924756, 0.48818086230647695, 0.43945299505003954, 0.3688780188890811, 0.17913552744714634, 0.17485299835453283, 0.29799126172564916, 0.43899397019303077, 0.41484177073515593, 0.4155627713373963, 0.38150934229409084, 0.4766676320220472, 0.4478498130955775, 0.3892928738678826, 0.42756333793294365, 0.45168662257289605, 0.7627725759230441, 0.7391666375398838, 0.7422585175535908, 0.7187727674514599, 0.7496622691953277, 0.7627972401730745, 0.7593985675213468, 0.7631469366038287, 0.7497997594906547, 0.09489603764337828, 0.09859917096446769, 0.11266067941783098, 0.10432322545682127, 0.10114291066791048, 0.09491151777112117, 0.1062370159448357, 0.08753498866798304, 0.1150005030465705, 0.1367171482381052, 0.16187725610379078, 0.4843695409167994, 0.14413213608341924, 0.13950074693520842, 0.133429839367862, 0.13537547267904537, 0.12654954006868757, 0.13811366520562607, 0.43396676295471814, 0.45991659021871834, 0.4130046871521553, 0.44487873651788834, 0.423861037486324, 0.45387329837369106, 0.39973506319483376, 0.4736034882704284, 0.4655572146248579, 0.3456259524287175, 0.35759061902920153, 0.3284819076280887, 0.34402371543956, 0.38281402268627385, 0.33103029913155724, 0.3649465778512164, 0.40312386753307805, 0.36776524961945944, 0.2032424858914772, 0.2080842473064043, 0.20150232800684742, 0.2098549694162969, 0.21259793131685079, 0.19944301178313117, 0.20151369212758596, 0.19772740397088706, 0.20091322804565803, 0.1874743126394427, 0.2038063724532737, 0.19002293324857533, 0.17733477187953706, 0.18430789927017355, 0.18580556634847534, 0.18311290650025014, 0.20176572151415617, 0.18681771172057804, 0.4602921211998817, 0.1852070840779878, 0.16011826291450848, 0.744142133308415, 0.680166334654683, 0.5593194442869243, 0.8012896833512448, 0.18429634582220422, 0.18175331558872265, 0.16610102387666026, 0.20167930252194277, 0.2014393048319385, 0.7268989061019675, 0.20053302675216245, 0.19524615938980672, 0.2072945592116029, 0.5798550331423573, 0.20795209406744264, 0.19750071832371574, 0.19702387662123355, 0.1758463426402228, 0.19051467763574215, 0.21701064690583083, 0.1747601653248113, 0.18687524605817052, 0.18280923597709176, 0.19042939922484503, 0.08089016121554637, 0.07560755890726956, 0.08543519639545905, 0.07883944662374254, 0.0772926651418655, 0.0759592355779447, 0.08005256929781412, 0.08349745736396275, 0.07952395761832376]}, "mutation_prompt": null}
{"id": "4af4ade8-41fe-4973-b8e9-5a3b13c3469b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.5))  # Reduce size by up to 50%\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = self.population[indices[local_best]]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveMemoryDE", "description": "An Enhanced Adaptive Memory Differential Evolution Algorithm that employs variable population size and dynamic exploration-exploitation balance for optimized performance.", "configspace": "", "generation": 64, "fitness": 0.5376547282834975, "feedback": "The algorithm EnhancedAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.31.", "error": "", "parent_id": "c88be50e-b9bd-4e57-957a-21c3edd0e68c", "metadata": {"aucs": [0.9071831372340875, 0.9057003855926455, 0.905640241912205, 0.9030870451112304, 0.9017613577407845, 0.9215025382056471, 0.90707754465878, 0.9063706562864122, 0.8973586975234522, 0.8387435755101685, 0.8272183327462026, 0.806001480927685, 0.8312158333966504, 0.8248832445346704, 0.8242946037434973, 0.8239675698083089, 0.8360851647108608, 0.7283678611828498, 0.16699674703355993, 0.1713895505246441, 0.5687332958340978, 0.14659016580344375, 0.5755165574798349, 0.17847101749929173, 0.5775697980251964, 0.13724216413785417, 0.1605705417679153, 0.1371476046753065, 0.15088072663597452, 0.14316880685374944, 0.16830092220197435, 0.09991625295363304, 0.12437806347595326, 0.14042165825663067, 0.10192168239856514, 0.1348144680001253, 0.9579808200850186, 0.9713832234314449, 0.9875726362785284, 0.9758611691809301, 0.9788939260178187, 0.9762134878917756, 0.993440430135797, 0.9851579541523776, 0.9770739825409072, 0.7732972291434148, 0.7649407653434338, 0.7374090189946579, 0.7349015715958194, 0.7399679890062261, 0.764892466868963, 0.7565580203642926, 0.7459951076168007, 0.7825992678718076, 0.8971743870981382, 0.8156346657561507, 0.8997024196336525, 0.8809479311693968, 0.9261245387638721, 0.21923592320099483, 0.9110264882054794, 0.9008980718899312, 0.9309279787199337, 0.7064275514860682, 0.7290033901392305, 0.7244303280498315, 0.6380591651238965, 0.1326751504330952, 0.7347454101147601, 0.6241446394840051, 0.6893374630591996, 0.6236716739335773, 0.6966225575936863, 0.6461475628992976, 0.7978501254991863, 0.678600781478526, 0.7288293492857698, 0.7740188539613356, 0.7458509030911109, 0.6685503298207548, 0.6486223825424333, 0.8091600140281711, 0.8048660906361225, 0.7961593311771671, 0.784916202451087, 0.7859881700989699, 0.7272828881289564, 0.7791795040392593, 0.7422851867669004, 0.7929060898996085, 0.8176827804403886, 0.8586576722654213, 0.7715817487340539, 0.8057798508905147, 0.8010680614016569, 0.8314823604336382, 0.8300421512208798, 0.7686444519680191, 0.8222396512871838, 0.5831837717274229, 0.6165917480411618, 0.6073965577233117, 0.3425152153605413, 0.7257700135530405, 0.723768812252743, 0.2553453829816792, 0.6523650894935689, 0.3275369597089762, 0.7192571836962679, 0.7127555565902008, 0.7292552748685991, 0.7340316871101968, 0.7393307643229154, 0.7433077513654363, 0.737268980617859, 0.6582797993055179, 0.7486575876287143, 0.8808177512855119, 0.8833484119372629, 0.8881284694781469, 0.8764796980070184, 0.8677401989881974, 0.8847271425363405, 0.8875560142218328, 0.8845430390780242, 0.8734348513400285, 0.16913079647834584, 0.1499198780419152, 0.13648257874686964, 0.14272288656344934, 0.14942717294456964, 0.132758105978679, 0.12958398832680618, 0.14042546651947452, 0.14836233153981848, 0.14474635520140033, 0.19811806654122954, 0.15971587661945486, 0.17108122822859673, 0.2298597340505737, 0.12305580745671996, 0.19711484223996623, 0.32965497378420483, 0.20456256182749355, 0.5919427854585452, 0.7374580336331551, 0.7145075563151083, 0.7424691849094689, 0.6199765701805868, 0.7391799055399434, 0.5778525444854947, 0.7465861557819731, 0.6566409014669701, 0.4685236092462707, 0.6398246349268033, 0.6932975342391146, 0.42450635511554535, 0.21677174486794337, 0.5916354930292811, 0.5475479035984334, 0.6786194257079203, 0.7015078131689055, 0.2322715805410126, 0.20718971847303858, 0.20088509149193123, 0.21830315021673763, 0.21926119796743837, 0.20918626433765464, 0.2069531568683195, 0.21559942022174394, 0.19889942284541762, 0.20624739657484858, 0.7548053182994526, 0.2407634726386968, 0.7757626878666799, 0.19764748862816772, 0.20921469915730107, 0.7159556444954711, 0.21605486263190865, 0.2221328033663864, 0.16421824458535905, 0.18339167094538855, 0.18659469681079976, 0.195342977640652, 0.19936877393126584, 0.8677640485587249, 0.14120657305212914, 0.9192710615117136, 0.18827102652994931, 0.12705787573001948, 0.2084971801410367, 0.8312167819844185, 0.16757020642406784, 0.20132962752892658, 0.1542845315814506, 0.1517802203791967, 0.9225886843683483, 0.2139726221766699, 0.1932244315629914, 0.18111718759344497, 0.201407080467914, 0.18429330972045077, 0.17949321815895714, 0.19394783816266326, 0.1885579109996044, 0.18844762478734, 0.1999320909348199, 0.09728530485942444, 0.09813681379498562, 0.09753185670595199, 0.08815006981180251, 0.08882508454409277, 0.08859841512386357, 0.08685459908576199, 0.10220429927464814, 0.09177888795763578]}, "mutation_prompt": null}
{"id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "solution": "import numpy as np\n\nclass HybridAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))  # Slightly less reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveMemoryDE", "description": "A Hybrid Adaptive Memory Differential Evolution with Multi-Elite Selection that integrates learning from multiple elite solutions to refine search efficiency.", "configspace": "", "generation": 65, "fitness": 0.5513924132408694, "feedback": "The algorithm HybridAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.31.", "error": "", "parent_id": "4af4ade8-41fe-4973-b8e9-5a3b13c3469b", "metadata": {"aucs": [0.9043907676140445, 0.9092614103437231, 0.9077471078302981, 0.9053249922843473, 0.9115310356224651, 0.9125897826958536, 0.9054600245764259, 0.9004538369954094, 0.9063267790499948, 0.830828915921143, 0.8142461258427698, 0.816565394309896, 0.784346643088049, 0.8199189173379613, 0.8247835889466715, 0.8291863345824162, 0.8279673840037479, 0.8275987827213401, 0.17073677778463303, 0.16540679586256024, 0.16601509119260172, 0.16929036137291553, 0.1560931559416313, 0.1615536704538667, 0.15220812767602987, 0.41041404506715384, 0.12134779539196838, 0.09760447473407352, 0.10458922589551056, 0.11852397813731497, 0.17238162008046676, 0.12425480479545581, 0.12953586019838292, 0.1690067003282817, 0.11991279884212813, 0.11417669533819186, 0.983857411138851, 0.9470609256526044, 0.9523865289832453, 0.9749654031387638, 0.9421340627968957, 0.9782085811706563, 0.8824154050108413, 0.9721153534612165, 0.9947787571167671, 0.7555848453257543, 0.7775101218180237, 0.7683941059754559, 0.7815793763477522, 0.7915775485033991, 0.782469461128421, 0.7926815700555506, 0.7976798356872024, 0.7961640365520177, 0.9160279078291091, 0.8878648872200029, 0.9272810482886745, 0.9087911701684476, 0.8995032621382366, 0.8950081464016162, 0.23292682152776556, 0.9094735499825526, 0.9082766112208539, 0.7281125204938826, 0.6076779114368824, 0.7439249571289215, 0.6785380408339343, 0.7086679747039044, 0.7933463145552109, 0.5662735008544397, 0.6370308104346228, 0.6617586653324902, 0.7162516075561352, 0.13127309550204913, 0.7526611709727105, 0.6184538668849104, 0.6834469107140462, 0.761558093515236, 0.7053605838109658, 0.6267468907783331, 0.7464968015014086, 0.7631723519542932, 0.7967225575448265, 0.7661943741692301, 0.79327188880734, 0.7913198956974672, 0.7469276241923768, 0.795004029534856, 0.7811806855387784, 0.7755377506849425, 0.7935607241973811, 0.8310587208429435, 0.8039795937451653, 0.8373438201080413, 0.794032229274515, 0.8146188566671521, 0.8089767984133063, 0.8414293465105843, 0.7273771194795711, 0.48001326689152546, 0.619746520598095, 0.4183953372411108, 0.566877432544981, 0.7001529551526218, 0.7029961687966315, 0.6891892344811819, 0.4688628182978102, 0.3561343111333114, 0.7320886466518355, 0.7383756822687426, 0.7262393027477625, 0.7423208727040982, 0.7283961828950151, 0.7549957914062433, 0.7139151010284683, 0.7160720853660123, 0.7351062559879453, 0.8797035444720761, 0.8823087394977789, 0.8796128697324225, 0.8806867287767814, 0.877602440838727, 0.8840837859844183, 0.879528249953215, 0.891455434779084, 0.8799269847942973, 0.10781963150892337, 0.1312091995165391, 0.17506721219258525, 0.1461126177291353, 0.13360146245471682, 0.10768727286471991, 0.1393041258793304, 0.14285905379548225, 0.13786230973944258, 0.25980108002937463, 0.20471263203969692, 0.6300428571329081, 0.1432672197033733, 0.19187206641165466, 0.21726027278400228, 0.707158570160729, 0.1875689565575862, 0.23380725398753044, 0.7240399790554295, 0.7321510683460117, 0.7376688452287954, 0.7326358647609614, 0.7185397543408745, 0.7444527172897096, 0.7321482701785015, 0.7017769566695361, 0.58192549413143, 0.7231034939778032, 0.4272784946614915, 0.4660412735849816, 0.5717104961518795, 0.689080099383754, 0.569931625889048, 0.69922567031898, 0.6794469178389277, 0.4726636312168323, 0.21462107408081188, 0.2088718388635492, 0.22450788808205902, 0.20272642017694575, 0.21384881026529667, 0.20907329554548237, 0.20053010845716468, 0.19822686000235068, 0.20637913596081492, 0.6950639884623435, 0.21913237534935093, 0.22093464920479833, 0.8126914037475946, 0.21770376620216092, 0.24204931207963987, 0.7431770305645036, 0.2476473017446389, 0.21601084268563986, 0.9010887743523728, 0.9394827085941141, 0.18612801498352916, 0.16221374624215945, 0.2127827573574611, 0.13097154214514561, 0.922905349646551, 0.1663058758911622, 0.9240261812648839, 0.9122721298487451, 0.1688927368880695, 0.16664501037934953, 0.1678706669847374, 0.21017416229980723, 0.15317027721241006, 0.9246616030312909, 0.10404424419054903, 0.896335570172045, 0.19357380580456907, 0.19595380600292145, 0.17743253196532738, 0.1958752874990951, 0.19651963616009827, 0.17527886613114207, 0.18752436618627666, 0.17426381849842087, 0.18961320464522724, 0.08523545136179289, 0.08630774057312685, 0.08907172105102179, 0.08778216200965983, 0.09240530935628577, 0.10734575885038977, 0.08053596609304714, 0.08489197931367176, 0.0847765811580522]}, "mutation_prompt": null}
{"id": "096793a2-3c0c-483a-867d-0f760ee953f9", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.85\n        self.F = 0.6\n        self.epsilon = 0.02\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # Enhanced reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.15))  # Slightly larger elite pool\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def stochastic_local_search(self, individual):\n        perturbation = np.random.normal(0, 0.1, self.dim)  # Small local perturbation\n        return np.clip(individual + perturbation, self.lower_bound, self.upper_bound)\n    \n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(elites[np.random.randint(len(elites))] + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                if np.random.rand() < 0.1:  # Occasionally apply local search\n                    trial = self.stochastic_local_search(trial)\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveMemoryDE", "description": "An Enhanced Adaptive Memory Differential Evolution with Stochastic Local Search for improved exploration and exploitation balance.", "configspace": "", "generation": 66, "fitness": 0.4672643915116276, "feedback": "The algorithm EnhancedAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.27.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.8370757027146687, 0.8258203518446726, 0.8287167474739408, 0.8458347053154616, 0.8482463878210939, 0.8255902877881595, 0.8472157752488458, 0.8423001229133351, 0.8418696082123558, 0.6276439290649205, 0.7246964948943435, 0.7000563067163563, 0.7276794662079522, 0.6521278357710001, 0.6786629292421085, 0.6811183750085927, 0.7173248207043481, 0.7070338777686556, 0.16186278259639897, 0.16174324283401098, 0.12692370996185476, 0.1309155109927317, 0.1100477996535425, 0.2679696591612769, 0.1267846660494315, 0.3392779707197413, 0.1174542896098898, 0.12960106549316774, 0.23602562772434488, 0.125409128371766, 0.11409984563672682, 0.11093328380675938, 0.1307774236474708, 0.14684681850539272, 0.11086356683621812, 0.11737303015549605, 0.9856918479131507, 0.9797510280123355, 0.9814130149612439, 0.9569428716144271, 0.9584098769946574, 0.9588082857978145, 0.9837990048129471, 0.9848486859594924, 0.9663993246252602, 0.5371931736840596, 0.5996982171998466, 0.6384199156965574, 0.6049846941527509, 0.5689659346666114, 0.631835084748743, 0.6422833788331267, 0.5522370516040811, 0.5617540418086803, 0.7902469880927205, 0.8534185197630693, 0.8212004043746848, 0.8807538918648566, 0.8292520423286096, 0.8481083155232303, 0.8335162427430771, 0.8089710067195828, 0.8517098262647023, 0.4922994404924196, 0.6199509411830066, 0.6020005314098182, 0.5923652688523253, 0.5222568385084406, 0.644298350114176, 0.5852158583401152, 0.5546845700831469, 0.5801281284314928, 0.6271723062318248, 0.5797281603331574, 0.5004025510932331, 0.6482433228833674, 0.6148812212882933, 0.566766334288149, 0.5205760609754306, 0.6030000560176845, 0.6076242455383729, 0.5923939385243115, 0.6368121939785795, 0.5534728296059772, 0.5885529757889678, 0.5920639256577118, 0.5547286306994763, 0.6224980416991547, 0.575363386785438, 0.5585529588204561, 0.7026739678031342, 0.6586827613068511, 0.7002493206866911, 0.6702286319254258, 0.6590555247335884, 0.6529472484751877, 0.6568820446925805, 0.6925611144757591, 0.6886787486878656, 0.2694962419231862, 0.3025087310365129, 0.3343829488775335, 0.38993724123676865, 0.311754682485758, 0.26274286405105773, 0.3127166477519401, 0.3409660025077573, 0.3056585367885237, 0.5121837209397702, 0.48768228067098596, 0.4525249109639363, 0.531400340021813, 0.4435773455716848, 0.5687699964394247, 0.46913093357758917, 0.45655636546576195, 0.4957388681903443, 0.8052196233240662, 0.7891072138551364, 0.7927591399850965, 0.7963993184012795, 0.795259175517898, 0.8175242665685929, 0.8094200326776733, 0.7751161494312403, 0.7890664510722285, 0.09291581522362469, 0.11412277989940645, 0.11791877410077778, 0.1439294150444992, 0.0964851363500907, 0.11407975159926587, 0.15874952699015554, 0.24277414838066014, 0.13383308516325254, 0.2204359767188836, 0.6959693236184588, 0.25706616913675184, 0.22368806219609172, 0.18784845837558906, 0.14598258530434305, 0.2970610217115148, 0.19432705960777652, 0.24755849957495957, 0.5087626132972534, 0.46585590594059234, 0.5362144950088688, 0.5071166618004046, 0.5117215836565563, 0.41523785884021214, 0.5167508208474783, 0.49321962042703926, 0.5171112038590411, 0.42895898902819307, 0.3992362613412551, 0.4241178257620096, 0.41126763303606484, 0.3899742895638253, 0.3714485215325517, 0.41460050331171583, 0.4162743278241856, 0.43706778536350643, 0.17869499708246384, 0.18668067901795315, 0.18152323150463168, 0.192983632641476, 0.18005092426879832, 0.18220914774235286, 0.2088593551314788, 0.20763624769801559, 0.19607453253456086, 0.4738609274410339, 0.21092988607748808, 0.23026352715960086, 0.5567295937018424, 0.20655554663214315, 0.2268425013520644, 0.21215611257689393, 0.43036792499816345, 0.23871284516698188, 0.8348425065298245, 0.8724281819364784, 0.17091143948065401, 0.18532250012617169, 0.8438759632185531, 0.17540727648414745, 0.167399662951758, 0.7978582260034355, 0.7804100214878598, 0.8668466707892097, 0.20531985639304595, 0.16710344441827907, 0.7758586825923535, 0.20834148628566718, 0.20507577904970287, 0.16896170062981397, 0.1555793459806355, 0.21214424693395517, 0.20500142677666944, 0.18592093004923205, 0.186942234605616, 0.1803980241043639, 0.18805130261929326, 0.18450584482165822, 0.18941822908044614, 0.1804814032288583, 0.18214403941031765, 0.0757780879246237, 0.08487928051151172, 0.09384160281574627, 0.08259066568054751, 0.07997397731565548, 0.08528137642381894, 0.07287725315145477, 0.08000793782744042, 0.07638557973543592]}, "mutation_prompt": null}
{"id": "e492d788-d8bf-4ae2-9b9c-d88b21a3e493", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.5))  # Increased reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.15))  # More elites selected\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + (np.random.rand() * 0.05)  # Adjusted control\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + (np.random.rand() * 0.05)  # Adjusted control\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + (np.random.rand() * 0.05)  # Adjusted control\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + (np.random.rand() * 0.05)  # Adaptive crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveMemoryDE", "description": "An Enhanced Hybrid Adaptive Memory DE utilizing dynamic mutation control and adaptive crossover to improve convergence.", "configspace": "", "generation": 67, "fitness": 0.4719921240227268, "feedback": "The algorithm EnhancedHybridAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.47 with standard deviation 0.28.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.8832861131187781, 0.8289717186641432, 0.8094424541502968, 0.8437139110378287, 0.853228600892609, 0.8615707136743767, 0.8561518392143459, 0.7873900570343022, 0.8002558863616138, 0.6874116576236082, 0.746502156729504, 0.5473502320939456, 0.671998385129248, 0.5883372567818008, 0.7043231251536296, 0.6830866885353494, 0.6626778526601591, 0.7425289635798725, 0.12949081875876367, 0.12778109761457368, 0.137908972144984, 0.12676650026592595, 0.4157238344499796, 0.10602454891211166, 0.14425187177612353, 0.11932011007858268, 0.10857445968511803, 0.13094512159044425, 0.11289011910831215, 0.13105739172143838, 0.12192714343866229, 0.11981973088374342, 0.11000428295712861, 0.15015772576526032, 0.10212741911484369, 0.10529721267055958, 0.937079377150411, 0.9541451422968406, 0.9695985860412301, 0.9508436252438328, 0.9102694971919085, 0.9480635591776375, 0.9615059633441814, 0.9411551701799948, 0.9917815918010069, 0.5871743881578863, 0.5763671424683144, 0.5823285525623132, 0.5746384578541645, 0.6409316322266754, 0.6362329118601352, 0.4878123503532543, 0.5758546986674233, 0.6490192315716483, 0.9345043766342053, 0.8942617274177077, 0.8951487124543227, 0.8911393289166339, 0.9007322861298445, 0.903919301887694, 0.8986897951072663, 0.8528929068333309, 0.8840466920257354, 0.7356151789194999, 0.41447335888421744, 0.49108167829500393, 0.601444436657704, 0.6328993846388788, 0.5431191252168468, 0.6654626392809264, 0.6288407945935054, 0.5239820636764982, 0.5583293196431764, 0.39797756582272237, 0.5440788273202746, 0.6464628229384746, 0.5670851077406105, 0.5169791928524435, 0.49936561285821757, 0.4961234336200985, 0.640877622522541, 0.6127823249492557, 0.5970448836683354, 0.7008202220845987, 0.58120799865151, 0.6848759393032204, 0.7313463463943903, 0.7057238464574153, 0.7517186958949551, 0.6787881250892849, 0.770457031392106, 0.8240552078183815, 0.8270033330541608, 0.7650384481545304, 0.7861191784788076, 0.7414724817794418, 0.8057939887345656, 0.7487034439656327, 0.8109746668540037, 0.2875051594142808, 0.2902422216576246, 0.23401602059314142, 0.45259275178385405, 0.6072473326334185, 0.5245958964953578, 0.30395057848484963, 0.2509328634410596, 0.25446977632924916, 0.5600080756545527, 0.4637112859246786, 0.4734663938768806, 0.48922933565013504, 0.48752429666322994, 0.4444757642329381, 0.4633957911195461, 0.5514622444140302, 0.3909620355126463, 0.7167022702571344, 0.840127968047744, 0.7832865440295581, 0.8385943316943831, 0.8447587228998868, 0.7950959787841183, 0.8295281652603477, 0.7835818662220202, 0.7511903735042302, 0.15965019716095707, 0.12560751416379567, 0.6391749434084211, 0.1207910113387477, 0.10174757734957474, 0.15501413116077223, 0.1103800325954537, 0.15369215815771964, 0.132981012286276, 0.154747097006948, 0.16724392202536742, 0.15132544186348584, 0.257675666507, 0.4224287758475803, 0.14350037271459892, 0.2041867605969062, 0.21777870648512287, 0.28068252800664073, 0.4120480515377608, 0.4428949200932989, 0.5303765725934562, 0.5416347516379125, 0.5578044618745279, 0.4220636138256938, 0.5116953341005159, 0.4763767272120797, 0.5244762190170158, 0.3881281259491214, 0.3067280682054804, 0.4690672474464108, 0.5766161306885433, 0.5646230070657536, 0.44088953856856405, 0.505412926278666, 0.4966975846776458, 0.43994129955320427, 0.21009580199485445, 0.18550466254828146, 0.19213399005747633, 0.22059595033515988, 0.19735696541747683, 0.22161135810741917, 0.1999831078779568, 0.175955948086583, 0.21221185417504063, 0.20207206555066037, 0.2183136030967593, 0.2328129144611355, 0.20269746927185617, 0.24391946605415582, 0.201830879067317, 0.21775803038288022, 0.23677632338052124, 0.24456019601538237, 0.17117665033342688, 0.19699452270052042, 0.15246112448595284, 0.19618423905280602, 0.16108723705348615, 0.8649005624227162, 0.9106202195547258, 0.8332175830334967, 0.1694237354670799, 0.9009701938178614, 0.2102129393751333, 0.15546797494112086, 0.8879021927838234, 0.20768058819833202, 0.8933916960387948, 0.12768669164154633, 0.21168670569833148, 0.21320931779755004, 0.18485305022151288, 0.19293422826191253, 0.17451149374292796, 0.1984985551471936, 0.1820036563560231, 0.18964629003764044, 0.1979965619716596, 0.17278495879594025, 0.18635187804493047, 0.09663774475402409, 0.07595985183262388, 0.0862567220488396, 0.09149202757266661, 0.08307302094961055, 0.07706151033354203, 0.08351487632496934, 0.08708865383752906, 0.07387516768209501]}, "mutation_prompt": null}
{"id": "8ba34de9-cdcf-4be0-bc50-612f2b4f13f7", "solution": "import numpy as np\n\nclass EnhancedMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.5))  # More reduction for exploration\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.15))  # Increase elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * (0.05 + np.abs(np.random.randn()))  # Dynamic crossover\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedMemoryDE", "description": "An Enhanced Memory-Based Differential Evolution that adaptively alters mutation strategies using elite influence and dynamic crossover rates to enhance convergence.", "configspace": "", "generation": 68, "fitness": 0.5402580877554906, "feedback": "The algorithm EnhancedMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.31.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.9128113972171003, 0.9071039260079512, 0.9009071008600831, 0.9071942740529186, 0.9126033308983035, 0.9034018909958161, 0.8975776585199468, 0.9075590985229033, 0.8985531250051497, 0.8124146853722435, 0.8300308757418465, 0.8019657866350192, 0.8245601927031776, 0.7098283765169908, 0.8245179887739448, 0.828986544429309, 0.7791472987563691, 0.6843851018535066, 0.17565954189713884, 0.14445288782634902, 0.16556224363188954, 0.1372789694228863, 0.14179062396855568, 0.1467319987101644, 0.1110631973424746, 0.1108878240222293, 0.6462371978766583, 0.1315434633740692, 0.10344351211478586, 0.1087813175155603, 0.11160977827736018, 0.12474886811712982, 0.12561170328981808, 0.13630727430843637, 0.11376195088130248, 0.10934906170054148, 0.7778375344732555, 0.07467368054438028, 0.8341345298067959, 0.8466927933039144, 0.8056241056706258, 0.869084762146114, 0.9453922088242849, 0.9607899277882281, 0.9645740096444517, 0.7606629526611673, 0.7405262289306482, 0.777091798869239, 0.7818582522020114, 0.7647884915447222, 0.7823212850327569, 0.7589090429006797, 0.8056032915412014, 0.7810622478598648, 0.9278720178508149, 0.9113329820323384, 0.9229709962598113, 0.9198119057370204, 0.9240761911399268, 0.8951285095064911, 0.9212314027729975, 0.8873127464392558, 0.9171920225990311, 0.4868705129697273, 0.823690417721674, 0.7431571808275554, 0.13325325131428456, 0.6309935145461253, 0.6351441542782734, 0.6074343293812918, 0.6987083089424058, 0.6663872905986031, 0.4875026047576676, 0.5782968691721808, 0.8173573462819026, 0.5043271686878419, 0.6231376649792587, 0.6153232556905499, 0.6544714560144134, 0.5472166423052554, 0.6178124133060693, 0.8199075917372449, 0.8190510773758882, 0.8216728623324923, 0.8191413166123032, 0.8259234516693985, 0.8405568118075364, 0.7929339825696917, 0.836816941602756, 0.8251760646323772, 0.8490509606905231, 0.8414433600087178, 0.8402529401732868, 0.8557827621319077, 0.8380675361828352, 0.7893516930315577, 0.8553497881992722, 0.8050104163251807, 0.8516313027824189, 0.272428901106503, 0.6325723629896705, 0.6582093594669247, 0.5782495310446216, 0.7465491102579933, 0.7688719415817539, 0.5263879789025275, 0.40339683633720613, 0.3386342825673079, 0.7476778970791762, 0.7553766061788432, 0.7624141075206348, 0.7348793969881044, 0.724084898277172, 0.6760546761626798, 0.6834636985524281, 0.7543545279289873, 0.7702215692834625, 0.8839583330084712, 0.8745554746614526, 0.8906879908805958, 0.8936845720126523, 0.888529978742002, 0.8897707385227231, 0.8786694323910463, 0.890698398230673, 0.8868115615879595, 0.17135566245748235, 0.14869391049892877, 0.1494712685682663, 0.14878486758337583, 0.605548428237314, 0.166342463427801, 0.16628069417774916, 0.15315020627092124, 0.14113343683393542, 0.2668090588383203, 0.23801818352152104, 0.2936249228627349, 0.14389456253210064, 0.35283297614777276, 0.18500331840039952, 0.768023906986516, 0.1600722837885421, 0.15927330798345596, 0.7066083419498106, 0.5793709128444033, 0.7254391140669048, 0.7218510057467273, 0.5052332863458768, 0.7508538084695857, 0.5492109895638291, 0.7157844095466368, 0.7554793261347601, 0.673850924328804, 0.5456582623423761, 0.542221456860654, 0.7232534556010515, 0.5568277514761684, 0.6772872375103871, 0.6809158384836232, 0.688081224833068, 0.7132377751882732, 0.2399179864650921, 0.18787734701776249, 0.2067655889520944, 0.22185120684931758, 0.2281593364922333, 0.21121863730164814, 0.23792271108470564, 0.2119292604569576, 0.23621187779474062, 0.19913790616760485, 0.2166917861664619, 0.20547823764506756, 0.22146803673193982, 0.24207304225509763, 0.20421511896639755, 0.20820311194100272, 0.18536321206735484, 0.1953040972586717, 0.17249102005818062, 0.197438043482703, 0.7850894916643749, 0.171463477465418, 0.19570162404764024, 0.16799756171526858, 0.9034868592704629, 0.14858804388935098, 0.9234633630373907, 0.90464190189458, 0.2105374501199162, 0.646708206270059, 0.16833248222249808, 0.875347259758323, 0.9012988704193288, 0.1281370463575351, 0.20695902105303077, 0.7718627385595853, 0.1886466035732618, 0.1783257564953965, 0.1907658541477032, 0.18129826346874056, 0.1886338880204005, 0.19883642354188802, 0.20270284847946674, 0.18342170778504407, 0.181667490470257, 0.08388909105646913, 0.09745328670546238, 0.08290594097057091, 0.0903979053449675, 0.09012945706203501, 0.0828780031900378, 0.08473370583122775, 0.08578547942465287, 0.0781383171825124]}, "mutation_prompt": null}
{"id": "4ad3429f-b71f-4600-8d9c-4414a2999d65", "solution": "import numpy as np\n\nclass SelfAdaptiveDualStrategyDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # Slightly more reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.15))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    if np.random.rand() < 0.5:\n                        local_best = np.argmin(self.fitness[indices])\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        local_best = d\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(local_best + F * (e - b + c - a), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "SelfAdaptiveDualStrategyDE", "description": "A Self-Adaptive Dual Strategy Differential Evolution integrating self-adaptive control parameters with a dual mutation strategy to enhance solution diversity and convergence speed.", "configspace": "", "generation": 69, "fitness": 0.36777467724090135, "feedback": "The algorithm SelfAdaptiveDualStrategyDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.23.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.7255122061383905, 0.6978698134981789, 0.7343269561975494, 0.7283228648118447, 0.7438671598976277, 0.733033814985713, 0.7435136129533431, 0.7231083257768438, 0.7510270270038117, 0.5638908064108741, 0.5979059578643922, 0.550441643361204, 0.5503897002585422, 0.5443360077145787, 0.589036222946264, 0.5932101353526766, 0.53904543885132, 0.5228769487594416, 0.110338884338959, 0.12529708318220167, 0.10599916399706166, 0.09596048171667226, 0.11174912844137419, 0.10050456940659092, 0.09968974455818502, 0.1071463527615768, 0.1076563124948261, 0.08576879859598463, 0.0928338419838316, 0.0881965728587516, 0.0816034872995548, 0.08853326261307426, 0.0853025844997044, 0.09675195712716489, 0.09810288619869367, 0.09329880739936247, 0.7474018768168871, 0.8738121724373973, 0.953472707984962, 0.9534210745421803, 0.942519577526037, 0.9151523239479199, 0.8668807085888396, 0.9215324839578487, 0.9241251644978405, 0.41917788536074985, 0.4184304338178092, 0.4204579347199783, 0.4066065834419351, 0.34082471899623, 0.43191235795751615, 0.4776614226683603, 0.44713239308335406, 0.4121972672842199, 0.670376635204627, 0.7025704251323905, 0.7107486738770172, 0.7236140865300826, 0.7602983285950732, 0.7360255686937143, 0.6962720773531335, 0.6937381124888768, 0.697076424395402, 0.38563640508202446, 0.460577476035675, 0.35930157275877794, 0.432456227303443, 0.3226906805273023, 0.3873366754986196, 0.41043152530754046, 0.4499793021442512, 0.41115580277784625, 0.37050092961463155, 0.39615554323961444, 0.46989714701581575, 0.39596460253764476, 0.3826461174220751, 0.43082026735924994, 0.37966776329946295, 0.4137127561759846, 0.41403369152160063, 0.4226442707488264, 0.43412399743205665, 0.35224668289155214, 0.43244538525059206, 0.43146138892203945, 0.38908977335877004, 0.4200594403258717, 0.3977560680725909, 0.3300702106359944, 0.5382426602048191, 0.5342867156400304, 0.5492277172405116, 0.5215923193654438, 0.4865747887046392, 0.48810103114085013, 0.5294179893346931, 0.538554384548193, 0.5825818762962739, 0.18173494960721592, 0.13407821896153493, 0.1788328453514656, 0.19644347181097077, 0.14515029697498083, 0.16077700986459564, 0.23518092182726924, 0.12127601544972388, 0.1483513631234249, 0.3386905426503909, 0.30726182476209785, 0.3116558818060752, 0.29295979471122413, 0.32164286090005967, 0.3200343824139481, 0.32783708335158446, 0.32634618961763384, 0.3412278639403086, 0.6477950597004085, 0.663001264360668, 0.6966554728342664, 0.7067214166077689, 0.6650542023433215, 0.690233627438902, 0.6749902552609957, 0.6843312065084172, 0.700540122752406, 0.08802585980903044, 0.09549136205064968, 0.10711794153127119, 0.09644255511551658, 0.08813925080707086, 0.08800096917094125, 0.11261064391842723, 0.10404073144336667, 0.10279404458316077, 0.22599849647185277, 0.14054489400534842, 0.1895515913029403, 0.14713034792985857, 0.12564748457832464, 0.12861616899778783, 0.13832541553322475, 0.17220169989380063, 0.16635188295427938, 0.30658624058808936, 0.36770062491131095, 0.3616748910160893, 0.3610231716372656, 0.34780243896903007, 0.34408445751627303, 0.3935255435409415, 0.3658203819654354, 0.36743490186389594, 0.2832211321668521, 0.2606044941483556, 0.27144695943427244, 0.25125561838939436, 0.27529837374650024, 0.2842100869566587, 0.31107575351704353, 0.2949972398459587, 0.2498126407096143, 0.18917056763071727, 0.17292882190700798, 0.20463654901203399, 0.21813288115763485, 0.174037156718296, 0.18038207878968937, 0.17854440870851174, 0.20481548054514565, 0.19032560504258222, 0.18217769336933975, 0.18313953888483758, 0.182990528985306, 0.1743581360393056, 0.17408069210216126, 0.1823135935256016, 0.1800147352152579, 0.17522719447261748, 0.1830984114017531, 0.6213750267082212, 0.16137861555547206, 0.7094244018657662, 0.44807114127838343, 0.17816238436705112, 0.1779967754247056, 0.42323415109118245, 0.6474072091757679, 0.7382433149808689, 0.7638457584434618, 0.5923582973804519, 0.5286418162475885, 0.18862074772084803, 0.4270611018171867, 0.6356195466716839, 0.20441473724047798, 0.2063378975960859, 0.20720684185002358, 0.19719473875359517, 0.19340943517765685, 0.19774292868578536, 0.18242981617480758, 0.1674980622582869, 0.17952557929261181, 0.1873787558796921, 0.1919878151277572, 0.19339813491090851, 0.07638889000222138, 0.08323787291780371, 0.07780400803892151, 0.07640519022152459, 0.07770901494000848, 0.06946677039831717, 0.07255632823681846, 0.08209297027881035, 0.0885905299728047]}, "mutation_prompt": null}
{"id": "3c3f3b19-cc9f-416f-a551-f8e3decf22fe", "solution": "import numpy as np\n\nclass HybridMemoryEvolutionStrategy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.2))  # Adjusted dynamic range\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n    \n    def adapt_crossover_probability(self, eval_count):\n        return self.cross_prob + (0.1 * np.sin(0.1 * eval_count))  # Dynamic adjustment based on evaluations\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = self.adapt_crossover_probability(eval_count) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridMemoryEvolutionStrategy", "description": "A Novel Hybrid Memory Evolution Strategy with Dynamic Crossover that adjusts exploration-exploitation balance using historical parameter learning.", "configspace": "", "generation": 70, "fitness": 0.5248114540085458, "feedback": "The algorithm HybridMemoryEvolutionStrategy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.30.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.9072977837632811, 0.8897485263255179, 0.9075935972086098, 0.9139488619935807, 0.8958873936785607, 0.9216165353601862, 0.9002526761011815, 0.9092267115444719, 0.9009271866822649, 0.8225315404995069, 0.7943977887384053, 0.8223632680191497, 0.7845040450599371, 0.7704755586816311, 0.827961879715624, 0.810598051900137, 0.7951291661067166, 0.8183283175766272, 0.5873071996960249, 0.5916242184264098, 0.46415052973395154, 0.16300109737081636, 0.1737667227707259, 0.1676460306198454, 0.16618466059504988, 0.1671430770245843, 0.1575157574182362, 0.14246120356849445, 0.14594720862424182, 0.13850668468001326, 0.11449114523251902, 0.10938746678079037, 0.15622257125103511, 0.16681598558952937, 0.14753952867071674, 0.10154374574386837, 0.9698620077120813, 0.9740158295717007, 0.9479370976262377, 0.9833964298710258, 0.9811736087731828, 0.9835608971669784, 0.9670121721525302, 0.9751439171210252, 0.9883901106190249, 0.7488084329619256, 0.6947698523539438, 0.7046834419966321, 0.7587107966257344, 0.7747212311860909, 0.7319108513059044, 0.7417350723157374, 0.4530541177835177, 0.7366827239645897, 0.8984636771189272, 0.9025198049765024, 0.22562418871395062, 0.9411876970456837, 0.9304985558749813, 0.9037811869699306, 0.9101553785953312, 0.13762368324061003, 0.8966738959862751, 0.7009634051678444, 0.620836201623665, 0.642333616456781, 0.6319081555808095, 0.6672694198035928, 0.5617432411110523, 0.7280106528730367, 0.665984606607143, 0.5857831298828378, 0.6839994539259235, 0.6434404243110035, 0.6843648470420876, 0.6783035047608743, 0.695586725851957, 0.786317918742073, 0.5802724008661748, 0.5994051563807276, 0.723389767451533, 0.7517618488960602, 0.7417326513778095, 0.6389959446554083, 0.7603300012477041, 0.7609531252156967, 0.7374042182959367, 0.7561617059933244, 0.7359620523871399, 0.6813023154111961, 0.8031691085702766, 0.808449593542701, 0.8088972025524547, 0.6313229198824941, 0.8030250005296992, 0.7729304493647652, 0.8380994495456363, 0.7770655247735827, 0.7710579327804172, 0.17557187049123135, 0.17263815349889589, 0.6245243487301857, 0.613219580088638, 0.48008204186097536, 0.6194220031236737, 0.24632419386027227, 0.289310029273961, 0.33804022475011775, 0.6139888668063955, 0.6355504790280755, 0.6495214793421779, 0.6227000534228568, 0.6477207358741829, 0.6654887509938558, 0.6461800226125594, 0.6511700000459127, 0.6406567065185204, 0.8331977610558252, 0.8790853387147571, 0.8712698774266809, 0.8799892561872699, 0.8632959830765224, 0.8605900251561108, 0.8721598951853459, 0.8604683072716579, 0.8474953350434702, 0.1488024522146516, 0.1336520926940271, 0.11768335958070963, 0.12317624841096908, 0.4811695611247766, 0.5232630574405943, 0.1301502868763451, 0.1424971125366692, 0.13458279979419097, 0.16830610543788116, 0.17956493962831377, 0.20444194116571357, 0.3563456479418251, 0.23244857462298096, 0.5035358412248914, 0.2015164721675322, 0.24832525863172583, 0.64792337068315, 0.6501693924748606, 0.6801545027520957, 0.6476648378145624, 0.7225864222053853, 0.6283811512476869, 0.641021678577026, 0.6987361987811815, 0.7125889825382462, 0.676167554423182, 0.5820798341703151, 0.5123392359305952, 0.6344602964172832, 0.5649696746340965, 0.36146805440264673, 0.32532851707740407, 0.632002979369553, 0.5928922638406269, 0.4816308423610427, 0.19468625542675966, 0.197522076109114, 0.2012867456559937, 0.2002821496959596, 0.19533483009187325, 0.21689777267620214, 0.1964996223081803, 0.2582977002306729, 0.21580913934694068, 0.23700308320556407, 0.1946308045731393, 0.23952369859041478, 0.7019657759246385, 0.2161326229795023, 0.238266892647921, 0.7943458404554979, 0.21720302749008702, 0.23876772580434613, 0.17172993899390554, 0.21051823314647133, 0.18710491131865925, 0.16200906515520797, 0.1625540192261442, 0.165982574148976, 0.9280031266320606, 0.8758499792166936, 0.8959332071611354, 0.9084830843722524, 0.1688561821335014, 0.8829244346071353, 0.16854619617649313, 0.21122480169721647, 0.20583805802454003, 0.15636864323905864, 0.1674898424285719, 0.21132743276405996, 0.18594334425130565, 0.1839144880833492, 0.19072460599175833, 0.1837732278014942, 0.17794067412918613, 0.1880279028408567, 0.19622154500842415, 0.1811406976037373, 0.17245138053289066, 0.08290526460064851, 0.08227124392266216, 0.10255075296382388, 0.0937502863327494, 0.08730699052344704, 0.08771644847935878, 0.08718698866648011, 0.0940754118583178, 0.08981040212192948]}, "mutation_prompt": null}
{"id": "7b162e92-e85b-4dd9-842d-ddfffe992bce", "solution": "import numpy as np\n\nclass EnhancedSubspaceDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # Slightly more reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def adaptive_subspace_selection(self):\n        subspace_dim = max(1, int(self.dim * (0.3 + 0.7 * np.random.rand())))\n        return np.random.choice(self.dim, subspace_dim, replace=False)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    subspace = self.adaptive_subspace_selection()\n                    mutant = np.copy(a)\n                    mutant[subspace] = np.clip(a[subspace] + F * (b[subspace] - c[subspace]), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedSubspaceDE", "description": "An Enhanced Differential Evolution with Dynamic Subspace Selection that promotes exploration and exploitation through adaptive subspace dimensions.", "configspace": "", "generation": 71, "fitness": 0.36614442739673847, "feedback": "The algorithm EnhancedSubspaceDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.37 with standard deviation 0.30.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.9365403699077383, 0.9073165731970373, 0.9094196109233477, 0.9237221832827581, 0.9055767986248615, 0.9244360462988735, 0.9139119068051884, 0.9374481427548021, 0.9055499397699077, 0.8731338987235276, 0.8819014521505706, 0.8753959210475107, 0.8561131807397825, 0.8644895437207553, 0.8887227683416447, 0.880648749107853, 0.8672125745067614, 0.8561034270894734, 0.14434936598863946, 0.19178951989454596, 0.16232207695023115, 0.14692803949386268, 0.1625793095172079, 0.8386994599844299, 0.12497889559814701, 0.12113998924175662, 0.11175754847762565, 0.14760299587619752, 0.12824820764292855, 0.09567178364389095, 0.13494830748947528, 0.09941903665657759, 0.12631643063377318, 0.14625228419046976, 0.11056001484018874, 0.12120181985552425, 0.9680713139135856, 0.980001128419974, 0.9838258784377844, 0.9685882826708447, 0.9656388038819924, 0.9695897992302456, 0.9750935513557277, 0.9706666430908121, 0.9707602429010216, 0.8225704280722019, 0.3745595565844104, 0.798069895537199, 0.7489109505586218, 0.7954265010298962, 0.6981239470560987, 0.7326627829709451, 0.7081139014120282, 0.8129090671093668, 0.8930162184397968, 0.37795575518419533, 0.2139348688621937, 0.9167250534346378, 0.3794225066152067, 0.3818459039299975, 0.3599592925124492, 0.17766557755093237, 0.34591165587910155, 0.2642951807856624, 0.26888759022801956, 0.25558504201981425, 0.39919402233327805, 0.3349774643504385, 0.21437918872683226, 0.24150433896066392, 0.5836811484907254, 0.29072746667194727, 0.35031345257734725, 0.29598790106566353, 0.3837785200807218, 0.30400825747992255, 0.13388460536117452, 0.2639815794159631, 0.369265707966861, 0.32347309504865396, 0.10295020077219852, 0.2317090076212721, 0.27093397746617454, 0.3817389813515072, 0.02826169915127119, 0.26955609226644484, 0.03154191543973628, 0.20583726657903045, 0.08351215539664358, 0.13405976697216104, 0.22280959706531644, 0.39669931864625363, 0.29081331022836276, 0.0037309045832866206, 9.999999999998899e-05, 0.15446356874205358, 0.443426787114206, 0.13852829568052527, 0.2862061454771384, 0.1267904727733652, 0.14843574539625237, 0.053335953942623915, 0.2364889180905757, 0.10729688215992306, 0.18278645058870613, 0.09605829547920042, 0.11769495987761824, 0.23637388551814398, 0.15681383055012743, 0.13404409878263046, 0.218880921222819, 0.1768929761578062, 0.18023026262628083, 0.19653130290778686, 0.1943571763839279, 0.17294889544649772, 0.13994670083964234, 0.7334540872181038, 0.8053995603902693, 0.8494216308473075, 0.7136079579053425, 0.7545250289700992, 0.7996001948398231, 0.783698134081698, 0.7810808745605979, 0.774646695187757, 0.09301526353336798, 0.1455231366932861, 0.10512519326152991, 0.18800628302261335, 0.1331117805880938, 0.1255228971303075, 0.11187861673118682, 0.14380325777424463, 0.1280127310479533, 0.15375150207200128, 0.27219228310299537, 0.2282122208847972, 0.23872397886615548, 0.1624784677144835, 0.21857431183925025, 0.15990878008512077, 0.23144889147265202, 0.12215655577404683, 0.5740240684624476, 0.43193631332566296, 0.3270030960008601, 0.27406177051852076, 0.28470771635557235, 0.4420300255795243, 0.33126266427651196, 0.5557873100139061, 0.3484874422325299, 0.3283791165469293, 0.2133449904353616, 0.24384061757263986, 0.3738504665882527, 0.17445530847758128, 0.24642421062841935, 0.19246551898930986, 0.34297337086699586, 0.3546302692686564, 0.21614438954855908, 0.19551227459414744, 0.18964368562548317, 0.19012895106888117, 0.1979512437946882, 0.16018173389791013, 0.22304470838843748, 0.16433373172195265, 0.19354376930539652, 0.22824596411698483, 0.1974434770693263, 0.1833847916921546, 0.22555856631334448, 0.21797217540973657, 0.18911828307528533, 0.18530830369984874, 0.1988685607606292, 0.16798096039150057, 0.1875306336657232, 0.17872214091471017, 0.16574671700763177, 0.9437192980524771, 0.9358109995727202, 0.18737308972644806, 0.17734245788067204, 0.11505841453840626, 0.16761233200006886, 0.89866058061773, 0.16975148424700093, 0.8199057005056617, 0.21371715823809023, 0.21250097999533113, 0.16825736054232732, 0.8657078442751249, 0.15601862501007357, 0.2127213618075725, 0.16154166977203455, 0.17156592099004464, 0.1767318696419241, 0.18383022088062084, 0.1764366535156321, 0.19164403733696023, 0.18108479664786414, 0.18807195097409302, 0.1920265984798163, 0.12938585491148658, 0.10071908927520312, 0.08398658651297941, 0.10495136007201888, 0.08092249105710725, 0.08672768554229715, 0.07764498880830928, 0.07583849906667861, 0.08387974293330103]}, "mutation_prompt": null}
{"id": "f0ac05b5-6ff2-4500-85e8-3b2d35895b82", "solution": "import numpy as np\n\nclass EnhancedMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # Increased reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.2))  # Increased elite percentage\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        hypermutation = np.random.rand(self.dim) < 0.1\n                        mutant = np.clip(a + F * (b - c + d - e) * (1 + hypermutation), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedMemoryDE", "description": "An Enhanced Memory Differential Evolution using Adaptive Hypermutation and Targeted Crossover for refined search in complex landscapes.", "configspace": "", "generation": 72, "fitness": 0.5301316804368049, "feedback": "The algorithm EnhancedMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.30.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.8846959634246954, 0.8854825022394817, 0.8924694918745192, 0.8949284445079082, 0.8988084408135536, 0.8865778764859782, 0.8859910856763548, 0.8920318729725437, 0.8849712202057282, 0.7757011572578492, 0.807008333298789, 0.813741458988346, 0.8067384226410594, 0.7940849373775605, 0.7771997907135738, 0.7780347112367559, 0.7989535614597252, 0.8002249338003645, 0.15776425617936363, 0.15989179431250145, 0.15192721906940498, 0.49045979378223614, 0.13449302173751843, 0.12310524147180768, 0.1392234907444334, 0.15180730351740335, 0.1278675487261557, 0.1432028454037485, 0.12427304930293737, 0.11615391271777264, 0.15233575740157268, 0.13989268548858347, 0.1398123019964278, 0.14485377614928097, 0.14354013298234947, 0.11680848014969847, 0.9527791326068169, 0.9550957380448358, 0.9473154818207185, 0.9734590169804592, 0.9270246919033958, 0.9678039303707149, 0.9740697140907241, 0.9302471021109647, 0.9808280389930559, 0.742982055335714, 0.7443893277158025, 0.6854939845592734, 0.7413797516404925, 0.7349553170910657, 0.726052068034359, 0.7372434287773671, 0.73880481728249, 0.744078820122896, 0.8945349450624079, 0.8947870141345515, 0.8901940102707188, 0.8675326942519995, 0.8840804320241131, 0.9109760312186528, 0.8953250867814736, 0.8936015951619842, 0.8966423097893798, 0.6107262138477552, 0.13396893593845183, 0.6195394640600353, 0.5609455273879423, 0.7283926942655995, 0.507093847810121, 0.5585542175022504, 0.7160294398854061, 0.5947031845047073, 0.5097214079284059, 0.13068827595339993, 0.5777362877206139, 0.6764344967285565, 0.5846750424862208, 0.6793198847618007, 0.6855316769431455, 0.6046875772284451, 0.542115453175366, 0.7126465950019591, 0.7549222515445912, 0.7660902355643201, 0.7194752853550348, 0.7471294558056163, 0.7308416267636682, 0.727358211538493, 0.7307041904199116, 0.755995584904507, 0.8107029337563004, 0.8246059795487827, 0.8245047605135918, 0.7982641169853133, 0.761996374173493, 0.7934290875050594, 0.7911565807735377, 0.790383232397042, 0.7989837410974295, 0.27643075331729383, 0.234957595684124, 0.416151480072666, 0.488511464073333, 0.38191681644247455, 0.33816206442313324, 0.3429347629975614, 0.2669521349600047, 0.45280634781951323, 0.6839786772700993, 0.6861668145151005, 0.6914140468766111, 0.6930276509487077, 0.6844559182643518, 0.7055835828908599, 0.6814995064167426, 0.6861677773104728, 0.6574198132296283, 0.8672699954285651, 0.8659645379034456, 0.8694151239491573, 0.8622538033626679, 0.8494391169518768, 0.8527180595407434, 0.8562701130929748, 0.8470418891452197, 0.8719634075885975, 0.13705485529567163, 0.14668914087867357, 0.4048219364611034, 0.14680772056219282, 0.17183397069141193, 0.14647533521661116, 0.11995564830104377, 0.16203161457126025, 0.12542143649256254, 0.49239405421392424, 0.18068045828773993, 0.14993299221477485, 0.19568686031653537, 0.2247967592613055, 0.17625064956871284, 0.2185266072468358, 0.22124446997880565, 0.18280258580010944, 0.6890633759845834, 0.613160371197646, 0.67441812431253, 0.6613176359527608, 0.657885473199816, 0.667954753732878, 0.6986555262080458, 0.65481544311382, 0.5386983613375387, 0.6285000608459749, 0.5951797317103474, 0.4928991243488243, 0.6215845719079564, 0.5944847061347462, 0.6316523161893034, 0.5853708883327329, 0.6117007234759013, 0.6267238469798592, 0.21930622709396652, 0.19093657819761056, 0.22568679145263815, 0.22196477537230008, 0.18705865139672728, 0.20189077137564193, 0.1971602450953922, 0.23391875594860823, 0.22085095683893663, 0.6979194911301494, 0.23895635987067987, 0.2185715027999664, 0.4755102219761561, 0.20758724512110382, 0.23916046926934675, 0.6106280420468221, 0.7376024171066009, 0.2120502416509722, 0.9042758648091253, 0.1537193355410844, 0.8715687976945364, 0.85278240000644, 0.17140429701194482, 0.893019693071771, 0.8883747712453466, 0.17519939236284332, 0.17077307375846706, 0.8892786752816486, 0.20593935175227995, 0.8217691627853178, 0.832905191788877, 0.20427654439614973, 0.8465164049743624, 0.12686881568500707, 0.21269937587847643, 0.2135535758558864, 0.21399786676609278, 0.18961194961984917, 0.171058054937401, 0.19015705028551944, 0.1778253468175508, 0.18661506071811595, 0.19838733348071314, 0.1880947294072487, 0.18260598652359283, 0.08448504769672238, 0.08189819790389341, 0.07730129740524683, 0.08558518655271019, 0.08654636136897498, 0.08390194522719518, 0.08483262615170939, 0.09303692079627712, 0.09568493618611751]}, "mutation_prompt": null}
{"id": "b5e1bda9-13ed-4927-96b8-0f9fafd430b5", "solution": "import numpy as np\n\nclass StochasticGradientInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.2))  # Slightly more reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.15))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def stochastic_gradient_update(self, individual, gradient, learning_rate=0.01):\n        return individual - learning_rate * gradient\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n\n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n\n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    best_local = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    gradient = (trial - self.population[i]) / (trial_fitness - self.fitness[i] + 1e-8)\n                    trial_updated = self.stochastic_gradient_update(trial, gradient)\n                    trial_updated = np.clip(trial_updated, self.lower_bound, self.upper_bound)\n                    trial_fitness_updated = func(trial_updated)\n                    eval_count += 1\n\n                    if trial_fitness_updated < trial_fitness:\n                        trial, trial_fitness = trial_updated, trial_fitness_updated\n\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "StochasticGradientInspiredDE", "description": "A Stochastic Gradient-Inspired Differential Evolution that combines differential evolution with stochastic gradient-like updates to enhance convergence speed and solution accuracy.", "configspace": "", "generation": 73, "fitness": 0.4921289288768808, "feedback": "The algorithm StochasticGradientInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.27.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.8336046699968095, 0.8439577343019495, 0.8427222480148585, 0.8186222666341236, 0.8462741637629182, 0.8377262623385566, 0.839028490197417, 0.8317260733233138, 0.8350585887276963, 0.6786221827249062, 0.6607078020658363, 0.7161150604812149, 0.7038000662844941, 0.6812196751296511, 0.6662079437735958, 0.6878362632287981, 0.7088086985935844, 0.6773301892157169, 0.13006264661527367, 0.13975656491065347, 0.44629169277192904, 0.3009254443333491, 0.1321882237096581, 0.1468459296133977, 0.12221312268815132, 0.14327100531296677, 0.12648242629307627, 0.4630910087285143, 0.153284213436075, 0.13459432752959077, 0.12580102207827693, 0.10050004013311442, 0.11263977353946086, 0.13292720473342468, 0.11907682151090249, 0.13834057761497132, 0.9440981316274775, 0.9370977255812415, 0.945772433462774, 0.958570821144707, 0.8969696423349505, 0.9717414396292224, 0.9433795252792514, 0.8883235098165218, 0.9711239036975899, 0.6618241589775056, 0.7166283473593392, 0.6558724689988079, 0.6814832093245142, 0.6847625592553082, 0.6846678313055768, 0.5931186159095766, 0.6860470133581708, 0.6604409409178937, 0.840916039503677, 0.8184618165202933, 0.8365054781913348, 0.8203095143979808, 0.8602431442213809, 0.8429110802186601, 0.8460061320762644, 0.8482437679912767, 0.8330515062015164, 0.5230725946280868, 0.44916912439299916, 0.43392572580253996, 0.5431614125246123, 0.5184847242640329, 0.5284671631265718, 0.6969502918114399, 0.6512201846680592, 0.6539183176310244, 0.568979298597039, 0.5492365778492959, 0.4574744928737813, 0.556662466079378, 0.5335773548542757, 0.5382994540895157, 0.5954756436167535, 0.6089331700589578, 0.5239468021119156, 0.6354341279752791, 0.6755300449899693, 0.6540091747999843, 0.5572023954950576, 0.6397660098372737, 0.6188663223837239, 0.651093777132346, 0.6578020353536942, 0.6417294300518852, 0.7261159621364409, 0.7439662455936265, 0.7174929967968908, 0.7158901556619296, 0.7209718624929516, 0.697859832635126, 0.7409018453624551, 0.7137806228882669, 0.7321509621591225, 0.2460303129352578, 0.38945763809590683, 0.09916420546673288, 0.5750870436377382, 0.6236941968953393, 0.5723602237954446, 0.40363075889662414, 0.33809728477067114, 0.19195661976687317, 0.5159850363422087, 0.5466189508533862, 0.547445439663611, 0.5080772480976667, 0.575784201345171, 0.54025820065812, 0.5282806933760904, 0.5619555714217865, 0.5708994432208285, 0.8186468313501649, 0.7921545557520875, 0.7968580284827688, 0.8013292519254698, 0.7965250921270723, 0.795546861096043, 0.804867834018363, 0.786431695165815, 0.806275456808963, 0.11032619970727542, 0.12240165751824317, 0.13181164424680447, 0.12696492168648643, 0.11427089437617577, 0.12197150415768587, 0.1490343815869103, 0.1348866486820165, 0.12226250761597279, 0.16877233251620238, 0.5819019847659176, 0.3670017666827836, 0.1706782878677614, 0.22154828308680008, 0.25670093484031764, 0.1980726867859407, 0.30444030571006, 0.22373100132005597, 0.5748944362334849, 0.5407892626205147, 0.5634064015110083, 0.4901528741589585, 0.4673082278074684, 0.510297434692335, 0.5276413272790047, 0.573953727524696, 0.5612613777397258, 0.49647581960065235, 0.42887389463447767, 0.5064641040104434, 0.5523995838276364, 0.39726299555114897, 0.511205797598, 0.5143096146716197, 0.47661194819506214, 0.4892745850086577, 0.22957028915302347, 0.2020945979068247, 0.20933560898118997, 0.19249845949654154, 0.18351913786094654, 0.19710067352812466, 0.22149221617308779, 0.21291164395074502, 0.20250235748608036, 0.18878556862741547, 0.21260928676790258, 0.6327936592352394, 0.21473319575994276, 0.65082263880621, 0.5874689045931504, 0.5486446238657505, 0.1979215099861822, 0.215557992931955, 0.1814622138008627, 0.8706297847913964, 0.182212186432109, 0.837492773941727, 0.841155074457353, 0.8441147021410759, 0.17783852320205462, 0.16248592477789048, 0.8431940184241096, 0.20495409852447077, 0.16632332842193154, 0.8200106727714332, 0.20809295127412064, 0.20721015127940468, 0.8129499699090366, 0.840051307038483, 0.8170834010286889, 0.12632642463607113, 0.1786623609447543, 0.1893615792496004, 0.18925775533299527, 0.1932403884029119, 0.16992432478790143, 0.19007357613242826, 0.18320431385791913, 0.18624513120035113, 0.19477498271996407, 0.08113215397314744, 0.07974513422233909, 0.08877102443919249, 0.0858443601367288, 0.07356955181933811, 0.08933608289524908, 0.09188833819511999, 0.08606258209773354, 0.08427530887420676]}, "mutation_prompt": null}
{"id": "68b1eff2-0249-4940-ba05-89144a80fa29", "solution": "import numpy as np\n\nclass HybridAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def time_variant_mutation(self, eval_count):\n        if eval_count < self.budget * 0.5:\n            return 1 + np.random.rand() * 0.5\n        else:\n            return 0.5 + np.random.rand() * 0.2\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = self.time_variant_mutation(eval_count)\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]\n                    F = self.time_variant_mutation(eval_count)\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveMemoryDE", "description": "A Hybrid Adaptive Memory Differential Evolution with Time-Variant Mutation that enhances exploration by dynamically adjusting mutation strategies over time.", "configspace": "", "generation": 74, "fitness": 0.24525142301388664, "feedback": "The algorithm HybridAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.25 with standard deviation 0.22.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.5625574784493341, 0.5424626039186056, 0.5563689561360712, 0.18034127778637543, 0.5856753708601301, 0.6090520830780213, 0.5876951803235475, 0.5847761120784281, 0.5657785878751849, 0.06238817568691124, 0.053175691062839925, 0.43127814124907615, 0.4209681831655968, 0.40731811038303534, 9.999999999998899e-05, 0.42741407866589365, 0.0050179392908099585, 0.4346821161311717, 0.08335951144253817, 0.3666785462265385, 0.09024779567064056, 0.12938260870891172, 0.05548205418618768, 0.1065314610493091, 0.09164701513510809, 0.10873476179500408, 0.0888833514775581, 0.07325088792415368, 0.08479138017129895, 0.085989241333429, 0.07811082175017803, 0.07894745841765394, 0.08131910799621545, 0.09947489671466936, 0.07489714349906695, 0.3298153523525147, 0.9847303824851765, 0.9904753321796911, 0.9785018098086353, 0.9893105668645618, 0.9855336205228205, 0.9918861832036547, 0.9856666155870264, 0.9931490769488021, 0.9918658689830424, 0.370428806342635, 0.4076669890025252, 0.057828352853618314, 0.41923945910433147, 0.1328751944824157, 0.12906262798701207, 0.08408667976077921, 0.04925454039287125, 0.08601844620637844, 0.5176700523275057, 0.5223937855724956, 0.15842213206981615, 0.5228304725263244, 0.5332447154721116, 0.5610517998825566, 0.5398764545307688, 0.5469747061490093, 0.12587606713694188, 0.3231240323123774, 0.16337665958877845, 0.2271791972572662, 0.0908972885712741, 0.08049949622798724, 0.4585449744178185, 0.3707360752767016, 0.30583688691361455, 0.2975925333258702, 0.010007638293873633, 0.009899191533652596, 0.00992996802006707, 0.2159835990647403, 0.15810794699319108, 0.2259154177251601, 0.19201444450934424, 0.13039405536322668, 0.09954454162093085, 0.3853674514870976, 0.2042468926335994, 9.999999999998899e-05, 0.00044977027028036964, 9.999999999998899e-05, 0.0004923409570053439, 0.32476005807981867, 9.999999999998899e-05, 0.36163924426135985, 0.07703424328595976, 0.08039995569729841, 0.04166371007763481, 0.04358955675227649, 0.0606406543168303, 0.09643970216444886, 0.465395564399252, 0.052038145103326494, 0.06205393283082217, 0.05576411850814822, 0.1784950221269197, 9.999999999998899e-05, 0.2824029206130022, 0.2788997209731843, 9.999999999998899e-05, 0.0625081727937371, 0.18800903871648067, 0.08704713252841756, 9.999999999998899e-05, 0.2952049795349734, 9.999999999998899e-05, 0.30932985927989787, 0.3205729917707538, 0.34050884761291467, 0.09696780328159982, 0.3443414096971824, 9.999999999998899e-05, 0.5278851259724218, 0.5353634754364913, 0.5513456313571535, 0.5601409337786278, 0.2025625741426028, 0.54875823406673, 0.5362547754083826, 0.5623781619381838, 0.23174542546809374, 0.08833905084208749, 0.07764028724498329, 0.09714008599189361, 0.1000739653276671, 0.07397443549145244, 0.0922444099060663, 0.16243762197523337, 0.09863924064536456, 0.06479658428203006, 0.17553736183387159, 0.14826406103604406, 0.142656682918888, 0.1434964181598427, 0.12552026904524283, 0.18974430146104893, 0.13552488060862944, 0.1394876984749781, 0.15066023732504485, 0.3565830190229621, 0.3539574685754864, 0.3344579595469519, 0.3361923689618803, 0.3416224439506069, 0.3749920413839857, 0.3338670969149561, 0.3851704783216503, 0.3669058462309903, 0.2757789997863185, 0.1869618467837164, 0.2753738698600815, 0.08112264212808673, 0.24592846688503178, 0.1621375525185913, 0.21446274834840273, 0.28972923532914174, 0.3054302877419174, 0.16951736537713713, 0.170141612399499, 0.1812169044474008, 0.16627552604068374, 0.1691601556502459, 0.17040098562530637, 0.1802444561934775, 0.19827126303069686, 0.16104036237168462, 0.14797157727851407, 0.1761847485897764, 0.18049162398908392, 0.3461806788706614, 0.1720016024403851, 0.17510258582684834, 0.16690479675804015, 0.32348820093452113, 0.176579714764327, 0.690765709747978, 0.11275988152829997, 0.2030255777790444, 0.17445727399996902, 0.16181832286823572, 0.17919141098257585, 0.14702091897223835, 0.1771601354677117, 0.1583839517866349, 0.1483954506763563, 0.15448288002930954, 0.11094585370003007, 0.1572801505057856, 0.1690176279533624, 0.18568195698047307, 0.19465455249386465, 0.19622267352985978, 0.18326750283978976, 0.15755753222485203, 0.21355739391070783, 0.16452638957404941, 0.1762362916252832, 0.17915943445226, 0.17161092721962923, 0.16614813807270434, 0.16134716112652803, 0.16904160571632132, 0.060316274636994405, 0.060865827839676645, 0.05688743888450387, 0.06487461076713374, 0.057862154584050085, 0.0572439113846116, 0.06441265073193647, 0.058287226732546826, 0.06821869951048798]}, "mutation_prompt": null}
{"id": "1c6ad06c-48b2-496b-9d66-5b564918d9d0", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.25))  # Moderate reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def random_population_strategy(self):\n        indices = np.random.choice(self.population_size, 3, replace=False)\n        return self.population[indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n\n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                if np.random.rand() < self.probability:\n                    a, b, c = self.random_population_strategy()\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    indices = np.random.choice(self.population_size, 5, replace=False)\n                    a, b, c, d, e = self.population[indices]\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveMemoryDE", "description": "An Enhanced Hybrid Adaptive Memory Differential Evolution incorporating a Randomized Population Strategy and Controlled Mutation to improve convergence stability and performance.", "configspace": "", "generation": 75, "fitness": 0.450798738218522, "feedback": "The algorithm EnhancedHybridAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.45 with standard deviation 0.28.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.831446623356699, 0.8324063717857426, 0.8222837825315007, 0.8373665478428336, 0.8190870162362933, 0.8488862528672021, 0.8422402135014202, 0.8586440638663617, 0.8350770808540603, 0.7223233362256487, 0.6731262907523266, 0.6984589197739846, 0.7047188114168541, 0.7514984137223816, 0.6814299983127978, 0.7164205081437531, 0.6679534966773492, 0.6986751775083617, 0.12415419645797043, 0.1348787266711996, 0.09797741956791484, 0.10951094326524713, 0.12424903944659726, 0.11554876725650953, 0.09929571858762976, 0.10276317208817887, 0.0945855813274189, 0.11963935846013807, 0.09818575029157328, 0.090830183817736, 0.0937997687092389, 0.09849667959400399, 0.10874645386845916, 0.10032738773447236, 0.10359111301377866, 0.10918707619651646, 0.9837703497465435, 0.9726319505458763, 0.954765247993482, 0.9473185028333024, 0.9763320989262532, 0.9765967994962581, 0.9836405042177805, 0.977470400627058, 0.9902436244646103, 0.5277767059881472, 0.5497416776176435, 0.543234038144963, 0.5818614423322985, 0.5997268070812627, 0.6205514942621766, 0.6075503690359751, 0.5335461635221677, 0.5663891953489291, 0.8031650349816988, 0.8140480570338328, 0.8233446253054503, 0.7850964520072117, 0.8444405460370711, 0.8080266601832138, 0.8462256189215036, 0.8290217626350282, 0.8459543874961548, 0.6180222542772754, 0.5868399463751649, 0.12984688967586167, 0.5874560210491283, 0.6020507059685551, 0.5528543159726425, 0.5150092465351845, 0.6188694096402068, 0.5889019717221173, 0.6187502053762302, 0.5922626619162268, 0.5853275860281901, 0.6732726990424924, 0.644580222533145, 0.48425826846537645, 0.5663785746440138, 0.6488087197775458, 0.6070994439170978, 0.6183790815375885, 0.624416220361846, 0.5845661662800026, 0.6039646250114282, 0.5887902267404782, 0.612471451351023, 0.607308762192841, 0.5747371793003558, 0.5548242253063354, 0.6698144563903308, 0.6898582703070436, 0.7234890260816076, 0.6734606254785906, 0.6766901619805332, 0.6778496763893671, 0.6884483729322226, 0.691229103011563, 0.696319706613618, 0.2825489459110212, 0.2479878497422393, 0.3636974432712101, 0.48395092389202643, 0.371005055312842, 0.4336648787780366, 0.3458895984247723, 0.33410833603801793, 0.30894045175544027, 0.45121503858193734, 0.5343544253989123, 0.475932634679346, 0.48292290609947053, 0.44007358560518917, 0.5023585261379577, 0.431913154809367, 0.45471279897184524, 0.5051082816125996, 0.7560801581026869, 0.7694068724416219, 0.7699097123967992, 0.7651126520111385, 0.8033101387557329, 0.7808423280434673, 0.7698619409136813, 0.7790029313042738, 0.780750196947783, 0.08826865520830673, 0.09420959336236079, 0.0943334182192912, 0.09385389572094538, 0.09133326247100781, 0.09646553192303564, 0.10952915989838985, 0.0908137651349622, 0.10141638550297427, 0.2575264104895004, 0.15271012797887962, 0.1712028922479374, 0.16558852171134297, 0.15731566538048336, 0.1425678598569493, 0.2526596753670446, 0.35028868689570436, 0.13019546853074881, 0.40681209838549004, 0.41565708220918873, 0.4262045551803181, 0.3916533413857475, 0.4409924917889848, 0.44553713787843585, 0.41557961365040497, 0.46545803146749554, 0.44543917478445716, 0.3526108175103737, 0.3613190985657375, 0.3454012778159361, 0.3957389461295625, 0.3627531217456761, 0.31260102819889457, 0.35662999701286613, 0.384123652479349, 0.41019374495887684, 0.1970946088935246, 0.20029022190211399, 0.1897927362432883, 0.18626990840525337, 0.19434607841466334, 0.19548262320446919, 0.21182894989153256, 0.20114861269588935, 0.2073297645347969, 0.18097226860169047, 0.323458807324684, 0.20464778054928945, 0.1904013714183912, 0.18313838806020766, 0.3616411022263365, 0.19305654311993492, 0.1759531987823837, 0.2355139301545962, 0.17177655036153283, 0.8041157758315549, 0.8651556931664991, 0.7248323056970852, 0.1988908497334302, 0.12188850129513107, 0.8021730998579271, 0.647518229104724, 0.7056494516789809, 0.20665285340630513, 0.16798176970575018, 0.8419545075944707, 0.7523124573061499, 0.20525326631107454, 0.20433430777441097, 0.2113741159955861, 0.212149388600388, 0.21215927436253956, 0.18487985521265782, 0.18075785581406767, 0.17649920429024346, 0.2078748985399267, 0.1940257381405105, 0.19018554983504155, 0.20163069528850652, 0.1895883721042092, 0.18063695311676276, 0.08146400276908139, 0.08071090177305906, 0.08746532505100002, 0.08066614233001967, 0.07435362536544654, 0.08699837179893877, 0.09417927013700156, 0.07426643206362282, 0.08067177767773426]}, "mutation_prompt": null}
{"id": "c1d29eca-0cc5-4c90-9827-560ebde4a675", "solution": "import numpy as np\n\nclass EnhancedHybridAMDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        self.adaptive_factor = 0.2\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # More dynamic adjustment\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.2))  # Increased elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e) + self.adaptive_factor * (elites[np.random.randint(len(elites))] - a), \n                                         self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAMDE", "description": "An Enhanced Hybrid Adaptive Memory Differential Evolution utilizing dynamic memory learning and adaptive crossover strategies to balance exploration and exploitation.", "configspace": "", "generation": 76, "fitness": 0.529204935642917, "feedback": "The algorithm EnhancedHybridAMDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.30.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.8969639755144546, 0.8957766054112325, 0.8893312333044369, 0.8998722427659969, 0.8936974018371608, 0.8933521574431147, 0.8998760977780276, 0.8913322287174981, 0.9029588741812195, 0.8034336013573601, 0.7988097816590685, 0.8064762458011614, 0.7896972447908583, 0.8030954331119025, 0.8041922190481117, 0.8014917366579013, 0.8135658959170028, 0.7994568529326449, 0.15886317511264914, 0.4542146155541059, 0.16127316891270582, 0.40998323107521095, 0.40665284550757363, 0.5062976074840972, 0.15643509579747517, 0.14238262136001834, 0.1472297400955278, 0.12082536549225731, 0.11014598177422408, 0.11445178376804632, 0.1358802693456097, 0.12431556698402313, 0.14622566784961077, 0.11557090394704306, 0.14019164566243125, 0.14109770992098425, 0.9849466620958456, 0.9309051814904391, 0.9603978121264539, 0.9675881379094422, 0.9494385653429487, 0.943502221368481, 0.9850494545297036, 0.9704750272690882, 0.9937033172735764, 0.7393522816735665, 0.725746620506387, 0.7346293500792003, 0.7458891593576766, 0.7594157287134498, 0.7310025910917948, 0.7523790810377672, 0.7607557160650471, 0.7626447762187798, 0.8365837480800276, 0.8916140215967859, 0.8935496365342037, 0.8893045301768068, 0.8798812060221461, 0.8915886693684434, 0.8895826121449523, 0.8972976756814207, 0.8817492705625652, 0.733024912004705, 0.6212286768181027, 0.7781859218023041, 0.6540683313836347, 0.13365249364393017, 0.5486070485670225, 0.46326329994061044, 0.6410677113558444, 0.6567833756104482, 0.6295357677060148, 0.6689329798246062, 0.6538844323623952, 0.6177310147757114, 0.6744306645386152, 0.6878718006761405, 0.6975598841593598, 0.56687788287868, 0.5252016170141618, 0.7806572964531715, 0.7391216943109423, 0.7620601869743528, 0.7871545767599458, 0.7579507653320453, 0.7772055339190467, 0.7879616790713894, 0.7665495094934419, 0.7821663961534723, 0.7949027920229671, 0.7982763900201102, 0.8163803959807685, 0.7693517530362153, 0.7924522562016397, 0.7625809597845109, 0.7878549035746002, 0.8060952179261375, 0.7980800523949161, 0.5512494092138862, 0.42263173698977685, 0.4537646717192554, 0.2586628432099688, 0.6630145192042158, 0.6995228140280206, 0.31131012412640935, 0.2753291726853466, 0.2703348719716727, 0.7040777524096955, 0.6972216385917243, 0.6944975956812292, 0.6957109000537789, 0.7130606923055034, 0.6930651156313516, 0.723102387234076, 0.7172235257897965, 0.7134335181755802, 0.861327011884338, 0.8518923152443721, 0.8627681007211201, 0.863354548686408, 0.8673748698501592, 0.8543760832997631, 0.8676087075822162, 0.861333556127679, 0.8536910037972973, 0.12799321986008594, 0.13586221088423867, 0.14144263536644464, 0.12502343488152112, 0.16586046776261354, 0.11089414464163505, 0.12467726233243026, 0.1274032720434196, 0.13163280155812407, 0.24264130707105236, 0.16852116706403397, 0.21944715207195742, 0.18434977481562898, 0.15124111011980335, 0.23068370760451218, 0.22787809197667497, 0.17847747199245545, 0.16721568011049426, 0.5617398476611526, 0.6869839479888746, 0.6919276420520424, 0.6594166836009758, 0.6580130069718404, 0.6655952214190632, 0.6910419380991643, 0.7222389649045822, 0.7043921185423601, 0.4633964262852691, 0.6071377795259981, 0.5157604176954937, 0.619463356806126, 0.5552673917513995, 0.5976028240119414, 0.5983440276757472, 0.622611061666428, 0.6549116347473032, 0.21563186388428868, 0.18600932441229723, 0.2012047672947782, 0.20530584510344574, 0.21509392936947402, 0.2156241029367698, 0.19998624738244186, 0.2048704128341341, 0.22436207251560458, 0.23265049191398235, 0.511284406783822, 0.2192570679389555, 0.21744364298816699, 0.23960439464447925, 0.23612591443821918, 0.6553300492527095, 0.5568048629126825, 0.2240282305700363, 0.17095691176327732, 0.18671265125709036, 0.18373938532286804, 0.17705896703012802, 0.20491855922169055, 0.8976479857179753, 0.18370633803038872, 0.16633763128890566, 0.8130873392513442, 0.8424447329705895, 0.21202292933919253, 0.12718794423181157, 0.838654996352899, 0.20456460793878872, 0.8166994282965625, 0.21153413961127188, 0.828636894781604, 0.21255741787253124, 0.17817734829660425, 0.18934858495199636, 0.20924466414802223, 0.1799975282212044, 0.17974861786758645, 0.18660938077476408, 0.17950590051724635, 0.1793319923305411, 0.20087956665321582, 0.08533500514546355, 0.10138199070352383, 0.08682124592177165, 0.09004309591120085, 0.09177895871095976, 0.08679939443005591, 0.08114085692506978, 0.08502654497713469, 0.09688019248928126]}, "mutation_prompt": null}
{"id": "35722234-0a66-4ea6-9b76-d57b12ccf59b", "solution": "import numpy as np\n\nclass SelfAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # More dynamic reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.15))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.rand() * self.epsilon)\n                    if np.random.rand() < 0.7:\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                    else:\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) * (1 + np.random.rand() * self.epsilon)\n                    mutant = np.clip(local_best + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) * (1 + np.random.rand() * self.epsilon)\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "SelfAdaptiveMemoryDE", "description": "A Self-Adaptive Memory DE algorithm incorporating stochastic strategies for enhanced exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.5393059069150298, "feedback": "The algorithm SelfAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.31.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.901718083828065, 0.8792147204724038, 0.8982983989261306, 0.9039500185133745, 0.9062549372806079, 0.9047015375296172, 0.9061816637351465, 0.896966271011435, 0.9001254008990061, 0.816835952191865, 0.8120495338594482, 0.8305187652951925, 0.8065377765625256, 0.8199724251681353, 0.8126448408903199, 0.7818068960627729, 0.7920368458829354, 0.8292870389256137, 0.13268568940672776, 0.4179880498559272, 0.31348460326866145, 0.15935099775237072, 0.13489212283156193, 0.1665446509931795, 0.15225545414428543, 0.4885261599892229, 0.16465718743642832, 0.14702274176521168, 0.12181963372668492, 0.1711430838882807, 0.12692043363804173, 0.12937417479835367, 0.12448470289728031, 0.1446743799868382, 0.1467324249970101, 0.5864833135079559, 0.978480633389697, 0.9481829867152097, 0.9338321798202104, 0.9738945490244197, 0.9596133931372783, 0.9620501672306349, 0.9119940096633368, 0.9673586009659241, 0.9846765319900306, 0.7704081605747388, 0.7548869765021693, 0.6917327866953159, 0.7640930948080582, 0.7808835895918245, 0.7656072479765199, 0.7831141429236445, 0.7842600673850597, 0.774966075769591, 0.9001753556711958, 0.8992050124133899, 0.8793312854276527, 0.9008976792583457, 0.8909425718812157, 0.9012396643611137, 0.8941358517839759, 0.13759537831599578, 0.8921535381129067, 0.45219052943999827, 0.792128851173717, 0.7910141615254765, 0.5997076596754987, 0.8017612152603963, 0.602111780161811, 0.6672399851419952, 0.5849581949976796, 0.5387250451558461, 0.5647154967436829, 0.6811011458777962, 0.5195199610594905, 0.7311655004253113, 0.6578171027052226, 0.6158579707345118, 0.5437572045822586, 0.43819391920544637, 0.37320980127701175, 0.7657299494985841, 0.7642876746661733, 0.7778787129704506, 0.7837203585251237, 0.7838849725578502, 0.7597763136272491, 0.7668957376702443, 0.771967494498544, 0.7719368964330312, 0.8021598989156378, 0.8169584870959374, 0.812397750190272, 0.8107192216542782, 0.8015630814321665, 0.8148381102537297, 0.8290844616990494, 0.817088004687607, 0.8192076738370357, 0.5426108679490729, 0.4010388503416682, 0.46883159556070597, 0.6201480589394122, 0.6762857268122284, 0.7607671683031862, 0.23761199054551985, 0.4006423828852286, 0.22316410250856944, 0.7215535640581712, 0.7342421924965798, 0.71980963081173, 0.7089835249689438, 0.7235422584578233, 0.7302002193631021, 0.7539976780559142, 0.6473454364088018, 0.726107032699637, 0.882292024332263, 0.8825330582068958, 0.8774733933238977, 0.8804070894590105, 0.8748835303071356, 0.8861854363347843, 0.8710351098746151, 0.8716337516823284, 0.8770378519215407, 0.1400979833170004, 0.48808968128126384, 0.12655785263697217, 0.125264487444256, 0.1347596511249507, 0.1518048762954568, 0.112966632015008, 0.11219273558621334, 0.1260668123186096, 0.2372771799425274, 0.6462028784836497, 0.16206373634339322, 0.15110702662322817, 0.22326713656028352, 0.239789462348466, 0.24356662996026046, 0.22034420448690561, 0.23821313030970215, 0.7170518600543576, 0.6885254877208065, 0.7082426018803565, 0.6234071047945924, 0.7261373829944094, 0.7183616476388912, 0.7251275706077059, 0.7237682431700456, 0.725064793327773, 0.6718321373961929, 0.6573506528988163, 0.6773465596228111, 0.6789119471150915, 0.4747972041181615, 0.46258218990337796, 0.5531353530427041, 0.413624476257479, 0.5848342679008216, 0.2189174198506385, 0.21731829737359665, 0.209438254767086, 0.2080273550909285, 0.19294800753683572, 0.21278636431726505, 0.24785202246287463, 0.22533895875465937, 0.21061455129415674, 0.23734374590747753, 0.2169726418221556, 0.2448681209937943, 0.21811787157714724, 0.6863502123818426, 0.20500382600113864, 0.23929592623795914, 0.20114782120460306, 0.22650111504676862, 0.9064764223280055, 0.9140128696914442, 0.18520043386430107, 0.8925171645193241, 0.873766082072139, 0.1691302020425155, 0.16772705966885382, 0.8985695246547898, 0.17188716882234056, 0.9088042803937099, 0.16917914650086696, 0.1272674873251246, 0.20997496423727657, 0.20865123398212615, 0.16552053303537817, 0.11196722122956493, 0.9061441939699588, 0.21375154237780636, 0.19894226549813498, 0.18213792483388858, 0.19377489582814922, 0.19240782462050388, 0.18829824473614432, 0.20035950068849062, 0.1770282097568866, 0.1786999582065204, 0.19226363749571207, 0.08585663844933611, 0.09893085328377671, 0.0849224225817754, 0.09157278927318935, 0.0898314068372833, 0.09106160670264185, 0.09886640267311375, 0.0898605615158482, 0.0866508345330933]}, "mutation_prompt": null}
{"id": "09ae67fc-dbb6-4dc9-932c-8d1d63e0bd63", "solution": "import numpy as np\n\nclass EnhancedAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # Increased reduction factor\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.15))  # Increased elite percentage\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def local_search(self, elite_solution):\n        perturbation = np.random.uniform(-0.1, 0.1, self.dim)\n        return np.clip(elite_solution + perturbation, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = self.local_search(elites[np.random.randint(len(elites))])\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(local_best + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedAdaptiveMemoryDE", "description": "An Enhanced Adaptive Memory Differential Evolution with Dynamic Parameter Tuning and Local Search Integration that leverages localized search around elite solutions to improve convergence.", "configspace": "", "generation": 78, "fitness": 0.3321430480678311, "feedback": "The algorithm EnhancedAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.6398211404550489, 0.6671406221849907, 0.6565889283285204, 0.6464893982707378, 0.6674313694145023, 0.664713585915057, 0.6528198462930572, 0.6775252701999493, 0.6736959367037978, 0.291874987785672, 0.27969670634492017, 0.27031783482321103, 0.273928970817393, 0.2748431455169227, 0.2715807741437547, 0.2397353178694317, 0.2717363269216294, 0.21944007626456852, 0.13474183991027278, 0.164334246691901, 0.1326716789351281, 0.1196272499661587, 0.21378193732852602, 0.16426908056288925, 0.13946528074007425, 0.11378941150678945, 0.12462772369710096, 0.11739356543591639, 0.15001833263718767, 0.10250224382745987, 0.11871316363260853, 0.10347213965416091, 0.13331920566938993, 0.11153744144162847, 0.10495139887795923, 0.09801655152234201, 0.919892647249605, 0.9552951123723235, 0.8912816810859017, 0.9674235885807363, 0.9666315860687975, 0.9647527222101141, 0.9485937923796607, 0.9754224725195507, 0.9261727449558503, 0.40335659145755665, 0.4075105884256316, 0.3751454294367401, 0.4016615857210233, 0.3907062026198931, 0.3663584158393418, 0.40606031600511405, 0.4012881465731103, 0.37021463826961176, 0.8205673726791732, 0.8120651776056599, 0.7746883960960349, 0.8213600631687554, 0.8101871318765783, 0.7936409331207661, 0.8241185787005274, 0.8024132510387282, 0.8659335376495902, 0.2820309259045717, 0.2929422118956231, 0.29013197445643424, 0.2758787475464902, 0.32162810473443126, 0.310126630389712, 0.3385648404466578, 0.2966453473713623, 0.2858554199101292, 0.31400162452361025, 0.13774299185044148, 0.3196581001419938, 0.2969780086050475, 0.30762969223272296, 0.2933292374419312, 0.3059726414738826, 0.33551607412714934, 0.2925733301783896, 0.21246770657773884, 0.20016923514999452, 0.21674705209060907, 0.19761408187104956, 0.16459668995167287, 0.20318608992521758, 0.23597801517382333, 0.21506248293198615, 0.2195727058936463, 0.24933201547814754, 0.29888379368088314, 0.25636100667901485, 0.307146529194119, 0.2612512893273967, 0.245908238155923, 0.32414867372731326, 0.3050207345047946, 0.27384098307396065, 0.09816915778790081, 0.08111998718769042, 0.054969140968991415, 0.07817136608323105, 0.06956999605392156, 0.06431529959226023, 0.08359374457237978, 0.01999356088246984, 0.06162300803133125, 0.19107078129410515, 0.206141293490269, 0.2026546205619587, 0.18928975431052708, 0.20023397311875857, 0.2235833935232706, 0.21019429028584502, 0.19250179345751317, 0.1912466580270218, 0.5611559048347652, 0.5634170937346785, 0.5660253188321221, 0.5559748101648684, 0.5720745923078792, 0.5618522059302706, 0.5564527796921103, 0.5405107733001613, 0.5530364259748499, 0.12251619814606052, 0.1124443820429668, 0.1450904106912898, 0.09905771789247841, 0.13081406049339273, 0.11134232489888951, 0.1323517106936899, 0.10577893751725098, 0.11229212914161635, 0.2531036940900194, 0.261059647385538, 0.22438745890320622, 0.29813978904611615, 0.15787732065633486, 0.3483337850609194, 0.2282706768310373, 0.27450884822529653, 0.2501366432702694, 0.3484023522631754, 0.3390310584698776, 0.35379991369783725, 0.3529871929468249, 0.34706359714320756, 0.3557984149812452, 0.3675082549886787, 0.34708365654835294, 0.3501731043931088, 0.2929975478149185, 0.28234812557611966, 0.3005014290606878, 0.2852393690181294, 0.2962640156643124, 0.2897849666413189, 0.2919780135367057, 0.2836104921639995, 0.2762049598574694, 0.20250795552854506, 0.24049409167218894, 0.2108802110779704, 0.2054631261001798, 0.20459701134496067, 0.20627121254588787, 0.20235653859708824, 0.20449145609652009, 0.21279818119492355, 0.3651078618312338, 0.21901313567255676, 0.22104684230688865, 0.44379002717199934, 0.20372266415460416, 0.23159538618210296, 0.23379069570683575, 0.3160620514321276, 0.20428066627840935, 0.15775832357222463, 0.18683164079238845, 0.18430541012505308, 0.8535779442772832, 0.8423699940490305, 0.8250553834219511, 0.8750609952771737, 0.8526206818938518, 0.8495638141468235, 0.16601428027423626, 0.20686185695166792, 0.7745854718853181, 0.2109978340397517, 0.20581208991930877, 0.20945955674356154, 0.12715002336058567, 0.8296157391408598, 0.2119560750216397, 0.18494105614434353, 0.1805385190209181, 0.18058496117640566, 0.19713318558610682, 0.2098199173663139, 0.18886836482816882, 0.1875108421951901, 0.18014154928590664, 0.19377181732894022, 0.08437085397911792, 0.08536662256593641, 0.09193504792744422, 0.08185968005187738, 0.09209631266048979, 0.09441549054320586, 0.11196433982959775, 0.09174648810766683, 0.09689451989775877]}, "mutation_prompt": null}
{"id": "fbcc620a-3c4e-4ba1-86f7-076b9eb0516d", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def dynamic_crossover_rate(self, eval_count):\n        return 0.9 - (0.5 * (eval_count / self.budget))  # Dynamic adjustment of CR based on evaluations\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            current_cr = self.dynamic_crossover_rate(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) * current_cr + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveMemoryDE", "description": "An Enhanced Hybrid Adaptive Memory DE utilizing Dynamic Crossover Rates for refined search precision and improved convergence.", "configspace": "", "generation": 79, "fitness": 0.32198714950105606, "feedback": "The algorithm EnhancedHybridAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.26.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.8535435552295476, 0.831857553674445, 0.8507928903339379, 0.8543016343080462, 0.8616302999945572, 0.8297347618406462, 0.8495847233003664, 0.8321657988164869, 0.8504017077441368, 0.7199620748918876, 0.6997050224063732, 0.7034085205461404, 0.7078578831903266, 0.7154960432521926, 0.7093715934162215, 0.6868891764459131, 0.7053505691636752, 0.7290195516372107, 0.6285372142769836, 0.6142837212863662, 0.6413337239624042, 0.6065741119666319, 0.6136466762939959, 0.5947403165985867, 0.5704765405416746, 0.6242844657268881, 0.5461384971594434, 0.6022593233457192, 0.5333928169458462, 0.5313295323509737, 0.5705767458599993, 0.620189037447942, 0.5557473707049306, 0.5480264616497479, 0.5851999791356941, 0.5624126067703603, 0.9742585959832105, 0.9607228053984769, 0.9668825773191031, 0.9733326846943368, 0.9837366006806944, 0.974480909728586, 0.972051985730041, 0.9661313291253826, 0.9850015594332995, 0.2869250901454904, 0.28738610991097535, 0.25092205720695926, 0.32325945858047855, 0.331727925108775, 0.29075218397225244, 0.2319813687897636, 0.21447386372468524, 0.23777730157036225, 0.31817503216706333, 0.3071894997287371, 0.3169232451059587, 0.31481597782182114, 0.6702632668786767, 0.31558243696090205, 0.3490342378479798, 0.5675356187338123, 0.3642626915952557, 0.2053068206289108, 0.18430523287585276, 0.18018501414177057, 0.2246761016665798, 0.1936385540069112, 0.23457755692625393, 0.1926738688370444, 0.16352266709984942, 0.17730985685702094, 0.157871637171488, 0.15989869402733548, 0.17096985846144253, 0.17557548256220867, 0.18238587815100515, 0.14944341352370172, 0.14027012807261474, 0.14736624859696845, 0.1812380259569809, 0.017265942397480805, 0.013465033151759287, 0.004697582850579418, 0.0023694319936159447, 0.03960580470783048, 0.01692069064935331, 0.014528573337180939, 0.02252750428914807, 9.999999999998899e-05, 0.13787227053177709, 0.18475342822588636, 0.14683953362249358, 0.07666574295420303, 0.0548275138234241, 0.06358433213199222, 0.13548895680895257, 0.07531799077122159, 0.10676151524414379, 0.024796530035813724, 0.013742950546549726, 0.005344797003993373, 0.0062213253182215045, 0.028565297888127894, 0.0002521441607604702, 0.043035516020692555, 0.060890261195909234, 0.007575909698755434, 0.11637118168402083, 0.14173026944968115, 0.13714024781221557, 0.11002057613589644, 0.10439126047532443, 0.14117123398072795, 0.14415759451273735, 0.0944152339496448, 0.12867911653663067, 0.478221448578932, 0.47343662776244166, 0.4713432294519818, 0.4701901047033096, 0.5003775191935866, 0.5004297288240906, 0.46527216849739284, 0.5009069679172192, 0.48138067357473047, 0.10178657938927882, 0.10843770763514549, 0.12361971042469011, 0.1061718774368321, 0.1100546356573674, 0.1309447357393856, 0.11034758853031768, 0.10531296367452092, 0.1008330188743457, 0.17126000578701073, 0.15656208549311013, 0.13830514047173126, 0.15389931705007998, 0.15417878620551195, 0.1631187633234471, 0.15291355235318882, 0.1710475490708825, 0.13948160431040102, 0.33991914363813946, 0.2943919317035584, 0.29663853900530956, 0.322819942783401, 0.3263457467991653, 0.3356598246913932, 0.3474114511084213, 0.34367629224189566, 0.3518607342716782, 0.236281007366832, 0.20610276723575494, 0.21922742911253246, 0.21157576729444894, 0.19272205134537645, 0.19277487121906622, 0.25753156097889907, 0.26135337940316117, 0.2566165786929726, 0.19920673842473613, 0.19417769847270117, 0.226825634594074, 0.20925466521701586, 0.18650248535932745, 0.18884788542702835, 0.2477551049389174, 0.20539966645196872, 0.2146495850537764, 0.2732048467169219, 0.23734841784380944, 0.23944594617601422, 0.30863164434893464, 0.25358630425762063, 0.2469283833409982, 0.2916890601988722, 0.3770077778183287, 0.2731050729567188, 0.18039831692387376, 0.702964038199456, 0.3886433312591333, 0.17571870200424977, 0.5358087091453623, 0.5360870844701864, 0.17927877100056955, 0.5153863136169471, 0.8000113406086324, 0.2042114005196647, 0.2005598868302514, 0.2036038377335393, 0.1984743456911432, 0.2072097374019145, 0.42933971360249457, 0.21159465552919854, 0.15191457847357093, 0.21296358991447528, 0.18892920910961009, 0.19073105582305494, 0.189821034049939, 0.19571654975717223, 0.18141662272978487, 0.18157834368799708, 0.20767897005427327, 0.198031456659434, 0.19667119447376757, 0.09609945970523459, 0.08774681500659731, 0.08305239237210771, 0.07830207111735932, 0.09099677059521605, 0.08517715298741191, 0.0721457238532095, 0.07819005934473788, 0.08734378193576287]}, "mutation_prompt": null}
{"id": "505472c3-9650-4361-a21d-ea2dbf0e6b2c", "solution": "import numpy as np\n\nclass EnhancedMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.weights = np.linspace(1.5, 0.5, self.memory_size)\n        self.memory_index = 0\n\n    def update_memory(self, F, CR, improvement):\n        weighted_update = improvement * self.weights[self.memory_index]\n        self.memory[\"F\"][self.memory_index] = (1 - weighted_update) * self.memory[\"F\"][self.memory_index] + weighted_update * F\n        self.memory[\"CR\"][self.memory_index] = (1 - weighted_update) * self.memory[\"CR\"][self.memory_index] + weighted_update * CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    improvement = self.fitness[i] - trial_fitness\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR, improvement)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedMemoryDE", "description": "A Hybrid Adaptive Memory Differential Evolution with Enhanced Memory Update Strategy that utilizes adaptive weights and dynamic crossover rates for improved convergence.", "configspace": "", "generation": 80, "fitness": 0.1210707136417778, "feedback": "The algorithm EnhancedMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.12 with standard deviation 0.19.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.8376088104958572, 0.06280433907172722, 0.5661528661844989, 0.8439068250328587, 0.8333152393783788, 0.059958962137902416, 0.3978772350742651, 0.04952338199085027, 0.4880180813065731, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.12095668880828447, 0.0, 0.1576618336368849, 0.15412371714915207, 0.11369395240324343, 0.04921320698774967, 0.13774271398853166, 0.0, 0.0, 0.09094794326163735, 0.0, 0.0, 0.15085364419713465, 0.004867757595321542, 0.12492537137662019, 0.026701300917267745, 0.19198093752721146, 0.0, 0.047946837768081396, 0.02581747977258042, 0.03858824421754303, 0.044389757948775865, 0.9563257069071994, 0.972090054348394, 0.9611332070936415, 0.9493191701750807, 0.9727083631108973, 0.16573898936336406, 0.0, 0.0, 0.02228404223120628, 0.09566275923472822, 0.0407322301464772, 0.0, 0.0, 0.14786865953339545, 0.20620725751277658, 0.11465609604116145, 0.1457714421650781, 0.018697516838357076, 0.09799572834948089, 0.16062268876127128, 0.18125362162536407, 0.0, 0.055340549332423716, 0.0, 0.0, 0.0, 0.0048228057448020945, 0.0, 0.0, 0.0, 0.0, 0.0, 0.03309842548316322, 0.0, 0.0, 0.10410564723129578, 0.0, 0.0, 0.1417612215638948, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.06590154418701555, 0.009662662242227782, 0.0, 0.0, 0.017434450538450053, 0.0, 0.030570859060104705, 0.08674455120473978, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.015073244313163148, 0.0, 0.00015496422582106373, 0.0, 0.11610511550393221, 0.26670434209720173, 0.381509495270701, 0.42084824712668767, 0.12212044828655544, 0.11200269253890638, 0.45256087320752136, 0.4063591483070895, 0.3423525776618933, 0.0732844582739901, 0.0, 0.06953852761417079, 0.0, 0.06747287110829714, 0.00028475489205970206, 0.015013260043587606, 0.06691665094759813, 0.0, 0.13102309645543064, 0.115772764294656, 0.126320673617634, 0.07154860442280819, 0.12027353272847852, 0.07422145638986988, 0.05148662509650581, 0.16829647793946134, 0.12493711630531923, 0.24050686501504515, 0.1675084864460692, 0.09048354262296199, 0.25651959669616764, 0.10770567472114323, 0.20301546834159356, 0.3833664336447169, 0.12429889991608922, 0.0953996214927767, 0.13437288155788196, 0.22166863526628455, 0.15215807786322022, 0.13224911605286138, 0.13018899156906683, 0.1488626792060741, 0.13825589059711096, 0.16890785676175424, 0.20617901597709531, 0.09627279540821532, 0.07366494248271138, 0.09428365412074946, 0.19626111306443872, 0.03857616793228458, 0.1954738202112274, 0.19129580003286506, 0.0654565909023368, 0.18286276209131447, 0.12761783902211865, 0.0, 0.12903887442135897, 0.1971780546046934, 0.0, 0.20360333263253505, 0.16244031194982167, 0.0, 0.1485086658163054, 0.18083422594666554, 0.1324934008424492, 0.18935560916267846, 0.2646160252684515, 0.17206457453645985, 0.2228954437159396, 0.3060347072958841, 0.14675605966813332, 0.16591269990210677, 0.25521494323726857, 0.03478598926186438, 0.01944557300850558, 0.2120373688753684, 0.13856125739327363, 0.027446521443801997, 0.022426402117193156, 0.020134853306327916, 0.20613384591371686, 0.19210532718901308, 0.18150355199546464, 0.13197993675171982, 0.18432773713270545, 0.15904327822095587, 0.11334747670918532, 0.12465242532932841, 0.18978918774972298, 0.1154675509238774, 0.08211237706997565, 0.0, 0.07819244094627897, 0.08536627789394446, 0.016954249036968072, 0.06310369800102578, 0.07554944128520369, 0.06719066104800409, 0.07898717307938752]}, "mutation_prompt": null}
{"id": "cfcf5def-ab1d-4f2f-a00a-65c230d2eb89", "solution": "import numpy as np\n\nclass StochasticCrossoverDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    a = elites[np.random.randint(len(elites))]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "StochasticCrossoverDE", "description": "An Adaptive Memory Differential Evolution with Stochastic Crossover using Elite-guided Mutation to enhance exploration and convergence.", "configspace": "", "generation": 81, "fitness": 0.541942984988126, "feedback": "The algorithm StochasticCrossoverDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.31.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.9048889702490689, 0.90689819522272, 0.8942369871677663, 0.8994736078750354, 0.9059649385702513, 0.9093326411648489, 0.9138874008992788, 0.8975691547366531, 0.8947949503663293, 0.8021625492826423, 0.8063549464592612, 0.8157375182659998, 0.8158931744340785, 0.8338083853972865, 0.808911841425933, 0.8361234193198035, 0.8115551887879698, 0.8143289457336029, 0.508751267023435, 0.5742687983011145, 0.14979830699461127, 0.16980096854322946, 0.16687937633588446, 0.15394543744268374, 0.5111217208616612, 0.15038595538253086, 0.16510414609569812, 0.13907251069976834, 0.14427952108066366, 0.11267839448384531, 0.13432453190863602, 0.13186949665467818, 0.1463576020274986, 0.10719611357464964, 0.12496967175540974, 0.14442904410380908, 0.9769947235452445, 0.9813743488294913, 0.967897402324227, 0.9815280486202613, 0.9570814030091248, 0.9223751353650371, 0.9688374290717774, 0.9702623582518416, 0.9892908137572848, 0.7592897685273916, 0.7651739798340864, 0.7786163340094303, 0.7724869571712853, 0.7698587581846974, 0.7550330377654244, 0.7608538562821638, 0.6762141038138674, 0.7768033334471197, 0.8946266117638865, 0.9135527494378314, 0.8867592484542678, 0.8961006813276412, 0.9109203197879043, 0.8962958640238842, 0.8953357314873025, 0.9115124205596508, 0.904514577259359, 0.13329859571398706, 0.12936158774804807, 0.76361875386546, 0.6519702161574772, 0.662201471079563, 0.740007621186258, 0.656835794637571, 0.666007034106356, 0.7021014982211521, 0.6672222286330667, 0.6442880365638679, 0.7716173409751801, 0.7062542090021346, 0.6355108697292942, 0.7150012624218165, 0.6301984773619023, 0.6903169673224083, 0.6895554027891886, 0.7957942306194272, 0.7874117316186284, 0.769261091541997, 0.7856019329740067, 0.7357839901465802, 0.7789583472217716, 0.7726426821003607, 0.7528122095211061, 0.7714481629640946, 0.8162811648367084, 0.8154732302715192, 0.8371296968254611, 0.8116123313620479, 0.8016598613141954, 0.775603258675766, 0.7925992096040205, 0.7792497602000117, 0.8028327228670011, 0.30859571547734466, 0.3642469801680762, 0.20068465724903461, 0.4851186627506421, 0.311449968584138, 0.33364108228636147, 0.5375842648204723, 0.4239326880339127, 0.559014495233331, 0.655379985533689, 0.7029830169734205, 0.6927709201051937, 0.7570606697492639, 0.7163250528318379, 0.7586009832965375, 0.7100893544349667, 0.7384980476917773, 0.7550289559075979, 0.8800223751749475, 0.8839767974308808, 0.8594811678458096, 0.8788640702608529, 0.8768541528353827, 0.8673996208572047, 0.8777008518910823, 0.8934674231494543, 0.8823995238633675, 0.6526921552716352, 0.10692566306992757, 0.11860374374103244, 0.14183619952719762, 0.10545312420432329, 0.5571847875378144, 0.35303469600197246, 0.13648479246123357, 0.11644086496397499, 0.3277715154323151, 0.7154861126563332, 0.18759965183335248, 0.15797563438995443, 0.19446428308566932, 0.2489951262436767, 0.211302081961121, 0.3290757547270968, 0.19289254793208088, 0.5222727089695594, 0.676823522458561, 0.6433949616934755, 0.5525375984796563, 0.48122875560922107, 0.7289635614335062, 0.5989435805542498, 0.6167795767460529, 0.662328810480258, 0.6998739450614385, 0.6612112776989094, 0.5604221929426745, 0.37769379150370863, 0.4937404810069117, 0.6630213619896858, 0.6155011042661886, 0.6937191591298848, 0.670527632287233, 0.20888694146415432, 0.20823426064680728, 0.19949645689679452, 0.25324638058437254, 0.1867167224370867, 0.21718648356474501, 0.2190794258295814, 0.200706355820639, 0.20460700959832268, 0.7124546759044039, 0.24569084967293908, 0.2088981109546939, 0.2461396123119851, 0.2172641697502815, 0.19133978065205648, 0.7806791040975717, 0.24433422410948946, 0.21439899762108838, 0.1868592498517122, 0.9304250540773963, 0.17577526272444977, 0.9093964394551552, 0.1610928518538578, 0.16531800184314838, 0.9062934394071644, 0.187097213518717, 0.14234834304304844, 0.906320046064822, 0.16825844208623497, 0.9124855661254853, 0.12694734940849717, 0.21128784560118308, 0.20994044383492227, 0.21225162718155566, 0.8979898548361114, 0.21373414723117745, 0.18286549387186302, 0.1955962366260361, 0.17666498605154635, 0.18064649143615974, 0.17962615630112178, 0.1737064364438371, 0.18126001700390426, 0.194687193583581, 0.20034900018238766, 0.08025879713733663, 0.08230992718377617, 0.10960640171409508, 0.10960518114045137, 0.0875003944671906, 0.09256904005195699, 0.08902689262554708, 0.0962180992589523, 0.09536437378610896]}, "mutation_prompt": null}
{"id": "89e230f7-681e-450e-b41e-ec4aea2708c0", "solution": "import numpy as np\n\nclass EnhancedHybridAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 * dim  # Slightly increased\n        self.population_size = self.initial_population_size\n        self.memory_size = 6  # Slightly increased\n        self.cross_prob = 0.85  # Slightly decreased\n        self.F = 0.6  # Slightly increased\n        self.epsilon = 0.02  # Slightly increased\n        self.probability = 0.35  # Slightly increased\n\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # More reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.2))  # Slightly increased\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n\n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n\n                if np.random.rand() < self.probability:\n                    strategy = np.random.rand()\n                    if strategy < 0.4:  # More exploitation\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                    else:  # More exploration\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n\n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedHybridAdaptiveMemoryDE", "description": "An Enhanced Hybrid Adaptive Memory DE with Dynamic Strategy Switching that adaptively selects between exploration and exploitation based on dynamic population feedback.", "configspace": "", "generation": 82, "fitness": 0.4250868508092318, "feedback": "The algorithm EnhancedHybridAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.43 with standard deviation 0.26.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.799873460695735, 0.8063158782788777, 0.8200003796230952, 0.8276244719779396, 0.8054111562403692, 0.8082922103111149, 0.7384051426162039, 0.7893149278648367, 0.7872888077977722, 0.6464022850126199, 0.6579690925962898, 0.6788815081503203, 0.6748953046376092, 0.6190631259423038, 0.6686791517579844, 0.612590105247647, 0.6275939771794261, 0.6415583371517091, 0.1099453398082818, 0.11422006517302508, 0.139492838293238, 0.13429790317102197, 0.11264223929855621, 0.13113264482885878, 0.1295975887583718, 0.11424545147974496, 0.10523928472109967, 0.10726586790778014, 0.11867020916174564, 0.1317662449851148, 0.09913031142120599, 0.11471569788282088, 0.09972363309374144, 0.12067924132277419, 0.094869743121893, 0.1082418567613479, 0.9937460485174452, 0.9781734931062864, 0.9640710188985713, 0.9699753845140079, 0.9852216052974504, 0.9447810771232376, 0.9750018809990847, 0.973590031608627, 0.9435679704407537, 0.5189884940567145, 0.5460776022726506, 0.5337618679396001, 0.5803087180885613, 0.5743262237002742, 0.534781754396191, 0.5986207675923565, 0.48788257108926614, 0.552530834628443, 0.8037698959007468, 0.768703622221152, 0.761185134871997, 0.7704582254871982, 0.8334012475301373, 0.7835166667849353, 0.7603779942726435, 0.7827831269523733, 0.7245458173720071, 0.43638047560425464, 0.5358177046719488, 0.5629497819803021, 0.5296503491006617, 0.5481100132034811, 0.5856470325111003, 0.4858950747066102, 0.5953555622574926, 0.5860876983859737, 0.5412918126899009, 0.5388352636826961, 0.12449360776473628, 0.4638147608068032, 0.5483901939003393, 0.5123664860519166, 0.5282630623607714, 0.5129913965690942, 0.49378224841221374, 0.5158528727300737, 0.5593074933575595, 0.4894791822390975, 0.5264051708364734, 0.5533740977748117, 0.48748815951597235, 0.4398449804822713, 0.5046195397942899, 0.4459740928622993, 0.573986440545653, 0.5912260673983225, 0.6192056094463834, 0.6060180895678757, 0.5383601274881127, 0.582745199818909, 0.6002820297221101, 0.5820370504320104, 0.6678851856972468, 0.20075046575180244, 0.3402424584617664, 0.34709276284022383, 0.2275289962122169, 0.4011871253813021, 0.35598647728244515, 0.27741279985361, 0.23541854919823213, 0.21075392213831323, 0.36147086117046956, 0.3740644307523152, 0.4055681280890857, 0.45401141474484596, 0.4718514513149237, 0.41586874794102824, 0.42314628108463104, 0.43534411562591335, 0.41555910300433885, 0.7181799192293719, 0.7569655456125739, 0.7323616381074205, 0.7260226389864186, 0.7432946235788374, 0.7513825867827764, 0.7192624860241463, 0.717744413047122, 0.7453262849068938, 0.09733047601035993, 0.09213928865612964, 0.09578514988410991, 0.10103977107653006, 0.09682999240660706, 0.09864130468016152, 0.08801215126081974, 0.09286348521187515, 0.08930168464504473, 0.20016739726283106, 0.1708884041306885, 0.17756651426397863, 0.2969641501958503, 0.24898923389962369, 0.15765715408955583, 0.2918240208498304, 0.18776214243383038, 0.3707970740044587, 0.4505019559255422, 0.38987189330529737, 0.38421914100750487, 0.37959657217576737, 0.4340219135961588, 0.4207257482938678, 0.39773277318441247, 0.42979108610962247, 0.4632827997984714, 0.37861508421188284, 0.34998822096666204, 0.3558906831140344, 0.30004453896540817, 0.3849799077188196, 0.3516324398209427, 0.3861777841225553, 0.3641064501896435, 0.3362640469197459, 0.20799560565290098, 0.18466599673281603, 0.18678103351777076, 0.20206551417755414, 0.19789950629135533, 0.19011548861777916, 0.19630621145419647, 0.17143410670858572, 0.20176967024673564, 0.20567675287706477, 0.45929403051972173, 0.21624628551409675, 0.24724745044774965, 0.37323773372866575, 0.21733812307992395, 0.2630457724243236, 0.47489073422412753, 0.38974373086179215, 0.17046457462454656, 0.15233358752483095, 0.19668119023324093, 0.782734894195988, 0.7212062924677476, 0.6615260024491817, 0.1842137687819111, 0.18707015099717128, 0.18164118087771375, 0.16725426168069046, 0.7594234914287441, 0.8177480856444851, 0.16554306792450701, 0.20183687506039438, 0.7333112095895357, 0.7754355223828059, 0.1261721839720813, 0.2072214007183354, 0.18233124838803028, 0.19492966521004917, 0.18697473961356648, 0.18193255634649264, 0.17430277233828906, 0.19667470753435168, 0.18536049294772416, 0.18803051080189703, 0.18127061327080862, 0.09052158195837978, 0.08467825026251974, 0.08513126270601767, 0.08462109237721938, 0.07870394524444468, 0.08142802307744113, 0.07569355992823967, 0.08063149246097723, 0.07777263687993818]}, "mutation_prompt": null}
{"id": "5d4e7b87-a705-46cc-a944-c03111ac8872", "solution": "import numpy as np\n\nclass HybridAdaptiveMemoryDEEnhanced:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))  # Slightly less reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c) + np.random.rand() * (d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c) + self.epsilon * (d - e), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveMemoryDEEnhanced", "description": "A Hybrid Adaptive Memory Differential Evolution with a Modified Mutation Strategy and Enhanced Elite Influence for improved exploration and exploitation balance.", "configspace": "", "generation": 83, "fitness": 0.5288025127623582, "feedback": "The algorithm HybridAdaptiveMemoryDEEnhanced got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.31.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.9204326907205753, 0.9139879414643205, 0.9146404150662446, 0.9087099035587206, 0.9061756802680547, 0.911201762162992, 0.9147581694882944, 0.9140569350152373, 0.9198424697181525, 0.8455698023821729, 0.8380355880387951, 0.8453705718924576, 0.8087687240769627, 0.8296428043330879, 0.8375721833590061, 0.8383550652297158, 0.7477633495979161, 0.8433311896602357, 0.15629016535631157, 0.1653794083881639, 0.16187904119873076, 0.13501829139181065, 0.11183958089949919, 0.14932998824065213, 0.1669283806695745, 0.12712461429616628, 0.1404381732516491, 0.17646168074259372, 0.11107848003434395, 0.135365236457764, 0.13830953593338657, 0.16311091101572617, 0.09472123398027665, 0.13974975235486398, 0.17862240336282065, 0.12681280373517334, 0.9499177228470577, 0.9767080398118618, 0.9473893703499396, 0.9553764073930048, 0.9635355360658251, 0.9357273969588978, 0.9842623014755708, 0.9569640911271955, 0.9437774893543336, 0.8006686231364506, 0.7828634128572826, 0.6320161078364088, 0.7902070861376451, 0.7849698622566726, 0.7952296879356189, 0.814796553444828, 0.8021052873520595, 0.7994091796197943, 0.3600972855597816, 0.9141917600972649, 0.8995848734738656, 0.9088761585604346, 0.9073997783931789, 0.3772366540452641, 0.2362438443714674, 0.8949160374768874, 0.9107672254288702, 0.5862621036911746, 0.6619141211375097, 0.8055891444558376, 0.8168064282715115, 0.1346220320849698, 0.5975204587954785, 0.5878241143268117, 0.5178388121902182, 0.7014371362485045, 0.5048290125407215, 0.13248855237242096, 0.6537489558863477, 0.573790262316861, 0.4182089499794259, 0.6111244151733328, 0.7277521821392732, 0.5213099394199119, 0.13310793345841643, 0.7639495730793906, 0.7930237426034457, 0.6251166382111393, 0.8264303987532171, 0.7956373180932199, 0.42943318127225405, 0.8280167915985227, 0.7467790878803204, 0.8235615075047739, 0.679778168648236, 0.7538199301929673, 0.820266795310072, 0.5164117175877405, 0.73735810738743, 0.8315513560735941, 0.8368587914714812, 0.8436080484236679, 0.850829304248777, 0.6350525616252132, 0.1721436935437567, 0.2080656939670804, 0.44091538706531863, 0.5586096810824016, 0.7291400735374552, 0.3257308512421597, 0.6454526759942405, 0.5921270910119303, 0.731520382534891, 0.5182291845199929, 0.742953347778319, 0.5926067033165336, 0.6372964814286741, 0.7707851937419542, 0.49392330799017814, 0.7446247332304767, 0.7617507265511203, 0.8617916554413496, 0.8873122354667529, 0.9019923639906098, 0.8894019663789118, 0.8885702826936916, 0.900941051073313, 0.8878752925009021, 0.8775589633633953, 0.9019656713935912, 0.14907152780425492, 0.1457434578443344, 0.14677879231970126, 0.16289973584187323, 0.15655630824171274, 0.13614438271269313, 0.14690669551253344, 0.13838141579736019, 0.15114144427575193, 0.6415141829222337, 0.16524400478007628, 0.7472078055015745, 0.6529798017855515, 0.30306616104763195, 0.33721103526421614, 0.20874583377827738, 0.7702612230030469, 0.26912774340455947, 0.5704947196716436, 0.5824819178707543, 0.6320322578850132, 0.5869967218383205, 0.5757265715516915, 0.6074806490979253, 0.5340158764619599, 0.6374392599511144, 0.7298953612190691, 0.7012519967299937, 0.35760022784225587, 0.7125796769299994, 0.5122325640023155, 0.6116606303759221, 0.38783084207632623, 0.7026327664260434, 0.3096676563130455, 0.5980779750253088, 0.20973037640948777, 0.19433388373300198, 0.22332954168400343, 0.212342292809928, 0.19799066129670506, 0.2095565112523693, 0.1981598681658614, 0.22263352216813936, 0.22440399857616422, 0.21242052080102158, 0.7914771273983767, 0.2078579903479092, 0.8147902698353032, 0.21796801854916392, 0.17063121121683578, 0.25123886017911456, 0.24391740479412616, 0.2083507552234536, 0.20902420036541347, 0.16587138857438277, 0.9202102906935046, 0.9235087726890031, 0.19904660715482336, 0.9245128363045999, 0.17615286577705735, 0.1631355795632562, 0.9194005385952242, 0.8877395471018982, 0.16809736824979105, 0.9322471876501948, 0.16518031337090833, 0.21214523864734713, 0.8991774922473327, 0.897636453392874, 0.16342020456674122, 0.21300359197653684, 0.18331215999263517, 0.17909168029762257, 0.17374967664725005, 0.18931361477548558, 0.24009775325584015, 0.17774790293296105, 0.18278024809116, 0.18750130576217594, 0.18335267560421897, 0.09624448305666011, 0.09018160753765092, 0.0913884897102838, 0.09741456120022374, 0.089540124934392, 0.10434639965010306, 0.09792933196384634, 0.08379112574802894, 0.09498213503779374]}, "mutation_prompt": null}
{"id": "1bbb51ad-a7ed-4271-b036-9402ea90b06e", "solution": "import numpy as np\n\nclass HybridAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # Slightly more reduction\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.15))  # Increase elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def local_search(self, individual, func):\n        neighbor = individual + np.random.uniform(-0.1, 0.1, self.dim)\n        neighbor = np.clip(neighbor, self.lower_bound, self.upper_bound)\n        return neighbor if func(neighbor) < func(individual) else individual\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial = self.local_search(trial, func)  # Apply local search\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveMemoryDE", "description": "A Hybrid Adaptive Memory Differential Evolution with Stochastic Multi-Elite and Local Search to enhance exploration and exploitation balance.", "configspace": "", "generation": 84, "fitness": 0.31973741613508877, "feedback": "The algorithm HybridAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.22.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.7208295333856055, 0.722337766130292, 0.7211544047786939, 0.702137399916583, 0.687789540770176, 0.7323822818228511, 0.7054603007496049, 0.7300944166675655, 0.7206304967647594, 0.4253231690814385, 0.392593221515507, 0.47686368262319523, 0.40365466531132566, 0.4458348694693657, 0.4532736933882783, 0.4682247937609103, 0.43255299568381944, 0.4644075948549977, 0.10465728345087022, 0.10613204224814976, 0.08466961533029227, 0.10219263549384905, 0.11051138024773677, 0.12932404700242917, 0.09972578142726196, 0.09610965668238891, 0.1112413859495387, 0.1086552863552952, 0.09081861013750125, 0.09689709384763612, 0.11565370041406697, 0.09487042313171301, 0.09858550109495168, 0.07989604815782547, 0.10339994684430986, 0.11750964342535031, 0.9236789382105828, 0.8409345120927371, 0.8111047050191489, 0.8601258438240997, 0.776276303631111, 0.8794367503550828, 0.8344653795891266, 0.90970680284422, 0.8747759632060318, 0.3600206884757309, 0.39810579100832777, 0.36651869411300464, 0.3444338459207844, 0.36348169979269185, 0.3666859453297332, 0.39710850225655747, 0.39514338698092155, 0.3730719866024699, 0.7348124250931287, 0.7278350513273393, 0.6542977132919312, 0.7317015328999901, 0.6904499207581349, 0.7227184945572025, 0.635734000820414, 0.6407245760100697, 0.6920769040173255, 0.18687294455545778, 0.1917746255219791, 0.26319808113353405, 0.2621700925122722, 0.22542022314150778, 0.22898269467722454, 0.18106692836982974, 0.18459273964594558, 0.279067020207028, 0.24365591563552413, 0.20977788426858512, 0.15067098779421428, 0.21363356540360923, 0.24904285529749937, 0.4137087153155201, 0.2393588884066301, 0.21087387559521265, 0.2189216691133028, 0.37335075078641733, 0.3430858635183306, 0.32715862826588704, 0.33935393425868055, 0.32969731915510825, 0.348313910077255, 0.3784952536528865, 0.37139816974388284, 0.3050842563850721, 0.4704547770053735, 0.4495297346107191, 0.46050091254141434, 0.40725205332157344, 0.45370802232994045, 0.43810388664658106, 0.5448611365808225, 0.43432431217740697, 0.4053705289669878, 0.18375588772199603, 0.13148140257876662, 0.12082571985695123, 0.23795796656206325, 0.23170668670130912, 0.22069481800280155, 0.08993371995223964, 0.10758932704480595, 0.16077549888412068, 0.2765659406849239, 0.24569258040768283, 0.2679946989099189, 0.2509243464109464, 0.2869079371427832, 0.3094529494162489, 0.2688240951006572, 0.2641033382985969, 0.2982087052753384, 0.631605049960911, 0.6382298651425189, 0.6324310264705358, 0.6040485785466014, 0.651837976904706, 0.6097994904037782, 0.6496740378427804, 0.6519506926677705, 0.6406237176389715, 0.09325667641262303, 0.10442243023335973, 0.09929086662754816, 0.10545080316846511, 0.0926562646259228, 0.0983580075129239, 0.09406623238213085, 0.0955302814355442, 0.09530243333528743, 0.13781554043364397, 0.1431730967538084, 0.13713899088718662, 0.1380737633831275, 0.15769061159612086, 0.14036515262989957, 0.18794350485713718, 0.1741126964653067, 0.14673171174800104, 0.3500831759024293, 0.31841741596269335, 0.35460576890736517, 0.34952502594374424, 0.35119144727807794, 0.35157024755562394, 0.36861225551832344, 0.3601295309005309, 0.3580259412803847, 0.2945214938785151, 0.27800348748409687, 0.30582203193153845, 0.30234607183346274, 0.2499239259139875, 0.28823397960164043, 0.2750716730564985, 0.3016918969686597, 0.2663994682294024, 0.18968635228995323, 0.1834001566254988, 0.18613817900021468, 0.19166053719027576, 0.20892810711481247, 0.1847237897702294, 0.1943316429313533, 0.1826268188659944, 0.18862220854335232, 0.1996124142923592, 0.1896373604825029, 0.19029029717296608, 0.21086564845740685, 0.1928752541423735, 0.19394017830620436, 0.1909507041489249, 0.2630905268431729, 0.1921433925697702, 0.16940288040829998, 0.1864767412317203, 0.19514298085741466, 0.18422560075074357, 0.17852775768521356, 0.668715486653336, 0.14054763873566822, 0.17124526128137607, 0.16967798535012257, 0.161914605218189, 0.2025346536581215, 0.14792104261566585, 0.16251018599280687, 0.1925946095355322, 0.666447077575568, 0.16074530277027732, 0.7171370896348856, 0.20200095847037414, 0.18190949762290742, 0.17398804749157748, 0.17568776796253038, 0.1888285098422271, 0.18448985478219526, 0.1714697060061806, 0.18610823496946582, 0.18265132269848172, 0.1807379602090079, 0.08572251095648298, 0.07859590285013585, 0.07869190867801845, 0.07324566840243951, 0.06835719159795828, 0.078466771596573, 0.0846883850910164, 0.07412737356188814, 0.08041946395842292]}, "mutation_prompt": null}
{"id": "224b4ea3-ed76-4c67-a8d2-731cc7de94e3", "solution": "import numpy as np\n\nclass HybridAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))\n\n    def multi_elite_selection(self, eval_count):\n        elite_size = max(1, int(self.population_size * 0.1))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def neighborhood_influence(self, vector, neighborhood_size=3):\n        neighbors = np.random.choice(self.population_size, neighborhood_size, replace=False)\n        neighbor_best = np.argmin(self.fitness[neighbors])\n        return self.population[neighbors[neighbor_best]]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection(eval_count)\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    if np.random.rand() < 0.5:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                    else:\n                        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                        mutant = np.clip(a + F * (b - c + d - e), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    if np.random.rand() < 0.3:  # 30% chance to use neighborhood influence\n                        a = self.neighborhood_influence(a)  # Apply neighborhood influence\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridAdaptiveMemoryDE", "description": "A Hybrid Adaptive Memory Differential Evolution enriched with Neighborhood Influence to enhance solution diversity and convergence.", "configspace": "", "generation": 85, "fitness": 0.5437901344735251, "feedback": "The algorithm HybridAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.30.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.8933969408765827, 0.9116673546695341, 0.8885801134253747, 0.9045071459846966, 0.9049038972969972, 0.8984725227131558, 0.9068269267796875, 0.8986553498275256, 0.894906357423293, 0.8171463255158735, 0.7778305719454142, 0.8111756952896475, 0.8086501737198059, 0.8365380193815294, 0.8116958192111849, 0.8299913593004511, 0.8271688615408408, 0.8392087624532141, 0.16685540971507995, 0.1613389817195099, 0.4207620598647829, 0.16169594648269903, 0.16266733618934415, 0.15028442647435225, 0.1698216702250318, 0.3348388021197888, 0.1586570779052121, 0.14082648909425755, 0.1282608346433406, 0.1557631326295994, 0.1612949891016242, 0.14025626562587112, 0.1081175024705261, 0.1159749992443263, 0.1071900056195505, 0.14254602859011234, 0.9689409161701736, 0.9874969281024998, 0.9590741673343156, 0.9775069447689811, 0.9714701473355517, 0.9761838764500732, 0.9725346981274958, 0.9734192232205492, 0.9447950172329901, 0.7619019468415118, 0.7626680105329706, 0.7344168915165261, 0.7225281085651458, 0.765418576727644, 0.7718457866309647, 0.7784974280644945, 0.7308397164361, 0.7369627671917173, 0.8855940571986951, 0.9114683086833423, 0.8935135456852225, 0.9163110965477383, 0.9170591207440301, 0.8928591467681978, 0.9016158389718865, 0.8850595709569012, 0.8850260986046664, 0.7726223709326938, 0.6406910605124094, 0.7461016515953063, 0.6483367873592135, 0.6492378288534219, 0.5956074009289611, 0.69948016745217, 0.6280195011323011, 0.7459279606638431, 0.6109613817803715, 0.4798071808578086, 0.6701128449452397, 0.8173520833361871, 0.7308804717756312, 0.6631268372160097, 0.5920041420754525, 0.623757570278999, 0.5701074277638905, 0.7682603112150981, 0.7847469137259786, 0.7311744961521263, 0.8044724763960756, 0.7808085900183459, 0.502414800705929, 0.6961862961950884, 0.7741686692407421, 0.7909091776168923, 0.8217451243667153, 0.8099456504608249, 0.8039839853726016, 0.8073961866284276, 0.7825134589909162, 0.8066141170088472, 0.8154853573480942, 0.8142427829164596, 0.8299030546119511, 0.45224199329206594, 0.29234085498395057, 0.2525010655136033, 0.7206403379165987, 0.675462403019223, 0.4872401371795174, 0.5135254865809588, 0.36819276682466084, 0.27929640520761656, 0.6960341356168804, 0.7144650344225176, 0.7222311391144451, 0.7324765047109487, 0.7354599707030636, 0.7028407285666429, 0.7338556557696394, 0.6794305991796418, 0.7166646789474145, 0.8739460029224132, 0.8756365541557432, 0.8809173997650102, 0.8761340689872422, 0.8741027372364182, 0.8677815182819806, 0.8717627360583566, 0.8707999283334193, 0.8772805316172878, 0.14578356371370338, 0.12118777329664476, 0.1251974348023026, 0.1596702914091085, 0.49850479746892296, 0.11972426091462152, 0.13221523955356662, 0.14120833125132903, 0.13804309532168613, 0.2697217204336365, 0.23290127772795233, 0.2097956534735872, 0.24276165852302833, 0.4437539617785572, 0.5729733368005447, 0.18841673565454298, 0.26408222672438264, 0.19398416850137057, 0.7162479858364563, 0.7060028433311516, 0.7221915156659273, 0.6867046261852184, 0.6916261414496759, 0.6558043642799383, 0.7025339628103346, 0.5723935030862017, 0.6613732511002117, 0.6626172459062394, 0.5998495118315981, 0.6162747994379565, 0.5307477732698602, 0.6511636054393846, 0.48657908318832155, 0.5405539901013097, 0.46819560763042667, 0.5310362455090001, 0.19595731848250564, 0.19430857330454998, 0.2063481763608298, 0.20266264245139587, 0.20973661927175902, 0.21645419866542448, 0.2066645550086228, 0.22131035371508212, 0.20905668218497397, 0.21974125517925802, 0.2446202932131608, 0.23703858193916494, 0.2192573193260342, 0.6645135735434089, 0.21292401624846657, 0.2284714435898193, 0.24402500366481017, 0.2149763085972366, 0.16543758958809562, 0.16509184164814705, 0.888586977142256, 0.9177763721041015, 0.16640638822966414, 0.16712417758372589, 0.16973474822626344, 0.17063696267011308, 0.8977546188162414, 0.8643149210787152, 0.21223891436185605, 0.15543209257682533, 0.8591989792399904, 0.21173981501773387, 0.20451594826113983, 0.9139787464914264, 0.8871792903866533, 0.9232045857314444, 0.176149100804618, 0.21127113718289348, 0.21326932252189956, 0.18679771384275412, 0.1724936656482582, 0.1855200335055518, 0.1693766995517001, 0.20032879014991556, 0.18069908447176697, 0.08085988815582512, 0.10474082321274802, 0.08449550507413883, 0.08366855143047691, 0.0957090247848309, 0.08611871858659925, 0.08095659527774646, 0.08419431134489264, 0.08592902960674142]}, "mutation_prompt": null}
{"id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "solution": "import numpy as np\n\nclass StochasticAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.2))  # Adjust reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.15)))  # Variable elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "StochasticAdaptiveMemoryDE", "description": "A Stochastic Adaptive Memory Differential Evolution that employs dynamic exploration-exploitation balance with probabilistic operator selection for enhanced optimization.", "configspace": "", "generation": 86, "fitness": 0.5517895900881143, "feedback": "The algorithm StochasticAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.30.", "error": "", "parent_id": "23be91cb-3cdc-4051-bedb-24dd34ceedc5", "metadata": {"aucs": [0.9026205426690144, 0.918100953155066, 0.9083011919376321, 0.9183198851672988, 0.9119666202749549, 0.918996756357273, 0.9097660278721412, 0.9085544183285155, 0.9028568217474686, 0.7667516072117984, 0.8320757008283169, 0.7790217129849755, 0.6313888650924127, 0.8443057388227235, 0.7363545465134662, 0.7429874322745604, 0.8354174336455281, 0.8254370279570588, 0.6185238047067152, 0.16321598728065256, 0.13196264733976637, 0.16192172014232764, 0.45722692821849187, 0.512506446451103, 0.585352367141468, 0.1753486661329513, 0.13660758046766497, 0.1269628061549387, 0.13026787090898873, 0.11355315144791456, 0.5436279500270496, 0.14991475383061337, 0.11737119098874571, 0.14011682992592467, 0.11353391965985882, 0.11370700915815779, 0.9671419644419946, 0.9675720285266917, 0.9482210989712663, 0.9617555698369844, 0.9481333650489878, 0.9793315550906359, 0.972670339714108, 0.9857194707830506, 0.9847619832978642, 0.7811285161127195, 0.7621229724891598, 0.7473590522699176, 0.782815184198584, 0.7760971899406182, 0.7937068339871737, 0.7981796189193153, 0.778751876854183, 0.7772729805283409, 0.9020103015440756, 0.8878817920936273, 0.8981001698988806, 0.9094038828423325, 0.9243902594667981, 0.910799119392464, 0.9157217177772835, 0.9287859708698138, 0.9062070819925682, 0.7243271667546878, 0.6687394528170313, 0.7565568692484745, 0.7296031185117531, 0.5938481915822508, 0.6230626281977379, 0.7078152830623873, 0.6468139233162942, 0.6218427163436924, 0.6445041840047643, 0.570970720931132, 0.6847941837514575, 0.1326027518481615, 0.7007885637241198, 0.6670429058254658, 0.5970052988998804, 0.5861511689450207, 0.6196218543565792, 0.7842692241710203, 0.7242068929373507, 0.8103738138546, 0.8092725064701798, 0.7811003122248297, 0.7310405853838757, 0.8014268104456516, 0.8026596341563637, 0.7890127778752402, 0.46315324620227083, 0.8318943615407436, 0.8432289981440042, 0.8125954977770943, 0.8144250697348216, 0.8265638362948337, 0.8376575872835728, 0.825456864574486, 0.8343003898681035, 0.5815121986874094, 0.41065022165595433, 0.1630574345242929, 0.679920219294416, 0.7122637662298834, 0.5961629065114564, 0.45054837314963747, 0.4988638819877669, 0.3922365477369202, 0.7208056005532877, 0.7237190341769981, 0.7017993560569323, 0.7360298530812563, 0.7248149710724867, 0.6905479147460585, 0.7191597419129188, 0.7070472287266962, 0.7301516254292839, 0.8880036630926731, 0.8738526122336807, 0.889292130743375, 0.8899557817685215, 0.8818879530919563, 0.882303373199465, 0.8762361426663454, 0.8857949622227747, 0.880896077477365, 0.12183090791265583, 0.4478857172917867, 0.16594463654645775, 0.13492385986070787, 0.12606168889025338, 0.13177283337085532, 0.1632163466492661, 0.11294746384973664, 0.17165509489664088, 0.5233848637034055, 0.5420638603695533, 0.17857780091539555, 0.3604553264411312, 0.7272688330190608, 0.1975365789083574, 0.1944738112188531, 0.3030648676376443, 0.4497065258527564, 0.6912964114164657, 0.5724542488991997, 0.7061674862979568, 0.7055804415977729, 0.7288887998812017, 0.7346104079481415, 0.7201744888262192, 0.5720922119878116, 0.7171609456930012, 0.6788683909478503, 0.6695615740525058, 0.49134322982947043, 0.5163727615430702, 0.6974567320696508, 0.5062361557434101, 0.6725453247124482, 0.6389669404445757, 0.6299763637554598, 0.20271966087222604, 0.20746793155232257, 0.21466509732704298, 0.18923297061971767, 0.21228681126649118, 0.20507217120734322, 0.20926500712691054, 0.19876585090528565, 0.22378635650494538, 0.22114587788619477, 0.24629063225479808, 0.23985665425193525, 0.24248033771374722, 0.22022354175702785, 0.7397488134351445, 0.22312676596921732, 0.24856701989728813, 0.22231891064188003, 0.15745128400482777, 0.18807468473812483, 0.9026375657365082, 0.1729790116445452, 0.21294336150062332, 0.1680141232652691, 0.9143393111479314, 0.16599965794558136, 0.17060749955445897, 0.9196297733634758, 0.20969313965199543, 0.9118122464524118, 0.16614073814293862, 0.16803043609456436, 0.8866240588503882, 0.8843725218119963, 0.21072947076427662, 0.21355502643937718, 0.18720653695703982, 0.17713503022290422, 0.1831534893698361, 0.17633295439978425, 0.1885394659002213, 0.17427519476459896, 0.1906397753757516, 0.21221073688346204, 0.20506418977605323, 0.10033453661764757, 0.0978477450275681, 0.08495963426012199, 0.083779686491121, 0.09706927912965313, 0.09074745655402383, 0.09550834900027216, 0.08763552956776455, 0.09370384065262094]}, "mutation_prompt": null}
{"id": "ee8ffd2f-b079-4bce-8cf1-52ed0b532b0b", "solution": "import numpy as np\n\nclass StochasticAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.2))  # Adjust reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.15)))  # Variable elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "StochasticAdaptiveMemoryDE", "description": "A Stochastic Adaptive Memory Differential Evolution that employs dynamic exploration-exploitation balance with probabilistic operator selection for enhanced optimization.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "metadata": {"aucs": [0.9026205426690144, 0.918100953155066, 0.9083011919376321, 0.9183198851672988, 0.9119666202749549, 0.918996756357273, 0.9097660278721412, 0.9085544183285155, 0.9028568217474686, 0.7667516072117984, 0.8320757008283169, 0.7790217129849755, 0.6313888650924127, 0.8443057388227235, 0.7363545465134662, 0.7429874322745604, 0.8354174336455281, 0.8254370279570588, 0.6185238047067152, 0.16321598728065256, 0.13196264733976637, 0.16192172014232764, 0.45722692821849187, 0.512506446451103, 0.585352367141468, 0.1753486661329513, 0.13660758046766497, 0.1269628061549387, 0.13026787090898873, 0.11355315144791456, 0.5436279500270496, 0.14991475383061337, 0.11737119098874571, 0.14011682992592467, 0.11353391965985882, 0.11370700915815779, 0.9671419644419946, 0.9675720285266917, 0.9482210989712663, 0.9617555698369844, 0.9481333650489878, 0.9793315550906359, 0.972670339714108, 0.9857194707830506, 0.9847619832978642, 0.7811285161127195, 0.7621229724891598, 0.7473590522699176, 0.782815184198584, 0.7760971899406182, 0.7937068339871737, 0.7981796189193153, 0.778751876854183, 0.7772729805283409, 0.9020103015440756, 0.8878817920936273, 0.8981001698988806, 0.9094038828423325, 0.9243902594667981, 0.910799119392464, 0.9157217177772835, 0.9287859708698138, 0.9062070819925682, 0.7243271667546878, 0.6687394528170313, 0.7565568692484745, 0.7296031185117531, 0.5938481915822508, 0.6230626281977379, 0.7078152830623873, 0.6468139233162942, 0.6218427163436924, 0.6445041840047643, 0.570970720931132, 0.6847941837514575, 0.1326027518481615, 0.7007885637241198, 0.6670429058254658, 0.5970052988998804, 0.5861511689450207, 0.6196218543565792, 0.7842692241710203, 0.7242068929373507, 0.8103738138546, 0.8092725064701798, 0.7811003122248297, 0.7310405853838757, 0.8014268104456516, 0.8026596341563637, 0.7890127778752402, 0.46315324620227083, 0.8318943615407436, 0.8432289981440042, 0.8125954977770943, 0.8144250697348216, 0.8265638362948337, 0.8376575872835728, 0.825456864574486, 0.8343003898681035, 0.5815121986874094, 0.41065022165595433, 0.1630574345242929, 0.679920219294416, 0.7122637662298834, 0.5961629065114564, 0.45054837314963747, 0.4988638819877669, 0.3922365477369202, 0.7208056005532877, 0.7237190341769981, 0.7017993560569323, 0.7360298530812563, 0.7248149710724867, 0.6905479147460585, 0.7191597419129188, 0.7070472287266962, 0.7301516254292839, 0.8880036630926731, 0.8738526122336807, 0.889292130743375, 0.8899557817685215, 0.8818879530919563, 0.882303373199465, 0.8762361426663454, 0.8857949622227747, 0.880896077477365, 0.12183090791265583, 0.4478857172917867, 0.16594463654645775, 0.13492385986070787, 0.12606168889025338, 0.13177283337085532, 0.1632163466492661, 0.11294746384973664, 0.17165509489664088, 0.5233848637034055, 0.5420638603695533, 0.17857780091539555, 0.3604553264411312, 0.7272688330190608, 0.1975365789083574, 0.1944738112188531, 0.3030648676376443, 0.4497065258527564, 0.6912964114164657, 0.5724542488991997, 0.7061674862979568, 0.7055804415977729, 0.7288887998812017, 0.7346104079481415, 0.7201744888262192, 0.5720922119878116, 0.7171609456930012, 0.6788683909478503, 0.6695615740525058, 0.49134322982947043, 0.5163727615430702, 0.6974567320696508, 0.5062361557434101, 0.6725453247124482, 0.6389669404445757, 0.6299763637554598, 0.20271966087222604, 0.20746793155232257, 0.21466509732704298, 0.18923297061971767, 0.21228681126649118, 0.20507217120734322, 0.20926500712691054, 0.19876585090528565, 0.22378635650494538, 0.22114587788619477, 0.24629063225479808, 0.23985665425193525, 0.24248033771374722, 0.22022354175702785, 0.7397488134351445, 0.22312676596921732, 0.24856701989728813, 0.22231891064188003, 0.15745128400482777, 0.18807468473812483, 0.9026375657365082, 0.1729790116445452, 0.21294336150062332, 0.1680141232652691, 0.9143393111479314, 0.16599965794558136, 0.17060749955445897, 0.9196297733634758, 0.20969313965199543, 0.9118122464524118, 0.16614073814293862, 0.16803043609456436, 0.8866240588503882, 0.8843725218119963, 0.21072947076427662, 0.21355502643937718, 0.18720653695703982, 0.17713503022290422, 0.1831534893698361, 0.17633295439978425, 0.1885394659002213, 0.17427519476459896, 0.1906397753757516, 0.21221073688346204, 0.20506418977605323, 0.10033453661764757, 0.0978477450275681, 0.08495963426012199, 0.083779686491121, 0.09706927912965313, 0.09074745655402383, 0.09550834900027216, 0.08763552956776455, 0.09370384065262094]}, "mutation_prompt": null}
{"id": "fc7d8744-f414-4894-a65c-4cf1f4152477", "solution": "import numpy as np\n\nclass AdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.2))  # Adjust reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.15)))  # Variable elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemoryDE", "description": "Adaptive Memory-based Differential Evolution with Dynamic Population and Elite Selection to Balance Exploration and Exploitation.", "configspace": "", "generation": 88, "fitness": 0.5517895900881143, "feedback": "The algorithm AdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.30.", "error": "", "parent_id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "metadata": {"aucs": [0.9026205426690144, 0.918100953155066, 0.9083011919376321, 0.9183198851672988, 0.9119666202749549, 0.918996756357273, 0.9097660278721412, 0.9085544183285155, 0.9028568217474686, 0.7667516072117984, 0.8320757008283169, 0.7790217129849755, 0.6313888650924127, 0.8443057388227235, 0.7363545465134662, 0.7429874322745604, 0.8354174336455281, 0.8254370279570588, 0.6185238047067152, 0.16321598728065256, 0.13196264733976637, 0.16192172014232764, 0.45722692821849187, 0.512506446451103, 0.585352367141468, 0.1753486661329513, 0.13660758046766497, 0.1269628061549387, 0.13026787090898873, 0.11355315144791456, 0.5436279500270496, 0.14991475383061337, 0.11737119098874571, 0.14011682992592467, 0.11353391965985882, 0.11370700915815779, 0.9671419644419946, 0.9675720285266917, 0.9482210989712663, 0.9617555698369844, 0.9481333650489878, 0.9793315550906359, 0.972670339714108, 0.9857194707830506, 0.9847619832978642, 0.7811285161127195, 0.7621229724891598, 0.7473590522699176, 0.782815184198584, 0.7760971899406182, 0.7937068339871737, 0.7981796189193153, 0.778751876854183, 0.7772729805283409, 0.9020103015440756, 0.8878817920936273, 0.8981001698988806, 0.9094038828423325, 0.9243902594667981, 0.910799119392464, 0.9157217177772835, 0.9287859708698138, 0.9062070819925682, 0.7243271667546878, 0.6687394528170313, 0.7565568692484745, 0.7296031185117531, 0.5938481915822508, 0.6230626281977379, 0.7078152830623873, 0.6468139233162942, 0.6218427163436924, 0.6445041840047643, 0.570970720931132, 0.6847941837514575, 0.1326027518481615, 0.7007885637241198, 0.6670429058254658, 0.5970052988998804, 0.5861511689450207, 0.6196218543565792, 0.7842692241710203, 0.7242068929373507, 0.8103738138546, 0.8092725064701798, 0.7811003122248297, 0.7310405853838757, 0.8014268104456516, 0.8026596341563637, 0.7890127778752402, 0.46315324620227083, 0.8318943615407436, 0.8432289981440042, 0.8125954977770943, 0.8144250697348216, 0.8265638362948337, 0.8376575872835728, 0.825456864574486, 0.8343003898681035, 0.5815121986874094, 0.41065022165595433, 0.1630574345242929, 0.679920219294416, 0.7122637662298834, 0.5961629065114564, 0.45054837314963747, 0.4988638819877669, 0.3922365477369202, 0.7208056005532877, 0.7237190341769981, 0.7017993560569323, 0.7360298530812563, 0.7248149710724867, 0.6905479147460585, 0.7191597419129188, 0.7070472287266962, 0.7301516254292839, 0.8880036630926731, 0.8738526122336807, 0.889292130743375, 0.8899557817685215, 0.8818879530919563, 0.882303373199465, 0.8762361426663454, 0.8857949622227747, 0.880896077477365, 0.12183090791265583, 0.4478857172917867, 0.16594463654645775, 0.13492385986070787, 0.12606168889025338, 0.13177283337085532, 0.1632163466492661, 0.11294746384973664, 0.17165509489664088, 0.5233848637034055, 0.5420638603695533, 0.17857780091539555, 0.3604553264411312, 0.7272688330190608, 0.1975365789083574, 0.1944738112188531, 0.3030648676376443, 0.4497065258527564, 0.6912964114164657, 0.5724542488991997, 0.7061674862979568, 0.7055804415977729, 0.7288887998812017, 0.7346104079481415, 0.7201744888262192, 0.5720922119878116, 0.7171609456930012, 0.6788683909478503, 0.6695615740525058, 0.49134322982947043, 0.5163727615430702, 0.6974567320696508, 0.5062361557434101, 0.6725453247124482, 0.6389669404445757, 0.6299763637554598, 0.20271966087222604, 0.20746793155232257, 0.21466509732704298, 0.18923297061971767, 0.21228681126649118, 0.20507217120734322, 0.20926500712691054, 0.19876585090528565, 0.22378635650494538, 0.22114587788619477, 0.24629063225479808, 0.23985665425193525, 0.24248033771374722, 0.22022354175702785, 0.7397488134351445, 0.22312676596921732, 0.24856701989728813, 0.22231891064188003, 0.15745128400482777, 0.18807468473812483, 0.9026375657365082, 0.1729790116445452, 0.21294336150062332, 0.1680141232652691, 0.9143393111479314, 0.16599965794558136, 0.17060749955445897, 0.9196297733634758, 0.20969313965199543, 0.9118122464524118, 0.16614073814293862, 0.16803043609456436, 0.8866240588503882, 0.8843725218119963, 0.21072947076427662, 0.21355502643937718, 0.18720653695703982, 0.17713503022290422, 0.1831534893698361, 0.17633295439978425, 0.1885394659002213, 0.17427519476459896, 0.1906397753757516, 0.21221073688346204, 0.20506418977605323, 0.10033453661764757, 0.0978477450275681, 0.08495963426012199, 0.083779686491121, 0.09706927912965313, 0.09074745655402383, 0.09550834900027216, 0.08763552956776455, 0.09370384065262094]}, "mutation_prompt": null}
{"id": "2bf2463f-8d5a-4bfb-ad99-a664a4d565f2", "solution": "import numpy as np\n\nclass ImprovedMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 8\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))  # Adjust reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.2)))  # Variable elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n\n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "ImprovedMemoryDE", "description": "Improved Memory Differential Evolution using adaptive elite-enhanced mutation and memory adjustments for balanced exploration-exploitation.", "configspace": "", "generation": 89, "fitness": 0.5287094570069404, "feedback": "The algorithm ImprovedMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.53 with standard deviation 0.31.", "error": "", "parent_id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "metadata": {"aucs": [0.9128987986498511, 0.8999677634439542, 0.9059291469081747, 0.9130557838617984, 0.9056785203055485, 0.9082471578296593, 0.9105455256444852, 0.9084241933433638, 0.890011092576931, 0.811981145808279, 0.6311273224624263, 0.8256969871392824, 0.8220014130396364, 0.8164292971782025, 0.8132378145491248, 0.8282997650795074, 0.8423021019955084, 0.834184430442376, 0.5382034538336078, 0.15895801121702968, 0.1477957692059837, 0.4997379310894223, 0.13741403514487915, 0.1735301134790982, 0.14234244423345066, 0.1667672182162987, 0.14783753175446468, 0.11036545558685285, 0.13250489726953818, 0.12491698892951841, 0.13821568033194886, 0.13878262772797278, 0.11997807483054224, 0.11987335269525934, 0.13421592544078687, 0.12523199691250886, 0.9420002885374568, 0.9622611063125454, 0.9635965992590902, 0.9750225351204712, 0.952996648336697, 0.985604995924927, 0.9645757372896377, 0.9570732661842457, 0.9880878023865373, 0.7771856282750804, 0.7973235842185822, 0.7583668575879596, 0.7788337658847493, 0.776757047544968, 0.7843872504878676, 0.7439955223697112, 0.7742031755770518, 0.7867777056977366, 0.9114970730294754, 0.899182375101337, 0.9108344697021968, 0.90958807925751, 0.9206808061939586, 0.9064796993696713, 0.8965174412248185, 0.9201902874105742, 0.9038150207904628, 0.7541933598063733, 0.5918608980017857, 0.594489871424994, 0.6049881869158313, 0.6019453789886804, 0.599676014986225, 0.645581500604888, 0.13458099612885, 0.7693345053796843, 0.6776009980557618, 0.13388882376520927, 0.60061012757913, 0.7822157893173154, 0.6283800456831865, 0.13411516707218019, 0.792844018671652, 0.5685356551154059, 0.5681595823275181, 0.7544730677976103, 0.7884600554642008, 0.6678002249181786, 0.4197705079084014, 0.7842404953945411, 0.7842999566878848, 0.7813412634959511, 0.43251658368380796, 0.7946977072060056, 0.8172690453860909, 0.7867218779450974, 0.8382401495005256, 0.801833240715264, 0.6715996587109018, 0.8190888635342226, 0.823583600065925, 0.8248253813469583, 0.821964499312331, 0.2529593596356047, 0.14076315015891994, 0.21230649254695177, 0.7145256293676084, 0.6485857679787188, 0.3306567896120036, 0.29026058466965454, 0.401632564791195, 0.2721605283497833, 0.7311057494453208, 0.7046463775970266, 0.70975133257531, 0.7329953487086858, 0.7455138567130084, 0.7596940703599713, 0.6938857491850767, 0.30174743362581025, 0.7313603710736953, 0.8868836162095102, 0.873691594223081, 0.8821866821590675, 0.8567714240435883, 0.8874424449242685, 0.8679896479436467, 0.8793537177859971, 0.8917450379779543, 0.8476197542096153, 0.13494129556392365, 0.6055359478586884, 0.13561244539878503, 0.11039719315330698, 0.16252859420758126, 0.1363184589574694, 0.11829809957963477, 0.13423182010387702, 0.1308014900366654, 0.216203489333346, 0.18945943294407175, 0.21391877748471044, 0.14653031174680586, 0.2705465055068861, 0.2237197808447451, 0.1930326507626362, 0.21199282622124205, 0.23049292932113996, 0.735605462615247, 0.7216199133898489, 0.7124938950243862, 0.4778032743507177, 0.7127524194670873, 0.70690014169059, 0.7267334944504656, 0.7348879824569342, 0.7531410062159805, 0.5697816224210284, 0.671608631144361, 0.687193386635771, 0.5646673430423276, 0.37873259665065684, 0.6732532667577682, 0.6630404772892904, 0.6681499819518653, 0.6869192503925327, 0.21169499120115287, 0.2158499634834775, 0.2227381078425653, 0.2025925747275804, 0.22427240556175454, 0.20811120419177276, 0.20749335820639603, 0.22286524186911316, 0.21543551370931868, 0.7055539811254159, 0.1968155510175491, 0.7677382591664708, 0.20387903225130488, 0.7723869357044357, 0.20359201999138732, 0.7563277799858729, 0.24791027273009536, 0.2155158777005085, 0.18631149889213205, 0.16979368164250996, 0.1855899349095369, 0.9141425160819764, 0.1507824041377206, 0.19776076615388083, 0.8940537472429668, 0.1564547288387197, 0.920009665914501, 0.2086686331854296, 0.2111694039596267, 0.20785449708627945, 0.16778007108978255, 0.905814862157477, 0.2075356050304541, 0.9246809578015021, 0.1566085207317085, 0.21432772754792617, 0.17794022470461224, 0.18043108635135519, 0.1832777245997249, 0.18079500337704668, 0.1921279747496646, 0.20098384953852566, 0.1981918609832538, 0.1794353390506771, 0.18618184738975063, 0.08425078375101369, 0.0841020184041279, 0.08899801469031476, 0.09271144487603378, 0.09466551111530985, 0.08031056187233421, 0.08764916383920685, 0.09242150394621151, 0.09832360041503685]}, "mutation_prompt": null}
{"id": "ce1a7073-5d95-45b4-9e20-81f7fdf3b899", "solution": "import numpy as np\n\nclass AdaptiveMemoryEliteDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.epsilon = 0.02\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, 0.5),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))  # Adjust reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.15)))  # Variable elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveMemoryEliteDE", "description": "An Adaptive Differential Evolution with Memory and Elite Selection, using stochastic parameter tuning and dynamic population control for optimal exploration-exploitation balance.", "configspace": "", "generation": 90, "fitness": 0.5350745965732441, "feedback": "The algorithm AdaptiveMemoryEliteDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.54 with standard deviation 0.31.", "error": "", "parent_id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "metadata": {"aucs": [0.8998132333034231, 0.9107521795863451, 0.8931234559672252, 0.8931207272951259, 0.9112311461680378, 0.902236432159629, 0.8963009899565129, 0.8942669492642594, 0.8924799205297893, 0.8051164760635646, 0.752476021610218, 0.8227644635862895, 0.8322748555408308, 0.7701770531438197, 0.7863561935090553, 0.806086819570804, 0.8113413564889576, 0.6810238259975501, 0.13738670382292462, 0.6294255900209996, 0.16202765675022834, 0.13972168840195487, 0.15799114199162756, 0.15390973160338794, 0.16360422435627153, 0.14365842351719038, 0.13871738741722406, 0.12670920359450433, 0.12893258169148336, 0.1325825805502343, 0.13300832569315157, 0.09356213476310116, 0.11262341851485347, 0.12732996424590892, 0.15068846531703306, 0.1673168732150201, 0.9769555737656733, 0.9798240661189461, 0.9828118725304905, 0.9615312034757862, 0.9645614538503275, 0.9701744641251518, 0.9535559416412078, 0.9693112794484617, 0.9879031584220249, 0.7699356052188643, 0.7474688439253433, 0.698213709115773, 0.751878017207313, 0.7792008254746112, 0.7543663487242336, 0.783041708782855, 0.7158234794409348, 0.7397337042211427, 0.8860804881022449, 0.9102650327527774, 0.9073417286628864, 0.911579735006161, 0.9242086028786828, 0.9249299621908667, 0.8893945775508973, 0.8620995501842424, 0.893798616415691, 0.6954984548432313, 0.7976291126505181, 0.6863308678365322, 0.5905691848925156, 0.5883453517791336, 0.6728687067465133, 0.7027008143890616, 0.7713923447965354, 0.6657544120675627, 0.6053362956960219, 0.6667102149940664, 0.7188377769231402, 0.7384505361500286, 0.6637836709917526, 0.5591052355801928, 0.712044004203501, 0.6049128269596261, 0.73308526395233, 0.7797306265156078, 0.803588837837909, 0.8033027167755583, 0.7287703662384009, 0.7849005078664603, 0.776346649541195, 0.7647823773103163, 0.8012177446541282, 0.7856819116315227, 0.8129935847959453, 0.8072612363494263, 0.8392810307390217, 0.8242227971897066, 0.8323628862040205, 0.7531787459393311, 0.8344241839668791, 0.8510098434028006, 0.8329906515424433, 0.6271412663867062, 0.5667505149105839, 0.4513518076492844, 0.7217608714543801, 0.6909399481451295, 0.722415174783571, 0.6071076505187509, 0.37889884802999985, 0.27294434393299993, 0.7147945345426265, 0.676532610562222, 0.6768725155750336, 0.6692237874115872, 0.6470032413517863, 0.5993496766803827, 0.6872978974558803, 0.7048186014989375, 0.672069584691853, 0.8827111698418503, 0.8814068540187346, 0.8805056482246116, 0.8663114214284771, 0.8729004276228638, 0.8671453131702578, 0.8691313880086166, 0.8748234009235941, 0.8721396446764926, 0.10386846881141265, 0.11395896267757177, 0.12062439940368408, 0.13938424864278454, 0.12693082160662694, 0.13960031828098596, 0.11140553339003179, 0.14057579850887036, 0.1375283235085395, 0.3119549381752197, 0.17504502553452805, 0.5999567284983278, 0.24645615883413485, 0.21075060361934217, 0.2071550673313428, 0.21319759157785634, 0.16554148772315436, 0.15544617865887955, 0.6270105658161479, 0.6221016181680412, 0.5683488664513484, 0.6503022694728826, 0.5852019542186402, 0.6022151335319881, 0.6828671051233586, 0.7095066638280216, 0.6401051765397758, 0.5617508616053251, 0.24421334382238125, 0.49636948303676, 0.6245175602775473, 0.6346073078556288, 0.6125099095382419, 0.5553149595766353, 0.648152975250287, 0.2220669670523404, 0.22480816919612057, 0.20875523765005177, 0.2000244445992576, 0.20780610358353857, 0.1966036090272536, 0.19210976589312379, 0.21283181885405655, 0.2216189429973049, 0.2347244524550982, 0.207196564556672, 0.22153452711037003, 0.24069004946346217, 0.23873411432804292, 0.2043361251789031, 0.21715009965359988, 0.2391188669810428, 0.24397950641424504, 0.23648302987792125, 0.15600771164809868, 0.14839919678135538, 0.9100260179426717, 0.1885326508748303, 0.19999286234328761, 0.17048118058488038, 0.9033466769362293, 0.16559460182506391, 0.8287233182875295, 0.9128910020381047, 0.9023771243715258, 0.8827084848663722, 0.16681708178585342, 0.8282310290571703, 0.11069977427285482, 0.21176560326643834, 0.20986511965189392, 0.2140819689963993, 0.19661171837880498, 0.17715372091278436, 0.18596832465602786, 0.18883519632817447, 0.1790085828556376, 0.18292660629882096, 0.19271439732806372, 0.17603765104906632, 0.20026945152980624, 0.11672908924830938, 0.0850594185839636, 0.1008750085877218, 0.09553339186344112, 0.08884435516171796, 0.08151188993699265, 0.09029590651963448, 0.0873339709975478, 0.08493630839264643]}, "mutation_prompt": null}
{"id": "b98cd1fb-07eb-4b81-9229-b74ded9941ce", "solution": "import numpy as np\n\nclass EnhancedStochasticAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))  # Adjusted reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.20)))  # Extended elite size range\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.laplace(0, self.epsilon)  # Laplace distribution for mutation control\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.laplace(0, self.epsilon)  # Laplace distribution for mutation control\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedStochasticAdaptiveMemoryDE", "description": "A Stochastic Adaptive Memory Differential Evolution with adaptive mutation control and dynamic elitism for improved diversity and convergence.", "configspace": "", "generation": 91, "fitness": 0.48619310930858434, "feedback": "The algorithm EnhancedStochasticAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.49 with standard deviation 0.31.", "error": "", "parent_id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "metadata": {"aucs": [0.9249646149886149, 0.9215391938603743, 0.9107309440411441, 0.908036058798856, 0.7970786775533354, 0.9209656358280506, 0.9089936667209508, 0.9150686968290118, 0.9056538679510321, 0.8446411488663574, 0.8165037193504106, 0.8491086376612275, 0.7846706495766114, 0.8344670305187544, 0.8612792747689755, 0.8372117776400951, 0.8299639765086154, 0.8490429522900138, 0.6130042024414806, 0.5464780956034367, 0.15409094299353587, 0.14125264228145262, 0.1759524898051874, 0.16624960198562933, 0.14755405099875318, 0.48877789887109746, 0.20270009431631375, 0.16055097012200825, 0.12949032655324078, 0.14805700155383272, 0.1262442331007687, 0.1369932572847743, 0.13872498467534533, 0.1000173608430105, 0.13639830691358001, 0.14036042765608092, 0.973837865117825, 0.9555117535945572, 0.9899775275204147, 0.946880378983179, 0.948438290850169, 0.9646230202992494, 0.964801809585807, 0.9690338173253934, 0.9609451841110958, 0.7814226244720193, 0.7998143002106921, 0.7329541979900103, 0.7885568475263763, 0.7696468500079623, 0.772330627838879, 0.4002809213297204, 0.46112447854903593, 0.7952602905612902, 0.895519873615872, 0.8968078159498238, 0.8826226867011391, 0.9248523530174896, 0.9179560561132916, 0.9158539416113379, 0.9038767788489487, 0.4704623591489089, 0.3965876173809315, 0.31487090229735304, 0.27135535920822107, 0.41337093910580736, 0.26636138663597886, 0.13180374549260965, 0.132109566848983, 0.16685561420690953, 0.1703733756316007, 0.3751970424094213, 0.16972580079676847, 0.24796709047899745, 0.2108454430333644, 0.17777598942675055, 0.5193638822876128, 0.43150037393761553, 0.7159060826452927, 0.2007925932780853, 0.17546781114627252, 0.8390567182712398, 0.8025689250249597, 0.5613076631598286, 0.811184537359855, 0.829543383876781, 0.7534857666025665, 0.3585902382280389, 0.8195985913744506, 0.7946413277432878, 0.8335488426818004, 0.33700489549313684, 0.8450427818509666, 0.24492633865723779, 0.7826479929582351, 0.8480745346968221, 0.8398285355900551, 0.8296512510422662, 0.8355260662517395, 0.041906896390257464, 0.30655381661733383, 0.3663636722104888, 0.3112067230988048, 0.6655441024077006, 0.30877787950059765, 0.275369443301106, 0.16890852993411065, 0.09925274136409357, 0.7234939402769789, 0.7279585840551068, 0.7597259194962322, 0.7651588158563642, 0.7425905094724079, 0.773353927997682, 0.3337252530526241, 0.7269226457046611, 0.5797073448096595, 0.8784626287399677, 0.8926109413086754, 0.8971657895519728, 0.8844626301795945, 0.8936596769480247, 0.8862608788078279, 0.6284177249418758, 0.873161126780128, 0.8795111295774897, 0.10906336466930278, 0.11664920210153962, 0.12475482316331743, 0.43579976171435475, 0.38140011967309284, 0.15382017773423684, 0.1354548931113292, 0.1198940334254297, 0.15221718025262543, 0.2038268431365715, 0.33397759685536155, 0.17652959312598981, 0.6000547946788992, 0.2420752693683258, 0.24088071891790663, 0.21912074803776926, 0.2553777193153438, 0.22723798430305564, 0.5678508147375144, 0.7632488711963328, 0.6658821797529425, 0.5565345340340235, 0.46244635382990495, 0.5571842351976268, 0.6119062570880027, 0.7572858992620427, 0.49009824618639697, 0.5962880460898453, 0.5475209473904712, 0.4224922098024688, 0.5370146847531333, 0.603205365871548, 0.7264100479446485, 0.3367441146488611, 0.282237934948529, 0.5920865643072899, 0.2142907108834302, 0.2353127491260255, 0.2160645800942783, 0.2198160940334396, 0.2052646150887626, 0.19365622098456248, 0.20204004667143782, 0.22627546549800492, 0.2095176731280185, 0.2420784233540858, 0.2429190187770668, 0.2467772035505973, 0.24723166858661139, 0.2182037141522618, 0.7593171044664527, 0.1995651136124199, 0.24256976958963705, 0.19503988532093186, 0.17017992055000009, 0.17233488181989065, 0.2117870414911318, 0.9020321897587709, 0.21168306945511084, 0.8886436283432723, 0.16096478399219538, 0.167271656003797, 0.82173243508639, 0.9212946540100467, 0.8174348451697072, 0.8930350835952341, 0.20337976675017122, 0.20994282081685933, 0.12698798490818075, 0.21156986801863253, 0.210626478455176, 0.21340984897617166, 0.19875946649929144, 0.18767346194926926, 0.19312874071996966, 0.1752154980359657, 0.17529369009834828, 0.18554229709218106, 0.19374260140748234, 0.18877722630861582, 0.18720451130772897, 0.16362683621032847, 0.10286588646189299, 0.08456963058870026, 0.0888547312742407, 0.09473119237089411, 0.09516936496863149, 0.08936543868896119, 0.08990775257149142, 0.08755779722936607]}, "mutation_prompt": null}
{"id": "a8ec0edf-e1ec-47c1-847c-8e8147c7a7a4", "solution": "import numpy as np\n\nclass HybridQuantumAdaptiveDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.2))\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.15)))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def quantum_inspired_mutation(self, a, b, c, d, e):\n        alpha = np.random.beta(2, 5)  # Quantum-inspired parameter\n        F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n        return np.clip(a + F * ((1-alpha) * (b - c) + alpha * (d - e)), self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    mutant = self.quantum_inspired_mutation(a, b, c, d, e)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridQuantumAdaptiveDE", "description": "A Hybrid Quantum-inspired Adaptive DE using dynamic trial vector generation and memory-based parameter tuning for enhanced robustness and convergence.", "configspace": "", "generation": 92, "fitness": -Infinity, "feedback": "An exception occurred: UnboundLocalError(\"local variable 'F' referenced before assignment\").", "error": "UnboundLocalError(\"local variable 'F' referenced before assignment\")", "parent_id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "metadata": {}, "mutation_prompt": null}
{"id": "ff23dadd-c503-4505-b481-1ed25db2f10d", "solution": "import numpy as np\n\nclass RefinedStochasticAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.2))\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.15)))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * ((b + c) / 2 - d + np.random.rand() * (e - a)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - (c + d) / 2), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "RefinedStochasticAdaptiveMemoryDE", "description": "A Refined Stochastic Adaptive Memory Differential Evolution algorithm that incorporates strategic mutation with weighted averaging and targeted crossover to enhance convergence in diverse landscapes.", "configspace": "", "generation": 93, "fitness": 0.4624212542358142, "feedback": "The algorithm RefinedStochasticAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.31.", "error": "", "parent_id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "metadata": {"aucs": [0.9251969767478259, 0.9312588793511595, 0.9240003584418938, 0.9319386242216166, 0.9314591977313733, 0.9099414727264712, 0.9118581133407319, 0.9259429138277296, 0.9229103717177911, 0.505981682390672, 0.21957522454727685, 0.8761778588226898, 0.8600711431029615, 0.46571935912517326, 0.8566736131030714, 0.611149647778894, 0.5421537111157615, 0.8693025786742283, 0.11266311796303585, 0.15291433376863062, 0.15961592308026717, 0.13402758675537574, 0.12271912133161056, 0.1685730080837069, 0.17705875632140144, 0.16821204047539362, 0.13053442460469922, 0.10735281741152725, 0.10748550119450195, 0.1105262422451766, 0.13188630761580267, 0.10821929888465787, 0.16191572163205925, 0.14338111186949787, 0.143131991222607, 0.12379003654985732, 0.9595266531596424, 0.9288434029705739, 0.9513078151776599, 0.9803003307306964, 0.7899651651923651, 0.9622087748035332, 0.8931931794572142, 0.9544912114429486, 0.9623363469362968, 0.827444647061987, 0.8124071324792488, 0.8091701662492283, 0.8123955798225685, 0.8236394919857439, 0.8432444763485885, 0.8108302456631284, 0.8129129654077942, 0.8084369758847061, 0.8780684789924528, 0.9303919943652137, 0.1710881189457807, 0.9346289187244353, 0.9457357612187602, 0.9393571843475753, 0.23350040886815948, 0.9329675025618018, 0.12666325526675715, 0.42156208129741946, 0.4843069189552941, 0.3795493979600846, 0.4671400478987925, 0.13297680199582973, 0.3948844504509529, 0.44269138925130247, 0.3752760295536417, 0.5792269492983465, 0.34983136757806355, 0.6194436119800903, 0.4221990756396754, 0.13538476539779531, 0.32919545918677573, 0.450893599667471, 0.44028364850053214, 0.4282985111069315, 0.13337998108815996, 0.8242295325324602, 0.4602767567641153, 0.8340805992848453, 0.5055226035621334, 0.8509109490564775, 0.24202525817377396, 0.31741073246398377, 0.5529587820476114, 0.3860216181644841, 0.8803731882554786, 0.8641201435494589, 0.480523092488667, 0.32146056873119555, 0.8379069589827198, 0.6455138972632581, 0.876839962992964, 0.6351158772748657, 0.36082145696274937, 0.2752230632069367, 0.1729003720867096, 0.16756449021025022, 0.5658314511080604, 0.3221401266702779, 0.26919882334123935, 0.7022688752134367, 0.20139962754340546, 0.1915023877622135, 0.789502563566563, 0.5639678297026072, 0.3773858481953126, 0.18368628637418383, 0.7876279131945858, 0.7889818555614292, 0.24783592671080157, 0.4342702229098768, 0.36634272497539044, 0.7946429796600141, 0.7821055947337456, 0.7422285946959728, 0.9059424733316122, 0.9091360533451103, 0.9126600456046156, 0.6571638939354771, 0.9018439258890708, 0.8995000211476744, 0.14032344934832675, 0.1538732020567466, 0.13774615280399305, 0.13979567621258704, 0.12772698741854516, 0.117962765819983, 0.14439415413864898, 0.3538946795004825, 0.1256511066431245, 0.6134217309994813, 0.4140560256444541, 0.2512289384844195, 0.1910086657294663, 0.16681759750995062, 0.6326114324340386, 0.769705624384744, 0.5880150637069836, 0.26785426655926625, 0.6409208764657521, 0.8194893196193813, 0.3087968460028754, 0.4871271221309543, 0.5555454333452039, 0.7941749436451235, 0.24068702573738887, 0.8244502163522899, 0.7819796287926037, 0.33416063501065296, 0.7671985086973805, 0.5462756246260898, 0.7265208705840505, 0.20807915412860922, 0.29248933806638044, 0.2568439794314862, 0.7394611248915776, 0.2105044057423826, 0.2261586508073663, 0.23760408539654054, 0.21661206249474507, 0.2271447168439341, 0.21921501421677303, 0.223577415687102, 0.21246440627772079, 0.193799421685939, 0.23163561290077794, 0.20279518443643252, 0.744026613072349, 0.22307413246320573, 0.247355792824408, 0.6996414642985472, 0.22250507789314322, 0.2036327956374695, 0.20912892505615444, 0.20825665847229358, 0.9129727840205344, 0.18698669563115122, 0.8971670589457191, 0.1713436262640322, 0.1989988782503872, 0.1988800653779259, 0.1658500396566185, 0.1682808181256138, 0.1794061861698517, 0.9303015631597966, 0.1561427097241389, 0.9334419440230624, 0.20807367854746384, 0.20874554442141757, 0.16950284609300492, 0.21188797409950955, 0.16790589243234022, 0.2140831994630995, 0.17680614853018506, 0.18591501617814088, 0.18357439456988633, 0.193103529162586, 0.20105475133257456, 0.17430261045524553, 0.1843880614153034, 0.1887954703790219, 0.19757364040214864, 0.10438671481878103, 0.0930461120169137, 0.08952987892549158, 0.11351805540958759, 0.09457095777506552, 0.11057324591923368, 0.11133729797123415, 0.10090967072250445, 0.08434796353901819]}, "mutation_prompt": null}
{"id": "1a1c1141-a1e8-47e9-b52c-c72b64097c7c", "solution": "import numpy as np\n\nclass EnhancedStochasticAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 10  # Increased memory size for better parameter diversity\n        self.cross_prob = 0.8  # Slightly lowered for more mutation diversity\n        self.F = 0.6  # Slightly higher differential weight for increased exploration\n        self.epsilon = 0.05  # Increased for more parameter perturbation\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))  # Increased reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.2)))  # Wider elite size range\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedStochasticAdaptiveMemoryDE", "description": "A Stochastic Adaptive Memory Differential Evolution with Enhanced Memory Utilization and Adaptive Mutation Strategies for Improved Convergence.", "configspace": "", "generation": 94, "fitness": 0.45607089890103897, "feedback": "The algorithm EnhancedStochasticAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.46 with standard deviation 0.27.", "error": "", "parent_id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "metadata": {"aucs": [0.8356617994728539, 0.8514092539667873, 0.8259261744868477, 0.836951073732235, 0.8408601913991509, 0.8161662275524854, 0.8350520859288407, 0.8276540550669614, 0.7970245198487471, 0.724568117470282, 0.7209927091385002, 0.6376640228919016, 0.7360607833860622, 0.7131581344373167, 0.6999913805551314, 0.6957984462655151, 0.6340684142685138, 0.6960355074823046, 0.14470978146275415, 0.12329966505713397, 0.1334015445797626, 0.2879148203737314, 0.2501320531566086, 0.2813770924195943, 0.14530809873386774, 0.13001830274350445, 0.3133989562234728, 0.1159483413379998, 0.14014552862828245, 0.12407029339780273, 0.13027996537557285, 0.14484355243666525, 0.1428057383908342, 0.10316944987009558, 0.12829842720016182, 0.1401455503002409, 0.9732275091496801, 0.9745274360445941, 0.9606097133213416, 0.9737538517776921, 0.9804064755307714, 0.9887613257302528, 0.9687357936144523, 0.9742048598823396, 0.9891958738245596, 0.551293330145249, 0.5787134903147915, 0.5445083727577015, 0.5907226111582944, 0.5629114155116743, 0.592837439870953, 0.5739491188296415, 0.587995411616169, 0.5642396377820607, 0.846695668463666, 0.8380865658332745, 0.7772588619206269, 0.8470136417013361, 0.8465184827275745, 0.7936597875047017, 0.8170443707453299, 0.7931290435088958, 0.7887919156248074, 0.6135974407256861, 0.5900952900025613, 0.6063850636395569, 0.6386205822320166, 0.4961559964197304, 0.5718757670491988, 0.6110648594890218, 0.6113533907966163, 0.6603438406998792, 0.5720333707646553, 0.576930486422153, 0.5931650859840181, 0.6555765865213684, 0.5812523047420999, 0.6254502672074184, 0.5662023956890445, 0.6463091606738376, 0.6006046236867086, 0.6395258122001324, 0.5882867597628906, 0.5161121621456629, 0.576132494910025, 0.572713934895015, 0.5807674098267874, 0.5112264773585788, 0.6135123169572632, 0.5724654700606395, 0.6972473600460269, 0.6267191327685746, 0.6735492340191704, 0.6630320316536461, 0.6148086506806278, 0.6073526048718667, 0.6742141555841483, 0.7286375416456621, 0.6693047142111788, 0.30984281033723715, 0.42096751737810734, 0.34772746027785006, 0.415994974200797, 0.561857450039952, 0.2855359203509117, 0.23524123951761344, 0.3838210199529122, 0.28466857123442524, 0.45757449273219586, 0.414322801227637, 0.4256623420401502, 0.40855529583625516, 0.4434946071339714, 0.49186183381188353, 0.49712201492458974, 0.5093850788223222, 0.4251101375117693, 0.7163266365551555, 0.7727307975171287, 0.8066321660228578, 0.7343865502186104, 0.7822013495996202, 0.7763787033428563, 0.7675972803358048, 0.8106156174362599, 0.7886618831802666, 0.10635515355763892, 0.10031418529977054, 0.09661380268768283, 0.08569939344375455, 0.1132325379727196, 0.12156765418995275, 0.1146406327264542, 0.09810050309575868, 0.10172943302600146, 0.15455522069287797, 0.15460127207746077, 0.2051301634453787, 0.14650551688615654, 0.2102004935563112, 0.13866989071489555, 0.1372571736306316, 0.18460706321169318, 0.16629345002721185, 0.4678504487612707, 0.4770825718526921, 0.4867084882781495, 0.4650286446623014, 0.4409134260074121, 0.46538341128499106, 0.4823164287229933, 0.5107478982686039, 0.4055759018043521, 0.40721184552187795, 0.39667032466251295, 0.35976975001264677, 0.3694762732280379, 0.4010725244494763, 0.41478740645343215, 0.4153146070464351, 0.41058332266931685, 0.3730987927951174, 0.20462076478695557, 0.20786034942341247, 0.20048562621507449, 0.18132766966541636, 0.21689042137682335, 0.2065181656363999, 0.18804018507605802, 0.20112878882672403, 0.2035900970288953, 0.5314089374835023, 0.6265899032489237, 0.6345080653557189, 0.44845766115825314, 0.513882234027714, 0.22509640386239305, 0.1942526597612404, 0.2379170579786808, 0.5543057085311447, 0.819431254996247, 0.8058735416401955, 0.15055787838741386, 0.19201740785609944, 0.17792967999529208, 0.8475938039355149, 0.16892245809801898, 0.1856609860508439, 0.16281808956381938, 0.20570967596019463, 0.20767249208267513, 0.2113454694100937, 0.2018145440554382, 0.8006403194285514, 0.2041906954512589, 0.21110495671950402, 0.15572607813116446, 0.21303107599783133, 0.17831573397979916, 0.20430940525290608, 0.2230597708280596, 0.17909326542453619, 0.1787509998303205, 0.18457962775493852, 0.19561456967979907, 0.17360448390101102, 0.18899333453800493, 0.08849378671737906, 0.07768603778403627, 0.07886628211253233, 0.0770442767034436, 0.07683218728919694, 0.08565752080165223, 0.07483903450787188, 0.0851542298429504, 0.0758295099349402]}, "mutation_prompt": null}
{"id": "5d7e5f89-bbf4-484a-a22d-e84dfdfefb7b", "solution": "import numpy as np\n\nclass EnhancedStochasticAdaptiveMemoryDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))  # Adjusted reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.2)))  # Altered elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "EnhancedStochasticAdaptiveMemoryDE", "description": "Enhanced Stochastic Adaptive Memory Differential Evolution with self-adaptive control parameters and dynamic replacement for improved search flexibility.", "configspace": "", "generation": 95, "fitness": 0.5530179682423386, "feedback": "The algorithm EnhancedStochasticAdaptiveMemoryDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.55 with standard deviation 0.30.", "error": "", "parent_id": "3fe678b2-f580-4961-bee4-cf8d5e56e455", "metadata": {"aucs": [0.9043709846827641, 0.8892435092617489, 0.8977846313364921, 0.8927665830036454, 0.9040508002621467, 0.9125453451327363, 0.9008911065285036, 0.8988006001438381, 0.8874483262387767, 0.8426313157942174, 0.823648531302938, 0.7769036286719626, 0.8261752782647472, 0.824260663309124, 0.8065674618639098, 0.8335314430190459, 0.8366043586248832, 0.8242352503591, 0.11768477630289798, 0.6374015075891434, 0.16590993733945092, 0.4694344575690569, 0.14099594553371841, 0.13325947703662455, 0.14743969764173848, 0.15292849675708453, 0.11429517018086477, 0.12143779232872198, 0.11404767939017402, 0.10513905612694763, 0.15907547880420547, 0.1355908981402647, 0.1492010885048094, 0.10878858334203145, 0.1365554602883169, 0.11652571562114522, 0.9698866851028539, 0.9434423476166102, 0.9863705440538163, 0.9595991522340009, 0.9747826065158522, 0.9215725763953243, 0.9548608891439787, 0.9808942298821886, 0.9828557839032255, 0.77644168913658, 0.7383557319757121, 0.7697882929079904, 0.7534527656021522, 0.7834951323156363, 0.7724261833674916, 0.7703928925526997, 0.7717068405109366, 0.7883540462927993, 0.8847161985312848, 0.8856661062065797, 0.891761605120437, 0.907622061180182, 0.891603644550306, 0.9053829516294934, 0.9155426999858167, 0.8983016566838333, 0.8838843192741207, 0.6535406840684064, 0.7439844310369683, 0.7537355000377466, 0.5994192937282958, 0.806968293373824, 0.762215731386151, 0.6949725891008245, 0.6489144527535448, 0.6980165857390355, 0.6121505118446868, 0.664447635062057, 0.7593436688935451, 0.5805093802643166, 0.7336242442300247, 0.5159442581462628, 0.7749962758263577, 0.5716296162858097, 0.6327443296648279, 0.7827206872079417, 0.7609396529394552, 0.8000585650255824, 0.7767964850595102, 0.5951445084444565, 0.7506536851160077, 0.7673993786547961, 0.7898846010241989, 0.785311200475152, 0.8098173552761274, 0.8273641467459262, 0.8512216757538502, 0.8278679443102877, 0.7836771508079015, 0.7608809586184178, 0.8213254184157827, 0.821090185746188, 0.8186996456994302, 0.48303508013736896, 0.33546241507149244, 0.2561313660033362, 0.7147153866774116, 0.3049972447290281, 0.7176398490521527, 0.5372208622410065, 0.5845761024633996, 0.2305471184172856, 0.7019215717048499, 0.6879081525865591, 0.7190885464796282, 0.7175580520942672, 0.7292638818752855, 0.7235960231498728, 0.67323937729257, 0.7485626021575457, 0.4935759803702754, 0.8811563722839385, 0.8575633090355825, 0.868587149903717, 0.8830496260153131, 0.8814651337414298, 0.8764998909556302, 0.8863038447685596, 0.8730130268973905, 0.8939133946883792, 0.13057956008570704, 0.4068686655200471, 0.13737320220580929, 0.16263383380396612, 0.1313075263825253, 0.6317054456974283, 0.14699836084935092, 0.5871120195311652, 0.15428129033121663, 0.1670599934268444, 0.21609328212022016, 0.4729487862245736, 0.414507425187156, 0.1991999783801618, 0.1783004191302513, 0.1862129690157982, 0.41711477409108155, 0.20532336692460718, 0.6974402080064239, 0.6986181837450567, 0.6820204339438134, 0.5894312967396667, 0.7508612461793271, 0.751962024714262, 0.7064542176819615, 0.7254106971456384, 0.7341843374889864, 0.6528861551511884, 0.6846029246711489, 0.3478674627821381, 0.3664365376959934, 0.6267015027267492, 0.6738960394325593, 0.7195259227976928, 0.5229436353189959, 0.6478733484444119, 0.20448910597017356, 0.21550267142659152, 0.19378851403856756, 0.223524641780796, 0.19818995031717068, 0.20438076749326406, 0.21052655046616742, 0.22489998427745284, 0.23522872142922258, 0.2202580040768144, 0.21822510032622022, 0.755380818484019, 0.20353718477756844, 0.7775413229100072, 0.6685793396310641, 0.21513706174344338, 0.7692809504246166, 0.2242176294818785, 0.17432737443836233, 0.1658789047353877, 0.9042587264534685, 0.9210299751740147, 0.21166752844818337, 0.19744367634621673, 0.1594907733435692, 0.16699636891630765, 0.16146761101062201, 0.8917537891101174, 0.16549725666151738, 0.8907757724998369, 0.8815525283564628, 0.835255949784468, 0.1250197839561995, 0.20902916777917546, 0.21164891158252908, 0.21362314204285504, 0.20356990553955678, 0.18029676575583475, 0.1736486066691264, 0.18521458721757056, 0.20344386442018847, 0.18069846488868513, 0.1995535062916316, 0.19420605643990652, 0.1917872145018873, 0.09212751897506366, 0.09000463543405623, 0.10384947009441714, 0.08526811667245215, 0.08909121351100935, 0.07968916452275587, 0.08462758880255772, 0.08110247941386606, 0.08962659139966722]}, "mutation_prompt": null}
{"id": "1f46f5f5-c8a2-421b-b1fb-d0b66a2d5d8d", "solution": "import numpy as np\n\nclass DynamicQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # Further adjusted reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.25)))  # Altered elite size\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def quantum_mutation(self, a, b, c, d, e, F):\n        theta = np.random.rand(self.dim) * np.pi  # Quantum inspired angle\n        q = a + F * (b - c) + np.sin(theta) * (d - e)  # Quantum-inspired mutation\n        return np.clip(q, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = self.quantum_mutation(a, b, c, d, e, F)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "DynamicQuantumInspiredDE", "description": "Dynamic Quantum-Inspired Differential Evolution with adaptive quantum-inspired mutation and crossover for enhanced global search efficiency.", "configspace": "", "generation": 96, "fitness": 0.5247920249105351, "feedback": "The algorithm DynamicQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.30.", "error": "", "parent_id": "5d7e5f89-bbf4-484a-a22d-e84dfdfefb7b", "metadata": {"aucs": [0.893730675475045, 0.8850128214988059, 0.8929307210991855, 0.8932604561525864, 0.8911018130552076, 0.8954098214743509, 0.8887745021005244, 0.8896534128170698, 0.8946099196185167, 0.8217263694254894, 0.7991737362002777, 0.8105111445878981, 0.8108080887271585, 0.7980541848879171, 0.794847547667812, 0.8135641939424323, 0.8190265636907454, 0.7855700492699499, 0.5244791426930154, 0.16153572324696963, 0.15698017913570872, 0.15477235361352049, 0.15918375297419773, 0.15132368387560002, 0.16488475238516154, 0.1631017462544696, 0.1416532721331405, 0.12612819646953355, 0.147796136124015, 0.13775990317210451, 0.13598971622549338, 0.13334199513681033, 0.1170319861677035, 0.12298075025803079, 0.13951797299843238, 0.12406373680191862, 0.9599627779514788, 0.936493449624116, 0.9758285917595165, 0.9711784168537761, 0.9724750262382441, 0.9545459990501846, 0.9812196873934371, 0.9660081676540605, 0.9840689642053769, 0.7754370433917196, 0.7199093443094051, 0.7511745956470164, 0.7525785432568208, 0.7177833874964374, 0.7559250449663365, 0.7387857511114174, 0.7308978517309203, 0.7557949232421521, 0.8691021345398606, 0.8983943887330513, 0.8722038367783829, 0.8998106140282792, 0.909301922585797, 0.911202820980899, 0.8689381428286783, 0.8938671235666574, 0.855446546424373, 0.7533064490155504, 0.7863837928042188, 0.7830629490109232, 0.699885354804177, 0.7301637860230135, 0.13288788816109842, 0.6675575695194785, 0.7276152070110508, 0.5838665628365449, 0.8150796270120666, 0.6959799487566818, 0.6803938442826614, 0.6244309067147293, 0.7120513059694016, 0.7001104063275951, 0.6152866487445436, 0.576451305160658, 0.6611951866467733, 0.7377512731257176, 0.6983801809234456, 0.7290797265000268, 0.4758794376993295, 0.7392286753586247, 0.6800701433330808, 0.7265179831489634, 0.7225210414337284, 0.7289801010872221, 0.7529264929131528, 0.7582436041753216, 0.788591542374686, 0.7701374806002852, 0.7684339402056863, 0.7966575688977562, 0.8179306453747239, 0.7850713065824952, 0.7880060697627816, 0.3208375424921561, 0.12611670969532573, 0.531596257780256, 0.2876934694242439, 0.6612741955512478, 0.4864217212477008, 0.4471948087804192, 0.44385075818444697, 0.5591591415282091, 0.697384856422514, 0.6740772883975668, 0.6599264122219046, 0.7046925821962553, 0.6859361631722185, 0.6854290364019862, 0.6719928695532165, 0.6685890304460471, 0.6007728675651707, 0.8686779673203915, 0.8464965294913591, 0.8584394468164573, 0.8634498281223641, 0.8742197772029819, 0.8567215527568579, 0.8607782905309189, 0.8583776614032961, 0.855383455877663, 0.11281146148988797, 0.5515725975269048, 0.16171764420896506, 0.1254363876493011, 0.11385943928263098, 0.11853319829203679, 0.1234430744133852, 0.1174567802344273, 0.4381581594792836, 0.28541206032801725, 0.15261724774687302, 0.3447099638651986, 0.1746289018371674, 0.22028952096811216, 0.19628970442826343, 0.2934141961484925, 0.1439837749768551, 0.140492236258417, 0.6736781844602784, 0.5019596418434656, 0.6579578214049434, 0.47545388844249314, 0.5762239292184216, 0.6052462094113296, 0.7014296567102833, 0.675153710087657, 0.7100782378542557, 0.6436311177920798, 0.6393910825277924, 0.5039504779142262, 0.5405834670205598, 0.6462245155588582, 0.6111145647857313, 0.666865695429124, 0.5364693617278946, 0.5848911231241408, 0.21029924056359273, 0.2269274056622459, 0.2071921822354269, 0.2125776816440229, 0.22119479493263217, 0.1983814986672634, 0.20746317910190792, 0.21143759043014065, 0.20414246775789324, 0.711837886531344, 0.2013040452108824, 0.21735438984999733, 0.23067743170083066, 0.19387975278239344, 0.23834346043710697, 0.2208114657385427, 0.24712367645264, 0.7300652673754331, 0.185154351208756, 0.18563405826501322, 0.18500730343320315, 0.16122703545134587, 0.15982001967081616, 0.19322260906208466, 0.18408407432087914, 0.20517910479854695, 0.8543038371938324, 0.16789928557348288, 0.11239824445431001, 0.8912054073164672, 0.8879830893059757, 0.20509415942384024, 0.8833085880502074, 0.8681477603883305, 0.15529266763354754, 0.21288758004991382, 0.18681956837146407, 0.19631461560180763, 0.1884493570869452, 0.17119859658028602, 0.19357551689886798, 0.19602246014388758, 0.19636700381317806, 0.19601603785403265, 0.19318937495894983, 0.08428073856550022, 0.08114785925480283, 0.08637974587059305, 0.09668915732813788, 0.08297817389412299, 0.08059519320555697, 0.10406867216774773, 0.0937035991015508, 0.08905779226898958]}, "mutation_prompt": null}
{"id": "2318c6fb-fb3a-4b4f-a2d0-f5bf57a015ef", "solution": "import numpy as np\n\nclass AdaptiveEliteStochasticDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 12 * dim  # Increased initial population size\n        self.population_size = self.initial_population_size\n        self.memory_size = 6  # Increased memory size\n        self.cross_prob = 0.85  # Adjusted crossover probability\n        self.F = 0.6  # Adjusted differential weight\n        self.epsilon = 0.015  # Adjusted exploration factor\n        self.probability = 0.35  # Adjusted probability for exploration\n\n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.25))  # Moderated reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.1, 0.25)))  # Adjusted elite size range\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]  # Use a random elite\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveEliteStochasticDE", "description": "Adaptive Elite-Based Stochastic Differential Evolution utilizing multi-elite dynamic adjustment and enhanced exploration-exploitation balance for robust optimization.", "configspace": "", "generation": 97, "fitness": 0.4231365142420411, "feedback": "The algorithm AdaptiveEliteStochasticDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.42 with standard deviation 0.26.", "error": "", "parent_id": "5d7e5f89-bbf4-484a-a22d-e84dfdfefb7b", "metadata": {"aucs": [0.8103233625428323, 0.803094897026702, 0.8258113204294055, 0.7987476896261384, 0.8087411177608599, 0.8224381287515791, 0.8358406339499616, 0.8138069207068925, 0.8136083519911262, 0.6460751335839243, 0.6535089405918825, 0.6798117647736053, 0.6771073035154107, 0.6758704512040514, 0.6006061651075545, 0.6542854312858457, 0.631156033585774, 0.6744905528535572, 0.1195255056446991, 0.10563362040362212, 0.21357974801245805, 0.10272419100812635, 0.12444005316527074, 0.1167472663794622, 0.11529625033839952, 0.10857674913558435, 0.11249298336246993, 0.11851944896411548, 0.11062387363099702, 0.13667421656854872, 0.11388180489392141, 0.11959947229788526, 0.11555368314652881, 0.13824134159598722, 0.1101460437256988, 0.10589582563734656, 0.9737361304448638, 0.9604263207863083, 0.9453667506689741, 0.9310623617441128, 0.9882761966896157, 0.9709555084268588, 0.9594608739919979, 0.9757376411394046, 0.9673811008801059, 0.5762384493253818, 0.527357546914863, 0.472637042151806, 0.4738673876185491, 0.5796812861934293, 0.5337777320975696, 0.5747748171812128, 0.5839230808053035, 0.5775002701277303, 0.8181250614363814, 0.7955070464542717, 0.7531182874818946, 0.7899390298776877, 0.7691191287478222, 0.7979372551631712, 0.7639509416125826, 0.7888766690333089, 0.78168124782625, 0.5768110300014233, 0.5422221977049732, 0.5409262219450075, 0.38779386956187667, 0.5784257950541227, 0.47273898568130523, 0.5634523511612515, 0.5569997051311288, 0.5539831504067794, 0.5531821176121409, 0.579247908014392, 0.46629256372085515, 0.5441339774064526, 0.4918907040457855, 0.5104850498801898, 0.5742891765680964, 0.5334658058796113, 0.4453535708301105, 0.5019972350618982, 0.49431457951114666, 0.4354672908811069, 0.4396789305959551, 0.48394568463961374, 0.4898233316209939, 0.49097428955508127, 0.43993792977251267, 0.5344916630411627, 0.5780374064636659, 0.5963783795014577, 0.5901619829070665, 0.601994860799266, 0.5953265722261851, 0.5607550064360749, 0.6119370080635518, 0.6089102414182372, 0.548870008375473, 0.1451070323161211, 0.3034420605857726, 0.24729298399160948, 0.2851465449827576, 0.25284368024975146, 0.42031292723150326, 0.22454926052468827, 0.3229389761973247, 0.25348522799017215, 0.3926018444149658, 0.47535520717659296, 0.39884088836830156, 0.4234130327510548, 0.4114693431707992, 0.42808897999863105, 0.36765892535331923, 0.37603217206183714, 0.3797206115640611, 0.7627057132012267, 0.7572376370987904, 0.718199750516805, 0.7039137270543399, 0.7593177268401143, 0.7176697318937715, 0.7144789767052024, 0.7455074474278331, 0.7315648494096711, 0.10006515620092082, 0.09891042658172666, 0.09699126849295059, 0.09485424245883356, 0.09087603292703139, 0.09651877929813635, 0.09960612889857312, 0.10990074259647387, 0.12460053122451087, 0.12912602280333563, 0.18981601721432506, 0.1547286391741567, 0.2750510058296335, 0.12451423155595132, 0.1467208044136531, 0.19038552605010806, 0.16749916041229862, 0.2310601532628852, 0.4374139515931674, 0.37935502671118504, 0.4371203705272715, 0.4153174900443458, 0.41054854580232936, 0.42899231025201856, 0.46704959322187156, 0.4578184497873209, 0.47792661577911566, 0.3223278022195494, 0.3322796648805646, 0.3407273032784227, 0.350812842807544, 0.3477837955846682, 0.35317196424897457, 0.3323238327566257, 0.33695751118712514, 0.35876403070073837, 0.175688477583808, 0.21437838716354451, 0.18417303190431533, 0.20871781373340903, 0.21073277199606943, 0.20690990191592495, 0.20318523649652187, 0.21439703605303706, 0.20817940992946804, 0.26615013655979736, 0.4802580298080319, 0.21698346117844214, 0.2657844030224661, 0.29592631123708946, 0.31418250520827395, 0.1953065266418702, 0.21992192524915088, 0.1918802241060097, 0.15261346847732982, 0.8134786001318797, 0.8442016945429761, 0.1946688704917212, 0.8188846662096727, 0.7342195605060173, 0.179675350789951, 0.6992337720027307, 0.7758780714981179, 0.20248981409256828, 0.7394096141527227, 0.16799244874175367, 0.16157838612715658, 0.2024421525161495, 0.20620077728668107, 0.12756416745327492, 0.12705835069246063, 0.21013695047154302, 0.20412864549987686, 0.18346292432841815, 0.1809680543068236, 0.18135169702884824, 0.18479895222536835, 0.1911318406534227, 0.18426820850524372, 0.19524045322208572, 0.1745995042181535, 0.07514188589737136, 0.0878803433822608, 0.08099381045377285, 0.09060446449111592, 0.08145629630283091, 0.0845344092005722, 0.07645584998151611, 0.08259908636651125, 0.08198909089373196]}, "mutation_prompt": null}
{"id": "959ab304-d71f-4182-883f-8579570defed", "solution": "import numpy as np\n\nclass AdaptiveCovarianceDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n        self.cov_matrix = np.eye(self.dim)  # Initialize covariance matrix\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.3))\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.2)))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def update_covariance_matrix(self, successful_individuals):\n        if len(successful_individuals) > 0:\n            diff = successful_individuals - np.mean(successful_individuals, axis=0)\n            self.cov_matrix = np.cov(diff, rowvar=False)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        successful_individuals = []\n\n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n\n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.multivariate_normal(np.zeros(self.dim), self.cov_matrix)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, mutant, self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    successful_individuals.append(trial)\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n            \n            self.update_covariance_matrix(np.array(successful_individuals))\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "AdaptiveCovarianceDE", "description": "Adaptive Covariance Differential Evolution integrates covariance matrix adaptation with differential evolution to enhance search efficiency and adaptability.", "configspace": "", "generation": 98, "fitness": 0.5169594305747358, "feedback": "The algorithm AdaptiveCovarianceDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.52 with standard deviation 0.30.", "error": "", "parent_id": "5d7e5f89-bbf4-484a-a22d-e84dfdfefb7b", "metadata": {"aucs": [0.8799935877648832, 0.8820724269104995, 0.8847491178936561, 0.8855766995769931, 0.9087261989272377, 0.9002208627225026, 0.8928226155191985, 0.8944118411284349, 0.8945647702709524, 0.8061929190008053, 0.7580854277520431, 0.7717245481428512, 0.8091424036007884, 0.8202354504028848, 0.8097008387512418, 0.7913298238138817, 0.8006992235087629, 0.7939152244727965, 0.09313544175158472, 0.585476062587801, 0.1549145980079174, 0.12578012451904774, 0.14991365251780675, 0.1432774189530004, 0.6331682450389282, 0.3959344476464157, 0.1407755124889949, 0.15118131923267497, 0.1589014879141205, 0.12942234914141082, 0.1330236098607005, 0.1374938463272496, 0.12214459765296093, 0.12081230679372879, 0.1702643068713573, 0.12884923002494975, 0.9618517381875642, 0.9709942247256076, 0.9659061015949799, 0.9581592373242618, 0.9741059555329422, 0.9620312586787452, 0.954994459453534, 0.9746216257787367, 0.9634326436674367, 0.7185744470568356, 0.7176900119272647, 0.7336099281616317, 0.7404697549560757, 0.7722565462913711, 0.7659885890380533, 0.7349646332340151, 0.7348847305558354, 0.7481779571905522, 0.9149126497262204, 0.8786345756834419, 0.8897248760842424, 0.9029774160986394, 0.8883999654252521, 0.8952931512935098, 0.88456559812445, 0.9146919537675651, 0.8988310501911582, 0.7082767923971567, 0.6008285924931487, 0.7190331034740325, 0.6967514799831945, 0.651118453828295, 0.7548749334086652, 0.7371868323629056, 0.5913200724216702, 0.6280930160240725, 0.5872978076332604, 0.6400907463978607, 0.5068825095356628, 0.4407689560009367, 0.6482361597523429, 0.7617697031238354, 0.13270127058106862, 0.13364064347307358, 0.7440350599592647, 0.7898842416411502, 0.3533278919262789, 0.7450281773275859, 0.7825872787132931, 0.6448869530122412, 0.7751619059632238, 0.7551696906656782, 0.7750511331569687, 0.7590622262486989, 0.7956935501571132, 0.804023870598011, 0.8014648482372849, 0.7830655989691193, 0.7564106904988044, 0.7681057897873222, 0.7987280547948589, 0.7180021375585567, 0.7964681174615763, 0.5262540157136089, 0.5385192354335879, 0.416999930032226, 0.6103649407383904, 0.6733734126915675, 0.6740374191050916, 0.34009163246790863, 0.34251779955045547, 0.15571705065321328, 0.6823184941727354, 0.6494340345090808, 0.6218300359294991, 0.6986299105545221, 0.7146817310449949, 0.7071687801628191, 0.6577842991488263, 0.6487023785856295, 0.6819800727551955, 0.871591671806696, 0.8712030840833229, 0.867492368583541, 0.8738825307001373, 0.8710040123071419, 0.8572187061150107, 0.8472952063620925, 0.8420183126755539, 0.8763980494184141, 0.43584816666394577, 0.1467116663790632, 0.1272580886100424, 0.13518639404570587, 0.16614335450406748, 0.1651549745768197, 0.12434082208032304, 0.13095458856438924, 0.15252890675555042, 0.5617163480976826, 0.3097834931769139, 0.2244197089888036, 0.1554578032617917, 0.34544517991881785, 0.16643372298577486, 0.6079272549777202, 0.3079755597062719, 0.4923204000365149, 0.7154076995962675, 0.7357193353340604, 0.6433955449354367, 0.6936151781627202, 0.4813139102688905, 0.6828268013471304, 0.5287685000939848, 0.6943383358374163, 0.6706319255614244, 0.261844823950969, 0.5498464776799041, 0.48993248425862335, 0.44884680069084726, 0.5657968329934897, 0.3696432910889289, 0.475084434517976, 0.35874054253170884, 0.2597114035893453, 0.2158718531581304, 0.2088115693239121, 0.18985892477531519, 0.19597877013147258, 0.22011311049929705, 0.18677642390853522, 0.20436996885546588, 0.20102402620338722, 0.19170269171680543, 0.23544510099578397, 0.7125464882808077, 0.22557522864138146, 0.20069145558790202, 0.19704446989162716, 0.2379489704520661, 0.22816668094447523, 0.20828707456496354, 0.24333232571331387, 0.1857146361277785, 0.1952377570202457, 0.9134586516475458, 0.1970178875249453, 0.16991719230051572, 0.19809284786864167, 0.16163560601636762, 0.14614301415322695, 0.8768351006288825, 0.2066821400938037, 0.1131588077208977, 0.8711121589508938, 0.1656913594151198, 0.20666982014454638, 0.11155356861498644, 0.21342683250687078, 0.879434241095563, 0.21301993953964238, 0.1891117976437261, 0.19344756983584632, 0.1930049969863381, 0.17441702692010308, 0.1902824188511515, 0.19160618885789704, 0.17979382208512384, 0.18198997271089912, 0.18586170574653738, 0.08756202662927792, 0.0818571221860882, 0.08965900897631907, 0.0966865681996314, 0.07319421436986917, 0.08795779428802963, 0.10326240176512913, 0.08651310947207125, 0.08469678572399808]}, "mutation_prompt": null}
{"id": "d5eef8d3-4aef-4ad4-8e70-0a9f3fcb5478", "solution": "import numpy as np\n\nclass HybridQuantumInspiredDE:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.initial_population_size = 10 * dim\n        self.population_size = self.initial_population_size\n        self.memory_size = 5\n        self.cross_prob = 0.9\n        self.F = 0.5\n        self.epsilon = 0.01\n        self.probability = 0.3\n        \n        self.population = np.random.uniform(self.lower_bound, self.upper_bound, (self.population_size, self.dim))\n        self.fitness = np.full(self.population_size, np.inf)\n        self.memory = {\n            \"F\": np.full(self.memory_size, self.F),\n            \"CR\": np.full(self.memory_size, self.cross_prob)\n        }\n        self.memory_index = 0\n\n    def update_memory(self, F, CR):\n        self.memory[\"F\"][self.memory_index] = F\n        self.memory[\"CR\"][self.memory_index] = CR\n        self.memory_index = (self.memory_index + 1) % self.memory_size\n\n    def dynamic_population_adjustment(self, eval_count):\n        fraction = eval_count / self.budget\n        self.population_size = int(self.initial_population_size * (1 - fraction * 0.4))  # Adjusted reduction rate\n\n    def multi_elite_selection(self):\n        elite_size = max(1, int(self.population_size * np.random.uniform(0.05, 0.2)))\n        elite_indices = np.argsort(self.fitness)[:elite_size]\n        return self.population[elite_indices]\n\n    def quantum_rotation(self, vector):\n        theta = np.random.uniform(-np.pi/4, np.pi/4, self.dim)\n        quantum_rotated = vector * np.cos(theta) + np.sin(theta)\n        return np.clip(quantum_rotated, self.lower_bound, self.upper_bound)\n\n    def __call__(self, func):\n        eval_count = 0\n        best_fitness = np.inf\n        \n        while eval_count < self.budget:\n            self.dynamic_population_adjustment(eval_count)\n            elites = self.multi_elite_selection()\n            for i in range(self.population_size):\n                indices = np.random.choice(self.population_size, 5, replace=False)\n                a, b, c, d, e = self.population[indices]\n                \n                if np.random.rand() < self.probability:\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c + np.random.rand() * (d - e)), self.lower_bound, self.upper_bound)\n                else:\n                    local_best = np.argmin(self.fitness[indices])\n                    a = elites[np.random.randint(len(elites))]\n                    F = np.random.choice(self.memory[\"F\"]) + np.random.rand() * self.epsilon\n                    mutant = np.clip(a + F * (b - c), self.lower_bound, self.upper_bound)\n                \n                CR = np.random.choice(self.memory[\"CR\"]) + np.random.rand() * self.epsilon\n                cross_points = np.random.rand(self.dim) < CR\n                if not np.any(cross_points):\n                    cross_points[np.random.randint(0, self.dim)] = True\n                trial = np.where(cross_points, self.quantum_rotation(mutant), self.population[i])\n\n                trial_fitness = func(trial)\n                eval_count += 1\n\n                if eval_count >= self.budget:\n                    break\n\n                if trial_fitness < self.fitness[i]:\n                    self.population[i] = trial\n                    self.fitness[i] = trial_fitness\n                    if trial_fitness < best_fitness:\n                        best_fitness = trial_fitness\n                        self.update_memory(F, CR)\n        \n        best_idx = np.argmin(self.fitness)\n        return self.population[best_idx], self.fitness[best_idx]", "name": "HybridQuantumInspiredDE", "description": "Hybrid Quantum-Inspired Differential Evolution leveraging quantum rotation gates and updating population dynamics for enhanced exploration and exploitation.", "configspace": "", "generation": 99, "fitness": 0.17886665057242973, "feedback": "The algorithm HybridQuantumInspiredDE got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.18 with standard deviation 0.12.", "error": "", "parent_id": "5d7e5f89-bbf4-484a-a22d-e84dfdfefb7b", "metadata": {"aucs": [0.34947765948944376, 0.3763286222000023, 0.34600645355630777, 0.3592390024601734, 0.3831524310283817, 0.35781610521428486, 0.3609968763523784, 0.35617720684691034, 0.3507137500386279, 0.015953976974436013, 0.01847571190862074, 0.011513053820323527, 0.007962380554938142, 0.015679553475782426, 0.022090011459477643, 0.004187455587929434, 0.020229290936989996, 0.021007948041139923, 0.11194937284106621, 0.09787583766000973, 0.10015166691814958, 0.11084815294634776, 0.0955730162571301, 0.0992324965527841, 0.09572082782840374, 0.10296310916002238, 0.09289789419615313, 0.09697863551010066, 0.09135263258268311, 0.09548008506740047, 0.10283285521287833, 0.09360583358830066, 0.09502993863859233, 0.09894281295749185, 0.09276292997782765, 0.08959566689937037, 0.23630737436650073, 0.3609589520755361, 0.5737599914768794, 0.5041115841271399, 0.2733552399617236, 0.4673452966901035, 0.23075260796353403, 0.5781887059066734, 0.5704530402922503, 0.22587403191332156, 0.2242633550157892, 0.2256145427633638, 0.22125172653553937, 0.21542363111650042, 0.22116945746922345, 0.2395002070990948, 0.21301484135119808, 0.23027633267378178, 0.24445048068227893, 0.28363410544160117, 0.2698673986004102, 0.2792039286067999, 0.2873896624231329, 0.27097351045374096, 0.2442629803914811, 0.31083328618916384, 0.26567659999346427, 0.12930631933450853, 0.13553709503736266, 0.13904537660411675, 0.14202785095747694, 0.1316127569600083, 0.15472483740082243, 0.1436633589419194, 0.13179617515450592, 0.1371062932370558, 0.14766174097524132, 0.12480997768631119, 0.1355581399843624, 0.11682324518155907, 0.13688319472099997, 0.12818129237838727, 0.13034943337377225, 0.12786321114095967, 0.12442430285565753, 0.02322956329018977, 9.999999999998899e-05, 0.0011478988084528963, 0.004895087487388983, 0.005519450263643755, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09962990646198044, 0.09211184162317898, 0.11638847862179613, 0.10248695460899981, 0.10206987956820268, 0.08098447990548752, 0.0946159372859593, 0.1003581489002412, 0.17637957162281181, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06354403066772718, 0.07170997376621124, 0.068556660365375, 0.08708117738802923, 0.08396910606421859, 0.07765713779315397, 0.09056368715787688, 0.06398850766732866, 0.07883950712188303, 0.34920410660784473, 0.33718016968274667, 0.34432188888198967, 0.3514594575409751, 0.36289260519162614, 0.35514481294041766, 0.34236057988169577, 0.33513069220680514, 0.35328017984094107, 0.08298295683415469, 0.10752545199088803, 0.09113287799983194, 0.08535129988351708, 0.08712267856588973, 0.09489236478054841, 0.12291825735218243, 0.09948700037252223, 0.09856010447789854, 0.14656538194539226, 0.16177049676659294, 0.1397598981694329, 0.17028153230509868, 0.15489777236010827, 0.16540056327227648, 0.17978500565195732, 0.1441397435608731, 0.14506527514374812, 0.2521693996619815, 0.24833619736677914, 0.2559589181651363, 0.23937770854818896, 0.25992547750576045, 0.25713352497423525, 0.2534614043773159, 0.25295644942649687, 0.2565593204293981, 0.2169247348845471, 0.19376505360342622, 0.2035289657059186, 0.1825394381109594, 0.18759381283259047, 0.19116972560894474, 0.20638709910911035, 0.20078678752199852, 0.201053718829181, 0.22248409210010833, 0.20619506281873956, 0.21412855640198036, 0.21929591657366476, 0.20958321342479824, 0.2276235220805607, 0.20435704915104658, 0.23386414413260959, 0.22964864173024746, 0.19787023534387826, 0.17778291010293323, 0.17658943241255987, 0.17247272941808534, 0.19881863478207085, 0.1799636979688124, 0.18106608999990514, 0.18040346339121693, 0.19018864144883596, 0.1827309695319589, 0.15280668989822765, 0.4569129078742249, 0.5106724563076788, 0.4630350315068328, 0.19685178809668757, 0.5123991022078276, 0.1570709993987035, 0.19046408447776098, 0.4047404983664148, 0.44782446619127814, 0.432028145207179, 0.16889796740023144, 0.4588956901253992, 0.1657465447705323, 0.3583029040607809, 0.1265572114691793, 0.21173737987006713, 0.18515624600355773, 0.17629155867670598, 0.18073655860829474, 0.18213327189722273, 0.18129895628779868, 0.17863037541325832, 0.18073034175796787, 0.20695998520861825, 0.189448806532873, 0.08163302447186183, 0.09960375872026739, 0.08265565785963658, 0.07577730073356748, 0.09127888290279829, 0.07397322939852691, 0.10252178358633124, 0.08700209901929556, 0.07789721096704705]}, "mutation_prompt": null}
