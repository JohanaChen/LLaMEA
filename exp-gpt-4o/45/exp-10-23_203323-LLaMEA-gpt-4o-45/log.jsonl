{"id": "18f17982-0d25-40f5-b284-9cebb93e2ca7", "solution": "import numpy as np\n\nclass AdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 2.0\n        self.c2 = 2.0\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            for i in range(self.num_particles):\n                cognitive_component = self.c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = self.c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# pso = AdaptivePSO(budget=10000, dim=10)\n# pso(func)", "name": "AdaptivePSO", "description": "A novel Particle Swarm Optimization variant with adaptive inertia and cognitive-social balance for enhanced exploration-exploitation trade-off.", "configspace": "", "generation": 0, "fitness": 0.2266774922224398, "feedback": "The algorithm AdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": null, "metadata": {"aucs": [0.6239882808738804, 0.6239882808738804, 0.6239882808738804, 0.6321117045986349, 0.6321117045986349, 0.6321117045986349, 0.6193630943065076, 0.6193630943065076, 0.6193630943065076, 0.35747324966205096, 0.35747324966205096, 0.35747324966205096, 0.29551085214198325, 0.29551085214198325, 0.29551085214198325, 0.29153081102423306, 0.29153081102423306, 0.29153081102423306, 0.08892503466435009, 0.08892503466435009, 0.08892503466435009, 0.12512368120271455, 0.12512368120271455, 0.12512368120271455, 0.11284855784676273, 0.11284855784676273, 0.11284855784676273, 0.1119380302528531, 0.1119380302528531, 0.1119380302528531, 0.08057852686615663, 0.08057852686615663, 0.08057852686615663, 0.10916407077898582, 0.10916407077898582, 0.10916407077898582, 0.9932781103676772, 0.9932781103676772, 0.9932781103676772, 0.9881449181034305, 0.9881449181034305, 0.9881449181034305, 0.9894625331726629, 0.9894625331726629, 0.9894625331726629, 0.11113984330838544, 0.11113984330838544, 0.11113984330838544, 0.3452563555794731, 0.3452563555794731, 0.3452563555794731, 0.12123346221861808, 0.12123346221861808, 0.12123346221861808, 0.17135583899603102, 0.17135583899603102, 0.17135583899603102, 0.2508686244557503, 0.2508686244557503, 0.2508686244557503, 0.09367371783107048, 0.09367371783107048, 0.09367371783107048, 0.13600981288592595, 0.13600981288592595, 0.13600981288592595, 0.07797996472380586, 0.07797996472380586, 0.07797996472380586, 0.1309772182831399, 0.1309772182831399, 0.1309772182831399, 0.14984286177440642, 0.14984286177440642, 0.14984286177440642, 0.114557796060484, 0.114557796060484, 0.114557796060484, 0.08341284352679812, 0.08341284352679812, 0.08341284352679812, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.03591964852916041, 0.03591964852916041, 0.03591964852916041, 0.0024110762727849178, 0.0024110762727849178, 0.0024110762727849178, 0.04518146253211541, 0.04518146253211541, 0.04518146253211541, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04397685461550105, 0.04397685461550105, 0.04397685461550105, 0.09732065886312102, 0.09732065886312102, 0.09732065886312102, 0.15938736510463514, 0.15938736510463514, 0.15938736510463514, 0.08017661192851389, 0.08017661192851389, 0.08017661192851389, 0.0647619725867633, 0.0647619725867633, 0.0647619725867633, 0.40331374385308305, 0.40331374385308305, 0.40331374385308305, 0.4437466417768745, 0.4437466417768745, 0.4437466417768745, 0.43507233167562753, 0.43507233167562753, 0.43507233167562753, 0.09602723395502688, 0.09602723395502688, 0.09602723395502688, 0.09523226229147186, 0.09523226229147186, 0.09523226229147186, 0.07947685672023652, 0.07947685672023652, 0.07947685672023652, 0.2819682045062839, 0.2819682045062839, 0.2819682045062839, 0.2177891895382782, 0.2177891895382782, 0.2177891895382782, 0.2049626633254129, 0.2049626633254129, 0.2049626633254129, 0.24183100902238808, 0.24183100902238808, 0.24183100902238808, 0.278168392256973, 0.278168392256973, 0.278168392256973, 0.37506767510703054, 0.37506767510703054, 0.37506767510703054, 0.13236623127547442, 0.13236623127547442, 0.13236623127547442, 0.17544839252370714, 0.17544839252370714, 0.17544839252370714, 0.22260689019154356, 0.22260689019154356, 0.22260689019154356, 0.1965193774219881, 0.1965193774219881, 0.1965193774219881, 0.1770355414546182, 0.1770355414546182, 0.1770355414546182, 0.20486918078322502, 0.20486918078322502, 0.20486918078322502, 0.20213295685149135, 0.20213295685149135, 0.20213295685149135, 0.20132543789676716, 0.20132543789676716, 0.20132543789676716, 0.18504347198234616, 0.18504347198234616, 0.18504347198234616, 0.16160801465187613, 0.16160801465187613, 0.16160801465187613, 0.6876360562432156, 0.6876360562432156, 0.6876360562432156, 0.18601239456899166, 0.18601239456899166, 0.18601239456899166, 0.4847033865920737, 0.4847033865920737, 0.4847033865920737, 0.20510669663053893, 0.20510669663053893, 0.20510669663053893, 0.186136869650378, 0.186136869650378, 0.186136869650378, 0.1822322700573369, 0.1822322700573369, 0.1822322700573369, 0.21415618406548487, 0.21415618406548487, 0.21415618406548487, 0.2052039741426831, 0.2052039741426831, 0.2052039741426831, 0.07142443882509775, 0.07142443882509775, 0.07142443882509775, 0.07297478872126739, 0.07297478872126739, 0.07297478872126739, 0.07829523551750495, 0.07829523551750495, 0.07829523551750495]}, "mutation_prompt": null}
{"id": "842ec4d9-3c1f-4cf6-9e3d-ed7c30079f61", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 1.5  # Adjusted cognitive coefficient\n        self.c2 = 2.5  # Adjusted social coefficient\n        self.neighborhood_size = 5  # Neighborhood size for local best\n        self.alpha = 0.5  # Learning rate adaptation factor\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        local_best_positions = personal_best_positions.copy()\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    \n                if score < global_best_score:\n                    global_best_score = score\n                    global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                # Determine local best in neighborhood\n                start_idx = max(0, i - self.neighborhood_size // 2)\n                end_idx = min(self.num_particles, i + self.neighborhood_size // 2)\n                local_best_score = float('inf')\n                for j in range(start_idx, end_idx):\n                    if personal_best_scores[j] < local_best_score:\n                        local_best_score = personal_best_scores[j]\n                        local_best_positions[i] = personal_best_positions[j].copy()\n                \n                # Dynamic learning rate adjustment\n                dynamic_c1 = self.c1 * (1 + self.alpha * np.random.uniform(-0.5, 0.5))\n                dynamic_c2 = self.c2 * (1 + self.alpha * np.random.uniform(-0.5, 0.5))\n\n                cognitive_component = dynamic_c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = dynamic_c2 * np.random.uniform(0, 1, self.dim) * (local_best_positions[i] - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# pso(func)", "name": "EnhancedAdaptivePSO", "description": "A novel Particle Swarm Optimization variant with adaptive inertia, dynamic learning rates, and neighborhood-based exploration for enhanced convergence.", "configspace": "", "generation": 1, "fitness": 0.19758222835156888, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "18f17982-0d25-40f5-b284-9cebb93e2ca7", "metadata": {"aucs": [0.4963620713284055, 0.4963620713284055, 0.4963620713284055, 0.47213719906737084, 0.47213719906737084, 0.47213719906737084, 0.4075006596554034, 0.4075006596554034, 0.4075006596554034, 0.1606844310377875, 0.1606844310377875, 0.1606844310377875, 0.1634198567000853, 0.1634198567000853, 0.1634198567000853, 0.17965041946550775, 0.17965041946550775, 0.17965041946550775, 0.11648802089921118, 0.11648802089921118, 0.11648802089921118, 0.06813073591495578, 0.06813073591495578, 0.06813073591495578, 0.11425872694294181, 0.11425872694294181, 0.11425872694294181, 0.09115772337268813, 0.09115772337268813, 0.09115772337268813, 0.11218156043869754, 0.11218156043869754, 0.11218156043869754, 0.11256836702764117, 0.11256836702764117, 0.11256836702764117, 0.9906117151043037, 0.9906117151043037, 0.9906117151043037, 0.9819238264447768, 0.9819238264447768, 0.9819238264447768, 0.9877179531458598, 0.9877179531458598, 0.9877179531458598, 0.07542481913489663, 0.07542481913489663, 0.07542481913489663, 0.23625280487810207, 0.23625280487810207, 0.23625280487810207, 0.08548914565921473, 0.08548914565921473, 0.08548914565921473, 0.22212095165455548, 0.22212095165455548, 0.22212095165455548, 0.20949830476116793, 0.20949830476116793, 0.20949830476116793, 0.15384683242957986, 0.15384683242957986, 0.15384683242957986, 0.1558345048611376, 0.1558345048611376, 0.1558345048611376, 0.0764644580226943, 0.0764644580226943, 0.0764644580226943, 0.09943128323155093, 0.09943128323155093, 0.09943128323155093, 0.16410262442422752, 0.16410262442422752, 0.16410262442422752, 0.1061459021400567, 0.1061459021400567, 0.1061459021400567, 0.09078858434425652, 0.09078858434425652, 0.09078858434425652, 0.00348013550722992, 0.00348013550722992, 0.00348013550722992, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04875514740737308, 0.04875514740737308, 0.04875514740737308, 0.07460880915724433, 0.07460880915724433, 0.07460880915724433, 0.07864104010312167, 0.07864104010312167, 0.07864104010312167, 0.02300325025707406, 0.02300325025707406, 0.02300325025707406, 0.020561597402495635, 0.020561597402495635, 0.020561597402495635, 0.03564940634618674, 0.03564940634618674, 0.03564940634618674, 0.04373761293002354, 0.04373761293002354, 0.04373761293002354, 0.003137439535644826, 0.003137439535644826, 0.003137439535644826, 0.0360933642471889, 0.0360933642471889, 0.0360933642471889, 0.30776079796824674, 0.30776079796824674, 0.30776079796824674, 0.3864570854093451, 0.3864570854093451, 0.3864570854093451, 0.35129632471751304, 0.35129632471751304, 0.35129632471751304, 0.07787732470150222, 0.07787732470150222, 0.07787732470150222, 0.08025806066572327, 0.08025806066572327, 0.08025806066572327, 0.07857222358128146, 0.07857222358128146, 0.07857222358128146, 0.21415224418083045, 0.21415224418083045, 0.21415224418083045, 0.1642612179648728, 0.1642612179648728, 0.1642612179648728, 0.24671631502823177, 0.24671631502823177, 0.24671631502823177, 0.22540024144244641, 0.22540024144244641, 0.22540024144244641, 0.24856371076711625, 0.24856371076711625, 0.24856371076711625, 0.24006013768572454, 0.24006013768572454, 0.24006013768572454, 0.17127990658146497, 0.17127990658146497, 0.17127990658146497, 0.16079222269138005, 0.16079222269138005, 0.16079222269138005, 0.17497859610537247, 0.17497859610537247, 0.17497859610537247, 0.16611338131108733, 0.16611338131108733, 0.16611338131108733, 0.18808365583621134, 0.18808365583621134, 0.18808365583621134, 0.17643508206055103, 0.17643508206055103, 0.17643508206055103, 0.19989186837583284, 0.19989186837583284, 0.19989186837583284, 0.1879405832928165, 0.1879405832928165, 0.1879405832928165, 0.18653631807529114, 0.18653631807529114, 0.18653631807529114, 0.2416421960849353, 0.2416421960849353, 0.2416421960849353, 0.5449085191865232, 0.5449085191865232, 0.5449085191865232, 0.1581238732600455, 0.1581238732600455, 0.1581238732600455, 0.3305639990476039, 0.3305639990476039, 0.3305639990476039, 0.22785416575623563, 0.22785416575623563, 0.22785416575623563, 0.19306373774374375, 0.19306373774374375, 0.19306373774374375, 0.1935859075182259, 0.1935859075182259, 0.1935859075182259, 0.18720904407975603, 0.18720904407975603, 0.18720904407975603, 0.1894742827964866, 0.1894742827964866, 0.1894742827964866, 0.07456152287151108, 0.07456152287151108, 0.07456152287151108, 0.07556853630340032, 0.07556853630340032, 0.07556853630340032, 0.07787607324099277, 0.07787607324099277, 0.07787607324099277]}, "mutation_prompt": null}
{"id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "An enhanced Particle Swarm Optimization with dynamic social-cognitive balance and adaptive neighborhood influence for robust convergence.", "configspace": "", "generation": 2, "fitness": 0.2342392769247185, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "18f17982-0d25-40f5-b284-9cebb93e2ca7", "metadata": {"aucs": [0.5721523072189221, 0.5721523072189221, 0.5721523072189221, 0.6238490366521984, 0.6238490366521984, 0.6238490366521984, 0.629679018324389, 0.629679018324389, 0.629679018324389, 0.033500162994882676, 0.033500162994882676, 0.033500162994882676, 0.33101104578903273, 0.33101104578903273, 0.33101104578903273, 0.039954132596335734, 0.039954132596335734, 0.039954132596335734, 0.13197469477353319, 0.13197469477353319, 0.13197469477353319, 0.1197591024834288, 0.1197591024834288, 0.1197591024834288, 0.18124602679005286, 0.18124602679005286, 0.18124602679005286, 0.10809857444804638, 0.10809857444804638, 0.10809857444804638, 0.11225710938209266, 0.11225710938209266, 0.11225710938209266, 0.2830967441414156, 0.2830967441414156, 0.2830967441414156, 0.9904632150838426, 0.9904632150838426, 0.9904632150838426, 0.9898754106081937, 0.9898754106081937, 0.9898754106081937, 0.9889075185521351, 0.9889075185521351, 0.9889075185521351, 0.2846414183687983, 0.2846414183687983, 0.2846414183687983, 0.14390344939564925, 0.14390344939564925, 0.14390344939564925, 0.08310366196826158, 0.08310366196826158, 0.08310366196826158, 0.172215868569481, 0.172215868569481, 0.172215868569481, 0.2586166915143331, 0.2586166915143331, 0.2586166915143331, 0.17999520537148805, 0.17999520537148805, 0.17999520537148805, 0.1326172022599893, 0.1326172022599893, 0.1326172022599893, 0.08920211015432711, 0.08920211015432711, 0.08920211015432711, 0.12277723021848741, 0.12277723021848741, 0.12277723021848741, 0.10410751778378147, 0.10410751778378147, 0.10410751778378147, 0.10103510621941858, 0.10103510621941858, 0.10103510621941858, 0.14806726932172953, 0.14806726932172953, 0.14806726932172953, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00353472492140805, 0.00353472492140805, 0.00353472492140805, 0.09131113929537038, 0.09131113929537038, 0.09131113929537038, 0.06531573515534872, 0.06531573515534872, 0.06531573515534872, 0.06063814371686227, 0.06063814371686227, 0.06063814371686227, 0.08391622265324217, 0.08391622265324217, 0.08391622265324217, 0.04268409054459099, 0.04268409054459099, 0.04268409054459099, 0.06990330642340437, 0.06990330642340437, 0.06990330642340437, 0.06378921934287829, 0.06378921934287829, 0.06378921934287829, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046023947573463175, 0.046023947573463175, 0.046023947573463175, 0.4342182063373401, 0.4342182063373401, 0.4342182063373401, 0.47012509965345217, 0.47012509965345217, 0.47012509965345217, 0.4284495044783311, 0.4284495044783311, 0.4284495044783311, 0.10207113920088051, 0.10207113920088051, 0.10207113920088051, 0.08990954583804323, 0.08990954583804323, 0.08990954583804323, 0.09263826125250141, 0.09263826125250141, 0.09263826125250141, 0.15105832281179632, 0.15105832281179632, 0.15105832281179632, 0.22953167016013531, 0.22953167016013531, 0.22953167016013531, 0.20268008372972446, 0.20268008372972446, 0.20268008372972446, 0.30529499397107007, 0.30529499397107007, 0.30529499397107007, 0.27173863536578424, 0.27173863536578424, 0.27173863536578424, 0.2616078574929944, 0.2616078574929944, 0.2616078574929944, 0.19665735368307125, 0.19665735368307125, 0.19665735368307125, 0.24753726347448923, 0.24753726347448923, 0.24753726347448923, 0.2511475784518672, 0.2511475784518672, 0.2511475784518672, 0.21590587472634515, 0.21590587472634515, 0.21590587472634515, 0.18717837638977208, 0.18717837638977208, 0.18717837638977208, 0.18838106388029707, 0.18838106388029707, 0.18838106388029707, 0.3824038702017436, 0.3824038702017436, 0.3824038702017436, 0.24279238649420265, 0.24279238649420265, 0.24279238649420265, 0.19912811589633694, 0.19912811589633694, 0.19912811589633694, 0.19431273749029898, 0.19431273749029898, 0.19431273749029898, 0.6965327252241778, 0.6965327252241778, 0.6965327252241778, 0.5371867206960035, 0.5371867206960035, 0.5371867206960035, 0.5760502943838572, 0.5760502943838572, 0.5760502943838572, 0.20133954468361015, 0.20133954468361015, 0.20133954468361015, 0.20130934839573078, 0.20130934839573078, 0.20130934839573078, 0.2059158062863422, 0.2059158062863422, 0.2059158062863422, 0.19181791681541982, 0.19181791681541982, 0.19181791681541982, 0.18628486958279922, 0.18628486958279922, 0.18628486958279922, 0.07465673538014361, 0.07465673538014361, 0.07465673538014361, 0.08106257795384697, 0.08106257795384697, 0.08106257795384697, 0.0847800975865084, 0.0847800975865084, 0.0847800975865084]}, "mutation_prompt": null}
{"id": "922642d7-16b9-4fbe-8952-adcb2b2843b2", "solution": "import numpy as np\n\nclass EnhancedDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.3  # Modified for improved exploration\n        self.c1_initial = 2.8  # Adjusted for stronger cognitive influence initially\n        self.c2_initial = 1.2  # Adjusted for reduced social influence initially\n        self.c1_final = 1.2  # Adjusted for reduced cognitive influence towards final\n        self.c2_final = 2.8  # Adjusted for stronger social influence towards final\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget) ** 1.2)  # Non-linear decay\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * (evaluations / self.budget))\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * (evaluations / self.budget))\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_dynamic_pso = EnhancedDynamicPSO(budget=10000, dim=10)\n# enhanced_dynamic_pso(func)", "name": "EnhancedDynamicPSO", "description": "A dynamically adaptable PSO with a focus on enhanced exploration and exploitative phase modulation for superior convergence.", "configspace": "", "generation": 3, "fitness": 0.22830389486035496, "feedback": "The algorithm EnhancedDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.22.", "error": "", "parent_id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "metadata": {"aucs": [0.5716327980346954, 0.5716327980346954, 0.5716327980346954, 0.18272683780286048, 0.18272683780286048, 0.18272683780286048, 0.6310467244645848, 0.6310467244645848, 0.6310467244645848, 0.3541480525759273, 0.3541480525759273, 0.3541480525759273, 0.030374336456032158, 0.030374336456032158, 0.030374336456032158, 0.04142124602787389, 0.04142124602787389, 0.04142124602787389, 0.19188506601390942, 0.19188506601390942, 0.19188506601390942, 0.06504016451031802, 0.06504016451031802, 0.06504016451031802, 0.09683100782562593, 0.09683100782562593, 0.09683100782562593, 0.12275197422884043, 0.12275197422884043, 0.12275197422884043, 0.1014539733297295, 0.1014539733297295, 0.1014539733297295, 0.11601661959038267, 0.11601661959038267, 0.11601661959038267, 0.9886815240544001, 0.9886815240544001, 0.9886815240544001, 0.9885702813194561, 0.9885702813194561, 0.9885702813194561, 0.9863092826577706, 0.9863092826577706, 0.9863092826577706, 0.30615010599749015, 0.30615010599749015, 0.30615010599749015, 0.3430859817989461, 0.3430859817989461, 0.3430859817989461, 0.08279780098598244, 0.08279780098598244, 0.08279780098598244, 0.17115843099668204, 0.17115843099668204, 0.17115843099668204, 0.27120814845379115, 0.27120814845379115, 0.27120814845379115, 0.14163138537813214, 0.14163138537813214, 0.14163138537813214, 0.10223823644986352, 0.10223823644986352, 0.10223823644986352, 0.09918899690777161, 0.09918899690777161, 0.09918899690777161, 0.14164615399132785, 0.14164615399132785, 0.14164615399132785, 0.11234370748545952, 0.11234370748545952, 0.11234370748545952, 0.13208543387721383, 0.13208543387721383, 0.13208543387721383, 0.08935565821915203, 0.08935565821915203, 0.08935565821915203, 0.01556090790079856, 0.01556090790079856, 0.01556090790079856, 0.005422957680442431, 0.005422957680442431, 0.005422957680442431, 0.002070533324557755, 0.002070533324557755, 0.002070533324557755, 0.023983659641912514, 0.023983659641912514, 0.023983659641912514, 0.10125186061475744, 0.10125186061475744, 0.10125186061475744, 0.04938634421531074, 0.04938634421531074, 0.04938634421531074, 0.10280790905709614, 0.10280790905709614, 0.10280790905709614, 0.049495593292359086, 0.049495593292359086, 0.049495593292359086, 0.058588917382563666, 0.058588917382563666, 0.058588917382563666, 0.08658800661985333, 0.08658800661985333, 0.08658800661985333, 0.004085614856088937, 0.004085614856088937, 0.004085614856088937, 0.046988527487615284, 0.046988527487615284, 0.046988527487615284, 0.39157909563847937, 0.39157909563847937, 0.39157909563847937, 0.4325681579834202, 0.4325681579834202, 0.4325681579834202, 0.43573744386224467, 0.43573744386224467, 0.43573744386224467, 0.07359388807345135, 0.07359388807345135, 0.07359388807345135, 0.08510102404552378, 0.08510102404552378, 0.08510102404552378, 0.0835506906402479, 0.0835506906402479, 0.0835506906402479, 0.21324039059524913, 0.21324039059524913, 0.21324039059524913, 0.21380890527250995, 0.21380890527250995, 0.21380890527250995, 0.24427390997774234, 0.24427390997774234, 0.24427390997774234, 0.3133409294604649, 0.3133409294604649, 0.3133409294604649, 0.2999253767097849, 0.2999253767097849, 0.2999253767097849, 0.3648921086595833, 0.3648921086595833, 0.3648921086595833, 0.14780628883911218, 0.14780628883911218, 0.14780628883911218, 0.22980675447864074, 0.22980675447864074, 0.22980675447864074, 0.21575192376841357, 0.21575192376841357, 0.21575192376841357, 0.1712310682543342, 0.1712310682543342, 0.1712310682543342, 0.1858240684267457, 0.1858240684267457, 0.1858240684267457, 0.2136054648719503, 0.2136054648719503, 0.2136054648719503, 0.1850486605264282, 0.1850486605264282, 0.1850486605264282, 0.203755078445516, 0.203755078445516, 0.203755078445516, 0.1910989011127222, 0.1910989011127222, 0.1910989011127222, 0.69778340622164, 0.69778340622164, 0.69778340622164, 0.6059639639002488, 0.6059639639002488, 0.6059639639002488, 0.1424845965646293, 0.1424845965646293, 0.1424845965646293, 0.5926660248648106, 0.5926660248648106, 0.5926660248648106, 0.5043370505449811, 0.5043370505449811, 0.5043370505449811, 0.19343309930218033, 0.19343309930218033, 0.19343309930218033, 0.1850099873680241, 0.1850099873680241, 0.1850099873680241, 0.1812611687009945, 0.1812611687009945, 0.1812611687009945, 0.19849253331524874, 0.19849253331524874, 0.19849253331524874, 0.07763308440050531, 0.07763308440050531, 0.07763308440050531, 0.07245635130583417, 0.07245635130583417, 0.07245635130583417, 0.08280827230631949, 0.08280827230631949, 0.08280827230631949]}, "mutation_prompt": null}
{"id": "0b0f2c29-4145-4def-8c34-c3f7cfb826ca", "solution": "import numpy as np\n\nclass AdaptiveRestartPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1 = 2.0\n        self.c2 = 2.0\n        self.restart_threshold = 0.2 * dim\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        stagnation_counter = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                        stagnation_counter = 0\n                else:\n                    stagnation_counter += 1\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = self.c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = self.c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n            \n            if stagnation_counter > self.restart_threshold:\n                positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n                velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n                stagnation_counter = 0\n\n# Usage:\n# adaptive_restart_pso = AdaptiveRestartPSO(budget=10000, dim=10)\n# adaptive_restart_pso(func)", "name": "AdaptiveRestartPSO", "description": "A novel Particle Swarm Optimization with adaptive inertia and random restart mechanism to prevent stagnation and enhance exploration.", "configspace": "", "generation": 4, "fitness": 0.10699096010360583, "feedback": "The algorithm AdaptiveRestartPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.11 with standard deviation 0.13.", "error": "", "parent_id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "metadata": {"aucs": [0.17876421815895827, 0.17876421815895827, 0.17876421815895827, 0.19424350619403186, 0.19424350619403186, 0.19424350619403186, 0.1919567702390077, 0.1919567702390077, 0.1919567702390077, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.05124437938357296, 0.05124437938357296, 0.05124437938357296, 0.04547503168714517, 0.04547503168714517, 0.04547503168714517, 0.05654065438247413, 0.05654065438247413, 0.05654065438247413, 0.032475263967276624, 0.032475263967276624, 0.032475263967276624, 0.03532084016324044, 0.03532084016324044, 0.03532084016324044, 0.02676088016931899, 0.02676088016931899, 0.02676088016931899, 0.9932781103676772, 0.9932781103676772, 0.9932781103676772, 0.08798053155947094, 0.08798053155947094, 0.08798053155947094, 0.13349876963881124, 0.13349876963881124, 0.13349876963881124, 0.10232740726089595, 0.10232740726089595, 0.10232740726089595, 0.07318048784478537, 0.07318048784478537, 0.07318048784478537, 0.09657682156261849, 0.09657682156261849, 0.09657682156261849, 0.14730583478398063, 0.14730583478398063, 0.14730583478398063, 0.14204375486983822, 0.14204375486983822, 0.14204375486983822, 0.14022915826452376, 0.14022915826452376, 0.14022915826452376, 0.011439984284518867, 0.011439984284518867, 0.011439984284518867, 0.009815529589801142, 0.009815529589801142, 0.009815529589801142, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.004177747817318056, 0.004177747817318056, 0.004177747817318056, 0.02063154539284029, 0.02063154539284029, 0.02063154539284029, 0.005208551373504955, 0.005208551373504955, 0.005208551373504955, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.06638040065204531, 0.06638040065204531, 0.06638040065204531, 0.07505015193945108, 0.07505015193945108, 0.07505015193945108, 0.07161255794075772, 0.07161255794075772, 0.07161255794075772, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.19712341997562788, 0.19712341997562788, 0.19712341997562788, 0.19191411402298042, 0.19191411402298042, 0.19191411402298042, 0.19516776062830266, 0.19516776062830266, 0.19516776062830266, 0.060303795219704415, 0.060303795219704415, 0.060303795219704415, 0.04218084438537517, 0.04218084438537517, 0.04218084438537517, 0.07070338260278752, 0.07070338260278752, 0.07070338260278752, 0.13292810154206725, 0.13292810154206725, 0.13292810154206725, 0.1327159491282428, 0.1327159491282428, 0.1327159491282428, 0.14803848490727467, 0.14803848490727467, 0.14803848490727467, 0.1765562727453649, 0.1765562727453649, 0.1765562727453649, 0.17207245762216195, 0.17207245762216195, 0.17207245762216195, 0.17265003138788504, 0.17265003138788504, 0.17265003138788504, 0.12161856142519156, 0.12161856142519156, 0.12161856142519156, 0.11247437662600257, 0.11247437662600257, 0.11247437662600257, 0.11110086340033576, 0.11110086340033576, 0.11110086340033576, 0.16767980637105206, 0.16767980637105206, 0.16767980637105206, 0.1690865467850552, 0.1690865467850552, 0.1690865467850552, 0.17612728057864457, 0.17612728057864457, 0.17612728057864457, 0.15150035977579734, 0.15150035977579734, 0.15150035977579734, 0.1444999069578876, 0.1444999069578876, 0.1444999069578876, 0.1444743875043507, 0.1444743875043507, 0.1444743875043507, 0.2021231462636378, 0.2021231462636378, 0.2021231462636378, 0.19114763445881422, 0.19114763445881422, 0.19114763445881422, 0.18221841857474153, 0.18221841857474153, 0.18221841857474153, 0.1650758810588473, 0.1650758810588473, 0.1650758810588473, 0.15997500140986776, 0.15997500140986776, 0.15997500140986776, 0.12553672574146424, 0.12553672574146424, 0.12553672574146424, 0.17517536406445633, 0.17517536406445633, 0.17517536406445633, 0.17500077980211504, 0.17500077980211504, 0.17500077980211504, 0.18215687664186608, 0.18215687664186608, 0.18215687664186608, 0.05871724057599226, 0.05871724057599226, 0.05871724057599226, 0.05085832296287662, 0.05085832296287662, 0.05085832296287662, 0.049628142824982624, 0.049628142824982624, 0.049628142824982624]}, "mutation_prompt": null}
{"id": "4c1ee741-f682-4a42-84bf-744aedb2f95b", "solution": "import numpy as np\n\nclass QuantumInspiredPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                quantum_behavior = np.random.uniform(-1, 1, self.dim) * np.exp(-evaluations / self.budget) * (np.random.uniform(-5, 5, self.dim) - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component + quantum_behavior\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# quantum_pso = QuantumInspiredPSO(budget=10000, dim=10)\n# quantum_pso(func)", "name": "QuantumInspiredPSO", "description": "Quantum-Inspired PSO with dynamic adaptive parameters and quantum behavior to enhance exploration and exploitation balance.", "configspace": "", "generation": 5, "fitness": 0.1344178869556374, "feedback": "The algorithm QuantumInspiredPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.13 with standard deviation 0.19.", "error": "", "parent_id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "metadata": {"aucs": [0.2006992651513354, 0.2006992651513354, 0.2006992651513354, 0.21048578384455618, 0.21048578384455618, 0.21048578384455618, 0.21823936735910332, 0.21823936735910332, 0.21823936735910332, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.052753796408636866, 0.052753796408636866, 0.052753796408636866, 0.05146705675469543, 0.05146705675469543, 0.05146705675469543, 0.05922931832224787, 0.05922931832224787, 0.05922931832224787, 0.05396472346053616, 0.05396472346053616, 0.05396472346053616, 0.03642626484717659, 0.03642626484717659, 0.03642626484717659, 0.042490664817458335, 0.042490664817458335, 0.042490664817458335, 0.9917386095602838, 0.9917386095602838, 0.9917386095602838, 0.9887736247328544, 0.9887736247328544, 0.9887736247328544, 0.9882429306583064, 0.9882429306583064, 0.9882429306583064, 0.09472423840752486, 0.09472423840752486, 0.09472423840752486, 0.10030810629067022, 0.10030810629067022, 0.10030810629067022, 0.09719534379487582, 0.09719534379487582, 0.09719534379487582, 0.1578452713157441, 0.1578452713157441, 0.1578452713157441, 0.14741757731045635, 0.14741757731045635, 0.14741757731045635, 0.1361590654506596, 0.1361590654506596, 0.1361590654506596, 0.03164137009761958, 0.03164137009761958, 0.03164137009761958, 0.026012152322553495, 0.026012152322553495, 0.026012152322553495, 0.01496294307532553, 0.01496294307532553, 0.01496294307532553, 0.017885609102944566, 0.017885609102944566, 0.017885609102944566, 0.042354586338813505, 0.042354586338813505, 0.042354586338813505, 0.01037181266511833, 0.01037181266511833, 0.01037181266511833, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04451780512166237, 0.04451780512166237, 0.04451780512166237, 0.033732373645763425, 0.033732373645763425, 0.033732373645763425, 0.040493250080915644, 0.040493250080915644, 0.040493250080915644, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0023735020142097163, 0.0023735020142097163, 0.0023735020142097163, 0.0030931796635537134, 0.0030931796635537134, 0.0030931796635537134, 0.015035165644082138, 0.015035165644082138, 0.015035165644082138, 0.2231782512028596, 0.2231782512028596, 0.2231782512028596, 0.2190027806599092, 0.2190027806599092, 0.2190027806599092, 0.2211460201825598, 0.2211460201825598, 0.2211460201825598, 0.059853997321952956, 0.059853997321952956, 0.059853997321952956, 0.05973623300612252, 0.05973623300612252, 0.05973623300612252, 0.05149809900230651, 0.05149809900230651, 0.05149809900230651, 0.16210786165318836, 0.16210786165318836, 0.16210786165318836, 0.1365671506570345, 0.1365671506570345, 0.1365671506570345, 0.14835338365087958, 0.14835338365087958, 0.14835338365087958, 0.1623975621442858, 0.1623975621442858, 0.1623975621442858, 0.17495634555667472, 0.17495634555667472, 0.17495634555667472, 0.18065155044597125, 0.18065155044597125, 0.18065155044597125, 0.12057663494423199, 0.12057663494423199, 0.12057663494423199, 0.12498123515327553, 0.12498123515327553, 0.12498123515327553, 0.11506896465103367, 0.11506896465103367, 0.11506896465103367, 0.15187272891263404, 0.15187272891263404, 0.15187272891263404, 0.15190241712599506, 0.15190241712599506, 0.15190241712599506, 0.1593824083260884, 0.1593824083260884, 0.1593824083260884, 0.14595105909357675, 0.14595105909357675, 0.14595105909357675, 0.15631948156867403, 0.15631948156867403, 0.15631948156867403, 0.13072831166688847, 0.13072831166688847, 0.13072831166688847, 0.20944883411634607, 0.20944883411634607, 0.20944883411634607, 0.1473881609297838, 0.1473881609297838, 0.1473881609297838, 0.1607224217160541, 0.1607224217160541, 0.1607224217160541, 0.17498209149184352, 0.17498209149184352, 0.17498209149184352, 0.10863532193268588, 0.10863532193268588, 0.10863532193268588, 0.18587900115239198, 0.18587900115239198, 0.18587900115239198, 0.1828698083771012, 0.1828698083771012, 0.1828698083771012, 0.18396948150757142, 0.18396948150757142, 0.18396948150757142, 0.18464455146312964, 0.18464455146312964, 0.18464455146312964, 0.053507169656349496, 0.053507169656349496, 0.053507169656349496, 0.06732457867776431, 0.06732457867776431, 0.06732457867776431, 0.05094920459904373, 0.05094920459904373, 0.05094920459904373]}, "mutation_prompt": null}
{"id": "6bdac499-0093-46ad-9c32-628fe6ea46fa", "solution": "import numpy as np\n\nclass EnhancedMultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.mutation_rate = 0.1\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget))\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * (evaluations / self.budget))\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * (evaluations / self.budget))\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n\n                # Apply mutation occasionally to maintain diversity\n                if np.random.rand() < self.mutation_rate:\n                    velocities[i] += np.random.normal(0, 0.1, self.dim)\n\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedMultiStrategyPSO", "description": "A multi-strategy-enhanced PSO with variable mutation and dynamic learning rates for improved exploration-exploitation balance.", "configspace": "", "generation": 6, "fitness": 0.19898774326060348, "feedback": "The algorithm EnhancedMultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "metadata": {"aucs": [0.48280783659539106, 0.48280783659539106, 0.48280783659539106, 0.49527768734084343, 0.49527768734084343, 0.49527768734084343, 0.5328202784350089, 0.5328202784350089, 0.5328202784350089, 0.0017364088529393529, 0.0017364088529393529, 0.0017364088529393529, 0.07502648747848673, 0.07502648747848673, 0.07502648747848673, 0.02758394279937726, 0.02758394279937726, 0.02758394279937726, 0.1061113140399701, 0.1061113140399701, 0.1061113140399701, 0.12643196395296397, 0.12643196395296397, 0.12643196395296397, 0.1146705827280673, 0.1146705827280673, 0.1146705827280673, 0.08628526688653837, 0.08628526688653837, 0.08628526688653837, 0.08699490129655041, 0.08699490129655041, 0.08699490129655041, 0.0977036316183949, 0.0977036316183949, 0.0977036316183949, 0.9888140876731482, 0.9888140876731482, 0.9888140876731482, 0.9624378683887738, 0.9624378683887738, 0.9624378683887738, 0.9917385098194377, 0.9917385098194377, 0.9917385098194377, 0.25036565383386855, 0.25036565383386855, 0.25036565383386855, 0.2599808539606955, 0.2599808539606955, 0.2599808539606955, 0.22155866084987474, 0.22155866084987474, 0.22155866084987474, 0.27161843266795216, 0.27161843266795216, 0.27161843266795216, 0.24303352052421956, 0.24303352052421956, 0.24303352052421956, 0.12779809171923806, 0.12779809171923806, 0.12779809171923806, 0.12237351772400329, 0.12237351772400329, 0.12237351772400329, 0.09011740472924012, 0.09011740472924012, 0.09011740472924012, 0.14981015745407966, 0.14981015745407966, 0.14981015745407966, 0.11549374356183184, 0.11549374356183184, 0.11549374356183184, 0.11643378597507092, 0.11643378597507092, 0.11643378597507092, 0.08082741940529325, 0.08082741940529325, 0.08082741940529325, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014249687754164242, 0.00014249687754164242, 0.00014249687754164242, 0.020390774232410203, 0.020390774232410203, 0.020390774232410203, 0.04643037210777545, 0.04643037210777545, 0.04643037210777545, 0.028365439459058672, 0.028365439459058672, 0.028365439459058672, 0.09467817897474196, 0.09467817897474196, 0.09467817897474196, 0.018271084391972003, 0.018271084391972003, 0.018271084391972003, 0.03150031126133057, 0.03150031126133057, 0.03150031126133057, 0.026978043104910143, 0.026978043104910143, 0.026978043104910143, 0.03883431996825071, 0.03883431996825071, 0.03883431996825071, 0.01597277809072062, 0.01597277809072062, 0.01597277809072062, 0.06579569797779872, 0.06579569797779872, 0.06579569797779872, 0.400509604875564, 0.400509604875564, 0.400509604875564, 0.4153911041221421, 0.4153911041221421, 0.4153911041221421, 0.3804598695644821, 0.3804598695644821, 0.3804598695644821, 0.08962037890636365, 0.08962037890636365, 0.08962037890636365, 0.10904211895216054, 0.10904211895216054, 0.10904211895216054, 0.0659019908561419, 0.0659019908561419, 0.0659019908561419, 0.26025594758666004, 0.26025594758666004, 0.26025594758666004, 0.1975904396289675, 0.1975904396289675, 0.1975904396289675, 0.2355813274490507, 0.2355813274490507, 0.2355813274490507, 0.27436486794611203, 0.27436486794611203, 0.27436486794611203, 0.1751456256086793, 0.1751456256086793, 0.1751456256086793, 0.25210983184796387, 0.25210983184796387, 0.25210983184796387, 0.16678862630773805, 0.16678862630773805, 0.16678862630773805, 0.20044098302801439, 0.20044098302801439, 0.20044098302801439, 0.21760765265927662, 0.21760765265927662, 0.21760765265927662, 0.1719725188654938, 0.1719725188654938, 0.1719725188654938, 0.1964547852467109, 0.1964547852467109, 0.1964547852467109, 0.20772269242717434, 0.20772269242717434, 0.20772269242717434, 0.20137990705740583, 0.20137990705740583, 0.20137990705740583, 0.17997173638460795, 0.17997173638460795, 0.17997173638460795, 0.19179863606184888, 0.19179863606184888, 0.19179863606184888, 0.1740887579875402, 0.1740887579875402, 0.1740887579875402, 0.17410903442934855, 0.17410903442934855, 0.17410903442934855, 0.12053729064285779, 0.12053729064285779, 0.12053729064285779, 0.46258455731591464, 0.46258455731591464, 0.46258455731591464, 0.1979294936050321, 0.1979294936050321, 0.1979294936050321, 0.20506190068317753, 0.20506190068317753, 0.20506190068317753, 0.18133578134717798, 0.18133578134717798, 0.18133578134717798, 0.19194404822191413, 0.19194404822191413, 0.19194404822191413, 0.18262856748226408, 0.18262856748226408, 0.18262856748226408, 0.07760744861918012, 0.07760744861918012, 0.07760744861918012, 0.07576156220775376, 0.07576156220775376, 0.07576156220775376, 0.08010692008096243, 0.08010692008096243, 0.08010692008096243]}, "mutation_prompt": null}
{"id": "b692ab87-af5d-47f1-be9d-a589b06144ad", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 1.7\n        self.c2_final = 2.3\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                random_component = np.random.uniform(-0.1, 0.1, self.dim)\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component + random_component\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "HybridAdaptivePSO", "description": "A hybrid Particle Swarm Optimization incorporating evolutionary multi-agent interactions and adaptive velocity scaling for improved exploration and exploitation balance.", "configspace": "", "generation": 7, "fitness": 0.198137606130908, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.20.", "error": "", "parent_id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "metadata": {"aucs": [0.36243506261985825, 0.36243506261985825, 0.36243506261985825, 0.394691996390492, 0.394691996390492, 0.394691996390492, 0.3966596804759144, 0.3966596804759144, 0.3966596804759144, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0136854534489661, 0.0136854534489661, 0.0136854534489661, 0.0013095145846505618, 0.0013095145846505618, 0.0013095145846505618, 0.06269244327188295, 0.06269244327188295, 0.06269244327188295, 0.09637338457581823, 0.09637338457581823, 0.09637338457581823, 0.06299917004848898, 0.06299917004848898, 0.06299917004848898, 0.08900890820336804, 0.08900890820336804, 0.08900890820336804, 0.09536461848104505, 0.09536461848104505, 0.09536461848104505, 0.10157577066558865, 0.10157577066558865, 0.10157577066558865, 0.9923330755443857, 0.9923330755443857, 0.9923330755443857, 0.9753713003227605, 0.9753713003227605, 0.9753713003227605, 0.9924315424777432, 0.9924315424777432, 0.9924315424777432, 0.2316350689912895, 0.2316350689912895, 0.2316350689912895, 0.22513759393080646, 0.22513759393080646, 0.22513759393080646, 0.21823939359654765, 0.21823939359654765, 0.21823939359654765, 0.283528480092881, 0.283528480092881, 0.283528480092881, 0.2660823449184265, 0.2660823449184265, 0.2660823449184265, 0.21071407587493574, 0.21071407587493574, 0.21071407587493574, 0.12527846172980484, 0.12527846172980484, 0.12527846172980484, 0.09662282881013273, 0.09662282881013273, 0.09662282881013273, 0.12394582902617313, 0.12394582902617313, 0.12394582902617313, 0.12023796390083663, 0.12023796390083663, 0.12023796390083663, 0.16110965116760412, 0.16110965116760412, 0.16110965116760412, 0.1438262352925862, 0.1438262352925862, 0.1438262352925862, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00014386311887759629, 0.00014386311887759629, 0.00014386311887759629, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.02002110299408122, 0.02002110299408122, 0.02002110299408122, 0.035693098821367286, 0.035693098821367286, 0.035693098821367286, 0.1132938190163415, 0.1132938190163415, 0.1132938190163415, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.033362076812882835, 0.033362076812882835, 0.033362076812882835, 0.06651201219057912, 0.06651201219057912, 0.06651201219057912, 0.05806557419159475, 0.05806557419159475, 0.05806557419159475, 0.36764541121367755, 0.36764541121367755, 0.36764541121367755, 0.37602503571323764, 0.37602503571323764, 0.37602503571323764, 0.35530022008026196, 0.35530022008026196, 0.35530022008026196, 0.11076114661658754, 0.11076114661658754, 0.11076114661658754, 0.09646238205004576, 0.09646238205004576, 0.09646238205004576, 0.0675807443380918, 0.0675807443380918, 0.0675807443380918, 0.20665591512375736, 0.20665591512375736, 0.20665591512375736, 0.21691942662140973, 0.21691942662140973, 0.21691942662140973, 0.15870915453447454, 0.15870915453447454, 0.15870915453447454, 0.27172842544251374, 0.27172842544251374, 0.27172842544251374, 0.23881108268359963, 0.23881108268359963, 0.23881108268359963, 0.2463994449724608, 0.2463994449724608, 0.2463994449724608, 0.1819434087194881, 0.1819434087194881, 0.1819434087194881, 0.15820757136193297, 0.15820757136193297, 0.15820757136193297, 0.20307771792314555, 0.20307771792314555, 0.20307771792314555, 0.19884995387544835, 0.19884995387544835, 0.19884995387544835, 0.1953128574610694, 0.1953128574610694, 0.1953128574610694, 0.17320102664420278, 0.17320102664420278, 0.17320102664420278, 0.2002823286654568, 0.2002823286654568, 0.2002823286654568, 0.21203836890253336, 0.21203836890253336, 0.21203836890253336, 0.20439748819332992, 0.20439748819332992, 0.20439748819332992, 0.4956030425852326, 0.4956030425852326, 0.4956030425852326, 0.49181875766215044, 0.49181875766215044, 0.49181875766215044, 0.09940534937342749, 0.09940534937342749, 0.09940534937342749, 0.3228758150785841, 0.3228758150785841, 0.3228758150785841, 0.26916364229561873, 0.26916364229561873, 0.26916364229561873, 0.20955606493275458, 0.20955606493275458, 0.20955606493275458, 0.17784228927347379, 0.17784228927347379, 0.17784228927347379, 0.1799256947734229, 0.1799256947734229, 0.1799256947734229, 0.1857893888899128, 0.1857893888899128, 0.1857893888899128, 0.07959762237301216, 0.07959762237301216, 0.07959762237301216, 0.06721997011590342, 0.06721997011590342, 0.06721997011590342, 0.07581949734644566, 0.07581949734644566, 0.07581949734644566]}, "mutation_prompt": null}
{"id": "46cbdeda-30eb-477c-b545-ee5793678a38", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "An enhanced Particle Swarm Optimization with dynamic social-cognitive balance and adaptive neighborhood influence for robust convergence.", "configspace": "", "generation": 3, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "metadata": {"aucs": [0.5721523072189221, 0.5721523072189221, 0.5721523072189221, 0.6238490366521984, 0.6238490366521984, 0.6238490366521984, 0.629679018324389, 0.629679018324389, 0.629679018324389, 0.033500162994882676, 0.033500162994882676, 0.033500162994882676, 0.33101104578903273, 0.33101104578903273, 0.33101104578903273, 0.039954132596335734, 0.039954132596335734, 0.039954132596335734, 0.13197469477353319, 0.13197469477353319, 0.13197469477353319, 0.1197591024834288, 0.1197591024834288, 0.1197591024834288, 0.18124602679005286, 0.18124602679005286, 0.18124602679005286, 0.10809857444804638, 0.10809857444804638, 0.10809857444804638, 0.11225710938209266, 0.11225710938209266, 0.11225710938209266, 0.2830967441414156, 0.2830967441414156, 0.2830967441414156, 0.9904632150838426, 0.9904632150838426, 0.9904632150838426, 0.9898754106081937, 0.9898754106081937, 0.9898754106081937, 0.9889075185521351, 0.9889075185521351, 0.9889075185521351, 0.2846414183687983, 0.2846414183687983, 0.2846414183687983, 0.14390344939564925, 0.14390344939564925, 0.14390344939564925, 0.08310366196826158, 0.08310366196826158, 0.08310366196826158, 0.172215868569481, 0.172215868569481, 0.172215868569481, 0.2586166915143331, 0.2586166915143331, 0.2586166915143331, 0.17999520537148805, 0.17999520537148805, 0.17999520537148805, 0.1326172022599893, 0.1326172022599893, 0.1326172022599893, 0.08920211015432711, 0.08920211015432711, 0.08920211015432711, 0.12277723021848741, 0.12277723021848741, 0.12277723021848741, 0.10410751778378147, 0.10410751778378147, 0.10410751778378147, 0.10103510621941858, 0.10103510621941858, 0.10103510621941858, 0.14806726932172953, 0.14806726932172953, 0.14806726932172953, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.00353472492140805, 0.00353472492140805, 0.00353472492140805, 0.09131113929537038, 0.09131113929537038, 0.09131113929537038, 0.06531573515534872, 0.06531573515534872, 0.06531573515534872, 0.06063814371686227, 0.06063814371686227, 0.06063814371686227, 0.08391622265324217, 0.08391622265324217, 0.08391622265324217, 0.04268409054459099, 0.04268409054459099, 0.04268409054459099, 0.06990330642340437, 0.06990330642340437, 0.06990330642340437, 0.06378921934287829, 0.06378921934287829, 0.06378921934287829, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.046023947573463175, 0.046023947573463175, 0.046023947573463175, 0.4342182063373401, 0.4342182063373401, 0.4342182063373401, 0.47012509965345217, 0.47012509965345217, 0.47012509965345217, 0.4284495044783311, 0.4284495044783311, 0.4284495044783311, 0.10207113920088051, 0.10207113920088051, 0.10207113920088051, 0.08990954583804323, 0.08990954583804323, 0.08990954583804323, 0.09263826125250141, 0.09263826125250141, 0.09263826125250141, 0.15105832281179632, 0.15105832281179632, 0.15105832281179632, 0.22953167016013531, 0.22953167016013531, 0.22953167016013531, 0.20268008372972446, 0.20268008372972446, 0.20268008372972446, 0.30529499397107007, 0.30529499397107007, 0.30529499397107007, 0.27173863536578424, 0.27173863536578424, 0.27173863536578424, 0.2616078574929944, 0.2616078574929944, 0.2616078574929944, 0.19665735368307125, 0.19665735368307125, 0.19665735368307125, 0.24753726347448923, 0.24753726347448923, 0.24753726347448923, 0.2511475784518672, 0.2511475784518672, 0.2511475784518672, 0.21590587472634515, 0.21590587472634515, 0.21590587472634515, 0.18717837638977208, 0.18717837638977208, 0.18717837638977208, 0.18838106388029707, 0.18838106388029707, 0.18838106388029707, 0.3824038702017436, 0.3824038702017436, 0.3824038702017436, 0.24279238649420265, 0.24279238649420265, 0.24279238649420265, 0.19912811589633694, 0.19912811589633694, 0.19912811589633694, 0.19431273749029898, 0.19431273749029898, 0.19431273749029898, 0.6965327252241778, 0.6965327252241778, 0.6965327252241778, 0.5371867206960035, 0.5371867206960035, 0.5371867206960035, 0.5760502943838572, 0.5760502943838572, 0.5760502943838572, 0.20133954468361015, 0.20133954468361015, 0.20133954468361015, 0.20130934839573078, 0.20130934839573078, 0.20130934839573078, 0.2059158062863422, 0.2059158062863422, 0.2059158062863422, 0.19181791681541982, 0.19181791681541982, 0.19181791681541982, 0.18628486958279922, 0.18628486958279922, 0.18628486958279922, 0.07465673538014361, 0.07465673538014361, 0.07465673538014361, 0.08106257795384697, 0.08106257795384697, 0.08106257795384697, 0.0847800975865084, 0.0847800975865084, 0.0847800975865084]}, "mutation_prompt": null}
{"id": "92b791b7-42ff-42f4-a17f-ef8376218df1", "solution": "import numpy as np\n\nclass HybridAdaptivePSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.mutation_rate = 0.1\n        self.crossover_rate = 0.8\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            # Evaluate and update personal and global bests\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            # Adaptive inertia weight and coefficients\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            # Particle update with crossover and mutation\n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                # Crossover\n                if np.random.rand() < self.crossover_rate:\n                    partner_idx = np.random.randint(self.num_particles)\n                    cross_point = np.random.randint(self.dim)\n                    positions[i][:cross_point] = personal_best_positions[partner_idx][:cross_point]\n                \n                # Mutation\n                if np.random.rand() < self.mutation_rate:\n                    mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[i] += mutation_vector * np.random.uniform(-1, 1, self.dim)\n                \n                # Update position\n                positions[i] = np.clip(positions[i] + velocities[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_pso_ga = HybridAdaptivePSOGA(budget=10000, dim=10)\n# hybrid_pso_ga(func)", "name": "HybridAdaptivePSOGA", "description": "Hybrid PSO-Genetic Algorithm with adaptive mutation and crossover rates for enhanced exploration and exploitation.", "configspace": "", "generation": 9, "fitness": 0.14972507982436536, "feedback": "The algorithm HybridAdaptivePSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.15 with standard deviation 0.19.", "error": "", "parent_id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "metadata": {"aucs": [0.2350764059737539, 0.2350764059737539, 0.2350764059737539, 0.25982891013489007, 0.25982891013489007, 0.25982891013489007, 0.28066973431640263, 0.28066973431640263, 0.28066973431640263, 0.010203452089616594, 0.010203452089616594, 0.010203452089616594, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0015859649339705628, 0.0015859649339705628, 0.0015859649339705628, 0.05454838474657264, 0.05454838474657264, 0.05454838474657264, 0.05188351492936705, 0.05188351492936705, 0.05188351492936705, 0.0675413628578364, 0.0675413628578364, 0.0675413628578364, 0.06501512019331623, 0.06501512019331623, 0.06501512019331623, 0.0641042036397792, 0.0641042036397792, 0.0641042036397792, 0.05485305115359718, 0.05485305115359718, 0.05485305115359718, 0.9915659278687641, 0.9915659278687641, 0.9915659278687641, 0.9886828764418566, 0.9886828764418566, 0.9886828764418566, 0.991705074877667, 0.991705074877667, 0.991705074877667, 0.12764208128945975, 0.12764208128945975, 0.12764208128945975, 0.11880580245896599, 0.11880580245896599, 0.11880580245896599, 0.10370521590473836, 0.10370521590473836, 0.10370521590473836, 0.14592228617701364, 0.14592228617701364, 0.14592228617701364, 0.186243465566313, 0.186243465566313, 0.186243465566313, 0.16068969611039718, 0.16068969611039718, 0.16068969611039718, 0.05717886107511072, 0.05717886107511072, 0.05717886107511072, 0.05854944549560803, 0.05854944549560803, 0.05854944549560803, 0.06982038812353986, 0.06982038812353986, 0.06982038812353986, 0.007597426073359559, 0.007597426073359559, 0.007597426073359559, 0.054935421909630744, 0.054935421909630744, 0.054935421909630744, 0.02106166251916708, 0.02106166251916708, 0.02106166251916708, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07982716453725103, 0.07982716453725103, 0.07982716453725103, 0.035443369313597595, 0.035443369313597595, 0.035443369313597595, 0.07562618209035954, 0.07562618209035954, 0.07562618209035954, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.018008147555494736, 0.018008147555494736, 0.018008147555494736, 0.0040642193126475545, 0.0040642193126475545, 0.0040642193126475545, 0.025601854404956104, 0.025601854404956104, 0.025601854404956104, 0.2848258130666754, 0.2848258130666754, 0.2848258130666754, 0.2636789760858619, 0.2636789760858619, 0.2636789760858619, 0.2480253443051379, 0.2480253443051379, 0.2480253443051379, 0.05853313618520484, 0.05853313618520484, 0.05853313618520484, 0.06397078216241403, 0.06397078216241403, 0.06397078216241403, 0.05651372842078162, 0.05651372842078162, 0.05651372842078162, 0.1588509046204577, 0.1588509046204577, 0.1588509046204577, 0.15427147116439888, 0.15427147116439888, 0.15427147116439888, 0.14648439486550302, 0.14648439486550302, 0.14648439486550302, 0.19327670830346477, 0.19327670830346477, 0.19327670830346477, 0.17437356006658322, 0.17437356006658322, 0.17437356006658322, 0.21632019724534957, 0.21632019724534957, 0.21632019724534957, 0.12552107193602402, 0.12552107193602402, 0.12552107193602402, 0.12652742578629117, 0.12652742578629117, 0.12652742578629117, 0.14831758430490627, 0.14831758430490627, 0.14831758430490627, 0.1671270222582607, 0.1671270222582607, 0.1671270222582607, 0.1456061071781627, 0.1456061071781627, 0.1456061071781627, 0.15553525727823814, 0.15553525727823814, 0.15553525727823814, 0.1587747873952119, 0.1587747873952119, 0.1587747873952119, 0.15852722114755236, 0.15852722114755236, 0.15852722114755236, 0.1577269064191551, 0.1577269064191551, 0.1577269064191551, 0.28420336451014205, 0.28420336451014205, 0.28420336451014205, 0.27067245598363876, 0.27067245598363876, 0.27067245598363876, 0.14339744526400156, 0.14339744526400156, 0.14339744526400156, 0.16263636396814563, 0.16263636396814563, 0.16263636396814563, 0.15141613644358698, 0.15141613644358698, 0.15141613644358698, 0.19729641013270283, 0.19729641013270283, 0.19729641013270283, 0.19969095147671334, 0.19969095147671334, 0.19969095147671334, 0.17781190503936328, 0.17781190503936328, 0.17781190503936328, 0.18186407326943288, 0.18186407326943288, 0.18186407326943288, 0.05647258686793666, 0.05647258686793666, 0.05647258686793666, 0.05973552184213127, 0.05973552184213127, 0.05973552184213127, 0.0635334582858772, 0.0635334582858772, 0.0635334582858772]}, "mutation_prompt": null}
{"id": "0b3d8c8c-569a-4bc5-93bd-f6e13b3c8fdb", "solution": "import numpy as np\n\nclass DynamicQuantumPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.quantum_factor = 0.1\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                quantum_component = self.quantum_factor * np.random.normal(0, 1, self.dim)\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component + quantum_component\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "DynamicQuantumPSO", "description": "A Dynamic Quantum-Inspired Particle Swarm Optimization leveraging quantum behaviors and adaptive exploration-exploitation balance for diverse problem-solving.", "configspace": "", "generation": 10, "fitness": 0.1873867131239957, "feedback": "The algorithm DynamicQuantumPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.20.", "error": "", "parent_id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "metadata": {"aucs": [0.34812870032705956, 0.34812870032705956, 0.34812870032705956, 0.3380310636946352, 0.3380310636946352, 0.3380310636946352, 0.3698711697344247, 0.3698711697344247, 0.3698711697344247, 0.003004556405844405, 0.003004556405844405, 0.003004556405844405, 0.005783381327594372, 0.005783381327594372, 0.005783381327594372, 0.015119970670765759, 0.015119970670765759, 0.015119970670765759, 0.08439220577268591, 0.08439220577268591, 0.08439220577268591, 0.06640970502960697, 0.06640970502960697, 0.06640970502960697, 0.09839694650552155, 0.09839694650552155, 0.09839694650552155, 0.06524727255991514, 0.06524727255991514, 0.06524727255991514, 0.07714751516152685, 0.07714751516152685, 0.07714751516152685, 0.0773113581328655, 0.0773113581328655, 0.0773113581328655, 0.9895770864917542, 0.9895770864917542, 0.9895770864917542, 0.9779820544518588, 0.9779820544518588, 0.9779820544518588, 0.989728858216981, 0.989728858216981, 0.989728858216981, 0.18400129682084398, 0.18400129682084398, 0.18400129682084398, 0.20764171305963453, 0.20764171305963453, 0.20764171305963453, 0.18355595118796797, 0.18355595118796797, 0.18355595118796797, 0.20947559492692536, 0.20947559492692536, 0.20947559492692536, 0.2006600851607775, 0.2006600851607775, 0.2006600851607775, 0.1738148402489318, 0.1738148402489318, 0.1738148402489318, 0.10172567596317772, 0.10172567596317772, 0.10172567596317772, 0.10241464724193827, 0.10241464724193827, 0.10241464724193827, 0.12378705914802923, 0.12378705914802923, 0.12378705914802923, 0.09295606420785862, 0.09295606420785862, 0.09295606420785862, 0.101429958966063, 0.101429958966063, 0.101429958966063, 0.11462653391463284, 0.11462653391463284, 0.11462653391463284, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0050119708625768755, 0.0050119708625768755, 0.0050119708625768755, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07332845216428796, 0.07332845216428796, 0.07332845216428796, 0.03140096650345203, 0.03140096650345203, 0.03140096650345203, 0.08737122163188982, 0.08737122163188982, 0.08737122163188982, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04606520846758244, 0.04606520846758244, 0.04606520846758244, 0.06080935541083421, 0.06080935541083421, 0.06080935541083421, 0.06435888594764438, 0.06435888594764438, 0.06435888594764438, 0.3328639312998386, 0.3328639312998386, 0.3328639312998386, 0.3239147088720268, 0.3239147088720268, 0.3239147088720268, 0.33154448714550777, 0.33154448714550777, 0.33154448714550777, 0.07281583235187195, 0.07281583235187195, 0.07281583235187195, 0.06504351689151211, 0.06504351689151211, 0.06504351689151211, 0.08349771397945993, 0.08349771397945993, 0.08349771397945993, 0.17115302015075617, 0.17115302015075617, 0.17115302015075617, 0.19227419984449357, 0.19227419984449357, 0.19227419984449357, 0.22783511252693556, 0.22783511252693556, 0.22783511252693556, 0.2150853886620262, 0.2150853886620262, 0.2150853886620262, 0.2513308883540868, 0.2513308883540868, 0.2513308883540868, 0.23457099063649245, 0.23457099063649245, 0.23457099063649245, 0.15030175788997546, 0.15030175788997546, 0.15030175788997546, 0.1596253079512815, 0.1596253079512815, 0.1596253079512815, 0.1698313790559952, 0.1698313790559952, 0.1698313790559952, 0.1837288406663543, 0.1837288406663543, 0.1837288406663543, 0.1769122799941819, 0.1769122799941819, 0.1769122799941819, 0.1908408751917191, 0.1908408751917191, 0.1908408751917191, 0.17437183894948616, 0.17437183894948616, 0.17437183894948616, 0.17848666476575503, 0.17848666476575503, 0.17848666476575503, 0.18965284076804545, 0.18965284076804545, 0.18965284076804545, 0.45960580668096207, 0.45960580668096207, 0.45960580668096207, 0.4584421133747948, 0.4584421133747948, 0.4584421133747948, 0.1124720670116538, 0.1124720670116538, 0.1124720670116538, 0.30987506570597556, 0.30987506570597556, 0.30987506570597556, 0.40241191959727907, 0.40241191959727907, 0.40241191959727907, 0.2083578532088889, 0.2083578532088889, 0.2083578532088889, 0.20501714713864416, 0.20501714713864416, 0.20501714713864416, 0.18405841982674387, 0.18405841982674387, 0.18405841982674387, 0.18938070765609127, 0.18938070765609127, 0.18938070765609127, 0.0792597252901307, 0.0792597252901307, 0.0792597252901307, 0.07086573175384037, 0.07086573175384037, 0.07086573175384037, 0.06534788541679881, 0.06534788541679881, 0.06534788541679881]}, "mutation_prompt": null}
{"id": "b681cf9f-c91b-4e82-9438-8583ac44aaa1", "solution": "import numpy as np\n\nclass AdaptivePSOWithClamping:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp = 0.5  # Added velocity clamping for stability\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                # Clamping velocities for stability\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# adaptive_pso = AdaptivePSOWithClamping(budget=10000, dim=10)\n# adaptive_pso(func)", "name": "AdaptivePSOWithClamping", "description": "An adaptive Particle Swarm Optimization with dynamic learning rates and velocity clamping for enhanced convergence and stability.", "configspace": "", "generation": 11, "fitness": 0.29050721042803324, "feedback": "The algorithm AdaptivePSOWithClamping got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "df16cccd-b9ae-4323-a99c-777948f2fd9a", "metadata": {"aucs": [0.7240743675152398, 0.7240743675152398, 0.7240743675152398, 0.7581995989415489, 0.7581995989415489, 0.7581995989415489, 0.7351887640610323, 0.7351887640610323, 0.7351887640610323, 0.44352084554500093, 0.44352084554500093, 0.44352084554500093, 0.43363752250815824, 0.43363752250815824, 0.43363752250815824, 0.4121633110476076, 0.4121633110476076, 0.4121633110476076, 0.11868175733987663, 0.11868175733987663, 0.11868175733987663, 0.12218337772587384, 0.12218337772587384, 0.12218337772587384, 0.11203968281063648, 0.11203968281063648, 0.11203968281063648, 0.13271798026676174, 0.13271798026676174, 0.13271798026676174, 0.11974863538435054, 0.11974863538435054, 0.11974863538435054, 0.11157782181537934, 0.11157782181537934, 0.11157782181537934, 0.93522326885522, 0.93522326885522, 0.93522326885522, 0.9376474998817406, 0.9376474998817406, 0.9376474998817406, 0.9488409059143703, 0.9488409059143703, 0.9488409059143703, 0.4292553188077104, 0.4292553188077104, 0.4292553188077104, 0.4973311608167562, 0.4973311608167562, 0.4973311608167562, 0.4807522398939025, 0.4807522398939025, 0.4807522398939025, 0.22750592706104766, 0.22750592706104766, 0.22750592706104766, 0.25970363540959607, 0.25970363540959607, 0.25970363540959607, 0.1763483580897287, 0.1763483580897287, 0.1763483580897287, 0.1275313925739332, 0.1275313925739332, 0.1275313925739332, 0.24108315784357603, 0.24108315784357603, 0.24108315784357603, 0.1939264314563618, 0.1939264314563618, 0.1939264314563618, 0.2054428514750387, 0.2054428514750387, 0.2054428514750387, 0.19985267476484359, 0.19985267476484359, 0.19985267476484359, 0.3265112564925854, 0.3265112564925854, 0.3265112564925854, 0.035458184503218804, 0.035458184503218804, 0.035458184503218804, 0.04511311126157003, 0.04511311126157003, 0.04511311126157003, 0.034545658359793396, 0.034545658359793396, 0.034545658359793396, 0.10764116793803857, 0.10764116793803857, 0.10764116793803857, 0.03996395592267021, 0.03996395592267021, 0.03996395592267021, 0.09316633655893058, 0.09316633655893058, 0.09316633655893058, 0.16215802431260895, 0.16215802431260895, 0.16215802431260895, 0.1222146745172149, 0.1222146745172149, 0.1222146745172149, 0.0920902578422017, 0.0920902578422017, 0.0920902578422017, 0.19651345991675362, 0.19651345991675362, 0.19651345991675362, 0.12433578348217911, 0.12433578348217911, 0.12433578348217911, 0.09539553508634668, 0.09539553508634668, 0.09539553508634668, 0.5086718125399792, 0.5086718125399792, 0.5086718125399792, 0.5314702773879545, 0.5314702773879545, 0.5314702773879545, 0.4878649321031966, 0.4878649321031966, 0.4878649321031966, 0.07632957733547319, 0.07632957733547319, 0.07632957733547319, 0.11293837362186054, 0.11293837362186054, 0.11293837362186054, 0.13601360652119243, 0.13601360652119243, 0.13601360652119243, 0.3444052697646517, 0.3444052697646517, 0.3444052697646517, 0.3221281142844691, 0.3221281142844691, 0.3221281142844691, 0.37841073597128805, 0.37841073597128805, 0.37841073597128805, 0.17640940862282273, 0.17640940862282273, 0.17640940862282273, 0.3793289702978102, 0.3793289702978102, 0.3793289702978102, 0.25187714231514124, 0.25187714231514124, 0.25187714231514124, 0.2112420414656485, 0.2112420414656485, 0.2112420414656485, 0.276399361574742, 0.276399361574742, 0.276399361574742, 0.18635176028029798, 0.18635176028029798, 0.18635176028029798, 0.22703313176012996, 0.22703313176012996, 0.22703313176012996, 0.23834840776683375, 0.23834840776683375, 0.23834840776683375, 0.24934833163637637, 0.24934833163637637, 0.24934833163637637, 0.2071972945245123, 0.2071972945245123, 0.2071972945245123, 0.20773380356195037, 0.20773380356195037, 0.20773380356195037, 0.19580677352267473, 0.19580677352267473, 0.19580677352267473, 0.12621569829836476, 0.12621569829836476, 0.12621569829836476, 0.8373775781974032, 0.8373775781974032, 0.8373775781974032, 0.8443845884953851, 0.8443845884953851, 0.8443845884953851, 0.6991103241376708, 0.6991103241376708, 0.6991103241376708, 0.2102787926766816, 0.2102787926766816, 0.2102787926766816, 0.09410656600294409, 0.09410656600294409, 0.09410656600294409, 0.17977103372945713, 0.17977103372945713, 0.17977103372945713, 0.190286712747316, 0.190286712747316, 0.190286712747316, 0.18681927769251017, 0.18681927769251017, 0.18681927769251017, 0.09962088570800987, 0.09962088570800987, 0.09962088570800987, 0.10951115549407786, 0.10951115549407786, 0.10951115549407786, 0.07444151678016164, 0.07444151678016164, 0.07444151678016164]}, "mutation_prompt": null}
{"id": "647156a7-7991-4ba7-8cf4-41cfa5b0e05f", "solution": "import numpy as np\n\nclass AdaptivePSOWithClamping:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp = 0.5  # Added velocity clamping for stability\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                # Clamping velocities for stability\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# adaptive_pso = AdaptivePSOWithClamping(budget=10000, dim=10)\n# adaptive_pso(func)", "name": "AdaptivePSOWithClamping", "description": "An adaptive Particle Swarm Optimization with dynamic learning rates and velocity clamping for enhanced convergence and stability.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b681cf9f-c91b-4e82-9438-8583ac44aaa1", "metadata": {"aucs": [0.7240743675152398, 0.7240743675152398, 0.7240743675152398, 0.7581995989415489, 0.7581995989415489, 0.7581995989415489, 0.7351887640610323, 0.7351887640610323, 0.7351887640610323, 0.44352084554500093, 0.44352084554500093, 0.44352084554500093, 0.43363752250815824, 0.43363752250815824, 0.43363752250815824, 0.4121633110476076, 0.4121633110476076, 0.4121633110476076, 0.11868175733987663, 0.11868175733987663, 0.11868175733987663, 0.12218337772587384, 0.12218337772587384, 0.12218337772587384, 0.11203968281063648, 0.11203968281063648, 0.11203968281063648, 0.13271798026676174, 0.13271798026676174, 0.13271798026676174, 0.11974863538435054, 0.11974863538435054, 0.11974863538435054, 0.11157782181537934, 0.11157782181537934, 0.11157782181537934, 0.93522326885522, 0.93522326885522, 0.93522326885522, 0.9376474998817406, 0.9376474998817406, 0.9376474998817406, 0.9488409059143703, 0.9488409059143703, 0.9488409059143703, 0.4292553188077104, 0.4292553188077104, 0.4292553188077104, 0.4973311608167562, 0.4973311608167562, 0.4973311608167562, 0.4807522398939025, 0.4807522398939025, 0.4807522398939025, 0.22750592706104766, 0.22750592706104766, 0.22750592706104766, 0.25970363540959607, 0.25970363540959607, 0.25970363540959607, 0.1763483580897287, 0.1763483580897287, 0.1763483580897287, 0.1275313925739332, 0.1275313925739332, 0.1275313925739332, 0.24108315784357603, 0.24108315784357603, 0.24108315784357603, 0.1939264314563618, 0.1939264314563618, 0.1939264314563618, 0.2054428514750387, 0.2054428514750387, 0.2054428514750387, 0.19985267476484359, 0.19985267476484359, 0.19985267476484359, 0.3265112564925854, 0.3265112564925854, 0.3265112564925854, 0.035458184503218804, 0.035458184503218804, 0.035458184503218804, 0.04511311126157003, 0.04511311126157003, 0.04511311126157003, 0.034545658359793396, 0.034545658359793396, 0.034545658359793396, 0.10764116793803857, 0.10764116793803857, 0.10764116793803857, 0.03996395592267021, 0.03996395592267021, 0.03996395592267021, 0.09316633655893058, 0.09316633655893058, 0.09316633655893058, 0.16215802431260895, 0.16215802431260895, 0.16215802431260895, 0.1222146745172149, 0.1222146745172149, 0.1222146745172149, 0.0920902578422017, 0.0920902578422017, 0.0920902578422017, 0.19651345991675362, 0.19651345991675362, 0.19651345991675362, 0.12433578348217911, 0.12433578348217911, 0.12433578348217911, 0.09539553508634668, 0.09539553508634668, 0.09539553508634668, 0.5086718125399792, 0.5086718125399792, 0.5086718125399792, 0.5314702773879545, 0.5314702773879545, 0.5314702773879545, 0.4878649321031966, 0.4878649321031966, 0.4878649321031966, 0.07632957733547319, 0.07632957733547319, 0.07632957733547319, 0.11293837362186054, 0.11293837362186054, 0.11293837362186054, 0.13601360652119243, 0.13601360652119243, 0.13601360652119243, 0.3444052697646517, 0.3444052697646517, 0.3444052697646517, 0.3221281142844691, 0.3221281142844691, 0.3221281142844691, 0.37841073597128805, 0.37841073597128805, 0.37841073597128805, 0.17640940862282273, 0.17640940862282273, 0.17640940862282273, 0.3793289702978102, 0.3793289702978102, 0.3793289702978102, 0.25187714231514124, 0.25187714231514124, 0.25187714231514124, 0.2112420414656485, 0.2112420414656485, 0.2112420414656485, 0.276399361574742, 0.276399361574742, 0.276399361574742, 0.18635176028029798, 0.18635176028029798, 0.18635176028029798, 0.22703313176012996, 0.22703313176012996, 0.22703313176012996, 0.23834840776683375, 0.23834840776683375, 0.23834840776683375, 0.24934833163637637, 0.24934833163637637, 0.24934833163637637, 0.2071972945245123, 0.2071972945245123, 0.2071972945245123, 0.20773380356195037, 0.20773380356195037, 0.20773380356195037, 0.19580677352267473, 0.19580677352267473, 0.19580677352267473, 0.12621569829836476, 0.12621569829836476, 0.12621569829836476, 0.8373775781974032, 0.8373775781974032, 0.8373775781974032, 0.8443845884953851, 0.8443845884953851, 0.8443845884953851, 0.6991103241376708, 0.6991103241376708, 0.6991103241376708, 0.2102787926766816, 0.2102787926766816, 0.2102787926766816, 0.09410656600294409, 0.09410656600294409, 0.09410656600294409, 0.17977103372945713, 0.17977103372945713, 0.17977103372945713, 0.190286712747316, 0.190286712747316, 0.190286712747316, 0.18681927769251017, 0.18681927769251017, 0.18681927769251017, 0.09962088570800987, 0.09962088570800987, 0.09962088570800987, 0.10951115549407786, 0.10951115549407786, 0.10951115549407786, 0.07444151678016164, 0.07444151678016164, 0.07444151678016164]}, "mutation_prompt": null}
{"id": "1860a8fe-9b1e-4f4c-9fc2-cdc70f7a75ac", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 40\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 1.2\n        self.c2_final = 2.8\n        self.velocity_clamp = 0.3  # Adjusted velocity clamping for refined control\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n\n                # Improved velocity control\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "An enhanced Particle Swarm Optimization with adaptive cognitive-social balance and improved velocity control for robust global exploration.", "configspace": "", "generation": 13, "fitness": 0.2849382209372815, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.24.", "error": "", "parent_id": "b681cf9f-c91b-4e82-9438-8583ac44aaa1", "metadata": {"aucs": [0.7580953155665429, 0.7580953155665429, 0.7580953155665429, 0.7396239650363802, 0.7396239650363802, 0.7396239650363802, 0.7615316452587819, 0.7615316452587819, 0.7615316452587819, 0.48430454521857, 0.48430454521857, 0.48430454521857, 0.45266510861810116, 0.45266510861810116, 0.45266510861810116, 0.44235588761175015, 0.44235588761175015, 0.44235588761175015, 0.0911579515446369, 0.0911579515446369, 0.0911579515446369, 0.12593359697930462, 0.12593359697930462, 0.12593359697930462, 0.09179235023846177, 0.09179235023846177, 0.09179235023846177, 0.10370873007311143, 0.10370873007311143, 0.10370873007311143, 0.1054029875692557, 0.1054029875692557, 0.1054029875692557, 0.09290921235354677, 0.09290921235354677, 0.09290921235354677, 0.8705516886999368, 0.8705516886999368, 0.8705516886999368, 0.8930159780154207, 0.8930159780154207, 0.8930159780154207, 0.8935070464690573, 0.8935070464690573, 0.8935070464690573, 0.5372077685687147, 0.5372077685687147, 0.5372077685687147, 0.550816719574883, 0.550816719574883, 0.550816719574883, 0.46947744741787634, 0.46947744741787634, 0.46947744741787634, 0.8350928787409995, 0.8350928787409995, 0.8350928787409995, 0.27467392510891253, 0.27467392510891253, 0.27467392510891253, 0.13072618253645107, 0.13072618253645107, 0.13072618253645107, 0.21120740775780855, 0.21120740775780855, 0.21120740775780855, 0.17252779795706552, 0.17252779795706552, 0.17252779795706552, 0.3353042180502045, 0.3353042180502045, 0.3353042180502045, 0.17951158732703354, 0.17951158732703354, 0.17951158732703354, 0.21857287826756655, 0.21857287826756655, 0.21857287826756655, 0.2211050158418637, 0.2211050158418637, 0.2211050158418637, 0.005378407433114796, 0.005378407433114796, 0.005378407433114796, 0.05355367403359523, 0.05355367403359523, 0.05355367403359523, 0.05143852551722339, 0.05143852551722339, 0.05143852551722339, 0.15130557703361813, 0.15130557703361813, 0.15130557703361813, 0.058220493380737204, 0.058220493380737204, 0.058220493380737204, 0.12384456228992224, 0.12384456228992224, 0.12384456228992224, 0.12395323318009666, 0.12395323318009666, 0.12395323318009666, 0.11687615067249457, 0.11687615067249457, 0.11687615067249457, 0.08379895397017312, 0.08379895397017312, 0.08379895397017312, 0.1125833680925894, 0.1125833680925894, 0.1125833680925894, 0.09012469099956977, 0.09012469099956977, 0.09012469099956977, 0.21233754338774868, 0.21233754338774868, 0.21233754338774868, 0.5015258359336972, 0.5015258359336972, 0.5015258359336972, 0.49142003923953936, 0.49142003923953936, 0.49142003923953936, 0.5306989232595719, 0.5306989232595719, 0.5306989232595719, 0.06336303174472746, 0.06336303174472746, 0.06336303174472746, 0.0763403164379699, 0.0763403164379699, 0.0763403164379699, 0.06560661060772055, 0.06560661060772055, 0.06560661060772055, 0.15774281311860017, 0.15774281311860017, 0.15774281311860017, 0.4932997966638559, 0.4932997966638559, 0.4932997966638559, 0.36623928847626663, 0.36623928847626663, 0.36623928847626663, 0.22554507648677224, 0.22554507648677224, 0.22554507648677224, 0.33955793187420036, 0.33955793187420036, 0.33955793187420036, 0.19706034271960737, 0.19706034271960737, 0.19706034271960737, 0.2075999270247033, 0.2075999270247033, 0.2075999270247033, 0.23411972776431555, 0.23411972776431555, 0.23411972776431555, 0.19228796679328597, 0.19228796679328597, 0.19228796679328597, 0.22846354532857982, 0.22846354532857982, 0.22846354532857982, 0.22896727244813175, 0.22896727244813175, 0.22896727244813175, 0.23422509875357322, 0.23422509875357322, 0.23422509875357322, 0.19706319422450447, 0.19706319422450447, 0.19706319422450447, 0.19758096317161844, 0.19758096317161844, 0.19758096317161844, 0.17362061826659558, 0.17362061826659558, 0.17362061826659558, 0.12623083965804505, 0.12623083965804505, 0.12623083965804505, 0.9074455319333752, 0.9074455319333752, 0.9074455319333752, 0.14224678810588753, 0.14224678810588753, 0.14224678810588753, 0.6029984569492153, 0.6029984569492153, 0.6029984569492153, 0.10382456105712301, 0.10382456105712301, 0.10382456105712301, 0.10446817463387448, 0.10446817463387448, 0.10446817463387448, 0.20203574451983164, 0.20203574451983164, 0.20203574451983164, 0.20657439711982695, 0.20657439711982695, 0.20657439711982695, 0.22603733606890897, 0.22603733606890897, 0.22603733606890897, 0.10062007003764051, 0.10062007003764051, 0.10062007003764051, 0.07183557001420193, 0.07183557001420193, 0.07183557001420193, 0.09271110065537502, 0.09271110065537502, 0.09271110065537502]}, "mutation_prompt": null}
{"id": "e881ab2f-b90a-4a65-938f-9dfeec3bb670", "solution": "import numpy as np\n\nclass AdaptivePSOWithClamping:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp = 0.5  # Added velocity clamping for stability\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                # Clamping velocities for stability\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# adaptive_pso = AdaptivePSOWithClamping(budget=10000, dim=10)\n# adaptive_pso(func)", "name": "AdaptivePSOWithClamping", "description": "An adaptive Particle Swarm Optimization with dynamic learning rates and velocity clamping for enhanced convergence and stability.", "configspace": "", "generation": 12, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b681cf9f-c91b-4e82-9438-8583ac44aaa1", "metadata": {"aucs": [0.7240743675152398, 0.7240743675152398, 0.7240743675152398, 0.7581995989415489, 0.7581995989415489, 0.7581995989415489, 0.7351887640610323, 0.7351887640610323, 0.7351887640610323, 0.44352084554500093, 0.44352084554500093, 0.44352084554500093, 0.43363752250815824, 0.43363752250815824, 0.43363752250815824, 0.4121633110476076, 0.4121633110476076, 0.4121633110476076, 0.11868175733987663, 0.11868175733987663, 0.11868175733987663, 0.12218337772587384, 0.12218337772587384, 0.12218337772587384, 0.11203968281063648, 0.11203968281063648, 0.11203968281063648, 0.13271798026676174, 0.13271798026676174, 0.13271798026676174, 0.11974863538435054, 0.11974863538435054, 0.11974863538435054, 0.11157782181537934, 0.11157782181537934, 0.11157782181537934, 0.93522326885522, 0.93522326885522, 0.93522326885522, 0.9376474998817406, 0.9376474998817406, 0.9376474998817406, 0.9488409059143703, 0.9488409059143703, 0.9488409059143703, 0.4292553188077104, 0.4292553188077104, 0.4292553188077104, 0.4973311608167562, 0.4973311608167562, 0.4973311608167562, 0.4807522398939025, 0.4807522398939025, 0.4807522398939025, 0.22750592706104766, 0.22750592706104766, 0.22750592706104766, 0.25970363540959607, 0.25970363540959607, 0.25970363540959607, 0.1763483580897287, 0.1763483580897287, 0.1763483580897287, 0.1275313925739332, 0.1275313925739332, 0.1275313925739332, 0.24108315784357603, 0.24108315784357603, 0.24108315784357603, 0.1939264314563618, 0.1939264314563618, 0.1939264314563618, 0.2054428514750387, 0.2054428514750387, 0.2054428514750387, 0.19985267476484359, 0.19985267476484359, 0.19985267476484359, 0.3265112564925854, 0.3265112564925854, 0.3265112564925854, 0.035458184503218804, 0.035458184503218804, 0.035458184503218804, 0.04511311126157003, 0.04511311126157003, 0.04511311126157003, 0.034545658359793396, 0.034545658359793396, 0.034545658359793396, 0.10764116793803857, 0.10764116793803857, 0.10764116793803857, 0.03996395592267021, 0.03996395592267021, 0.03996395592267021, 0.09316633655893058, 0.09316633655893058, 0.09316633655893058, 0.16215802431260895, 0.16215802431260895, 0.16215802431260895, 0.1222146745172149, 0.1222146745172149, 0.1222146745172149, 0.0920902578422017, 0.0920902578422017, 0.0920902578422017, 0.19651345991675362, 0.19651345991675362, 0.19651345991675362, 0.12433578348217911, 0.12433578348217911, 0.12433578348217911, 0.09539553508634668, 0.09539553508634668, 0.09539553508634668, 0.5086718125399792, 0.5086718125399792, 0.5086718125399792, 0.5314702773879545, 0.5314702773879545, 0.5314702773879545, 0.4878649321031966, 0.4878649321031966, 0.4878649321031966, 0.07632957733547319, 0.07632957733547319, 0.07632957733547319, 0.11293837362186054, 0.11293837362186054, 0.11293837362186054, 0.13601360652119243, 0.13601360652119243, 0.13601360652119243, 0.3444052697646517, 0.3444052697646517, 0.3444052697646517, 0.3221281142844691, 0.3221281142844691, 0.3221281142844691, 0.37841073597128805, 0.37841073597128805, 0.37841073597128805, 0.17640940862282273, 0.17640940862282273, 0.17640940862282273, 0.3793289702978102, 0.3793289702978102, 0.3793289702978102, 0.25187714231514124, 0.25187714231514124, 0.25187714231514124, 0.2112420414656485, 0.2112420414656485, 0.2112420414656485, 0.276399361574742, 0.276399361574742, 0.276399361574742, 0.18635176028029798, 0.18635176028029798, 0.18635176028029798, 0.22703313176012996, 0.22703313176012996, 0.22703313176012996, 0.23834840776683375, 0.23834840776683375, 0.23834840776683375, 0.24934833163637637, 0.24934833163637637, 0.24934833163637637, 0.2071972945245123, 0.2071972945245123, 0.2071972945245123, 0.20773380356195037, 0.20773380356195037, 0.20773380356195037, 0.19580677352267473, 0.19580677352267473, 0.19580677352267473, 0.12621569829836476, 0.12621569829836476, 0.12621569829836476, 0.8373775781974032, 0.8373775781974032, 0.8373775781974032, 0.8443845884953851, 0.8443845884953851, 0.8443845884953851, 0.6991103241376708, 0.6991103241376708, 0.6991103241376708, 0.2102787926766816, 0.2102787926766816, 0.2102787926766816, 0.09410656600294409, 0.09410656600294409, 0.09410656600294409, 0.17977103372945713, 0.17977103372945713, 0.17977103372945713, 0.190286712747316, 0.190286712747316, 0.190286712747316, 0.18681927769251017, 0.18681927769251017, 0.18681927769251017, 0.09962088570800987, 0.09962088570800987, 0.09962088570800987, 0.10951115549407786, 0.10951115549407786, 0.10951115549407786, 0.07444151678016164, 0.07444151678016164, 0.07444151678016164]}, "mutation_prompt": null}
{"id": "24c76ca1-76d3-4ee4-92e2-996b254313c0", "solution": "import numpy as np\n\nclass AdaptivePSOWithDynamicPopulation:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp = 0.5\n        self.initial_population_size = 20\n        self.max_population_size = 40\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        num_particles = self.initial_population_size\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n            # Adaptively adjust the population size\n            if evaluations < self.budget // 2:\n                num_particles = min(num_particles + 1, self.max_population_size)\n                if num_particles > positions.shape[0]:\n                    additional_positions = np.random.uniform(self.lower_bound, self.upper_bound, (1, self.dim))\n                    additional_velocities = np.random.uniform(-1, 1, (1, self.dim))\n                    positions = np.vstack((positions, additional_positions))\n                    velocities = np.vstack((velocities, additional_velocities))\n                    personal_best_positions = np.vstack((personal_best_positions, additional_positions))\n                    personal_best_scores = np.append(personal_best_scores, float('inf'))", "name": "AdaptivePSOWithDynamicPopulation", "description": "An enhanced Particle Swarm Optimization using dynamic coefficients, velocity clamping, and adaptive population size for improved convergence and flexibility.", "configspace": "", "generation": 15, "fitness": 0.2865203218920285, "feedback": "The algorithm AdaptivePSOWithDynamicPopulation got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "b681cf9f-c91b-4e82-9438-8583ac44aaa1", "metadata": {"aucs": [0.7276466691833148, 0.7276466691833148, 0.7276466691833148, 0.7037955333222614, 0.7037955333222614, 0.7037955333222614, 0.7111137361481241, 0.7111137361481241, 0.7111137361481241, 0.40176800919587097, 0.40176800919587097, 0.40176800919587097, 0.38932794890303213, 0.38932794890303213, 0.38932794890303213, 0.3994866424024214, 0.3994866424024214, 0.3994866424024214, 0.0566055017715873, 0.0566055017715873, 0.0566055017715873, 0.12506733418143134, 0.12506733418143134, 0.12506733418143134, 0.10597119531620969, 0.10597119531620969, 0.10597119531620969, 0.10577594563022485, 0.10577594563022485, 0.10577594563022485, 0.11520717814942583, 0.11520717814942583, 0.11520717814942583, 0.08955884062121022, 0.08955884062121022, 0.08955884062121022, 0.9169840967946923, 0.9169840967946923, 0.9169840967946923, 0.9079693951289276, 0.9079693951289276, 0.9079693951289276, 0.9376534326986521, 0.9376534326986521, 0.9376534326986521, 0.41903767748816345, 0.41903767748816345, 0.41903767748816345, 0.4219432349267205, 0.4219432349267205, 0.4219432349267205, 0.41143741992223626, 0.41143741992223626, 0.41143741992223626, 0.7128437725241858, 0.7128437725241858, 0.7128437725241858, 0.34511448411446977, 0.34511448411446977, 0.34511448411446977, 0.17698285638328148, 0.17698285638328148, 0.17698285638328148, 0.25289218114722334, 0.25289218114722334, 0.25289218114722334, 0.2930124023162042, 0.2930124023162042, 0.2930124023162042, 0.20473464985179968, 0.20473464985179968, 0.20473464985179968, 0.12934612386951716, 0.12934612386951716, 0.12934612386951716, 0.2148192835590823, 0.2148192835590823, 0.2148192835590823, 0.2186705487274785, 0.2186705487274785, 0.2186705487274785, 0.05037512928278143, 0.05037512928278143, 0.05037512928278143, 0.03655533085171647, 0.03655533085171647, 0.03655533085171647, 0.006838436711717577, 0.006838436711717577, 0.006838436711717577, 0.12269935442313529, 0.12269935442313529, 0.12269935442313529, 0.10131202591727173, 0.10131202591727173, 0.10131202591727173, 0.11838260528694189, 0.11838260528694189, 0.11838260528694189, 0.14829518026001787, 0.14829518026001787, 0.14829518026001787, 0.07413377862821857, 0.07413377862821857, 0.07413377862821857, 0.06857374159647589, 0.06857374159647589, 0.06857374159647589, 0.16664052291627118, 0.16664052291627118, 0.16664052291627118, 0.1668595287312319, 0.1668595287312319, 0.1668595287312319, 0.10898606620179929, 0.10898606620179929, 0.10898606620179929, 0.4830450930664101, 0.4830450930664101, 0.4830450930664101, 0.48380279727778774, 0.48380279727778774, 0.48380279727778774, 0.5287333558756159, 0.5287333558756159, 0.5287333558756159, 0.0794816629902676, 0.0794816629902676, 0.0794816629902676, 0.11786355808868776, 0.11786355808868776, 0.11786355808868776, 0.14891969412206563, 0.14891969412206563, 0.14891969412206563, 0.23695918834286622, 0.23695918834286622, 0.23695918834286622, 0.38355870258264246, 0.38355870258264246, 0.38355870258264246, 0.3375904160974781, 0.3375904160974781, 0.3375904160974781, 0.38234191669539697, 0.38234191669539697, 0.38234191669539697, 0.3794592849970533, 0.3794592849970533, 0.3794592849970533, 0.3716906450795856, 0.3716906450795856, 0.3716906450795856, 0.21734296248960705, 0.21734296248960705, 0.21734296248960705, 0.18518232959422243, 0.18518232959422243, 0.18518232959422243, 0.2365199590752166, 0.2365199590752166, 0.2365199590752166, 0.22074633182059877, 0.22074633182059877, 0.22074633182059877, 0.22408546937207396, 0.22408546937207396, 0.22408546937207396, 0.31432302548949953, 0.31432302548949953, 0.31432302548949953, 0.20363100067217432, 0.20363100067217432, 0.20363100067217432, 0.1879677493025158, 0.1879677493025158, 0.1879677493025158, 0.18909327609001747, 0.18909327609001747, 0.18909327609001747, 0.12630379778208223, 0.12630379778208223, 0.12630379778208223, 0.7041959055478256, 0.7041959055478256, 0.7041959055478256, 0.1490656522331375, 0.1490656522331375, 0.1490656522331375, 0.6014406166133983, 0.6014406166133983, 0.6014406166133983, 0.47545308387516216, 0.47545308387516216, 0.47545308387516216, 0.10513801199679107, 0.10513801199679107, 0.10513801199679107, 0.20416819858042312, 0.20416819858042312, 0.20416819858042312, 0.1960073814930613, 0.1960073814930613, 0.1960073814930613, 0.2055171200173711, 0.2055171200173711, 0.2055171200173711, 0.08841037287061715, 0.08841037287061715, 0.08841037287061715, 0.10737111946863698, 0.10737111946863698, 0.10737111946863698, 0.08963570154043232, 0.08963570154043232, 0.08963570154043232]}, "mutation_prompt": null}
{"id": "8fe25547-c68e-450a-8eb0-18b6d9b1e847", "solution": "import numpy as np\n\nclass EnhancedPSOWithSwarmRegeneration:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Modified for wider dynamic range\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.regeneration_threshold = 0.3 * self.budget  # Allowing for swarm regeneration if stuck\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        stagnation_counter = 0\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                        stagnation_counter = 0  # Reset stagnation counter\n                else:\n                    stagnation_counter += 1\n                \n                if evaluations >= self.budget:\n                    break\n\n            if stagnation_counter > self.regeneration_threshold:\n                # Swarm regeneration strategy\n                positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n                velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n                stagnation_counter = 0\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial\n            c2 = self.c2_initial\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n\n                # Remove velocity clamping for more varied exploration\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedPSOWithSwarmRegeneration(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedPSOWithSwarmRegeneration", "description": "An enhanced Particle Swarm Optimization with adaptive inertia and swarm regeneration for improved global search capability.", "configspace": "", "generation": 16, "fitness": 0.23066761618030107, "feedback": "The algorithm EnhancedPSOWithSwarmRegeneration got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.23.", "error": "", "parent_id": "b681cf9f-c91b-4e82-9438-8583ac44aaa1", "metadata": {"aucs": [0.6829211303917134, 0.6829211303917134, 0.6829211303917134, 0.708055809424107, 0.708055809424107, 0.708055809424107, 0.6888011186026699, 0.6888011186026699, 0.6888011186026699, 0.058535266730698976, 0.058535266730698976, 0.058535266730698976, 0.0314814263529144, 0.0314814263529144, 0.0314814263529144, 0.026679071856616776, 0.026679071856616776, 0.026679071856616776, 0.31976123728333605, 0.31976123728333605, 0.31976123728333605, 0.14383096530296846, 0.14383096530296846, 0.14383096530296846, 0.13998310776297362, 0.13998310776297362, 0.13998310776297362, 0.09241162667992353, 0.09241162667992353, 0.09241162667992353, 0.10036955042010287, 0.10036955042010287, 0.10036955042010287, 0.11720236721939437, 0.11720236721939437, 0.11720236721939437, 0.9932780707646197, 0.9932780707646197, 0.9932780707646197, 0.9881453063721, 0.9881453063721, 0.9881453063721, 0.9894597473876209, 0.9894597473876209, 0.9894597473876209, 0.23608292557788113, 0.23608292557788113, 0.23608292557788113, 0.14458258006658653, 0.14458258006658653, 0.14458258006658653, 0.1230890526508518, 0.1230890526508518, 0.1230890526508518, 0.17125239381240553, 0.17125239381240553, 0.17125239381240553, 0.2636645818681993, 0.2636645818681993, 0.2636645818681993, 0.12128698435926688, 0.12128698435926688, 0.12128698435926688, 0.14432850691872523, 0.14432850691872523, 0.14432850691872523, 0.13902001249961105, 0.13902001249961105, 0.13902001249961105, 0.1529320763087506, 0.1529320763087506, 0.1529320763087506, 0.16318911816635462, 0.16318911816635462, 0.16318911816635462, 0.17504501536356598, 0.17504501536356598, 0.17504501536356598, 0.08841321523797763, 0.08841321523797763, 0.08841321523797763, 0.0010095420384721443, 0.0010095420384721443, 0.0010095420384721443, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.008004800309455051, 0.008004800309455051, 0.008004800309455051, 0.08066306504051046, 0.08066306504051046, 0.08066306504051046, 0.0013934302904184959, 0.0013934302904184959, 0.0013934302904184959, 0.07407256738425183, 0.07407256738425183, 0.07407256738425183, 0.0813953223256092, 0.0813953223256092, 0.0813953223256092, 0.05558647957899887, 0.05558647957899887, 0.05558647957899887, 0.07347468048907302, 0.07347468048907302, 0.07347468048907302, 0.056455780528077204, 0.056455780528077204, 0.056455780528077204, 0.0055067125815152496, 0.0055067125815152496, 0.0055067125815152496, 0.06753682893550539, 0.06753682893550539, 0.06753682893550539, 0.4404910153928786, 0.4404910153928786, 0.4404910153928786, 0.47205714666356136, 0.47205714666356136, 0.47205714666356136, 0.4618072588772475, 0.4618072588772475, 0.4618072588772475, 0.09745587902353292, 0.09745587902353292, 0.09745587902353292, 0.09000641446304614, 0.09000641446304614, 0.09000641446304614, 0.08471209592334594, 0.08471209592334594, 0.08471209592334594, 0.21648172007468813, 0.21648172007468813, 0.21648172007468813, 0.25523327904633386, 0.25523327904633386, 0.25523327904633386, 0.24296591698227088, 0.24296591698227088, 0.24296591698227088, 0.36705136097111946, 0.36705136097111946, 0.36705136097111946, 0.3812166610242025, 0.3812166610242025, 0.3812166610242025, 0.26258126173112684, 0.26258126173112684, 0.26258126173112684, 0.19234756686039034, 0.19234756686039034, 0.19234756686039034, 0.17594828659018225, 0.17594828659018225, 0.17594828659018225, 0.20307056237697219, 0.20307056237697219, 0.20307056237697219, 0.20153143113625105, 0.20153143113625105, 0.20153143113625105, 0.19942449165757847, 0.19942449165757847, 0.19942449165757847, 0.21125979743720835, 0.21125979743720835, 0.21125979743720835, 0.20128943516128084, 0.20128943516128084, 0.20128943516128084, 0.21098833209268208, 0.21098833209268208, 0.21098833209268208, 0.37212910761141094, 0.37212910761141094, 0.37212910761141094, 0.162016528891608, 0.162016528891608, 0.162016528891608, 0.7074038642495016, 0.7074038642495016, 0.7074038642495016, 0.14074465826719484, 0.14074465826719484, 0.14074465826719484, 0.5004735746481253, 0.5004735746481253, 0.5004735746481253, 0.20723893536340587, 0.20723893536340587, 0.20723893536340587, 0.18614674454960345, 0.18614674454960345, 0.18614674454960345, 0.20315536892708563, 0.20315536892708563, 0.20315536892708563, 0.22600137074608795, 0.22600137074608795, 0.22600137074608795, 0.20293933474707282, 0.20293933474707282, 0.20293933474707282, 0.08356071512007313, 0.08356071512007313, 0.08356071512007313, 0.06746372690905633, 0.06746372690905633, 0.06746372690905633, 0.07187304658172688, 0.07187304658172688, 0.07187304658172688]}, "mutation_prompt": null}
{"id": "4951a340-da65-4b52-8f38-f71c69cc5c92", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 40\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp = 0.6  # Increased velocity clamping for more control\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))  # Start with zero velocities for stability\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                # Clamping velocities for stability\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "A dynamically self-adjusting PSO with adaptive parameters, velocity control, and enhanced exploratory capabilities.", "configspace": "", "generation": 17, "fitness": 0.29666053803521386, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "b681cf9f-c91b-4e82-9438-8583ac44aaa1", "metadata": {"aucs": [0.6691482234504929, 0.6691482234504929, 0.6691482234504929, 0.6999134884314397, 0.6999134884314397, 0.6999134884314397, 0.6921837403154976, 0.6921837403154976, 0.6921837403154976, 0.3666835387531596, 0.3666835387531596, 0.3666835387531596, 0.34914741350341794, 0.34914741350341794, 0.34914741350341794, 0.3952899285486381, 0.3952899285486381, 0.3952899285486381, 0.09286141707763651, 0.09286141707763651, 0.09286141707763651, 0.11213813183203636, 0.11213813183203636, 0.11213813183203636, 0.13641290417341878, 0.13641290417341878, 0.13641290417341878, 0.1175811484891025, 0.1175811484891025, 0.1175811484891025, 0.12582755220647557, 0.12582755220647557, 0.12582755220647557, 0.10765109805978135, 0.10765109805978135, 0.10765109805978135, 0.9317573120977979, 0.9317573120977979, 0.9317573120977979, 0.9367374874894914, 0.9367374874894914, 0.9367374874894914, 0.9429167999087797, 0.9429167999087797, 0.9429167999087797, 0.4299096179645143, 0.4299096179645143, 0.4299096179645143, 0.4239112078180769, 0.4239112078180769, 0.4239112078180769, 0.42521123837401387, 0.42521123837401387, 0.42521123837401387, 0.5996472123741106, 0.5996472123741106, 0.5996472123741106, 0.7874432414913947, 0.7874432414913947, 0.7874432414913947, 0.2306752516833659, 0.2306752516833659, 0.2306752516833659, 0.23020401464270113, 0.23020401464270113, 0.23020401464270113, 0.17814213605590157, 0.17814213605590157, 0.17814213605590157, 0.18870191403805403, 0.18870191403805403, 0.18870191403805403, 0.18016934098684956, 0.18016934098684956, 0.18016934098684956, 0.16566572672995517, 0.16566572672995517, 0.16566572672995517, 0.2295857454302176, 0.2295857454302176, 0.2295857454302176, 0.07888986111837915, 0.07888986111837915, 0.07888986111837915, 0.006734258870511489, 0.006734258870511489, 0.006734258870511489, 0.0020346146382925756, 0.0020346146382925756, 0.0020346146382925756, 0.11938799228990771, 0.11938799228990771, 0.11938799228990771, 0.08223320027753211, 0.08223320027753211, 0.08223320027753211, 0.13964790933345217, 0.13964790933345217, 0.13964790933345217, 0.11494978249012833, 0.11494978249012833, 0.11494978249012833, 0.10678997399371615, 0.10678997399371615, 0.10678997399371615, 0.11187835998039986, 0.11187835998039986, 0.11187835998039986, 0.13085438233392943, 0.13085438233392943, 0.13085438233392943, 0.1035474277094941, 0.1035474277094941, 0.1035474277094941, 0.08535444541258186, 0.08535444541258186, 0.08535444541258186, 0.5045335715237809, 0.5045335715237809, 0.5045335715237809, 0.47639896888858113, 0.47639896888858113, 0.47639896888858113, 0.5042881052748733, 0.5042881052748733, 0.5042881052748733, 0.09586890281727445, 0.09586890281727445, 0.09586890281727445, 0.09746974382884399, 0.09746974382884399, 0.09746974382884399, 0.12861861463277324, 0.12861861463277324, 0.12861861463277324, 0.30729391681585116, 0.30729391681585116, 0.30729391681585116, 0.30329404375819435, 0.30329404375819435, 0.30329404375819435, 0.3567465287104069, 0.3567465287104069, 0.3567465287104069, 0.20662853601694964, 0.20662853601694964, 0.20662853601694964, 0.3621073913008308, 0.3621073913008308, 0.3621073913008308, 0.2544565066138741, 0.2544565066138741, 0.2544565066138741, 0.23983003389814328, 0.23983003389814328, 0.23983003389814328, 0.29996707789215227, 0.29996707789215227, 0.29996707789215227, 0.21083902739507954, 0.21083902739507954, 0.21083902739507954, 0.28636257099190954, 0.28636257099190954, 0.28636257099190954, 0.24422093682725243, 0.24422093682725243, 0.24422093682725243, 0.2711769638878001, 0.2711769638878001, 0.2711769638878001, 0.1954674504191828, 0.1954674504191828, 0.1954674504191828, 0.2199548169369142, 0.2199548169369142, 0.2199548169369142, 0.1926638718330882, 0.1926638718330882, 0.1926638718330882, 0.12534497787036747, 0.12534497787036747, 0.12534497787036747, 0.8200014949200951, 0.8200014949200951, 0.8200014949200951, 0.1422246051583217, 0.1422246051583217, 0.1422246051583217, 0.5442864155034856, 0.5442864155034856, 0.5442864155034856, 0.6912778649157226, 0.6912778649157226, 0.6912778649157226, 0.6206992167501437, 0.6206992167501437, 0.6206992167501437, 0.1772127481557152, 0.1772127481557152, 0.1772127481557152, 0.1909223103976263, 0.1909223103976263, 0.1909223103976263, 0.20262078003160855, 0.20262078003160855, 0.20262078003160855, 0.08026932668097597, 0.08026932668097597, 0.08026932668097597, 0.08144114080149922, 0.08144114080149922, 0.08144114080149922, 0.09725123671143554, 0.09725123671143554, 0.09725123671143554]}, "mutation_prompt": null}
{"id": "64d6df5e-1ec6-4808-9053-ff6d130b08dc", "solution": "import numpy as np\n\nclass HybridPSOGA:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 40\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.mutation_rate = 0.1  # Mutation rate for GA component\n        self.velocity_clamp = 0.6  # Increased velocity clamping for more control\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))  # Start with zero velocities for stability\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                # Clamping velocities for stability\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n            # Genetic Algorithm-inspired crossover\n            for i in range(0, self.num_particles, 2):\n                if i+1 < self.num_particles:\n                    alpha = np.random.rand(self.dim)\n                    child1 = alpha * positions[i] + (1 - alpha) * positions[i+1]\n                    child2 = alpha * positions[i+1] + (1 - alpha) * positions[i]\n                    positions[i], positions[i+1] = child1, child2\n                    # Mutation\n                    if np.random.rand() < self.mutation_rate:\n                        mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                        positions[i] = mutation_vector\n                    if np.random.rand() < self.mutation_rate:\n                        mutation_vector = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                        positions[i+1] = mutation_vector\n\n# Usage:\n# hybrid_pso_ga = HybridPSOGA(budget=10000, dim=10)\n# hybrid_pso_ga(func)", "name": "HybridPSOGA", "description": "A hybrid PSO-GA algorithm combining dynamic particle swarm optimization with genetic algorithm-inspired crossover for enhanced exploration and exploitation.", "configspace": "", "generation": 18, "fitness": 0.2222219934483864, "feedback": "The algorithm HybridPSOGA got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.22 with standard deviation 0.21.", "error": "", "parent_id": "4951a340-da65-4b52-8f38-f71c69cc5c92", "metadata": {"aucs": [0.44294818018331417, 0.44294818018331417, 0.44294818018331417, 0.42396344326894186, 0.42396344326894186, 0.42396344326894186, 0.4207111984824875, 0.4207111984824875, 0.4207111984824875, 0.00800752800303084, 0.00800752800303084, 0.00800752800303084, 0.0008677225839807123, 0.0008677225839807123, 0.0008677225839807123, 0.0011706184359246974, 0.0011706184359246974, 0.0011706184359246974, 0.08239872404189696, 0.08239872404189696, 0.08239872404189696, 0.10985787125732549, 0.10985787125732549, 0.10985787125732549, 0.08433010276646746, 0.08433010276646746, 0.08433010276646746, 0.09106805786473593, 0.09106805786473593, 0.09106805786473593, 0.10207363293109828, 0.10207363293109828, 0.10207363293109828, 0.11678225683303023, 0.11678225683303023, 0.11678225683303023, 0.9169938906588202, 0.9169938906588202, 0.9169938906588202, 0.8874631769452225, 0.8874631769452225, 0.8874631769452225, 0.8868168612002381, 0.8868168612002381, 0.8868168612002381, 0.27095670181133324, 0.27095670181133324, 0.27095670181133324, 0.27097614791325497, 0.27097614791325497, 0.27097614791325497, 0.2822415295407579, 0.2822415295407579, 0.2822415295407579, 0.3287004945214974, 0.3287004945214974, 0.3287004945214974, 0.2730409343996941, 0.2730409343996941, 0.2730409343996941, 0.17036391020448916, 0.17036391020448916, 0.17036391020448916, 0.12178089842329243, 0.12178089842329243, 0.12178089842329243, 0.1430338613868516, 0.1430338613868516, 0.1430338613868516, 0.14934355195101268, 0.14934355195101268, 0.14934355195101268, 0.12661140764445755, 0.12661140764445755, 0.12661140764445755, 0.12556224852416398, 0.12556224852416398, 0.12556224852416398, 0.166930572905701, 0.166930572905701, 0.166930572905701, 0.025774861463671694, 0.025774861463671694, 0.025774861463671694, 0.023278931970931227, 0.023278931970931227, 0.023278931970931227, 0.01679234327656265, 0.01679234327656265, 0.01679234327656265, 0.12918528181146316, 0.12918528181146316, 0.12918528181146316, 0.08101232737878761, 0.08101232737878761, 0.08101232737878761, 0.11475614852212035, 0.11475614852212035, 0.11475614852212035, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.011650211000563293, 0.011650211000563293, 0.011650211000563293, 0.06319616496788871, 0.06319616496788871, 0.06319616496788871, 0.0538947269813298, 0.0538947269813298, 0.0538947269813298, 0.07038359577046926, 0.07038359577046926, 0.07038359577046926, 0.3896887385389094, 0.3896887385389094, 0.3896887385389094, 0.3918086279138133, 0.3918086279138133, 0.3918086279138133, 0.39238758721706535, 0.39238758721706535, 0.39238758721706535, 0.08761709517704586, 0.08761709517704586, 0.08761709517704586, 0.12112484551885094, 0.12112484551885094, 0.12112484551885094, 0.09446749494259798, 0.09446749494259798, 0.09446749494259798, 0.20325872738438244, 0.20325872738438244, 0.20325872738438244, 0.16108463501170878, 0.16108463501170878, 0.16108463501170878, 0.16001588498749442, 0.16001588498749442, 0.16001588498749442, 0.2556928061389028, 0.2556928061389028, 0.2556928061389028, 0.28176895268441293, 0.28176895268441293, 0.28176895268441293, 0.2280211180436683, 0.2280211180436683, 0.2280211180436683, 0.17061919949038762, 0.17061919949038762, 0.17061919949038762, 0.23465388458129732, 0.23465388458129732, 0.23465388458129732, 0.20329204863918748, 0.20329204863918748, 0.20329204863918748, 0.22970529318154442, 0.22970529318154442, 0.22970529318154442, 0.2172129060041107, 0.2172129060041107, 0.2172129060041107, 0.21227497575246868, 0.21227497575246868, 0.21227497575246868, 0.1784448190107376, 0.1784448190107376, 0.1784448190107376, 0.19106367621171372, 0.19106367621171372, 0.19106367621171372, 0.18371307016397864, 0.18371307016397864, 0.18371307016397864, 0.6676658053109676, 0.6676658053109676, 0.6676658053109676, 0.6257830236930577, 0.6257830236930577, 0.6257830236930577, 0.6515802473766028, 0.6515802473766028, 0.6515802473766028, 0.5050912529226783, 0.5050912529226783, 0.5050912529226783, 0.20710861106642497, 0.20710861106642497, 0.20710861106642497, 0.36604947604772875, 0.36604947604772875, 0.36604947604772875, 0.18870591948451432, 0.18870591948451432, 0.18870591948451432, 0.18402040356121874, 0.18402040356121874, 0.18402040356121874, 0.17846590954109431, 0.17846590954109431, 0.17846590954109431, 0.07744539772049319, 0.07744539772049319, 0.07744539772049319, 0.0862720706782818, 0.0862720706782818, 0.0862720706782818, 0.07875890645966888, 0.07875890645966888, 0.07875890645966888]}, "mutation_prompt": null}
{"id": "94e31cfd-e03d-40ce-ad80-ab3f1250bbe7", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 40\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp = 0.6  # Increased velocity clamping for more control\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))  # Start with zero velocities for stability\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                # Clamping velocities for stability\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "A dynamically self-adjusting PSO with adaptive parameters, velocity control, and enhanced exploratory capabilities.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4951a340-da65-4b52-8f38-f71c69cc5c92", "metadata": {"aucs": [0.6691482234504929, 0.6691482234504929, 0.6691482234504929, 0.6999134884314397, 0.6999134884314397, 0.6999134884314397, 0.6921837403154976, 0.6921837403154976, 0.6921837403154976, 0.3666835387531596, 0.3666835387531596, 0.3666835387531596, 0.34914741350341794, 0.34914741350341794, 0.34914741350341794, 0.3952899285486381, 0.3952899285486381, 0.3952899285486381, 0.09286141707763651, 0.09286141707763651, 0.09286141707763651, 0.11213813183203636, 0.11213813183203636, 0.11213813183203636, 0.13641290417341878, 0.13641290417341878, 0.13641290417341878, 0.1175811484891025, 0.1175811484891025, 0.1175811484891025, 0.12582755220647557, 0.12582755220647557, 0.12582755220647557, 0.10765109805978135, 0.10765109805978135, 0.10765109805978135, 0.9317573120977979, 0.9317573120977979, 0.9317573120977979, 0.9367374874894914, 0.9367374874894914, 0.9367374874894914, 0.9429167999087797, 0.9429167999087797, 0.9429167999087797, 0.4299096179645143, 0.4299096179645143, 0.4299096179645143, 0.4239112078180769, 0.4239112078180769, 0.4239112078180769, 0.42521123837401387, 0.42521123837401387, 0.42521123837401387, 0.5996472123741106, 0.5996472123741106, 0.5996472123741106, 0.7874432414913947, 0.7874432414913947, 0.7874432414913947, 0.2306752516833659, 0.2306752516833659, 0.2306752516833659, 0.23020401464270113, 0.23020401464270113, 0.23020401464270113, 0.17814213605590157, 0.17814213605590157, 0.17814213605590157, 0.18870191403805403, 0.18870191403805403, 0.18870191403805403, 0.18016934098684956, 0.18016934098684956, 0.18016934098684956, 0.16566572672995517, 0.16566572672995517, 0.16566572672995517, 0.2295857454302176, 0.2295857454302176, 0.2295857454302176, 0.07888986111837915, 0.07888986111837915, 0.07888986111837915, 0.006734258870511489, 0.006734258870511489, 0.006734258870511489, 0.0020346146382925756, 0.0020346146382925756, 0.0020346146382925756, 0.11938799228990771, 0.11938799228990771, 0.11938799228990771, 0.08223320027753211, 0.08223320027753211, 0.08223320027753211, 0.13964790933345217, 0.13964790933345217, 0.13964790933345217, 0.11494978249012833, 0.11494978249012833, 0.11494978249012833, 0.10678997399371615, 0.10678997399371615, 0.10678997399371615, 0.11187835998039986, 0.11187835998039986, 0.11187835998039986, 0.13085438233392943, 0.13085438233392943, 0.13085438233392943, 0.1035474277094941, 0.1035474277094941, 0.1035474277094941, 0.08535444541258186, 0.08535444541258186, 0.08535444541258186, 0.5045335715237809, 0.5045335715237809, 0.5045335715237809, 0.47639896888858113, 0.47639896888858113, 0.47639896888858113, 0.5042881052748733, 0.5042881052748733, 0.5042881052748733, 0.09586890281727445, 0.09586890281727445, 0.09586890281727445, 0.09746974382884399, 0.09746974382884399, 0.09746974382884399, 0.12861861463277324, 0.12861861463277324, 0.12861861463277324, 0.30729391681585116, 0.30729391681585116, 0.30729391681585116, 0.30329404375819435, 0.30329404375819435, 0.30329404375819435, 0.3567465287104069, 0.3567465287104069, 0.3567465287104069, 0.20662853601694964, 0.20662853601694964, 0.20662853601694964, 0.3621073913008308, 0.3621073913008308, 0.3621073913008308, 0.2544565066138741, 0.2544565066138741, 0.2544565066138741, 0.23983003389814328, 0.23983003389814328, 0.23983003389814328, 0.29996707789215227, 0.29996707789215227, 0.29996707789215227, 0.21083902739507954, 0.21083902739507954, 0.21083902739507954, 0.28636257099190954, 0.28636257099190954, 0.28636257099190954, 0.24422093682725243, 0.24422093682725243, 0.24422093682725243, 0.2711769638878001, 0.2711769638878001, 0.2711769638878001, 0.1954674504191828, 0.1954674504191828, 0.1954674504191828, 0.2199548169369142, 0.2199548169369142, 0.2199548169369142, 0.1926638718330882, 0.1926638718330882, 0.1926638718330882, 0.12534497787036747, 0.12534497787036747, 0.12534497787036747, 0.8200014949200951, 0.8200014949200951, 0.8200014949200951, 0.1422246051583217, 0.1422246051583217, 0.1422246051583217, 0.5442864155034856, 0.5442864155034856, 0.5442864155034856, 0.6912778649157226, 0.6912778649157226, 0.6912778649157226, 0.6206992167501437, 0.6206992167501437, 0.6206992167501437, 0.1772127481557152, 0.1772127481557152, 0.1772127481557152, 0.1909223103976263, 0.1909223103976263, 0.1909223103976263, 0.20262078003160855, 0.20262078003160855, 0.20262078003160855, 0.08026932668097597, 0.08026932668097597, 0.08026932668097597, 0.08144114080149922, 0.08144114080149922, 0.08144114080149922, 0.09725123671143554, 0.09725123671143554, 0.09725123671143554]}, "mutation_prompt": null}
{"id": "a186f9d1-7b67-4933-b718-9c51d305de91", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 40\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp = 0.6  # Increased velocity clamping for more control\n    \n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))  # Start with zero velocities for stability\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                # Clamping velocities for stability\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "A dynamically self-adjusting PSO with adaptive parameters, velocity control, and enhanced exploratory capabilities.", "configspace": "", "generation": 18, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "4951a340-da65-4b52-8f38-f71c69cc5c92", "metadata": {"aucs": [0.6691482234504929, 0.6691482234504929, 0.6691482234504929, 0.6999134884314397, 0.6999134884314397, 0.6999134884314397, 0.6921837403154976, 0.6921837403154976, 0.6921837403154976, 0.3666835387531596, 0.3666835387531596, 0.3666835387531596, 0.34914741350341794, 0.34914741350341794, 0.34914741350341794, 0.3952899285486381, 0.3952899285486381, 0.3952899285486381, 0.09286141707763651, 0.09286141707763651, 0.09286141707763651, 0.11213813183203636, 0.11213813183203636, 0.11213813183203636, 0.13641290417341878, 0.13641290417341878, 0.13641290417341878, 0.1175811484891025, 0.1175811484891025, 0.1175811484891025, 0.12582755220647557, 0.12582755220647557, 0.12582755220647557, 0.10765109805978135, 0.10765109805978135, 0.10765109805978135, 0.9317573120977979, 0.9317573120977979, 0.9317573120977979, 0.9367374874894914, 0.9367374874894914, 0.9367374874894914, 0.9429167999087797, 0.9429167999087797, 0.9429167999087797, 0.4299096179645143, 0.4299096179645143, 0.4299096179645143, 0.4239112078180769, 0.4239112078180769, 0.4239112078180769, 0.42521123837401387, 0.42521123837401387, 0.42521123837401387, 0.5996472123741106, 0.5996472123741106, 0.5996472123741106, 0.7874432414913947, 0.7874432414913947, 0.7874432414913947, 0.2306752516833659, 0.2306752516833659, 0.2306752516833659, 0.23020401464270113, 0.23020401464270113, 0.23020401464270113, 0.17814213605590157, 0.17814213605590157, 0.17814213605590157, 0.18870191403805403, 0.18870191403805403, 0.18870191403805403, 0.18016934098684956, 0.18016934098684956, 0.18016934098684956, 0.16566572672995517, 0.16566572672995517, 0.16566572672995517, 0.2295857454302176, 0.2295857454302176, 0.2295857454302176, 0.07888986111837915, 0.07888986111837915, 0.07888986111837915, 0.006734258870511489, 0.006734258870511489, 0.006734258870511489, 0.0020346146382925756, 0.0020346146382925756, 0.0020346146382925756, 0.11938799228990771, 0.11938799228990771, 0.11938799228990771, 0.08223320027753211, 0.08223320027753211, 0.08223320027753211, 0.13964790933345217, 0.13964790933345217, 0.13964790933345217, 0.11494978249012833, 0.11494978249012833, 0.11494978249012833, 0.10678997399371615, 0.10678997399371615, 0.10678997399371615, 0.11187835998039986, 0.11187835998039986, 0.11187835998039986, 0.13085438233392943, 0.13085438233392943, 0.13085438233392943, 0.1035474277094941, 0.1035474277094941, 0.1035474277094941, 0.08535444541258186, 0.08535444541258186, 0.08535444541258186, 0.5045335715237809, 0.5045335715237809, 0.5045335715237809, 0.47639896888858113, 0.47639896888858113, 0.47639896888858113, 0.5042881052748733, 0.5042881052748733, 0.5042881052748733, 0.09586890281727445, 0.09586890281727445, 0.09586890281727445, 0.09746974382884399, 0.09746974382884399, 0.09746974382884399, 0.12861861463277324, 0.12861861463277324, 0.12861861463277324, 0.30729391681585116, 0.30729391681585116, 0.30729391681585116, 0.30329404375819435, 0.30329404375819435, 0.30329404375819435, 0.3567465287104069, 0.3567465287104069, 0.3567465287104069, 0.20662853601694964, 0.20662853601694964, 0.20662853601694964, 0.3621073913008308, 0.3621073913008308, 0.3621073913008308, 0.2544565066138741, 0.2544565066138741, 0.2544565066138741, 0.23983003389814328, 0.23983003389814328, 0.23983003389814328, 0.29996707789215227, 0.29996707789215227, 0.29996707789215227, 0.21083902739507954, 0.21083902739507954, 0.21083902739507954, 0.28636257099190954, 0.28636257099190954, 0.28636257099190954, 0.24422093682725243, 0.24422093682725243, 0.24422093682725243, 0.2711769638878001, 0.2711769638878001, 0.2711769638878001, 0.1954674504191828, 0.1954674504191828, 0.1954674504191828, 0.2199548169369142, 0.2199548169369142, 0.2199548169369142, 0.1926638718330882, 0.1926638718330882, 0.1926638718330882, 0.12534497787036747, 0.12534497787036747, 0.12534497787036747, 0.8200014949200951, 0.8200014949200951, 0.8200014949200951, 0.1422246051583217, 0.1422246051583217, 0.1422246051583217, 0.5442864155034856, 0.5442864155034856, 0.5442864155034856, 0.6912778649157226, 0.6912778649157226, 0.6912778649157226, 0.6206992167501437, 0.6206992167501437, 0.6206992167501437, 0.1772127481557152, 0.1772127481557152, 0.1772127481557152, 0.1909223103976263, 0.1909223103976263, 0.1909223103976263, 0.20262078003160855, 0.20262078003160855, 0.20262078003160855, 0.08026932668097597, 0.08026932668097597, 0.08026932668097597, 0.08144114080149922, 0.08144114080149922, 0.08144114080149922, 0.09725123671143554, 0.09725123671143554, 0.09725123671143554]}, "mutation_prompt": null}
{"id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50  # Increased the number of particles for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.3  # Slightly decreased minimum inertia weight for more exploitation\n        self.c1_initial = 2.0  # Adjusted cognitive factor to balance exploration\n        self.c2_initial = 1.5\n        self.c1_final = 1.2\n        self.c2_final = 2.8  # Increased social factor to enhance convergence towards the global best\n        self.velocity_clamp = 0.5  # Fine-tuned velocity clamping for dynamic control\n        self.local_search_probability = 0.1  # Probability to perform local search\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_pso = HybridAdaptivePSO(budget=10000, dim=10)\n# hybrid_pso(func)", "name": "HybridAdaptivePSO", "description": "A hybrid Particle Swarm Optimization with adaptive learning rates and local search integration to improve convergence on diverse optimization landscapes.", "configspace": "", "generation": 21, "fitness": 0.31150096387517473, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "4951a340-da65-4b52-8f38-f71c69cc5c92", "metadata": {"aucs": [0.7363787569756914, 0.7363787569756914, 0.7363787569756914, 0.7248797351275806, 0.7248797351275806, 0.7248797351275806, 0.7320364224996398, 0.7320364224996398, 0.7320364224996398, 0.4264638157865718, 0.4264638157865718, 0.4264638157865718, 0.38691623948681053, 0.38691623948681053, 0.38691623948681053, 0.41698839053177394, 0.41698839053177394, 0.41698839053177394, 0.12261860398177582, 0.12261860398177582, 0.12261860398177582, 0.11156532513319706, 0.11156532513319706, 0.11156532513319706, 0.08788151331308347, 0.08788151331308347, 0.08788151331308347, 0.10651128418585709, 0.10651128418585709, 0.10651128418585709, 0.09659488949347816, 0.09659488949347816, 0.09659488949347816, 0.1346237296608187, 0.1346237296608187, 0.1346237296608187, 0.9014366062710284, 0.9014366062710284, 0.9014366062710284, 0.8971553584584812, 0.8971553584584812, 0.8971553584584812, 0.9014983066838862, 0.9014983066838862, 0.9014983066838862, 0.4798998754207935, 0.4798998754207935, 0.4798998754207935, 0.4599245109364033, 0.4599245109364033, 0.4599245109364033, 0.44489143323641256, 0.44489143323641256, 0.44489143323641256, 0.6706209042544029, 0.6706209042544029, 0.6706209042544029, 0.33481533490178506, 0.33481533490178506, 0.33481533490178506, 0.17523123873603275, 0.17523123873603275, 0.17523123873603275, 0.16914205391684578, 0.16914205391684578, 0.16914205391684578, 0.17791508121830957, 0.17791508121830957, 0.17791508121830957, 0.21005890262746496, 0.21005890262746496, 0.21005890262746496, 0.21622629173752894, 0.21622629173752894, 0.21622629173752894, 0.1930167037278243, 0.1930167037278243, 0.1930167037278243, 0.21472650847827268, 0.21472650847827268, 0.21472650847827268, 0.011404059391924237, 0.011404059391924237, 0.011404059391924237, 0.05498457960622105, 0.05498457960622105, 0.05498457960622105, 0.047344660209236444, 0.047344660209236444, 0.047344660209236444, 0.15840755276186025, 0.15840755276186025, 0.15840755276186025, 0.060778372540811865, 0.060778372540811865, 0.060778372540811865, 0.1149423457569465, 0.1149423457569465, 0.1149423457569465, 0.1442004380158607, 0.1442004380158607, 0.1442004380158607, 0.10334869933839541, 0.10334869933839541, 0.10334869933839541, 0.08849045277333478, 0.08849045277333478, 0.08849045277333478, 0.14165130137532556, 0.14165130137532556, 0.14165130137532556, 0.11177129605748837, 0.11177129605748837, 0.11177129605748837, 0.2349719227552225, 0.2349719227552225, 0.2349719227552225, 0.5253449795549913, 0.5253449795549913, 0.5253449795549913, 0.5208999142777505, 0.5208999142777505, 0.5208999142777505, 0.5746371427506808, 0.5746371427506808, 0.5746371427506808, 0.08318526480172461, 0.08318526480172461, 0.08318526480172461, 0.10065913333963017, 0.10065913333963017, 0.10065913333963017, 0.12086284224136468, 0.12086284224136468, 0.12086284224136468, 0.18766825428095968, 0.18766825428095968, 0.18766825428095968, 0.2722427200946341, 0.2722427200946341, 0.2722427200946341, 0.3251598686665236, 0.3251598686665236, 0.3251598686665236, 0.3595194756743736, 0.3595194756743736, 0.3595194756743736, 0.33965427888589905, 0.33965427888589905, 0.33965427888589905, 0.3926123993036492, 0.3926123993036492, 0.3926123993036492, 0.26690668237644966, 0.26690668237644966, 0.26690668237644966, 0.28850093696636514, 0.28850093696636514, 0.28850093696636514, 0.23995473009435309, 0.23995473009435309, 0.23995473009435309, 0.23301214223822142, 0.23301214223822142, 0.23301214223822142, 0.22030669105200829, 0.22030669105200829, 0.22030669105200829, 0.21429760099972994, 0.21429760099972994, 0.21429760099972994, 0.20808215448800904, 0.20808215448800904, 0.20808215448800904, 0.6002689972967836, 0.6002689972967836, 0.6002689972967836, 0.1760182450436587, 0.1760182450436587, 0.1760182450436587, 0.7956418751867436, 0.7956418751867436, 0.7956418751867436, 0.8495921256228233, 0.8495921256228233, 0.8495921256228233, 0.14214484108439374, 0.14214484108439374, 0.14214484108439374, 0.5530757710655174, 0.5530757710655174, 0.5530757710655174, 0.6481181363384939, 0.6481181363384939, 0.6481181363384939, 0.5517096457507537, 0.5517096457507537, 0.5517096457507537, 0.19328283834327575, 0.19328283834327575, 0.19328283834327575, 0.18635375112452934, 0.18635375112452934, 0.18635375112452934, 0.17704971370179734, 0.17704971370179734, 0.17704971370179734, 0.0909755053691772, 0.0909755053691772, 0.0909755053691772, 0.11204996742785167, 0.11204996742785167, 0.11204996742785167, 0.07596727620508614, 0.07596727620508614, 0.07596727620508614]}, "mutation_prompt": null}
{"id": "07229583-035f-4f71-8492-f22d9df26209", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4  # Slightly increased minimum inertia weight for more consistent exploration\n        self.c1_initial = 1.8  # Fine-tuned cognitive factor for slightly improved personal best influence\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Further increased social factor for stronger convergence pull\n        self.velocity_clamp = 0.4  # Adjusted velocity clamping for better control\n        self.local_search_probability = 0.15  # Increased probability to perform local search\n        self.alpha = 1.5  # Parameter for Lévy flight distribution\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    # Lévy flight perturbation\n                    levy_flight = np.random.standard_cauchy(self.dim) * np.power(np.random.uniform(0, 1, self.dim), -1/self.alpha)\n                    candidate_position = positions[i] + levy_flight\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_pso = HybridAdaptivePSO(budget=10000, dim=10)\n# hybrid_pso(func)", "name": "HybridAdaptivePSO", "description": "A hybrid Particle Swarm Optimization with adaptive learning rates and Lévy flight local search for enhanced exploration and convergence.", "configspace": "", "generation": 22, "fitness": 0.2823287106305743, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7247308576567948, 0.7247308576567948, 0.7247308576567948, 0.7215710790168656, 0.7215710790168656, 0.7215710790168656, 0.7147890551598215, 0.7147890551598215, 0.7147890551598215, 0.34597941186854697, 0.34597941186854697, 0.34597941186854697, 0.3760337260249247, 0.3760337260249247, 0.3760337260249247, 0.35879061523223077, 0.35879061523223077, 0.35879061523223077, 0.1057040362068421, 0.1057040362068421, 0.1057040362068421, 0.13685421545081244, 0.13685421545081244, 0.13685421545081244, 0.09780240338308432, 0.09780240338308432, 0.09780240338308432, 0.14370584726149027, 0.14370584726149027, 0.14370584726149027, 0.07633240435985822, 0.07633240435985822, 0.07633240435985822, 0.1133170280734217, 0.1133170280734217, 0.1133170280734217, 0.9314673292295379, 0.9314673292295379, 0.9314673292295379, 0.9193807125684959, 0.9193807125684959, 0.9193807125684959, 0.9279089793520805, 0.9279089793520805, 0.9279089793520805, 0.45879296878177234, 0.45879296878177234, 0.45879296878177234, 0.47383512132469396, 0.47383512132469396, 0.47383512132469396, 0.42948522436583336, 0.42948522436583336, 0.42948522436583336, 0.3736689131416604, 0.3736689131416604, 0.3736689131416604, 0.21096882132546313, 0.21096882132546313, 0.21096882132546313, 0.17470074186508422, 0.17470074186508422, 0.17470074186508422, 0.18286339101940652, 0.18286339101940652, 0.18286339101940652, 0.17743972860941903, 0.17743972860941903, 0.17743972860941903, 0.20932888525886206, 0.20932888525886206, 0.20932888525886206, 0.1848269984453631, 0.1848269984453631, 0.1848269984453631, 0.1890831911129155, 0.1890831911129155, 0.1890831911129155, 0.22499590284423465, 0.22499590284423465, 0.22499590284423465, 0.021830292541965335, 0.021830292541965335, 0.021830292541965335, 0.00043959749144084626, 0.00043959749144084626, 0.00043959749144084626, 0.08331772079272526, 0.08331772079272526, 0.08331772079272526, 0.09147733976289474, 0.09147733976289474, 0.09147733976289474, 0.09109252460733919, 0.09109252460733919, 0.09109252460733919, 0.1670379515850191, 0.1670379515850191, 0.1670379515850191, 0.07337290851142464, 0.07337290851142464, 0.07337290851142464, 0.07206276665587086, 0.07206276665587086, 0.07206276665587086, 0.09057204171344346, 0.09057204171344346, 0.09057204171344346, 0.10970648799602478, 0.10970648799602478, 0.10970648799602478, 0.06827618763276277, 0.06827618763276277, 0.06827618763276277, 0.17352370441472798, 0.17352370441472798, 0.17352370441472798, 0.4787762813616443, 0.4787762813616443, 0.4787762813616443, 0.5081358052002755, 0.5081358052002755, 0.5081358052002755, 0.5338452170786717, 0.5338452170786717, 0.5338452170786717, 0.08586709925441227, 0.08586709925441227, 0.08586709925441227, 0.13633664674779034, 0.13633664674779034, 0.13633664674779034, 0.10848972994375494, 0.10848972994375494, 0.10848972994375494, 0.17424840413870424, 0.17424840413870424, 0.17424840413870424, 0.17375558426140192, 0.17375558426140192, 0.17375558426140192, 0.3150188879653385, 0.3150188879653385, 0.3150188879653385, 0.21738213843312826, 0.21738213843312826, 0.21738213843312826, 0.37115382343634185, 0.37115382343634185, 0.37115382343634185, 0.24770260434474134, 0.24770260434474134, 0.24770260434474134, 0.19287199675147282, 0.19287199675147282, 0.19287199675147282, 0.22593788072753485, 0.22593788072753485, 0.22593788072753485, 0.2138971108093366, 0.2138971108093366, 0.2138971108093366, 0.2668054896577676, 0.2668054896577676, 0.2668054896577676, 0.21926365231273404, 0.21926365231273404, 0.21926365231273404, 0.23784364967331895, 0.23784364967331895, 0.23784364967331895, 0.19771430175041638, 0.19771430175041638, 0.19771430175041638, 0.17992468521334282, 0.17992468521334282, 0.17992468521334282, 0.19012878991915427, 0.19012878991915427, 0.19012878991915427, 0.12504358143238337, 0.12504358143238337, 0.12504358143238337, 0.8451477632740025, 0.8451477632740025, 0.8451477632740025, 0.6674055438875168, 0.6674055438875168, 0.6674055438875168, 0.6027832286864698, 0.6027832286864698, 0.6027832286864698, 0.7634672068623763, 0.7634672068623763, 0.7634672068623763, 0.166825565627849, 0.166825565627849, 0.166825565627849, 0.20072108348692064, 0.20072108348692064, 0.20072108348692064, 0.19807436863701888, 0.19807436863701888, 0.19807436863701888, 0.20103532836175586, 0.20103532836175586, 0.20103532836175586, 0.10332656703522392, 0.10332656703522392, 0.10332656703522392, 0.08408145507765608, 0.08408145507765608, 0.08408145507765608, 0.06758858140574064, 0.06758858140574064, 0.06758858140574064]}, "mutation_prompt": null}
{"id": "76451b6d-39da-48e1-b2b3-91c53e1e0e74", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # More particles for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.85\n        self.w_min = 0.4  # Adjusted for better balance between exploration and exploitation\n        self.c1_initial = 1.5  # Balanced cognitive factor for reduced self-reliance\n        self.c2_initial = 2.0\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Increased emphasis on social learning over time\n        self.velocity_clamp = 0.6  # Adjusted velocity clamping for broader search space traversal\n        self.neighborhood_search_probability = 0.15  # Probability to perform neighborhood search\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.neighborhood_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)  # Larger perturbation for neighborhood exploration\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptivePSO", "description": "An enhanced Particle Swarm Optimization with adaptive velocity reduction and stochastic neighborhood exploration for improved global search efficiency.", "configspace": "", "generation": 23, "fitness": 0.2816282562757613, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6685146040644897, 0.6685146040644897, 0.6685146040644897, 0.7156752448440546, 0.7156752448440546, 0.7156752448440546, 0.6665644818629666, 0.6665644818629666, 0.6665644818629666, 0.2887111283150383, 0.2887111283150383, 0.2887111283150383, 0.2906987274457663, 0.2906987274457663, 0.2906987274457663, 0.3314467399359855, 0.3314467399359855, 0.3314467399359855, 0.13995153437517727, 0.13995153437517727, 0.13995153437517727, 0.11015199421074118, 0.11015199421074118, 0.11015199421074118, 0.13635892569062058, 0.13635892569062058, 0.13635892569062058, 0.09894142009673745, 0.09894142009673745, 0.09894142009673745, 0.1140669945282512, 0.1140669945282512, 0.1140669945282512, 0.13763512197059047, 0.13763512197059047, 0.13763512197059047, 0.8948924751153111, 0.8948924751153111, 0.8948924751153111, 0.8842472133895021, 0.8842472133895021, 0.8842472133895021, 0.9016801423896998, 0.9016801423896998, 0.9016801423896998, 0.4163390515792381, 0.4163390515792381, 0.4163390515792381, 0.4410473665803012, 0.4410473665803012, 0.4410473665803012, 0.37267347002796425, 0.37267347002796425, 0.37267347002796425, 0.6620757587543971, 0.6620757587543971, 0.6620757587543971, 0.787409452046238, 0.787409452046238, 0.787409452046238, 0.17528081415516916, 0.17528081415516916, 0.17528081415516916, 0.20674853704543217, 0.20674853704543217, 0.20674853704543217, 0.18746883110293389, 0.18746883110293389, 0.18746883110293389, 0.17303285093527898, 0.17303285093527898, 0.17303285093527898, 0.21928997732671263, 0.21928997732671263, 0.21928997732671263, 0.18187941826584175, 0.18187941826584175, 0.18187941826584175, 0.2075037853412358, 0.2075037853412358, 0.2075037853412358, 0.008272872068664228, 0.008272872068664228, 0.008272872068664228, 0.07829864688900412, 0.07829864688900412, 0.07829864688900412, 0.028488009060517072, 0.028488009060517072, 0.028488009060517072, 0.14927239063030762, 0.14927239063030762, 0.14927239063030762, 0.07435236131129186, 0.07435236131129186, 0.07435236131129186, 0.15330308321403996, 0.15330308321403996, 0.15330308321403996, 0.12904570452825703, 0.12904570452825703, 0.12904570452825703, 0.08213108678863568, 0.08213108678863568, 0.08213108678863568, 0.10506253339540339, 0.10506253339540339, 0.10506253339540339, 0.20374102322027154, 0.20374102322027154, 0.20374102322027154, 0.08057312261453353, 0.08057312261453353, 0.08057312261453353, 0.11244492352569047, 0.11244492352569047, 0.11244492352569047, 0.4695638335629977, 0.4695638335629977, 0.4695638335629977, 0.49429836447760134, 0.49429836447760134, 0.49429836447760134, 0.4796727894917119, 0.4796727894917119, 0.4796727894917119, 0.16991692083871912, 0.16991692083871912, 0.16991692083871912, 0.14909166199553237, 0.14909166199553237, 0.14909166199553237, 0.0934264165911356, 0.0934264165911356, 0.0934264165911356, 0.16699822404106357, 0.16699822404106357, 0.16699822404106357, 0.23961044497214956, 0.23961044497214956, 0.23961044497214956, 0.2732060113419844, 0.2732060113419844, 0.2732060113419844, 0.31106968360200493, 0.31106968360200493, 0.31106968360200493, 0.30442180759931947, 0.30442180759931947, 0.30442180759931947, 0.2330862237618483, 0.2330862237618483, 0.2330862237618483, 0.2504554404682695, 0.2504554404682695, 0.2504554404682695, 0.24134855209888773, 0.24134855209888773, 0.24134855209888773, 0.211620324402098, 0.211620324402098, 0.211620324402098, 0.20973043466181995, 0.20973043466181995, 0.20973043466181995, 0.21113276189997565, 0.21113276189997565, 0.21113276189997565, 0.23878703061454853, 0.23878703061454853, 0.23878703061454853, 0.1841267375532265, 0.1841267375532265, 0.1841267375532265, 0.2398680376740121, 0.2398680376740121, 0.2398680376740121, 0.1859811245710994, 0.1859811245710994, 0.1859811245710994, 0.1250584461921933, 0.1250584461921933, 0.1250584461921933, 0.8158540957282949, 0.8158540957282949, 0.8158540957282949, 0.14182336345476088, 0.14182336345476088, 0.14182336345476088, 0.6449678465179118, 0.6449678465179118, 0.6449678465179118, 0.20921626532452098, 0.20921626532452098, 0.20921626532452098, 0.5169865300692105, 0.5169865300692105, 0.5169865300692105, 0.18390004768799906, 0.18390004768799906, 0.18390004768799906, 0.19294060165155769, 0.19294060165155769, 0.19294060165155769, 0.19075752264788237, 0.19075752264788237, 0.19075752264788237, 0.09705343429660829, 0.09705343429660829, 0.09705343429660829, 0.09384462030551188, 0.09384462030551188, 0.09384462030551188, 0.09214703311606809, 0.09214703311606809, 0.09214703311606809]}, "mutation_prompt": null}
{"id": "23f30f0e-edc9-4a57-aa1b-12b4820d3fe5", "solution": "import numpy as np\n\nclass EnhancedChaoticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased particle count for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.85\n        self.w_min = 0.4  # Adjusted inertia range for adaptive exploration-exploitation balance\n        self.c1_initial = 1.8  # Balancing cognitive factor for better individual search\n        self.c2_initial = 1.6\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Enhanced social factor for stronger convergence\n        self.velocity_clamp = 0.6  # Adjusted velocity clamping for better control\n        self.local_search_probability = 0.15  # Higher probability for local search\n        self.chaos_coefficient = 0.02  # Chaotic perturbation factor\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    chaos_perturbation = np.random.uniform(-self.chaos_coefficient, self.chaos_coefficient, self.dim)\n                    candidate_position = positions[i] + chaos_perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedChaoticPSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedChaoticPSO", "description": "An enhanced Particle Swarm Optimization with adaptive parameters and chaotic local search to improve performance across diverse optimization landscapes.", "configspace": "", "generation": 24, "fitness": 0.2836492544208634, "feedback": "The algorithm EnhancedChaoticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6899866844722977, 0.6899866844722977, 0.6899866844722977, 0.6995013620809718, 0.6995013620809718, 0.6995013620809718, 0.7073240279614442, 0.7073240279614442, 0.7073240279614442, 0.3617720163835696, 0.3617720163835696, 0.3617720163835696, 0.2945935832185326, 0.2945935832185326, 0.2945935832185326, 0.33296705891549483, 0.33296705891549483, 0.33296705891549483, 0.13191936994969888, 0.13191936994969888, 0.13191936994969888, 0.10980845549755835, 0.10980845549755835, 0.10980845549755835, 0.1625100399684405, 0.1625100399684405, 0.1625100399684405, 0.10446156860971534, 0.10446156860971534, 0.10446156860971534, 0.11118538609441986, 0.11118538609441986, 0.11118538609441986, 0.10684504258718353, 0.10684504258718353, 0.10684504258718353, 0.8754424848232605, 0.8754424848232605, 0.8754424848232605, 0.8895572700892358, 0.8895572700892358, 0.8895572700892358, 0.8894482584122709, 0.8894482584122709, 0.8894482584122709, 0.46036250536794854, 0.46036250536794854, 0.46036250536794854, 0.41309767991843094, 0.41309767991843094, 0.41309767991843094, 0.375358499162866, 0.375358499162866, 0.375358499162866, 0.6211100548225609, 0.6211100548225609, 0.6211100548225609, 0.5519065533351405, 0.5519065533351405, 0.5519065533351405, 0.2186780712301558, 0.2186780712301558, 0.2186780712301558, 0.12257661859845226, 0.12257661859845226, 0.12257661859845226, 0.18439123275305902, 0.18439123275305902, 0.18439123275305902, 0.19028489097036227, 0.19028489097036227, 0.19028489097036227, 0.1982280284092499, 0.1982280284092499, 0.1982280284092499, 0.1813738224781356, 0.1813738224781356, 0.1813738224781356, 0.2254106583823725, 0.2254106583823725, 0.2254106583823725, 0.009833534531172305, 0.009833534531172305, 0.009833534531172305, 0.043425544059876975, 0.043425544059876975, 0.043425544059876975, 0.005171142323439737, 0.005171142323439737, 0.005171142323439737, 0.2330430566976418, 0.2330430566976418, 0.2330430566976418, 0.06931229755408508, 0.06931229755408508, 0.06931229755408508, 0.08826302452840007, 0.08826302452840007, 0.08826302452840007, 0.10700484020848, 0.10700484020848, 0.10700484020848, 0.10410289962896035, 0.10410289962896035, 0.10410289962896035, 0.09338926062489517, 0.09338926062489517, 0.09338926062489517, 0.11345007256948925, 0.11345007256948925, 0.11345007256948925, 0.07311932873041738, 0.07311932873041738, 0.07311932873041738, 0.13764316142526567, 0.13764316142526567, 0.13764316142526567, 0.4846971408327364, 0.4846971408327364, 0.4846971408327364, 0.4987616083872074, 0.4987616083872074, 0.4987616083872074, 0.5078691101083384, 0.5078691101083384, 0.5078691101083384, 0.0930734573990083, 0.0930734573990083, 0.0930734573990083, 0.07931664025073115, 0.07931664025073115, 0.07931664025073115, 0.1277516649659448, 0.1277516649659448, 0.1277516649659448, 0.2647374906345813, 0.2647374906345813, 0.2647374906345813, 0.2239769612063599, 0.2239769612063599, 0.2239769612063599, 0.1838314973969435, 0.1838314973969435, 0.1838314973969435, 0.37504271698967107, 0.37504271698967107, 0.37504271698967107, 0.36958175576123753, 0.36958175576123753, 0.36958175576123753, 0.4210413370460556, 0.4210413370460556, 0.4210413370460556, 0.1903774924837941, 0.1903774924837941, 0.1903774924837941, 0.27639813228658316, 0.27639813228658316, 0.27639813228658316, 0.2505783856142981, 0.2505783856142981, 0.2505783856142981, 0.2569702010983914, 0.2569702010983914, 0.2569702010983914, 0.24429925613291603, 0.24429925613291603, 0.24429925613291603, 0.214832834036912, 0.214832834036912, 0.214832834036912, 0.21513987692100578, 0.21513987692100578, 0.21513987692100578, 0.2445502703390816, 0.2445502703390816, 0.2445502703390816, 0.19101626191125287, 0.19101626191125287, 0.19101626191125287, 0.12530674198654945, 0.12530674198654945, 0.12530674198654945, 0.7924279396176195, 0.7924279396176195, 0.7924279396176195, 0.17536410774688227, 0.17536410774688227, 0.17536410774688227, 0.6822687639458871, 0.6822687639458871, 0.6822687639458871, 0.23936689395430033, 0.23936689395430033, 0.23936689395430033, 0.539801355842079, 0.539801355842079, 0.539801355842079, 0.19279943415157008, 0.19279943415157008, 0.19279943415157008, 0.20497007352231877, 0.20497007352231877, 0.20497007352231877, 0.1958322828016904, 0.1958322828016904, 0.1958322828016904, 0.08697914121604333, 0.08697914121604333, 0.08697914121604333, 0.09928650352324786, 0.09928650352324786, 0.09928650352324786, 0.08663960081597544, 0.08663960081597544, 0.08663960081597544]}, "mutation_prompt": null}
{"id": "6482862f-e4d2-4c35-a486-ec84a57d68bf", "solution": "import numpy as np\n\nclass EnhancedClusteringPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased particle count for better initial coverage\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.2  # Further reduced to enhance exploitation in later stages\n        self.c1_initial = 1.8  # Fine-tuned to enhance personal exploration\n        self.c2_initial = 1.7\n        self.c1_final = 1.0\n        self.c2_final = 2.9  # Further increase for stronger global convergence\n        self.velocity_clamp = 0.6  # Improved dynamic control\n        self.local_search_probability = 0.2  # Increased probability for more frequent local exploration\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            # Dynamic clustering for diverse exploration\n            if evaluations % (self.budget // 10) == 0: \n                clusters = np.random.randint(0, 5, self.num_particles)  # Randomly assign particles to clusters\n\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                # Introduce clustering effect on velocity update\n                cluster_center = np.mean(positions[clusters == clusters[i]], axis=0)\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                cluster_component = 0.1 * (cluster_center - positions[i])  # Small influence from the cluster center\n\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component + cluster_component\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedClusteringPSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedClusteringPSO", "description": "Enhanced Particle Swarm Optimization with adaptive inertia and dynamic clustering for improved global exploration and local exploitation.", "configspace": "", "generation": 25, "fitness": 0.279570164426223, "feedback": "The algorithm EnhancedClusteringPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7423864760727078, 0.7423864760727078, 0.7423864760727078, 0.7491314749611301, 0.7491314749611301, 0.7491314749611301, 0.7351707190561712, 0.7351707190561712, 0.7351707190561712, 0.426220700118064, 0.426220700118064, 0.426220700118064, 0.32410454491730245, 0.32410454491730245, 0.32410454491730245, 0.3584277929097246, 0.3584277929097246, 0.3584277929097246, 0.12303465459838225, 0.12303465459838225, 0.12303465459838225, 0.11987712122436167, 0.11987712122436167, 0.11987712122436167, 0.1498253947689966, 0.1498253947689966, 0.1498253947689966, 0.13392895121038728, 0.13392895121038728, 0.13392895121038728, 0.10701605746023501, 0.10701605746023501, 0.10701605746023501, 0.13360595741829018, 0.13360595741829018, 0.13360595741829018, 0.8537910945978564, 0.8537910945978564, 0.8537910945978564, 0.8808041520402456, 0.8808041520402456, 0.8808041520402456, 0.8446556985236653, 0.8446556985236653, 0.8446556985236653, 0.4640236475266948, 0.4640236475266948, 0.4640236475266948, 0.4748419032765825, 0.4748419032765825, 0.4748419032765825, 0.4406932272955204, 0.4406932272955204, 0.4406932272955204, 0.22675832728720557, 0.22675832728720557, 0.22675832728720557, 0.2765699564556364, 0.2765699564556364, 0.2765699564556364, 0.34956480174632454, 0.34956480174632454, 0.34956480174632454, 0.20343062523394828, 0.20343062523394828, 0.20343062523394828, 0.21526843271908924, 0.21526843271908924, 0.21526843271908924, 0.346784260334251, 0.346784260334251, 0.346784260334251, 0.12924320595206196, 0.12924320595206196, 0.12924320595206196, 0.15301433833621503, 0.15301433833621503, 0.15301433833621503, 0.23036591142231333, 0.23036591142231333, 0.23036591142231333, 0.0997063468814906, 0.0997063468814906, 0.0997063468814906, 0.044316919740228555, 0.044316919740228555, 0.044316919740228555, 0.03234071228241353, 0.03234071228241353, 0.03234071228241353, 0.11925437290458207, 0.11925437290458207, 0.11925437290458207, 0.0901480053880872, 0.0901480053880872, 0.0901480053880872, 0.16437028405072818, 0.16437028405072818, 0.16437028405072818, 0.15224322764626397, 0.15224322764626397, 0.15224322764626397, 0.087597681927578, 0.087597681927578, 0.087597681927578, 0.2290573179333012, 0.2290573179333012, 0.2290573179333012, 0.139067968350865, 0.139067968350865, 0.139067968350865, 0.08401220822283872, 0.08401220822283872, 0.08401220822283872, 0.17284472653877003, 0.17284472653877003, 0.17284472653877003, 0.5137156034566998, 0.5137156034566998, 0.5137156034566998, 0.48399479366137976, 0.48399479366137976, 0.48399479366137976, 0.5203231419069876, 0.5203231419069876, 0.5203231419069876, 0.0977496571936366, 0.0977496571936366, 0.0977496571936366, 0.09249989333817898, 0.09249989333817898, 0.09249989333817898, 0.171780104233203, 0.171780104233203, 0.171780104233203, 0.21257439298675218, 0.21257439298675218, 0.21257439298675218, 0.3055212650644231, 0.3055212650644231, 0.3055212650644231, 0.2256098659543735, 0.2256098659543735, 0.2256098659543735, 0.29117728090950434, 0.29117728090950434, 0.29117728090950434, 0.3058006944791558, 0.3058006944791558, 0.3058006944791558, 0.21045880552781326, 0.21045880552781326, 0.21045880552781326, 0.2592663747884587, 0.2592663747884587, 0.2592663747884587, 0.2902751638390757, 0.2902751638390757, 0.2902751638390757, 0.2300050785648181, 0.2300050785648181, 0.2300050785648181, 0.2476711502743174, 0.2476711502743174, 0.2476711502743174, 0.26518060911683183, 0.26518060911683183, 0.26518060911683183, 0.23892371741646756, 0.23892371741646756, 0.23892371741646756, 0.18915231189055026, 0.18915231189055026, 0.18915231189055026, 0.22279587970820935, 0.22279587970820935, 0.22279587970820935, 0.19755118020599072, 0.19755118020599072, 0.19755118020599072, 0.17400611147345113, 0.17400611147345113, 0.17400611147345113, 0.8473537197687564, 0.8473537197687564, 0.8473537197687564, 0.1416700232533572, 0.1416700232533572, 0.1416700232533572, 0.6703678313552905, 0.6703678313552905, 0.6703678313552905, 0.20801949945436826, 0.20801949945436826, 0.20801949945436826, 0.1038080688670896, 0.1038080688670896, 0.1038080688670896, 0.17500543498393895, 0.17500543498393895, 0.17500543498393895, 0.18949297906301266, 0.18949297906301266, 0.18949297906301266, 0.19035098898038072, 0.19035098898038072, 0.19035098898038072, 0.0997116183625627, 0.0997116183625627, 0.0997116183625627, 0.07828706940576469, 0.07828706940576469, 0.07828706940576469, 0.07145232987274408, 0.07145232987274408, 0.07145232987274408]}, "mutation_prompt": null}
{"id": "75eac7fc-0b6a-40b0-ae4c-abf6cdcff655", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Adjusted for better balance between exploration and exploitation\n        self.w_min = 0.2  # Further reduced to enhance convergence\n        self.c1_initial = 1.9\n        self.c2_initial = 1.8  # Balanced initial cognitive and social factors\n        self.c1_final = 1.1\n        self.c2_final = 2.9  # Enhanced final social factor for stronger convergence\n        self.velocity_clamp = 0.6  # Slightly increased for better movement range\n        self.local_search_probability = 0.15  # Increased for more local refinements\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)  # Increased perturbation for thorough exploration\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "HybridAdaptivePSO", "description": "A Hybrid Adaptive PSO with dynamic local search and perturbation strategies for balanced exploration and exploitation.", "configspace": "", "generation": 26, "fitness": 0.30410073387371167, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.777101319180486, 0.777101319180486, 0.777101319180486, 0.7732562428117039, 0.7732562428117039, 0.7732562428117039, 0.7622221455970031, 0.7622221455970031, 0.7622221455970031, 0.4882283034889614, 0.4882283034889614, 0.4882283034889614, 0.49131298324972894, 0.49131298324972894, 0.49131298324972894, 0.5212316074036192, 0.5212316074036192, 0.5212316074036192, 0.3907536268137938, 0.3907536268137938, 0.3907536268137938, 0.17413278039718738, 0.17413278039718738, 0.17413278039718738, 0.13691703196768013, 0.13691703196768013, 0.13691703196768013, 0.10158812307719678, 0.10158812307719678, 0.10158812307719678, 0.15099078707663027, 0.15099078707663027, 0.15099078707663027, 0.10898023481927555, 0.10898023481927555, 0.10898023481927555, 0.9107602709047614, 0.9107602709047614, 0.9107602709047614, 0.9028338817687505, 0.9028338817687505, 0.9028338817687505, 0.9123859683998832, 0.9123859683998832, 0.9123859683998832, 0.511578439700764, 0.511578439700764, 0.511578439700764, 0.5243614500120575, 0.5243614500120575, 0.5243614500120575, 0.4899154306536134, 0.4899154306536134, 0.4899154306536134, 0.7160246137071897, 0.7160246137071897, 0.7160246137071897, 0.3689849022433459, 0.3689849022433459, 0.3689849022433459, 0.14906256506975646, 0.14906256506975646, 0.14906256506975646, 0.1866489007937695, 0.1866489007937695, 0.1866489007937695, 0.1870203294118964, 0.1870203294118964, 0.1870203294118964, 0.17698039306776225, 0.17698039306776225, 0.17698039306776225, 0.18478676517066872, 0.18478676517066872, 0.18478676517066872, 0.20565426694986055, 0.20565426694986055, 0.20565426694986055, 0.20779869812913943, 0.20779869812913943, 0.20779869812913943, 0.01168644651130979, 0.01168644651130979, 0.01168644651130979, 0.05229556880601072, 0.05229556880601072, 0.05229556880601072, 0.009954378934636354, 0.009954378934636354, 0.009954378934636354, 0.11670366033794088, 0.11670366033794088, 0.11670366033794088, 0.06611576660183349, 0.06611576660183349, 0.06611576660183349, 0.08669935749322755, 0.08669935749322755, 0.08669935749322755, 0.1715704211184741, 0.1715704211184741, 0.1715704211184741, 0.20318625777923416, 0.20318625777923416, 0.20318625777923416, 0.0795216326736623, 0.0795216326736623, 0.0795216326736623, 0.19015618631709008, 0.19015618631709008, 0.19015618631709008, 0.23859239642433783, 0.23859239642433783, 0.23859239642433783, 0.12958703033474062, 0.12958703033474062, 0.12958703033474062, 0.4917847951638529, 0.4917847951638529, 0.4917847951638529, 0.5187211075185791, 0.5187211075185791, 0.5187211075185791, 0.5090084216607735, 0.5090084216607735, 0.5090084216607735, 0.0754943861612195, 0.0754943861612195, 0.0754943861612195, 0.09471316436933408, 0.09471316436933408, 0.09471316436933408, 0.13489996894759748, 0.13489996894759748, 0.13489996894759748, 0.2542342471686774, 0.2542342471686774, 0.2542342471686774, 0.21014829129842727, 0.21014829129842727, 0.21014829129842727, 0.36572365687708197, 0.36572365687708197, 0.36572365687708197, 0.2484766607365002, 0.2484766607365002, 0.2484766607365002, 0.4656375065363342, 0.4656375065363342, 0.4656375065363342, 0.24908744466980137, 0.24908744466980137, 0.24908744466980137, 0.2084797160167109, 0.2084797160167109, 0.2084797160167109, 0.2780484549093378, 0.2780484549093378, 0.2780484549093378, 0.2366754318548645, 0.2366754318548645, 0.2366754318548645, 0.2350784606168418, 0.2350784606168418, 0.2350784606168418, 0.23403607249781166, 0.23403607249781166, 0.23403607249781166, 0.21623885988295788, 0.21623885988295788, 0.21623885988295788, 0.18414926430008904, 0.18414926430008904, 0.18414926430008904, 0.24509041319456004, 0.24509041319456004, 0.24509041319456004, 0.1943289982108647, 0.1943289982108647, 0.1943289982108647, 0.12615027461495176, 0.12615027461495176, 0.12615027461495176, 0.8654830854097534, 0.8654830854097534, 0.8654830854097534, 0.14205393281184042, 0.14205393281184042, 0.14205393281184042, 0.5532057570841756, 0.5532057570841756, 0.5532057570841756, 0.7579069961921387, 0.7579069961921387, 0.7579069961921387, 0.10360187378384866, 0.10360187378384866, 0.10360187378384866, 0.1967581549577988, 0.1967581549577988, 0.1967581549577988, 0.1895651376589187, 0.1895651376589187, 0.1895651376589187, 0.18615828837899817, 0.18615828837899817, 0.18615828837899817, 0.08573115776494056, 0.08573115776494056, 0.08573115776494056, 0.08248454127271543, 0.08248454127271543, 0.08248454127271543, 0.08851715118595804, 0.08851715118595804, 0.08851715118595804]}, "mutation_prompt": null}
{"id": "c79842b0-f9c9-4a14-b1af-9acee8613df0", "solution": "import numpy as np\n\nclass DynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.c1_initial = 1.9  # Slightly adjusted for balance\n        self.c2_initial = 1.6\n        self.c1_final = 1.1\n        self.c2_final = 3.0  # Increased for better social convergence\n        self.velocity_clamp = 0.4  # Reduced for finer control\n        self.local_search_probability = 0.2  # Increased local search probability for improved local exploration\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)  # Reduced perturbation for finer adjustments\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# dynamic_pso = DynamicPSO(budget=10000, dim=10)\n# dynamic_pso(func)", "name": "DynamicPSO", "description": "Dynamic Particle Swarm Optimization with adaptive velocity reduction and enhanced local search to improve convergence precision and robustness.", "configspace": "", "generation": 27, "fitness": 0.2675568368540156, "feedback": "The algorithm DynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7092138168966133, 0.7092138168966133, 0.7092138168966133, 0.7177366316631151, 0.7177366316631151, 0.7177366316631151, 0.7330997638376318, 0.7330997638376318, 0.7330997638376318, 0.384681999914132, 0.384681999914132, 0.384681999914132, 0.3765960993920364, 0.3765960993920364, 0.3765960993920364, 0.3095620417161252, 0.3095620417161252, 0.3095620417161252, 0.08887617290541217, 0.08887617290541217, 0.08887617290541217, 0.13622976642416873, 0.13622976642416873, 0.13622976642416873, 0.08960018745457687, 0.08960018745457687, 0.08960018745457687, 0.09150327532618974, 0.09150327532618974, 0.09150327532618974, 0.10449395245367576, 0.10449395245367576, 0.10449395245367576, 0.13757714339440774, 0.13757714339440774, 0.13757714339440774, 0.8948015063296613, 0.8948015063296613, 0.8948015063296613, 0.8503691158153085, 0.8503691158153085, 0.8503691158153085, 0.8504011631035132, 0.8504011631035132, 0.8504011631035132, 0.46106835858580564, 0.46106835858580564, 0.46106835858580564, 0.4586375329032375, 0.4586375329032375, 0.4586375329032375, 0.4325072640751215, 0.4325072640751215, 0.4325072640751215, 0.2263531059532068, 0.2263531059532068, 0.2263531059532068, 0.2749230173268157, 0.2749230173268157, 0.2749230173268157, 0.14982862737947666, 0.14982862737947666, 0.14982862737947666, 0.1609863749021586, 0.1609863749021586, 0.1609863749021586, 0.17394054041070317, 0.17394054041070317, 0.17394054041070317, 0.19182021165993945, 0.19182021165993945, 0.19182021165993945, 0.20479297377170014, 0.20479297377170014, 0.20479297377170014, 0.19234046060810195, 0.19234046060810195, 0.19234046060810195, 0.21224461450763843, 0.21224461450763843, 0.21224461450763843, 0.009300460746021089, 0.009300460746021089, 0.009300460746021089, 0.046152026858102047, 0.046152026858102047, 0.046152026858102047, 0.09367635405444985, 0.09367635405444985, 0.09367635405444985, 0.1918479548445572, 0.1918479548445572, 0.1918479548445572, 0.06181441721119518, 0.06181441721119518, 0.06181441721119518, 0.10465659294035357, 0.10465659294035357, 0.10465659294035357, 0.16043224611835938, 0.16043224611835938, 0.16043224611835938, 0.17572418770727383, 0.17572418770727383, 0.17572418770727383, 0.06896805538351258, 0.06896805538351258, 0.06896805538351258, 0.07253741884949139, 0.07253741884949139, 0.07253741884949139, 0.07142304797029175, 0.07142304797029175, 0.07142304797029175, 0.07630528956674676, 0.07630528956674676, 0.07630528956674676, 0.5072311603606514, 0.5072311603606514, 0.5072311603606514, 0.4890081668604245, 0.4890081668604245, 0.4890081668604245, 0.5023023297624929, 0.5023023297624929, 0.5023023297624929, 0.0803986658631417, 0.0803986658631417, 0.0803986658631417, 0.09643072285544518, 0.09643072285544518, 0.09643072285544518, 0.08525799975651338, 0.08525799975651338, 0.08525799975651338, 0.3396450478791382, 0.3396450478791382, 0.3396450478791382, 0.3923334017214143, 0.3923334017214143, 0.3923334017214143, 0.2797903046761028, 0.2797903046761028, 0.2797903046761028, 0.34095055301679966, 0.34095055301679966, 0.34095055301679966, 0.26098232729804793, 0.26098232729804793, 0.26098232729804793, 0.2315358153783894, 0.2315358153783894, 0.2315358153783894, 0.19495170827672448, 0.19495170827672448, 0.19495170827672448, 0.2715984401178484, 0.2715984401178484, 0.2715984401178484, 0.25545212765784364, 0.25545212765784364, 0.25545212765784364, 0.2426324219531717, 0.2426324219531717, 0.2426324219531717, 0.24810040401962263, 0.24810040401962263, 0.24810040401962263, 0.2608494053174307, 0.2608494053174307, 0.2608494053174307, 0.1755022511354356, 0.1755022511354356, 0.1755022511354356, 0.18344364866521368, 0.18344364866521368, 0.18344364866521368, 0.18845066558382373, 0.18845066558382373, 0.18845066558382373, 0.1251300366984961, 0.1251300366984961, 0.1251300366984961, 0.8524714955364282, 0.8524714955364282, 0.8524714955364282, 0.14137920798711345, 0.14137920798711345, 0.14137920798711345, 0.5844835582301453, 0.5844835582301453, 0.5844835582301453, 0.20317079639084212, 0.20317079639084212, 0.20317079639084212, 0.10285006406527442, 0.10285006406527442, 0.10285006406527442, 0.20141294643464036, 0.20141294643464036, 0.20141294643464036, 0.20288863248207167, 0.20288863248207167, 0.20288863248207167, 0.1852342444114644, 0.1852342444114644, 0.1852342444114644, 0.09732624442079174, 0.09732624442079174, 0.09732624442079174, 0.08066219823849552, 0.08066219823849552, 0.08066219823849552, 0.11321148947685633, 0.11321148947685633, 0.11321148947685633]}, "mutation_prompt": null}
{"id": "c8f15dbd-3b09-40f2-a8c9-2f6bd4ca1985", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Adjusted the number of particles for better search space coverage\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Balanced inertia to maintain both exploration and exploitation\n        self.w_min = 0.4\n        self.c1_initial = 1.5  # Balanced cognitive factor for moderate exploration\n        self.c2_initial = 2.0\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Increased social factor for stronger convergence influence\n        self.velocity_clamp = 0.6  # Enhanced velocity clamping for stability\n        self.local_search_probability = 0.2  # Increased probability for more frequent local searches\n        self.mutation_probability = 0.3  # Introduced mutation for diversity\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n                if np.random.rand() < self.mutation_probability:\n                    mutation = np.random.normal(0, 0.1, self.dim)\n                    positions[i] = positions[i] + mutation\n                    positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "HybridAdaptivePSO", "description": "A dynamic hybrid PSO integrating mutation and adaptive parameters for enhanced convergence in diverse optimization landscapes.", "configspace": "", "generation": 28, "fitness": 0.23424065930550247, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.20.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.4945157062090465, 0.4945157062090465, 0.4945157062090465, 0.45201513071710975, 0.45201513071710975, 0.45201513071710975, 0.4691931988123913, 0.4691931988123913, 0.4691931988123913, 0.04841499874387589, 0.04841499874387589, 0.04841499874387589, 0.05934086002843508, 0.05934086002843508, 0.05934086002843508, 0.027237333871937497, 0.027237333871937497, 0.027237333871937497, 0.1210248980472115, 0.1210248980472115, 0.1210248980472115, 0.11384415593026864, 0.11384415593026864, 0.11384415593026864, 0.0837772989478266, 0.0837772989478266, 0.0837772989478266, 0.12537476115268453, 0.12537476115268453, 0.12537476115268453, 0.11190320842216983, 0.11190320842216983, 0.11190320842216983, 0.11523382898534362, 0.11523382898534362, 0.11523382898534362, 0.8923597133277066, 0.8923597133277066, 0.8923597133277066, 0.8753069816921977, 0.8753069816921977, 0.8753069816921977, 0.8805672507221777, 0.8805672507221777, 0.8805672507221777, 0.29411944085147823, 0.29411944085147823, 0.29411944085147823, 0.29927295098771023, 0.29927295098771023, 0.29927295098771023, 0.30223217201454444, 0.30223217201454444, 0.30223217201454444, 0.2684451160714354, 0.2684451160714354, 0.2684451160714354, 0.27988101270325116, 0.27988101270325116, 0.27988101270325116, 0.17602356389105678, 0.17602356389105678, 0.17602356389105678, 0.11672134364991271, 0.11672134364991271, 0.11672134364991271, 0.15166816283165085, 0.15166816283165085, 0.15166816283165085, 0.1912415771671997, 0.1912415771671997, 0.1912415771671997, 0.17971367068331223, 0.17971367068331223, 0.17971367068331223, 0.179015632660381, 0.179015632660381, 0.179015632660381, 0.19258372124517698, 0.19258372124517698, 0.19258372124517698, 0.027191921498453286, 0.027191921498453286, 0.027191921498453286, 0.043876056542705766, 0.043876056542705766, 0.043876056542705766, 0.023005149748976716, 0.023005149748976716, 0.023005149748976716, 0.10026556588452262, 0.10026556588452262, 0.10026556588452262, 0.07428952417941292, 0.07428952417941292, 0.07428952417941292, 0.0804106633514059, 0.0804106633514059, 0.0804106633514059, 0.0007327589073643503, 0.0007327589073643503, 0.0007327589073643503, 0.002823000501058215, 0.002823000501058215, 0.002823000501058215, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.12452107073437857, 0.12452107073437857, 0.12452107073437857, 0.09728031037776586, 0.09728031037776586, 0.09728031037776586, 0.1052068788760484, 0.1052068788760484, 0.1052068788760484, 0.4177761845553123, 0.4177761845553123, 0.4177761845553123, 0.4258671710318427, 0.4258671710318427, 0.4258671710318427, 0.4294960402578094, 0.4294960402578094, 0.4294960402578094, 0.07963171465314567, 0.07963171465314567, 0.07963171465314567, 0.08599373157491097, 0.08599373157491097, 0.08599373157491097, 0.07432973370230433, 0.07432973370230433, 0.07432973370230433, 0.256837073893316, 0.256837073893316, 0.256837073893316, 0.2029782909775908, 0.2029782909775908, 0.2029782909775908, 0.2511146954608263, 0.2511146954608263, 0.2511146954608263, 0.2976423350301073, 0.2976423350301073, 0.2976423350301073, 0.2971254647105488, 0.2971254647105488, 0.2971254647105488, 0.22822855517366925, 0.22822855517366925, 0.22822855517366925, 0.23607960636433145, 0.23607960636433145, 0.23607960636433145, 0.254533364420759, 0.254533364420759, 0.254533364420759, 0.20368823796670876, 0.20368823796670876, 0.20368823796670876, 0.2406667154502906, 0.2406667154502906, 0.2406667154502906, 0.24027616024009368, 0.24027616024009368, 0.24027616024009368, 0.2561064448903386, 0.2561064448903386, 0.2561064448903386, 0.2034416083356243, 0.2034416083356243, 0.2034416083356243, 0.189539900655032, 0.189539900655032, 0.189539900655032, 0.19741369067924253, 0.19741369067924253, 0.19741369067924253, 0.6516380803501769, 0.6516380803501769, 0.6516380803501769, 0.7050966830327654, 0.7050966830327654, 0.7050966830327654, 0.14164388027165242, 0.14164388027165242, 0.14164388027165242, 0.5736854423312328, 0.5736854423312328, 0.5736854423312328, 0.20911441509926798, 0.20911441509926798, 0.20911441509926798, 0.47210623130373686, 0.47210623130373686, 0.47210623130373686, 0.18903034340923264, 0.18903034340923264, 0.18903034340923264, 0.19660490932216512, 0.19660490932216512, 0.19660490932216512, 0.18696575214184252, 0.18696575214184252, 0.18696575214184252, 0.0951669761220757, 0.0951669761220757, 0.0951669761220757, 0.08565774066944054, 0.08565774066944054, 0.08565774066944054, 0.10911970494920131, 0.10911970494920131, 0.10911970494920131]}, "mutation_prompt": null}
{"id": "29140054-64a8-4f14-8762-201d9eb298ad", "solution": "import numpy as np\n\nclass HybridInertiaPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Modified to improve exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Adjusted for improved convergence\n        self.w_min = 0.2  # Further exploration-exploitation balance\n        self.c1_initial = 2.1  # Slight boost in cognitive factor\n        self.c2_initial = 1.6\n        self.c1_final = 1.3\n        self.c2_final = 3.0  # Increased to emphasize social learning\n        self.velocity_clamp = 0.6  # Adjusted for enhanced control\n        self.local_search_probability = 0.15  # Increased probability for local enhancements\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget) ** 2)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_inertia_pso = HybridInertiaPSO(budget=10000, dim=10)\n# hybrid_inertia_pso(func)", "name": "HybridInertiaPSO", "description": "A swarm-based optimizer blending adaptive inertia weights and innovative local search for robust performance across varying problem landscapes.", "configspace": "", "generation": 29, "fitness": 0.28340174633268495, "feedback": "The algorithm HybridInertiaPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6922485347349369, 0.6922485347349369, 0.6922485347349369, 0.63832761808748, 0.63832761808748, 0.63832761808748, 0.6423253694707012, 0.6423253694707012, 0.6423253694707012, 0.2825683060760861, 0.2825683060760861, 0.2825683060760861, 0.2459524670378087, 0.2459524670378087, 0.2459524670378087, 0.27653235677398824, 0.27653235677398824, 0.27653235677398824, 0.13702008654510356, 0.13702008654510356, 0.13702008654510356, 0.11703944432971825, 0.11703944432971825, 0.11703944432971825, 0.10595533698810178, 0.10595533698810178, 0.10595533698810178, 0.1385685147416108, 0.1385685147416108, 0.1385685147416108, 0.11840619191528035, 0.11840619191528035, 0.11840619191528035, 0.13804540943559673, 0.13804540943559673, 0.13804540943559673, 0.894189193443828, 0.894189193443828, 0.894189193443828, 0.8959318944369848, 0.8959318944369848, 0.8959318944369848, 0.8900185864089898, 0.8900185864089898, 0.8900185864089898, 0.3725688086150991, 0.3725688086150991, 0.3725688086150991, 0.3660891388940659, 0.3660891388940659, 0.3660891388940659, 0.37320149740412334, 0.37320149740412334, 0.37320149740412334, 0.7523312902953824, 0.7523312902953824, 0.7523312902953824, 0.27609487589167925, 0.27609487589167925, 0.27609487589167925, 0.17574506209124008, 0.17574506209124008, 0.17574506209124008, 0.16568724771595478, 0.16568724771595478, 0.16568724771595478, 0.23277866972560513, 0.23277866972560513, 0.23277866972560513, 0.15581668900578027, 0.15581668900578027, 0.15581668900578027, 0.22333719176206246, 0.22333719176206246, 0.22333719176206246, 0.21264146432885656, 0.21264146432885656, 0.21264146432885656, 0.20171455764443613, 0.20171455764443613, 0.20171455764443613, 0.012486870809454209, 0.012486870809454209, 0.012486870809454209, 0.004865810280917704, 0.004865810280917704, 0.004865810280917704, 0.08256480930955457, 0.08256480930955457, 0.08256480930955457, 0.12473848824889788, 0.12473848824889788, 0.12473848824889788, 0.1242567798608405, 0.1242567798608405, 0.1242567798608405, 0.14249581836695546, 0.14249581836695546, 0.14249581836695546, 0.12018550234253822, 0.12018550234253822, 0.12018550234253822, 0.0674798806013236, 0.0674798806013236, 0.0674798806013236, 0.06672178266376938, 0.06672178266376938, 0.06672178266376938, 0.16108555810379455, 0.16108555810379455, 0.16108555810379455, 0.05770399203015386, 0.05770399203015386, 0.05770399203015386, 0.09801739788792452, 0.09801739788792452, 0.09801739788792452, 0.4512670886064515, 0.4512670886064515, 0.4512670886064515, 0.47079516771554086, 0.47079516771554086, 0.47079516771554086, 0.4790783089517635, 0.4790783089517635, 0.4790783089517635, 0.0992611833758843, 0.0992611833758843, 0.0992611833758843, 0.12758692447561426, 0.12758692447561426, 0.12758692447561426, 0.0851952451528939, 0.0851952451528939, 0.0851952451528939, 0.30167531544719006, 0.30167531544719006, 0.30167531544719006, 0.298229936318098, 0.298229936318098, 0.298229936318098, 0.2926426522095128, 0.2926426522095128, 0.2926426522095128, 0.30526370627700616, 0.30526370627700616, 0.30526370627700616, 0.3590715635355072, 0.3590715635355072, 0.3590715635355072, 0.2438959190577269, 0.2438959190577269, 0.2438959190577269, 0.22265692832070427, 0.22265692832070427, 0.22265692832070427, 0.2652878732092171, 0.2652878732092171, 0.2652878732092171, 0.27382906812374563, 0.27382906812374563, 0.27382906812374563, 0.22707327644279562, 0.22707327644279562, 0.22707327644279562, 0.2269095195182157, 0.2269095195182157, 0.2269095195182157, 0.24500277113853586, 0.24500277113853586, 0.24500277113853586, 0.3405018440376989, 0.3405018440376989, 0.3405018440376989, 0.24282106101477807, 0.24282106101477807, 0.24282106101477807, 0.185518703879765, 0.185518703879765, 0.185518703879765, 0.7832624450876653, 0.7832624450876653, 0.7832624450876653, 0.814191831934054, 0.814191831934054, 0.814191831934054, 0.14192048209570096, 0.14192048209570096, 0.14192048209570096, 0.571310081578197, 0.571310081578197, 0.571310081578197, 0.20845715027461986, 0.20845715027461986, 0.20845715027461986, 0.5335547089765366, 0.5335547089765366, 0.5335547089765366, 0.18282159682172572, 0.18282159682172572, 0.18282159682172572, 0.1730097166464991, 0.1730097166464991, 0.1730097166464991, 0.19330565865207427, 0.19330565865207427, 0.19330565865207427, 0.09788050631427703, 0.09788050631427703, 0.09788050631427703, 0.10038107044613209, 0.10038107044613209, 0.10038107044613209, 0.07752793601056618, 0.07752793601056618, 0.07752793601056618]}, "mutation_prompt": null}
{"id": "91e1f93c-d9cf-4042-b8d6-834495ddcbfb", "solution": "import numpy as np\n\nclass AdaptiveMultiPhasePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased particles for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.2  # Reduced inertia range for fine-tuning\n        self.c1_initial = 2.0\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Enhanced social factor for stronger convergence\n        self.velocity_clamp = 0.6  # Adjusted for dynamic control\n        self.local_search_probability = 0.15  # Increased probability for local search\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.uniform(-0.2, 0.2, self.dim)  # More diverse perturbation\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "AdaptiveMultiPhasePSO", "description": "An Adaptive Multi-Phase PSO with stochastic selection and dynamic local search for improved convergence and robustness.", "configspace": "", "generation": 30, "fitness": 0.3057690621843961, "feedback": "The algorithm AdaptiveMultiPhasePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7622821910908562, 0.7622821910908562, 0.7622821910908562, 0.7413153203699968, 0.7413153203699968, 0.7413153203699968, 0.7641332915918954, 0.7641332915918954, 0.7641332915918954, 0.45987123470373703, 0.45987123470373703, 0.45987123470373703, 0.484830985037796, 0.484830985037796, 0.484830985037796, 0.5008983870363439, 0.5008983870363439, 0.5008983870363439, 0.38696874067745723, 0.38696874067745723, 0.38696874067745723, 0.10704751984897609, 0.10704751984897609, 0.10704751984897609, 0.12155896197168914, 0.12155896197168914, 0.12155896197168914, 0.12650884142516294, 0.12650884142516294, 0.12650884142516294, 0.08195426688442309, 0.08195426688442309, 0.08195426688442309, 0.10551547047267418, 0.10551547047267418, 0.10551547047267418, 0.8324585920809393, 0.8324585920809393, 0.8324585920809393, 0.9045689570498067, 0.9045689570498067, 0.9045689570498067, 0.8377970517482074, 0.8377970517482074, 0.8377970517482074, 0.4889077646533838, 0.4889077646533838, 0.4889077646533838, 0.5683207534989374, 0.5683207534989374, 0.5683207534989374, 0.48933169947574806, 0.48933169947574806, 0.48933169947574806, 0.16912626344413473, 0.16912626344413473, 0.16912626344413473, 0.7955732437805373, 0.7955732437805373, 0.7955732437805373, 0.22178368851120545, 0.22178368851120545, 0.22178368851120545, 0.29620393160846903, 0.29620393160846903, 0.29620393160846903, 0.19019057438191556, 0.19019057438191556, 0.19019057438191556, 0.1863196798968988, 0.1863196798968988, 0.1863196798968988, 0.11147516412361347, 0.11147516412361347, 0.11147516412361347, 0.12871876487142742, 0.12871876487142742, 0.12871876487142742, 0.12479149368045495, 0.12479149368045495, 0.12479149368045495, 0.11892945580529413, 0.11892945580529413, 0.11892945580529413, 0.019125269801105738, 0.019125269801105738, 0.019125269801105738, 0.057196843660609065, 0.057196843660609065, 0.057196843660609065, 0.09958317362652835, 0.09958317362652835, 0.09958317362652835, 0.05644143746372121, 0.05644143746372121, 0.05644143746372121, 0.13514578331224292, 0.13514578331224292, 0.13514578331224292, 0.05108984118027715, 0.05108984118027715, 0.05108984118027715, 0.07407688411096824, 0.07407688411096824, 0.07407688411096824, 0.100033040649949, 0.100033040649949, 0.100033040649949, 0.10075785482673039, 0.10075785482673039, 0.10075785482673039, 0.03691555407834002, 0.03691555407834002, 0.03691555407834002, 0.29202402737586575, 0.29202402737586575, 0.29202402737586575, 0.4747239104246088, 0.4747239104246088, 0.4747239104246088, 0.521169939618431, 0.521169939618431, 0.521169939618431, 0.5048025685924719, 0.5048025685924719, 0.5048025685924719, 0.10353271045013968, 0.10353271045013968, 0.10353271045013968, 0.06510302636050724, 0.06510302636050724, 0.06510302636050724, 0.09598042567747123, 0.09598042567747123, 0.09598042567747123, 0.4498174252839884, 0.4498174252839884, 0.4498174252839884, 0.28206667220804715, 0.28206667220804715, 0.28206667220804715, 0.20626949838440556, 0.20626949838440556, 0.20626949838440556, 0.34502149540515725, 0.34502149540515725, 0.34502149540515725, 0.3218054984422001, 0.3218054984422001, 0.3218054984422001, 0.2815147897057164, 0.2815147897057164, 0.2815147897057164, 0.23262873247696558, 0.23262873247696558, 0.23262873247696558, 0.3368000270447705, 0.3368000270447705, 0.3368000270447705, 0.193424009105711, 0.193424009105711, 0.193424009105711, 0.22928292175131815, 0.22928292175131815, 0.22928292175131815, 0.23508750976812298, 0.23508750976812298, 0.23508750976812298, 0.2364636105250414, 0.2364636105250414, 0.2364636105250414, 0.1826228601047315, 0.1826228601047315, 0.1826228601047315, 0.19470148057830639, 0.19470148057830639, 0.19470148057830639, 0.5240203335411153, 0.5240203335411153, 0.5240203335411153, 0.8584367226315716, 0.8584367226315716, 0.8584367226315716, 0.1568920467323922, 0.1568920467323922, 0.1568920467323922, 0.8637266162696678, 0.8637266162696678, 0.8637266162696678, 0.7703792601192365, 0.7703792601192365, 0.7703792601192365, 0.21180397032075993, 0.21180397032075993, 0.21180397032075993, 0.12774687681339403, 0.12774687681339403, 0.12774687681339403, 0.18815357995296067, 0.18815357995296067, 0.18815357995296067, 0.1805713456928999, 0.1805713456928999, 0.1805713456928999, 0.19174231734986857, 0.19174231734986857, 0.19174231734986857, 0.11442446090631653, 0.11442446090631653, 0.11442446090631653, 0.09346030334297206, 0.09346030334297206, 0.09346030334297206, 0.11142353188693122, 0.11142353188693122, 0.11142353188693122]}, "mutation_prompt": null}
{"id": "f58a3435-08ed-43db-811b-9483514d298e", "solution": "import numpy as np\n\nclass MultiStrategyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Enhanced exploitation by decreasing minimum inertia weight\n        self.c1_initial = 1.5  # Modified cognitive factor for improved balance\n        self.c2_initial = 1.8\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Emphasized social factor for stronger global convergence\n        self.velocity_clamp = 0.6  # Further adjusted velocity clamping\n        self.local_search_probability = 0.2  # Increased probability for local search\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp, self.velocity_clamp, (self.num_particles, self.dim))  # Initial random velocities\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    mutation = np.random.normal(0, 0.05, self.dim)  # Mutation for deeper local search\n                    candidate_position = positions[i] + mutation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# multi_strategy_pso = MultiStrategyPSO(budget=10000, dim=10)\n# multi_strategy_pso(func)", "name": "MultiStrategyPSO", "description": "A multi-strategy Particle Swarm Optimization with adaptive weights and mutation-based local search for robust convergence across complex landscapes.", "configspace": "", "generation": 31, "fitness": 0.29796404673796484, "feedback": "The algorithm MultiStrategyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7189123238518877, 0.7189123238518877, 0.7189123238518877, 0.7113160111047245, 0.7113160111047245, 0.7113160111047245, 0.737961752268912, 0.737961752268912, 0.737961752268912, 0.4429765219242062, 0.4429765219242062, 0.4429765219242062, 0.425006555575803, 0.425006555575803, 0.425006555575803, 0.426781374959884, 0.426781374959884, 0.426781374959884, 0.16199677426216164, 0.16199677426216164, 0.16199677426216164, 0.11574223398499695, 0.11574223398499695, 0.11574223398499695, 0.09230042745685552, 0.09230042745685552, 0.09230042745685552, 0.11565065560402432, 0.11565065560402432, 0.11565065560402432, 0.11189015770491006, 0.11189015770491006, 0.11189015770491006, 0.10613516917576549, 0.10613516917576549, 0.10613516917576549, 0.9037212296440339, 0.9037212296440339, 0.9037212296440339, 0.9191820405763713, 0.9191820405763713, 0.9191820405763713, 0.8716516266577055, 0.8716516266577055, 0.8716516266577055, 0.5431842737593641, 0.5431842737593641, 0.5431842737593641, 0.49333420151440477, 0.49333420151440477, 0.49333420151440477, 0.478095790318419, 0.478095790318419, 0.478095790318419, 0.7503428863210089, 0.7503428863210089, 0.7503428863210089, 0.26953196223843257, 0.26953196223843257, 0.26953196223843257, 0.14908885052794518, 0.14908885052794518, 0.14908885052794518, 0.19141708315593098, 0.19141708315593098, 0.19141708315593098, 0.20463702614996115, 0.20463702614996115, 0.20463702614996115, 0.1767316540667483, 0.1767316540667483, 0.1767316540667483, 0.2270122379077657, 0.2270122379077657, 0.2270122379077657, 0.18544290714621503, 0.18544290714621503, 0.18544290714621503, 0.22353519999233085, 0.22353519999233085, 0.22353519999233085, 0.03979450116075256, 0.03979450116075256, 0.03979450116075256, 0.0452558633894794, 0.0452558633894794, 0.0452558633894794, 0.065350464288365, 0.065350464288365, 0.065350464288365, 0.1752660496742401, 0.1752660496742401, 0.1752660496742401, 0.07391012145724851, 0.07391012145724851, 0.07391012145724851, 0.09047836732933445, 0.09047836732933445, 0.09047836732933445, 0.10537666021878156, 0.10537666021878156, 0.10537666021878156, 0.075523560032288, 0.075523560032288, 0.075523560032288, 0.07640576022928913, 0.07640576022928913, 0.07640576022928913, 0.14534207142735744, 0.14534207142735744, 0.14534207142735744, 0.08217579473036041, 0.08217579473036041, 0.08217579473036041, 0.17645008978955434, 0.17645008978955434, 0.17645008978955434, 0.49757797274191007, 0.49757797274191007, 0.49757797274191007, 0.4996443703074649, 0.4996443703074649, 0.4996443703074649, 0.5244800722834692, 0.5244800722834692, 0.5244800722834692, 0.07999799149161735, 0.07999799149161735, 0.07999799149161735, 0.14081741053714902, 0.14081741053714902, 0.14081741053714902, 0.13636959684647787, 0.13636959684647787, 0.13636959684647787, 0.3976712509041116, 0.3976712509041116, 0.3976712509041116, 0.2010060987275657, 0.2010060987275657, 0.2010060987275657, 0.34217182949131486, 0.34217182949131486, 0.34217182949131486, 0.22668205460499347, 0.22668205460499347, 0.22668205460499347, 0.24991595687379597, 0.24991595687379597, 0.24991595687379597, 0.2683235878922001, 0.2683235878922001, 0.2683235878922001, 0.14506656853411148, 0.14506656853411148, 0.14506656853411148, 0.21690200419035788, 0.21690200419035788, 0.21690200419035788, 0.24828035617619248, 0.24828035617619248, 0.24828035617619248, 0.2226807071638517, 0.2226807071638517, 0.2226807071638517, 0.2501250993305335, 0.2501250993305335, 0.2501250993305335, 0.23043175676235927, 0.23043175676235927, 0.23043175676235927, 0.18663086362854642, 0.18663086362854642, 0.18663086362854642, 0.20529678632352466, 0.20529678632352466, 0.20529678632352466, 0.19637863953310775, 0.19637863953310775, 0.19637863953310775, 0.12562974845595076, 0.12562974845595076, 0.12562974845595076, 0.8420478145161178, 0.8420478145161178, 0.8420478145161178, 0.14211041585833206, 0.14211041585833206, 0.14211041585833206, 0.7505435094166952, 0.7505435094166952, 0.7505435094166952, 0.612761027842895, 0.612761027842895, 0.612761027842895, 0.6806227021125699, 0.6806227021125699, 0.6806227021125699, 0.20208278722562933, 0.20208278722562933, 0.20208278722562933, 0.18285792228479958, 0.18285792228479958, 0.18285792228479958, 0.187361339695284, 0.187361339695284, 0.187361339695284, 0.0877315135369181, 0.0877315135369181, 0.0877315135369181, 0.1117903751382826, 0.1117903751382826, 0.1117903751382826, 0.1565130031275188, 0.1565130031275188, 0.1565130031275188]}, "mutation_prompt": null}
{"id": "1ed2c1fb-7ecc-4ec6-81b1-da227825195d", "solution": "import numpy as np\n\nclass DynamicMultiSwarmPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Adjusted for more dynamic inertia\n        self.c1_initial = 2.5\n        self.c2_initial = 1.0\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Enhanced social factor for better convergence\n        self.velocity_clamp = 0.8  # Increased for wider velocity control\n        self.local_search_probability = 0.15  # Higher probability for local refinement\n        self.num_swarms = 2  # Introduced multiple swarms for diversity\n\n    def __call__(self, func):\n        np.random.seed(0)\n        swarm_size = self.num_particles // self.num_swarms\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_positions = [None] * self.num_swarms\n        global_best_scores = [float('inf')] * self.num_swarms\n        \n        evaluations = 0\n        while evaluations < self.budget:\n            for swarm_index in range(self.num_swarms):\n                start = swarm_index * swarm_size\n                end = start + swarm_size\n                for i in range(start, end):\n                    score = func(positions[i])\n                    evaluations += 1\n                    if score < personal_best_scores[i]:\n                        personal_best_scores[i] = score\n                        personal_best_positions[i] = positions[i].copy()\n                        if score < global_best_scores[swarm_index]:\n                            global_best_scores[swarm_index] = score\n                            global_best_positions[swarm_index] = positions[i].copy()\n\n                    if evaluations >= self.budget:\n                        break\n                \n                inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n                c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n                c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n                for i in range(start, end):\n                    if np.random.rand() < self.local_search_probability:\n                        perturbation = np.random.normal(0, 0.05, self.dim)\n                        candidate_position = positions[i] + perturbation\n                        candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_position)\n                        evaluations += 1\n                        if candidate_score < personal_best_scores[i]:\n                            personal_best_scores[i] = candidate_score\n                            personal_best_positions[i] = candidate_position.copy()\n                            if candidate_score < global_best_scores[swarm_index]:\n                                global_best_scores[swarm_index] = candidate_score\n                                global_best_positions[swarm_index] = candidate_position.copy()\n\n                    cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                    social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_positions[swarm_index] - positions[i])\n                    velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                    \n                    velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                    \n                    positions[i] += velocities[i]\n                    positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# dynamic_pso = DynamicMultiSwarmPSO(budget=10000, dim=10)\n# dynamic_pso(func)", "name": "DynamicMultiSwarmPSO", "description": "A Dynamic Multi-swarm PSO with adaptive inertia and collaborative learning for enhanced exploration and convergence.", "configspace": "", "generation": 32, "fitness": 0.2944600401975545, "feedback": "The algorithm DynamicMultiSwarmPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7012403382825176, 0.7012403382825176, 0.7012403382825176, 0.716578494088327, 0.716578494088327, 0.716578494088327, 0.7109179345377845, 0.7109179345377845, 0.7109179345377845, 0.4291499967368212, 0.4291499967368212, 0.4291499967368212, 0.41608960815188223, 0.41608960815188223, 0.41608960815188223, 0.39295757031485135, 0.39295757031485135, 0.39295757031485135, 0.13869305429760515, 0.13869305429760515, 0.13869305429760515, 0.15527023126383976, 0.15527023126383976, 0.15527023126383976, 0.164721955511413, 0.164721955511413, 0.164721955511413, 0.11888407966911085, 0.11888407966911085, 0.11888407966911085, 0.13700399181611433, 0.13700399181611433, 0.13700399181611433, 0.11174043092165897, 0.11174043092165897, 0.11174043092165897, 0.936340205615421, 0.936340205615421, 0.936340205615421, 0.9327872131214602, 0.9327872131214602, 0.9327872131214602, 0.9384094033237961, 0.9384094033237961, 0.9384094033237961, 0.46670009340970864, 0.46670009340970864, 0.46670009340970864, 0.44765066871184556, 0.44765066871184556, 0.44765066871184556, 0.40474732719370465, 0.40474732719370465, 0.40474732719370465, 0.22606619674574646, 0.22606619674574646, 0.22606619674574646, 0.27349482375148626, 0.27349482375148626, 0.27349482375148626, 0.23170615370061154, 0.23170615370061154, 0.23170615370061154, 0.375487566298489, 0.375487566298489, 0.375487566298489, 0.16174090573660338, 0.16174090573660338, 0.16174090573660338, 0.16307274588596332, 0.16307274588596332, 0.16307274588596332, 0.20674719046818857, 0.20674719046818857, 0.20674719046818857, 0.23178146667750432, 0.23178146667750432, 0.23178146667750432, 0.19705935815829478, 0.19705935815829478, 0.19705935815829478, 0.006150335030752463, 0.006150335030752463, 0.006150335030752463, 0.06856203151475604, 0.06856203151475604, 0.06856203151475604, 0.02367031854979018, 0.02367031854979018, 0.02367031854979018, 0.12542561996121981, 0.12542561996121981, 0.12542561996121981, 0.06591538546546072, 0.06591538546546072, 0.06591538546546072, 0.10297283495146403, 0.10297283495146403, 0.10297283495146403, 0.11525309512076687, 0.11525309512076687, 0.11525309512076687, 0.08185024942653285, 0.08185024942653285, 0.08185024942653285, 0.07645348192694656, 0.07645348192694656, 0.07645348192694656, 0.21822515481132032, 0.21822515481132032, 0.21822515481132032, 0.13711004214423939, 0.13711004214423939, 0.13711004214423939, 0.10937830241344804, 0.10937830241344804, 0.10937830241344804, 0.4747302913471172, 0.4747302913471172, 0.4747302913471172, 0.5055239727388913, 0.5055239727388913, 0.5055239727388913, 0.49670621810776316, 0.49670621810776316, 0.49670621810776316, 0.15453121418325588, 0.15453121418325588, 0.15453121418325588, 0.13976725681658753, 0.13976725681658753, 0.13976725681658753, 0.15014566048231792, 0.15014566048231792, 0.15014566048231792, 0.35767791625165, 0.35767791625165, 0.35767791625165, 0.24149208608065353, 0.24149208608065353, 0.24149208608065353, 0.17561150932596847, 0.17561150932596847, 0.17561150932596847, 0.334124242584357, 0.334124242584357, 0.334124242584357, 0.3869872786378391, 0.3869872786378391, 0.3869872786378391, 0.24048363343030243, 0.24048363343030243, 0.24048363343030243, 0.27247823291018736, 0.27247823291018736, 0.27247823291018736, 0.27698911559112116, 0.27698911559112116, 0.27698911559112116, 0.2867458005245993, 0.2867458005245993, 0.2867458005245993, 0.22943833992862606, 0.22943833992862606, 0.22943833992862606, 0.24768201453125205, 0.24768201453125205, 0.24768201453125205, 0.21343048342452875, 0.21343048342452875, 0.21343048342452875, 0.19601339512868432, 0.19601339512868432, 0.19601339512868432, 0.20185878642866817, 0.20185878642866817, 0.20185878642866817, 0.20864236091875277, 0.20864236091875277, 0.20864236091875277, 0.18477945051167788, 0.18477945051167788, 0.18477945051167788, 0.7981471373075392, 0.7981471373075392, 0.7981471373075392, 0.8020689449276557, 0.8020689449276557, 0.8020689449276557, 0.5990833402942406, 0.5990833402942406, 0.5990833402942406, 0.2078670201710383, 0.2078670201710383, 0.2078670201710383, 0.3973135924042205, 0.3973135924042205, 0.3973135924042205, 0.19637541723041485, 0.19637541723041485, 0.19637541723041485, 0.1956811842171774, 0.1956811842171774, 0.1956811842171774, 0.21489388414530652, 0.21489388414530652, 0.21489388414530652, 0.11182234609500774, 0.11182234609500774, 0.11182234609500774, 0.08776812949601587, 0.08776812949601587, 0.08776812949601587, 0.09625678234305901, 0.09625678234305901, 0.09625678234305901]}, "mutation_prompt": null}
{"id": "1e0c07f3-256f-47cd-a76f-114a2d563204", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased particles for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.85  # Adjusted for better balance between exploration and exploitation\n        self.w_min = 0.25  # Lowered further to emphasize exploitation\n        self.c1_initial = 2.2  # Fine-tuned cognitive factor for diverse exploration\n        self.c2_initial = 1.3\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Boosted social factor for ensuring convergence reliability\n        self.velocity_clamp = 0.6  # Slightly increased for enhanced exploration\n        self.local_search_probability = 0.15  # Increased the likelihood of local search\n        self.adaptive_perturbation_scale = 0.3  # Adaptive perturbation scale\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget) ** 0.5)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * (evaluations / self.budget) ** 0.5)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * (evaluations / self.budget) ** 0.5)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, self.adaptive_perturbation_scale * (1 - evaluations / self.budget), self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_hybrid_pso = EnhancedHybridPSO(budget=10000, dim=10)\n# enhanced_hybrid_pso(func)", "name": "EnhancedHybridPSO", "description": "An enhanced Hybrid PSO integrating dynamically adaptive inertia weights and stochastic perturbations to balance exploration and exploitation across varied terrains.", "configspace": "", "generation": 33, "fitness": 0.30724585213390937, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7996145387631568, 0.7996145387631568, 0.7996145387631568, 0.7826711262722414, 0.7826711262722414, 0.7826711262722414, 0.7932499032779612, 0.7932499032779612, 0.7932499032779612, 0.5136457522335052, 0.5136457522335052, 0.5136457522335052, 0.5402070487424449, 0.5402070487424449, 0.5402070487424449, 0.5876832930204691, 0.5876832930204691, 0.5876832930204691, 0.16985583816730465, 0.16985583816730465, 0.16985583816730465, 0.12017488879917693, 0.12017488879917693, 0.12017488879917693, 0.1365956423023743, 0.1365956423023743, 0.1365956423023743, 0.11625232303742905, 0.11625232303742905, 0.11625232303742905, 0.11129215173385398, 0.11129215173385398, 0.11129215173385398, 0.11418913011790155, 0.11418913011790155, 0.11418913011790155, 0.8861812966176843, 0.8861812966176843, 0.8861812966176843, 0.8790732072581202, 0.8790732072581202, 0.8790732072581202, 0.884534816029605, 0.884534816029605, 0.884534816029605, 0.5399566440087924, 0.5399566440087924, 0.5399566440087924, 0.535271270950352, 0.535271270950352, 0.535271270950352, 0.5149075462080787, 0.5149075462080787, 0.5149075462080787, 0.8090824854498694, 0.8090824854498694, 0.8090824854498694, 0.27873854185976865, 0.27873854185976865, 0.27873854185976865, 0.21904286448812016, 0.21904286448812016, 0.21904286448812016, 0.22853378108780742, 0.22853378108780742, 0.22853378108780742, 0.19881326004303135, 0.19881326004303135, 0.19881326004303135, 0.18946677892819785, 0.18946677892819785, 0.18946677892819785, 0.22383787213723594, 0.22383787213723594, 0.22383787213723594, 0.21405373743758038, 0.21405373743758038, 0.21405373743758038, 0.2023608133104624, 0.2023608133104624, 0.2023608133104624, 0.01205487067158173, 0.01205487067158173, 0.01205487067158173, 0.04353969273718372, 0.04353969273718372, 0.04353969273718372, 0.020390878543446567, 0.020390878543446567, 0.020390878543446567, 0.2041883560988782, 0.2041883560988782, 0.2041883560988782, 0.08042062247396864, 0.08042062247396864, 0.08042062247396864, 0.10692354235948076, 0.10692354235948076, 0.10692354235948076, 0.16963252705763987, 0.16963252705763987, 0.16963252705763987, 0.16318194857010915, 0.16318194857010915, 0.16318194857010915, 0.1277838741376749, 0.1277838741376749, 0.1277838741376749, 0.12742990080898775, 0.12742990080898775, 0.12742990080898775, 0.11871567063144761, 0.11871567063144761, 0.11871567063144761, 0.2165381376503639, 0.2165381376503639, 0.2165381376503639, 0.5041339422035545, 0.5041339422035545, 0.5041339422035545, 0.5219630600614559, 0.5219630600614559, 0.5219630600614559, 0.5789371433551502, 0.5789371433551502, 0.5789371433551502, 0.0891738432561362, 0.0891738432561362, 0.0891738432561362, 0.07976991903433339, 0.07976991903433339, 0.07976991903433339, 0.12829341136131167, 0.12829341136131167, 0.12829341136131167, 0.1926469674941148, 0.1926469674941148, 0.1926469674941148, 0.1933691174715012, 0.1933691174715012, 0.1933691174715012, 0.2035679147180185, 0.2035679147180185, 0.2035679147180185, 0.24586405905207043, 0.24586405905207043, 0.24586405905207043, 0.40114821667251666, 0.40114821667251666, 0.40114821667251666, 0.25765256717067186, 0.25765256717067186, 0.25765256717067186, 0.25320714656846344, 0.25320714656846344, 0.25320714656846344, 0.22449937650807184, 0.22449937650807184, 0.22449937650807184, 0.26879264461178354, 0.26879264461178354, 0.26879264461178354, 0.27179528549040244, 0.27179528549040244, 0.27179528549040244, 0.22800048104436033, 0.22800048104436033, 0.22800048104436033, 0.22314007718747697, 0.22314007718747697, 0.22314007718747697, 0.19247117266634028, 0.19247117266634028, 0.19247117266634028, 0.18488674594967347, 0.18488674594967347, 0.18488674594967347, 0.1791452256409357, 0.1791452256409357, 0.1791452256409357, 0.8371744496316802, 0.8371744496316802, 0.8371744496316802, 0.888449780686463, 0.888449780686463, 0.888449780686463, 0.14193161471675508, 0.14193161471675508, 0.14193161471675508, 0.6109212941354852, 0.6109212941354852, 0.6109212941354852, 0.20863958776830505, 0.20863958776830505, 0.20863958776830505, 0.10383732612659058, 0.10383732612659058, 0.10383732612659058, 0.2209106938764488, 0.2209106938764488, 0.2209106938764488, 0.1990649236758658, 0.1990649236758658, 0.1990649236758658, 0.18797256982142452, 0.18797256982142452, 0.18797256982142452, 0.09547961400659877, 0.09547961400659877, 0.09547961400659877, 0.1009652631591762, 0.1009652631591762, 0.1009652631591762, 0.12380934449504988, 0.12380934449504988, 0.12380934449504988]}, "mutation_prompt": null}
{"id": "b5d923c3-4915-42a0-a815-d34913a25fb1", "solution": "import numpy as np\n\nclass EnhancedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for broader exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.4  # Adjusted inertia range for improved balance of exploration and exploitation\n        self.c1_initial = 1.5\n        self.c2_initial = 2.0  # Enhanced social factor for better convergence\n        self.c1_final = 1.0\n        self.c2_final = 3.0\n        self.velocity_clamp = 0.4  # Adjust velocity clamping to maintain controlled exploration\n        self.local_search_probability = 0.2  # Increased probability for local search\n        self.elite_fraction = 0.1  # Fraction of top-performing particles selected for elite processing\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            elite_threshold = int(self.elite_fraction * self.num_particles)\n            sorted_indices = np.argsort(personal_best_scores)\n            elite_positions = personal_best_positions[sorted_indices[:elite_threshold]]\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n                if i < elite_threshold:\n                    elite_mutation = np.random.normal(0, 0.02, self.dim)\n                    elite_candidate = positions[i] + elite_mutation\n                    elite_candidate = np.clip(elite_candidate, self.lower_bound, self.upper_bound)\n                    elite_score = func(elite_candidate)\n                    evaluations += 1\n                    if elite_score < personal_best_scores[i]:\n                        personal_best_scores[i] = elite_score\n                        personal_best_positions[i] = elite_candidate.copy()\n                        if elite_score < global_best_score:\n                            global_best_score = elite_score\n                            global_best_position = elite_candidate.copy()\n\n# Usage:\n# enhanced_pso = EnhancedPSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedPSO", "description": "An Enhanced PSO variant incorporating dynamic learning rates, elite selection, and Gaussian mutation for robust search capabilities across varying landscapes.", "configspace": "", "generation": 34, "fitness": 0.28137409111579803, "feedback": "The algorithm EnhancedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7011765331990687, 0.7011765331990687, 0.7011765331990687, 0.6843719022755097, 0.6843719022755097, 0.6843719022755097, 0.7015450454327191, 0.7015450454327191, 0.7015450454327191, 0.3087331354470333, 0.3087331354470333, 0.3087331354470333, 0.2910289016275508, 0.2910289016275508, 0.2910289016275508, 0.3073654937619289, 0.3073654937619289, 0.3073654937619289, 0.14961662412068744, 0.14961662412068744, 0.14961662412068744, 0.14042348460215504, 0.14042348460215504, 0.14042348460215504, 0.08732949694476921, 0.08732949694476921, 0.08732949694476921, 0.09198220629890475, 0.09198220629890475, 0.09198220629890475, 0.1098818521884346, 0.1098818521884346, 0.1098818521884346, 0.13155659105700213, 0.13155659105700213, 0.13155659105700213, 0.8573826487431664, 0.8573826487431664, 0.8573826487431664, 0.8462203006518103, 0.8462203006518103, 0.8462203006518103, 0.827276133045587, 0.827276133045587, 0.827276133045587, 0.42184155678058555, 0.42184155678058555, 0.42184155678058555, 0.4586213237375366, 0.4586213237375366, 0.4586213237375366, 0.41163113338174173, 0.41163113338174173, 0.41163113338174173, 0.7923772773825003, 0.7923772773825003, 0.7923772773825003, 0.27101547130322756, 0.27101547130322756, 0.27101547130322756, 0.1486128654887885, 0.1486128654887885, 0.1486128654887885, 0.23531456261356454, 0.23531456261356454, 0.23531456261356454, 0.16870899418706597, 0.16870899418706597, 0.16870899418706597, 0.1748994294198557, 0.1748994294198557, 0.1748994294198557, 0.21251197278126288, 0.21251197278126288, 0.21251197278126288, 0.19266763895358563, 0.19266763895358563, 0.19266763895358563, 0.22734467192275176, 0.22734467192275176, 0.22734467192275176, 0.0431048253265266, 0.0431048253265266, 0.0431048253265266, 0.052278977851641484, 0.052278977851641484, 0.052278977851641484, 0.08401794395111084, 0.08401794395111084, 0.08401794395111084, 0.1424494214927876, 0.1424494214927876, 0.1424494214927876, 0.06805087243394958, 0.06805087243394958, 0.06805087243394958, 0.12050933475717263, 0.12050933475717263, 0.12050933475717263, 0.17565864013313226, 0.17565864013313226, 0.17565864013313226, 0.06105295216030315, 0.06105295216030315, 0.06105295216030315, 0.08200320828687124, 0.08200320828687124, 0.08200320828687124, 0.09509137226020448, 0.09509137226020448, 0.09509137226020448, 0.08519428687217101, 0.08519428687217101, 0.08519428687217101, 0.1458270374318854, 0.1458270374318854, 0.1458270374318854, 0.5303508744469492, 0.5303508744469492, 0.5303508744469492, 0.4766809503522893, 0.4766809503522893, 0.4766809503522893, 0.5269316836983426, 0.5269316836983426, 0.5269316836983426, 0.07072648116312596, 0.07072648116312596, 0.07072648116312596, 0.10498154298689766, 0.10498154298689766, 0.10498154298689766, 0.08679873859697695, 0.08679873859697695, 0.08679873859697695, 0.44873675575557104, 0.44873675575557104, 0.44873675575557104, 0.19124786557835127, 0.19124786557835127, 0.19124786557835127, 0.20050968760766819, 0.20050968760766819, 0.20050968760766819, 0.24118975761341221, 0.24118975761341221, 0.24118975761341221, 0.24037514037043073, 0.24037514037043073, 0.24037514037043073, 0.24110073008932897, 0.24110073008932897, 0.24110073008932897, 0.2118583714977611, 0.2118583714977611, 0.2118583714977611, 0.2829720843905097, 0.2829720843905097, 0.2829720843905097, 0.23830553004904387, 0.23830553004904387, 0.23830553004904387, 0.20415185098093613, 0.20415185098093613, 0.20415185098093613, 0.211579603344498, 0.211579603344498, 0.211579603344498, 0.25597869210088997, 0.25597869210088997, 0.25597869210088997, 0.1953305995400182, 0.1953305995400182, 0.1953305995400182, 0.17742306099824434, 0.17742306099824434, 0.17742306099824434, 0.17974218497887506, 0.17974218497887506, 0.17974218497887506, 0.12499032987910863, 0.12499032987910863, 0.12499032987910863, 0.8399598664760226, 0.8399598664760226, 0.8399598664760226, 0.1415386389145069, 0.1415386389145069, 0.1415386389145069, 0.6399275326595912, 0.6399275326595912, 0.6399275326595912, 0.6377853299223226, 0.6377853299223226, 0.6377853299223226, 0.6352442790672439, 0.6352442790672439, 0.6352442790672439, 0.18208943452313797, 0.18208943452313797, 0.18208943452313797, 0.18133978721704802, 0.18133978721704802, 0.18133978721704802, 0.18527345438700726, 0.18527345438700726, 0.18527345438700726, 0.1002965082376599, 0.1002965082376599, 0.1002965082376599, 0.08570323901125754, 0.08570323901125754, 0.08570323901125754, 0.08113785359588144, 0.08113785359588144, 0.08113785359588144]}, "mutation_prompt": null}
{"id": "6981dbf7-0cc0-4613-9575-98e3e0ad361e", "solution": "import numpy as np\n\nclass MultiSwarmCooperativePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_swarms = 2\n        self.num_particles_per_swarm = 25  # Divide particles across multiple swarms\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted for better balance between exploration and exploitation\n        self.c1_initial = 1.8\n        self.c2_initial = 2.0\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Increased social factor for stronger convergence\n        self.velocity_clamp = 0.8  # Adjusted velocity clamping\n        self.local_search_probability = 0.15  # Increased local search probability\n        self.chaotic_search_probability = 0.05  # Introduced chaotic search\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_swarms, self.num_particles_per_swarm, self.dim))\n        velocities = np.zeros((self.num_swarms, self.num_particles_per_swarm, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full((self.num_swarms, self.num_particles_per_swarm), float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for swarm in range(self.num_swarms):\n                for i in range(self.num_particles_per_swarm):\n                    score = func(positions[swarm][i])\n                    evaluations += 1\n                    if score < personal_best_scores[swarm][i]:\n                        personal_best_scores[swarm][i] = score\n                        personal_best_positions[swarm][i] = positions[swarm][i].copy()\n                        if score < global_best_score:\n                            global_best_score = score\n                            global_best_position = positions[swarm][i].copy()\n\n                    if evaluations >= self.budget:\n                        break\n                \n                if evaluations >= self.budget:\n                    break\n\n                inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n                c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n                c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n                for i in range(self.num_particles_per_swarm):\n                    if np.random.rand() < self.local_search_probability:\n                        perturbation = np.random.normal(0, 0.1, self.dim)\n                        candidate_position = positions[swarm][i] + perturbation\n                        candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                        candidate_score = func(candidate_position)\n                        evaluations += 1\n                        if candidate_score < personal_best_scores[swarm][i]:\n                            personal_best_scores[swarm][i] = candidate_score\n                            personal_best_positions[swarm][i] = candidate_position.copy()\n                            if candidate_score < global_best_score:\n                                global_best_score = candidate_score\n                                global_best_position = candidate_position.copy()\n\n                    if np.random.rand() < self.chaotic_search_probability:\n                        # Perform chaotic search\n                        chaos_factor = np.random.uniform(-0.2, 0.2, self.dim)\n                        chaotic_position = positions[swarm][i] + chaos_factor\n                        chaotic_position = np.clip(chaotic_position, self.lower_bound, self.upper_bound)\n                        chaotic_score = func(chaotic_position)\n                        evaluations += 1\n                        if chaotic_score < personal_best_scores[swarm][i]:\n                            personal_best_scores[swarm][i] = chaotic_score\n                            personal_best_positions[swarm][i] = chaotic_position.copy()\n                            if chaotic_score < global_best_score:\n                                global_best_score = chaotic_score\n                                global_best_position = chaotic_position.copy()\n\n                    cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[swarm][i] - positions[swarm][i])\n                    social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[swarm][i])\n                    velocities[swarm][i] = inertia_weight * velocities[swarm][i] + cognitive_component + social_component\n                    \n                    velocities[swarm][i] = np.clip(velocities[swarm][i], -self.velocity_clamp, self.velocity_clamp)\n                    \n                    positions[swarm][i] += velocities[swarm][i]\n                    positions[swarm][i] = np.clip(positions[swarm][i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# multi_swarm_pso = MultiSwarmCooperativePSO(budget=10000, dim=10)\n# multi_swarm_pso(func)", "name": "MultiSwarmCooperativePSO", "description": "Multi-Swarm Cooperative PSO with adaptive parameters and sporadic chaotic local search for enhanced exploration and convergence.", "configspace": "", "generation": 35, "fitness": 0.260727235033614, "feedback": "The algorithm MultiSwarmCooperativePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6341833100398712, 0.6341833100398712, 0.6341833100398712, 0.6290505990230466, 0.6290505990230466, 0.6290505990230466, 0.6090137928177349, 0.6090137928177349, 0.6090137928177349, 0.24096117330728284, 0.24096117330728284, 0.24096117330728284, 0.2456449163987543, 0.2456449163987543, 0.2456449163987543, 0.16872592418490695, 0.16872592418490695, 0.16872592418490695, 0.20912467977322935, 0.20912467977322935, 0.20912467977322935, 0.20574780230934409, 0.20574780230934409, 0.20574780230934409, 0.09395466546109987, 0.09395466546109987, 0.09395466546109987, 0.11043799982088076, 0.11043799982088076, 0.11043799982088076, 0.13961827056170328, 0.13961827056170328, 0.13961827056170328, 0.11920416801724643, 0.11920416801724643, 0.11920416801724643, 0.9272721167185729, 0.9272721167185729, 0.9272721167185729, 0.919274160610299, 0.919274160610299, 0.919274160610299, 0.9251231932482695, 0.9251231932482695, 0.9251231932482695, 0.3713167923965851, 0.3713167923965851, 0.3713167923965851, 0.3669073494855105, 0.3669073494855105, 0.3669073494855105, 0.3569455064568128, 0.3569455064568128, 0.3569455064568128, 0.5195314934908088, 0.5195314934908088, 0.5195314934908088, 0.26488957484373554, 0.26488957484373554, 0.26488957484373554, 0.24941841633239326, 0.24941841633239326, 0.24941841633239326, 0.16425650801498082, 0.16425650801498082, 0.16425650801498082, 0.1919583349290962, 0.1919583349290962, 0.1919583349290962, 0.28717090236178433, 0.28717090236178433, 0.28717090236178433, 0.18471750092621853, 0.18471750092621853, 0.18471750092621853, 0.17638792979172901, 0.17638792979172901, 0.17638792979172901, 0.19785791621829585, 0.19785791621829585, 0.19785791621829585, 0.04174300793822494, 0.04174300793822494, 0.04174300793822494, 0.0605348652649742, 0.0605348652649742, 0.0605348652649742, 0.005455065966330941, 0.005455065966330941, 0.005455065966330941, 0.11321020351852817, 0.11321020351852817, 0.11321020351852817, 0.08545267889634323, 0.08545267889634323, 0.08545267889634323, 0.10790212484008677, 0.10790212484008677, 0.10790212484008677, 0.08304992703140446, 0.08304992703140446, 0.08304992703140446, 0.09015152127737425, 0.09015152127737425, 0.09015152127737425, 0.11336253857744483, 0.11336253857744483, 0.11336253857744483, 0.10896924397027141, 0.10896924397027141, 0.10896924397027141, 0.07746183295760223, 0.07746183295760223, 0.07746183295760223, 0.130635922911833, 0.130635922911833, 0.130635922911833, 0.4579234673631023, 0.4579234673631023, 0.4579234673631023, 0.43364582272811236, 0.43364582272811236, 0.43364582272811236, 0.463595879796423, 0.463595879796423, 0.463595879796423, 0.09238385672974803, 0.09238385672974803, 0.09238385672974803, 0.10315613112013511, 0.10315613112013511, 0.10315613112013511, 0.1261850563505641, 0.1261850563505641, 0.1261850563505641, 0.17377395483099012, 0.17377395483099012, 0.17377395483099012, 0.28476874529078555, 0.28476874529078555, 0.28476874529078555, 0.3370459435360196, 0.3370459435360196, 0.3370459435360196, 0.349043538839403, 0.349043538839403, 0.349043538839403, 0.3574899638654102, 0.3574899638654102, 0.3574899638654102, 0.3448401901633552, 0.3448401901633552, 0.3448401901633552, 0.22023694278385586, 0.22023694278385586, 0.22023694278385586, 0.22399635424682218, 0.22399635424682218, 0.22399635424682218, 0.20809334766754994, 0.20809334766754994, 0.20809334766754994, 0.20937858308308455, 0.20937858308308455, 0.20937858308308455, 0.2083780311794612, 0.2083780311794612, 0.2083780311794612, 0.23420876673203206, 0.23420876673203206, 0.23420876673203206, 0.21257325372090996, 0.21257325372090996, 0.21257325372090996, 0.21367516357150862, 0.21367516357150862, 0.21367516357150862, 0.18532277055868573, 0.18532277055868573, 0.18532277055868573, 0.18559039449778936, 0.18559039449778936, 0.18559039449778936, 0.7754343772843699, 0.7754343772843699, 0.7754343772843699, 0.14186361114450952, 0.14186361114450952, 0.14186361114450952, 0.5738721591742216, 0.5738721591742216, 0.5738721591742216, 0.20821897849229964, 0.20821897849229964, 0.20821897849229964, 0.10437878382126986, 0.10437878382126986, 0.10437878382126986, 0.1936339201076709, 0.1936339201076709, 0.1936339201076709, 0.18025591045429135, 0.18025591045429135, 0.18025591045429135, 0.183142998389765, 0.183142998389765, 0.183142998389765, 0.09739647250939087, 0.09739647250939087, 0.09739647250939087, 0.07269611268445164, 0.07269611268445164, 0.07269611268445164, 0.08953750901160862, 0.08953750901160862, 0.08953750901160862]}, "mutation_prompt": null}
{"id": "58cc09a8-68a6-46bb-a80d-bbec3bcf9e30", "solution": "import numpy as np\n\nclass DynamicSwarmOptimizer:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted minimum inertia weight for more balanced exploration\n        self.c1_initial = 2.5  # Increased cognitive factor for enhanced local search\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Further increased social factor to strengthen convergence\n        self.velocity_clamp = 0.4  # Slightly reduced velocity clamping for improved control\n        self.local_search_probability = 0.15  # Increased probability for local search integration\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# dynamic_swarm_optimizer = DynamicSwarmOptimizer(budget=10000, dim=10)\n# dynamic_swarm_optimizer(func)", "name": "DynamicSwarmOptimizer", "description": "A dynamic swarm-based optimization algorithm utilizing adaptive inertia and probabilistic local search to enhance global convergence and solution refinement.", "configspace": "", "generation": 36, "fitness": 0.266208974923036, "feedback": "The algorithm DynamicSwarmOptimizer got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6508909976714158, 0.6508909976714158, 0.6508909976714158, 0.6403350054716745, 0.6403350054716745, 0.6403350054716745, 0.6539088070676209, 0.6539088070676209, 0.6539088070676209, 0.24897785329534083, 0.24897785329534083, 0.24897785329534083, 0.1914608305768769, 0.1914608305768769, 0.1914608305768769, 0.234401130162734, 0.234401130162734, 0.234401130162734, 0.1375314119008222, 0.1375314119008222, 0.1375314119008222, 0.08899907482360414, 0.08899907482360414, 0.08899907482360414, 0.1092904990675615, 0.1092904990675615, 0.1092904990675615, 0.08832385032583134, 0.08832385032583134, 0.08832385032583134, 0.11110262197730258, 0.11110262197730258, 0.11110262197730258, 0.1157536039431123, 0.1157536039431123, 0.1157536039431123, 0.8623620157935471, 0.8623620157935471, 0.8623620157935471, 0.8356332318106341, 0.8356332318106341, 0.8356332318106341, 0.8515491723198995, 0.8515491723198995, 0.8515491723198995, 0.3810574981879731, 0.3810574981879731, 0.3810574981879731, 0.41461967666164823, 0.41461967666164823, 0.41461967666164823, 0.3721633152602396, 0.3721633152602396, 0.3721633152602396, 0.663577650398078, 0.663577650398078, 0.663577650398078, 0.2769373472423945, 0.2769373472423945, 0.2769373472423945, 0.23117656739044357, 0.23117656739044357, 0.23117656739044357, 0.19504944382453926, 0.19504944382453926, 0.19504944382453926, 0.22068579273526268, 0.22068579273526268, 0.22068579273526268, 0.17083739915045626, 0.17083739915045626, 0.17083739915045626, 0.1935799335433962, 0.1935799335433962, 0.1935799335433962, 0.1820152136183183, 0.1820152136183183, 0.1820152136183183, 0.1589619504541997, 0.1589619504541997, 0.1589619504541997, 0.027465303340150626, 0.027465303340150626, 0.027465303340150626, 0.04025048174907275, 0.04025048174907275, 0.04025048174907275, 0.07821194303280932, 0.07821194303280932, 0.07821194303280932, 0.132763330678222, 0.132763330678222, 0.132763330678222, 0.09640374123952733, 0.09640374123952733, 0.09640374123952733, 0.08334155510253516, 0.08334155510253516, 0.08334155510253516, 0.12426756042894527, 0.12426756042894527, 0.12426756042894527, 0.06003236648628496, 0.06003236648628496, 0.06003236648628496, 0.10981648998483506, 0.10981648998483506, 0.10981648998483506, 0.10084515868371857, 0.10084515868371857, 0.10084515868371857, 0.06892737514536751, 0.06892737514536751, 0.06892737514536751, 0.11650925513533916, 0.11650925513533916, 0.11650925513533916, 0.49831557678541416, 0.49831557678541416, 0.49831557678541416, 0.4721966724953316, 0.4721966724953316, 0.4721966724953316, 0.4717836197302, 0.4717836197302, 0.4717836197302, 0.0910720933472865, 0.0910720933472865, 0.0910720933472865, 0.10431974923303766, 0.10431974923303766, 0.10431974923303766, 0.1568281642252598, 0.1568281642252598, 0.1568281642252598, 0.23677835954099713, 0.23677835954099713, 0.23677835954099713, 0.2321223054079592, 0.2321223054079592, 0.2321223054079592, 0.33006623041147143, 0.33006623041147143, 0.33006623041147143, 0.3270261114383478, 0.3270261114383478, 0.3270261114383478, 0.36106962706522905, 0.36106962706522905, 0.36106962706522905, 0.24304556675724454, 0.24304556675724454, 0.24304556675724454, 0.18588530473778597, 0.18588530473778597, 0.18588530473778597, 0.2841906383561773, 0.2841906383561773, 0.2841906383561773, 0.23529083687079888, 0.23529083687079888, 0.23529083687079888, 0.20074314152832162, 0.20074314152832162, 0.20074314152832162, 0.422380174013669, 0.422380174013669, 0.422380174013669, 0.23445268841586364, 0.23445268841586364, 0.23445268841586364, 0.1768736249237114, 0.1768736249237114, 0.1768736249237114, 0.17908834569572663, 0.17908834569572663, 0.17908834569572663, 0.19117286917594045, 0.19117286917594045, 0.19117286917594045, 0.17216594648604877, 0.17216594648604877, 0.17216594648604877, 0.7668415755010013, 0.7668415755010013, 0.7668415755010013, 0.1414162116950043, 0.1414162116950043, 0.1414162116950043, 0.629267873735228, 0.629267873735228, 0.629267873735228, 0.16581031438232707, 0.16581031438232707, 0.16581031438232707, 0.49012755242352146, 0.49012755242352146, 0.49012755242352146, 0.1738381812171097, 0.1738381812171097, 0.1738381812171097, 0.18723527353380576, 0.18723527353380576, 0.18723527353380576, 0.19085696925275697, 0.19085696925275697, 0.19085696925275697, 0.12602413873597795, 0.12602413873597795, 0.12602413873597795, 0.0769630306286172, 0.0769630306286172, 0.0769630306286172, 0.09178097102968608, 0.09178097102968608, 0.09178097102968608]}, "mutation_prompt": null}
{"id": "9669d164-e516-42ea-abd0-f61fabc2f35a", "solution": "import numpy as np\n\nclass HybridDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Adjusted for enhanced swarm diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_init = 0.8\n        self.w_final = 0.2  # More aggressive weight decay for faster convergence\n        self.c1_init = 2.5  # Increased initial cognitive factor for diversity\n        self.c2_init = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Maximize social influence over time\n        self.velocity_clamp = 0.6  # Slightly relaxed clamping\n        self.local_search_probability = 0.15  # Enhanced local search frequency\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_init - ((self.w_init - self.w_final) * evaluations / self.budget)\n            c1 = self.c1_init - ((self.c1_init - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_init + ((self.c2_final - self.c2_init) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)  # Increased perturbation magnitude\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_dynamic_pso = HybridDynamicPSO(budget=10000, dim=10)\n# hybrid_dynamic_pso(func)", "name": "HybridDynamicPSO", "description": "A hybrid Particle Swarm Optimization enhanced with dynamic local search strategies and adaptive momentum for improved exploration and exploitation balance.", "configspace": "", "generation": 37, "fitness": 0.3062384165260148, "feedback": "The algorithm HybridDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.24.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.730593340222617, 0.730593340222617, 0.730593340222617, 0.7352574862611956, 0.7352574862611956, 0.7352574862611956, 0.7286147323031127, 0.7286147323031127, 0.7286147323031127, 0.4444914141441384, 0.4444914141441384, 0.4444914141441384, 0.47973847468605, 0.47973847468605, 0.47973847468605, 0.415299938541298, 0.415299938541298, 0.415299938541298, 0.15063833997723453, 0.15063833997723453, 0.15063833997723453, 0.10927308983923845, 0.10927308983923845, 0.10927308983923845, 0.14678730690911157, 0.14678730690911157, 0.14678730690911157, 0.12087338325324959, 0.12087338325324959, 0.12087338325324959, 0.09583991613916354, 0.09583991613916354, 0.09583991613916354, 0.13182778100457815, 0.13182778100457815, 0.13182778100457815, 0.893631207407019, 0.893631207407019, 0.893631207407019, 0.8847090155326974, 0.8847090155326974, 0.8847090155326974, 0.8908753660093753, 0.8908753660093753, 0.8908753660093753, 0.45188641734429436, 0.45188641734429436, 0.45188641734429436, 0.45663306082344224, 0.45663306082344224, 0.45663306082344224, 0.427771954443942, 0.427771954443942, 0.427771954443942, 0.6060164642158004, 0.6060164642158004, 0.6060164642158004, 0.6443606922663299, 0.6443606922663299, 0.6443606922663299, 0.23463479584584046, 0.23463479584584046, 0.23463479584584046, 0.20464550800362646, 0.20464550800362646, 0.20464550800362646, 0.17591311022179146, 0.17591311022179146, 0.17591311022179146, 0.18855100810939196, 0.18855100810939196, 0.18855100810939196, 0.21457053877135446, 0.21457053877135446, 0.21457053877135446, 0.12686486896615645, 0.12686486896615645, 0.12686486896615645, 0.17106339359041123, 0.17106339359041123, 0.17106339359041123, 0.06605058133632757, 0.06605058133632757, 0.06605058133632757, 0.00541020023328509, 0.00541020023328509, 0.00541020023328509, 0.03354167099191274, 0.03354167099191274, 0.03354167099191274, 0.2062984102047386, 0.2062984102047386, 0.2062984102047386, 0.09300725628668605, 0.09300725628668605, 0.09300725628668605, 0.2557876193384465, 0.2557876193384465, 0.2557876193384465, 0.12229392620382329, 0.12229392620382329, 0.12229392620382329, 0.12367529668077282, 0.12367529668077282, 0.12367529668077282, 0.0991321990752082, 0.0991321990752082, 0.0991321990752082, 0.09635903584659844, 0.09635903584659844, 0.09635903584659844, 0.08495784222113811, 0.08495784222113811, 0.08495784222113811, 0.1368911748851841, 0.1368911748851841, 0.1368911748851841, 0.5120528702614986, 0.5120528702614986, 0.5120528702614986, 0.4834467458761983, 0.4834467458761983, 0.4834467458761983, 0.5296432697169751, 0.5296432697169751, 0.5296432697169751, 0.07713267116355149, 0.07713267116355149, 0.07713267116355149, 0.14636749880137412, 0.14636749880137412, 0.14636749880137412, 0.13439663953853465, 0.13439663953853465, 0.13439663953853465, 0.17282122090040142, 0.17282122090040142, 0.17282122090040142, 0.2821927759347299, 0.2821927759347299, 0.2821927759347299, 0.19602135739358284, 0.19602135739358284, 0.19602135739358284, 0.4043586934181933, 0.4043586934181933, 0.4043586934181933, 0.39054246130213965, 0.39054246130213965, 0.39054246130213965, 0.23495557554094693, 0.23495557554094693, 0.23495557554094693, 0.27089673122599134, 0.27089673122599134, 0.27089673122599134, 0.23690909698490936, 0.23690909698490936, 0.23690909698490936, 0.281321415775141, 0.281321415775141, 0.281321415775141, 0.22670069174989504, 0.22670069174989504, 0.22670069174989504, 0.20613999391519877, 0.20613999391519877, 0.20613999391519877, 0.22114449151748938, 0.22114449151748938, 0.22114449151748938, 0.18925006518494214, 0.18925006518494214, 0.18925006518494214, 0.19586088791574152, 0.19586088791574152, 0.19586088791574152, 0.20648751268627163, 0.20648751268627163, 0.20648751268627163, 0.8307057005866605, 0.8307057005866605, 0.8307057005866605, 0.8784611282406916, 0.8784611282406916, 0.8784611282406916, 0.14190957870735033, 0.14190957870735033, 0.14190957870735033, 0.6764234594406955, 0.6764234594406955, 0.6764234594406955, 0.20832395327378106, 0.20832395327378106, 0.20832395327378106, 0.6452811187832903, 0.6452811187832903, 0.6452811187832903, 0.21710587925025993, 0.21710587925025993, 0.21710587925025993, 0.1883806031997025, 0.1883806031997025, 0.1883806031997025, 0.20561840096649675, 0.20561840096649675, 0.20561840096649675, 0.09175160053312759, 0.09175160053312759, 0.09175160053312759, 0.07055949308137954, 0.07055949308137954, 0.07055949308137954, 0.11123458886934134, 0.11123458886934134, 0.11123458886934134]}, "mutation_prompt": null}
{"id": "496b0867-3db4-4e8e-88c2-b8b3ab9e4953", "solution": "import numpy as np\n\nclass EnhancedPSOWithSGD:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 40  # Adjusted number of particles for exploration-exploitation balance\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Fine-tuned maximum inertia weight for better stabilization\n        self.w_min = 0.4  # Increased minimum inertia weight\n        self.c1_initial = 1.5  # Adjusted initial cognitive factor\n        self.c2_initial = 2.0\n        self.c1_final = 1.0\n        self.c2_final = 2.5  # Adjusted final social factor to enhance convergence\n        self.velocity_clamp = 0.6  # Adjusted velocity clamping for improved dynamic control\n        self.local_search_probability = 0.15  # Increased probability of local search\n        self.sgd_learning_rate = 0.01  # Learning rate for stochastic gradient descent\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    gradient = np.random.normal(0, 1, self.dim)\n                    candidate_position = positions[i] - self.sgd_learning_rate * gradient\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso_sgd = EnhancedPSOWithSGD(budget=10000, dim=10)\n# enhanced_pso_sgd(func)", "name": "EnhancedPSOWithSGD", "description": "An enhanced Particle Swarm Optimization with adaptive inertia and velocity scaling, incorporating stochastic gradient descent to refine individual solutions.", "configspace": "", "generation": 38, "fitness": 0.3060294585081667, "feedback": "The algorithm EnhancedPSOWithSGD got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.8050965850237717, 0.8050965850237717, 0.8050965850237717, 0.8025733095197982, 0.8025733095197982, 0.8025733095197982, 0.7880357910678399, 0.7880357910678399, 0.7880357910678399, 0.5381604163378109, 0.5381604163378109, 0.5381604163378109, 0.5646755902194387, 0.5646755902194387, 0.5646755902194387, 0.5446413907841448, 0.5446413907841448, 0.5446413907841448, 0.0938045301192677, 0.0938045301192677, 0.0938045301192677, 0.12359408244347991, 0.12359408244347991, 0.12359408244347991, 0.11052196134423153, 0.11052196134423153, 0.11052196134423153, 0.09214728414785456, 0.09214728414785456, 0.09214728414785456, 0.10954565086559565, 0.10954565086559565, 0.10954565086559565, 0.11916467242567119, 0.11916467242567119, 0.11916467242567119, 0.9377023400186512, 0.9377023400186512, 0.9377023400186512, 0.9145838996111926, 0.9145838996111926, 0.9145838996111926, 0.9263339445146022, 0.9263339445146022, 0.9263339445146022, 0.5410447645282611, 0.5410447645282611, 0.5410447645282611, 0.6022270604303579, 0.6022270604303579, 0.6022270604303579, 0.5633220239311236, 0.5633220239311236, 0.5633220239311236, 0.830477553860717, 0.830477553860717, 0.830477553860717, 0.27182468104671176, 0.27182468104671176, 0.27182468104671176, 0.1776033168139889, 0.1776033168139889, 0.1776033168139889, 0.356576211306467, 0.356576211306467, 0.356576211306467, 0.2308629228341581, 0.2308629228341581, 0.2308629228341581, 0.19376553361262616, 0.19376553361262616, 0.19376553361262616, 0.22601326094444996, 0.22601326094444996, 0.22601326094444996, 0.1970665315846184, 0.1970665315846184, 0.1970665315846184, 0.22330915298694065, 0.22330915298694065, 0.22330915298694065, 0.0073627673414427, 0.0073627673414427, 0.0073627673414427, 0.056123716613878605, 0.056123716613878605, 0.056123716613878605, 0.01193414492901268, 0.01193414492901268, 0.01193414492901268, 0.1710410577360839, 0.1710410577360839, 0.1710410577360839, 0.07342287825175575, 0.07342287825175575, 0.07342287825175575, 0.11447111222979511, 0.11447111222979511, 0.11447111222979511, 0.173770493365352, 0.173770493365352, 0.173770493365352, 0.17262143495057458, 0.17262143495057458, 0.17262143495057458, 0.08677605972423752, 0.08677605972423752, 0.08677605972423752, 0.09941000218569407, 0.09941000218569407, 0.09941000218569407, 0.10844990555846556, 0.10844990555846556, 0.10844990555846556, 0.13262481765759382, 0.13262481765759382, 0.13262481765759382, 0.5121137976629659, 0.5121137976629659, 0.5121137976629659, 0.5433859610628873, 0.5433859610628873, 0.5433859610628873, 0.5427470185346254, 0.5427470185346254, 0.5427470185346254, 0.08402761450299845, 0.08402761450299845, 0.08402761450299845, 0.10747720993855236, 0.10747720993855236, 0.10747720993855236, 0.09948046298894064, 0.09948046298894064, 0.09948046298894064, 0.19964400089249013, 0.19964400089249013, 0.19964400089249013, 0.24398194328756295, 0.24398194328756295, 0.24398194328756295, 0.3063115000112667, 0.3063115000112667, 0.3063115000112667, 0.22783591038851414, 0.22783591038851414, 0.22783591038851414, 0.23890935163404925, 0.23890935163404925, 0.23890935163404925, 0.29214131548194255, 0.29214131548194255, 0.29214131548194255, 0.19031029582273318, 0.19031029582273318, 0.19031029582273318, 0.23718709754447043, 0.23718709754447043, 0.23718709754447043, 0.24775805667334738, 0.24775805667334738, 0.24775805667334738, 0.25174364835882734, 0.25174364835882734, 0.25174364835882734, 0.22799170549605707, 0.22799170549605707, 0.22799170549605707, 0.2250844554886673, 0.2250844554886673, 0.2250844554886673, 0.19546688219743102, 0.19546688219743102, 0.19546688219743102, 0.18048004824083042, 0.18048004824083042, 0.18048004824083042, 0.22605161354462266, 0.22605161354462266, 0.22605161354462266, 0.12588079686550713, 0.12588079686550713, 0.12588079686550713, 0.8882150453342792, 0.8882150453342792, 0.8882150453342792, 0.14257164971774272, 0.14257164971774272, 0.14257164971774272, 0.6548320879572307, 0.6548320879572307, 0.6548320879572307, 0.20944587678183968, 0.20944587678183968, 0.20944587678183968, 0.634184423104742, 0.634184423104742, 0.634184423104742, 0.22199198729172587, 0.22199198729172587, 0.22199198729172587, 0.239892520311892, 0.239892520311892, 0.239892520311892, 0.1957658608031898, 0.1957658608031898, 0.1957658608031898, 0.09421684293944854, 0.09421684293944854, 0.09421684293944854, 0.07510537207847523, 0.07510537207847523, 0.07510537207847523, 0.07920580678048994, 0.07920580678048994, 0.07920580678048994]}, "mutation_prompt": null}
{"id": "a2228721-5bbe-4832-929a-bf26dcea5a5e", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Adjusted inertia weight for better exploration-exploitation balance\n        self.c1_initial = 1.8  # Modified cognitive factor for adaptive behavior\n        self.c2_initial = 1.7\n        self.c1_final = 1.3\n        self.c2_final = 2.7\n        self.velocity_clamp = 0.7  # Increased velocity clamping to encourage broader search\n        self.local_search_probability = 0.1\n        self.de_mutation_factor = 0.8  # Added Differential Evolution mutation factor\n        self.de_crossover_probability = 0.9  # Added Differential Evolution crossover probability\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        \n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                r1, r2, r3 = np.random.choice(self.num_particles, 3, replace=False)  # Selecting random particles\n                mutant = positions[r1] + self.de_mutation_factor * (positions[r2] - positions[r3])\n                mutant = np.clip(mutant, self.lower_bound, self.upper_bound)\n                trial = np.where(np.random.rand(self.dim) < self.de_crossover_probability, mutant, positions[i])\n                trial_score = func(trial)\n                evaluations += 1\n                if trial_score < personal_best_scores[i]:\n                    personal_best_scores[i] = trial_score\n                    personal_best_positions[i] = trial\n                    if trial_score < global_best_score:\n                        global_best_score = trial_score\n                        global_best_position = trial.copy()\n                    \n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_pso = HybridAdaptivePSO(budget=10000, dim=10)\n# hybrid_pso(func)", "name": "HybridAdaptivePSO", "description": "A Hybrid Particle Swarm Optimization with adaptive weights, integrated differential evolution, and local search for improved exploration and exploitation balance.", "configspace": "", "generation": 39, "fitness": 0.27443757122912965, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.625638553434295, 0.625638553434295, 0.625638553434295, 0.6043133849940443, 0.6043133849940443, 0.6043133849940443, 0.6024928073461571, 0.6024928073461571, 0.6024928073461571, 0.2261113190513836, 0.2261113190513836, 0.2261113190513836, 0.22800143041471255, 0.22800143041471255, 0.22800143041471255, 0.09857993785325747, 0.09857993785325747, 0.09857993785325747, 0.285525461864498, 0.285525461864498, 0.285525461864498, 0.0997636598142666, 0.0997636598142666, 0.0997636598142666, 0.10814256147798917, 0.10814256147798917, 0.10814256147798917, 0.12480332048076159, 0.12480332048076159, 0.12480332048076159, 0.11060555006416284, 0.11060555006416284, 0.11060555006416284, 0.10075465912318982, 0.10075465912318982, 0.10075465912318982, 0.8985217421758628, 0.8985217421758628, 0.8985217421758628, 0.8979757877487484, 0.8979757877487484, 0.8979757877487484, 0.8915947528295907, 0.8915947528295907, 0.8915947528295907, 0.36144465246116675, 0.36144465246116675, 0.36144465246116675, 0.3561610690165189, 0.3561610690165189, 0.3561610690165189, 0.32395731450855114, 0.32395731450855114, 0.32395731450855114, 0.6098625507371039, 0.6098625507371039, 0.6098625507371039, 0.6764853803702452, 0.6764853803702452, 0.6764853803702452, 0.2207746994722054, 0.2207746994722054, 0.2207746994722054, 0.22937699226646857, 0.22937699226646857, 0.22937699226646857, 0.1514748222473954, 0.1514748222473954, 0.1514748222473954, 0.17776012028859456, 0.17776012028859456, 0.17776012028859456, 0.1951305315158003, 0.1951305315158003, 0.1951305315158003, 0.16029294860175436, 0.16029294860175436, 0.16029294860175436, 0.17820854812201747, 0.17820854812201747, 0.17820854812201747, 0.0003443218343250898, 0.0003443218343250898, 0.0003443218343250898, 0.04999764125041806, 0.04999764125041806, 0.04999764125041806, 0.02870559512932691, 0.02870559512932691, 0.02870559512932691, 0.113518035946366, 0.113518035946366, 0.113518035946366, 0.05181792115898565, 0.05181792115898565, 0.05181792115898565, 0.10656810366599001, 0.10656810366599001, 0.10656810366599001, 0.019544408789893386, 0.019544408789893386, 0.019544408789893386, 0.031056517992671395, 0.031056517992671395, 0.031056517992671395, 0.05467479528928221, 0.05467479528928221, 0.05467479528928221, 0.10006508636688527, 0.10006508636688527, 0.10006508636688527, 0.17537103178459967, 0.17537103178459967, 0.17537103178459967, 0.12193900992756912, 0.12193900992756912, 0.12193900992756912, 0.4390965321361606, 0.4390965321361606, 0.4390965321361606, 0.447167820260845, 0.447167820260845, 0.447167820260845, 0.4405180181633199, 0.4405180181633199, 0.4405180181633199, 0.10847442675421659, 0.10847442675421659, 0.10847442675421659, 0.14111122479898508, 0.14111122479898508, 0.14111122479898508, 0.10297809566734051, 0.10297809566734051, 0.10297809566734051, 0.2761354587430205, 0.2761354587430205, 0.2761354587430205, 0.22788920519370903, 0.22788920519370903, 0.22788920519370903, 0.21446267421224963, 0.21446267421224963, 0.21446267421224963, 0.29571591996898194, 0.29571591996898194, 0.29571591996898194, 0.3443999522176886, 0.3443999522176886, 0.3443999522176886, 0.36011468845296213, 0.36011468845296213, 0.36011468845296213, 0.25364558248450064, 0.25364558248450064, 0.25364558248450064, 0.23881992859267953, 0.23881992859267953, 0.23881992859267953, 0.20827114719079232, 0.20827114719079232, 0.20827114719079232, 0.20929837004456242, 0.20929837004456242, 0.20929837004456242, 0.20833591902940363, 0.20833591902940363, 0.20833591902940363, 0.24328177545327345, 0.24328177545327345, 0.24328177545327345, 0.18837619063474553, 0.18837619063474553, 0.18837619063474553, 0.21572965850311743, 0.21572965850311743, 0.21572965850311743, 0.22286433572360476, 0.22286433572360476, 0.22286433572360476, 0.18470301016701773, 0.18470301016701773, 0.18470301016701773, 0.7542459573569134, 0.7542459573569134, 0.7542459573569134, 0.7582530826002652, 0.7582530826002652, 0.7582530826002652, 0.688487282075156, 0.688487282075156, 0.688487282075156, 0.16630830307635247, 0.16630830307635247, 0.16630830307635247, 0.573021988714808, 0.573021988714808, 0.573021988714808, 0.19517289743565824, 0.19517289743565824, 0.19517289743565824, 0.19932828069786968, 0.19932828069786968, 0.19932828069786968, 0.19007232995755763, 0.19007232995755763, 0.19007232995755763, 0.09407457658327478, 0.09407457658327478, 0.09407457658327478, 0.08584284211617121, 0.08584284211617121, 0.08584284211617121, 0.08595062607307713, 0.08595062607307713, 0.08595062607307713]}, "mutation_prompt": null}
{"id": "8372f3b5-5749-47a7-baad-d0c7d8974c2a", "solution": "import numpy as np\n\nclass DynamicTopologyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for broader exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.4  # Adjusted inertia weight for better balance\n        self.c1_initial = 1.8  # Fine-tuned cognitive factor\n        self.c2_initial = 1.7\n        self.c1_final = 1.0\n        self.c2_final = 2.5  # Reduced social factor for more balanced convergence\n        self.velocity_clamp = 0.6  # Adjusted velocity clamping for dynamic control\n        self.local_search_probability = 0.15  # Increased probability for local search\n        self.topology_switch_probability = 0.2  # Probability to switch between topologies\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        use_ring_topology = True  # Start with a ring topology\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            if np.random.rand() < self.topology_switch_probability:\n                use_ring_topology = not use_ring_topology  # Switch topology\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.15, self.dim)  # Increased mutation strength\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                if use_ring_topology:\n                    neighbors = [personal_best_positions[j] for j in [(i-1) % self.num_particles, i, (i+1) % self.num_particles]]\n                    best_neighbor_position = min(neighbors, key=lambda x: func(x))\n                else:\n                    best_neighbor_position = global_best_position\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (best_neighbor_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "DynamicTopologyPSO", "description": "Enhanced PSO with dynamic topology adjustment and adaptive mutation for diverse search and improved convergence.", "configspace": "", "generation": 40, "fitness": 0.20288393796688756, "feedback": "The algorithm DynamicTopologyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.20 with standard deviation 0.16.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.4346055318414166, 0.4346055318414166, 0.4346055318414166, 0.43852763839580355, 0.43852763839580355, 0.43852763839580355, 0.41785889174913404, 0.41785889174913404, 0.41785889174913404, 0.07959063683061118, 0.07959063683061118, 0.07959063683061118, 0.10539311027136267, 0.10539311027136267, 0.10539311027136267, 0.01632818572155481, 0.01632818572155481, 0.01632818572155481, 0.10254998365089363, 0.10254998365089363, 0.10254998365089363, 0.08652733740955443, 0.08652733740955443, 0.08652733740955443, 0.09445420681221217, 0.09445420681221217, 0.09445420681221217, 0.12462462021990883, 0.12462462021990883, 0.12462462021990883, 0.12142073060735459, 0.12142073060735459, 0.12142073060735459, 0.1048181040558166, 0.1048181040558166, 0.1048181040558166, 0.7534961543001328, 0.7534961543001328, 0.7534961543001328, 0.7315548201299482, 0.7315548201299482, 0.7315548201299482, 0.7379473528569123, 0.7379473528569123, 0.7379473528569123, 0.29448201079937353, 0.29448201079937353, 0.29448201079937353, 0.27393486204477124, 0.27393486204477124, 0.27393486204477124, 0.2795311698362938, 0.2795311698362938, 0.2795311698362938, 0.21505179892900028, 0.21505179892900028, 0.21505179892900028, 0.2523959029903945, 0.2523959029903945, 0.2523959029903945, 0.18371123440411352, 0.18371123440411352, 0.18371123440411352, 0.14088991421072006, 0.14088991421072006, 0.14088991421072006, 0.19311381453247334, 0.19311381453247334, 0.19311381453247334, 0.12373699077435973, 0.12373699077435973, 0.12373699077435973, 0.1740276543137943, 0.1740276543137943, 0.1740276543137943, 0.11534645817907108, 0.11534645817907108, 0.11534645817907108, 0.15922411972494088, 0.15922411972494088, 0.15922411972494088, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.017048845605257323, 0.017048845605257323, 0.017048845605257323, 0.007864270475588797, 0.007864270475588797, 0.007864270475588797, 0.11402263782315747, 0.11402263782315747, 0.11402263782315747, 0.060802722596495884, 0.060802722596495884, 0.060802722596495884, 0.13551455047594974, 0.13551455047594974, 0.13551455047594974, 0.000867844720644495, 0.000867844720644495, 0.000867844720644495, 0.009179226228893222, 0.009179226228893222, 0.009179226228893222, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10765223618487962, 0.10765223618487962, 0.10765223618487962, 0.048476746740689136, 0.048476746740689136, 0.048476746740689136, 0.09476476179807236, 0.09476476179807236, 0.09476476179807236, 0.3986107710917135, 0.3986107710917135, 0.3986107710917135, 0.38494146237034244, 0.38494146237034244, 0.38494146237034244, 0.4281541870920801, 0.4281541870920801, 0.4281541870920801, 0.06544931778115592, 0.06544931778115592, 0.06544931778115592, 0.10445149312156976, 0.10445149312156976, 0.10445149312156976, 0.09436736301711113, 0.09436736301711113, 0.09436736301711113, 0.21373806271004436, 0.21373806271004436, 0.21373806271004436, 0.16740510790595453, 0.16740510790595453, 0.16740510790595453, 0.1565264308045654, 0.1565264308045654, 0.1565264308045654, 0.20362571011690556, 0.20362571011690556, 0.20362571011690556, 0.25918460127445775, 0.25918460127445775, 0.25918460127445775, 0.2002125070610381, 0.2002125070610381, 0.2002125070610381, 0.19805658089506872, 0.19805658089506872, 0.19805658089506872, 0.22981335923547175, 0.22981335923547175, 0.22981335923547175, 0.16994095736534653, 0.16994095736534653, 0.16994095736534653, 0.2029947996788517, 0.2029947996788517, 0.2029947996788517, 0.20309618423858777, 0.20309618423858777, 0.20309618423858777, 0.21222052126062785, 0.21222052126062785, 0.21222052126062785, 0.1897593376859058, 0.1897593376859058, 0.1897593376859058, 0.18419053128393403, 0.18419053128393403, 0.18419053128393403, 0.18056607905826072, 0.18056607905826072, 0.18056607905826072, 0.16429685188093135, 0.16429685188093135, 0.16429685188093135, 0.5634059767113376, 0.5634059767113376, 0.5634059767113376, 0.1568127856855448, 0.1568127856855448, 0.1568127856855448, 0.37619387153746875, 0.37619387153746875, 0.37619387153746875, 0.39194499881213574, 0.39194499881213574, 0.39194499881213574, 0.3927391660900835, 0.3927391660900835, 0.3927391660900835, 0.18337604075595626, 0.18337604075595626, 0.18337604075595626, 0.1713754742216702, 0.1713754742216702, 0.1713754742216702, 0.179043590006981, 0.179043590006981, 0.179043590006981, 0.08351405146129187, 0.08351405146129187, 0.08351405146129187, 0.07899313768330973, 0.07899313768330973, 0.07899313768330973, 0.06710514547864876, 0.06710514547864876, 0.06710514547864876]}, "mutation_prompt": null}
{"id": "1c6743f8-4db4-48cb-85aa-81a16939cff0", "solution": "import numpy as np\n\nclass MultiPhaseAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased particles for more robustness\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.4  # Modified inertia range for better balance\n        self.c1_initial = 1.5\n        self.c2_initial = 1.5\n        self.c1_final = 2.0\n        self.c2_final = 2.5  # Adjusted social factor to enhance convergence\n        self.velocity_clamp = 0.4  # Modified velocity clamp for refined movements\n        self.local_search_probability = 0.2  # Increased probability for local search\n        self.global_perturbation_chance = 0.1  # Added global perturbation strategy\n\n    def __call__(self, func):\n        np.random.seed(1)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial + ((self.c1_final - self.c1_initial) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                if np.random.rand() < self.global_perturbation_chance:\n                    global_perturbation = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    positions[i] = global_perturbation\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# multi_phase_pso = MultiPhaseAdaptivePSO(budget=10000, dim=10)\n# multi_phase_pso(func)", "name": "MultiPhaseAdaptivePSO", "description": "A multi-phase adaptive Particle Swarm Optimization with dynamic boundary handling and stochastic perturbations for robust exploration and exploitation.", "configspace": "", "generation": 41, "fitness": 0.22717641878017542, "feedback": "The algorithm MultiPhaseAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.5475404249011153, 0.5475404249011153, 0.5475404249011153, 0.4929571983109061, 0.4929571983109061, 0.4929571983109061, 0.5389775090079973, 0.5389775090079973, 0.5389775090079973, 0.16890258870978758, 0.16890258870978758, 0.16890258870978758, 0.04832093214032429, 0.04832093214032429, 0.04832093214032429, 0.06361900353984928, 0.06361900353984928, 0.06361900353984928, 0.1201088776723489, 0.1201088776723489, 0.1201088776723489, 0.10499546294600315, 0.10499546294600315, 0.10499546294600315, 0.10480355074844605, 0.10480355074844605, 0.10480355074844605, 0.07748209531472605, 0.07748209531472605, 0.07748209531472605, 0.09620201058696054, 0.09620201058696054, 0.09620201058696054, 0.0959783781936212, 0.0959783781936212, 0.0959783781936212, 0.7758851143749251, 0.7758851143749251, 0.7758851143749251, 0.7582794860515528, 0.7582794860515528, 0.7582794860515528, 0.7840988667741314, 0.7840988667741314, 0.7840988667741314, 0.3316296914192809, 0.3316296914192809, 0.3316296914192809, 0.3168579674441895, 0.3168579674441895, 0.3168579674441895, 0.3053169568858255, 0.3053169568858255, 0.3053169568858255, 0.21349334492411087, 0.21349334492411087, 0.21349334492411087, 0.7383768910592498, 0.7383768910592498, 0.7383768910592498, 0.17309551718095684, 0.17309551718095684, 0.17309551718095684, 0.18837489197993562, 0.18837489197993562, 0.18837489197993562, 0.15108200744263645, 0.15108200744263645, 0.15108200744263645, 0.15328169836207073, 0.15328169836207073, 0.15328169836207073, 0.13538596308733453, 0.13538596308733453, 0.13538596308733453, 0.12340303871205649, 0.12340303871205649, 0.12340303871205649, 0.1603568395029149, 0.1603568395029149, 0.1603568395029149, 0.0031286529281630004, 0.0031286529281630004, 0.0031286529281630004, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0060151727525759036, 0.0060151727525759036, 0.0060151727525759036, 0.07219474315314733, 0.07219474315314733, 0.07219474315314733, 0.0636294986109327, 0.0636294986109327, 0.0636294986109327, 0.07489155871689213, 0.07489155871689213, 0.07489155871689213, 0.039765408141332004, 0.039765408141332004, 0.039765408141332004, 0.03805498851588085, 0.03805498851588085, 0.03805498851588085, 0.013791983548152698, 0.013791983548152698, 0.013791983548152698, 0.11795530876364502, 0.11795530876364502, 0.11795530876364502, 0.09971965663388271, 0.09971965663388271, 0.09971965663388271, 0.07183894296321502, 0.07183894296321502, 0.07183894296321502, 0.4354173338473484, 0.4354173338473484, 0.4354173338473484, 0.4102663914173602, 0.4102663914173602, 0.4102663914173602, 0.43733692830628823, 0.43733692830628823, 0.43733692830628823, 0.07986819812649959, 0.07986819812649959, 0.07986819812649959, 0.09526921206658612, 0.09526921206658612, 0.09526921206658612, 0.12023429890469284, 0.12023429890469284, 0.12023429890469284, 0.2245123367859888, 0.2245123367859888, 0.2245123367859888, 0.18362160180717602, 0.18362160180717602, 0.18362160180717602, 0.27299986299342827, 0.27299986299342827, 0.27299986299342827, 0.27230896266273585, 0.27230896266273585, 0.27230896266273585, 0.2616118682736446, 0.2616118682736446, 0.2616118682736446, 0.30184517254825094, 0.30184517254825094, 0.30184517254825094, 0.18689828056672864, 0.18689828056672864, 0.18689828056672864, 0.23245534718809924, 0.23245534718809924, 0.23245534718809924, 0.2499812831847361, 0.2499812831847361, 0.2499812831847361, 0.1970168862054672, 0.1970168862054672, 0.1970168862054672, 0.21187622621495217, 0.21187622621495217, 0.21187622621495217, 0.2407543330733941, 0.2407543330733941, 0.2407543330733941, 0.1843872770151601, 0.1843872770151601, 0.1843872770151601, 0.2086520888701212, 0.2086520888701212, 0.2086520888701212, 0.22037904458221924, 0.22037904458221924, 0.22037904458221924, 0.18552873290000593, 0.18552873290000593, 0.18552873290000593, 0.5588576429339317, 0.5588576429339317, 0.5588576429339317, 0.34855642066159664, 0.34855642066159664, 0.34855642066159664, 0.4562161539754551, 0.4562161539754551, 0.4562161539754551, 0.20125344336050777, 0.20125344336050777, 0.20125344336050777, 0.37418571175991244, 0.37418571175991244, 0.37418571175991244, 0.19053226400534284, 0.19053226400534284, 0.19053226400534284, 0.18565725965078872, 0.18565725965078872, 0.18565725965078872, 0.1818817835959612, 0.1818817835959612, 0.1818817835959612, 0.09891197924098472, 0.09891197924098472, 0.09891197924098472, 0.07279664076372538, 0.07279664076372538, 0.07279664076372538, 0.10473896268246319, 0.10473896268246319, 0.10473896268246319]}, "mutation_prompt": null}
{"id": "a8fe1d66-63be-4e3a-ae77-87e026ddc55a", "solution": "import numpy as np\n\nclass ImprovedHybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased the number of particles for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4  # Increased minimum inertia weight slightly for stability\n        self.c1_initial = 2.0\n        self.c2_initial = 1.5\n        self.c1_final = 1.0  # Reduced cognitive factor's final value for more importance on social component\n        self.c2_final = 2.9  # Slightly increased social factor's final value\n        self.velocity_clamp = 0.4  # Adjusted velocity clamping for finer control\n        self.local_search_probability = 0.15  # Increased probability to perform local search\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)  # Increased perturbation for more aggressive local search\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n\n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "ImprovedHybridAdaptivePSO", "description": "An Improved Hybrid Adaptive PSO with dynamic local search and individual particle adaptability for enhanced global and local exploitation.", "configspace": "", "generation": 42, "fitness": 0.2827611010518609, "feedback": "The algorithm ImprovedHybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6779859152248062, 0.6779859152248062, 0.6779859152248062, 0.6649118763512804, 0.6649118763512804, 0.6649118763512804, 0.6797434735791039, 0.6797434735791039, 0.6797434735791039, 0.30241096745745266, 0.30241096745745266, 0.30241096745745266, 0.32007479068193667, 0.32007479068193667, 0.32007479068193667, 0.2954171543065116, 0.2954171543065116, 0.2954171543065116, 0.1409616132497986, 0.1409616132497986, 0.1409616132497986, 0.2608363413904895, 0.2608363413904895, 0.2608363413904895, 0.11157100396488162, 0.11157100396488162, 0.11157100396488162, 0.09627224220128705, 0.09627224220128705, 0.09627224220128705, 0.12201932375953894, 0.12201932375953894, 0.12201932375953894, 0.12258212311574967, 0.12258212311574967, 0.12258212311574967, 0.859230914839094, 0.859230914839094, 0.859230914839094, 0.8287718006513729, 0.8287718006513729, 0.8287718006513729, 0.8475726514192182, 0.8475726514192182, 0.8475726514192182, 0.43298766827876967, 0.43298766827876967, 0.43298766827876967, 0.43547836067400436, 0.43547836067400436, 0.43547836067400436, 0.41583661879082345, 0.41583661879082345, 0.41583661879082345, 0.7760824828550693, 0.7760824828550693, 0.7760824828550693, 0.4088078274378396, 0.4088078274378396, 0.4088078274378396, 0.17330815241126873, 0.17330815241126873, 0.17330815241126873, 0.15665092842527573, 0.15665092842527573, 0.15665092842527573, 0.2220788277361886, 0.2220788277361886, 0.2220788277361886, 0.17176975742728173, 0.17176975742728173, 0.17176975742728173, 0.1877799998196792, 0.1877799998196792, 0.1877799998196792, 0.18613179976707916, 0.18613179976707916, 0.18613179976707916, 0.21579735447973136, 0.21579735447973136, 0.21579735447973136, 0.008783408607454524, 0.008783408607454524, 0.008783408607454524, 0.06592977321150861, 0.06592977321150861, 0.06592977321150861, 0.0554993312141856, 0.0554993312141856, 0.0554993312141856, 0.11981450111974279, 0.11981450111974279, 0.11981450111974279, 0.09048733624870131, 0.09048733624870131, 0.09048733624870131, 0.1688440077056952, 0.1688440077056952, 0.1688440077056952, 0.19000534919779166, 0.19000534919779166, 0.19000534919779166, 0.10140449719843525, 0.10140449719843525, 0.10140449719843525, 0.1266357824159382, 0.1266357824159382, 0.1266357824159382, 0.135265503234119, 0.135265503234119, 0.135265503234119, 0.157555526075831, 0.157555526075831, 0.157555526075831, 0.19166185772060784, 0.19166185772060784, 0.19166185772060784, 0.47377594668417755, 0.47377594668417755, 0.47377594668417755, 0.47854131306161596, 0.47854131306161596, 0.47854131306161596, 0.48921561828798876, 0.48921561828798876, 0.48921561828798876, 0.08592846483511296, 0.08592846483511296, 0.08592846483511296, 0.06953196330022615, 0.06953196330022615, 0.06953196330022615, 0.10030047689298549, 0.10030047689298549, 0.10030047689298549, 0.2297716952414517, 0.2297716952414517, 0.2297716952414517, 0.24177130465340368, 0.24177130465340368, 0.24177130465340368, 0.1931990010230824, 0.1931990010230824, 0.1931990010230824, 0.2726272410030489, 0.2726272410030489, 0.2726272410030489, 0.36378200227998736, 0.36378200227998736, 0.36378200227998736, 0.2341568126479988, 0.2341568126479988, 0.2341568126479988, 0.3084448078485188, 0.3084448078485188, 0.3084448078485188, 0.28990263634308655, 0.28990263634308655, 0.28990263634308655, 0.19865619917031696, 0.19865619917031696, 0.19865619917031696, 0.23794216975700289, 0.23794216975700289, 0.23794216975700289, 0.24490075961356006, 0.24490075961356006, 0.24490075961356006, 0.23551612706176817, 0.23551612706176817, 0.23551612706176817, 0.17538108535455177, 0.17538108535455177, 0.17538108535455177, 0.44588392996825343, 0.44588392996825343, 0.44588392996825343, 0.195404706045896, 0.195404706045896, 0.195404706045896, 0.1246710480570482, 0.1246710480570482, 0.1246710480570482, 0.8180310640203508, 0.8180310640203508, 0.8180310640203508, 0.14131222674316757, 0.14131222674316757, 0.14131222674316757, 0.6583901766977258, 0.6583901766977258, 0.6583901766977258, 0.165813021606662, 0.165813021606662, 0.165813021606662, 0.5445320028385241, 0.5445320028385241, 0.5445320028385241, 0.1984431067130643, 0.1984431067130643, 0.1984431067130643, 0.1849267761228327, 0.1849267761228327, 0.1849267761228327, 0.17481483388380714, 0.17481483388380714, 0.17481483388380714, 0.07227643217822666, 0.07227643217822666, 0.07227643217822666, 0.08798456925841036, 0.08798456925841036, 0.08798456925841036, 0.09801091229458758, 0.09801091229458758, 0.09801091229458758]}, "mutation_prompt": null}
{"id": "789d6e0d-a0b2-4d39-9eec-ea4420d3c206", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased the number of particles further for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.85  # Adjusted maximum inertia weight for dynamic exploration-exploitation balance\n        self.w_min = 0.2  # Reduced minimum inertia weight for more exploitation as convergence nears\n        self.c1_initial = 1.8  # Adjusted cognitive factor to enhance exploration\n        self.c2_initial = 1.4\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Further increased social factor to enhance convergence towards the global best\n        self.velocity_clamp = 0.6  # Adjusted velocity clamping for dynamic control\n        self.local_search_probability = 0.15  # Increased probability to perform local search with crossover strategy\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    crossover_partner = np.random.randint(0, self.num_particles)\n                    crossover_position = 0.5 * (positions[i] + positions[crossover_partner])\n                    crossover_position = np.clip(crossover_position, self.lower_bound, self.upper_bound)\n                    crossover_score = func(crossover_position)\n                    evaluations += 1\n                    if crossover_score < personal_best_scores[i]:\n                        personal_best_scores[i] = crossover_score\n                        personal_best_positions[i] = crossover_position.copy()\n                        if crossover_score < global_best_score:\n                            global_best_score = crossover_score\n                            global_best_position = crossover_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptivePSO", "description": "An enhanced Particle Swarm Optimization with adaptive inertia and crossover-inspired local search for improved global convergence.", "configspace": "", "generation": 43, "fitness": 0.2885044715787095, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7451905686899019, 0.7451905686899019, 0.7451905686899019, 0.7468440785953653, 0.7468440785953653, 0.7468440785953653, 0.7449866394483673, 0.7449866394483673, 0.7449866394483673, 0.5359243565858849, 0.5359243565858849, 0.5359243565858849, 0.4601555507829075, 0.4601555507829075, 0.4601555507829075, 0.4841314422762666, 0.4841314422762666, 0.4841314422762666, 0.15692718396364258, 0.15692718396364258, 0.15692718396364258, 0.11103132547665495, 0.11103132547665495, 0.11103132547665495, 0.10529917939078992, 0.10529917939078992, 0.10529917939078992, 0.10016294463033204, 0.10016294463033204, 0.10016294463033204, 0.1436542251432651, 0.1436542251432651, 0.1436542251432651, 0.14117200538719277, 0.14117200538719277, 0.14117200538719277, 0.9056779688428245, 0.9056779688428245, 0.9056779688428245, 0.8893021803538476, 0.8893021803538476, 0.8893021803538476, 0.9005255270405346, 0.9005255270405346, 0.9005255270405346, 0.4996710898778931, 0.4996710898778931, 0.4996710898778931, 0.5435772516190644, 0.5435772516190644, 0.5435772516190644, 0.5227896459076912, 0.5227896459076912, 0.5227896459076912, 0.22780557743542063, 0.22780557743542063, 0.22780557743542063, 0.21616844882705333, 0.21616844882705333, 0.21616844882705333, 0.2262424170264299, 0.2262424170264299, 0.2262424170264299, 0.2271472158374236, 0.2271472158374236, 0.2271472158374236, 0.18192818331090566, 0.18192818331090566, 0.18192818331090566, 0.2516912961604637, 0.2516912961604637, 0.2516912961604637, 0.21641546114172483, 0.21641546114172483, 0.21641546114172483, 0.18315242726762504, 0.18315242726762504, 0.18315242726762504, 0.2118652350355652, 0.2118652350355652, 0.2118652350355652, 0.09093036976871594, 0.09093036976871594, 0.09093036976871594, 0.04968382728674681, 0.04968382728674681, 0.04968382728674681, 0.0037080506422978443, 0.0037080506422978443, 0.0037080506422978443, 0.17536620622809074, 0.17536620622809074, 0.17536620622809074, 0.0677264366500222, 0.0677264366500222, 0.0677264366500222, 0.07949270838114786, 0.07949270838114786, 0.07949270838114786, 0.18955474498196567, 0.18955474498196567, 0.18955474498196567, 0.06302051749381754, 0.06302051749381754, 0.06302051749381754, 0.08076164268459962, 0.08076164268459962, 0.08076164268459962, 0.11101574485000087, 0.11101574485000087, 0.11101574485000087, 0.11599374423329356, 0.11599374423329356, 0.11599374423329356, 0.1061771711324021, 0.1061771711324021, 0.1061771711324021, 0.5328227156448805, 0.5328227156448805, 0.5328227156448805, 0.5178814470879753, 0.5178814470879753, 0.5178814470879753, 0.5386703431875914, 0.5386703431875914, 0.5386703431875914, 0.09300013677810726, 0.09300013677810726, 0.09300013677810726, 0.08071089191298086, 0.08071089191298086, 0.08071089191298086, 0.08629656606151637, 0.08629656606151637, 0.08629656606151637, 0.39323807339259376, 0.39323807339259376, 0.39323807339259376, 0.18508687610117602, 0.18508687610117602, 0.18508687610117602, 0.3676501841777282, 0.3676501841777282, 0.3676501841777282, 0.20299139342938388, 0.20299139342938388, 0.20299139342938388, 0.4159536780295511, 0.4159536780295511, 0.4159536780295511, 0.4044642714506478, 0.4044642714506478, 0.4044642714506478, 0.24234341679559934, 0.24234341679559934, 0.24234341679559934, 0.2526877747867816, 0.2526877747867816, 0.2526877747867816, 0.26124942496443426, 0.26124942496443426, 0.26124942496443426, 0.19622164703636502, 0.19622164703636502, 0.19622164703636502, 0.23573106801912547, 0.23573106801912547, 0.23573106801912547, 0.22385052606093825, 0.22385052606093825, 0.22385052606093825, 0.19657490304525926, 0.19657490304525926, 0.19657490304525926, 0.20800486748449232, 0.20800486748449232, 0.20800486748449232, 0.19375417762966618, 0.19375417762966618, 0.19375417762966618, 0.1873172861789305, 0.1873172861789305, 0.1873172861789305, 0.8622345748909057, 0.8622345748909057, 0.8622345748909057, 0.14197607329170037, 0.14197607329170037, 0.14197607329170037, 0.7570402689645728, 0.7570402689645728, 0.7570402689645728, 0.20983489974573377, 0.20983489974573377, 0.20983489974573377, 0.09442317891922103, 0.09442317891922103, 0.09442317891922103, 0.21987470803964748, 0.21987470803964748, 0.21987470803964748, 0.18172073232443053, 0.18172073232443053, 0.18172073232443053, 0.20262934145086153, 0.20262934145086153, 0.20262934145086153, 0.09422024401876294, 0.09422024401876294, 0.09422024401876294, 0.09429694409222356, 0.09429694409222356, 0.09429694409222356, 0.08469872828515979, 0.08469872828515979, 0.08469872828515979]}, "mutation_prompt": null}
{"id": "7b08db2a-1d6f-48ed-a7b5-9af79e73769c", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Further decreased minimum inertia weight for increased exploitation\n        self.c1_initial = 2.0\n        self.c2_initial = 1.5\n        self.c1_final = 1.3  # Altered cognitive factor's final value for balanced exploration\n        self.c2_final = 3.0  # Increased final social factor for stronger convergence pull\n        self.velocity_clamp = 0.6  # Adjusted velocity clamping for moderated control\n        self.local_search_probability = 0.15  # Increased probability for local search\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            # Nonlinear inertia weight decay\n            inertia_weight = self.w_max * (1 - (evaluations / self.budget) ** 2) + self.w_min\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)  # Increased variance for broader local search\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "An enhanced Adaptive Particle Swarm Optimization combining nonlinear inertia weight decay and stochastic local intensification to refine convergence on diverse optimization tasks.", "configspace": "", "generation": 44, "fitness": 0.23256339379856236, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.4427152995052124, 0.4427152995052124, 0.4427152995052124, 0.44584917705524096, 0.44584917705524096, 0.44584917705524096, 0.4611110666682826, 0.4611110666682826, 0.4611110666682826, 0.10764070882913424, 0.10764070882913424, 0.10764070882913424, 0.060548208484866195, 0.060548208484866195, 0.060548208484866195, 0.057848268370940814, 0.057848268370940814, 0.057848268370940814, 0.11129306801152328, 0.11129306801152328, 0.11129306801152328, 0.10285035550727628, 0.10285035550727628, 0.10285035550727628, 0.11983572369218998, 0.11983572369218998, 0.11983572369218998, 0.08461381820700986, 0.08461381820700986, 0.08461381820700986, 0.11430045721341486, 0.11430045721341486, 0.11430045721341486, 0.1073412866227843, 0.1073412866227843, 0.1073412866227843, 0.8969887011735783, 0.8969887011735783, 0.8969887011735783, 0.9120380651933656, 0.9120380651933656, 0.9120380651933656, 0.9130554941803866, 0.9130554941803866, 0.9130554941803866, 0.28721130650219007, 0.28721130650219007, 0.28721130650219007, 0.29036273635343746, 0.29036273635343746, 0.29036273635343746, 0.2810730350214742, 0.2810730350214742, 0.2810730350214742, 0.3324217081930063, 0.3324217081930063, 0.3324217081930063, 0.3178266114980879, 0.3178266114980879, 0.3178266114980879, 0.3874698520215484, 0.3874698520215484, 0.3874698520215484, 0.15851529080240145, 0.15851529080240145, 0.15851529080240145, 0.14584202290287163, 0.14584202290287163, 0.14584202290287163, 0.17598700880647644, 0.17598700880647644, 0.17598700880647644, 0.15922261599128507, 0.15922261599128507, 0.15922261599128507, 0.16166979618915722, 0.16166979618915722, 0.16166979618915722, 0.21728458779064797, 0.21728458779064797, 0.21728458779064797, 0.022521303764157508, 0.022521303764157508, 0.022521303764157508, 0.02540075022406474, 0.02540075022406474, 0.02540075022406474, 0.007663801173115492, 0.007663801173115492, 0.007663801173115492, 0.15933470137296912, 0.15933470137296912, 0.15933470137296912, 0.05302077411997996, 0.05302077411997996, 0.05302077411997996, 0.15863452569784353, 0.15863452569784353, 0.15863452569784353, 0.012090779120899398, 0.012090779120899398, 0.012090779120899398, 0.01563177823659223, 0.01563177823659223, 0.01563177823659223, 0.013891421963175943, 0.013891421963175943, 0.013891421963175943, 0.08858497427759993, 0.08858497427759993, 0.08858497427759993, 0.0728988543840291, 0.0728988543840291, 0.0728988543840291, 0.07694130959436729, 0.07694130959436729, 0.07694130959436729, 0.39449284644787774, 0.39449284644787774, 0.39449284644787774, 0.3822974400062227, 0.3822974400062227, 0.3822974400062227, 0.39162275535955027, 0.39162275535955027, 0.39162275535955027, 0.08935907457639114, 0.08935907457639114, 0.08935907457639114, 0.14536228586361288, 0.14536228586361288, 0.14536228586361288, 0.10410560684837822, 0.10410560684837822, 0.10410560684837822, 0.23268438775355027, 0.23268438775355027, 0.23268438775355027, 0.19394435476486782, 0.19394435476486782, 0.19394435476486782, 0.2301285778597152, 0.2301285778597152, 0.2301285778597152, 0.29396965417032783, 0.29396965417032783, 0.29396965417032783, 0.28626609533301794, 0.28626609533301794, 0.28626609533301794, 0.2700381675189001, 0.2700381675189001, 0.2700381675189001, 0.20590961744197633, 0.20590961744197633, 0.20590961744197633, 0.23739454434334661, 0.23739454434334661, 0.23739454434334661, 0.19739414476321737, 0.19739414476321737, 0.19739414476321737, 0.2467476084669269, 0.2467476084669269, 0.2467476084669269, 0.23699820960209372, 0.23699820960209372, 0.23699820960209372, 0.2126833509171937, 0.2126833509171937, 0.2126833509171937, 0.21965941375804054, 0.21965941375804054, 0.21965941375804054, 0.28672617766615305, 0.28672617766615305, 0.28672617766615305, 0.18024016444171376, 0.18024016444171376, 0.18024016444171376, 0.12519016211285017, 0.12519016211285017, 0.12519016211285017, 0.629444851051487, 0.629444851051487, 0.629444851051487, 0.14121606308591705, 0.14121606308591705, 0.14121606308591705, 0.5556296538827147, 0.5556296538827147, 0.5556296538827147, 0.4520922059909813, 0.4520922059909813, 0.4520922059909813, 0.4271003007425056, 0.4271003007425056, 0.4271003007425056, 0.19424318654447248, 0.19424318654447248, 0.19424318654447248, 0.18543148588331992, 0.18543148588331992, 0.18543148588331992, 0.18918329347417917, 0.18918329347417917, 0.18918329347417917, 0.08791970025989992, 0.08791970025989992, 0.08791970025989992, 0.08500627815327333, 0.08500627815327333, 0.08500627815327333, 0.07455144969523075, 0.07455144969523075, 0.07455144969523075]}, "mutation_prompt": null}
{"id": "38f67acf-e029-40db-8e4c-6fd07ee7088d", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.c1_initial = 2.0  \n        self.c2_initial = 1.5\n        self.c1_final = 1.2\n        self.c2_final = 2.8  \n        self.velocity_clamp = 0.7  # Increased velocity clamping for better control\n        self.local_search_probability = 0.2  # Increased probability for local search\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        neighborhood_size = 5  # Introduced neighborhood concept\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                # Neighborhood adaptation\n                neighbors_indices = np.random.choice(self.num_particles, neighborhood_size, replace=False)\n                local_best_index = neighbors_indices[np.argmin(personal_best_scores[neighbors_indices])]\n                local_best_position = personal_best_positions[local_best_index]\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (local_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_pso = HybridAdaptivePSO(budget=10000, dim=10)\n# hybrid_pso(func)", "name": "HybridAdaptivePSO", "description": "A hybrid Particle Swarm Optimization with dynamic neighborhood adaptation and enhanced exploitation through quadratic local search for improved convergence.", "configspace": "", "generation": 45, "fitness": 0.2330049602781571, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.19.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.4653158400376709, 0.4653158400376709, 0.4653158400376709, 0.46440348717589897, 0.46440348717589897, 0.46440348717589897, 0.47568243586940084, 0.47568243586940084, 0.47568243586940084, 0.17209603009241925, 0.17209603009241925, 0.17209603009241925, 0.16510273476486692, 0.16510273476486692, 0.16510273476486692, 0.10213356662436057, 0.10213356662436057, 0.10213356662436057, 0.09256184107247167, 0.09256184107247167, 0.09256184107247167, 0.10326418072813015, 0.10326418072813015, 0.10326418072813015, 0.11764190505145711, 0.11764190505145711, 0.11764190505145711, 0.08884579626805555, 0.08884579626805555, 0.08884579626805555, 0.12368806141691324, 0.12368806141691324, 0.12368806141691324, 0.09981028083701127, 0.09981028083701127, 0.09981028083701127, 0.8769469603772587, 0.8769469603772587, 0.8769469603772587, 0.8712830629858338, 0.8712830629858338, 0.8712830629858338, 0.8853002088207954, 0.8853002088207954, 0.8853002088207954, 0.28369350000958693, 0.28369350000958693, 0.28369350000958693, 0.27168653607270565, 0.27168653607270565, 0.27168653607270565, 0.2836277556049457, 0.2836277556049457, 0.2836277556049457, 0.31418861030239376, 0.31418861030239376, 0.31418861030239376, 0.33388369006891694, 0.33388369006891694, 0.33388369006891694, 0.3110002681264177, 0.3110002681264177, 0.3110002681264177, 0.16556482902491299, 0.16556482902491299, 0.16556482902491299, 0.15656780045326413, 0.15656780045326413, 0.15656780045326413, 0.1481951871560675, 0.1481951871560675, 0.1481951871560675, 0.16570729251807292, 0.16570729251807292, 0.16570729251807292, 0.1709119256910877, 0.1709119256910877, 0.1709119256910877, 0.16839178414021605, 0.16839178414021605, 0.16839178414021605, 0.004623406678943454, 0.004623406678943454, 0.004623406678943454, 0.07686661297148256, 0.07686661297148256, 0.07686661297148256, 0.02621972100796066, 0.02621972100796066, 0.02621972100796066, 0.12784817075139854, 0.12784817075139854, 0.12784817075139854, 0.05756305132992512, 0.05756305132992512, 0.05756305132992512, 0.12749879488417082, 0.12749879488417082, 0.12749879488417082, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.09741680142788178, 0.09741680142788178, 0.09741680142788178, 0.11321938403689913, 0.11321938403689913, 0.11321938403689913, 0.09628465442728518, 0.09628465442728518, 0.09628465442728518, 0.38388897372629116, 0.38388897372629116, 0.38388897372629116, 0.40480065850651903, 0.40480065850651903, 0.40480065850651903, 0.3990676235481847, 0.3990676235481847, 0.3990676235481847, 0.09788402280962505, 0.09788402280962505, 0.09788402280962505, 0.13265456450706392, 0.13265456450706392, 0.13265456450706392, 0.12474336501497763, 0.12474336501497763, 0.12474336501497763, 0.25278967476656966, 0.25278967476656966, 0.25278967476656966, 0.21273293601175014, 0.21273293601175014, 0.21273293601175014, 0.21885704595476752, 0.21885704595476752, 0.21885704595476752, 0.27753792185396864, 0.27753792185396864, 0.27753792185396864, 0.29925437211001304, 0.29925437211001304, 0.29925437211001304, 0.26302486955141624, 0.26302486955141624, 0.26302486955141624, 0.18463424156166575, 0.18463424156166575, 0.18463424156166575, 0.2184637083626031, 0.2184637083626031, 0.2184637083626031, 0.1776564642769456, 0.1776564642769456, 0.1776564642769456, 0.25245459803578274, 0.25245459803578274, 0.25245459803578274, 0.2512156209630453, 0.2512156209630453, 0.2512156209630453, 0.24675369154283977, 0.24675369154283977, 0.24675369154283977, 0.17160483340880694, 0.17160483340880694, 0.17160483340880694, 0.19291261699473705, 0.19291261699473705, 0.19291261699473705, 0.1775718849823339, 0.1775718849823339, 0.1775718849823339, 0.18436950573493427, 0.18436950573493427, 0.18436950573493427, 0.5893388285988239, 0.5893388285988239, 0.5893388285988239, 0.5563870272246025, 0.5563870272246025, 0.5563870272246025, 0.5040954727243392, 0.5040954727243392, 0.5040954727243392, 0.22509610384298517, 0.22509610384298517, 0.22509610384298517, 0.32164546734012733, 0.32164546734012733, 0.32164546734012733, 0.22116958734316927, 0.22116958734316927, 0.22116958734316927, 0.18890228695561684, 0.18890228695561684, 0.18890228695561684, 0.17401290990595153, 0.17401290990595153, 0.17401290990595153, 0.0881114132954266, 0.0881114132954266, 0.0881114132954266, 0.09042749263461569, 0.09042749263461569, 0.09042749263461569, 0.08696118712973222, 0.08696118712973222, 0.08696118712973222]}, "mutation_prompt": null}
{"id": "71fbac32-c24f-4ba8-a58c-cddf5e94ea17", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50  # Retained particle count for consistent exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Further decreased minimum inertia weight to boost exploitation\n        self.c1_initial = 2.1  # Slightly increased initial cognitive factor for better personal exploration\n        self.c2_initial = 1.4\n        self.c1_final = 1.0\n        self.c2_final = 2.9  # Increased final social factor for stronger convergence towards the global best\n        self.velocity_clamp = 0.6  # Enhanced velocity clamping for more robust control\n        self.local_search_probability = 0.05  # Reduced local search probability for strategic intensification\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget) ** 2)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_pso = HybridAdaptivePSO(budget=10000, dim=10)\n# hybrid_pso(func)", "name": "HybridAdaptivePSO", "description": "A hybrid Particle Swarm Optimization with adaptive inertia weight and dynamic local search frequency for enhanced exploration and exploitation balance.", "configspace": "", "generation": 46, "fitness": 0.277259278567908, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6207207462719972, 0.6207207462719972, 0.6207207462719972, 0.6345399363531965, 0.6345399363531965, 0.6345399363531965, 0.6646954185513592, 0.6646954185513592, 0.6646954185513592, 0.2777843721259291, 0.2777843721259291, 0.2777843721259291, 0.26294980928943135, 0.26294980928943135, 0.26294980928943135, 0.28861750952052545, 0.28861750952052545, 0.28861750952052545, 0.10520142987666736, 0.10520142987666736, 0.10520142987666736, 0.10803764882550426, 0.10803764882550426, 0.10803764882550426, 0.08723785498157899, 0.08723785498157899, 0.08723785498157899, 0.10725486541327223, 0.10725486541327223, 0.10725486541327223, 0.12840578100034983, 0.12840578100034983, 0.12840578100034983, 0.1499807015661343, 0.1499807015661343, 0.1499807015661343, 0.9292382222897987, 0.9292382222897987, 0.9292382222897987, 0.9206278293868432, 0.9206278293868432, 0.9206278293868432, 0.9202057019128885, 0.9202057019128885, 0.9202057019128885, 0.3928840436928607, 0.3928840436928607, 0.3928840436928607, 0.3993308311658761, 0.3993308311658761, 0.3993308311658761, 0.3856761709741823, 0.3856761709741823, 0.3856761709741823, 0.2290307472278974, 0.2290307472278974, 0.2290307472278974, 0.21863893429263848, 0.21863893429263848, 0.21863893429263848, 0.17547774592074294, 0.17547774592074294, 0.17547774592074294, 0.1596745904320267, 0.1596745904320267, 0.1596745904320267, 0.16671318457734274, 0.16671318457734274, 0.16671318457734274, 0.24682036411430797, 0.24682036411430797, 0.24682036411430797, 0.1912885899259129, 0.1912885899259129, 0.1912885899259129, 0.17201870636996486, 0.17201870636996486, 0.17201870636996486, 0.19722234786737636, 0.19722234786737636, 0.19722234786737636, 0.06803119595356888, 0.06803119595356888, 0.06803119595356888, 0.03872161185338796, 0.03872161185338796, 0.03872161185338796, 0.08975145301935405, 0.08975145301935405, 0.08975145301935405, 0.2517563377286556, 0.2517563377286556, 0.2517563377286556, 0.08375486201462756, 0.08375486201462756, 0.08375486201462756, 0.1585530491529329, 0.1585530491529329, 0.1585530491529329, 0.0680684723814362, 0.0680684723814362, 0.0680684723814362, 0.07526410583951293, 0.07526410583951293, 0.07526410583951293, 0.0634446958464796, 0.0634446958464796, 0.0634446958464796, 0.15045234765699766, 0.15045234765699766, 0.15045234765699766, 0.05146826401528848, 0.05146826401528848, 0.05146826401528848, 0.10300070182889298, 0.10300070182889298, 0.10300070182889298, 0.4694700888551254, 0.4694700888551254, 0.4694700888551254, 0.4517403929893271, 0.4517403929893271, 0.4517403929893271, 0.48297080003954973, 0.48297080003954973, 0.48297080003954973, 0.09919868670164522, 0.09919868670164522, 0.09919868670164522, 0.10420257740919081, 0.10420257740919081, 0.10420257740919081, 0.10308025989171399, 0.10308025989171399, 0.10308025989171399, 0.2698048299079031, 0.2698048299079031, 0.2698048299079031, 0.2692708556818889, 0.2692708556818889, 0.2692708556818889, 0.17503233959576614, 0.17503233959576614, 0.17503233959576614, 0.252034595188517, 0.252034595188517, 0.252034595188517, 0.21607954938685703, 0.21607954938685703, 0.21607954938685703, 0.2479208760325532, 0.2479208760325532, 0.2479208760325532, 0.21380314488171326, 0.21380314488171326, 0.21380314488171326, 0.3008828215549013, 0.3008828215549013, 0.3008828215549013, 0.2298275826496654, 0.2298275826496654, 0.2298275826496654, 0.2208000678580977, 0.2208000678580977, 0.2208000678580977, 0.2255684980701046, 0.2255684980701046, 0.2255684980701046, 0.24656578353687997, 0.24656578353687997, 0.24656578353687997, 0.19034476687575486, 0.19034476687575486, 0.19034476687575486, 0.20616972581723136, 0.20616972581723136, 0.20616972581723136, 0.19398060566059394, 0.19398060566059394, 0.19398060566059394, 0.7267740151383042, 0.7267740151383042, 0.7267740151383042, 0.8081017679780366, 0.8081017679780366, 0.8081017679780366, 0.14216304803285418, 0.14216304803285418, 0.14216304803285418, 0.5696307316055688, 0.5696307316055688, 0.5696307316055688, 0.7393239074716355, 0.7393239074716355, 0.7393239074716355, 0.5467574254315044, 0.5467574254315044, 0.5467574254315044, 0.21591891379438521, 0.21591891379438521, 0.21591891379438521, 0.20411633226743187, 0.20411633226743187, 0.20411633226743187, 0.1986560950057572, 0.1986560950057572, 0.1986560950057572, 0.09362198544511047, 0.09362198544511047, 0.09362198544511047, 0.0893355307360687, 0.0893355307360687, 0.0893355307360687, 0.11697827417999818, 0.11697827417999818, 0.11697827417999818]}, "mutation_prompt": null}
{"id": "9b9d753b-23a1-41ad-81b0-c127bdc9b91a", "solution": "import numpy as np\n\nclass AdaptiveStochasticPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Lowered to increase exploitation\n        self.c1_initial = 1.8  # Reduced initial cognitive factor\n        self.c2_initial = 1.7  # Increased initial social factor for better global search\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Further increased to push towards global optima\n        self.velocity_clamp = 0.6  # Slightly increased for broader velocity range\n        self.local_search_probability = 0.15  # Increased chance of local search\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget) ** 1.2)  # Non-linear decay\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * (evaluations / self.budget) ** 1.1)  # Non-linear adjustment\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * (evaluations / self.budget) ** 1.1)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)  # Smaller perturbation for mild local search\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "AdaptiveStochasticPSO", "description": "A self-adaptive Particle Swarm Optimization with dynamically adjusting learning factors and stochastic local search to enhance exploration-exploitation balance.", "configspace": "", "generation": 47, "fitness": 0.28211556700493673, "feedback": "The algorithm AdaptiveStochasticPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.23.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7386075070713691, 0.7386075070713691, 0.7386075070713691, 0.7100507556478404, 0.7100507556478404, 0.7100507556478404, 0.7157390073030301, 0.7157390073030301, 0.7157390073030301, 0.37925637559082803, 0.37925637559082803, 0.37925637559082803, 0.3807654274990653, 0.3807654274990653, 0.3807654274990653, 0.3519734393065529, 0.3519734393065529, 0.3519734393065529, 0.1364056435253207, 0.1364056435253207, 0.1364056435253207, 0.13023484493688897, 0.13023484493688897, 0.13023484493688897, 0.09331657388743897, 0.09331657388743897, 0.09331657388743897, 0.08463098595141161, 0.08463098595141161, 0.08463098595141161, 0.10690092508953752, 0.10690092508953752, 0.10690092508953752, 0.1562387417211707, 0.1562387417211707, 0.1562387417211707, 0.9035128989585246, 0.9035128989585246, 0.9035128989585246, 0.9029782485879083, 0.9029782485879083, 0.9029782485879083, 0.9170294439747517, 0.9170294439747517, 0.9170294439747517, 0.46178734072364114, 0.46178734072364114, 0.46178734072364114, 0.40708172311159774, 0.40708172311159774, 0.40708172311159774, 0.4124548858329308, 0.4124548858329308, 0.4124548858329308, 0.7432398494781751, 0.7432398494781751, 0.7432398494781751, 0.26962042234555483, 0.26962042234555483, 0.26962042234555483, 0.22496916721482274, 0.22496916721482274, 0.22496916721482274, 0.15776388664501506, 0.15776388664501506, 0.15776388664501506, 0.21969606530449182, 0.21969606530449182, 0.21969606530449182, 0.20959427974828782, 0.20959427974828782, 0.20959427974828782, 0.18362178981689248, 0.18362178981689248, 0.18362178981689248, 0.20636560316389574, 0.20636560316389574, 0.20636560316389574, 0.12818619379829854, 0.12818619379829854, 0.12818619379829854, 0.004137403764170822, 0.004137403764170822, 0.004137403764170822, 0.037314157459895636, 0.037314157459895636, 0.037314157459895636, 0.0008318346059812409, 0.0008318346059812409, 0.0008318346059812409, 0.16943768683394134, 0.16943768683394134, 0.16943768683394134, 0.048764757615602505, 0.048764757615602505, 0.048764757615602505, 0.13512007698573703, 0.13512007698573703, 0.13512007698573703, 0.12214607711227088, 0.12214607711227088, 0.12214607711227088, 0.1287223978017653, 0.1287223978017653, 0.1287223978017653, 0.09055290779816372, 0.09055290779816372, 0.09055290779816372, 0.12365490239840105, 0.12365490239840105, 0.12365490239840105, 0.06115155357608315, 0.06115155357608315, 0.06115155357608315, 0.2188580214310909, 0.2188580214310909, 0.2188580214310909, 0.5216703427552685, 0.5216703427552685, 0.5216703427552685, 0.5029499976140575, 0.5029499976140575, 0.5029499976140575, 0.4905571346736335, 0.4905571346736335, 0.4905571346736335, 0.11031769100418476, 0.11031769100418476, 0.11031769100418476, 0.1423075055213867, 0.1423075055213867, 0.1423075055213867, 0.12726013084764276, 0.12726013084764276, 0.12726013084764276, 0.19727883637728005, 0.19727883637728005, 0.19727883637728005, 0.19581083422576917, 0.19581083422576917, 0.19581083422576917, 0.16953085427886072, 0.16953085427886072, 0.16953085427886072, 0.3477238614052922, 0.3477238614052922, 0.3477238614052922, 0.32406183363814767, 0.32406183363814767, 0.32406183363814767, 0.27540586719950744, 0.27540586719950744, 0.27540586719950744, 0.18908870191858518, 0.18908870191858518, 0.18908870191858518, 0.23066199278441413, 0.23066199278441413, 0.23066199278441413, 0.17081645938590095, 0.17081645938590095, 0.17081645938590095, 0.20292445049412922, 0.20292445049412922, 0.20292445049412922, 0.23076458861929772, 0.23076458861929772, 0.23076458861929772, 0.20188132835866424, 0.20188132835866424, 0.20188132835866424, 0.17537007603630006, 0.17537007603630006, 0.17537007603630006, 0.28954947375654827, 0.28954947375654827, 0.28954947375654827, 0.19017630986486378, 0.19017630986486378, 0.19017630986486378, 0.12612199488661258, 0.12612199488661258, 0.12612199488661258, 0.8038472776860184, 0.8038472776860184, 0.8038472776860184, 0.14215972859278814, 0.14215972859278814, 0.14215972859278814, 0.639196729879219, 0.639196729879219, 0.639196729879219, 0.43519584210391293, 0.43519584210391293, 0.43519584210391293, 0.5569567769366813, 0.5569567769366813, 0.5569567769366813, 0.19856891690034695, 0.19856891690034695, 0.19856891690034695, 0.1782460568355524, 0.1782460568355524, 0.1782460568355524, 0.2204150097996479, 0.2204150097996479, 0.2204150097996479, 0.07839104323443558, 0.07839104323443558, 0.07839104323443558, 0.09040226289237308, 0.09040226289237308, 0.09040226289237308, 0.0839971102297774, 0.0839971102297774, 0.0839971102297774]}, "mutation_prompt": null}
{"id": "dc205ca2-9049-4428-beb7-549ffff70c3f", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 40  # Reduced number of particles for faster convergence\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.85  # Adjusted inertia weight for improved balance\n        self.w_min = 0.4\n        self.c1_initial = 2.2  # Enhanced cognitive factor for better individual exploration\n        self.c2_initial = 1.3\n        self.c1_final = 1.0\n        self.c2_final = 2.6  # Adjusted social factor to drive convergence towards global best\n        self.velocity_clamp = 0.6  # Modified velocity clamping for more controlled movement\n        self.local_search_probability = 0.15  # Increased probability for local search implementation\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)  # Tighter perturbation for fine local adjustments\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "An Enhanced Particle Swarm Optimization integrating adaptive velocity control and targeted local perturbations to boost convergence efficiency in diverse optimization scenarios.", "configspace": "", "generation": 48, "fitness": 0.3035564068770216, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7769503219867382, 0.7769503219867382, 0.7769503219867382, 0.7669953734946234, 0.7669953734946234, 0.7669953734946234, 0.7870309036746089, 0.7870309036746089, 0.7870309036746089, 0.5056057153824218, 0.5056057153824218, 0.5056057153824218, 0.48558639627987576, 0.48558639627987576, 0.48558639627987576, 0.48141872285529186, 0.48141872285529186, 0.48141872285529186, 0.49409037959557, 0.49409037959557, 0.49409037959557, 0.10708428063091469, 0.10708428063091469, 0.10708428063091469, 0.13272694484507397, 0.13272694484507397, 0.13272694484507397, 0.09030549990606251, 0.09030549990606251, 0.09030549990606251, 0.13634379045235911, 0.13634379045235911, 0.13634379045235911, 0.11321698052017126, 0.11321698052017126, 0.11321698052017126, 0.9256787685582276, 0.9256787685582276, 0.9256787685582276, 0.9139607401598924, 0.9139607401598924, 0.9139607401598924, 0.9300964972946376, 0.9300964972946376, 0.9300964972946376, 0.5427833489858837, 0.5427833489858837, 0.5427833489858837, 0.5784427892233804, 0.5784427892233804, 0.5784427892233804, 0.4871546118856127, 0.4871546118856127, 0.4871546118856127, 0.4412244920303563, 0.4412244920303563, 0.4412244920303563, 0.27777992564499365, 0.27777992564499365, 0.27777992564499365, 0.21526255802191685, 0.21526255802191685, 0.21526255802191685, 0.24664314831513778, 0.24664314831513778, 0.24664314831513778, 0.2285881532993178, 0.2285881532993178, 0.2285881532993178, 0.20248494458195987, 0.20248494458195987, 0.20248494458195987, 0.20143170552119838, 0.20143170552119838, 0.20143170552119838, 0.1828355221082555, 0.1828355221082555, 0.1828355221082555, 0.22578275640219447, 0.22578275640219447, 0.22578275640219447, 0.05395250388118533, 0.05395250388118533, 0.05395250388118533, 0.04297408664117297, 0.04297408664117297, 0.04297408664117297, 0.023561328034817586, 0.023561328034817586, 0.023561328034817586, 0.11433473695868457, 0.11433473695868457, 0.11433473695868457, 0.08745562817412555, 0.08745562817412555, 0.08745562817412555, 0.11722088225492333, 0.11722088225492333, 0.11722088225492333, 0.13525830034675945, 0.13525830034675945, 0.13525830034675945, 0.2562275881652111, 0.2562275881652111, 0.2562275881652111, 0.08064813388479175, 0.08064813388479175, 0.08064813388479175, 0.11543540477894254, 0.11543540477894254, 0.11543540477894254, 0.09040398239507286, 0.09040398239507286, 0.09040398239507286, 0.21018485485705163, 0.21018485485705163, 0.21018485485705163, 0.5003395280059993, 0.5003395280059993, 0.5003395280059993, 0.47870870521329156, 0.47870870521329156, 0.47870870521329156, 0.5341050956972014, 0.5341050956972014, 0.5341050956972014, 0.0653737525495659, 0.0653737525495659, 0.0653737525495659, 0.09832086635632242, 0.09832086635632242, 0.09832086635632242, 0.14955067108967846, 0.14955067108967846, 0.14955067108967846, 0.5795977137006052, 0.5795977137006052, 0.5795977137006052, 0.17432195927340177, 0.17432195927340177, 0.17432195927340177, 0.2940602915688951, 0.2940602915688951, 0.2940602915688951, 0.25456272928529367, 0.25456272928529367, 0.25456272928529367, 0.4451021635137218, 0.4451021635137218, 0.4451021635137218, 0.23742878134256828, 0.23742878134256828, 0.23742878134256828, 0.17480052933074675, 0.17480052933074675, 0.17480052933074675, 0.32689662750412485, 0.32689662750412485, 0.32689662750412485, 0.2310056749500835, 0.2310056749500835, 0.2310056749500835, 0.24012694160893566, 0.24012694160893566, 0.24012694160893566, 0.21803033328223864, 0.21803033328223864, 0.21803033328223864, 0.2166658332393614, 0.2166658332393614, 0.2166658332393614, 0.18163439018781025, 0.18163439018781025, 0.18163439018781025, 0.190101645398977, 0.190101645398977, 0.190101645398977, 0.2240821088176097, 0.2240821088176097, 0.2240821088176097, 0.12554847262768087, 0.12554847262768087, 0.12554847262768087, 0.8486554180351858, 0.8486554180351858, 0.8486554180351858, 0.14232142911578904, 0.14232142911578904, 0.14232142911578904, 0.5856196006019736, 0.5856196006019736, 0.5856196006019736, 0.611478995997083, 0.611478995997083, 0.611478995997083, 0.09423166113638903, 0.09423166113638903, 0.09423166113638903, 0.1950437905265353, 0.1950437905265353, 0.1950437905265353, 0.18737109016828146, 0.18737109016828146, 0.18737109016828146, 0.19114328271208247, 0.19114328271208247, 0.19114328271208247, 0.07687466001050414, 0.07687466001050414, 0.07687466001050414, 0.08017432311309225, 0.08017432311309225, 0.08017432311309225, 0.0976195271551118, 0.0976195271551118, 0.0976195271551118]}, "mutation_prompt": null}
{"id": "9dae738e-5c3f-4b41-a19b-64a0dd0dd429", "solution": "import numpy as np\n\nclass DynamicHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50  # Initial number of particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4  # Slightly modified minimum inertia weight for balance\n        self.c1_initial = 1.8  # Modified cognitive factor to adjust search balance\n        self.c2_initial = 1.7\n        self.c1_final = 1.4\n        self.c2_final = 2.9  # Further increase in social factor for better convergence\n        self.velocity_clamp = 0.6  # Adjusted velocity clamping for refined control\n        self.local_search_probability = 0.15  # Adjusted probability for local search\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# dynamic_hybrid_pso = DynamicHybridPSO(budget=10000, dim=10)\n# dynamic_hybrid_pso(func)", "name": "DynamicHybridPSO", "description": "A Particle Swarm Optimization with adaptive parameters and dynamically adjusted local search for robust performance across varied optimization landscapes.", "configspace": "", "generation": 49, "fitness": 0.26853262870610406, "feedback": "The algorithm DynamicHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.703480314453926, 0.703480314453926, 0.703480314453926, 0.6758772637898507, 0.6758772637898507, 0.6758772637898507, 0.6664017623611755, 0.6664017623611755, 0.6664017623611755, 0.30809336221479466, 0.30809336221479466, 0.30809336221479466, 0.2905298866141901, 0.2905298866141901, 0.2905298866141901, 0.33848882864771235, 0.33848882864771235, 0.33848882864771235, 0.113715118093765, 0.113715118093765, 0.113715118093765, 0.14486654249874942, 0.14486654249874942, 0.14486654249874942, 0.15644045500867831, 0.15644045500867831, 0.15644045500867831, 0.12790114060940783, 0.12790114060940783, 0.12790114060940783, 0.1022792991841116, 0.1022792991841116, 0.1022792991841116, 0.10708011622321323, 0.10708011622321323, 0.10708011622321323, 0.8997783681487349, 0.8997783681487349, 0.8997783681487349, 0.897267671527508, 0.897267671527508, 0.897267671527508, 0.900369210791667, 0.900369210791667, 0.900369210791667, 0.368524975973341, 0.368524975973341, 0.368524975973341, 0.42746083518437494, 0.42746083518437494, 0.42746083518437494, 0.40900964747210955, 0.40900964747210955, 0.40900964747210955, 0.2241997330079103, 0.2241997330079103, 0.2241997330079103, 0.20739646769347697, 0.20739646769347697, 0.20739646769347697, 0.8085591436538799, 0.8085591436538799, 0.8085591436538799, 0.16518260927208084, 0.16518260927208084, 0.16518260927208084, 0.2347136536942478, 0.2347136536942478, 0.2347136536942478, 0.16419803878191364, 0.16419803878191364, 0.16419803878191364, 0.18564227139739364, 0.18564227139739364, 0.18564227139739364, 0.1750916654872703, 0.1750916654872703, 0.1750916654872703, 0.21021246650902625, 0.21021246650902625, 0.21021246650902625, 0.024068134840305344, 0.024068134840305344, 0.024068134840305344, 0.04031578577617878, 0.04031578577617878, 0.04031578577617878, 0.056007415736915034, 0.056007415736915034, 0.056007415736915034, 0.1408403778403765, 0.1408403778403765, 0.1408403778403765, 0.08983149842664784, 0.08983149842664784, 0.08983149842664784, 0.13507812513937167, 0.13507812513937167, 0.13507812513937167, 0.05616024443756684, 0.05616024443756684, 0.05616024443756684, 0.06367649416379595, 0.06367649416379595, 0.06367649416379595, 0.061391426111385816, 0.061391426111385816, 0.061391426111385816, 0.15662054978067885, 0.15662054978067885, 0.15662054978067885, 0.17989615286981098, 0.17989615286981098, 0.17989615286981098, 0.14791573602546781, 0.14791573602546781, 0.14791573602546781, 0.48992084859084084, 0.48992084859084084, 0.48992084859084084, 0.4894102613190021, 0.4894102613190021, 0.4894102613190021, 0.5068673096570919, 0.5068673096570919, 0.5068673096570919, 0.13697302550386925, 0.13697302550386925, 0.13697302550386925, 0.08584997821694884, 0.08584997821694884, 0.08584997821694884, 0.10563782009812972, 0.10563782009812972, 0.10563782009812972, 0.3537672058664584, 0.3537672058664584, 0.3537672058664584, 0.15942030560777565, 0.15942030560777565, 0.15942030560777565, 0.32362659117981984, 0.32362659117981984, 0.32362659117981984, 0.26516003972747926, 0.26516003972747926, 0.26516003972747926, 0.2810110580168007, 0.2810110580168007, 0.2810110580168007, 0.27610790157247533, 0.27610790157247533, 0.27610790157247533, 0.1925512289437864, 0.1925512289437864, 0.1925512289437864, 0.29160899920911354, 0.29160899920911354, 0.29160899920911354, 0.2506963869304587, 0.2506963869304587, 0.2506963869304587, 0.21352907295078916, 0.21352907295078916, 0.21352907295078916, 0.2597295866732072, 0.2597295866732072, 0.2597295866732072, 0.22186210692922181, 0.22186210692922181, 0.22186210692922181, 0.19330226162370456, 0.19330226162370456, 0.19330226162370456, 0.20016175305992, 0.20016175305992, 0.20016175305992, 0.21655562981340615, 0.21655562981340615, 0.21655562981340615, 0.7883671460804775, 0.7883671460804775, 0.7883671460804775, 0.16439558714318359, 0.16439558714318359, 0.16439558714318359, 0.13614526899579782, 0.13614526899579782, 0.13614526899579782, 0.15383636610707274, 0.15383636610707274, 0.15383636610707274, 0.21263620617614654, 0.21263620617614654, 0.21263620617614654, 0.3427226761363691, 0.3427226761363691, 0.3427226761363691, 0.18231787276908795, 0.18231787276908795, 0.18231787276908795, 0.1793142938875233, 0.1793142938875233, 0.1793142938875233, 0.17702638786567204, 0.17702638786567204, 0.17702638786567204, 0.12220481070833777, 0.12220481070833777, 0.12220481070833777, 0.08696376961719121, 0.08696376961719121, 0.08696376961719121, 0.11010672041932046, 0.11010672041932046, 0.11010672041932046]}, "mutation_prompt": null}
{"id": "3fa3afe0-18c9-456e-9af9-b77a505964e2", "solution": "import numpy as np\n\nclass DynamicHarmonySearch:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.harmony_memory_size = 50\n        self.harmony_memory_consideration_rate = 0.9\n        self.pitch_adjustment_rate_initial = 0.3\n        self.pitch_adjustment_rate_final = 0.9\n        self.bandwidth = 0.1\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.random_restart_probability = 0.1\n\n    def __call__(self, func):\n        np.random.seed(0)\n        harmony_memory = np.random.uniform(self.lower_bound, self.upper_bound, (self.harmony_memory_size, self.dim))\n        harmony_scores = np.apply_along_axis(func, 1, harmony_memory)\n        evaluations = self.harmony_memory_size\n        best_harmony_index = np.argmin(harmony_scores)\n        best_harmony = harmony_memory[best_harmony_index]\n        best_score = harmony_scores[best_harmony_index]\n\n        while evaluations < self.budget:\n            new_harmony = np.zeros(self.dim)\n            for i in range(self.dim):\n                if np.random.rand() < self.harmony_memory_consideration_rate:\n                    new_harmony[i] = harmony_memory[np.random.randint(self.harmony_memory_size), i]\n                    if np.random.rand() < self.pitch_adjustment_rate_initial + (\n                        (self.pitch_adjustment_rate_final - self.pitch_adjustment_rate_initial) * evaluations / self.budget):\n                        new_harmony[i] += self.bandwidth * (2 * np.random.rand() - 1)\n                else:\n                    new_harmony[i] = np.random.uniform(self.lower_bound, self.upper_bound)\n            new_harmony = np.clip(new_harmony, self.lower_bound, self.upper_bound)\n            new_score = func(new_harmony)\n            evaluations += 1\n\n            if new_score < best_score:\n                best_score = new_score\n                best_harmony = new_harmony.copy()\n\n            worst_index = np.argmax(harmony_scores)\n            if new_score < harmony_scores[worst_index]:\n                harmony_memory[worst_index] = new_harmony\n                harmony_scores[worst_index] = new_score\n\n            if np.random.rand() < self.random_restart_probability:\n                restart_harmony = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                restart_score = func(restart_harmony)\n                evaluations += 1\n                if restart_score < best_score:\n                    best_score = restart_score\n                    best_harmony = restart_harmony.copy()\n            \n# Usage:\n# dynamic_hs = DynamicHarmonySearch(budget=10000, dim=10)\n# dynamic_hs(func)", "name": "DynamicHarmonySearch", "description": "Dynamic Harmony Search with Adaptive Pitch Adjustment and Random Restarts for Optimal Exploration and Exploitation.", "configspace": "", "generation": 50, "fitness": 0.23165207035058297, "feedback": "The algorithm DynamicHarmonySearch got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.23 with standard deviation 0.18.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.5862724053194371, 0.5862724053194371, 0.5862724053194371, 0.5532683160984264, 0.5532683160984264, 0.5532683160984264, 0.5291377084825011, 0.5291377084825011, 0.5291377084825011, 0.20369118875367032, 0.20369118875367032, 0.20369118875367032, 0.2663502394881987, 0.2663502394881987, 0.2663502394881987, 0.2663936864999724, 0.2663936864999724, 0.2663936864999724, 0.18187154755845403, 0.18187154755845403, 0.18187154755845403, 0.16297121899969425, 0.16297121899969425, 0.16297121899969425, 0.17672726982975873, 0.17672726982975873, 0.17672726982975873, 0.15857588945675438, 0.15857588945675438, 0.15857588945675438, 0.1776472645269892, 0.1776472645269892, 0.1776472645269892, 0.17329473255675842, 0.17329473255675842, 0.17329473255675842, 0.8185570129782334, 0.8185570129782334, 0.8185570129782334, 0.8605575800283107, 0.8605575800283107, 0.8605575800283107, 0.8612145130244491, 0.8612145130244491, 0.8612145130244491, 0.24573105825898878, 0.24573105825898878, 0.24573105825898878, 0.3136892834682905, 0.3136892834682905, 0.3136892834682905, 0.26052170800238816, 0.26052170800238816, 0.26052170800238816, 0.15601216530229833, 0.15601216530229833, 0.15601216530229833, 0.2562353120239914, 0.2562353120239914, 0.2562353120239914, 0.2038012318121344, 0.2038012318121344, 0.2038012318121344, 0.1644551514794632, 0.1644551514794632, 0.1644551514794632, 0.22461935938489874, 0.22461935938489874, 0.22461935938489874, 0.2940908855499782, 0.2940908855499782, 0.2940908855499782, 0.1569851841001082, 0.1569851841001082, 0.1569851841001082, 0.12460265862921494, 0.12460265862921494, 0.12460265862921494, 0.14208468771834837, 0.14208468771834837, 0.14208468771834837, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0003298581531103739, 0.0003298581531103739, 0.0003298581531103739, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.07860568030921078, 0.07860568030921078, 0.07860568030921078, 0.07137236133705172, 0.07137236133705172, 0.07137236133705172, 0.06717927269038027, 0.06717927269038027, 0.06717927269038027, 0.013869051855515901, 0.013869051855515901, 0.013869051855515901, 0.0012789083706198356, 0.0012789083706198356, 0.0012789083706198356, 0.03673900353974424, 0.03673900353974424, 0.03673900353974424, 0.13442114849048103, 0.13442114849048103, 0.13442114849048103, 0.12923200465244022, 0.12923200465244022, 0.12923200465244022, 0.08369691620053166, 0.08369691620053166, 0.08369691620053166, 0.42694905419588625, 0.42694905419588625, 0.42694905419588625, 0.4670937317139703, 0.4670937317139703, 0.4670937317139703, 0.4578200993686591, 0.4578200993686591, 0.4578200993686591, 0.1036275212024792, 0.1036275212024792, 0.1036275212024792, 0.1394243005728626, 0.1394243005728626, 0.1394243005728626, 0.12878572393757826, 0.12878572393757826, 0.12878572393757826, 0.13331620437327474, 0.13331620437327474, 0.13331620437327474, 0.1294826273707731, 0.1294826273707731, 0.1294826273707731, 0.12175360514498823, 0.12175360514498823, 0.12175360514498823, 0.2694671862318968, 0.2694671862318968, 0.2694671862318968, 0.24598205445581134, 0.24598205445581134, 0.24598205445581134, 0.28732217571757257, 0.28732217571757257, 0.28732217571757257, 0.2623739930703668, 0.2623739930703668, 0.2623739930703668, 0.22121384291129664, 0.22121384291129664, 0.22121384291129664, 0.22953916816041975, 0.22953916816041975, 0.22953916816041975, 0.21935151140967724, 0.21935151140967724, 0.21935151140967724, 0.2019530739775569, 0.2019530739775569, 0.2019530739775569, 0.20789952915153254, 0.20789952915153254, 0.20789952915153254, 0.2298872929698489, 0.2298872929698489, 0.2298872929698489, 0.22830134582507866, 0.22830134582507866, 0.22830134582507866, 0.20886118445640178, 0.20886118445640178, 0.20886118445640178, 0.18599349744531668, 0.18599349744531668, 0.18599349744531668, 0.6611291269601124, 0.6611291269601124, 0.6611291269601124, 0.16310380142977376, 0.16310380142977376, 0.16310380142977376, 0.3877091644076176, 0.3877091644076176, 0.3877091644076176, 0.20582634900715846, 0.20582634900715846, 0.20582634900715846, 0.16218599001763812, 0.16218599001763812, 0.16218599001763812, 0.18586320869544826, 0.18586320869544826, 0.18586320869544826, 0.17470964340106399, 0.17470964340106399, 0.17470964340106399, 0.22251262799217475, 0.22251262799217475, 0.22251262799217475, 0.09210507993233097, 0.09210507993233097, 0.09210507993233097, 0.10021158963748822, 0.10021158963748822, 0.10021158963748822, 0.08091029516712045, 0.08091029516712045, 0.08091029516712045]}, "mutation_prompt": null}
{"id": "77abb5b4-dea8-4ffc-8c88-56ccc8255b0b", "solution": "import numpy as np\n\nclass EnhancedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted for adaptive exploration-exploitation trade-off\n        self.c1_initial = 1.5  # Fine-tuned for exploration-exploitation balance\n        self.c2_initial = 1.7\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Further increased for stronger convergence\n        self.velocity_clamp_initial = 0.6  # Dynamic velocity clamping\n        self.velocity_clamp_final = 0.3\n        self.local_search_probability = 0.15  # Increased probability for local improvements\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    neighborhood_indices = np.random.choice(self.num_particles, size=5, replace=False)\n                    neighborhood_best_position = min(neighborhood_indices, key=lambda idx: personal_best_scores[idx])\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation + (personal_best_positions[neighborhood_best_position] - positions[i]) * 0.1\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedHybridPSO", "description": "An Enhanced Hybrid PSO with Dynamic Neighborhood-based Perturbations and Adaptive Velocity Clamping for Diverse Optimization Challenges.", "configspace": "", "generation": 51, "fitness": 0.2927746811448261, "feedback": "The algorithm EnhancedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.694526469818669, 0.694526469818669, 0.694526469818669, 0.6739265609722871, 0.6739265609722871, 0.6739265609722871, 0.676236474425198, 0.676236474425198, 0.676236474425198, 0.3284109590733929, 0.3284109590733929, 0.3284109590733929, 0.26422860112528146, 0.26422860112528146, 0.26422860112528146, 0.3141657030762107, 0.3141657030762107, 0.3141657030762107, 0.1280697297641542, 0.1280697297641542, 0.1280697297641542, 0.11878077996277592, 0.11878077996277592, 0.11878077996277592, 0.1395413979777026, 0.1395413979777026, 0.1395413979777026, 0.10913580299428305, 0.10913580299428305, 0.10913580299428305, 0.1069328763294638, 0.1069328763294638, 0.1069328763294638, 0.09447254864691568, 0.09447254864691568, 0.09447254864691568, 0.8836873994991568, 0.8836873994991568, 0.8836873994991568, 0.8905511348682532, 0.8905511348682532, 0.8905511348682532, 0.8844503598410548, 0.8844503598410548, 0.8844503598410548, 0.43491549761570825, 0.43491549761570825, 0.43491549761570825, 0.4314891253881403, 0.4314891253881403, 0.4314891253881403, 0.42224646350948025, 0.42224646350948025, 0.42224646350948025, 0.8146090025698772, 0.8146090025698772, 0.8146090025698772, 0.7321588765661751, 0.7321588765661751, 0.7321588765661751, 0.1509342893175437, 0.1509342893175437, 0.1509342893175437, 0.18458816261562971, 0.18458816261562971, 0.18458816261562971, 0.18488890709432249, 0.18488890709432249, 0.18488890709432249, 0.1981823457405093, 0.1981823457405093, 0.1981823457405093, 0.20740630972697216, 0.20740630972697216, 0.20740630972697216, 0.24503638683656004, 0.24503638683656004, 0.24503638683656004, 0.2128581976336622, 0.2128581976336622, 0.2128581976336622, 0.08481508169764329, 0.08481508169764329, 0.08481508169764329, 0.048559653746393594, 0.048559653746393594, 0.048559653746393594, 0.07546625185917533, 0.07546625185917533, 0.07546625185917533, 0.19860261966519832, 0.19860261966519832, 0.19860261966519832, 0.04492222521099809, 0.04492222521099809, 0.04492222521099809, 0.12214993819271225, 0.12214993819271225, 0.12214993819271225, 0.14627467835395036, 0.14627467835395036, 0.14627467835395036, 0.0796111788823557, 0.0796111788823557, 0.0796111788823557, 0.06546498794812028, 0.06546498794812028, 0.06546498794812028, 0.13639748924803974, 0.13639748924803974, 0.13639748924803974, 0.09713074631237628, 0.09713074631237628, 0.09713074631237628, 0.1077408278048333, 0.1077408278048333, 0.1077408278048333, 0.5122769636886013, 0.5122769636886013, 0.5122769636886013, 0.474239153629342, 0.474239153629342, 0.474239153629342, 0.5042253974249171, 0.5042253974249171, 0.5042253974249171, 0.08712823623578447, 0.08712823623578447, 0.08712823623578447, 0.12608798150119505, 0.12608798150119505, 0.12608798150119505, 0.10755741064548274, 0.10755741064548274, 0.10755741064548274, 0.23628448807923474, 0.23628448807923474, 0.23628448807923474, 0.2369501066757208, 0.2369501066757208, 0.2369501066757208, 0.33145166196605036, 0.33145166196605036, 0.33145166196605036, 0.3584052864249181, 0.3584052864249181, 0.3584052864249181, 0.3585571869162625, 0.3585571869162625, 0.3585571869162625, 0.2663078932360958, 0.2663078932360958, 0.2663078932360958, 0.2159495595758416, 0.2159495595758416, 0.2159495595758416, 0.21284017411434497, 0.21284017411434497, 0.21284017411434497, 0.2307472598684931, 0.2307472598684931, 0.2307472598684931, 0.22442062686767872, 0.22442062686767872, 0.22442062686767872, 0.24079307578022324, 0.24079307578022324, 0.24079307578022324, 0.25071579097323216, 0.25071579097323216, 0.25071579097323216, 0.19546136620796895, 0.19546136620796895, 0.19546136620796895, 0.21873286074048082, 0.21873286074048082, 0.21873286074048082, 0.19350988743448228, 0.19350988743448228, 0.19350988743448228, 0.8170393525970535, 0.8170393525970535, 0.8170393525970535, 0.8101643510400678, 0.8101643510400678, 0.8101643510400678, 0.14207527756918825, 0.14207527756918825, 0.14207527756918825, 0.7918820126985517, 0.7918820126985517, 0.7918820126985517, 0.20804720317782144, 0.20804720317782144, 0.20804720317782144, 0.10406689784658607, 0.10406689784658607, 0.10406689784658607, 0.19496106409224445, 0.19496106409224445, 0.19496106409224445, 0.1823082825060871, 0.1823082825060871, 0.1823082825060871, 0.19231158156525796, 0.19231158156525796, 0.19231158156525796, 0.09622778420133182, 0.09622778420133182, 0.09622778420133182, 0.08922056096174524, 0.08922056096174524, 0.08922056096174524, 0.13526426427401606, 0.13526426427401606, 0.13526426427401606]}, "mutation_prompt": null}
{"id": "7e319f34-0923-41cb-8af5-dfc85e2aac44", "solution": "import numpy as np\n\nclass DynamicNeighborhoodPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased the number of particles for enhanced exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.4  # Adjusted minimum inertia weight for dynamic adaptation\n        self.c1 = 1.5  # Balanced cognitive factor for individual insight\n        self.c2 = 2.0  # Moderate social factor for collaborative guidance\n        self.velocity_clamp = 0.4  # Refined velocity clamping to control oscillations\n        self.neighborhood_size = 5  # Introduced neighborhood-based interactions\n        self.adaptive_threshold = 0.05  # Threshold for adaptively adjusting exploration\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                # Dynamic neighborhood interaction\n                neighbors = np.random.choice(self.num_particles, self.neighborhood_size, replace=False)\n                local_best_position = min(neighbors, key=lambda idx: personal_best_scores[idx])\n                local_best_position = personal_best_positions[local_best_position]\n\n                if np.random.rand() < self.adaptive_threshold:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = self.c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = self.c2 * np.random.uniform(0, 1, self.dim) * (local_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# dynamic_neighborhood_pso = DynamicNeighborhoodPSO(budget=10000, dim=10)\n# dynamic_neighborhood_pso(func)", "name": "DynamicNeighborhoodPSO", "description": "A novel Particle Swarm Optimization with dynamic neighborhood topology and adaptive exploration-exploitation balance for diverse optimization tasks.", "configspace": "", "generation": 52, "fitness": 0.24067339007793503, "feedback": "The algorithm DynamicNeighborhoodPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.19.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.5760821732031531, 0.5760821732031531, 0.5760821732031531, 0.543924738470529, 0.543924738470529, 0.543924738470529, 0.5513016271139375, 0.5513016271139375, 0.5513016271139375, 0.2064043089398948, 0.2064043089398948, 0.2064043089398948, 0.2138417609012978, 0.2138417609012978, 0.2138417609012978, 0.17316054395206926, 0.17316054395206926, 0.17316054395206926, 0.0990303401635465, 0.0990303401635465, 0.0990303401635465, 0.10290494634076497, 0.10290494634076497, 0.10290494634076497, 0.0915045746031552, 0.0915045746031552, 0.0915045746031552, 0.07825072914743392, 0.07825072914743392, 0.07825072914743392, 0.11651033453216353, 0.11651033453216353, 0.11651033453216353, 0.09821742769387765, 0.09821742769387765, 0.09821742769387765, 0.7589670667262295, 0.7589670667262295, 0.7589670667262295, 0.7420384634052251, 0.7420384634052251, 0.7420384634052251, 0.7458735539845847, 0.7458735539845847, 0.7458735539845847, 0.31649946075713975, 0.31649946075713975, 0.31649946075713975, 0.33006705169769013, 0.33006705169769013, 0.33006705169769013, 0.31937135480375034, 0.31937135480375034, 0.31937135480375034, 0.22503564031612577, 0.22503564031612577, 0.22503564031612577, 0.5913475973830169, 0.5913475973830169, 0.5913475973830169, 0.166221548566439, 0.166221548566439, 0.166221548566439, 0.18153329578272392, 0.18153329578272392, 0.18153329578272392, 0.1564298251667624, 0.1564298251667624, 0.1564298251667624, 0.18850253848252618, 0.18850253848252618, 0.18850253848252618, 0.17177649702840103, 0.17177649702840103, 0.17177649702840103, 0.17956770613023587, 0.17956770613023587, 0.17956770613023587, 0.1873674930094118, 0.1873674930094118, 0.1873674930094118, 0.018318652295552962, 0.018318652295552962, 0.018318652295552962, 0.0554268159256992, 0.0554268159256992, 0.0554268159256992, 0.020209834354803946, 0.020209834354803946, 0.020209834354803946, 0.14164894392481997, 0.14164894392481997, 0.14164894392481997, 0.05867471389692691, 0.05867471389692691, 0.05867471389692691, 0.13700917309780303, 0.13700917309780303, 0.13700917309780303, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.10664663527214613, 0.10664663527214613, 0.10664663527214613, 0.09934823909206258, 0.09934823909206258, 0.09934823909206258, 0.0779335377206889, 0.0779335377206889, 0.0779335377206889, 0.4711302360687192, 0.4711302360687192, 0.4711302360687192, 0.4112440632356059, 0.4112440632356059, 0.4112440632356059, 0.43227561798062675, 0.43227561798062675, 0.43227561798062675, 0.06775125263302328, 0.06775125263302328, 0.06775125263302328, 0.08725159343333422, 0.08725159343333422, 0.08725159343333422, 0.10514007307112205, 0.10514007307112205, 0.10514007307112205, 0.2560719477802804, 0.2560719477802804, 0.2560719477802804, 0.2211841424087212, 0.2211841424087212, 0.2211841424087212, 0.16589799496306967, 0.16589799496306967, 0.16589799496306967, 0.24446065569964281, 0.24446065569964281, 0.24446065569964281, 0.3222825638680855, 0.3222825638680855, 0.3222825638680855, 0.23194807629202796, 0.23194807629202796, 0.23194807629202796, 0.2011262502612503, 0.2011262502612503, 0.2011262502612503, 0.248064560079992, 0.248064560079992, 0.248064560079992, 0.16990616013331616, 0.16990616013331616, 0.16990616013331616, 0.23888039452258913, 0.23888039452258913, 0.23888039452258913, 0.23291295477546603, 0.23291295477546603, 0.23291295477546603, 0.23969224191766736, 0.23969224191766736, 0.23969224191766736, 0.1709218570461175, 0.1709218570461175, 0.1709218570461175, 0.1748608772215139, 0.1748608772215139, 0.1748608772215139, 0.19005121414727977, 0.19005121414727977, 0.19005121414727977, 0.18353896457210772, 0.18353896457210772, 0.18353896457210772, 0.7065240253088494, 0.7065240253088494, 0.7065240253088494, 0.6073811953792468, 0.6073811953792468, 0.6073811953792468, 0.5061297080802228, 0.5061297080802228, 0.5061297080802228, 0.4144756812480491, 0.4144756812480491, 0.4144756812480491, 0.39737657363040857, 0.39737657363040857, 0.39737657363040857, 0.19373679375160824, 0.19373679375160824, 0.19373679375160824, 0.17904017696106533, 0.17904017696106533, 0.17904017696106533, 0.1882549703460521, 0.1882549703460521, 0.1882549703460521, 0.07815884973067844, 0.07815884973067844, 0.07815884973067844, 0.08725163152070403, 0.08725163152070403, 0.08725163152070403, 0.07631164366028975, 0.07631164366028975, 0.07631164366028975]}, "mutation_prompt": null}
{"id": "5bd1c348-042e-4620-b0bb-60ff89ff44d7", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Further decreased minimum inertia weight for better exploitation\n        self.c1_initial = 1.8  # Adjusted cognitive factor for improved balance\n        self.c2_initial = 1.7\n        self.c1_final = 1.1\n        self.c2_final = 3.0  # Increased social factor for stronger convergence\n        self.velocity_clamp = 0.4  # More aggressive velocity clamping\n        self.local_search_probability = 0.15  # Increased probability for local search\n        self.reinit_probability = 0.05  # Added random re-initialization probability\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                if np.random.rand() < self.reinit_probability:\n                    positions[i] = np.random.uniform(self.lower_bound, self.upper_bound, self.dim)\n                    velocities[i] = np.zeros(self.dim)\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "HybridAdaptivePSO", "description": "A hybrid Particle Swarm Optimization with dynamic adaptive learning rates, local search, and random re-initialization for enhanced exploration and exploitation.", "configspace": "", "generation": 53, "fitness": 0.2551008167898771, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6730543588236337, 0.6730543588236337, 0.6730543588236337, 0.6305302876329797, 0.6305302876329797, 0.6305302876329797, 0.6456357419427379, 0.6456357419427379, 0.6456357419427379, 0.17875507290419812, 0.17875507290419812, 0.17875507290419812, 0.22641977620336007, 0.22641977620336007, 0.22641977620336007, 0.1826771143040703, 0.1826771143040703, 0.1826771143040703, 0.12049933254303757, 0.12049933254303757, 0.12049933254303757, 0.11002063028974085, 0.11002063028974085, 0.11002063028974085, 0.1023630196068479, 0.1023630196068479, 0.1023630196068479, 0.1089330287803546, 0.1089330287803546, 0.1089330287803546, 0.10785027300195305, 0.10785027300195305, 0.10785027300195305, 0.13467563829357188, 0.13467563829357188, 0.13467563829357188, 0.8249514739053034, 0.8249514739053034, 0.8249514739053034, 0.8320196345431614, 0.8320196345431614, 0.8320196345431614, 0.8158915299078713, 0.8158915299078713, 0.8158915299078713, 0.3910259350328996, 0.3910259350328996, 0.3910259350328996, 0.38736386566684866, 0.38736386566684866, 0.38736386566684866, 0.3680229091423708, 0.3680229091423708, 0.3680229091423708, 0.7280983727959824, 0.7280983727959824, 0.7280983727959824, 0.273436810889816, 0.273436810889816, 0.273436810889816, 0.217827905751522, 0.217827905751522, 0.217827905751522, 0.11477995685591591, 0.11477995685591591, 0.11477995685591591, 0.15863304572960302, 0.15863304572960302, 0.15863304572960302, 0.16029532330565233, 0.16029532330565233, 0.16029532330565233, 0.17202957339580205, 0.17202957339580205, 0.17202957339580205, 0.12277451206870571, 0.12277451206870571, 0.12277451206870571, 0.1956227258281088, 0.1956227258281088, 0.1956227258281088, 0.02442524117852951, 0.02442524117852951, 0.02442524117852951, 0.0014527610187716755, 0.0014527610187716755, 0.0014527610187716755, 0.09814496976244957, 0.09814496976244957, 0.09814496976244957, 0.12248627914110688, 0.12248627914110688, 0.12248627914110688, 0.07253296276567867, 0.07253296276567867, 0.07253296276567867, 0.11976886530553998, 0.11976886530553998, 0.11976886530553998, 0.10949734763559282, 0.10949734763559282, 0.10949734763559282, 0.07173457230088875, 0.07173457230088875, 0.07173457230088875, 0.05589282300683496, 0.05589282300683496, 0.05589282300683496, 0.12104744627510577, 0.12104744627510577, 0.12104744627510577, 0.06199354363605247, 0.06199354363605247, 0.06199354363605247, 0.07676751440115936, 0.07676751440115936, 0.07676751440115936, 0.4513586537025599, 0.4513586537025599, 0.4513586537025599, 0.44672789291419635, 0.44672789291419635, 0.44672789291419635, 0.46749776762368933, 0.46749776762368933, 0.46749776762368933, 0.07998181812507787, 0.07998181812507787, 0.07998181812507787, 0.09254441466590957, 0.09254441466590957, 0.09254441466590957, 0.10550715664070398, 0.10550715664070398, 0.10550715664070398, 0.3394337919609727, 0.3394337919609727, 0.3394337919609727, 0.2431737014591524, 0.2431737014591524, 0.2431737014591524, 0.19448003437426764, 0.19448003437426764, 0.19448003437426764, 0.33049573047168224, 0.33049573047168224, 0.33049573047168224, 0.35555893548746564, 0.35555893548746564, 0.35555893548746564, 0.23271777653384684, 0.23271777653384684, 0.23271777653384684, 0.1371743388752097, 0.1371743388752097, 0.1371743388752097, 0.2558428951152487, 0.2558428951152487, 0.2558428951152487, 0.19523457813049028, 0.19523457813049028, 0.19523457813049028, 0.2023128803314943, 0.2023128803314943, 0.2023128803314943, 0.23482205188394034, 0.23482205188394034, 0.23482205188394034, 0.25070537058284603, 0.25070537058284603, 0.25070537058284603, 0.20198459781093847, 0.20198459781093847, 0.20198459781093847, 0.1854913027626195, 0.1854913027626195, 0.1854913027626195, 0.17818794423621753, 0.17818794423621753, 0.17818794423621753, 0.18311607081124515, 0.18311607081124515, 0.18311607081124515, 0.7819404821343257, 0.7819404821343257, 0.7819404821343257, 0.14156996462949467, 0.14156996462949467, 0.14156996462949467, 0.5658828237887048, 0.5658828237887048, 0.5658828237887048, 0.29789021301874785, 0.29789021301874785, 0.29789021301874785, 0.47130603764442014, 0.47130603764442014, 0.47130603764442014, 0.1757071869285266, 0.1757071869285266, 0.1757071869285266, 0.17936490076319445, 0.17936490076319445, 0.17936490076319445, 0.21101750274084385, 0.21101750274084385, 0.21101750274084385, 0.08350076178468191, 0.08350076178468191, 0.08350076178468191, 0.08497397792557881, 0.08497397792557881, 0.08497397792557881, 0.0898230774390999, 0.0898230774390999, 0.0898230774390999]}, "mutation_prompt": null}
{"id": "b62a3f89-11f2-4578-9517-a6694d6f025b", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for more exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4  # Adjusted for slightly more exploitation\n        self.c1_initial = 2.5  # Higher initial cognitive factor for better exploration\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Increased for stronger convergence ability\n        self.velocity_clamp = 0.6  # Modified velocity clamping for better control\n        self.local_search_probability = 0.2  # Increased probability for local search\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "An enhanced PSO with adaptive cognitive-social balance and dynamic local search to improve exploration-exploitation trade-off.", "configspace": "", "generation": 54, "fitness": 0.2648396951979515, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.5987918318136527, 0.5987918318136527, 0.5987918318136527, 0.6190123543085477, 0.6190123543085477, 0.6190123543085477, 0.6120975312118757, 0.6120975312118757, 0.6120975312118757, 0.1991668769728585, 0.1991668769728585, 0.1991668769728585, 0.19365313278725826, 0.19365313278725826, 0.19365313278725826, 0.22023393297795157, 0.22023393297795157, 0.22023393297795157, 0.1357483253388545, 0.1357483253388545, 0.1357483253388545, 0.15223319363089527, 0.15223319363089527, 0.15223319363089527, 0.13717533490059264, 0.13717533490059264, 0.13717533490059264, 0.11315115499770578, 0.11315115499770578, 0.11315115499770578, 0.11684938492811381, 0.11684938492811381, 0.11684938492811381, 0.14794660065767018, 0.14794660065767018, 0.14794660065767018, 0.9012529660044041, 0.9012529660044041, 0.9012529660044041, 0.8848005430259036, 0.8848005430259036, 0.8848005430259036, 0.8900163775890066, 0.8900163775890066, 0.8900163775890066, 0.34937163233223434, 0.34937163233223434, 0.34937163233223434, 0.3546471971207481, 0.3546471971207481, 0.3546471971207481, 0.3576665162177418, 0.3576665162177418, 0.3576665162177418, 0.34433419469484083, 0.34433419469484083, 0.34433419469484083, 0.5969513008744527, 0.5969513008744527, 0.5969513008744527, 0.630553839786913, 0.630553839786913, 0.630553839786913, 0.1724693092783749, 0.1724693092783749, 0.1724693092783749, 0.16445440025993063, 0.16445440025993063, 0.16445440025993063, 0.17813026072789073, 0.17813026072789073, 0.17813026072789073, 0.18386057991276328, 0.18386057991276328, 0.18386057991276328, 0.20680625151170284, 0.20680625151170284, 0.20680625151170284, 0.1906975402449651, 0.1906975402449651, 0.1906975402449651, 0.07456157202323266, 0.07456157202323266, 0.07456157202323266, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.04707250932229401, 0.04707250932229401, 0.04707250932229401, 0.21666806953028206, 0.21666806953028206, 0.21666806953028206, 0.0523682565043857, 0.0523682565043857, 0.0523682565043857, 0.09428608853409637, 0.09428608853409637, 0.09428608853409637, 0.11147522381779729, 0.11147522381779729, 0.11147522381779729, 0.07355258094452188, 0.07355258094452188, 0.07355258094452188, 0.08527401561042547, 0.08527401561042547, 0.08527401561042547, 0.14203259815234814, 0.14203259815234814, 0.14203259815234814, 0.14382457769923263, 0.14382457769923263, 0.14382457769923263, 0.13174033286676856, 0.13174033286676856, 0.13174033286676856, 0.4644907107826157, 0.4644907107826157, 0.4644907107826157, 0.47932226054412586, 0.47932226054412586, 0.47932226054412586, 0.4722720948829906, 0.4722720948829906, 0.4722720948829906, 0.08803523754744225, 0.08803523754744225, 0.08803523754744225, 0.11318168962897857, 0.11318168962897857, 0.11318168962897857, 0.14092363995542856, 0.14092363995542856, 0.14092363995542856, 0.1825283875984819, 0.1825283875984819, 0.1825283875984819, 0.17215256045077443, 0.17215256045077443, 0.17215256045077443, 0.322722728273816, 0.322722728273816, 0.322722728273816, 0.30999452969734, 0.30999452969734, 0.30999452969734, 0.32752673193982484, 0.32752673193982484, 0.32752673193982484, 0.3535654952053735, 0.3535654952053735, 0.3535654952053735, 0.19052834068831082, 0.19052834068831082, 0.19052834068831082, 0.2259902655946967, 0.2259902655946967, 0.2259902655946967, 0.21597906134699563, 0.21597906134699563, 0.21597906134699563, 0.22041787874948982, 0.22041787874948982, 0.22041787874948982, 0.23528109801937003, 0.23528109801937003, 0.23528109801937003, 0.23102726702730292, 0.23102726702730292, 0.23102726702730292, 0.21463001802223503, 0.21463001802223503, 0.21463001802223503, 0.2104372766659971, 0.2104372766659971, 0.2104372766659971, 0.2052959377722403, 0.2052959377722403, 0.2052959377722403, 0.12447076965751092, 0.12447076965751092, 0.12447076965751092, 0.7771594303096618, 0.7771594303096618, 0.7771594303096618, 0.16420334035317197, 0.16420334035317197, 0.16420334035317197, 0.5956862432252941, 0.5956862432252941, 0.5956862432252941, 0.2088748324239469, 0.2088748324239469, 0.2088748324239469, 0.16123135720760107, 0.16123135720760107, 0.16123135720760107, 0.19544622581290805, 0.19544622581290805, 0.19544622581290805, 0.19823979652111134, 0.19823979652111134, 0.19823979652111134, 0.19863028641711777, 0.19863028641711777, 0.19863028641711777, 0.09195746044246222, 0.09195746044246222, 0.09195746044246222, 0.07748703963070769, 0.07748703963070769, 0.07748703963070769, 0.07373967274394777, 0.07373967274394777, 0.07373967274394777]}, "mutation_prompt": null}
{"id": "a0cc1e24-0c80-4456-be86-d2033f54894f", "solution": "import numpy as np\n\nclass HybridAdaptivePSOLevy:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Slightly increased the number of particles for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.5\n        self.c1_final = 1.2\n        self.c2_final = 2.8\n        self.velocity_clamp = 0.5\n        self.local_search_probability = 0.1\n\n    def levy_flight(self, lam):\n        u = np.random.normal(0, 1, self.dim) * np.sqrt((1 / lam))\n        v = np.random.normal(0, 1, self.dim)\n        return u / np.power(np.abs(v), 1/lam)\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    levy_jump = self.levy_flight(1.5)\n                    candidate_position = positions[i] + levy_jump\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_pso_levy = HybridAdaptivePSOLevy(budget=10000, dim=10)\n# hybrid_pso_levy(func)", "name": "HybridAdaptivePSOLevy", "description": "A hybrid Adaptive PSO with Lévy flight-based local search to enhance exploration and exploitation balance in high-dimensional spaces.", "configspace": "", "generation": 55, "fitness": 0.2808924427834097, "feedback": "The algorithm HybridAdaptivePSOLevy got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6974542415440556, 0.6974542415440556, 0.6974542415440556, 0.712032366375527, 0.712032366375527, 0.712032366375527, 0.6875275231485154, 0.6875275231485154, 0.6875275231485154, 0.3667323040422984, 0.3667323040422984, 0.3667323040422984, 0.35450680334571305, 0.35450680334571305, 0.35450680334571305, 0.3047788216933506, 0.3047788216933506, 0.3047788216933506, 0.11952385193032855, 0.11952385193032855, 0.11952385193032855, 0.1289575873090698, 0.1289575873090698, 0.1289575873090698, 0.12407988255699087, 0.12407988255699087, 0.12407988255699087, 0.11500362984686274, 0.11500362984686274, 0.11500362984686274, 0.1125394079869726, 0.1125394079869726, 0.1125394079869726, 0.1357545086778169, 0.1357545086778169, 0.1357545086778169, 0.873907000516529, 0.873907000516529, 0.873907000516529, 0.8811068636316663, 0.8811068636316663, 0.8811068636316663, 0.8820393150186462, 0.8820393150186462, 0.8820393150186462, 0.4557183126976575, 0.4557183126976575, 0.4557183126976575, 0.45605314696810184, 0.45605314696810184, 0.45605314696810184, 0.4190824541099776, 0.4190824541099776, 0.4190824541099776, 0.6033571127721835, 0.6033571127721835, 0.6033571127721835, 0.27162514795854964, 0.27162514795854964, 0.27162514795854964, 0.22768222158400309, 0.22768222158400309, 0.22768222158400309, 0.24952783939301748, 0.24952783939301748, 0.24952783939301748, 0.20684123476758565, 0.20684123476758565, 0.20684123476758565, 0.17909202493112175, 0.17909202493112175, 0.17909202493112175, 0.24049314421068546, 0.24049314421068546, 0.24049314421068546, 0.1640095048666501, 0.1640095048666501, 0.1640095048666501, 0.13143553569392297, 0.13143553569392297, 0.13143553569392297, 0.031628167858194556, 0.031628167858194556, 0.031628167858194556, 0.08508083758401486, 0.08508083758401486, 0.08508083758401486, 0.14966843199556845, 0.14966843199556845, 0.14966843199556845, 0.11706352961145206, 0.11706352961145206, 0.11706352961145206, 0.07920113480848578, 0.07920113480848578, 0.07920113480848578, 0.08599005309381025, 0.08599005309381025, 0.08599005309381025, 0.11399246179179989, 0.11399246179179989, 0.11399246179179989, 0.10977525868600169, 0.10977525868600169, 0.10977525868600169, 0.07137426302277505, 0.07137426302277505, 0.07137426302277505, 0.14564245636430728, 0.14564245636430728, 0.14564245636430728, 0.0718521054807415, 0.0718521054807415, 0.0718521054807415, 0.11086060609732029, 0.11086060609732029, 0.11086060609732029, 0.4849515083223829, 0.4849515083223829, 0.4849515083223829, 0.47953187527692276, 0.47953187527692276, 0.47953187527692276, 0.5081168171235911, 0.5081168171235911, 0.5081168171235911, 0.10960853311162266, 0.10960853311162266, 0.10960853311162266, 0.11004791254554291, 0.11004791254554291, 0.11004791254554291, 0.09470482061993302, 0.09470482061993302, 0.09470482061993302, 0.25902193490294123, 0.25902193490294123, 0.25902193490294123, 0.16958596852759744, 0.16958596852759744, 0.16958596852759744, 0.20613643646384383, 0.20613643646384383, 0.20613643646384383, 0.24891188057988212, 0.24891188057988212, 0.24891188057988212, 0.3312493714028195, 0.3312493714028195, 0.3312493714028195, 0.27657001586458096, 0.27657001586458096, 0.27657001586458096, 0.20982077851281533, 0.20982077851281533, 0.20982077851281533, 0.24318773613188926, 0.24318773613188926, 0.24318773613188926, 0.2472535587517548, 0.2472535587517548, 0.2472535587517548, 0.2096867496079754, 0.2096867496079754, 0.2096867496079754, 0.2515031633491993, 0.2515031633491993, 0.2515031633491993, 0.2561175741249049, 0.2561175741249049, 0.2561175741249049, 0.18036029672463316, 0.18036029672463316, 0.18036029672463316, 0.2417992261967159, 0.2417992261967159, 0.2417992261967159, 0.20044064171132914, 0.20044064171132914, 0.20044064171132914, 0.12483013463695447, 0.12483013463695447, 0.12483013463695447, 0.815815877009477, 0.815815877009477, 0.815815877009477, 0.14159969441174836, 0.14159969441174836, 0.14159969441174836, 0.6566404554259166, 0.6566404554259166, 0.6566404554259166, 0.5221223284684723, 0.5221223284684723, 0.5221223284684723, 0.5598283537391135, 0.5598283537391135, 0.5598283537391135, 0.17978309980143692, 0.17978309980143692, 0.17978309980143692, 0.18774110152366263, 0.18774110152366263, 0.18774110152366263, 0.18012395674353487, 0.18012395674353487, 0.18012395674353487, 0.0922445714518042, 0.0922445714518042, 0.0922445714518042, 0.08509084881955675, 0.08509084881955675, 0.08509084881955675, 0.08683756454866975, 0.08683756454866975, 0.08683756454866975]}, "mutation_prompt": null}
{"id": "00e6442b-b18e-4496-be81-cf19706bb5c3", "solution": "import numpy as np\n\nclass DualLayerAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for broader exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Reduced min inertia to allow more exploitation in late stages\n        self.c1_initial = 1.5  # Reduced cognitive factor to stabilize exploration\n        self.c2_initial = 1.7\n        self.c1_final = 1.0\n        self.c2_final = 2.9  # Higher social factor for stronger convergence\n        self.velocity_clamp = 0.4  # Tighter velocity clamping for precise control\n        self.local_search_probability = 0.15  # Increased chance for local search operations\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * (evaluations / self.budget) ** 1.5)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.uniform(-0.2, 0.2, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "DualLayerAdaptivePSO", "description": "A Dual-Layer Adaptive PSO that employs a swarm-wide inertia modulation and stochastic perturbation to enhance exploration and robust convergence.", "configspace": "", "generation": 56, "fitness": 0.268378103818175, "feedback": "The algorithm DualLayerAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6699976193576281, 0.6699976193576281, 0.6699976193576281, 0.658947276572379, 0.658947276572379, 0.658947276572379, 0.6543801717929942, 0.6543801717929942, 0.6543801717929942, 0.3230455536834155, 0.3230455536834155, 0.3230455536834155, 0.2898699725063216, 0.2898699725063216, 0.2898699725063216, 0.24718337297805748, 0.24718337297805748, 0.24718337297805748, 0.11041136107146832, 0.11041136107146832, 0.11041136107146832, 0.12175894726505809, 0.12175894726505809, 0.12175894726505809, 0.11818962997704818, 0.11818962997704818, 0.11818962997704818, 0.08696020957847395, 0.08696020957847395, 0.08696020957847395, 0.09649083220604693, 0.09649083220604693, 0.09649083220604693, 0.135950280594904, 0.135950280594904, 0.135950280594904, 0.8672217270572397, 0.8672217270572397, 0.8672217270572397, 0.8398528661786222, 0.8398528661786222, 0.8398528661786222, 0.8451647362665935, 0.8451647362665935, 0.8451647362665935, 0.4310381459063397, 0.4310381459063397, 0.4310381459063397, 0.4580671516153547, 0.4580671516153547, 0.4580671516153547, 0.4023210916242663, 0.4023210916242663, 0.4023210916242663, 0.6336549515510046, 0.6336549515510046, 0.6336549515510046, 0.7785609648700483, 0.7785609648700483, 0.7785609648700483, 0.2165760386072656, 0.2165760386072656, 0.2165760386072656, 0.19550962130320837, 0.19550962130320837, 0.19550962130320837, 0.17455170613152382, 0.17455170613152382, 0.17455170613152382, 0.18734288468272087, 0.18734288468272087, 0.18734288468272087, 0.2057185945146709, 0.2057185945146709, 0.2057185945146709, 0.20390440079719863, 0.20390440079719863, 0.20390440079719863, 0.13119636609723506, 0.13119636609723506, 0.13119636609723506, 0.10273954634203786, 0.10273954634203786, 0.10273954634203786, 0.050424315053354096, 0.050424315053354096, 0.050424315053354096, 0.03614538971795778, 0.03614538971795778, 0.03614538971795778, 0.13182128710189822, 0.13182128710189822, 0.13182128710189822, 0.10610957587169634, 0.10610957587169634, 0.10610957587169634, 0.14897841550463764, 0.14897841550463764, 0.14897841550463764, 0.1030688371600671, 0.1030688371600671, 0.1030688371600671, 0.10144997830769575, 0.10144997830769575, 0.10144997830769575, 0.07335963498835119, 0.07335963498835119, 0.07335963498835119, 0.10497721724037712, 0.10497721724037712, 0.10497721724037712, 0.07827782974490949, 0.07827782974490949, 0.07827782974490949, 0.11391201673386253, 0.11391201673386253, 0.11391201673386253, 0.4725902820771418, 0.4725902820771418, 0.4725902820771418, 0.47915349428922316, 0.47915349428922316, 0.47915349428922316, 0.5318638176854871, 0.5318638176854871, 0.5318638176854871, 0.09003916410608404, 0.09003916410608404, 0.09003916410608404, 0.12352269486187428, 0.12352269486187428, 0.12352269486187428, 0.14993517708887905, 0.14993517708887905, 0.14993517708887905, 0.18793602097145767, 0.18793602097145767, 0.18793602097145767, 0.1865918501075985, 0.1865918501075985, 0.1865918501075985, 0.18124432203886998, 0.18124432203886998, 0.18124432203886998, 0.2031351238439142, 0.2031351238439142, 0.2031351238439142, 0.19099265072019145, 0.19099265072019145, 0.19099265072019145, 0.2374187630472916, 0.2374187630472916, 0.2374187630472916, 0.15489135755000938, 0.15489135755000938, 0.15489135755000938, 0.2053295078670453, 0.2053295078670453, 0.2053295078670453, 0.22210788789380387, 0.22210788789380387, 0.22210788789380387, 0.23804135907991286, 0.23804135907991286, 0.23804135907991286, 0.2255728477061587, 0.2255728477061587, 0.2255728477061587, 0.24763788709890322, 0.24763788709890322, 0.24763788709890322, 0.1801741655827962, 0.1801741655827962, 0.1801741655827962, 0.1923930333630065, 0.1923930333630065, 0.1923930333630065, 0.19051397139625137, 0.19051397139625137, 0.19051397139625137, 0.12543988835599285, 0.12543988835599285, 0.12543988835599285, 0.836443580040455, 0.836443580040455, 0.836443580040455, 0.14189406102156554, 0.14189406102156554, 0.14189406102156554, 0.5534244060188072, 0.5534244060188072, 0.5534244060188072, 0.16583765847157905, 0.16583765847157905, 0.16583765847157905, 0.5239091589579309, 0.5239091589579309, 0.5239091589579309, 0.1940776278800901, 0.1940776278800901, 0.1940776278800901, 0.22054239668915365, 0.22054239668915365, 0.22054239668915365, 0.1949337439178166, 0.1949337439178166, 0.1949337439178166, 0.07016622389481031, 0.07016622389481031, 0.07016622389481031, 0.0849681372181107, 0.0849681372181107, 0.0849681372181107, 0.0853706955124609, 0.0853706955124609, 0.0853706955124609]}, "mutation_prompt": null}
{"id": "0815dfb8-a911-462a-8364-05f29cae9edd", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased the number of particles for broader exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.85\n        self.w_min = 0.2  # Reduced inertia weight for stronger exploitation\n        self.c1_initial = 1.8  # Adjusted cognitive factor for better personal best influence\n        self.c2_initial = 1.7\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Enhanced social factor to improve global best attraction\n        self.velocity_clamp = 0.4  # Adjusted velocity clamp to control excessive movements\n        self.local_search_probability = 0.15  # Increased probability for local search exploration\n\n    def __call__(self, func):\n        np.random.seed(42)  # Changed seed for potential different random exploration\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)  # Adjusted perturbation for more effective local search\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_pso = HybridAdaptivePSO(budget=10000, dim=10)\n# hybrid_pso(func)", "name": "HybridAdaptivePSO", "description": "A hybrid Particle Swarm Optimization with adaptive parameters and a refined local search mechanism to enhance exploration and accelerate convergence.", "configspace": "", "generation": 57, "fitness": 0.28948126251065415, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7501224350241154, 0.7501224350241154, 0.7501224350241154, 0.7352056112632757, 0.7352056112632757, 0.7352056112632757, 0.7380795832643584, 0.7380795832643584, 0.7380795832643584, 0.40594816547858104, 0.40594816547858104, 0.40594816547858104, 0.40357959840709323, 0.40357959840709323, 0.40357959840709323, 0.41506468540796126, 0.41506468540796126, 0.41506468540796126, 0.1139735276479138, 0.1139735276479138, 0.1139735276479138, 0.11179250520163664, 0.11179250520163664, 0.11179250520163664, 0.13783809533645508, 0.13783809533645508, 0.13783809533645508, 0.10504836889721314, 0.10504836889721314, 0.10504836889721314, 0.10998455818907826, 0.10998455818907826, 0.10998455818907826, 0.08452135102874725, 0.08452135102874725, 0.08452135102874725, 0.7973026156912408, 0.7973026156912408, 0.7973026156912408, 0.7975357749053942, 0.7975357749053942, 0.7975357749053942, 0.8131302185319897, 0.8131302185319897, 0.8131302185319897, 0.45485485420445604, 0.45485485420445604, 0.45485485420445604, 0.4871530571484193, 0.4871530571484193, 0.4871530571484193, 0.43199436955782344, 0.43199436955782344, 0.43199436955782344, 0.16587825122692723, 0.16587825122692723, 0.16587825122692723, 0.20969801582319103, 0.20969801582319103, 0.20969801582319103, 0.67253352162458, 0.67253352162458, 0.67253352162458, 0.18997342760229963, 0.18997342760229963, 0.18997342760229963, 0.4246901668478853, 0.4246901668478853, 0.4246901668478853, 0.12660367840517917, 0.12660367840517917, 0.12660367840517917, 0.11429222259986949, 0.11429222259986949, 0.11429222259986949, 0.18512653250281874, 0.18512653250281874, 0.18512653250281874, 0.21000761793777434, 0.21000761793777434, 0.21000761793777434, 0.007887292101699694, 0.007887292101699694, 0.007887292101699694, 0.0047042243296294695, 0.0047042243296294695, 0.0047042243296294695, 0.07081568472229816, 0.07081568472229816, 0.07081568472229816, 0.12350028331331653, 0.12350028331331653, 0.12350028331331653, 0.09741923083109683, 0.09741923083109683, 0.09741923083109683, 0.18601436687463813, 0.18601436687463813, 0.18601436687463813, 0.04171926893274991, 0.04171926893274991, 0.04171926893274991, 0.09400379286570637, 0.09400379286570637, 0.09400379286570637, 0.16422464994640795, 0.16422464994640795, 0.16422464994640795, 0.09082970416868197, 0.09082970416868197, 0.09082970416868197, 0.04272985937567286, 0.04272985937567286, 0.04272985937567286, 0.19051337288122938, 0.19051337288122938, 0.19051337288122938, 0.49482208729243715, 0.49482208729243715, 0.49482208729243715, 0.5041411777239415, 0.5041411777239415, 0.5041411777239415, 0.4880793195079203, 0.4880793195079203, 0.4880793195079203, 0.07780515909377883, 0.07780515909377883, 0.07780515909377883, 0.06982494315747045, 0.06982494315747045, 0.06982494315747045, 0.09527616583550802, 0.09527616583550802, 0.09527616583550802, 0.17981853271237502, 0.17981853271237502, 0.17981853271237502, 0.34962976013489755, 0.34962976013489755, 0.34962976013489755, 0.2735544599177647, 0.2735544599177647, 0.2735544599177647, 0.4567473157358155, 0.4567473157358155, 0.4567473157358155, 0.2819635591638774, 0.2819635591638774, 0.2819635591638774, 0.26368510047025484, 0.26368510047025484, 0.26368510047025484, 0.2040180344108884, 0.2040180344108884, 0.2040180344108884, 0.17312429531592555, 0.17312429531592555, 0.17312429531592555, 0.16068878459168012, 0.16068878459168012, 0.16068878459168012, 0.216440742444726, 0.216440742444726, 0.216440742444726, 0.21395140294351467, 0.21395140294351467, 0.21395140294351467, 0.24401544623938076, 0.24401544623938076, 0.24401544623938076, 0.18528016556197047, 0.18528016556197047, 0.18528016556197047, 0.1835528738905845, 0.1835528738905845, 0.1835528738905845, 0.1725866702098383, 0.1725866702098383, 0.1725866702098383, 0.8433033237732339, 0.8433033237732339, 0.8433033237732339, 0.16300339155327148, 0.16300339155327148, 0.16300339155327148, 0.8318186925471368, 0.8318186925471368, 0.8318186925471368, 0.5232882954447333, 0.5232882954447333, 0.5232882954447333, 0.20984206377672254, 0.20984206377672254, 0.20984206377672254, 0.6979558391774309, 0.6979558391774309, 0.6979558391774309, 0.19773970114336903, 0.19773970114336903, 0.19773970114336903, 0.248944318726805, 0.248944318726805, 0.248944318726805, 0.20595043163281046, 0.20595043163281046, 0.20595043163281046, 0.08937300702499174, 0.08937300702499174, 0.08937300702499174, 0.09921901845272474, 0.09921901845272474, 0.09921901845272474, 0.13691228105991138, 0.13691228105991138, 0.13691228105991138]}, "mutation_prompt": null}
{"id": "07dd5306-4130-4351-8c63-1074eb21e2bf", "solution": "import numpy as np\n\nclass HybridDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased the number of particles for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_initial = 0.9\n        self.w_final = 0.4  # Changed inertia range for balance\n        self.c1_initial = 2.5  # Adjusted cognitive factor to balance exploration\n        self.c1_final = 1.5\n        self.c2_initial = 1.0\n        self.c2_final = 2.5  # Increased social factor to enhance convergence\n        self.velocity_clamp = 0.6  # Fine-tuned velocity clamping\n        self.local_search_probability = 0.15  # Increased probability to perform local search based on progress\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_initial - ((self.w_initial - self.w_final) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1 * inertia_weight, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# hybrid_dynamic_pso = HybridDynamicPSO(budget=10000, dim=10)\n# hybrid_dynamic_pso(func)", "name": "HybridDynamicPSO", "description": "A hybrid Particle Swarm Optimization with dynamic inertia adjustment and adaptive local search based on convergence rate to enhance global optimization performance.", "configspace": "", "generation": 58, "fitness": 0.2905671778635255, "feedback": "The algorithm HybridDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6810298224850229, 0.6810298224850229, 0.6810298224850229, 0.6679887338093604, 0.6679887338093604, 0.6679887338093604, 0.6450431926840685, 0.6450431926840685, 0.6450431926840685, 0.27029632278840576, 0.27029632278840576, 0.27029632278840576, 0.2822114403340621, 0.2822114403340621, 0.2822114403340621, 0.30459674022997796, 0.30459674022997796, 0.30459674022997796, 0.1363591860940747, 0.1363591860940747, 0.1363591860940747, 0.11416748824227219, 0.11416748824227219, 0.11416748824227219, 0.14493544821578375, 0.14493544821578375, 0.14493544821578375, 0.08737963469245347, 0.08737963469245347, 0.08737963469245347, 0.10296208727426603, 0.10296208727426603, 0.10296208727426603, 0.10929162850715624, 0.10929162850715624, 0.10929162850715624, 0.8879079845313419, 0.8879079845313419, 0.8879079845313419, 0.8905491224242132, 0.8905491224242132, 0.8905491224242132, 0.8961354526737556, 0.8961354526737556, 0.8961354526737556, 0.39052179033252077, 0.39052179033252077, 0.39052179033252077, 0.38872671289700633, 0.38872671289700633, 0.38872671289700633, 0.3455466937720354, 0.3455466937720354, 0.3455466937720354, 0.7017328840481858, 0.7017328840481858, 0.7017328840481858, 0.27231721189599867, 0.27231721189599867, 0.27231721189599867, 0.2242703667385041, 0.2242703667385041, 0.2242703667385041, 0.18230943352571483, 0.18230943352571483, 0.18230943352571483, 0.17163673692604242, 0.17163673692604242, 0.17163673692604242, 0.18216572479180182, 0.18216572479180182, 0.18216572479180182, 0.17655093437312175, 0.17655093437312175, 0.17655093437312175, 0.2615004385391767, 0.2615004385391767, 0.2615004385391767, 0.16330276310967295, 0.16330276310967295, 0.16330276310967295, 0.03556529374303352, 0.03556529374303352, 0.03556529374303352, 0.05064127869897095, 0.05064127869897095, 0.05064127869897095, 0.06213682171072066, 0.06213682171072066, 0.06213682171072066, 0.11469322470200527, 0.11469322470200527, 0.11469322470200527, 0.11349322548967633, 0.11349322548967633, 0.11349322548967633, 0.13412384678143174, 0.13412384678143174, 0.13412384678143174, 0.14654776276500248, 0.14654776276500248, 0.14654776276500248, 0.0992303138817735, 0.0992303138817735, 0.0992303138817735, 0.07637080292562792, 0.07637080292562792, 0.07637080292562792, 0.2256272736139434, 0.2256272736139434, 0.2256272736139434, 0.0757619911261076, 0.0757619911261076, 0.0757619911261076, 0.14887534753032783, 0.14887534753032783, 0.14887534753032783, 0.4514727717133633, 0.4514727717133633, 0.4514727717133633, 0.5113380008500558, 0.5113380008500558, 0.5113380008500558, 0.48922578589314747, 0.48922578589314747, 0.48922578589314747, 0.12090779163329257, 0.12090779163329257, 0.12090779163329257, 0.12179696669224926, 0.12179696669224926, 0.12179696669224926, 0.12528875489700186, 0.12528875489700186, 0.12528875489700186, 0.22614951243877546, 0.22614951243877546, 0.22614951243877546, 0.25832592271285126, 0.25832592271285126, 0.25832592271285126, 0.24236257714958287, 0.24236257714958287, 0.24236257714958287, 0.3486610577087351, 0.3486610577087351, 0.3486610577087351, 0.34411978832074364, 0.34411978832074364, 0.34411978832074364, 0.3462606458306423, 0.3462606458306423, 0.3462606458306423, 0.1911376363267947, 0.1911376363267947, 0.1911376363267947, 0.2289680669868921, 0.2289680669868921, 0.2289680669868921, 0.20853641201400408, 0.20853641201400408, 0.20853641201400408, 0.22789050838540192, 0.22789050838540192, 0.22789050838540192, 0.2318610789333908, 0.2318610789333908, 0.2318610789333908, 0.2414364701828734, 0.2414364701828734, 0.2414364701828734, 0.21352915552877227, 0.21352915552877227, 0.21352915552877227, 0.4297648243251163, 0.4297648243251163, 0.4297648243251163, 0.2354248763553657, 0.2354248763553657, 0.2354248763553657, 0.7837608928349993, 0.7837608928349993, 0.7837608928349993, 0.8167667500419585, 0.8167667500419585, 0.8167667500419585, 0.1415667798077508, 0.1415667798077508, 0.1415667798077508, 0.7228928153560186, 0.7228928153560186, 0.7228928153560186, 0.20856147656536794, 0.20856147656536794, 0.20856147656536794, 0.5830005267250631, 0.5830005267250631, 0.5830005267250631, 0.19629208722092872, 0.19629208722092872, 0.19629208722092872, 0.18753238918150084, 0.18753238918150084, 0.18753238918150084, 0.2005533603453764, 0.2005533603453764, 0.2005533603453764, 0.09666261268266263, 0.09666261268266263, 0.09666261268266263, 0.09858977882707476, 0.09858977882707476, 0.09858977882707476, 0.1256955728014616, 0.1256955728014616, 0.1256955728014616]}, "mutation_prompt": null}
{"id": "325c5cb2-9caf-4a91-a99c-ecd59a9cf8b5", "solution": "import numpy as np\n\nclass ImprovedHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased the number of particles for enhanced diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.85  # Slightly decreased the maximum inertia weight for better control\n        self.w_min = 0.4  # Increased minimum inertia weight to maintain diversity\n        self.c1_initial = 1.8  # Adjusted cognitive factor to encourage personal exploration\n        self.c2_initial = 1.7\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Increased social factor for stronger convergence\n        self.velocity_clamp = 0.6  # Fine-tuned velocity clamping for stability\n        self.local_search_probability = 0.15  # Increased probability for local searches\n        self.levy_exponent = 1.5  # Exponent factor for Lévy flight distribution\n\n    def levy_flight(self, size):\n        return np.random.standard_normal(size) / np.power(np.random.standard_normal(size), 1 / self.levy_exponent)\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = self.levy_flight(self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# improved_pso = ImprovedHybridPSO(budget=10000, dim=10)\n# improved_pso(func)", "name": "ImprovedHybridPSO", "description": "An improved Hybrid Particle Swarm Optimization with adaptive learning rates, enhanced local search, and Lévy flight perturbations for robust convergence across varied optimization landscapes.", "configspace": "", "generation": 59, "fitness": 0.2941878837142562, "feedback": "The algorithm ImprovedHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.24.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7456590903154893, 0.7456590903154893, 0.7456590903154893, 0.743407819488409, 0.743407819488409, 0.743407819488409, 0.742970602157726, 0.742970602157726, 0.742970602157726, 0.41574252753484064, 0.41574252753484064, 0.41574252753484064, 0.34693833485372283, 0.34693833485372283, 0.34693833485372283, 0.41367699781069367, 0.41367699781069367, 0.41367699781069367, 0.12978278594537973, 0.12978278594537973, 0.12978278594537973, 0.11706320601763887, 0.11706320601763887, 0.11706320601763887, 0.11053211090680326, 0.11053211090680326, 0.11053211090680326, 0.07690223801764628, 0.07690223801764628, 0.07690223801764628, 0.12750332191222935, 0.12750332191222935, 0.12750332191222935, 0.1383149645712134, 0.1383149645712134, 0.1383149645712134, 0.9130611144085188, 0.9130611144085188, 0.9130611144085188, 0.9147624625111032, 0.9147624625111032, 0.9147624625111032, 0.9046730674076122, 0.9046730674076122, 0.9046730674076122, 0.4838193559054108, 0.4838193559054108, 0.4838193559054108, 0.44886934436296444, 0.44886934436296444, 0.44886934436296444, 0.43007060251286255, 0.43007060251286255, 0.43007060251286255, 0.22733680290053648, 0.22733680290053648, 0.22733680290053648, 0.2683340085061141, 0.2683340085061141, 0.2683340085061141, 0.1763352825418273, 0.1763352825418273, 0.1763352825418273, 0.1891231915792171, 0.1891231915792171, 0.1891231915792171, 0.18258073737018432, 0.18258073737018432, 0.18258073737018432, 0.25798561592130864, 0.25798561592130864, 0.25798561592130864, 0.20321673735205503, 0.20321673735205503, 0.20321673735205503, 0.1874996511987579, 0.1874996511987579, 0.1874996511987579, 0.22828257297208243, 0.22828257297208243, 0.22828257297208243, 0.010747504157651244, 0.010747504157651244, 0.010747504157651244, 0.06404710905846767, 0.06404710905846767, 0.06404710905846767, 0.022508434276263478, 0.022508434276263478, 0.022508434276263478, 0.06161308823349354, 0.06161308823349354, 0.06161308823349354, 0.05842714450753461, 0.05842714450753461, 0.05842714450753461, 0.10058607333499203, 0.10058607333499203, 0.10058607333499203, 0.11302114739507796, 0.11302114739507796, 0.11302114739507796, 0.09940681799098416, 0.09940681799098416, 0.09940681799098416, 0.0720930259651883, 0.0720930259651883, 0.0720930259651883, 0.12502119819465118, 0.12502119819465118, 0.12502119819465118, 0.120648681933338, 0.120648681933338, 0.120648681933338, 0.1375553250864836, 0.1375553250864836, 0.1375553250864836, 0.48512311148630916, 0.48512311148630916, 0.48512311148630916, 0.5146422266035968, 0.5146422266035968, 0.5146422266035968, 0.5124293300105763, 0.5124293300105763, 0.5124293300105763, 0.1185838377035765, 0.1185838377035765, 0.1185838377035765, 0.15227293048952628, 0.15227293048952628, 0.15227293048952628, 0.08051718175192579, 0.08051718175192579, 0.08051718175192579, 0.3008578934764743, 0.3008578934764743, 0.3008578934764743, 0.364369142376209, 0.364369142376209, 0.364369142376209, 0.4061478379221578, 0.4061478379221578, 0.4061478379221578, 0.2891383939095684, 0.2891383939095684, 0.2891383939095684, 0.3706192808121117, 0.3706192808121117, 0.3706192808121117, 0.2701303355675082, 0.2701303355675082, 0.2701303355675082, 0.2576027782014392, 0.2576027782014392, 0.2576027782014392, 0.2991471066991179, 0.2991471066991179, 0.2991471066991179, 0.29014998878856546, 0.29014998878856546, 0.29014998878856546, 0.23237569733347052, 0.23237569733347052, 0.23237569733347052, 0.21635548200094967, 0.21635548200094967, 0.21635548200094967, 0.24789370926154364, 0.24789370926154364, 0.24789370926154364, 0.1944486870024673, 0.1944486870024673, 0.1944486870024673, 0.17794928681878575, 0.17794928681878575, 0.17794928681878575, 0.19977080346593612, 0.19977080346593612, 0.19977080346593612, 0.8277790532549576, 0.8277790532549576, 0.8277790532549576, 0.8583552876981202, 0.8583552876981202, 0.8583552876981202, 0.1420029022410676, 0.1420029022410676, 0.1420029022410676, 0.5542096546290027, 0.5542096546290027, 0.5542096546290027, 0.20871517597317935, 0.20871517597317935, 0.20871517597317935, 0.7078099330135705, 0.7078099330135705, 0.7078099330135705, 0.17953905745293686, 0.17953905745293686, 0.17953905745293686, 0.1929160537699297, 0.1929160537699297, 0.1929160537699297, 0.19095247632597856, 0.19095247632597856, 0.19095247632597856, 0.07489903443184553, 0.07489903443184553, 0.07489903443184553, 0.06462373879891326, 0.06462373879891326, 0.06462373879891326, 0.08908012103865748, 0.08908012103865748, 0.08908012103865748]}, "mutation_prompt": null}
{"id": "7afe45dc-7663-4e05-9c8a-083884d7f7d0", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for diverse search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.2  # Reduced inertia weight for more aggressive convergence\n        self.c1_initial = 2.5  # Increased cognitive factor for improved personal exploration\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 2.5  # Balanced final social factor to prevent premature convergence\n        self.velocity_clamp = 0.6  # Adjusted velocity clamp for controlled movements\n        self.local_search_probability = 0.15  # Increased probability for local search\n        self.mutation_probability = 0.1  # Probability for differential mutation\n        self.mutation_factor = 0.5  # Mutation scaling factor\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                if np.random.rand() < self.mutation_probability:\n                    r1, r2, r3 = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[r1] + self.mutation_factor * (personal_best_positions[r2] - personal_best_positions[r3])\n                    mutant_vector = np.clip(mutant_vector, self.lower_bound, self.upper_bound)\n                    if func(mutant_vector) < func(personal_best_positions[i]):\n                        personal_best_positions[i] = mutant_vector\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "An adaptive Particle Swarm Algorithm integrating differential mutation for enhanced exploration and exploitation balance.", "configspace": "", "generation": 60, "fitness": 0.29157554978604466, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7060663357782295, 0.7060663357782295, 0.7060663357782295, 0.6723433922203275, 0.6723433922203275, 0.6723433922203275, 0.6847660805066805, 0.6847660805066805, 0.6847660805066805, 0.34098460729523705, 0.34098460729523705, 0.34098460729523705, 0.3680844058276701, 0.3680844058276701, 0.3680844058276701, 0.37747603083363623, 0.37747603083363623, 0.37747603083363623, 0.11921173311935285, 0.11921173311935285, 0.11921173311935285, 0.12085319271840544, 0.12085319271840544, 0.12085319271840544, 0.1463900941895495, 0.1463900941895495, 0.1463900941895495, 0.12659934856428867, 0.12659934856428867, 0.12659934856428867, 0.13417534732007697, 0.13417534732007697, 0.13417534732007697, 0.11762313872194141, 0.11762313872194141, 0.11762313872194141, 0.8635308501299627, 0.8635308501299627, 0.8635308501299627, 0.8507612458716692, 0.8507612458716692, 0.8507612458716692, 0.8625357032605165, 0.8625357032605165, 0.8625357032605165, 0.41312785584924727, 0.41312785584924727, 0.41312785584924727, 0.4273502350843531, 0.4273502350843531, 0.4273502350843531, 0.40200411579755224, 0.40200411579755224, 0.40200411579755224, 0.22629330187559804, 0.22629330187559804, 0.22629330187559804, 0.25972706272462953, 0.25972706272462953, 0.25972706272462953, 0.22167280529054112, 0.22167280529054112, 0.22167280529054112, 0.2329506093351742, 0.2329506093351742, 0.2329506093351742, 0.16968855199056254, 0.16968855199056254, 0.16968855199056254, 0.18384895739548657, 0.18384895739548657, 0.18384895739548657, 0.44911769926346845, 0.44911769926346845, 0.44911769926346845, 0.3005831298173466, 0.3005831298173466, 0.3005831298173466, 0.20582047598831055, 0.20582047598831055, 0.20582047598831055, 0.00011845804266463755, 0.00011845804266463755, 0.00011845804266463755, 0.054335316314820914, 0.054335316314820914, 0.054335316314820914, 0.02192832591606353, 0.02192832591606353, 0.02192832591606353, 0.14093300999037162, 0.14093300999037162, 0.14093300999037162, 0.08080310293517301, 0.08080310293517301, 0.08080310293517301, 0.15506336936470888, 0.15506336936470888, 0.15506336936470888, 0.2239224982110659, 0.2239224982110659, 0.2239224982110659, 0.04833211086123956, 0.04833211086123956, 0.04833211086123956, 0.06878885074650098, 0.06878885074650098, 0.06878885074650098, 0.1897770636984123, 0.1897770636984123, 0.1897770636984123, 0.08365370916289216, 0.08365370916289216, 0.08365370916289216, 0.10404687821952141, 0.10404687821952141, 0.10404687821952141, 0.5508033564812288, 0.5508033564812288, 0.5508033564812288, 0.4839691923666125, 0.4839691923666125, 0.4839691923666125, 0.4848276522471996, 0.4848276522471996, 0.4848276522471996, 0.12205462473407702, 0.12205462473407702, 0.12205462473407702, 0.10014272677923564, 0.10014272677923564, 0.10014272677923564, 0.10821079266546463, 0.10821079266546463, 0.10821079266546463, 0.3670335522466305, 0.3670335522466305, 0.3670335522466305, 0.18864803641449923, 0.18864803641449923, 0.18864803641449923, 0.1720232691059519, 0.1720232691059519, 0.1720232691059519, 0.34331832403835927, 0.34331832403835927, 0.34331832403835927, 0.34182976308417035, 0.34182976308417035, 0.34182976308417035, 0.3887052730919117, 0.3887052730919117, 0.3887052730919117, 0.28850767084289786, 0.28850767084289786, 0.28850767084289786, 0.22423387342447776, 0.22423387342447776, 0.22423387342447776, 0.2128358150862807, 0.2128358150862807, 0.2128358150862807, 0.2410054228525712, 0.2410054228525712, 0.2410054228525712, 0.23253284966149168, 0.23253284966149168, 0.23253284966149168, 0.22674739093665264, 0.22674739093665264, 0.22674739093665264, 0.19345041830825171, 0.19345041830825171, 0.19345041830825171, 0.2206574046280294, 0.2206574046280294, 0.2206574046280294, 0.19570096520235947, 0.19570096520235947, 0.19570096520235947, 0.7931074603170264, 0.7931074603170264, 0.7931074603170264, 0.8064726250006907, 0.8064726250006907, 0.8064726250006907, 0.15240277740468833, 0.15240277740468833, 0.15240277740468833, 0.7494107957289575, 0.7494107957289575, 0.7494107957289575, 0.20650902562630458, 0.20650902562630458, 0.20650902562630458, 0.596482986582511, 0.596482986582511, 0.596482986582511, 0.18694083369672598, 0.18694083369672598, 0.18694083369672598, 0.21531215348140775, 0.21531215348140775, 0.21531215348140775, 0.19508686845940293, 0.19508686845940293, 0.19508686845940293, 0.08342293040152604, 0.08342293040152604, 0.08342293040152604, 0.08415770781377474, 0.08415770781377474, 0.08415770781377474, 0.08160604565059892, 0.08160604565059892, 0.08160604565059892]}, "mutation_prompt": null}
{"id": "50f10ea3-1569-4ef3-9d44-8d7a65d6f5e9", "solution": "import numpy as np\nfrom scipy.stats import levy\n\nclass LevyPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased particles for better coverage\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4  # Increased minimum inertia weight to keep particles dynamic\n        self.c1_initial = 1.5  # Balanced cognitive factor for personal exploration\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Higher final social factor to focus towards the global best\n        self.velocity_clamp = 0.6  # Enhanced velocity clamping to allow more movement\n        self.levy_search_probability = 0.15  # Levy flight local search probability\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.levy_search_probability:\n                    levy_step = levy.rvs(size=self.dim)\n                    candidate_position = positions[i] + levy_step\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# levy_pso = LevyPSO(budget=10000, dim=10)\n# levy_pso(func)", "name": "LevyPSO", "description": "A variant of Particle Swarm Optimization with dynamic learning factors and a Levy flight-based local search for enhanced exploration and exploitation balance.", "configspace": "", "generation": 61, "fitness": 0.28622936501296503, "feedback": "The algorithm LevyPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6784435998721925, 0.6784435998721925, 0.6784435998721925, 0.6978912609582858, 0.6978912609582858, 0.6978912609582858, 0.6940301078978842, 0.6940301078978842, 0.6940301078978842, 0.3578956981346889, 0.3578956981346889, 0.3578956981346889, 0.2875980524716302, 0.2875980524716302, 0.2875980524716302, 0.2581602455628156, 0.2581602455628156, 0.2581602455628156, 0.13736807363277803, 0.13736807363277803, 0.13736807363277803, 0.15738299425603308, 0.15738299425603308, 0.15738299425603308, 0.10767193021207766, 0.10767193021207766, 0.10767193021207766, 0.16265805812630185, 0.16265805812630185, 0.16265805812630185, 0.11101538959615953, 0.11101538959615953, 0.11101538959615953, 0.14343688769221374, 0.14343688769221374, 0.14343688769221374, 0.9093914841091646, 0.9093914841091646, 0.9093914841091646, 0.8774428320767357, 0.8774428320767357, 0.8774428320767357, 0.8900773782585432, 0.8900773782585432, 0.8900773782585432, 0.44201997835160334, 0.44201997835160334, 0.44201997835160334, 0.4430109312104602, 0.4430109312104602, 0.4430109312104602, 0.38289014891992623, 0.38289014891992623, 0.38289014891992623, 0.754454652936016, 0.754454652936016, 0.754454652936016, 0.27548453677675366, 0.27548453677675366, 0.27548453677675366, 0.1729152392540585, 0.1729152392540585, 0.1729152392540585, 0.19087532916438643, 0.19087532916438643, 0.19087532916438643, 0.16768325047942179, 0.16768325047942179, 0.16768325047942179, 0.17020926700110828, 0.17020926700110828, 0.17020926700110828, 0.1744079710119889, 0.1744079710119889, 0.1744079710119889, 0.18742774984778776, 0.18742774984778776, 0.18742774984778776, 0.17166179554814387, 0.17166179554814387, 0.17166179554814387, 0.010485421714954812, 0.010485421714954812, 0.010485421714954812, 0.030119200307256677, 0.030119200307256677, 0.030119200307256677, 0.08609453452692817, 0.08609453452692817, 0.08609453452692817, 0.13239131933089443, 0.13239131933089443, 0.13239131933089443, 0.07360735540590435, 0.07360735540590435, 0.07360735540590435, 0.09372216107732789, 0.09372216107732789, 0.09372216107732789, 0.19941913134843603, 0.19941913134843603, 0.19941913134843603, 0.09668589618576895, 0.09668589618576895, 0.09668589618576895, 0.08716804876115969, 0.08716804876115969, 0.08716804876115969, 0.10049435268822504, 0.10049435268822504, 0.10049435268822504, 0.17962000731581396, 0.17962000731581396, 0.17962000731581396, 0.23860480420301478, 0.23860480420301478, 0.23860480420301478, 0.5008017925888111, 0.5008017925888111, 0.5008017925888111, 0.5227863476413352, 0.5227863476413352, 0.5227863476413352, 0.531559158909512, 0.531559158909512, 0.531559158909512, 0.12175992336832875, 0.12175992336832875, 0.12175992336832875, 0.12502485073307212, 0.12502485073307212, 0.12502485073307212, 0.13288577195540585, 0.13288577195540585, 0.13288577195540585, 0.20032628539225517, 0.20032628539225517, 0.20032628539225517, 0.23451120963748995, 0.23451120963748995, 0.23451120963748995, 0.266620744034733, 0.266620744034733, 0.266620744034733, 0.3184411205586074, 0.3184411205586074, 0.3184411205586074, 0.35106791798148373, 0.35106791798148373, 0.35106791798148373, 0.3826463078920911, 0.3826463078920911, 0.3826463078920911, 0.3070420350648332, 0.3070420350648332, 0.3070420350648332, 0.3392853166090313, 0.3392853166090313, 0.3392853166090313, 0.2254395278356437, 0.2254395278356437, 0.2254395278356437, 0.20921254125436028, 0.20921254125436028, 0.20921254125436028, 0.24851955712666474, 0.24851955712666474, 0.24851955712666474, 0.2278065643630035, 0.2278065643630035, 0.2278065643630035, 0.20079461276396782, 0.20079461276396782, 0.20079461276396782, 0.19661678414677775, 0.19661678414677775, 0.19661678414677775, 0.1788638641377076, 0.1788638641377076, 0.1788638641377076, 0.17426192981540134, 0.17426192981540134, 0.17426192981540134, 0.8328931997061328, 0.8328931997061328, 0.8328931997061328, 0.1420219182394158, 0.1420219182394158, 0.1420219182394158, 0.5717670065000986, 0.5717670065000986, 0.5717670065000986, 0.16655164117018462, 0.16655164117018462, 0.16655164117018462, 0.7140791261986901, 0.7140791261986901, 0.7140791261986901, 0.19279241549412274, 0.19279241549412274, 0.19279241549412274, 0.18081020381198287, 0.18081020381198287, 0.18081020381198287, 0.2024973788260317, 0.2024973788260317, 0.2024973788260317, 0.10633952027542859, 0.10633952027542859, 0.10633952027542859, 0.09202093516702647, 0.09202093516702647, 0.09202093516702647, 0.07854969550900659, 0.07854969550900659, 0.07854969550900659]}, "mutation_prompt": null}
{"id": "4db22fb3-6207-4796-8b99-5222823662e0", "solution": "import numpy as np\n\nclass ReinforcedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased the number of particles for improved exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Further decreased minimum inertia weight for stronger exploitation\n        self.c1_initial = 2.0\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Further increased social factor to strengthen convergence towards the global best\n        self.velocity_clamp = 0.6  # Adjusted velocity clamping for better stability\n        self.mutation_probability = 0.15  # Probability to introduce random mutation\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.mutation_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# reinforced_pso = ReinforcedAdaptivePSO(budget=10000, dim=10)\n# reinforced_pso(func)", "name": "ReinforcedAdaptivePSO", "description": "A Reinforced Adaptive PSO with dynamic inertia and mutation-influenced local search to enhance convergence and diversity.", "configspace": "", "generation": 62, "fitness": 0.30580766432249873, "feedback": "The algorithm ReinforcedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7092170762689434, 0.7092170762689434, 0.7092170762689434, 0.7043466682270357, 0.7043466682270357, 0.7043466682270357, 0.6966734594681849, 0.6966734594681849, 0.6966734594681849, 0.39964481944424035, 0.39964481944424035, 0.39964481944424035, 0.42741810404105396, 0.42741810404105396, 0.42741810404105396, 0.4055655733668787, 0.4055655733668787, 0.4055655733668787, 0.14748035424636052, 0.14748035424636052, 0.14748035424636052, 0.1615417458318099, 0.1615417458318099, 0.1615417458318099, 0.11567209660217304, 0.11567209660217304, 0.11567209660217304, 0.11208655310696503, 0.11208655310696503, 0.11208655310696503, 0.10967884892715007, 0.10967884892715007, 0.10967884892715007, 0.1379404561159594, 0.1379404561159594, 0.1379404561159594, 0.8890741680437548, 0.8890741680437548, 0.8890741680437548, 0.8782933925817136, 0.8782933925817136, 0.8782933925817136, 0.901710152759436, 0.901710152759436, 0.901710152759436, 0.46611044060104556, 0.46611044060104556, 0.46611044060104556, 0.4541654449792759, 0.4541654449792759, 0.4541654449792759, 0.45729143617917123, 0.45729143617917123, 0.45729143617917123, 0.22719000058399175, 0.22719000058399175, 0.22719000058399175, 0.2761644463062456, 0.2761644463062456, 0.2761644463062456, 0.17599356543296396, 0.17599356543296396, 0.17599356543296396, 0.18390501153433447, 0.18390501153433447, 0.18390501153433447, 0.35753988873587306, 0.35753988873587306, 0.35753988873587306, 0.1758878530177559, 0.1758878530177559, 0.1758878530177559, 0.2019674375760473, 0.2019674375760473, 0.2019674375760473, 0.18110821200413474, 0.18110821200413474, 0.18110821200413474, 0.184011214661856, 0.184011214661856, 0.184011214661856, 0.06195180696881131, 0.06195180696881131, 0.06195180696881131, 0.04840433458751636, 0.04840433458751636, 0.04840433458751636, 0.08304894064407431, 0.08304894064407431, 0.08304894064407431, 0.1256534708979743, 0.1256534708979743, 0.1256534708979743, 0.09805596682428064, 0.09805596682428064, 0.09805596682428064, 0.1200939918457169, 0.1200939918457169, 0.1200939918457169, 0.15023415948957386, 0.15023415948957386, 0.15023415948957386, 0.08632713221319843, 0.08632713221319843, 0.08632713221319843, 0.09440636572017591, 0.09440636572017591, 0.09440636572017591, 0.2828074014596563, 0.2828074014596563, 0.2828074014596563, 0.08958839825418996, 0.08958839825418996, 0.08958839825418996, 0.10993071711410884, 0.10993071711410884, 0.10993071711410884, 0.48870128500646515, 0.48870128500646515, 0.48870128500646515, 0.5072155718109843, 0.5072155718109843, 0.5072155718109843, 0.526610668765748, 0.526610668765748, 0.526610668765748, 0.0850641514801398, 0.0850641514801398, 0.0850641514801398, 0.12277206186867384, 0.12277206186867384, 0.12277206186867384, 0.13067528309922893, 0.13067528309922893, 0.13067528309922893, 0.29178215088092974, 0.29178215088092974, 0.29178215088092974, 0.18666723397888807, 0.18666723397888807, 0.18666723397888807, 0.40011309698603736, 0.40011309698603736, 0.40011309698603736, 0.3905279586521463, 0.3905279586521463, 0.3905279586521463, 0.40749688899782055, 0.40749688899782055, 0.40749688899782055, 0.23414994800436095, 0.23414994800436095, 0.23414994800436095, 0.2126201670572394, 0.2126201670572394, 0.2126201670572394, 0.32575499446353995, 0.32575499446353995, 0.32575499446353995, 0.22764641217395043, 0.22764641217395043, 0.22764641217395043, 0.2401236177089987, 0.2401236177089987, 0.2401236177089987, 0.2204697206621581, 0.2204697206621581, 0.2204697206621581, 0.2698404320426008, 0.2698404320426008, 0.2698404320426008, 0.4255197714655292, 0.4255197714655292, 0.4255197714655292, 0.5495959410489576, 0.5495959410489576, 0.5495959410489576, 0.1955172619261688, 0.1955172619261688, 0.1955172619261688, 0.8114024401781923, 0.8114024401781923, 0.8114024401781923, 0.8064236330239157, 0.8064236330239157, 0.8064236330239157, 0.14173509554134323, 0.14173509554134323, 0.14173509554134323, 0.6284043970201731, 0.6284043970201731, 0.6284043970201731, 0.20781457048969265, 0.20781457048969265, 0.20781457048969265, 0.6595874637662549, 0.6595874637662549, 0.6595874637662549, 0.1855187871092705, 0.1855187871092705, 0.1855187871092705, 0.1831596166247128, 0.1831596166247128, 0.1831596166247128, 0.17972623248005437, 0.17972623248005437, 0.17972623248005437, 0.10333637156792497, 0.10333637156792497, 0.10333637156792497, 0.0959823484450677, 0.0959823484450677, 0.0959823484450677, 0.08801515022910955, 0.08801515022910955, 0.08801515022910955]}, "mutation_prompt": null}
{"id": "85abe2f5-73dc-4f55-9c2d-54dcdd1293cc", "solution": "import numpy as np\n\nclass AdaptiveDynamicPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.85  # Adjusted inertia weight to balance exploration and exploitation\n        self.w_min = 0.25\n        self.c1_initial = 1.8  # Balanced cognitive factor for enhanced personal learning\n        self.c2_initial = 1.7\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Increased social factor for stronger convergence\n        self.velocity_clamp = 0.6  # Adjusted velocity clamping for controlled movement\n        self.local_search_probability = 0.15  # Increased probability for local search to maintain diversity\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)  # Increased perturbation for more exploration\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# adaptive_pso = AdaptiveDynamicPSO(budget=10000, dim=10)\n# adaptive_pso(func)", "name": "AdaptiveDynamicPSO", "description": "An adaptive Particle Swarm Optimization with dynamic velocity adjustment and diversity-enhanced local search to efficiently navigate complex optimization landscapes.", "configspace": "", "generation": 63, "fitness": 0.3080300532503503, "feedback": "The algorithm AdaptiveDynamicPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.712883069511377, 0.712883069511377, 0.712883069511377, 0.7500391137508134, 0.7500391137508134, 0.7500391137508134, 0.7294624107369161, 0.7294624107369161, 0.7294624107369161, 0.4338436505276225, 0.4338436505276225, 0.4338436505276225, 0.39359269571283895, 0.39359269571283895, 0.39359269571283895, 0.39254512216280457, 0.39254512216280457, 0.39254512216280457, 0.13173839800938136, 0.13173839800938136, 0.13173839800938136, 0.13889774048365466, 0.13889774048365466, 0.13889774048365466, 0.15471619866840325, 0.15471619866840325, 0.15471619866840325, 0.10078685596232406, 0.10078685596232406, 0.10078685596232406, 0.11023663398522021, 0.11023663398522021, 0.11023663398522021, 0.10962687022265849, 0.10962687022265849, 0.10962687022265849, 0.8943522659604511, 0.8943522659604511, 0.8943522659604511, 0.8837773444700536, 0.8837773444700536, 0.8837773444700536, 0.8964685619423196, 0.8964685619423196, 0.8964685619423196, 0.4777474197324576, 0.4777474197324576, 0.4777474197324576, 0.44632115710423803, 0.44632115710423803, 0.44632115710423803, 0.4337463527457438, 0.4337463527457438, 0.4337463527457438, 0.3712503336487082, 0.3712503336487082, 0.3712503336487082, 0.2784480336215309, 0.2784480336215309, 0.2784480336215309, 0.6601415961044865, 0.6601415961044865, 0.6601415961044865, 0.19110614642421087, 0.19110614642421087, 0.19110614642421087, 0.17513215285388872, 0.17513215285388872, 0.17513215285388872, 0.19018942331453625, 0.19018942331453625, 0.19018942331453625, 0.21878371006285402, 0.21878371006285402, 0.21878371006285402, 0.18400314711046595, 0.18400314711046595, 0.18400314711046595, 0.20772761546710383, 0.20772761546710383, 0.20772761546710383, 0.00617076016678908, 0.00617076016678908, 0.00617076016678908, 0.0029434377533520406, 0.0029434377533520406, 0.0029434377533520406, 0.0814163176019943, 0.0814163176019943, 0.0814163176019943, 0.14958496822438738, 0.14958496822438738, 0.14958496822438738, 0.09819720019295075, 0.09819720019295075, 0.09819720019295075, 0.09426098188321608, 0.09426098188321608, 0.09426098188321608, 0.1223146322200026, 0.1223146322200026, 0.1223146322200026, 0.10156238744106905, 0.10156238744106905, 0.10156238744106905, 0.14735873318222548, 0.14735873318222548, 0.14735873318222548, 0.2381400798612744, 0.2381400798612744, 0.2381400798612744, 0.05927980097943597, 0.05927980097943597, 0.05927980097943597, 0.19929952433687503, 0.19929952433687503, 0.19929952433687503, 0.506735277704808, 0.506735277704808, 0.506735277704808, 0.5111529431551272, 0.5111529431551272, 0.5111529431551272, 0.5341384774222322, 0.5341384774222322, 0.5341384774222322, 0.11360754603898682, 0.11360754603898682, 0.11360754603898682, 0.10276699154036129, 0.10276699154036129, 0.10276699154036129, 0.10923606319100365, 0.10923606319100365, 0.10923606319100365, 0.3817519136733867, 0.3817519136733867, 0.3817519136733867, 0.2605974903338292, 0.2605974903338292, 0.2605974903338292, 0.2729725685090362, 0.2729725685090362, 0.2729725685090362, 0.41225765687522087, 0.41225765687522087, 0.41225765687522087, 0.3704280425579244, 0.3704280425579244, 0.3704280425579244, 0.23782151309080368, 0.23782151309080368, 0.23782151309080368, 0.25935530145109253, 0.25935530145109253, 0.25935530145109253, 0.20950233146205133, 0.20950233146205133, 0.20950233146205133, 0.3257565127653812, 0.3257565127653812, 0.3257565127653812, 0.2780518367005421, 0.2780518367005421, 0.2780518367005421, 0.268628582135754, 0.268628582135754, 0.268628582135754, 0.26666950327478267, 0.26666950327478267, 0.26666950327478267, 0.2113864816846247, 0.2113864816846247, 0.2113864816846247, 0.2445563009034637, 0.2445563009034637, 0.2445563009034637, 0.19138665431354696, 0.19138665431354696, 0.19138665431354696, 0.8121584961674104, 0.8121584961674104, 0.8121584961674104, 0.8322921101614941, 0.8322921101614941, 0.8322921101614941, 0.14202498888709758, 0.14202498888709758, 0.14202498888709758, 0.6006163607549224, 0.6006163607549224, 0.6006163607549224, 0.20848634323676263, 0.20848634323676263, 0.20848634323676263, 0.6716096408033927, 0.6716096408033927, 0.6716096408033927, 0.18591766447850533, 0.18591766447850533, 0.18591766447850533, 0.1867245421150655, 0.1867245421150655, 0.1867245421150655, 0.2016600818331009, 0.2016600818331009, 0.2016600818331009, 0.0863978557934959, 0.0863978557934959, 0.0863978557934959, 0.09765024306169656, 0.09765024306169656, 0.09765024306169656, 0.11577267380768552, 0.11577267380768552, 0.11577267380768552]}, "mutation_prompt": null}
{"id": "6f0df055-a09c-4302-b130-2b009c19c58e", "solution": "import numpy as np\n\nclass MultiPhaseHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for enhanced exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Adjusted inertia weight for better balance between exploration and exploitation\n        self.w_min = 0.4\n        self.c1_initial = 2.2  # Enhanced cognitive factor for improved local search\n        self.c2_initial = 1.3\n        self.c1_final = 1.0\n        self.c2_final = 2.5  # Reduced social factor for improved convergence stability\n        self.velocity_clamp = 0.6  # Modified velocity clamping for flexible movement\n        self.local_search_probability = 0.15  # Higher probability for local search to assist exploitation\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        phase_switch_threshold = self.budget // 3  # Introduce phases based on budget\n        increase_local_search_after_phase = False\n\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            if evaluations > phase_switch_threshold:\n                increase_local_search_after_phase = True\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if increase_local_search_after_phase and np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)  # Reduced perturbation for precision\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# pso = MultiPhaseHybridPSO(budget=10000, dim=10)\n# pso(func)", "name": "MultiPhaseHybridPSO", "description": "A Multi-phase Hybrid Particle Swarm Optimization with adaptive velocity adjustment and periodic local search to enhance convergence and solution diversity.", "configspace": "", "generation": 64, "fitness": 0.2981472933556429, "feedback": "The algorithm MultiPhaseHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7653135865554394, 0.7653135865554394, 0.7653135865554394, 0.7606453047435722, 0.7606453047435722, 0.7606453047435722, 0.7756949995790203, 0.7756949995790203, 0.7756949995790203, 0.48322437103900473, 0.48322437103900473, 0.48322437103900473, 0.4656367703325329, 0.4656367703325329, 0.4656367703325329, 0.4841578532008619, 0.4841578532008619, 0.4841578532008619, 0.1628282830998372, 0.1628282830998372, 0.1628282830998372, 0.12076982420261007, 0.12076982420261007, 0.12076982420261007, 0.12585433585633676, 0.12585433585633676, 0.12585433585633676, 0.13866727599212214, 0.13866727599212214, 0.13866727599212214, 0.11091103191799323, 0.11091103191799323, 0.11091103191799323, 0.11120490423401974, 0.11120490423401974, 0.11120490423401974, 0.8813429856852449, 0.8813429856852449, 0.8813429856852449, 0.8975963111286737, 0.8975963111286737, 0.8975963111286737, 0.8799910188247733, 0.8799910188247733, 0.8799910188247733, 0.5114255527830243, 0.5114255527830243, 0.5114255527830243, 0.5433631398559895, 0.5433631398559895, 0.5433631398559895, 0.4802153389790754, 0.4802153389790754, 0.4802153389790754, 0.16730097634556662, 0.16730097634556662, 0.16730097634556662, 0.2765107871491551, 0.2765107871491551, 0.2765107871491551, 0.6222300687098177, 0.6222300687098177, 0.6222300687098177, 0.18973831261153584, 0.18973831261153584, 0.18973831261153584, 0.2094075865859465, 0.2094075865859465, 0.2094075865859465, 0.19102797509230962, 0.19102797509230962, 0.19102797509230962, 0.1284852547452181, 0.1284852547452181, 0.1284852547452181, 0.19373094664988233, 0.19373094664988233, 0.19373094664988233, 0.21141913395998368, 0.21141913395998368, 0.21141913395998368, 0.0832608762595548, 0.0832608762595548, 0.0832608762595548, 0.0015036398350691815, 0.0015036398350691815, 0.0015036398350691815, 0.07299792800476534, 0.07299792800476534, 0.07299792800476534, 0.10218299893098393, 0.10218299893098393, 0.10218299893098393, 0.056817357324384865, 0.056817357324384865, 0.056817357324384865, 0.15110060333196962, 0.15110060333196962, 0.15110060333196962, 0.040123796120568156, 0.040123796120568156, 0.040123796120568156, 0.10398066712032594, 0.10398066712032594, 0.10398066712032594, 0.2493648875272123, 0.2493648875272123, 0.2493648875272123, 0.11703009067367098, 0.11703009067367098, 0.11703009067367098, 0.0677830262661504, 0.0677830262661504, 0.0677830262661504, 0.16283436169705878, 0.16283436169705878, 0.16283436169705878, 0.5439566665989357, 0.5439566665989357, 0.5439566665989357, 0.5320066039387596, 0.5320066039387596, 0.5320066039387596, 0.5414737866838784, 0.5414737866838784, 0.5414737866838784, 0.10762620171667603, 0.10762620171667603, 0.10762620171667603, 0.08264529925613773, 0.08264529925613773, 0.08264529925613773, 0.09695591659745406, 0.09695591659745406, 0.09695591659745406, 0.2409558345382734, 0.2409558345382734, 0.2409558345382734, 0.23400503847938392, 0.23400503847938392, 0.23400503847938392, 0.18314835940629515, 0.18314835940629515, 0.18314835940629515, 0.3731679726540521, 0.3731679726540521, 0.3731679726540521, 0.47221638250369946, 0.47221638250369946, 0.47221638250369946, 0.3497118001470262, 0.3497118001470262, 0.3497118001470262, 0.24017249758978765, 0.24017249758978765, 0.24017249758978765, 0.24838306094036722, 0.24838306094036722, 0.24838306094036722, 0.15402815527254643, 0.15402815527254643, 0.15402815527254643, 0.22325625167520424, 0.22325625167520424, 0.22325625167520424, 0.22370464562856374, 0.22370464562856374, 0.22370464562856374, 0.2600394610863682, 0.2600394610863682, 0.2600394610863682, 0.20226467169286777, 0.20226467169286777, 0.20226467169286777, 0.18737351546489267, 0.18737351546489267, 0.18737351546489267, 0.20716477969375602, 0.20716477969375602, 0.20716477969375602, 0.8508222086210308, 0.8508222086210308, 0.8508222086210308, 0.16401642436511843, 0.16401642436511843, 0.16401642436511843, 0.1358786624742706, 0.1358786624742706, 0.1358786624742706, 0.6867980104056597, 0.6867980104056597, 0.6867980104056597, 0.21145816744995594, 0.21145816744995594, 0.21145816744995594, 0.6849611166917846, 0.6849611166917846, 0.6849611166917846, 0.20179603071007113, 0.20179603071007113, 0.20179603071007113, 0.1883582859020012, 0.1883582859020012, 0.1883582859020012, 0.20479769394056335, 0.20479769394056335, 0.20479769394056335, 0.09418223870943698, 0.09418223870943698, 0.09418223870943698, 0.08898077440837893, 0.08898077440837893, 0.08898077440837893, 0.15262444341182801, 0.15262444341182801, 0.15262444341182801]}, "mutation_prompt": null}
{"id": "8ca5462e-2ba2-4578-8835-cf21f66a4fdd", "solution": "import numpy as np\n\nclass MultiStrategyHybridPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased the number of particles for better diversity\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.2\n        self.c1_initial = 2.1\n        self.c2_initial = 1.7\n        self.c1_final = 1.3\n        self.c2_final = 3.0\n        self.velocity_clamp = 0.6\n        self.local_search_probability = 0.15  # Increased probability to leverage local search\n        self.leader_selection_prob = 0.2  # Probability of selecting a random leader\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-0.5, 0.5, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                if np.random.rand() < self.leader_selection_prob:\n                    random_leader = personal_best_positions[np.random.randint(self.num_particles)]\n                else:\n                    random_leader = global_best_position\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (random_leader - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# multi_strategy_pso = MultiStrategyHybridPSO(budget=10000, dim=10)\n# multi_strategy_pso(func)", "name": "MultiStrategyHybridPSO", "description": "A multi-strategy hybrid Particle Swarm Optimization incorporating dynamic neighborhood adjustment and differential leader selection for enhanced convergence and diversity maintenance.", "configspace": "", "generation": 65, "fitness": 0.266995204073592, "feedback": "The algorithm MultiStrategyHybridPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6423351673326021, 0.6423351673326021, 0.6423351673326021, 0.6165710952372759, 0.6165710952372759, 0.6165710952372759, 0.6211497644701076, 0.6211497644701076, 0.6211497644701076, 0.22436526247178346, 0.22436526247178346, 0.22436526247178346, 0.2755308832911074, 0.2755308832911074, 0.2755308832911074, 0.25646174386107734, 0.25646174386107734, 0.25646174386107734, 0.11324114666309537, 0.11324114666309537, 0.11324114666309537, 0.10779034881237626, 0.10779034881237626, 0.10779034881237626, 0.14755461679630355, 0.14755461679630355, 0.14755461679630355, 0.09446758037488323, 0.09446758037488323, 0.09446758037488323, 0.09626694092214771, 0.09626694092214771, 0.09626694092214771, 0.12055295079373496, 0.12055295079373496, 0.12055295079373496, 0.8514208597327455, 0.8514208597327455, 0.8514208597327455, 0.8687277005337373, 0.8687277005337373, 0.8687277005337373, 0.8627109276275094, 0.8627109276275094, 0.8627109276275094, 0.3159445234186241, 0.3159445234186241, 0.3159445234186241, 0.3388742130887141, 0.3388742130887141, 0.3388742130887141, 0.33684760897453137, 0.33684760897453137, 0.33684760897453137, 0.16571958704807044, 0.16571958704807044, 0.16571958704807044, 0.27016576042805496, 0.27016576042805496, 0.27016576042805496, 0.7051741383916552, 0.7051741383916552, 0.7051741383916552, 0.17864322664911303, 0.17864322664911303, 0.17864322664911303, 0.19803425973632838, 0.19803425973632838, 0.19803425973632838, 0.12057573176997372, 0.12057573176997372, 0.12057573176997372, 0.22989210274335492, 0.22989210274335492, 0.22989210274335492, 0.27769925061835976, 0.27769925061835976, 0.27769925061835976, 0.12545234447639653, 0.12545234447639653, 0.12545234447639653, 0.02427095078712249, 0.02427095078712249, 0.02427095078712249, 0.0460895956966908, 0.0460895956966908, 0.0460895956966908, 0.0006344952468810838, 0.0006344952468810838, 0.0006344952468810838, 0.08643403046506659, 0.08643403046506659, 0.08643403046506659, 0.048244494383528735, 0.048244494383528735, 0.048244494383528735, 0.10956056632203803, 0.10956056632203803, 0.10956056632203803, 0.027658264974670055, 0.027658264974670055, 0.027658264974670055, 0.03414498413961031, 0.03414498413961031, 0.03414498413961031, 0.05310325916062608, 0.05310325916062608, 0.05310325916062608, 0.14177761419178936, 0.14177761419178936, 0.14177761419178936, 0.13253215756681713, 0.13253215756681713, 0.13253215756681713, 0.10794468775618116, 0.10794468775618116, 0.10794468775618116, 0.4390903151261921, 0.4390903151261921, 0.4390903151261921, 0.4799284306887118, 0.4799284306887118, 0.4799284306887118, 0.4550892134700292, 0.4550892134700292, 0.4550892134700292, 0.08517584006500478, 0.08517584006500478, 0.08517584006500478, 0.07617181960504238, 0.07617181960504238, 0.07617181960504238, 0.14075316827151751, 0.14075316827151751, 0.14075316827151751, 0.22430635354808914, 0.22430635354808914, 0.22430635354808914, 0.23691702801298276, 0.23691702801298276, 0.23691702801298276, 0.22971473023472577, 0.22971473023472577, 0.22971473023472577, 0.3138075937663122, 0.3138075937663122, 0.3138075937663122, 0.3690066903528415, 0.3690066903528415, 0.3690066903528415, 0.2702495805117713, 0.2702495805117713, 0.2702495805117713, 0.18549151262357044, 0.18549151262357044, 0.18549151262357044, 0.23993364940290374, 0.23993364940290374, 0.23993364940290374, 0.2835391410798962, 0.2835391410798962, 0.2835391410798962, 0.2611104633059571, 0.2611104633059571, 0.2611104633059571, 0.22878844829496503, 0.22878844829496503, 0.22878844829496503, 0.21936358342778972, 0.21936358342778972, 0.21936358342778972, 0.19378975194545045, 0.19378975194545045, 0.19378975194545045, 0.18911278689397326, 0.18911278689397326, 0.18911278689397326, 0.194219110265913, 0.194219110265913, 0.194219110265913, 0.7762450795309073, 0.7762450795309073, 0.7762450795309073, 0.16408855967624836, 0.16408855967624836, 0.16408855967624836, 0.7393414719585454, 0.7393414719585454, 0.7393414719585454, 0.5385816701947104, 0.5385816701947104, 0.5385816701947104, 0.21097479971051492, 0.21097479971051492, 0.21097479971051492, 0.6353690106058089, 0.6353690106058089, 0.6353690106058089, 0.1999055767707718, 0.1999055767707718, 0.1999055767707718, 0.1929972819682816, 0.1929972819682816, 0.1929972819682816, 0.17745969633458447, 0.17745969633458447, 0.17745969633458447, 0.07670877923035113, 0.07670877923035113, 0.07670877923035113, 0.09059093311260602, 0.09059093311260602, 0.09059093311260602, 0.131267786356971, 0.131267786356971, 0.131267786356971]}, "mutation_prompt": null}
{"id": "9a16ac03-f396-4f41-918e-6d4a7052e293", "solution": "import numpy as np\n\nclass EnhancedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased for better diversity and exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.4  # Adjusted for balanced exploration-exploitation\n        self.c1_initial = 2.2  # Enhanced cognitive factor for personal learning\n        self.c2_initial = 1.3\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Increased for stronger convergence to global best\n        self.velocity_clamp = 0.7  # Adjusted for dynamic control\n        self.adaptive_local_search_prob = lambda eval_ratio: 0.1 + 0.2 * (1.0 - eval_ratio)  # Adaptive probability\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-1, 1, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                local_search_probability = self.adaptive_local_search_prob(evaluations / self.budget)\n                if np.random.rand() < local_search_probability:\n                    perturbation = np.random.normal(0, 0.2, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# enhanced_pso = EnhancedAdaptivePSO(budget=10000, dim=10)\n# enhanced_pso(func)", "name": "EnhancedAdaptivePSO", "description": "An Enhanced Particle Swarm Optimization with stochastic velocity adjustment and adaptive exploration-exploitation balance for robust optimization.", "configspace": "", "generation": 66, "fitness": 0.27862552977470884, "feedback": "The algorithm EnhancedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.708052931154471, 0.708052931154471, 0.708052931154471, 0.6883250317711352, 0.6883250317711352, 0.6883250317711352, 0.72256503066062, 0.72256503066062, 0.72256503066062, 0.3224666643190679, 0.3224666643190679, 0.3224666643190679, 0.2756240733268589, 0.2756240733268589, 0.2756240733268589, 0.31661019428988535, 0.31661019428988535, 0.31661019428988535, 0.14729145542357513, 0.14729145542357513, 0.14729145542357513, 0.12506888941694028, 0.12506888941694028, 0.12506888941694028, 0.11112495845514914, 0.11112495845514914, 0.11112495845514914, 0.11672371598268183, 0.11672371598268183, 0.11672371598268183, 0.12102843278648467, 0.12102843278648467, 0.12102843278648467, 0.143539359966389, 0.143539359966389, 0.143539359966389, 0.8791412915437667, 0.8791412915437667, 0.8791412915437667, 0.8889190190408316, 0.8889190190408316, 0.8889190190408316, 0.8961888960351088, 0.8961888960351088, 0.8961888960351088, 0.42565534659169846, 0.42565534659169846, 0.42565534659169846, 0.4652477230745885, 0.4652477230745885, 0.4652477230745885, 0.396611688011434, 0.396611688011434, 0.396611688011434, 0.22436250485626397, 0.22436250485626397, 0.22436250485626397, 0.27196097927294516, 0.27196097927294516, 0.27196097927294516, 0.17492351082360236, 0.17492351082360236, 0.17492351082360236, 0.19573165726851582, 0.19573165726851582, 0.19573165726851582, 0.16334931068075165, 0.16334931068075165, 0.16334931068075165, 0.1931579604587268, 0.1931579604587268, 0.1931579604587268, 0.1882501227453477, 0.1882501227453477, 0.1882501227453477, 0.19276962852665291, 0.19276962852665291, 0.19276962852665291, 0.12953157606870536, 0.12953157606870536, 0.12953157606870536, 0.004426053759094106, 0.004426053759094106, 0.004426053759094106, 0.03944045439703403, 0.03944045439703403, 0.03944045439703403, 0.007834330058003602, 0.007834330058003602, 0.007834330058003602, 0.204346352322205, 0.204346352322205, 0.204346352322205, 0.05403377578650492, 0.05403377578650492, 0.05403377578650492, 0.19702246343030072, 0.19702246343030072, 0.19702246343030072, 0.0991328612523823, 0.0991328612523823, 0.0991328612523823, 0.08757025231753435, 0.08757025231753435, 0.08757025231753435, 0.08063839762235203, 0.08063839762235203, 0.08063839762235203, 0.23568699862838327, 0.23568699862838327, 0.23568699862838327, 0.10046781311450048, 0.10046781311450048, 0.10046781311450048, 0.18369080372170843, 0.18369080372170843, 0.18369080372170843, 0.4891950328132104, 0.4891950328132104, 0.4891950328132104, 0.5045442612666272, 0.5045442612666272, 0.5045442612666272, 0.4831301027948183, 0.4831301027948183, 0.4831301027948183, 0.1145886438650996, 0.1145886438650996, 0.1145886438650996, 0.08087709947606181, 0.08087709947606181, 0.08087709947606181, 0.11560740750365983, 0.11560740750365983, 0.11560740750365983, 0.2329422168540296, 0.2329422168540296, 0.2329422168540296, 0.36369203379818915, 0.36369203379818915, 0.36369203379818915, 0.24631843628877048, 0.24631843628877048, 0.24631843628877048, 0.3639191261129765, 0.3639191261129765, 0.3639191261129765, 0.2814646123337323, 0.2814646123337323, 0.2814646123337323, 0.2549080025429782, 0.2549080025429782, 0.2549080025429782, 0.28873818922481964, 0.28873818922481964, 0.28873818922481964, 0.27969192875751137, 0.27969192875751137, 0.27969192875751137, 0.3059788941638363, 0.3059788941638363, 0.3059788941638363, 0.22543274656860035, 0.22543274656860035, 0.22543274656860035, 0.27481708310000486, 0.27481708310000486, 0.27481708310000486, 0.2656069791811868, 0.2656069791811868, 0.2656069791811868, 0.21392785861468144, 0.21392785861468144, 0.21392785861468144, 0.5044977008452286, 0.5044977008452286, 0.5044977008452286, 0.20291843007080268, 0.20291843007080268, 0.20291843007080268, 0.12460807454074907, 0.12460807454074907, 0.12460807454074907, 0.8292139072374065, 0.8292139072374065, 0.8292139072374065, 0.14220252347629736, 0.14220252347629736, 0.14220252347629736, 0.527075373162982, 0.527075373162982, 0.527075373162982, 0.20780388584017395, 0.20780388584017395, 0.20780388584017395, 0.49164458624029517, 0.49164458624029517, 0.49164458624029517, 0.20888921112041203, 0.20888921112041203, 0.20888921112041203, 0.19943151130540882, 0.19943151130540882, 0.19943151130540882, 0.202759487642709, 0.202759487642709, 0.202759487642709, 0.06257610904536992, 0.06257610904536992, 0.06257610904536992, 0.09334438488260344, 0.09334438488260344, 0.09334438488260344, 0.10017979414559852, 0.10017979414559852, 0.10017979414559852]}, "mutation_prompt": null}
{"id": "bbb9c4c7-c812-4c1c-9da5-56c580bfa7e4", "solution": "import numpy as np\n\nclass ReinforcedAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased the number of particles for enhanced exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.85\n        self.w_min = 0.35  # Adjusted inertia weight for better balance\n        self.c1_initial = 1.8  # Fine-tuned cognitive factor for individual learning\n        self.c2_initial = 1.7\n        self.c1_final = 1.4\n        self.c2_final = 3.0  # Boosted social factor to promote global convergence\n        self.velocity_clamp = 0.6  # Modified velocity clamping to allow dynamic shifts\n        self.local_search_probability = 0.15  # Increased probability for local search\n\n    def __call__(self, func):\n        np.random.seed(42)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.15, self.dim)  # Adjusted perturbation scale\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# reinforced_pso = ReinforcedAdaptivePSO(budget=10000, dim=10)\n# reinforced_pso(func)", "name": "ReinforcedAdaptivePSO", "description": "A reinforced Particle Swarm Optimization with adaptive hyper-parameters and stochastic local search for improved global exploration and fine-tuning.", "configspace": "", "generation": 67, "fitness": 0.2686874740219719, "feedback": "The algorithm ReinforcedAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.22.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.6814637877282553, 0.6814637877282553, 0.6814637877282553, 0.6729865179162197, 0.6729865179162197, 0.6729865179162197, 0.6854298062970887, 0.6854298062970887, 0.6854298062970887, 0.3608267687471408, 0.3608267687471408, 0.3608267687471408, 0.3167199684385077, 0.3167199684385077, 0.3167199684385077, 0.34225134373684263, 0.34225134373684263, 0.34225134373684263, 0.09010085335100249, 0.09010085335100249, 0.09010085335100249, 0.12045764036806483, 0.12045764036806483, 0.12045764036806483, 0.10778730674876591, 0.10778730674876591, 0.10778730674876591, 0.10981042939824381, 0.10981042939824381, 0.10981042939824381, 0.09895181760570282, 0.09895181760570282, 0.09895181760570282, 0.10271182635864029, 0.10271182635864029, 0.10271182635864029, 0.8760281463065999, 0.8760281463065999, 0.8760281463065999, 0.8644220169752469, 0.8644220169752469, 0.8644220169752469, 0.8453429128576238, 0.8453429128576238, 0.8453429128576238, 0.40630283868710515, 0.40630283868710515, 0.40630283868710515, 0.38411768134497526, 0.38411768134497526, 0.38411768134497526, 0.40110112605543813, 0.40110112605543813, 0.40110112605543813, 0.15020815902405715, 0.15020815902405715, 0.15020815902405715, 0.21244045240599307, 0.21244045240599307, 0.21244045240599307, 0.22369178837144155, 0.22369178837144155, 0.22369178837144155, 0.1288488575018255, 0.1288488575018255, 0.1288488575018255, 0.18139955750765457, 0.18139955750765457, 0.18139955750765457, 0.16401411760703266, 0.16401411760703266, 0.16401411760703266, 0.11946997783229818, 0.11946997783229818, 0.11946997783229818, 0.13399333895963828, 0.13399333895963828, 0.13399333895963828, 0.15981676367536624, 0.15981676367536624, 0.15981676367536624, 0.054144191277561204, 0.054144191277561204, 0.054144191277561204, 0.010725573708697644, 0.010725573708697644, 0.010725573708697644, 0.05401205966410527, 0.05401205966410527, 0.05401205966410527, 0.15180031868845545, 0.15180031868845545, 0.15180031868845545, 0.03556434804455144, 0.03556434804455144, 0.03556434804455144, 0.08676631590401263, 0.08676631590401263, 0.08676631590401263, 0.05863967563086403, 0.05863967563086403, 0.05863967563086403, 0.13422245216716144, 0.13422245216716144, 0.13422245216716144, 0.123982963630616, 0.123982963630616, 0.123982963630616, 0.11949944741619933, 0.11949944741619933, 0.11949944741619933, 0.08325873116914972, 0.08325873116914972, 0.08325873116914972, 0.18208738833672455, 0.18208738833672455, 0.18208738833672455, 0.47500261092739915, 0.47500261092739915, 0.47500261092739915, 0.505244694237396, 0.505244694237396, 0.505244694237396, 0.4781755986218378, 0.4781755986218378, 0.4781755986218378, 0.12634517394360867, 0.12634517394360867, 0.12634517394360867, 0.06700759237731779, 0.06700759237731779, 0.06700759237731779, 0.12146070795106445, 0.12146070795106445, 0.12146070795106445, 0.19057393946077839, 0.19057393946077839, 0.19057393946077839, 0.22649026089336777, 0.22649026089336777, 0.22649026089336777, 0.3448148844481155, 0.3448148844481155, 0.3448148844481155, 0.22238381873549962, 0.22238381873549962, 0.22238381873549962, 0.4026854176693764, 0.4026854176693764, 0.4026854176693764, 0.34453011216470586, 0.34453011216470586, 0.34453011216470586, 0.2300697849237907, 0.2300697849237907, 0.2300697849237907, 0.23789423165191825, 0.23789423165191825, 0.23789423165191825, 0.14582309011409, 0.14582309011409, 0.14582309011409, 0.22090473406559297, 0.22090473406559297, 0.22090473406559297, 0.20228065629505887, 0.20228065629505887, 0.20228065629505887, 0.24214655866426016, 0.24214655866426016, 0.24214655866426016, 0.5742679985252174, 0.5742679985252174, 0.5742679985252174, 0.18636230295854628, 0.18636230295854628, 0.18636230295854628, 0.2354491137216559, 0.2354491137216559, 0.2354491137216559, 0.8272378721846521, 0.8272378721846521, 0.8272378721846521, 0.1572571533189262, 0.1572571533189262, 0.1572571533189262, 0.8144411979767483, 0.8144411979767483, 0.8144411979767483, 0.5249642338979876, 0.5249642338979876, 0.5249642338979876, 0.21067001130116225, 0.21067001130116225, 0.21067001130116225, 0.12751248177026642, 0.12751248177026642, 0.12751248177026642, 0.18319883429285444, 0.18319883429285444, 0.18319883429285444, 0.2019415839658235, 0.2019415839658235, 0.2019415839658235, 0.18721479712539235, 0.18721479712539235, 0.18721479712539235, 0.09363284473970834, 0.09363284473970834, 0.09363284473970834, 0.10905199842374624, 0.10905199842374624, 0.10905199842374624, 0.09306257078924007, 0.09306257078924007, 0.09306257078924007]}, "mutation_prompt": null}
{"id": "b711fe52-98ed-4fef-9fe8-5471058d0bf8", "solution": "import numpy as np\n\nclass HybridAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.4  # Adjusted inertia range for balanced exploration and exploitation\n        self.c1_initial = 1.5  # Balanced cognitive factor for diversified search\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Increased social factor for enhanced convergence\n        self.velocity_clamp = 0.7  # Adjusted velocity clamping for more robust control\n        self.local_search_probability = 0.15  # Enhanced local search probability\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.uniform(-0.1, 0.1, self.dim)  # Mutation-based local search\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "HybridAdaptivePSO", "description": "A hybrid Particle Swarm Optimization with adaptive inertia and mutation-based local search enhancing global and local exploration.", "configspace": "", "generation": 68, "fitness": 0.30332942865586465, "feedback": "The algorithm HybridAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.24.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7571673019524573, 0.7571673019524573, 0.7571673019524573, 0.7376634835332211, 0.7376634835332211, 0.7376634835332211, 0.7420712864831909, 0.7420712864831909, 0.7420712864831909, 0.44591332160435704, 0.44591332160435704, 0.44591332160435704, 0.3734853832899595, 0.3734853832899595, 0.3734853832899595, 0.4026283353554111, 0.4026283353554111, 0.4026283353554111, 0.15588703944562565, 0.15588703944562565, 0.15588703944562565, 0.09868798598579764, 0.09868798598579764, 0.09868798598579764, 0.13623995261765098, 0.13623995261765098, 0.13623995261765098, 0.08333804067887818, 0.08333804067887818, 0.08333804067887818, 0.1477967851161186, 0.1477967851161186, 0.1477967851161186, 0.12742276886379145, 0.12742276886379145, 0.12742276886379145, 0.8988773972793428, 0.8988773972793428, 0.8988773972793428, 0.9014432415187809, 0.9014432415187809, 0.9014432415187809, 0.9078720934982983, 0.9078720934982983, 0.9078720934982983, 0.5266789238292058, 0.5266789238292058, 0.5266789238292058, 0.45568287986082767, 0.45568287986082767, 0.45568287986082767, 0.45658106735640547, 0.45658106735640547, 0.45658106735640547, 0.8727804222262, 0.8727804222262, 0.8727804222262, 0.21559081658050683, 0.21559081658050683, 0.21559081658050683, 0.2318962882583805, 0.2318962882583805, 0.2318962882583805, 0.12370583014826331, 0.12370583014826331, 0.12370583014826331, 0.1796999129302852, 0.1796999129302852, 0.1796999129302852, 0.18636935652344433, 0.18636935652344433, 0.18636935652344433, 0.2089965729166121, 0.2089965729166121, 0.2089965729166121, 0.24087152196769135, 0.24087152196769135, 0.24087152196769135, 0.21123639131924976, 0.21123639131924976, 0.21123639131924976, 0.0397453904578422, 0.0397453904578422, 0.0397453904578422, 0.08247632277451178, 0.08247632277451178, 0.08247632277451178, 0.011289660664596135, 0.011289660664596135, 0.011289660664596135, 0.15278830270217114, 0.15278830270217114, 0.15278830270217114, 0.07010672480734725, 0.07010672480734725, 0.07010672480734725, 0.20880813681710264, 0.20880813681710264, 0.20880813681710264, 0.14769531676730274, 0.14769531676730274, 0.14769531676730274, 0.14136355386510346, 0.14136355386510346, 0.14136355386510346, 0.07661175758800565, 0.07661175758800565, 0.07661175758800565, 0.1834426893453971, 0.1834426893453971, 0.1834426893453971, 0.07535413242484623, 0.07535413242484623, 0.07535413242484623, 0.17985942331697957, 0.17985942331697957, 0.17985942331697957, 0.49233667217398935, 0.49233667217398935, 0.49233667217398935, 0.5230956962132203, 0.5230956962132203, 0.5230956962132203, 0.5118186202005737, 0.5118186202005737, 0.5118186202005737, 0.09383245510382388, 0.09383245510382388, 0.09383245510382388, 0.12661559066007466, 0.12661559066007466, 0.12661559066007466, 0.11373027935601909, 0.11373027935601909, 0.11373027935601909, 0.3097771149159, 0.3097771149159, 0.3097771149159, 0.18255175508579646, 0.18255175508579646, 0.18255175508579646, 0.3146710333057958, 0.3146710333057958, 0.3146710333057958, 0.348728584106187, 0.348728584106187, 0.348728584106187, 0.426509909561384, 0.426509909561384, 0.426509909561384, 0.3920292713972713, 0.3920292713972713, 0.3920292713972713, 0.23313751675202798, 0.23313751675202798, 0.23313751675202798, 0.2562544018427909, 0.2562544018427909, 0.2562544018427909, 0.3388390167802562, 0.3388390167802562, 0.3388390167802562, 0.2371878816171321, 0.2371878816171321, 0.2371878816171321, 0.2876630786011828, 0.2876630786011828, 0.2876630786011828, 0.2225299332508457, 0.2225299332508457, 0.2225299332508457, 0.19640463864969704, 0.19640463864969704, 0.19640463864969704, 0.29568546686100294, 0.29568546686100294, 0.29568546686100294, 0.18391091611821353, 0.18391091611821353, 0.18391091611821353, 0.1844828038825952, 0.1844828038825952, 0.1844828038825952, 0.8718034151196283, 0.8718034151196283, 0.8718034151196283, 0.14199420355626358, 0.14199420355626358, 0.14199420355626358, 0.6697495593170727, 0.6697495593170727, 0.6697495593170727, 0.16706905593173982, 0.16706905593173982, 0.16706905593173982, 0.713010563195214, 0.713010563195214, 0.713010563195214, 0.17689000792152987, 0.17689000792152987, 0.17689000792152987, 0.19123150193955618, 0.19123150193955618, 0.19123150193955618, 0.18477157103184272, 0.18477157103184272, 0.18477157103184272, 0.08349820677981046, 0.08349820677981046, 0.08349820677981046, 0.09444120730936756, 0.09444120730936756, 0.09444120730936756, 0.07734112201328969, 0.07734112201328969, 0.07734112201328969]}, "mutation_prompt": null}
{"id": "6ebb17ea-355c-4b1a-9166-f8da7acdfd5a", "solution": "import numpy as np\n\nclass DynamicAdaptivePSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles for thorough search\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.2  # Further decreased minimum inertia weight for enhanced exploitation\n        self.c1_initial = 1.5  # Balanced cognitive factor for individual learning\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0  # Slightly higher social factor to encourage global exploration\n        self.velocity_clamp = 0.6  # Modified velocity clamping for better balance\n        self.local_search_probability = 0.15  # Increased local search probability\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.zeros((self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.05, self.dim)  # Reduced perturbation for finer adjustments\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -self.velocity_clamp, self.velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n\n# Usage:\n# dynamic_pso = DynamicAdaptivePSO(budget=10000, dim=10)\n# dynamic_pso(func)", "name": "DynamicAdaptivePSO", "description": "A dynamically adaptive Particle Swarm Optimization with refined local search and inertia control for improved convergence across diverse optimization landscapes.", "configspace": "", "generation": 69, "fitness": 0.3053427596408581, "feedback": "The algorithm DynamicAdaptivePSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7399224294736393, 0.7399224294736393, 0.7399224294736393, 0.7490069321758068, 0.7490069321758068, 0.7490069321758068, 0.7389678828458328, 0.7389678828458328, 0.7389678828458328, 0.4640473357409989, 0.4640473357409989, 0.4640473357409989, 0.4345808210021125, 0.4345808210021125, 0.4345808210021125, 0.4452018567204029, 0.4452018567204029, 0.4452018567204029, 0.4924624492694236, 0.4924624492694236, 0.4924624492694236, 0.11149865198949516, 0.11149865198949516, 0.11149865198949516, 0.1366490634461741, 0.1366490634461741, 0.1366490634461741, 0.10431062811842895, 0.10431062811842895, 0.10431062811842895, 0.09234184004628165, 0.09234184004628165, 0.09234184004628165, 0.10190765513343014, 0.10190765513343014, 0.10190765513343014, 0.8889857100263749, 0.8889857100263749, 0.8889857100263749, 0.8841636988738545, 0.8841636988738545, 0.8841636988738545, 0.8900950953703677, 0.8900950953703677, 0.8900950953703677, 0.4617651527534199, 0.4617651527534199, 0.4617651527534199, 0.5177638901375782, 0.5177638901375782, 0.5177638901375782, 0.48408266292254276, 0.48408266292254276, 0.48408266292254276, 0.22669164217702398, 0.22669164217702398, 0.22669164217702398, 0.27862039520592696, 0.27862039520592696, 0.27862039520592696, 0.22642043991539618, 0.22642043991539618, 0.22642043991539618, 0.2202667413466649, 0.2202667413466649, 0.2202667413466649, 0.3861055690356019, 0.3861055690356019, 0.3861055690356019, 0.3057044669807847, 0.3057044669807847, 0.3057044669807847, 0.1988941547488614, 0.1988941547488614, 0.1988941547488614, 0.19960447345810817, 0.19960447345810817, 0.19960447345810817, 0.19785558462746722, 0.19785558462746722, 0.19785558462746722, 0.060389219492488655, 0.060389219492488655, 0.060389219492488655, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.08293729241379955, 0.08293729241379955, 0.08293729241379955, 0.11332571391190938, 0.11332571391190938, 0.11332571391190938, 0.0919820544380423, 0.0919820544380423, 0.0919820544380423, 0.17146141780498492, 0.17146141780498492, 0.17146141780498492, 0.19796860024448903, 0.19796860024448903, 0.19796860024448903, 0.09415020237573368, 0.09415020237573368, 0.09415020237573368, 0.12925657976386173, 0.12925657976386173, 0.12925657976386173, 0.2331249567014969, 0.2331249567014969, 0.2331249567014969, 0.10229673622834556, 0.10229673622834556, 0.10229673622834556, 0.10380230199870932, 0.10380230199870932, 0.10380230199870932, 0.4966999028065201, 0.4966999028065201, 0.4966999028065201, 0.5134412949378224, 0.5134412949378224, 0.5134412949378224, 0.5184405671880241, 0.5184405671880241, 0.5184405671880241, 0.10297666430304764, 0.10297666430304764, 0.10297666430304764, 0.13766333587361368, 0.13766333587361368, 0.13766333587361368, 0.07700129157084556, 0.07700129157084556, 0.07700129157084556, 0.3005115861561387, 0.3005115861561387, 0.3005115861561387, 0.19188049106106442, 0.19188049106106442, 0.19188049106106442, 0.4570851492878235, 0.4570851492878235, 0.4570851492878235, 0.3660194402496578, 0.3660194402496578, 0.3660194402496578, 0.415433313525299, 0.415433313525299, 0.415433313525299, 0.25309275692526234, 0.25309275692526234, 0.25309275692526234, 0.28647709061318627, 0.28647709061318627, 0.28647709061318627, 0.21896555091110215, 0.21896555091110215, 0.21896555091110215, 0.23276435337042056, 0.23276435337042056, 0.23276435337042056, 0.24630181073283341, 0.24630181073283341, 0.24630181073283341, 0.25151537600453133, 0.25151537600453133, 0.25151537600453133, 0.2517341673599688, 0.2517341673599688, 0.2517341673599688, 0.22355516569259926, 0.22355516569259926, 0.22355516569259926, 0.24421527898809414, 0.24421527898809414, 0.24421527898809414, 0.20885186017947233, 0.20885186017947233, 0.20885186017947233, 0.1246288892785904, 0.1246288892785904, 0.1246288892785904, 0.848140454680401, 0.848140454680401, 0.848140454680401, 0.14188465992653765, 0.14188465992653765, 0.14188465992653765, 0.7106715155722236, 0.7106715155722236, 0.7106715155722236, 0.20753947856135746, 0.20753947856135746, 0.20753947856135746, 0.6473387770237753, 0.6473387770237753, 0.6473387770237753, 0.19237002476621357, 0.19237002476621357, 0.19237002476621357, 0.20664906202935285, 0.20664906202935285, 0.20664906202935285, 0.24969374843010173, 0.24969374843010173, 0.24969374843010173, 0.09845119860992035, 0.09845119860992035, 0.09845119860992035, 0.09305682246835145, 0.09305682246835145, 0.09305682246835145, 0.11091531614176642, 0.11091531614176642, 0.11091531614176642]}, "mutation_prompt": null}
{"id": "c62d2d41-c4c1-459e-bcf1-98aee8801dbe", "solution": "import numpy as np\n\nclass RefinedPSO:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50  # Same number of particles for consistent exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Slightly reduced inertia weight range for better stability\n        self.w_min = 0.2\n        self.c1_initial = 2.1  # Adjusted cognitive factor for improved personal search\n        self.c2_initial = 1.7\n        self.c1_final = 1.3\n        self.c2_final = 2.9  # Further increased social factor to drive towards global optima\n        self.velocity_clamp_initial = 1.0  # Start with a larger velocity clamp\n        self.velocity_clamp_final = 0.3  # Tighten velocity clamp over time\n        self.local_search_probability = 0.15  # Increased local search probability for better local refinement\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n            \n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    perturbation = np.random.normal(0, 0.1, self.dim)\n                    candidate_position = positions[i] + perturbation\n                    candidate_position = np.clip(candidate_position, self.lower_bound, self.upper_bound)\n                    candidate_score = func(candidate_position)\n                    evaluations += 1\n                    if candidate_score < personal_best_scores[i]:\n                        personal_best_scores[i] = candidate_score\n                        personal_best_positions[i] = candidate_position.copy()\n                        if candidate_score < global_best_score:\n                            global_best_score = candidate_score\n                            global_best_position = candidate_position.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "RefinedPSO", "description": "A refined Particle Swarm Optimization incorporating adaptive learning rates, velocity mutation, and enhanced local search for improved exploration-exploitation balance.", "configspace": "", "generation": 70, "fitness": 0.313794086888259, "feedback": "The algorithm RefinedPSO got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.25.", "error": "", "parent_id": "223b4c74-6c17-4756-b5f4-42c8c7ab9509", "metadata": {"aucs": [0.7593089892230716, 0.7593089892230716, 0.7593089892230716, 0.7506526819219022, 0.7506526819219022, 0.7506526819219022, 0.7389772039573841, 0.7389772039573841, 0.7389772039573841, 0.46672272756170674, 0.46672272756170674, 0.46672272756170674, 0.4595100948560352, 0.4595100948560352, 0.4595100948560352, 0.44599725549959524, 0.44599725549959524, 0.44599725549959524, 0.4243530040057123, 0.4243530040057123, 0.4243530040057123, 0.11717383595549857, 0.11717383595549857, 0.11717383595549857, 0.11861853922069154, 0.11861853922069154, 0.11861853922069154, 0.11519174936636134, 0.11519174936636134, 0.11519174936636134, 0.1270044324641989, 0.1270044324641989, 0.1270044324641989, 0.1079086392614248, 0.1079086392614248, 0.1079086392614248, 0.9483596691228611, 0.9483596691228611, 0.9483596691228611, 0.9285942725168098, 0.9285942725168098, 0.9285942725168098, 0.9391449096215412, 0.9391449096215412, 0.9391449096215412, 0.4615308590619307, 0.4615308590619307, 0.4615308590619307, 0.43810427250294315, 0.43810427250294315, 0.43810427250294315, 0.42221774848997506, 0.42221774848997506, 0.42221774848997506, 0.5915321777460679, 0.5915321777460679, 0.5915321777460679, 0.2117353636702174, 0.2117353636702174, 0.2117353636702174, 0.2324767151608993, 0.2324767151608993, 0.2324767151608993, 0.16848467646078757, 0.16848467646078757, 0.16848467646078757, 0.2035794374636123, 0.2035794374636123, 0.2035794374636123, 0.18117476203603755, 0.18117476203603755, 0.18117476203603755, 0.20030754484598956, 0.20030754484598956, 0.20030754484598956, 0.21431722659015218, 0.21431722659015218, 0.21431722659015218, 0.22594345030662732, 0.22594345030662732, 0.22594345030662732, 0.008548651339457147, 0.008548651339457147, 0.008548651339457147, 0.030676328119203178, 0.030676328119203178, 0.030676328119203178, 0.012131292267399285, 0.012131292267399285, 0.012131292267399285, 0.16907068432544625, 0.16907068432544625, 0.16907068432544625, 0.06027113503154702, 0.06027113503154702, 0.06027113503154702, 0.09271657891682261, 0.09271657891682261, 0.09271657891682261, 0.10174359383594889, 0.10174359383594889, 0.10174359383594889, 0.12834576228571126, 0.12834576228571126, 0.12834576228571126, 0.08002463190129583, 0.08002463190129583, 0.08002463190129583, 0.12357240841867201, 0.12357240841867201, 0.12357240841867201, 0.07226458107517664, 0.07226458107517664, 0.07226458107517664, 0.19976953700371103, 0.19976953700371103, 0.19976953700371103, 0.5093778890497094, 0.5093778890497094, 0.5093778890497094, 0.48637855893705184, 0.48637855893705184, 0.48637855893705184, 0.5092202505777725, 0.5092202505777725, 0.5092202505777725, 0.10876717793379809, 0.10876717793379809, 0.10876717793379809, 0.14634075658974166, 0.14634075658974166, 0.14634075658974166, 0.13838280502604117, 0.13838280502604117, 0.13838280502604117, 0.13593004179078416, 0.13593004179078416, 0.13593004179078416, 0.36628218015868363, 0.36628218015868363, 0.36628218015868363, 0.19162496966487275, 0.19162496966487275, 0.19162496966487275, 0.4194266673360517, 0.4194266673360517, 0.4194266673360517, 0.35465446406367407, 0.35465446406367407, 0.35465446406367407, 0.3777317476091674, 0.3777317476091674, 0.3777317476091674, 0.2512736648190804, 0.2512736648190804, 0.2512736648190804, 0.2794111428496586, 0.2794111428496586, 0.2794111428496586, 0.23522284058590948, 0.23522284058590948, 0.23522284058590948, 0.19630360292389393, 0.19630360292389393, 0.19630360292389393, 0.22383055451670142, 0.22383055451670142, 0.22383055451670142, 0.2852912906341427, 0.2852912906341427, 0.2852912906341427, 0.2425890556322241, 0.2425890556322241, 0.2425890556322241, 0.6315368567400869, 0.6315368567400869, 0.6315368567400869, 0.20318540114870376, 0.20318540114870376, 0.20318540114870376, 0.18578756581813283, 0.18578756581813283, 0.18578756581813283, 0.8831572929606526, 0.8831572929606526, 0.8831572929606526, 0.8304371891103987, 0.8304371891103987, 0.8304371891103987, 0.6376613132059867, 0.6376613132059867, 0.6376613132059867, 0.1677995429262824, 0.1677995429262824, 0.1677995429262824, 0.6593033064945607, 0.6593033064945607, 0.6593033064945607, 0.18819251991298536, 0.18819251991298536, 0.18819251991298536, 0.20859810819506253, 0.20859810819506253, 0.20859810819506253, 0.1875595471941004, 0.1875595471941004, 0.1875595471941004, 0.09399703494975853, 0.09399703494975853, 0.09399703494975853, 0.0852436944799676, 0.0852436944799676, 0.0852436944799676, 0.09461779870858245, 0.09461779870858245, 0.09461779870858245]}, "mutation_prompt": null}
{"id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_probability = 0.2\n        self.mutation_factor = 0.5  # Differential mutation factor\n        self.crossover_rate = 0.9  # Crossover rate for differential evolution\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "AdaptiveHybridOptimization", "description": "Adaptive Hybrid Optimization (AHO) combining particle swarm dynamics with differential evolution for enhanced diversity and convergence.", "configspace": "", "generation": 71, "fitness": 0.3468728006081674, "feedback": "The algorithm AdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.35 with standard deviation 0.27.", "error": "", "parent_id": "c62d2d41-c4c1-459e-bcf1-98aee8801dbe", "metadata": {"aucs": [0.7895836015197397, 0.7895836015197397, 0.7895836015197397, 0.7946939659872195, 0.7946939659872195, 0.7946939659872195, 0.7827185030060426, 0.7827185030060426, 0.7827185030060426, 0.5581754454568489, 0.5581754454568489, 0.5581754454568489, 0.574857286697678, 0.574857286697678, 0.574857286697678, 0.5566457282797854, 0.5566457282797854, 0.5566457282797854, 0.17464627716960057, 0.17464627716960057, 0.17464627716960057, 0.1166444184302361, 0.1166444184302361, 0.1166444184302361, 0.11687482365635138, 0.11687482365635138, 0.11687482365635138, 0.13365689645103163, 0.13365689645103163, 0.13365689645103163, 0.15728296835600997, 0.15728296835600997, 0.15728296835600997, 0.11315853967223444, 0.11315853967223444, 0.11315853967223444, 0.939123796775058, 0.939123796775058, 0.939123796775058, 0.9293789576951788, 0.9293789576951788, 0.9293789576951788, 0.928710751654857, 0.928710751654857, 0.928710751654857, 0.4894503000255258, 0.4894503000255258, 0.4894503000255258, 0.5103152794355856, 0.5103152794355856, 0.5103152794355856, 0.47916012461591806, 0.47916012461591806, 0.47916012461591806, 0.8545918793380147, 0.8545918793380147, 0.8545918793380147, 0.7546022019729164, 0.7546022019729164, 0.7546022019729164, 0.6982566528891132, 0.6982566528891132, 0.6982566528891132, 0.19614203018179022, 0.19614203018179022, 0.19614203018179022, 0.2168586275342569, 0.2168586275342569, 0.2168586275342569, 0.20369001311330848, 0.20369001311330848, 0.20369001311330848, 0.132991816190819, 0.132991816190819, 0.132991816190819, 0.2200528903526182, 0.2200528903526182, 0.2200528903526182, 0.2541679426183254, 0.2541679426183254, 0.2541679426183254, 0.05313909309388709, 0.05313909309388709, 0.05313909309388709, 0.0942862222464832, 0.0942862222464832, 0.0942862222464832, 0.05322492539476953, 0.05322492539476953, 0.05322492539476953, 0.20426992583527892, 0.20426992583527892, 0.20426992583527892, 0.1728343595006363, 0.1728343595006363, 0.1728343595006363, 0.15438215489718898, 0.15438215489718898, 0.15438215489718898, 0.07088574780650558, 0.07088574780650558, 0.07088574780650558, 0.15239007691748085, 0.15239007691748085, 0.15239007691748085, 0.09376040974467525, 0.09376040974467525, 0.09376040974467525, 0.1777896452539588, 0.1777896452539588, 0.1777896452539588, 0.1628951900566381, 0.1628951900566381, 0.1628951900566381, 0.07978427742195893, 0.07978427742195893, 0.07978427742195893, 0.5204904934952671, 0.5204904934952671, 0.5204904934952671, 0.5526658242353327, 0.5526658242353327, 0.5526658242353327, 0.5313657011976667, 0.5313657011976667, 0.5313657011976667, 0.09446891363605114, 0.09446891363605114, 0.09446891363605114, 0.10082884432785666, 0.10082884432785666, 0.10082884432785666, 0.15506941409652442, 0.15506941409652442, 0.15506941409652442, 0.2074271186152098, 0.2074271186152098, 0.2074271186152098, 0.2959668217386152, 0.2959668217386152, 0.2959668217386152, 0.3791244445331239, 0.3791244445331239, 0.3791244445331239, 0.40770683646633, 0.40770683646633, 0.40770683646633, 0.461536616982939, 0.461536616982939, 0.461536616982939, 0.46257700593028883, 0.46257700593028883, 0.46257700593028883, 0.21902107551280947, 0.21902107551280947, 0.21902107551280947, 0.3563258561221383, 0.3563258561221383, 0.3563258561221383, 0.2474680005978266, 0.2474680005978266, 0.2474680005978266, 0.20417258914390446, 0.20417258914390446, 0.20417258914390446, 0.22729678098722805, 0.22729678098722805, 0.22729678098722805, 0.22314842379469357, 0.22314842379469357, 0.22314842379469357, 0.21588487370922083, 0.21588487370922083, 0.21588487370922083, 0.22100840205041583, 0.22100840205041583, 0.22100840205041583, 0.24216124021531737, 0.24216124021531737, 0.24216124021531737, 0.8375012045719195, 0.8375012045719195, 0.8375012045719195, 0.9090806808219745, 0.9090806808219745, 0.9090806808219745, 0.1418618374584506, 0.1418618374584506, 0.1418618374584506, 0.7905978270547784, 0.7905978270547784, 0.7905978270547784, 0.7569990490845664, 0.7569990490845664, 0.7569990490845664, 0.21082535228295762, 0.21082535228295762, 0.21082535228295762, 0.1974656061574156, 0.1974656061574156, 0.1974656061574156, 0.1848299648349595, 0.1848299648349595, 0.1848299648349595, 0.18760627427163612, 0.18760627427163612, 0.18760627427163612, 0.08880660277206842, 0.08880660277206842, 0.08880660277206842, 0.10952451462961632, 0.10952451462961632, 0.10952451462961632, 0.08795370521342216, 0.08795370521342216, 0.08795370521342216]}, "mutation_prompt": null}
{"id": "5d0c4a52-d863-4b08-8b64-440d5500a2dc", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_probability = 0.2\n        self.mutation_factor = 0.5  # Differential mutation factor\n        self.crossover_rate = 0.9  # Crossover rate for differential evolution\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "AdaptiveHybridOptimization", "description": "Adaptive Hybrid Optimization (AHO) combining particle swarm dynamics with differential evolution for enhanced diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7895836015197397, 0.7895836015197397, 0.7895836015197397, 0.7946939659872195, 0.7946939659872195, 0.7946939659872195, 0.7827185030060426, 0.7827185030060426, 0.7827185030060426, 0.5581754454568489, 0.5581754454568489, 0.5581754454568489, 0.574857286697678, 0.574857286697678, 0.574857286697678, 0.5566457282797854, 0.5566457282797854, 0.5566457282797854, 0.17464627716960057, 0.17464627716960057, 0.17464627716960057, 0.1166444184302361, 0.1166444184302361, 0.1166444184302361, 0.11687482365635138, 0.11687482365635138, 0.11687482365635138, 0.13365689645103163, 0.13365689645103163, 0.13365689645103163, 0.15728296835600997, 0.15728296835600997, 0.15728296835600997, 0.11315853967223444, 0.11315853967223444, 0.11315853967223444, 0.939123796775058, 0.939123796775058, 0.939123796775058, 0.9293789576951788, 0.9293789576951788, 0.9293789576951788, 0.928710751654857, 0.928710751654857, 0.928710751654857, 0.4894503000255258, 0.4894503000255258, 0.4894503000255258, 0.5103152794355856, 0.5103152794355856, 0.5103152794355856, 0.47916012461591806, 0.47916012461591806, 0.47916012461591806, 0.8545918793380147, 0.8545918793380147, 0.8545918793380147, 0.7546022019729164, 0.7546022019729164, 0.7546022019729164, 0.6982566528891132, 0.6982566528891132, 0.6982566528891132, 0.19614203018179022, 0.19614203018179022, 0.19614203018179022, 0.2168586275342569, 0.2168586275342569, 0.2168586275342569, 0.20369001311330848, 0.20369001311330848, 0.20369001311330848, 0.132991816190819, 0.132991816190819, 0.132991816190819, 0.2200528903526182, 0.2200528903526182, 0.2200528903526182, 0.2541679426183254, 0.2541679426183254, 0.2541679426183254, 0.05313909309388709, 0.05313909309388709, 0.05313909309388709, 0.0942862222464832, 0.0942862222464832, 0.0942862222464832, 0.05322492539476953, 0.05322492539476953, 0.05322492539476953, 0.20426992583527892, 0.20426992583527892, 0.20426992583527892, 0.1728343595006363, 0.1728343595006363, 0.1728343595006363, 0.15438215489718898, 0.15438215489718898, 0.15438215489718898, 0.07088574780650558, 0.07088574780650558, 0.07088574780650558, 0.15239007691748085, 0.15239007691748085, 0.15239007691748085, 0.09376040974467525, 0.09376040974467525, 0.09376040974467525, 0.1777896452539588, 0.1777896452539588, 0.1777896452539588, 0.1628951900566381, 0.1628951900566381, 0.1628951900566381, 0.07978427742195893, 0.07978427742195893, 0.07978427742195893, 0.5204904934952671, 0.5204904934952671, 0.5204904934952671, 0.5526658242353327, 0.5526658242353327, 0.5526658242353327, 0.5313657011976667, 0.5313657011976667, 0.5313657011976667, 0.09446891363605114, 0.09446891363605114, 0.09446891363605114, 0.10082884432785666, 0.10082884432785666, 0.10082884432785666, 0.15506941409652442, 0.15506941409652442, 0.15506941409652442, 0.2074271186152098, 0.2074271186152098, 0.2074271186152098, 0.2959668217386152, 0.2959668217386152, 0.2959668217386152, 0.3791244445331239, 0.3791244445331239, 0.3791244445331239, 0.40770683646633, 0.40770683646633, 0.40770683646633, 0.461536616982939, 0.461536616982939, 0.461536616982939, 0.46257700593028883, 0.46257700593028883, 0.46257700593028883, 0.21902107551280947, 0.21902107551280947, 0.21902107551280947, 0.3563258561221383, 0.3563258561221383, 0.3563258561221383, 0.2474680005978266, 0.2474680005978266, 0.2474680005978266, 0.20417258914390446, 0.20417258914390446, 0.20417258914390446, 0.22729678098722805, 0.22729678098722805, 0.22729678098722805, 0.22314842379469357, 0.22314842379469357, 0.22314842379469357, 0.21588487370922083, 0.21588487370922083, 0.21588487370922083, 0.22100840205041583, 0.22100840205041583, 0.22100840205041583, 0.24216124021531737, 0.24216124021531737, 0.24216124021531737, 0.8375012045719195, 0.8375012045719195, 0.8375012045719195, 0.9090806808219745, 0.9090806808219745, 0.9090806808219745, 0.1418618374584506, 0.1418618374584506, 0.1418618374584506, 0.7905978270547784, 0.7905978270547784, 0.7905978270547784, 0.7569990490845664, 0.7569990490845664, 0.7569990490845664, 0.21082535228295762, 0.21082535228295762, 0.21082535228295762, 0.1974656061574156, 0.1974656061574156, 0.1974656061574156, 0.1848299648349595, 0.1848299648349595, 0.1848299648349595, 0.18760627427163612, 0.18760627427163612, 0.18760627427163612, 0.08880660277206842, 0.08880660277206842, 0.08880660277206842, 0.10952451462961632, 0.10952451462961632, 0.10952451462961632, 0.08795370521342216, 0.08795370521342216, 0.08795370521342216]}, "mutation_prompt": null}
{"id": "de1d473a-5f94-452f-8866-73f45b13a3bd", "solution": "import numpy as np\n\nclass QuantumHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.2\n        self.c1_initial = 2.5\n        self.c2_initial = 2.0\n        self.c1_final = 1.2\n        self.c2_final = 2.8\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.2\n        self.local_search_probability = 0.25\n        self.mutation_factor = 0.55  # Differential mutation factor\n        self.crossover_rate = 0.85  # Crossover rate for differential evolution\n        self.quantum_probability = 0.15\n        self.theta = np.pi / 4  # Quantum rotation angle\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                if np.random.rand() < self.quantum_probability:\n                    velocities[i] = velocities[i] * np.cos(self.theta) + np.cross(velocities[i], np.sin(self.theta * np.ones(self.dim)))\n\n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "QuantumHybridOptimization", "description": "Quantum-inspired Hybrid Particle Swarm and Differential Evolution with Adaptive Quantum Rotation Gates for enhanced exploration and exploitation.", "configspace": "", "generation": 73, "fitness": -Infinity, "feedback": "An exception occurred: ValueError('incompatible dimensions for cross product\\n(dimension must be 2 or 3)').", "error": "ValueError('incompatible dimensions for cross product\\n(dimension must be 2 or 3)')", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {}, "mutation_prompt": null}
{"id": "51b599b6-d695-4ec2-a995-c0e2715e692e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Increased number of particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Increased initial inertia weight\n        self.w_min = 0.2  # Decreased minimum inertia weight\n        self.c1_initial = 2.5  # Adjusted cognitive coefficient\n        self.c2_initial = 1.5  # Adjusted social coefficient\n        self.c1_final = 1.2  # Adjusted cognitive coefficient\n        self.c2_final = 2.8  # Adjusted social coefficient\n        self.velocity_clamp_initial = 0.95  # Increased initial velocity clamp\n        self.velocity_clamp_final = 0.2  # Decreased final velocity clamp\n        self.local_search_probability = 0.25  # Increased probability for local search\n        self.mutation_factor = 0.6  # Adjusted differential mutation factor\n        self.crossover_rate = 0.85  # Adjusted crossover rate for differential evolution\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector + np.random.normal(0, 0.1, self.dim), self.lower_bound, self.upper_bound)  # Added perturbation\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) integrates adaptive velocity control with a perturbation mechanism for improved exploration and exploitation balance.", "configspace": "", "generation": 74, "fitness": 0.2863838731800645, "feedback": "The algorithm EnhancedAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.29 with standard deviation 0.23.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.693049028933699, 0.693049028933699, 0.693049028933699, 0.707991449262763, 0.707991449262763, 0.707991449262763, 0.7124796708450036, 0.7124796708450036, 0.7124796708450036, 0.40162587682835005, 0.40162587682835005, 0.40162587682835005, 0.37796134402890136, 0.37796134402890136, 0.37796134402890136, 0.35543951438106225, 0.35543951438106225, 0.35543951438106225, 0.16874985133447384, 0.16874985133447384, 0.16874985133447384, 0.10964121792351011, 0.10964121792351011, 0.10964121792351011, 0.14260583568667662, 0.14260583568667662, 0.14260583568667662, 0.09693744310734509, 0.09693744310734509, 0.09693744310734509, 0.1394272368847589, 0.1394272368847589, 0.1394272368847589, 0.1156979617853201, 0.1156979617853201, 0.1156979617853201, 0.9187995654872525, 0.9187995654872525, 0.9187995654872525, 0.9134395345414359, 0.9134395345414359, 0.9134395345414359, 0.9205040361953036, 0.9205040361953036, 0.9205040361953036, 0.4027649072077937, 0.4027649072077937, 0.4027649072077937, 0.39108726539284466, 0.39108726539284466, 0.39108726539284466, 0.3882213414540612, 0.3882213414540612, 0.3882213414540612, 0.3508161915939103, 0.3508161915939103, 0.3508161915939103, 0.7370572087490259, 0.7370572087490259, 0.7370572087490259, 0.6910262429815993, 0.6910262429815993, 0.6910262429815993, 0.16491813900490948, 0.16491813900490948, 0.16491813900490948, 0.18802090746505196, 0.18802090746505196, 0.18802090746505196, 0.17269810508683459, 0.17269810508683459, 0.17269810508683459, 0.17441003187329407, 0.17441003187329407, 0.17441003187329407, 0.16248592442508558, 0.16248592442508558, 0.16248592442508558, 0.2018244760478174, 0.2018244760478174, 0.2018244760478174, 0.007011645373927067, 0.007011645373927067, 0.007011645373927067, 0.03988714560819795, 0.03988714560819795, 0.03988714560819795, 0.03776925737020409, 0.03776925737020409, 0.03776925737020409, 0.17711131824762238, 0.17711131824762238, 0.17711131824762238, 0.09336578919478322, 0.09336578919478322, 0.09336578919478322, 0.14753305662059646, 0.14753305662059646, 0.14753305662059646, 0.10895389492809515, 0.10895389492809515, 0.10895389492809515, 0.07763185092660263, 0.07763185092660263, 0.07763185092660263, 0.08841978327551059, 0.08841978327551059, 0.08841978327551059, 0.1481312189812477, 0.1481312189812477, 0.1481312189812477, 0.2018170973910577, 0.2018170973910577, 0.2018170973910577, 0.1416247359304712, 0.1416247359304712, 0.1416247359304712, 0.5002282887773659, 0.5002282887773659, 0.5002282887773659, 0.4505026685037514, 0.4505026685037514, 0.4505026685037514, 0.4907087983117169, 0.4907087983117169, 0.4907087983117169, 0.13213911058887806, 0.13213911058887806, 0.13213911058887806, 0.09724760048773018, 0.09724760048773018, 0.09724760048773018, 0.1248699934355686, 0.1248699934355686, 0.1248699934355686, 0.18866705665040207, 0.18866705665040207, 0.18866705665040207, 0.16818675486473256, 0.16818675486473256, 0.16818675486473256, 0.22406431461203646, 0.22406431461203646, 0.22406431461203646, 0.31088920462471126, 0.31088920462471126, 0.31088920462471126, 0.28407872171625126, 0.28407872171625126, 0.28407872171625126, 0.36340245494533097, 0.36340245494533097, 0.36340245494533097, 0.2848573933884534, 0.2848573933884534, 0.2848573933884534, 0.22921628476555522, 0.22921628476555522, 0.22921628476555522, 0.2642731121565606, 0.2642731121565606, 0.2642731121565606, 0.25247244774728206, 0.25247244774728206, 0.25247244774728206, 0.2227793503630019, 0.2227793503630019, 0.2227793503630019, 0.2157204326585478, 0.2157204326585478, 0.2157204326585478, 0.21553998141448483, 0.21553998141448483, 0.21553998141448483, 0.20313930779058942, 0.20313930779058942, 0.20313930779058942, 0.2218407476910389, 0.2218407476910389, 0.2218407476910389, 0.18570784992616818, 0.18570784992616818, 0.18570784992616818, 0.8504075474399542, 0.8504075474399542, 0.8504075474399542, 0.17312159166013974, 0.17312159166013974, 0.17312159166013974, 0.6849929775712177, 0.6849929775712177, 0.6849929775712177, 0.2087651755428579, 0.2087651755428579, 0.2087651755428579, 0.15050403866675366, 0.15050403866675366, 0.15050403866675366, 0.18689142177608464, 0.18689142177608464, 0.18689142177608464, 0.19119208425552547, 0.19119208425552547, 0.19119208425552547, 0.1829910695272089, 0.1829910695272089, 0.1829910695272089, 0.11254992661819307, 0.11254992661819307, 0.11254992661819307, 0.09659035422314233, 0.09659035422314233, 0.09659035422314233, 0.0821637039070039, 0.0821637039070039, 0.0821637039070039]}, "mutation_prompt": null}
{"id": "b1b5cd39-7565-46d7-a276-0f7e7e6f7a9f", "solution": "import numpy as np\n\nclass QuantumInspiredHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Adjusted inertia weight to promote exploration\n        self.w_min = 0.2\n        self.c1_initial = 2.2  # Slightly increased cognitive component\n        self.c2_initial = 1.7\n        self.c1_final = 1.6\n        self.c2_final = 2.7\n        self.velocity_clamp_initial = 0.8\n        self.velocity_clamp_final = 0.3\n        self.local_search_probability = 0.3  # Increased probability for local search\n        self.mutation_factor = 0.6  # Enhanced mutation factor for diversity\n        self.crossover_rate = 0.85  # Adjusted crossover rate\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "QuantumInspiredHybridOptimization", "description": "Quantum-Inspired Hybrid Optimization (QHO) combines quantum-inspired superposition states with enhanced differential evolution for improved exploration and convergence.", "configspace": "", "generation": 75, "fitness": 0.3327365907028977, "feedback": "The algorithm QuantumInspiredHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7181355739031029, 0.7181355739031029, 0.7181355739031029, 0.7036952644479508, 0.7036952644479508, 0.7036952644479508, 0.7317694882202112, 0.7317694882202112, 0.7317694882202112, 0.4192067187370858, 0.4192067187370858, 0.4192067187370858, 0.3902501083638975, 0.3902501083638975, 0.3902501083638975, 0.4110602521450655, 0.4110602521450655, 0.4110602521450655, 0.16431120349450934, 0.16431120349450934, 0.16431120349450934, 0.13151765311000785, 0.13151765311000785, 0.13151765311000785, 0.13035689227977088, 0.13035689227977088, 0.13035689227977088, 0.12525442349049098, 0.12525442349049098, 0.12525442349049098, 0.1452653700720059, 0.1452653700720059, 0.1452653700720059, 0.15388166681155202, 0.15388166681155202, 0.15388166681155202, 0.9177066238999433, 0.9177066238999433, 0.9177066238999433, 0.9177179464130784, 0.9177179464130784, 0.9177179464130784, 0.9302963294544063, 0.9302963294544063, 0.9302963294544063, 0.42238348005769955, 0.42238348005769955, 0.42238348005769955, 0.4485293464250918, 0.4485293464250918, 0.4485293464250918, 0.3883028290645816, 0.3883028290645816, 0.3883028290645816, 0.6613059336752791, 0.6613059336752791, 0.6613059336752791, 0.6704407498576224, 0.6704407498576224, 0.6704407498576224, 0.6586632533168082, 0.6586632533168082, 0.6586632533168082, 0.2708214080350061, 0.2708214080350061, 0.2708214080350061, 0.23045861237150433, 0.23045861237150433, 0.23045861237150433, 0.20018376102048763, 0.20018376102048763, 0.20018376102048763, 0.2085991381144362, 0.2085991381144362, 0.2085991381144362, 0.20419701869555051, 0.20419701869555051, 0.20419701869555051, 0.262177488438197, 0.262177488438197, 0.262177488438197, 0.07131764976585031, 0.07131764976585031, 0.07131764976585031, 0.04852986223229694, 0.04852986223229694, 0.04852986223229694, 0.036063822634704645, 0.036063822634704645, 0.036063822634704645, 0.2069715385074311, 0.2069715385074311, 0.2069715385074311, 0.17277287179512546, 0.17277287179512546, 0.17277287179512546, 0.20961131536368072, 0.20961131536368072, 0.20961131536368072, 0.06361961452968568, 0.06361961452968568, 0.06361961452968568, 0.10689245643805056, 0.10689245643805056, 0.10689245643805056, 0.10922724594206235, 0.10922724594206235, 0.10922724594206235, 0.197500433574756, 0.197500433574756, 0.197500433574756, 0.1265237341238632, 0.1265237341238632, 0.1265237341238632, 0.07934321164755054, 0.07934321164755054, 0.07934321164755054, 0.48766214379225703, 0.48766214379225703, 0.48766214379225703, 0.49353843974855804, 0.49353843974855804, 0.49353843974855804, 0.5075903273626763, 0.5075903273626763, 0.5075903273626763, 0.08172491850012398, 0.08172491850012398, 0.08172491850012398, 0.11678994378433438, 0.11678994378433438, 0.11678994378433438, 0.46730037868825314, 0.46730037868825314, 0.46730037868825314, 0.17749257902715598, 0.17749257902715598, 0.17749257902715598, 0.20578713674226645, 0.20578713674226645, 0.20578713674226645, 0.3302950534965934, 0.3302950534965934, 0.3302950534965934, 0.402505787560244, 0.402505787560244, 0.402505787560244, 0.3483479467699536, 0.3483479467699536, 0.3483479467699536, 0.39505975920998926, 0.39505975920998926, 0.39505975920998926, 0.24490696023029157, 0.24490696023029157, 0.24490696023029157, 0.2713617619566989, 0.2713617619566989, 0.2713617619566989, 0.31367774596666276, 0.31367774596666276, 0.31367774596666276, 0.22859600658018686, 0.22859600658018686, 0.22859600658018686, 0.21978556825480022, 0.21978556825480022, 0.21978556825480022, 0.2528873949561359, 0.2528873949561359, 0.2528873949561359, 0.18895958755628195, 0.18895958755628195, 0.18895958755628195, 0.21197332376780664, 0.21197332376780664, 0.21197332376780664, 0.19471185352955533, 0.19471185352955533, 0.19471185352955533, 0.813895618611536, 0.813895618611536, 0.813895618611536, 0.8539493622759929, 0.8539493622759929, 0.8539493622759929, 0.14160302600177677, 0.14160302600177677, 0.14160302600177677, 0.6898328620475859, 0.6898328620475859, 0.6898328620475859, 0.7626672817069817, 0.7626672817069817, 0.7626672817069817, 0.6039697825212591, 0.6039697825212591, 0.6039697825212591, 0.20007484052510127, 0.20007484052510127, 0.20007484052510127, 0.19135166551419103, 0.19135166551419103, 0.19135166551419103, 0.18524570866987777, 0.18524570866987777, 0.18524570866987777, 0.10873770083670187, 0.10873770083670187, 0.10873770083670187, 0.09475566957972481, 0.09475566957972481, 0.09475566957972481, 0.1251341043666787, 0.1251341043666787, 0.1251341043666787]}, "mutation_prompt": null}
{"id": "617c8867-2a9f-43d6-b5a7-43820a96d9e8", "solution": "import numpy as np\n\nclass SwarmInspiredAdaptiveDifferentialEvolution:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Slightly increased population size\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Tweaked inertia weight for more exploration\n        self.w_min = 0.2\n        self.c1_initial = 1.5\n        self.c2_initial = 2.0\n        self.c1_final = 2.0\n        self.c2_final = 3.0\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.3\n        self.local_search_probability = 0.25  # Increased probability for local search\n        self.mutation_factor = 0.6  # Slightly increased mutation factor\n        self.crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial + ((self.c1_final - self.c1_initial) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "SwarmInspiredAdaptiveDifferentialEvolution", "description": "Swarm-Inspired Adaptive Differential Evolution (SADE) combines adaptive particle dynamics with differential perturbation for robust global exploration and premature convergence prevention.", "configspace": "", "generation": 76, "fitness": 0.2990899174601462, "feedback": "The algorithm SwarmInspiredAdaptiveDifferentialEvolution got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7044090707125741, 0.7044090707125741, 0.7044090707125741, 0.712224032809134, 0.712224032809134, 0.712224032809134, 0.6400134748101143, 0.6400134748101143, 0.6400134748101143, 0.32663755093326097, 0.32663755093326097, 0.32663755093326097, 0.30984497611765704, 0.30984497611765704, 0.30984497611765704, 0.31032774672682883, 0.31032774672682883, 0.31032774672682883, 0.13791204726437467, 0.13791204726437467, 0.13791204726437467, 0.14084964762692254, 0.14084964762692254, 0.14084964762692254, 0.1302200690637335, 0.1302200690637335, 0.1302200690637335, 0.1383479334548542, 0.1383479334548542, 0.1383479334548542, 0.14818273110374724, 0.14818273110374724, 0.14818273110374724, 0.1674024046709306, 0.1674024046709306, 0.1674024046709306, 0.8918118574386316, 0.8918118574386316, 0.8918118574386316, 0.926026794294351, 0.926026794294351, 0.926026794294351, 0.9201884772092557, 0.9201884772092557, 0.9201884772092557, 0.3524254887809716, 0.3524254887809716, 0.3524254887809716, 0.3582491982598449, 0.3582491982598449, 0.3582491982598449, 0.3651876463925857, 0.3651876463925857, 0.3651876463925857, 0.5969585839549132, 0.5969585839549132, 0.5969585839549132, 0.30049336753669, 0.30049336753669, 0.30049336753669, 0.2846202793079543, 0.2846202793079543, 0.2846202793079543, 0.22276471251070196, 0.22276471251070196, 0.22276471251070196, 0.19106729875897077, 0.19106729875897077, 0.19106729875897077, 0.18009676057851298, 0.18009676057851298, 0.18009676057851298, 0.3384394939909554, 0.3384394939909554, 0.3384394939909554, 0.1798597788295403, 0.1798597788295403, 0.1798597788295403, 0.19154108324718833, 0.19154108324718833, 0.19154108324718833, 0.04117490548913261, 0.04117490548913261, 0.04117490548913261, 0.03641776181173795, 0.03641776181173795, 0.03641776181173795, 0.02592618482514486, 0.02592618482514486, 0.02592618482514486, 0.17922884920848914, 0.17922884920848914, 0.17922884920848914, 0.17856853406300321, 0.17856853406300321, 0.17856853406300321, 0.1411593659432272, 0.1411593659432272, 0.1411593659432272, 0.08846777277449269, 0.08846777277449269, 0.08846777277449269, 0.10785608659589507, 0.10785608659589507, 0.10785608659589507, 0.07626742842856926, 0.07626742842856926, 0.07626742842856926, 0.1668200023661076, 0.1668200023661076, 0.1668200023661076, 0.12883510751388294, 0.12883510751388294, 0.12883510751388294, 0.19214636990379008, 0.19214636990379008, 0.19214636990379008, 0.4643517218488332, 0.4643517218488332, 0.4643517218488332, 0.46041559770607077, 0.46041559770607077, 0.46041559770607077, 0.4821437533545936, 0.4821437533545936, 0.4821437533545936, 0.11288394003266189, 0.11288394003266189, 0.11288394003266189, 0.08960417941271204, 0.08960417941271204, 0.08960417941271204, 0.12415468737402535, 0.12415468737402535, 0.12415468737402535, 0.3300436214834196, 0.3300436214834196, 0.3300436214834196, 0.21222176353063094, 0.21222176353063094, 0.21222176353063094, 0.4252379738979698, 0.4252379738979698, 0.4252379738979698, 0.334442935259623, 0.334442935259623, 0.334442935259623, 0.3299037340660472, 0.3299037340660472, 0.3299037340660472, 0.22778338792427222, 0.22778338792427222, 0.22778338792427222, 0.2531246678953021, 0.2531246678953021, 0.2531246678953021, 0.28015360342671614, 0.28015360342671614, 0.28015360342671614, 0.2463475947974404, 0.2463475947974404, 0.2463475947974404, 0.2100608357389816, 0.2100608357389816, 0.2100608357389816, 0.24072533378903394, 0.24072533378903394, 0.24072533378903394, 0.2353524289854234, 0.2353524289854234, 0.2353524289854234, 0.2189486018234238, 0.2189486018234238, 0.2189486018234238, 0.20916807493744405, 0.20916807493744405, 0.20916807493744405, 0.21743613286073482, 0.21743613286073482, 0.21743613286073482, 0.18591397236738794, 0.18591397236738794, 0.18591397236738794, 0.8701175061312255, 0.8701175061312255, 0.8701175061312255, 0.7958104561306789, 0.7958104561306789, 0.7958104561306789, 0.6956675079911023, 0.6956675079911023, 0.6956675079911023, 0.20939747980194767, 0.20939747980194767, 0.20939747980194767, 0.6740314066939479, 0.6740314066939479, 0.6740314066939479, 0.20872939868574347, 0.20872939868574347, 0.20872939868574347, 0.1885069804419287, 0.1885069804419287, 0.1885069804419287, 0.18144643271869698, 0.18144643271869698, 0.18144643271869698, 0.0958274047948442, 0.0958274047948442, 0.0958274047948442, 0.09476003186010806, 0.09476003186010806, 0.09476003186010806, 0.10079003405888198, 0.10079003405888198, 0.10079003405888198]}, "mutation_prompt": null}
{"id": "676629bd-8535-414b-a24d-a078d245b518", "solution": "import numpy as np\n\nclass QuantumInspiredHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 2.0\n        self.c1_final = 1.2\n        self.c2_final = 2.8\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.2\n        self.local_search_probability = 0.25\n        self.mutation_factor = 0.6  # Differential mutation factor\n        self.crossover_rate = 0.8  # Crossover rate for differential evolution\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                quantum_velocity = np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])  # Quantum behavior\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component + quantum_velocity\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "QuantumInspiredHybridOptimization", "description": "Quantum-Inspired Particle Swarm Optimization with Differential Evolution for efficient exploration and exploitation balance.", "configspace": "", "generation": 77, "fitness": 0.2614463616341404, "feedback": "The algorithm QuantumInspiredHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.47282028717425495, 0.47282028717425495, 0.47282028717425495, 0.4453429557405181, 0.4453429557405181, 0.4453429557405181, 0.47454196517146674, 0.47454196517146674, 0.47454196517146674, 0.13743319344819538, 0.13743319344819538, 0.13743319344819538, 0.09810479745568612, 0.09810479745568612, 0.09810479745568612, 0.12708190750702142, 0.12708190750702142, 0.12708190750702142, 0.12023740001437855, 0.12023740001437855, 0.12023740001437855, 0.14671802866688, 0.14671802866688, 0.14671802866688, 0.104599100918504, 0.104599100918504, 0.104599100918504, 0.09334942697544335, 0.09334942697544335, 0.09334942697544335, 0.11567112160821402, 0.11567112160821402, 0.11567112160821402, 0.09918899953884097, 0.09918899953884097, 0.09918899953884097, 0.9398863287287356, 0.9398863287287356, 0.9398863287287356, 0.9452450737847946, 0.9452450737847946, 0.9452450737847946, 0.9379215119480473, 0.9379215119480473, 0.9379215119480473, 0.2936949498612078, 0.2936949498612078, 0.2936949498612078, 0.30546275175301985, 0.30546275175301985, 0.30546275175301985, 0.30273194005405835, 0.30273194005405835, 0.30273194005405835, 0.5583706756247773, 0.5583706756247773, 0.5583706756247773, 0.4589589837280611, 0.4589589837280611, 0.4589589837280611, 0.5552241641126736, 0.5552241641126736, 0.5552241641126736, 0.19387930195324254, 0.19387930195324254, 0.19387930195324254, 0.16627426581243432, 0.16627426581243432, 0.16627426581243432, 0.17246343188955038, 0.17246343188955038, 0.17246343188955038, 0.20895963849906118, 0.20895963849906118, 0.20895963849906118, 0.16970456253112676, 0.16970456253112676, 0.16970456253112676, 0.177819490400561, 0.177819490400561, 0.177819490400561, 0.03124689608567277, 0.03124689608567277, 0.03124689608567277, 0.05575379213563536, 0.05575379213563536, 0.05575379213563536, 0.07656983566816578, 0.07656983566816578, 0.07656983566816578, 0.21441041819612205, 0.21441041819612205, 0.21441041819612205, 0.1450927586230526, 0.1450927586230526, 0.1450927586230526, 0.19896141375536358, 0.19896141375536358, 0.19896141375536358, 0.0004072134004030614, 0.0004072134004030614, 0.0004072134004030614, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0002457832410822647, 0.0002457832410822647, 0.0002457832410822647, 0.11766136062106292, 0.11766136062106292, 0.11766136062106292, 0.11200656354973348, 0.11200656354973348, 0.11200656354973348, 0.11349688572765282, 0.11349688572765282, 0.11349688572765282, 0.4158413212656906, 0.4158413212656906, 0.4158413212656906, 0.42584970313745185, 0.42584970313745185, 0.42584970313745185, 0.4227247345743326, 0.4227247345743326, 0.4227247345743326, 0.12901039076054444, 0.12901039076054444, 0.12901039076054444, 0.13906838711172242, 0.13906838711172242, 0.13906838711172242, 0.0968424194591675, 0.0968424194591675, 0.0968424194591675, 0.24330800020414656, 0.24330800020414656, 0.24330800020414656, 0.19993342320680763, 0.19993342320680763, 0.19993342320680763, 0.15313606113631972, 0.15313606113631972, 0.15313606113631972, 0.29316306697265604, 0.29316306697265604, 0.29316306697265604, 0.2983211467539265, 0.2983211467539265, 0.2983211467539265, 0.29569706520820693, 0.29569706520820693, 0.29569706520820693, 0.22959213122050925, 0.22959213122050925, 0.22959213122050925, 0.24282688003844066, 0.24282688003844066, 0.24282688003844066, 0.2235041969834325, 0.2235041969834325, 0.2235041969834325, 0.2323897828416751, 0.2323897828416751, 0.2323897828416751, 0.23223247182750273, 0.23223247182750273, 0.23223247182750273, 0.2137647865069966, 0.2137647865069966, 0.2137647865069966, 0.19554998514966015, 0.19554998514966015, 0.19554998514966015, 0.29340924104421284, 0.29340924104421284, 0.29340924104421284, 0.23012511228112909, 0.23012511228112909, 0.23012511228112909, 0.6617037305978564, 0.6617037305978564, 0.6617037305978564, 0.7239479572392162, 0.7239479572392162, 0.7239479572392162, 0.17673464316850263, 0.17673464316850263, 0.17673464316850263, 0.6003045003346621, 0.6003045003346621, 0.6003045003346621, 0.20826152748451965, 0.20826152748451965, 0.20826152748451965, 0.5234613579400675, 0.5234613579400675, 0.5234613579400675, 0.17783588353032442, 0.17783588353032442, 0.17783588353032442, 0.17937148393881786, 0.17937148393881786, 0.17937148393881786, 0.2028396118853072, 0.2028396118853072, 0.2028396118853072, 0.09350436770022841, 0.09350436770022841, 0.09350436770022841, 0.09302583750688975, 0.09302583750688975, 0.09302583750688975, 0.08921765274248306, 0.08921765274248306, 0.08921765274248306]}, "mutation_prompt": null}
{"id": "08c38867-6ddd-417c-b06a-5c057dafe1ad", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_probability = 0.25\n        self.annealing_factor = 0.99\n        self.initial_temperature = 1.0\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        temperature = self.initial_temperature\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                neighbors = np.random.choice(self.num_particles, 3, replace=False)\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = neighbors\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i] or np.exp((personal_best_scores[i] - trial_score) / temperature) > np.random.rand():\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                    if trial_score < global_best_score:\n                        global_best_score = trial_score\n                        global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)\n            \n            temperature *= self.annealing_factor", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) integrating dynamic topology adaptation with simulated annealing for improved exploration-exploitation balance.", "configspace": "", "generation": 78, "fitness": -Infinity, "feedback": "An exception occurred: AttributeError(\"'EnhancedAdaptiveHybridOptimization' object has no attribute 'mutation_factor'\").", "error": "AttributeError(\"'EnhancedAdaptiveHybridOptimization' object has no attribute 'mutation_factor'\")", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {}, "mutation_prompt": null}
{"id": "05263f8c-7beb-4d96-9a96-900ccd242a8d", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Adjusted for better inertia control\n        self.w_min = 0.4\n        self.c1_initial = 2.2  # Slightly increased to boost cognitive attraction\n        self.c2_initial = 1.7\n        self.c1_final = 1.3\n        self.c2_final = 2.8  # Enhanced social attraction towards the end\n        self.velocity_clamp_initial = 0.8\n        self.velocity_clamp_final = 0.3\n        self.local_search_probability = 0.25  # Increased chance for local search\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.85  # Adjusted for balancing exploration-exploitation\n        self.quantum_factor = 0.05  # New parameter for quantum-inspired adjustment\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                quantum_effect = self.quantum_factor * np.random.normal(0, 1, self.dim)  # Quantum-inspired adjustment\n                velocities[i] += quantum_effect\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "QuantumInspiredAdaptiveHybridOptimization", "description": "Quantum-Inspired Adaptive Hybrid Optimization (QAHO) leveraging quantum superposition for enhanced exploration in PSO and differential evolution.", "configspace": "", "generation": 79, "fitness": 0.25973802394447737, "feedback": "The algorithm QuantumInspiredAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.22.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.4986587411705288, 0.4986587411705288, 0.4986587411705288, 0.45871350770843944, 0.45871350770843944, 0.45871350770843944, 0.4589903015074728, 0.4589903015074728, 0.4589903015074728, 0.12552994404217277, 0.12552994404217277, 0.12552994404217277, 0.09658283541936452, 0.09658283541936452, 0.09658283541936452, 0.09949874606562426, 0.09949874606562426, 0.09949874606562426, 0.14285372618521086, 0.14285372618521086, 0.14285372618521086, 0.12869731776475113, 0.12869731776475113, 0.12869731776475113, 0.08814367194486472, 0.08814367194486472, 0.08814367194486472, 0.0987549094772685, 0.0987549094772685, 0.0987549094772685, 0.12457229041394313, 0.12457229041394313, 0.12457229041394313, 0.09846114673226403, 0.09846114673226403, 0.09846114673226403, 0.9329440459431303, 0.9329440459431303, 0.9329440459431303, 0.9270144929759677, 0.9270144929759677, 0.9270144929759677, 0.9071063370244475, 0.9071063370244475, 0.9071063370244475, 0.3118966854310613, 0.3118966854310613, 0.3118966854310613, 0.30221913593385674, 0.30221913593385674, 0.30221913593385674, 0.3075794724370444, 0.3075794724370444, 0.3075794724370444, 0.6112961917143144, 0.6112961917143144, 0.6112961917143144, 0.5492290181970116, 0.5492290181970116, 0.5492290181970116, 0.5140255303870995, 0.5140255303870995, 0.5140255303870995, 0.18605886060628096, 0.18605886060628096, 0.18605886060628096, 0.14005624519575, 0.14005624519575, 0.14005624519575, 0.1748686632039993, 0.1748686632039993, 0.1748686632039993, 0.19235013685224034, 0.19235013685224034, 0.19235013685224034, 0.18391546522361657, 0.18391546522361657, 0.18391546522361657, 0.17994396295092918, 0.17994396295092918, 0.17994396295092918, 0.06369473819747051, 0.06369473819747051, 0.06369473819747051, 0.0674122985972152, 0.0674122985972152, 0.0674122985972152, 0.06730163543712808, 0.06730163543712808, 0.06730163543712808, 0.20601001087384252, 0.20601001087384252, 0.20601001087384252, 0.15943505446886141, 0.15943505446886141, 0.15943505446886141, 0.17318569419043028, 0.17318569419043028, 0.17318569419043028, 0.001940384793235883, 0.001940384793235883, 0.001940384793235883, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.009789439934082433, 0.009789439934082433, 0.009789439934082433, 0.1217094008202132, 0.1217094008202132, 0.1217094008202132, 0.12073303760133913, 0.12073303760133913, 0.12073303760133913, 0.12037463894084632, 0.12037463894084632, 0.12037463894084632, 0.4441031476084031, 0.4441031476084031, 0.4441031476084031, 0.44840635640980986, 0.44840635640980986, 0.44840635640980986, 0.435181407733763, 0.435181407733763, 0.435181407733763, 0.09143245223385932, 0.09143245223385932, 0.09143245223385932, 0.10702382763110019, 0.10702382763110019, 0.10702382763110019, 0.1260121048622721, 0.1260121048622721, 0.1260121048622721, 0.15627846345692464, 0.15627846345692464, 0.15627846345692464, 0.15265641289860143, 0.15265641289860143, 0.15265641289860143, 0.16063646202585857, 0.16063646202585857, 0.16063646202585857, 0.30889560250538406, 0.30889560250538406, 0.30889560250538406, 0.29798803687464803, 0.29798803687464803, 0.29798803687464803, 0.3010698709418702, 0.3010698709418702, 0.3010698709418702, 0.21916778891100985, 0.21916778891100985, 0.21916778891100985, 0.24464808655235215, 0.24464808655235215, 0.24464808655235215, 0.23532026359818203, 0.23532026359818203, 0.23532026359818203, 0.22418931889107174, 0.22418931889107174, 0.22418931889107174, 0.21686177737308232, 0.21686177737308232, 0.21686177737308232, 0.24389095682503648, 0.24389095682503648, 0.24389095682503648, 0.20044782561035956, 0.20044782561035956, 0.20044782561035956, 0.21735760320732256, 0.21735760320732256, 0.21735760320732256, 0.20068219289058375, 0.20068219289058375, 0.20068219289058375, 0.1746170216414311, 0.1746170216414311, 0.1746170216414311, 0.7199199570772585, 0.7199199570772585, 0.7199199570772585, 0.14138434322187554, 0.14138434322187554, 0.14138434322187554, 0.630982449550116, 0.630982449550116, 0.630982449550116, 0.6601974117030087, 0.6601974117030087, 0.6601974117030087, 0.5926901438512178, 0.5926901438512178, 0.5926901438512178, 0.18518607116548325, 0.18518607116548325, 0.18518607116548325, 0.18673918152273516, 0.18673918152273516, 0.18673918152273516, 0.18246800244496753, 0.18246800244496753, 0.18246800244496753, 0.07474594518814082, 0.07474594518814082, 0.07474594518814082, 0.08360908360884023, 0.08360908360884023, 0.08360908360884023, 0.08470043762248292, 0.08470043762248292, 0.08470043762248292]}, "mutation_prompt": null}
{"id": "19f83e22-944c-4d4b-bfbf-2509fb697a20", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_probability = 0.2\n        self.mutation_factor = 0.5  # Differential mutation factor\n        self.crossover_rate = 0.9  # Crossover rate for differential evolution\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "AdaptiveHybridOptimization", "description": "Adaptive Hybrid Optimization (AHO) combining particle swarm dynamics with differential evolution for enhanced diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7895836015197397, 0.7895836015197397, 0.7895836015197397, 0.7946939659872195, 0.7946939659872195, 0.7946939659872195, 0.7827185030060426, 0.7827185030060426, 0.7827185030060426, 0.5581754454568489, 0.5581754454568489, 0.5581754454568489, 0.574857286697678, 0.574857286697678, 0.574857286697678, 0.5566457282797854, 0.5566457282797854, 0.5566457282797854, 0.17464627716960057, 0.17464627716960057, 0.17464627716960057, 0.1166444184302361, 0.1166444184302361, 0.1166444184302361, 0.11687482365635138, 0.11687482365635138, 0.11687482365635138, 0.13365689645103163, 0.13365689645103163, 0.13365689645103163, 0.15728296835600997, 0.15728296835600997, 0.15728296835600997, 0.11315853967223444, 0.11315853967223444, 0.11315853967223444, 0.939123796775058, 0.939123796775058, 0.939123796775058, 0.9293789576951788, 0.9293789576951788, 0.9293789576951788, 0.928710751654857, 0.928710751654857, 0.928710751654857, 0.4894503000255258, 0.4894503000255258, 0.4894503000255258, 0.5103152794355856, 0.5103152794355856, 0.5103152794355856, 0.47916012461591806, 0.47916012461591806, 0.47916012461591806, 0.8545918793380147, 0.8545918793380147, 0.8545918793380147, 0.7546022019729164, 0.7546022019729164, 0.7546022019729164, 0.6982566528891132, 0.6982566528891132, 0.6982566528891132, 0.19614203018179022, 0.19614203018179022, 0.19614203018179022, 0.2168586275342569, 0.2168586275342569, 0.2168586275342569, 0.20369001311330848, 0.20369001311330848, 0.20369001311330848, 0.132991816190819, 0.132991816190819, 0.132991816190819, 0.2200528903526182, 0.2200528903526182, 0.2200528903526182, 0.2541679426183254, 0.2541679426183254, 0.2541679426183254, 0.05313909309388709, 0.05313909309388709, 0.05313909309388709, 0.0942862222464832, 0.0942862222464832, 0.0942862222464832, 0.05322492539476953, 0.05322492539476953, 0.05322492539476953, 0.20426992583527892, 0.20426992583527892, 0.20426992583527892, 0.1728343595006363, 0.1728343595006363, 0.1728343595006363, 0.15438215489718898, 0.15438215489718898, 0.15438215489718898, 0.07088574780650558, 0.07088574780650558, 0.07088574780650558, 0.15239007691748085, 0.15239007691748085, 0.15239007691748085, 0.09376040974467525, 0.09376040974467525, 0.09376040974467525, 0.1777896452539588, 0.1777896452539588, 0.1777896452539588, 0.1628951900566381, 0.1628951900566381, 0.1628951900566381, 0.07978427742195893, 0.07978427742195893, 0.07978427742195893, 0.5204904934952671, 0.5204904934952671, 0.5204904934952671, 0.5526658242353327, 0.5526658242353327, 0.5526658242353327, 0.5313657011976667, 0.5313657011976667, 0.5313657011976667, 0.09446891363605114, 0.09446891363605114, 0.09446891363605114, 0.10082884432785666, 0.10082884432785666, 0.10082884432785666, 0.15506941409652442, 0.15506941409652442, 0.15506941409652442, 0.2074271186152098, 0.2074271186152098, 0.2074271186152098, 0.2959668217386152, 0.2959668217386152, 0.2959668217386152, 0.3791244445331239, 0.3791244445331239, 0.3791244445331239, 0.40770683646633, 0.40770683646633, 0.40770683646633, 0.461536616982939, 0.461536616982939, 0.461536616982939, 0.46257700593028883, 0.46257700593028883, 0.46257700593028883, 0.21902107551280947, 0.21902107551280947, 0.21902107551280947, 0.3563258561221383, 0.3563258561221383, 0.3563258561221383, 0.2474680005978266, 0.2474680005978266, 0.2474680005978266, 0.20417258914390446, 0.20417258914390446, 0.20417258914390446, 0.22729678098722805, 0.22729678098722805, 0.22729678098722805, 0.22314842379469357, 0.22314842379469357, 0.22314842379469357, 0.21588487370922083, 0.21588487370922083, 0.21588487370922083, 0.22100840205041583, 0.22100840205041583, 0.22100840205041583, 0.24216124021531737, 0.24216124021531737, 0.24216124021531737, 0.8375012045719195, 0.8375012045719195, 0.8375012045719195, 0.9090806808219745, 0.9090806808219745, 0.9090806808219745, 0.1418618374584506, 0.1418618374584506, 0.1418618374584506, 0.7905978270547784, 0.7905978270547784, 0.7905978270547784, 0.7569990490845664, 0.7569990490845664, 0.7569990490845664, 0.21082535228295762, 0.21082535228295762, 0.21082535228295762, 0.1974656061574156, 0.1974656061574156, 0.1974656061574156, 0.1848299648349595, 0.1848299648349595, 0.1848299648349595, 0.18760627427163612, 0.18760627427163612, 0.18760627427163612, 0.08880660277206842, 0.08880660277206842, 0.08880660277206842, 0.10952451462961632, 0.10952451462961632, 0.10952451462961632, 0.08795370521342216, 0.08795370521342216, 0.08795370521342216]}, "mutation_prompt": null}
{"id": "e5733f8f-ff3e-41da-ba53-93fa97e77c7a", "solution": "import numpy as np\n\nclass QuantumInspiredAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.2\n        self.c1_initial = 2.2\n        self.c2_initial = 1.7\n        self.c1_final = 1.4\n        self.c2_final = 2.6\n        self.velocity_clamp_initial = 0.85\n        self.velocity_clamp_final = 0.3\n        self.local_search_probability = 0.25\n        self.mutation_factor = 0.6  # Differential mutation factor\n        self.crossover_rate = 0.85  # Crossover rate for differential evolution\n        self.quantum_prob = 0.05  # Probability of quantum-inspired update\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n\n                if np.random.rand() < self.quantum_prob:\n                    velocities[i] += np.random.uniform(-0.1, 0.1, self.dim) * (global_best_position - positions[i])\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "QuantumInspiredAdaptiveHybridOptimization", "description": "Quantum-Inspired Adaptive Hybrid Optimization (QAHO) integrating quantum superposition principles with adaptive dynamics for enhanced exploration and convergence.", "configspace": "", "generation": 81, "fitness": 0.33396952657357, "feedback": "The algorithm QuantumInspiredAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.24.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7206584826067635, 0.7206584826067635, 0.7206584826067635, 0.7511906270359132, 0.7511906270359132, 0.7511906270359132, 0.7314228771153821, 0.7314228771153821, 0.7314228771153821, 0.48069482271499353, 0.48069482271499353, 0.48069482271499353, 0.4917621359460518, 0.4917621359460518, 0.4917621359460518, 0.49081971963132365, 0.49081971963132365, 0.49081971963132365, 0.11486770084406017, 0.11486770084406017, 0.11486770084406017, 0.14185660991588234, 0.14185660991588234, 0.14185660991588234, 0.11074028895094834, 0.11074028895094834, 0.11074028895094834, 0.1381113544372229, 0.1381113544372229, 0.1381113544372229, 0.13266029870417784, 0.13266029870417784, 0.13266029870417784, 0.14362538372164713, 0.14362538372164713, 0.14362538372164713, 0.94583940603049, 0.94583940603049, 0.94583940603049, 0.9011111218851187, 0.9011111218851187, 0.9011111218851187, 0.9489800289696441, 0.9489800289696441, 0.9489800289696441, 0.4414489802637802, 0.4414489802637802, 0.4414489802637802, 0.4937545192670002, 0.4937545192670002, 0.4937545192670002, 0.4537037038202283, 0.4537037038202283, 0.4537037038202283, 0.6035681107098898, 0.6035681107098898, 0.6035681107098898, 0.2172741071405564, 0.2172741071405564, 0.2172741071405564, 0.5616195636554657, 0.5616195636554657, 0.5616195636554657, 0.1818657028570343, 0.1818657028570343, 0.1818657028570343, 0.12627973831268025, 0.12627973831268025, 0.12627973831268025, 0.20831950597544047, 0.20831950597544047, 0.20831950597544047, 0.21075880298012217, 0.21075880298012217, 0.21075880298012217, 0.2185041131115919, 0.2185041131115919, 0.2185041131115919, 0.21340768268009014, 0.21340768268009014, 0.21340768268009014, 0.06991320685260649, 0.06991320685260649, 0.06991320685260649, 0.06501159043749538, 0.06501159043749538, 0.06501159043749538, 0.04272968533274213, 0.04272968533274213, 0.04272968533274213, 0.21283851290961242, 0.21283851290961242, 0.21283851290961242, 0.1575126430590308, 0.1575126430590308, 0.1575126430590308, 0.19051062643770122, 0.19051062643770122, 0.19051062643770122, 0.141382396608297, 0.141382396608297, 0.141382396608297, 0.17759080477932698, 0.17759080477932698, 0.17759080477932698, 0.05519896604210006, 0.05519896604210006, 0.05519896604210006, 0.23784303218544034, 0.23784303218544034, 0.23784303218544034, 0.11833644671752663, 0.11833644671752663, 0.11833644671752663, 0.1496999458328956, 0.1496999458328956, 0.1496999458328956, 0.5031419030592287, 0.5031419030592287, 0.5031419030592287, 0.5006926974089003, 0.5006926974089003, 0.5006926974089003, 0.4932789702986019, 0.4932789702986019, 0.4932789702986019, 0.09480744232186811, 0.09480744232186811, 0.09480744232186811, 0.14061458472925803, 0.14061458472925803, 0.14061458472925803, 0.1212142301395217, 0.1212142301395217, 0.1212142301395217, 0.24123231197935058, 0.24123231197935058, 0.24123231197935058, 0.3738156288612823, 0.3738156288612823, 0.3738156288612823, 0.35652965065099596, 0.35652965065099596, 0.35652965065099596, 0.3922966187752701, 0.3922966187752701, 0.3922966187752701, 0.438201563741767, 0.438201563741767, 0.438201563741767, 0.42876263004010884, 0.42876263004010884, 0.42876263004010884, 0.2464387970345424, 0.2464387970345424, 0.2464387970345424, 0.3277870666705409, 0.3277870666705409, 0.3277870666705409, 0.23813032802711065, 0.23813032802711065, 0.23813032802711065, 0.24862695239728427, 0.24862695239728427, 0.24862695239728427, 0.2540895798069426, 0.2540895798069426, 0.2540895798069426, 0.2517254742944389, 0.2517254742944389, 0.2517254742944389, 0.21597058518623402, 0.21597058518623402, 0.21597058518623402, 0.24258856810204144, 0.24258856810204144, 0.24258856810204144, 0.21986137480334678, 0.21986137480334678, 0.21986137480334678, 0.8127586914472262, 0.8127586914472262, 0.8127586914472262, 0.8507163972379743, 0.8507163972379743, 0.8507163972379743, 0.141548421814916, 0.141548421814916, 0.141548421814916, 0.7515208060352647, 0.7515208060352647, 0.7515208060352647, 0.7231503847523586, 0.7231503847523586, 0.7231503847523586, 0.7672676808705502, 0.7672676808705502, 0.7672676808705502, 0.1952330981400474, 0.1952330981400474, 0.1952330981400474, 0.1906546077318727, 0.1906546077318727, 0.1906546077318727, 0.17844621496411817, 0.17844621496411817, 0.17844621496411817, 0.12146482637601275, 0.12146482637601275, 0.12146482637601275, 0.1013453566219854, 0.1013453566219854, 0.1013453566219854, 0.08847922249780438, 0.08847922249780438, 0.08847922249780438]}, "mutation_prompt": null}
{"id": "8fffc229-9d2a-4c22-be66-1f074945559b", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0\n        self.c1_final = 1.7\n        self.c2_final = 2.3\n        self.velocity_clamp_initial = 0.8\n        self.velocity_clamp_final = 0.2\n        self.local_search_probability = 0.25\n        self.mutation_factor_initial = 0.8\n        self.mutation_factor_final = 0.3\n        self.crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n            mutation_factor = self.mutation_factor_initial - ((self.mutation_factor_initial - self.mutation_factor_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) that integrates adaptive mutation scaling, inertia weight scheduling, and crossover strategies for improved exploration and exploitation.", "configspace": "", "generation": 82, "fitness": 0.2794114259945885, "feedback": "The algorithm EnhancedAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.21.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.5653227208360894, 0.5653227208360894, 0.5653227208360894, 0.5584898109833716, 0.5584898109833716, 0.5584898109833716, 0.5759820326968415, 0.5759820326968415, 0.5759820326968415, 0.21888897439283106, 0.21888897439283106, 0.21888897439283106, 0.2059575496986824, 0.2059575496986824, 0.2059575496986824, 0.22441828706691347, 0.22441828706691347, 0.22441828706691347, 0.15689441978013396, 0.15689441978013396, 0.15689441978013396, 0.11418628075553239, 0.11418628075553239, 0.11418628075553239, 0.09871936102715428, 0.09871936102715428, 0.09871936102715428, 0.08797271299155596, 0.08797271299155596, 0.08797271299155596, 0.15060609005781278, 0.15060609005781278, 0.15060609005781278, 0.10956817739530655, 0.10956817739530655, 0.10956817739530655, 0.8854862557954881, 0.8854862557954881, 0.8854862557954881, 0.9076995265266719, 0.9076995265266719, 0.9076995265266719, 0.8994825086863967, 0.8994825086863967, 0.8994825086863967, 0.3609518595901011, 0.3609518595901011, 0.3609518595901011, 0.3596897890833348, 0.3596897890833348, 0.3596897890833348, 0.3602658450900995, 0.3602658450900995, 0.3602658450900995, 0.5297288826070387, 0.5297288826070387, 0.5297288826070387, 0.20861102987055846, 0.20861102987055846, 0.20861102987055846, 0.5130535965788648, 0.5130535965788648, 0.5130535965788648, 0.11969946606193116, 0.11969946606193116, 0.11969946606193116, 0.250365514453724, 0.250365514453724, 0.250365514453724, 0.18004194117833994, 0.18004194117833994, 0.18004194117833994, 0.24436866844263294, 0.24436866844263294, 0.24436866844263294, 0.16611210089870287, 0.16611210089870287, 0.16611210089870287, 0.2412431995241403, 0.2412431995241403, 0.2412431995241403, 0.05625519855630534, 0.05625519855630534, 0.05625519855630534, 0.04505520984255329, 0.04505520984255329, 0.04505520984255329, 0.04342599372219336, 0.04342599372219336, 0.04342599372219336, 0.1851613247920072, 0.1851613247920072, 0.1851613247920072, 0.133621486195457, 0.133621486195457, 0.133621486195457, 0.18427044699964845, 0.18427044699964845, 0.18427044699964845, 0.05157218458416324, 0.05157218458416324, 0.05157218458416324, 0.033439953686834056, 0.033439953686834056, 0.033439953686834056, 0.04638801801717729, 0.04638801801717729, 0.04638801801717729, 0.1390329892268365, 0.1390329892268365, 0.1390329892268365, 0.1080362984595018, 0.1080362984595018, 0.1080362984595018, 0.11791560828443215, 0.11791560828443215, 0.11791560828443215, 0.4456338546880457, 0.4456338546880457, 0.4456338546880457, 0.46086852019527136, 0.46086852019527136, 0.46086852019527136, 0.4786190290074718, 0.4786190290074718, 0.4786190290074718, 0.110426878858083, 0.110426878858083, 0.110426878858083, 0.13846223901828758, 0.13846223901828758, 0.13846223901828758, 0.11249772004407055, 0.11249772004407055, 0.11249772004407055, 0.2979733691067973, 0.2979733691067973, 0.2979733691067973, 0.2978883164576843, 0.2978883164576843, 0.2978883164576843, 0.27077010204743623, 0.27077010204743623, 0.27077010204743623, 0.33185554020368446, 0.33185554020368446, 0.33185554020368446, 0.344985159660012, 0.344985159660012, 0.344985159660012, 0.22779583551284477, 0.22779583551284477, 0.22779583551284477, 0.24191547806525315, 0.24191547806525315, 0.24191547806525315, 0.2648511722108491, 0.2648511722108491, 0.2648511722108491, 0.2670215677813238, 0.2670215677813238, 0.2670215677813238, 0.23008477201976518, 0.23008477201976518, 0.23008477201976518, 0.21714628810109848, 0.21714628810109848, 0.21714628810109848, 0.2235055799558222, 0.2235055799558222, 0.2235055799558222, 0.19555791160724434, 0.19555791160724434, 0.19555791160724434, 0.1989099109251582, 0.1989099109251582, 0.1989099109251582, 0.25519184854560917, 0.25519184854560917, 0.25519184854560917, 0.17575500995104687, 0.17575500995104687, 0.17575500995104687, 0.7952959142807114, 0.7952959142807114, 0.7952959142807114, 0.734979557194555, 0.734979557194555, 0.734979557194555, 0.7274430980817175, 0.7274430980817175, 0.7274430980817175, 0.5659007929182481, 0.5659007929182481, 0.5659007929182481, 0.20516014954690864, 0.20516014954690864, 0.20516014954690864, 0.18863996476491052, 0.18863996476491052, 0.18863996476491052, 0.18235733166696233, 0.18235733166696233, 0.18235733166696233, 0.1893811285033815, 0.1893811285033815, 0.1893811285033815, 0.08703186384227424, 0.08703186384227424, 0.08703186384227424, 0.08779869595903178, 0.08779869595903178, 0.08779869595903178, 0.12793675645145375, 0.12793675645145375, 0.12793675645145375]}, "mutation_prompt": null}
{"id": "9e266214-7248-450c-9cce-3792a1204d1f", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.2\n        self.c2_initial = 1.5\n        self.c1_final = 1.3\n        self.c2_final = 2.7\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.2\n        self.local_search_probability = 0.3\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.85\n        self.chaos_factor = 0.7\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector += self.chaos_factor * np.sin(np.pi * trial_vector)\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) introducing a chaotic map for improved exploration and convergence control.", "configspace": "", "generation": 83, "fitness": 0.2790260334985302, "feedback": "The algorithm EnhancedAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.28 with standard deviation 0.22.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.6114392292107433, 0.6114392292107433, 0.6114392292107433, 0.6437903121055175, 0.6437903121055175, 0.6437903121055175, 0.6149134820448336, 0.6149134820448336, 0.6149134820448336, 0.27467254794625984, 0.27467254794625984, 0.27467254794625984, 0.23933094823134704, 0.23933094823134704, 0.23933094823134704, 0.2324383196280264, 0.2324383196280264, 0.2324383196280264, 0.265842848444917, 0.265842848444917, 0.265842848444917, 0.1409740638287731, 0.1409740638287731, 0.1409740638287731, 0.0911899750470182, 0.0911899750470182, 0.0911899750470182, 0.10145980397496879, 0.10145980397496879, 0.10145980397496879, 0.1232080720387354, 0.1232080720387354, 0.1232080720387354, 0.13400292043132522, 0.13400292043132522, 0.13400292043132522, 0.9409877757134025, 0.9409877757134025, 0.9409877757134025, 0.9473143859097918, 0.9473143859097918, 0.9473143859097918, 0.9465207026958967, 0.9465207026958967, 0.9465207026958967, 0.33962224330163315, 0.33962224330163315, 0.33962224330163315, 0.33626936997689694, 0.33626936997689694, 0.33626936997689694, 0.35621005620524304, 0.35621005620524304, 0.35621005620524304, 0.22861789715383396, 0.22861789715383396, 0.22861789715383396, 0.21837366302387728, 0.21837366302387728, 0.21837366302387728, 0.21784537877013765, 0.21784537877013765, 0.21784537877013765, 0.17411148667686172, 0.17411148667686172, 0.17411148667686172, 0.18283082817371465, 0.18283082817371465, 0.18283082817371465, 0.1897552326532579, 0.1897552326532579, 0.1897552326532579, 0.20880392625512256, 0.20880392625512256, 0.20880392625512256, 0.12310987645901916, 0.12310987645901916, 0.12310987645901916, 0.20512281708942826, 0.20512281708942826, 0.20512281708942826, 0.05970147170731055, 0.05970147170731055, 0.05970147170731055, 0.02706061212684563, 0.02706061212684563, 0.02706061212684563, 0.01397428165723924, 0.01397428165723924, 0.01397428165723924, 0.1764774931031079, 0.1764774931031079, 0.1764774931031079, 0.0677226741296032, 0.0677226741296032, 0.0677226741296032, 0.09999813300336413, 0.09999813300336413, 0.09999813300336413, 0.023098347902313243, 0.023098347902313243, 0.023098347902313243, 0.04219132721652763, 0.04219132721652763, 0.04219132721652763, 0.06744523459728957, 0.06744523459728957, 0.06744523459728957, 0.1589587408134021, 0.1589587408134021, 0.1589587408134021, 0.1739935183482645, 0.1739935183482645, 0.1739935183482645, 0.07573021703014349, 0.07573021703014349, 0.07573021703014349, 0.4650165596576762, 0.4650165596576762, 0.4650165596576762, 0.48433641031261654, 0.48433641031261654, 0.48433641031261654, 0.4575362405911927, 0.4575362405911927, 0.4575362405911927, 0.09663027221998233, 0.09663027221998233, 0.09663027221998233, 0.29606428433887555, 0.29606428433887555, 0.29606428433887555, 0.12928011423605967, 0.12928011423605967, 0.12928011423605967, 0.16427464844908535, 0.16427464844908535, 0.16427464844908535, 0.24269174772647617, 0.24269174772647617, 0.24269174772647617, 0.2508633330354242, 0.2508633330354242, 0.2508633330354242, 0.3072271277999461, 0.3072271277999461, 0.3072271277999461, 0.35046521108533457, 0.35046521108533457, 0.35046521108533457, 0.3299858070255357, 0.3299858070255357, 0.3299858070255357, 0.2918514579264462, 0.2918514579264462, 0.2918514579264462, 0.30361396874196167, 0.30361396874196167, 0.30361396874196167, 0.29815926078812083, 0.29815926078812083, 0.29815926078812083, 0.20258990265964671, 0.20258990265964671, 0.20258990265964671, 0.2105511423663574, 0.2105511423663574, 0.2105511423663574, 0.2103105583350836, 0.2103105583350836, 0.2103105583350836, 0.21463465322479736, 0.21463465322479736, 0.21463465322479736, 0.21110557270355468, 0.21110557270355468, 0.21110557270355468, 0.2378396623403003, 0.2378396623403003, 0.2378396623403003, 0.18595270547307685, 0.18595270547307685, 0.18595270547307685, 0.7480770633016366, 0.7480770633016366, 0.7480770633016366, 0.7140164136104837, 0.7140164136104837, 0.7140164136104837, 0.5429598617445712, 0.5429598617445712, 0.5429598617445712, 0.6473897247412402, 0.6473897247412402, 0.6473897247412402, 0.5985306558695938, 0.5985306558695938, 0.5985306558695938, 0.1799422331561138, 0.1799422331561138, 0.1799422331561138, 0.18266119042144924, 0.18266119042144924, 0.18266119042144924, 0.1854318529467046, 0.1854318529467046, 0.1854318529467046, 0.0982992414198659, 0.0982992414198659, 0.0982992414198659, 0.08974966056853717, 0.08974966056853717, 0.08974966056853717, 0.08672565845043645, 0.08672565845043645, 0.08672565845043645]}, "mutation_prompt": null}
{"id": "95add460-8e1c-423e-ae47-33862938d634", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_probability = 0.2\n        self.mutation_factor = 0.5  # Differential mutation factor\n        self.crossover_rate = 0.9  # Crossover rate for differential evolution\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "AdaptiveHybridOptimization", "description": "Adaptive Hybrid Optimization (AHO) combining particle swarm dynamics with differential evolution for enhanced diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7895836015197397, 0.7895836015197397, 0.7895836015197397, 0.7946939659872195, 0.7946939659872195, 0.7946939659872195, 0.7827185030060426, 0.7827185030060426, 0.7827185030060426, 0.5581754454568489, 0.5581754454568489, 0.5581754454568489, 0.574857286697678, 0.574857286697678, 0.574857286697678, 0.5566457282797854, 0.5566457282797854, 0.5566457282797854, 0.17464627716960057, 0.17464627716960057, 0.17464627716960057, 0.1166444184302361, 0.1166444184302361, 0.1166444184302361, 0.11687482365635138, 0.11687482365635138, 0.11687482365635138, 0.13365689645103163, 0.13365689645103163, 0.13365689645103163, 0.15728296835600997, 0.15728296835600997, 0.15728296835600997, 0.11315853967223444, 0.11315853967223444, 0.11315853967223444, 0.939123796775058, 0.939123796775058, 0.939123796775058, 0.9293789576951788, 0.9293789576951788, 0.9293789576951788, 0.928710751654857, 0.928710751654857, 0.928710751654857, 0.4894503000255258, 0.4894503000255258, 0.4894503000255258, 0.5103152794355856, 0.5103152794355856, 0.5103152794355856, 0.47916012461591806, 0.47916012461591806, 0.47916012461591806, 0.8545918793380147, 0.8545918793380147, 0.8545918793380147, 0.7546022019729164, 0.7546022019729164, 0.7546022019729164, 0.6982566528891132, 0.6982566528891132, 0.6982566528891132, 0.19614203018179022, 0.19614203018179022, 0.19614203018179022, 0.2168586275342569, 0.2168586275342569, 0.2168586275342569, 0.20369001311330848, 0.20369001311330848, 0.20369001311330848, 0.132991816190819, 0.132991816190819, 0.132991816190819, 0.2200528903526182, 0.2200528903526182, 0.2200528903526182, 0.2541679426183254, 0.2541679426183254, 0.2541679426183254, 0.05313909309388709, 0.05313909309388709, 0.05313909309388709, 0.0942862222464832, 0.0942862222464832, 0.0942862222464832, 0.05322492539476953, 0.05322492539476953, 0.05322492539476953, 0.20426992583527892, 0.20426992583527892, 0.20426992583527892, 0.1728343595006363, 0.1728343595006363, 0.1728343595006363, 0.15438215489718898, 0.15438215489718898, 0.15438215489718898, 0.07088574780650558, 0.07088574780650558, 0.07088574780650558, 0.15239007691748085, 0.15239007691748085, 0.15239007691748085, 0.09376040974467525, 0.09376040974467525, 0.09376040974467525, 0.1777896452539588, 0.1777896452539588, 0.1777896452539588, 0.1628951900566381, 0.1628951900566381, 0.1628951900566381, 0.07978427742195893, 0.07978427742195893, 0.07978427742195893, 0.5204904934952671, 0.5204904934952671, 0.5204904934952671, 0.5526658242353327, 0.5526658242353327, 0.5526658242353327, 0.5313657011976667, 0.5313657011976667, 0.5313657011976667, 0.09446891363605114, 0.09446891363605114, 0.09446891363605114, 0.10082884432785666, 0.10082884432785666, 0.10082884432785666, 0.15506941409652442, 0.15506941409652442, 0.15506941409652442, 0.2074271186152098, 0.2074271186152098, 0.2074271186152098, 0.2959668217386152, 0.2959668217386152, 0.2959668217386152, 0.3791244445331239, 0.3791244445331239, 0.3791244445331239, 0.40770683646633, 0.40770683646633, 0.40770683646633, 0.461536616982939, 0.461536616982939, 0.461536616982939, 0.46257700593028883, 0.46257700593028883, 0.46257700593028883, 0.21902107551280947, 0.21902107551280947, 0.21902107551280947, 0.3563258561221383, 0.3563258561221383, 0.3563258561221383, 0.2474680005978266, 0.2474680005978266, 0.2474680005978266, 0.20417258914390446, 0.20417258914390446, 0.20417258914390446, 0.22729678098722805, 0.22729678098722805, 0.22729678098722805, 0.22314842379469357, 0.22314842379469357, 0.22314842379469357, 0.21588487370922083, 0.21588487370922083, 0.21588487370922083, 0.22100840205041583, 0.22100840205041583, 0.22100840205041583, 0.24216124021531737, 0.24216124021531737, 0.24216124021531737, 0.8375012045719195, 0.8375012045719195, 0.8375012045719195, 0.9090806808219745, 0.9090806808219745, 0.9090806808219745, 0.1418618374584506, 0.1418618374584506, 0.1418618374584506, 0.7905978270547784, 0.7905978270547784, 0.7905978270547784, 0.7569990490845664, 0.7569990490845664, 0.7569990490845664, 0.21082535228295762, 0.21082535228295762, 0.21082535228295762, 0.1974656061574156, 0.1974656061574156, 0.1974656061574156, 0.1848299648349595, 0.1848299648349595, 0.1848299648349595, 0.18760627427163612, 0.18760627427163612, 0.18760627427163612, 0.08880660277206842, 0.08880660277206842, 0.08880660277206842, 0.10952451462961632, 0.10952451462961632, 0.10952451462961632, 0.08795370521342216, 0.08795370521342216, 0.08795370521342216]}, "mutation_prompt": null}
{"id": "429c4d00-9516-46b6-8029-beacc73eaf85", "solution": "import numpy as np\n\nclass DynamicAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.7\n        self.c1_final = 1.3\n        self.c2_final = 2.8\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.2\n        self.local_search_probability = 0.25\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                \n                if evaluations >= self.budget:\n                    break\n            \n            cycle_ratio = (np.sin((np.pi / 2) * (evaluations / self.budget)) + 1) / 2\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * cycle_ratio)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * cycle_ratio)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * cycle_ratio)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * cycle_ratio)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "DynamicAdaptiveHybridOptimization", "description": "Dynamic Adaptive Hybrid Optimization (DAHO) leveraging periodic adaptive parameters and hybrid techniques for improved balance between exploration and exploitation.", "configspace": "", "generation": 85, "fitness": 0.3327137079822788, "feedback": "The algorithm DynamicAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.33 with standard deviation 0.26.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.780502092995884, 0.780502092995884, 0.780502092995884, 0.7774118901451236, 0.7774118901451236, 0.7774118901451236, 0.7644600167917829, 0.7644600167917829, 0.7644600167917829, 0.46798249460302266, 0.46798249460302266, 0.46798249460302266, 0.46791501066827523, 0.46791501066827523, 0.46791501066827523, 0.47377990650877944, 0.47377990650877944, 0.47377990650877944, 0.11298564216251938, 0.11298564216251938, 0.11298564216251938, 0.11569729710180421, 0.11569729710180421, 0.11569729710180421, 0.13333687451882548, 0.13333687451882548, 0.13333687451882548, 0.11079260291506765, 0.11079260291506765, 0.11079260291506765, 0.11883363585993245, 0.11883363585993245, 0.11883363585993245, 0.12942870327872424, 0.12942870327872424, 0.12942870327872424, 0.8856607229999731, 0.8856607229999731, 0.8856607229999731, 0.9010013171475721, 0.9010013171475721, 0.9010013171475721, 0.8949654213511659, 0.8949654213511659, 0.8949654213511659, 0.45154589702075265, 0.45154589702075265, 0.45154589702075265, 0.4687702657192707, 0.4687702657192707, 0.4687702657192707, 0.46864966395274577, 0.46864966395274577, 0.46864966395274577, 0.9014375615306481, 0.9014375615306481, 0.9014375615306481, 0.21418972751818155, 0.21418972751818155, 0.21418972751818155, 0.6345051351395885, 0.6345051351395885, 0.6345051351395885, 0.18727105144474987, 0.18727105144474987, 0.18727105144474987, 0.20592449372317967, 0.20592449372317967, 0.20592449372317967, 0.2029113186242456, 0.2029113186242456, 0.2029113186242456, 0.13207262126886887, 0.13207262126886887, 0.13207262126886887, 0.21520162811626442, 0.21520162811626442, 0.21520162811626442, 0.23911966160832376, 0.23911966160832376, 0.23911966160832376, 0.06842324681491085, 0.06842324681491085, 0.06842324681491085, 0.12275386997870574, 0.12275386997870574, 0.12275386997870574, 0.053287209097495736, 0.053287209097495736, 0.053287209097495736, 0.19331753477015834, 0.19331753477015834, 0.19331753477015834, 0.13120444913459395, 0.13120444913459395, 0.13120444913459395, 0.09561332200434625, 0.09561332200434625, 0.09561332200434625, 0.19171813195211973, 0.19171813195211973, 0.19171813195211973, 0.20409636733509562, 0.20409636733509562, 0.20409636733509562, 0.09102306689311246, 0.09102306689311246, 0.09102306689311246, 0.228627635059637, 0.228627635059637, 0.228627635059637, 0.12129863939057084, 0.12129863939057084, 0.12129863939057084, 0.07992761728737263, 0.07992761728737263, 0.07992761728737263, 0.481025941857967, 0.481025941857967, 0.481025941857967, 0.5038514936946692, 0.5038514936946692, 0.5038514936946692, 0.5107878573411635, 0.5107878573411635, 0.5107878573411635, 0.08535262468724503, 0.08535262468724503, 0.08535262468724503, 0.09232423530747835, 0.09232423530747835, 0.09232423530747835, 0.141298153049095, 0.141298153049095, 0.141298153049095, 0.2101540808718818, 0.2101540808718818, 0.2101540808718818, 0.1894217807085512, 0.1894217807085512, 0.1894217807085512, 0.35037504535567654, 0.35037504535567654, 0.35037504535567654, 0.2564227209897305, 0.2564227209897305, 0.2564227209897305, 0.37252811769479854, 0.37252811769479854, 0.37252811769479854, 0.46281270621968595, 0.46281270621968595, 0.46281270621968595, 0.2278057549474719, 0.2278057549474719, 0.2278057549474719, 0.29948267305694587, 0.29948267305694587, 0.29948267305694587, 0.2392946547669127, 0.2392946547669127, 0.2392946547669127, 0.21613526372899206, 0.21613526372899206, 0.21613526372899206, 0.25150651139212776, 0.25150651139212776, 0.25150651139212776, 0.25035406932545057, 0.25035406932545057, 0.25035406932545057, 0.2187693492903502, 0.2187693492903502, 0.2187693492903502, 0.20619705049867254, 0.20619705049867254, 0.20619705049867254, 0.1885144512651027, 0.1885144512651027, 0.1885144512651027, 0.18344017180488914, 0.18344017180488914, 0.18344017180488914, 0.8714318950309903, 0.8714318950309903, 0.8714318950309903, 0.8606418962723151, 0.8606418962723151, 0.8606418962723151, 0.8074767959422103, 0.8074767959422103, 0.8074767959422103, 0.8545725077519665, 0.8545725077519665, 0.8545725077519665, 0.7540118633364441, 0.7540118633364441, 0.7540118633364441, 0.17673521164517247, 0.17673521164517247, 0.17673521164517247, 0.18343689187894596, 0.18343689187894596, 0.18343689187894596, 0.18151893982464817, 0.18151893982464817, 0.18151893982464817, 0.09596362303591066, 0.09596362303591066, 0.09596362303591066, 0.08665724091995985, 0.08665724091995985, 0.08665724091995985, 0.10744165679726358, 0.10744165679726358, 0.10744165679726358]}, "mutation_prompt": null}
{"id": "114b5a38-29f2-42e4-8e41-15aefeb18c3a", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.1\n        self.c2_initial = 1.7\n        self.c1_final = 1.4\n        self.c2_final = 2.6\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.2\n        self.local_search_probability = 0.25\n        self.mutation_factor_initial = 0.6\n        self.mutation_factor_final = 0.3\n        self.crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n            mutation_factor = self.mutation_factor_initial - ((self.mutation_factor_initial - self.mutation_factor_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) integrating dynamic inertia adjustment and adaptive differential evolution for improved convergence and solution quality.", "configspace": "", "generation": 86, "fitness": 0.3064851822240498, "feedback": "The algorithm EnhancedAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.31 with standard deviation 0.23.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.6452966070721675, 0.6452966070721675, 0.6452966070721675, 0.646864820723932, 0.646864820723932, 0.646864820723932, 0.6442687384648542, 0.6442687384648542, 0.6442687384648542, 0.26781057169561584, 0.26781057169561584, 0.26781057169561584, 0.27197392397708253, 0.27197392397708253, 0.27197392397708253, 0.18712352479925654, 0.18712352479925654, 0.18712352479925654, 0.1460576775865755, 0.1460576775865755, 0.1460576775865755, 0.14287476136663213, 0.14287476136663213, 0.14287476136663213, 0.18058791277885544, 0.18058791277885544, 0.18058791277885544, 0.10998694525268515, 0.10998694525268515, 0.10998694525268515, 0.12072460780076255, 0.12072460780076255, 0.12072460780076255, 0.15817998115697063, 0.15817998115697063, 0.15817998115697063, 0.9403227875636296, 0.9403227875636296, 0.9403227875636296, 0.937575217341869, 0.937575217341869, 0.937575217341869, 0.9487857275255595, 0.9487857275255595, 0.9487857275255595, 0.3844205733848366, 0.3844205733848366, 0.3844205733848366, 0.4007404472412972, 0.4007404472412972, 0.4007404472412972, 0.36712881832646904, 0.36712881832646904, 0.36712881832646904, 0.6602934446111923, 0.6602934446111923, 0.6602934446111923, 0.6642934711937422, 0.6642934711937422, 0.6642934711937422, 0.674105186833333, 0.674105186833333, 0.674105186833333, 0.248167982477961, 0.248167982477961, 0.248167982477961, 0.23230440032531963, 0.23230440032531963, 0.23230440032531963, 0.18646901445565223, 0.18646901445565223, 0.18646901445565223, 0.20781662498553088, 0.20781662498553088, 0.20781662498553088, 0.17007469436620926, 0.17007469436620926, 0.17007469436620926, 0.2660006490949458, 0.2660006490949458, 0.2660006490949458, 0.059588162547354884, 0.059588162547354884, 0.059588162547354884, 0.05429310979303159, 0.05429310979303159, 0.05429310979303159, 0.04507641595058465, 0.04507641595058465, 0.04507641595058465, 0.22090057583264555, 0.22090057583264555, 0.22090057583264555, 0.1674454228086928, 0.1674454228086928, 0.1674454228086928, 0.18996202832103803, 0.18996202832103803, 0.18996202832103803, 0.0974744348173745, 0.0974744348173745, 0.0974744348173745, 0.06877133531354596, 0.06877133531354596, 0.06877133531354596, 0.04889153006056279, 0.04889153006056279, 0.04889153006056279, 0.16131966333093373, 0.16131966333093373, 0.16131966333093373, 0.13015461497993985, 0.13015461497993985, 0.13015461497993985, 0.10218864207837886, 0.10218864207837886, 0.10218864207837886, 0.4477093932827766, 0.4477093932827766, 0.4477093932827766, 0.4659345778181694, 0.4659345778181694, 0.4659345778181694, 0.46601024607701413, 0.46601024607701413, 0.46601024607701413, 0.12064644801409918, 0.12064644801409918, 0.12064644801409918, 0.2525961442064245, 0.2525961442064245, 0.2525961442064245, 0.12095156825385434, 0.12095156825385434, 0.12095156825385434, 0.1834182259678171, 0.1834182259678171, 0.1834182259678171, 0.30529023636753105, 0.30529023636753105, 0.30529023636753105, 0.3408350040138868, 0.3408350040138868, 0.3408350040138868, 0.35862588452525623, 0.35862588452525623, 0.35862588452525623, 0.3471319373539964, 0.3471319373539964, 0.3471319373539964, 0.33326379055061617, 0.33326379055061617, 0.33326379055061617, 0.24514681677570527, 0.24514681677570527, 0.24514681677570527, 0.28341754256356533, 0.28341754256356533, 0.28341754256356533, 0.2739789539969959, 0.2739789539969959, 0.2739789539969959, 0.20615283961556952, 0.20615283961556952, 0.20615283961556952, 0.23552188575191968, 0.23552188575191968, 0.23552188575191968, 0.23513537353787728, 0.23513537353787728, 0.23513537353787728, 0.228346447037429, 0.228346447037429, 0.228346447037429, 0.21165474346269986, 0.21165474346269986, 0.21165474346269986, 0.21211240461652114, 0.21211240461652114, 0.21211240461652114, 0.7617341086807781, 0.7617341086807781, 0.7617341086807781, 0.7674332124922051, 0.7674332124922051, 0.7674332124922051, 0.14112974973585912, 0.14112974973585912, 0.14112974973585912, 0.7522569531786972, 0.7522569531786972, 0.7522569531786972, 0.6641224721877136, 0.6641224721877136, 0.6641224721877136, 0.10385628043088824, 0.10385628043088824, 0.10385628043088824, 0.19741668963506032, 0.19741668963506032, 0.19741668963506032, 0.19274404336523598, 0.19274404336523598, 0.19274404336523598, 0.18741042581075684, 0.18741042581075684, 0.18741042581075684, 0.08582283440771843, 0.08582283440771843, 0.08582283440771843, 0.08770326721658117, 0.08770326721658117, 0.08770326721658117, 0.09510757096334566, 0.09510757096334566, 0.09510757096334566]}, "mutation_prompt": null}
{"id": "10daae07-3812-424f-bf21-aa4ab2c00168", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles_initial = 30\n        self.num_particles_final = 60\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.2\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.3\n        self.c2_final = 2.8\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.2\n        self.local_search_probability = 0.25\n        self.mutation_factor_initial = 0.6\n        self.mutation_factor_final = 0.3\n        self.crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(0)\n        num_particles = self.num_particles_initial\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n            mutation_factor = self.mutation_factor_initial - ((self.mutation_factor_initial - self.mutation_factor_final) * evaluations / self.budget)\n            num_particles = int(self.num_particles_initial + ((self.num_particles_final - self.num_particles_initial) * evaluations / self.budget))\n\n            for i in range(num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (eAHO) introducing dynamic population size and adaptive mutation for improved global exploration and local exploitation.", "configspace": "", "generation": 87, "fitness": -Infinity, "feedback": "An exception occurred: IndexError('index 30 is out of bounds for axis 0 with size 30').", "error": "IndexError('index 30 is out of bounds for axis 0 with size 30')", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {}, "mutation_prompt": null}
{"id": "4766a39d-9e4c-4258-b919-c3ddc182af32", "solution": "import numpy as np\n\nclass HybridDynamicOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 3.0\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.3\n        self.local_search_probability = 0.25\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.8\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "HybridDynamicOptimization", "description": "Hybrid Dynamic Optimization (HDO) integrates adaptive particle dynamics with genetic strategies for efficient solution exploration and exploitation.", "configspace": "", "generation": 88, "fitness": 0.26700809854312174, "feedback": "The algorithm HybridDynamicOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.27 with standard deviation 0.21.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.579791708375089, 0.579791708375089, 0.579791708375089, 0.5442326920721137, 0.5442326920721137, 0.5442326920721137, 0.5798908471099411, 0.5798908471099411, 0.5798908471099411, 0.2143102737260837, 0.2143102737260837, 0.2143102737260837, 0.18353722056939614, 0.18353722056939614, 0.18353722056939614, 0.13946218920993902, 0.13946218920993902, 0.13946218920993902, 0.252815960851277, 0.252815960851277, 0.252815960851277, 0.12711281768992777, 0.12711281768992777, 0.12711281768992777, 0.16036133728131174, 0.16036133728131174, 0.16036133728131174, 0.11030499615827283, 0.11030499615827283, 0.11030499615827283, 0.13196347869354685, 0.13196347869354685, 0.13196347869354685, 0.10930669037105767, 0.10930669037105767, 0.10930669037105767, 0.9116869862955854, 0.9116869862955854, 0.9116869862955854, 0.9248020092064078, 0.9248020092064078, 0.9248020092064078, 0.931838595354795, 0.931838595354795, 0.931838595354795, 0.35014215160423035, 0.35014215160423035, 0.35014215160423035, 0.34193604099604114, 0.34193604099604114, 0.34193604099604114, 0.31277643824284185, 0.31277643824284185, 0.31277643824284185, 0.224371676462922, 0.224371676462922, 0.224371676462922, 0.5818391382351609, 0.5818391382351609, 0.5818391382351609, 0.6247870385442205, 0.6247870385442205, 0.6247870385442205, 0.18279811420471392, 0.18279811420471392, 0.18279811420471392, 0.16253028067802333, 0.16253028067802333, 0.16253028067802333, 0.20543646523697456, 0.20543646523697456, 0.20543646523697456, 0.16153382656683624, 0.16153382656683624, 0.16153382656683624, 0.16450798691285762, 0.16450798691285762, 0.16450798691285762, 0.1701977216219197, 0.1701977216219197, 0.1701977216219197, 0.02200083218758464, 0.02200083218758464, 0.02200083218758464, 0.04283394796053486, 0.04283394796053486, 0.04283394796053486, 0.02657493797629107, 0.02657493797629107, 0.02657493797629107, 0.1877695598241106, 0.1877695598241106, 0.1877695598241106, 0.12844942687613126, 0.12844942687613126, 0.12844942687613126, 0.16144516097257144, 0.16144516097257144, 0.16144516097257144, 0.05816220853930665, 0.05816220853930665, 0.05816220853930665, 0.06239272475992297, 0.06239272475992297, 0.06239272475992297, 0.03870232520050687, 0.03870232520050687, 0.03870232520050687, 0.12885375989292092, 0.12885375989292092, 0.12885375989292092, 0.12853624627766314, 0.12853624627766314, 0.12853624627766314, 0.10454824844293453, 0.10454824844293453, 0.10454824844293453, 0.42774015044231395, 0.42774015044231395, 0.42774015044231395, 0.45821093594988493, 0.45821093594988493, 0.45821093594988493, 0.4719490263187368, 0.4719490263187368, 0.4719490263187368, 0.14036367669665828, 0.14036367669665828, 0.14036367669665828, 0.1073952609899036, 0.1073952609899036, 0.1073952609899036, 0.1310299824770833, 0.1310299824770833, 0.1310299824770833, 0.20982672304980066, 0.20982672304980066, 0.20982672304980066, 0.18183538491679208, 0.18183538491679208, 0.18183538491679208, 0.27310608272887815, 0.27310608272887815, 0.27310608272887815, 0.3086405785746116, 0.3086405785746116, 0.3086405785746116, 0.3339845454593048, 0.3339845454593048, 0.3339845454593048, 0.34513822327724997, 0.34513822327724997, 0.34513822327724997, 0.26868442246116464, 0.26868442246116464, 0.26868442246116464, 0.23672016024760079, 0.23672016024760079, 0.23672016024760079, 0.24537755653598048, 0.24537755653598048, 0.24537755653598048, 0.24706742564928352, 0.24706742564928352, 0.24706742564928352, 0.23223076414003685, 0.23223076414003685, 0.23223076414003685, 0.24245129066892535, 0.24245129066892535, 0.24245129066892535, 0.23122602723288666, 0.23122602723288666, 0.23122602723288666, 0.22938650770314128, 0.22938650770314128, 0.22938650770314128, 0.22367028451700643, 0.22367028451700643, 0.22367028451700643, 0.12493662981680431, 0.12493662981680431, 0.12493662981680431, 0.7442279427176276, 0.7442279427176276, 0.7442279427176276, 0.14086606102944332, 0.14086606102944332, 0.14086606102944332, 0.5956236757382962, 0.5956236757382962, 0.5956236757382962, 0.20959576942432645, 0.20959576942432645, 0.20959576942432645, 0.5712992966771149, 0.5712992966771149, 0.5712992966771149, 0.18666204299358502, 0.18666204299358502, 0.18666204299358502, 0.1844530002144411, 0.1844530002144411, 0.1844530002144411, 0.173231380848062, 0.173231380848062, 0.173231380848062, 0.09188969964960192, 0.09188969964960192, 0.09188969964960192, 0.09005466587410826, 0.09005466587410826, 0.09005466587410826, 0.09116385890214496, 0.09116385890214496, 0.09116385890214496]}, "mutation_prompt": null}
{"id": "088cfa59-c30b-4c2c-963f-e727a62d3841", "solution": "import numpy as np\n\nclass QuantumEnhancedHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.9\n        self.w_min = 0.4\n        self.c1_initial = 1.5\n        self.c2_initial = 2.0\n        self.c1_final = 2.0\n        self.c2_final = 3.0\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.3\n        self.local_search_probability = 0.25\n        self.mutation_factor = 0.6\n        self.crossover_rate = 0.85\n        self.quantum_factor = 0.1\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial + ((self.c1_final - self.c1_initial) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                quantum_component = self.quantum_factor * np.random.randn(self.dim)\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component + quantum_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "QuantumEnhancedHybridOptimization", "description": "Quantum-Enhanced Hybrid Optimization (QHO) integrating quantum-inspired dynamics with adaptive particle swarm and differential evolution for improved exploration and convergence.", "configspace": "", "generation": 89, "fitness": 0.25629019320072915, "feedback": "The algorithm QuantumEnhancedHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.26 with standard deviation 0.21.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.4368679507922113, 0.4368679507922113, 0.4368679507922113, 0.48698940917998956, 0.48698940917998956, 0.48698940917998956, 0.4564462874174047, 0.4564462874174047, 0.4564462874174047, 0.10731316707088479, 0.10731316707088479, 0.10731316707088479, 0.09027800731507452, 0.09027800731507452, 0.09027800731507452, 0.08672661970942208, 0.08672661970942208, 0.08672661970942208, 0.11504572755137377, 0.11504572755137377, 0.11504572755137377, 0.11325793930332129, 0.11325793930332129, 0.11325793930332129, 0.11403886312065403, 0.11403886312065403, 0.11403886312065403, 0.09442474237761767, 0.09442474237761767, 0.09442474237761767, 0.10442665212717761, 0.10442665212717761, 0.10442665212717761, 0.10074497422036788, 0.10074497422036788, 0.10074497422036788, 0.9394487334835394, 0.9394487334835394, 0.9394487334835394, 0.9393632924308221, 0.9393632924308221, 0.9393632924308221, 0.9442242713741821, 0.9442242713741821, 0.9442242713741821, 0.2673239316053918, 0.2673239316053918, 0.2673239316053918, 0.278352030863262, 0.278352030863262, 0.278352030863262, 0.28070233006156997, 0.28070233006156997, 0.28070233006156997, 0.3319006027410185, 0.3319006027410185, 0.3319006027410185, 0.31429375242239044, 0.31429375242239044, 0.31429375242239044, 0.3230657075381864, 0.3230657075381864, 0.3230657075381864, 0.2021010886566098, 0.2021010886566098, 0.2021010886566098, 0.15790837821535209, 0.15790837821535209, 0.15790837821535209, 0.15430420147360713, 0.15430420147360713, 0.15430420147360713, 0.1559857152890337, 0.1559857152890337, 0.1559857152890337, 0.1628915446763094, 0.1628915446763094, 0.1628915446763094, 0.17165886556349674, 0.17165886556349674, 0.17165886556349674, 0.04617717203543581, 0.04617717203543581, 0.04617717203543581, 0.052745192050550616, 0.052745192050550616, 0.052745192050550616, 0.04596355199341795, 0.04596355199341795, 0.04596355199341795, 0.18647770432684807, 0.18647770432684807, 0.18647770432684807, 0.1559674422374494, 0.1559674422374494, 0.1559674422374494, 0.1589309407359204, 0.1589309407359204, 0.1589309407359204, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.11886107561646253, 0.11886107561646253, 0.11886107561646253, 0.10422297633675204, 0.10422297633675204, 0.10422297633675204, 0.09911140353898684, 0.09911140353898684, 0.09911140353898684, 0.4107842857303845, 0.4107842857303845, 0.4107842857303845, 0.40942753110024055, 0.40942753110024055, 0.40942753110024055, 0.4248240366191074, 0.4248240366191074, 0.4248240366191074, 0.08775046029455902, 0.08775046029455902, 0.08775046029455902, 0.11649321505060739, 0.11649321505060739, 0.11649321505060739, 0.12960585021299575, 0.12960585021299575, 0.12960585021299575, 0.20992600044103882, 0.20992600044103882, 0.20992600044103882, 0.24352679818805079, 0.24352679818805079, 0.24352679818805079, 0.21773710175275096, 0.21773710175275096, 0.21773710175275096, 0.2872134031571518, 0.2872134031571518, 0.2872134031571518, 0.29144405090167924, 0.29144405090167924, 0.29144405090167924, 0.2880958506382585, 0.2880958506382585, 0.2880958506382585, 0.2219398547639715, 0.2219398547639715, 0.2219398547639715, 0.2314728987145218, 0.2314728987145218, 0.2314728987145218, 0.2151604976985877, 0.2151604976985877, 0.2151604976985877, 0.21585857067440728, 0.21585857067440728, 0.21585857067440728, 0.22348334103305956, 0.22348334103305956, 0.22348334103305956, 0.2550684099962074, 0.2550684099962074, 0.2550684099962074, 0.2332360332831761, 0.2332360332831761, 0.2332360332831761, 0.20341864062024428, 0.20341864062024428, 0.20341864062024428, 0.19749223768168944, 0.19749223768168944, 0.19749223768168944, 0.641802757687507, 0.641802757687507, 0.641802757687507, 0.6822758865330484, 0.6822758865330484, 0.6822758865330484, 0.5855870025406333, 0.5855870025406333, 0.5855870025406333, 0.5628638370689123, 0.5628638370689123, 0.5628638370689123, 0.62120805382136, 0.62120805382136, 0.62120805382136, 0.5149967843611105, 0.5149967843611105, 0.5149967843611105, 0.1836432632771926, 0.1836432632771926, 0.1836432632771926, 0.18312083438162063, 0.18312083438162063, 0.18312083438162063, 0.18156780356609903, 0.18156780356609903, 0.18156780356609903, 0.08774653700825497, 0.08774653700825497, 0.08774653700825497, 0.08717939358435922, 0.08717939358435922, 0.08717939358435922, 0.1081004426176152, 0.1081004426176152, 0.1081004426176152]}, "mutation_prompt": null}
{"id": "799f5821-4138-4c8d-9c37-c31ddd97eef1", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.2  # Adjusted to allow more exploration\n        self.c1_initial = 2.0\n        self.c2_initial = 2.0  # Symmetric initial cognitive and social factors\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.1  # More aggressive reduction for refined search\n        self.mutation_factor = 0.7  # Increased for more diversity\n        self.crossover_rate = 0.85  # Slightly reduced for stability\n        self.local_search_probability_start = 0.3  # Dynamic local search probability\n        self.local_search_probability_end = 0.1\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n            local_search_probability = self.local_search_probability_start - ((self.local_search_probability_start - self.local_search_probability_end) * evaluations / self.budget)\n            \n            for i in range(self.num_particles):\n                if np.random.rand() < local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) with dynamic local search probability and adaptive velocity control for improved exploration and convergence.", "configspace": "", "generation": 90, "fitness": 0.3432694505931842, "feedback": "The algorithm EnhancedAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.34 with standard deviation 0.26.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7831495846613192, 0.7831495846613192, 0.7831495846613192, 0.7797461877103609, 0.7797461877103609, 0.7797461877103609, 0.7537045570406622, 0.7537045570406622, 0.7537045570406622, 0.5071584539723194, 0.5071584539723194, 0.5071584539723194, 0.5263860071291221, 0.5263860071291221, 0.5263860071291221, 0.511820945047312, 0.511820945047312, 0.511820945047312, 0.46491066145281257, 0.46491066145281257, 0.46491066145281257, 0.12158381958997566, 0.12158381958997566, 0.12158381958997566, 0.0845757633280868, 0.0845757633280868, 0.0845757633280868, 0.10464522919278407, 0.10464522919278407, 0.10464522919278407, 0.1060771992526276, 0.1060771992526276, 0.1060771992526276, 0.11477677865991753, 0.11477677865991753, 0.11477677865991753, 0.918578041502602, 0.918578041502602, 0.918578041502602, 0.9290244097409424, 0.9290244097409424, 0.9290244097409424, 0.9371046698709644, 0.9371046698709644, 0.9371046698709644, 0.5033984112382656, 0.5033984112382656, 0.5033984112382656, 0.5080522075557392, 0.5080522075557392, 0.5080522075557392, 0.46142537150079443, 0.46142537150079443, 0.46142537150079443, 0.8267926400960943, 0.8267926400960943, 0.8267926400960943, 0.6970532499254176, 0.6970532499254176, 0.6970532499254176, 0.21969627143687365, 0.21969627143687365, 0.21969627143687365, 0.22604647906622144, 0.22604647906622144, 0.22604647906622144, 0.12485851060826936, 0.12485851060826936, 0.12485851060826936, 0.2012557283452091, 0.2012557283452091, 0.2012557283452091, 0.2322483609555176, 0.2322483609555176, 0.2322483609555176, 0.2059791614095936, 0.2059791614095936, 0.2059791614095936, 0.23006088718064344, 0.23006088718064344, 0.23006088718064344, 0.07965101961564958, 0.07965101961564958, 0.07965101961564958, 0.06351405529341503, 0.06351405529341503, 0.06351405529341503, 0.043149418960983676, 0.043149418960983676, 0.043149418960983676, 0.2095160796170802, 0.2095160796170802, 0.2095160796170802, 0.1717666312974545, 0.1717666312974545, 0.1717666312974545, 0.21374856083342975, 0.21374856083342975, 0.21374856083342975, 0.1307773802284119, 0.1307773802284119, 0.1307773802284119, 0.12185822078606201, 0.12185822078606201, 0.12185822078606201, 0.08179949238729933, 0.08179949238729933, 0.08179949238729933, 0.14324844357900035, 0.14324844357900035, 0.14324844357900035, 0.1621643881785867, 0.1621643881785867, 0.1621643881785867, 0.08036391890478956, 0.08036391890478956, 0.08036391890478956, 0.48638034313208345, 0.48638034313208345, 0.48638034313208345, 0.541155719273673, 0.541155719273673, 0.541155719273673, 0.5284182975881841, 0.5284182975881841, 0.5284182975881841, 0.11238668952249264, 0.11238668952249264, 0.11238668952249264, 0.11085164901549704, 0.11085164901549704, 0.11085164901549704, 0.13608680312100818, 0.13608680312100818, 0.13608680312100818, 0.1586830868636966, 0.1586830868636966, 0.1586830868636966, 0.23408615050219928, 0.23408615050219928, 0.23408615050219928, 0.4752319342933462, 0.4752319342933462, 0.4752319342933462, 0.3239539826707929, 0.3239539826707929, 0.3239539826707929, 0.3879485685899211, 0.3879485685899211, 0.3879485685899211, 0.4390079339680898, 0.4390079339680898, 0.4390079339680898, 0.26412426220937757, 0.26412426220937757, 0.26412426220937757, 0.3269347834927776, 0.3269347834927776, 0.3269347834927776, 0.3165824008244563, 0.3165824008244563, 0.3165824008244563, 0.24716172326285968, 0.24716172326285968, 0.24716172326285968, 0.2163544112064908, 0.2163544112064908, 0.2163544112064908, 0.23969281121547703, 0.23969281121547703, 0.23969281121547703, 0.20462145512803442, 0.20462145512803442, 0.20462145512803442, 0.19648459951666009, 0.19648459951666009, 0.19648459951666009, 0.22202384606190761, 0.22202384606190761, 0.22202384606190761, 0.1535400396919303, 0.1535400396919303, 0.1535400396919303, 0.8739088603928602, 0.8739088603928602, 0.8739088603928602, 0.8067735531235142, 0.8067735531235142, 0.8067735531235142, 0.7601603331877885, 0.7601603331877885, 0.7601603331877885, 0.7775119178027656, 0.7775119178027656, 0.7775119178027656, 0.7029991101241176, 0.7029991101241176, 0.7029991101241176, 0.20977538775495574, 0.20977538775495574, 0.20977538775495574, 0.18946847494865604, 0.18946847494865604, 0.18946847494865604, 0.2440809299719604, 0.2440809299719604, 0.2440809299719604, 0.07436075942405329, 0.07436075942405329, 0.07436075942405329, 0.09081734101249772, 0.09081734101249772, 0.09081734101249772, 0.0821650866625292, 0.0821650866625292, 0.0821650866625292]}, "mutation_prompt": null}
{"id": "a8ec8073-6a1a-495b-8ecc-6b9bc4ce3afc", "solution": "import numpy as np\n\nclass QuantumGuidedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Adjusted for increased inertia at start\n        self.w_min = 0.2  # Reduced for better convergence at end\n        self.c1_initial = 2.2  # Increased for more exploration\n        self.c2_initial = 1.7\n        self.c1_final = 1.6\n        self.c2_final = 2.6\n        self.velocity_clamp_initial = 1.0  # More aggressive initial velocity\n        self.velocity_clamp_final = 0.3  # More controlled final velocity\n        self.local_search_probability = 0.25  # Increased local search probability\n        self.mutation_factor = 0.6  # Stronger differential mutation\n        self.crossover_rate = 0.85  # Reduced crossover for diversity\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component + np.random.uniform(-1, 1, self.dim) * (self.upper_bound - self.lower_bound) * 0.05\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "QuantumGuidedAdaptiveHybridOptimization", "description": "Quantum-Guided Adaptive Hybrid Optimization (QGAHO) enhances convergence by integrating quantum-inspired exploration with adaptive hybrid dynamics.", "configspace": "", "generation": 91, "fitness": 0.237814390909629, "feedback": "The algorithm QuantumGuidedAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.24 with standard deviation 0.20.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.4126501314321035, 0.4126501314321035, 0.4126501314321035, 0.4275945317031773, 0.4275945317031773, 0.4275945317031773, 0.39137013766184414, 0.39137013766184414, 0.39137013766184414, 0.07969839628275854, 0.07969839628275854, 0.07969839628275854, 0.07659961402320237, 0.07659961402320237, 0.07659961402320237, 0.05446307586276944, 0.05446307586276944, 0.05446307586276944, 0.10790666365737211, 0.10790666365737211, 0.10790666365737211, 0.09683469345863471, 0.09683469345863471, 0.09683469345863471, 0.08935311764989196, 0.08935311764989196, 0.08935311764989196, 0.0943002842409234, 0.0943002842409234, 0.0943002842409234, 0.09912088273488229, 0.09912088273488229, 0.09912088273488229, 0.10555488152856274, 0.10555488152856274, 0.10555488152856274, 0.9448729797998965, 0.9448729797998965, 0.9448729797998965, 0.9491588975595666, 0.9491588975595666, 0.9491588975595666, 0.9244594503479127, 0.9244594503479127, 0.9244594503479127, 0.2588412778340162, 0.2588412778340162, 0.2588412778340162, 0.24605702852317968, 0.24605702852317968, 0.24605702852317968, 0.2794228812826255, 0.2794228812826255, 0.2794228812826255, 0.5315320696252956, 0.5315320696252956, 0.5315320696252956, 0.31336701412060985, 0.31336701412060985, 0.31336701412060985, 0.2956788563618289, 0.2956788563618289, 0.2956788563618289, 0.10555759287057698, 0.10555759287057698, 0.10555759287057698, 0.15771847313835874, 0.15771847313835874, 0.15771847313835874, 0.17132292019024375, 0.17132292019024375, 0.17132292019024375, 0.16117046045910333, 0.16117046045910333, 0.16117046045910333, 0.15324282020432223, 0.15324282020432223, 0.15324282020432223, 0.16834020694536378, 0.16834020694536378, 0.16834020694536378, 0.024410242934247428, 0.024410242934247428, 0.024410242934247428, 0.032729793166259014, 0.032729793166259014, 0.032729793166259014, 0.009337914863879249, 0.009337914863879249, 0.009337914863879249, 0.23997598872760084, 0.23997598872760084, 0.23997598872760084, 0.1210516297258577, 0.1210516297258577, 0.1210516297258577, 0.19658237862113015, 0.19658237862113015, 0.19658237862113015, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 9.999999999998899e-05, 0.0034287884544770275, 0.0034287884544770275, 0.0034287884544770275, 0.10568441544352225, 0.10568441544352225, 0.10568441544352225, 0.1220757596592652, 0.1220757596592652, 0.1220757596592652, 0.09304870641563157, 0.09304870641563157, 0.09304870641563157, 0.3809618356487542, 0.3809618356487542, 0.3809618356487542, 0.39280346121045706, 0.39280346121045706, 0.39280346121045706, 0.39104030458452477, 0.39104030458452477, 0.39104030458452477, 0.08933816102593595, 0.08933816102593595, 0.08933816102593595, 0.10353461348443294, 0.10353461348443294, 0.10353461348443294, 0.10820688971830494, 0.10820688971830494, 0.10820688971830494, 0.20460471021703774, 0.20460471021703774, 0.20460471021703774, 0.20054502253648498, 0.20054502253648498, 0.20054502253648498, 0.20946166978015301, 0.20946166978015301, 0.20946166978015301, 0.28290828954842573, 0.28290828954842573, 0.28290828954842573, 0.27497101052946926, 0.27497101052946926, 0.27497101052946926, 0.2682358581847162, 0.2682358581847162, 0.2682358581847162, 0.2124563752682176, 0.2124563752682176, 0.2124563752682176, 0.16827905582913205, 0.16827905582913205, 0.16827905582913205, 0.2189923477866048, 0.2189923477866048, 0.2189923477866048, 0.21511815146367386, 0.21511815146367386, 0.21511815146367386, 0.24717453950944435, 0.24717453950944435, 0.24717453950944435, 0.2195449966666836, 0.2195449966666836, 0.2195449966666836, 0.1918837286603905, 0.1918837286603905, 0.1918837286603905, 0.19025032680776144, 0.19025032680776144, 0.19025032680776144, 0.1913176558614038, 0.1913176558614038, 0.1913176558614038, 0.1842988533661999, 0.1842988533661999, 0.1842988533661999, 0.6012324122079964, 0.6012324122079964, 0.6012324122079964, 0.573409467520615, 0.573409467520615, 0.573409467520615, 0.5342900931221977, 0.5342900931221977, 0.5342900931221977, 0.5095295223406207, 0.5095295223406207, 0.5095295223406207, 0.5040186594653024, 0.5040186594653024, 0.5040186594653024, 0.18291673624697813, 0.18291673624697813, 0.18291673624697813, 0.1782713458065478, 0.1782713458065478, 0.1782713458065478, 0.18936465727500895, 0.18936465727500895, 0.18936465727500895, 0.08206095440490824, 0.08206095440490824, 0.08206095440490824, 0.09184477349544473, 0.09184477349544473, 0.09184477349544473, 0.08505470840856377, 0.08505470840856377, 0.08505470840856377]}, "mutation_prompt": null}
{"id": "94355605-4625-4144-a916-16e5e6b3ef84", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.2\n        self.c1_initial = 2.5\n        self.c2_initial = 1.5\n        self.c1_final = 1.0\n        self.c2_final = 2.8\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.2\n        self.local_search_probability = 0.25\n        self.mutation_factor_initial = 0.6\n        self.mutation_factor_final = 0.3\n        self.crossover_rate_initial = 0.8\n        self.crossover_rate_final = 0.95\n        self.chaotic_map = lambda x: 0.9 * x * (1 - x)  # Logistic map\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        chaotic_value = 0.5\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n            mutation_factor = self.mutation_factor_initial - (self.mutation_factor_initial - self.mutation_factor_final) * evaluations / self.budget\n            crossover_rate = self.crossover_rate_initial + (self.crossover_rate_final - self.crossover_rate_initial) * evaluations / self.budget\n\n            chaotic_value = self.chaotic_map(chaotic_value)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * chaotic_value * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * chaotic_value * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) incorporating adaptive learning rates and chaotic maps to improve exploration and exploitation balance.", "configspace": "", "generation": 92, "fitness": 0.19149362688689756, "feedback": "The algorithm EnhancedAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.19 with standard deviation 0.14.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.40466824557820724, 0.40466824557820724, 0.40466824557820724, 0.3640517438204197, 0.3640517438204197, 0.3640517438204197, 0.3809411255005658, 0.3809411255005658, 0.3809411255005658, 0.07192263511425279, 0.07192263511425279, 0.07192263511425279, 0.05940283266099633, 0.05940283266099633, 0.05940283266099633, 0.03225291274030517, 0.03225291274030517, 0.03225291274030517, 0.076508535875069, 0.076508535875069, 0.076508535875069, 0.07779281916112701, 0.07779281916112701, 0.07779281916112701, 0.07971497887426326, 0.07971497887426326, 0.07971497887426326, 0.09259606466640868, 0.09259606466640868, 0.09259606466640868, 0.09012368375170643, 0.09012368375170643, 0.09012368375170643, 0.08979050483813622, 0.08979050483813622, 0.08979050483813622, 0.5325461430165175, 0.5325461430165175, 0.5325461430165175, 0.29454299336716006, 0.29454299336716006, 0.29454299336716006, 0.6028978986254675, 0.6028978986254675, 0.6028978986254675, 0.22667535534229544, 0.22667535534229544, 0.22667535534229544, 0.17724450025908078, 0.17724450025908078, 0.17724450025908078, 0.20832795112048863, 0.20832795112048863, 0.20832795112048863, 0.3550711023581955, 0.3550711023581955, 0.3550711023581955, 0.2483757667442935, 0.2483757667442935, 0.2483757667442935, 0.23668268516694146, 0.23668268516694146, 0.23668268516694146, 0.09631631585198397, 0.09631631585198397, 0.09631631585198397, 0.11096243879591916, 0.11096243879591916, 0.11096243879591916, 0.14949655253965177, 0.14949655253965177, 0.14949655253965177, 0.13636400372977675, 0.13636400372977675, 0.13636400372977675, 0.1270170824002067, 0.1270170824002067, 0.1270170824002067, 0.1426172663324382, 0.1426172663324382, 0.1426172663324382, 0.015310481824650335, 0.015310481824650335, 0.015310481824650335, 0.03436624813613054, 0.03436624813613054, 0.03436624813613054, 0.028702706906484354, 0.028702706906484354, 0.028702706906484354, 0.19015104159474405, 0.19015104159474405, 0.19015104159474405, 0.16218726662818495, 0.16218726662818495, 0.16218726662818495, 0.1927946848460026, 0.1927946848460026, 0.1927946848460026, 0.013259410558722595, 0.013259410558722595, 0.013259410558722595, 0.009280748848100262, 0.009280748848100262, 0.009280748848100262, 0.00012250570680538697, 0.00012250570680538697, 0.00012250570680538697, 0.07178621687918985, 0.07178621687918985, 0.07178621687918985, 0.06397655429083193, 0.06397655429083193, 0.06397655429083193, 0.10018842199760036, 0.10018842199760036, 0.10018842199760036, 0.37069735581120933, 0.37069735581120933, 0.37069735581120933, 0.3606097775854382, 0.3606097775854382, 0.3606097775854382, 0.4206265778009358, 0.4206265778009358, 0.4206265778009358, 0.07372405452733888, 0.07372405452733888, 0.07372405452733888, 0.09781074026537295, 0.09781074026537295, 0.09781074026537295, 0.0687907255500333, 0.0687907255500333, 0.0687907255500333, 0.15004011925083782, 0.15004011925083782, 0.15004011925083782, 0.20252618919094834, 0.20252618919094834, 0.20252618919094834, 0.17983007845129773, 0.17983007845129773, 0.17983007845129773, 0.2325410266212633, 0.2325410266212633, 0.2325410266212633, 0.24428575512450312, 0.24428575512450312, 0.24428575512450312, 0.2385795789367885, 0.2385795789367885, 0.2385795789367885, 0.17104510649983096, 0.17104510649983096, 0.17104510649983096, 0.18901068494441797, 0.18901068494441797, 0.18901068494441797, 0.19488523384038992, 0.19488523384038992, 0.19488523384038992, 0.24068038851261597, 0.24068038851261597, 0.24068038851261597, 0.22223213488191218, 0.22223213488191218, 0.22223213488191218, 0.20205974432812623, 0.20205974432812623, 0.20205974432812623, 0.16717758024211815, 0.16717758024211815, 0.16717758024211815, 0.18530223346102825, 0.18530223346102825, 0.18530223346102825, 0.16688114981040547, 0.16688114981040547, 0.16688114981040547, 0.1790729506447758, 0.1790729506447758, 0.1790729506447758, 0.5711312630582495, 0.5711312630582495, 0.5711312630582495, 0.312406868656231, 0.312406868656231, 0.312406868656231, 0.6057642847698418, 0.6057642847698418, 0.6057642847698418, 0.24182939860588215, 0.24182939860588215, 0.24182939860588215, 0.3627780164405975, 0.3627780164405975, 0.3627780164405975, 0.18437496098578088, 0.18437496098578088, 0.18437496098578088, 0.19064304991569503, 0.19064304991569503, 0.19064304991569503, 0.18045669252928764, 0.18045669252928764, 0.18045669252928764, 0.08095661404328436, 0.08095661404328436, 0.08095661404328436, 0.08892843287381835, 0.08892843287381835, 0.08892843287381835, 0.06283194124704605, 0.06283194124704605, 0.06283194124704605]}, "mutation_prompt": null}
{"id": "7ed8ce78-f0ca-4614-bbed-549fe1c29fc0", "solution": "import numpy as np\n\nclass DynamicSynergisticOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Changed number of particles\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8  # Adjusted inertia weight max\n        self.w_min = 0.4  # Adjusted inertia weight min\n        self.c1_initial = 2.1  # Altered cognitive component scaling\n        self.c2_initial = 1.7\n        self.c1_final = 1.4\n        self.c2_final = 2.6  # Altered social component scaling\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.3\n        self.local_search_probability = 0.25  # Increased local search probability\n        self.mutation_factor = 0.6  # Differentiated mutation factor\n        self.crossover_rate = 0.85  # Slightly adjusted crossover rate\n\n    def __call__(self, func):\n        np.random.seed(42)  # Different seed for variability\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n        elite_position = None  # Track elite position\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n                        elite_position = global_best_position.copy()  # Update elite\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n                            elite_position = global_best_position.copy()  # Update elite\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                elite_component = (0.1 * np.random.uniform(0, 1, self.dim) * (elite_position - positions[i])) if elite_position is not None else 0  # Elite component\n\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component + elite_component\n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "DynamicSynergisticOptimization", "description": "Dynamic Synergistic Optimization (DSO) enhancing adaptive particle swarm and differential evolution with elite selection for improved convergence.", "configspace": "", "generation": 93, "fitness": 0.3048620403828103, "feedback": "The algorithm DynamicSynergisticOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.30 with standard deviation 0.23.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.6480659654011713, 0.6480659654011713, 0.6480659654011713, 0.6434417978039644, 0.6434417978039644, 0.6434417978039644, 0.6777070424797951, 0.6777070424797951, 0.6777070424797951, 0.31600928933621086, 0.31600928933621086, 0.31600928933621086, 0.28506436272301405, 0.28506436272301405, 0.28506436272301405, 0.28885737806419154, 0.28885737806419154, 0.28885737806419154, 0.15103308102528312, 0.15103308102528312, 0.15103308102528312, 0.14300715253479135, 0.14300715253479135, 0.14300715253479135, 0.09101692478799162, 0.09101692478799162, 0.09101692478799162, 0.10669102624975224, 0.10669102624975224, 0.10669102624975224, 0.10449112798391091, 0.10449112798391091, 0.10449112798391091, 0.10829825920186653, 0.10829825920186653, 0.10829825920186653, 0.8874893003167225, 0.8874893003167225, 0.8874893003167225, 0.9316367296806817, 0.9316367296806817, 0.9316367296806817, 0.9250305106711886, 0.9250305106711886, 0.9250305106711886, 0.41063837591739594, 0.41063837591739594, 0.41063837591739594, 0.374702848465311, 0.374702848465311, 0.374702848465311, 0.4171873549728007, 0.4171873549728007, 0.4171873549728007, 0.5448569068994459, 0.5448569068994459, 0.5448569068994459, 0.426020630045177, 0.426020630045177, 0.426020630045177, 0.2312255443575132, 0.2312255443575132, 0.2312255443575132, 0.19939364490707367, 0.19939364490707367, 0.19939364490707367, 0.12814159653158075, 0.12814159653158075, 0.12814159653158075, 0.17925927311982792, 0.17925927311982792, 0.17925927311982792, 0.30616590133745103, 0.30616590133745103, 0.30616590133745103, 0.18633507869986876, 0.18633507869986876, 0.18633507869986876, 0.20171857535484683, 0.20171857535484683, 0.20171857535484683, 0.052349060222552146, 0.052349060222552146, 0.052349060222552146, 0.048765199382435065, 0.048765199382435065, 0.048765199382435065, 0.0596570890697381, 0.0596570890697381, 0.0596570890697381, 0.1767324240682535, 0.1767324240682535, 0.1767324240682535, 0.08983047409240608, 0.08983047409240608, 0.08983047409240608, 0.2154200134113231, 0.2154200134113231, 0.2154200134113231, 0.12326913928414274, 0.12326913928414274, 0.12326913928414274, 0.03150847741285978, 0.03150847741285978, 0.03150847741285978, 0.06700070384670942, 0.06700070384670942, 0.06700070384670942, 0.14259248727542906, 0.14259248727542906, 0.14259248727542906, 0.13353917308864316, 0.13353917308864316, 0.13353917308864316, 0.149985862130541, 0.149985862130541, 0.149985862130541, 0.48025725388373997, 0.48025725388373997, 0.48025725388373997, 0.46087240824655906, 0.46087240824655906, 0.46087240824655906, 0.4722514480960852, 0.4722514480960852, 0.4722514480960852, 0.12250628181367207, 0.12250628181367207, 0.12250628181367207, 0.12466301789305922, 0.12466301789305922, 0.12466301789305922, 0.1408867233660811, 0.1408867233660811, 0.1408867233660811, 0.350461584367744, 0.350461584367744, 0.350461584367744, 0.29577964686969516, 0.29577964686969516, 0.29577964686969516, 0.27704156861559315, 0.27704156861559315, 0.27704156861559315, 0.33291477400277913, 0.33291477400277913, 0.33291477400277913, 0.34450878630659987, 0.34450878630659987, 0.34450878630659987, 0.38291597877287753, 0.38291597877287753, 0.38291597877287753, 0.1872605472266996, 0.1872605472266996, 0.1872605472266996, 0.27030392894096533, 0.27030392894096533, 0.27030392894096533, 0.21734466566606758, 0.21734466566606758, 0.21734466566606758, 0.21782111885020372, 0.21782111885020372, 0.21782111885020372, 0.2398761546633047, 0.2398761546633047, 0.2398761546633047, 0.23088805868029527, 0.23088805868029527, 0.23088805868029527, 0.21256060856002335, 0.21256060856002335, 0.21256060856002335, 0.2137328076960282, 0.2137328076960282, 0.2137328076960282, 0.2265147757930679, 0.2265147757930679, 0.2265147757930679, 0.8505182864560707, 0.8505182864560707, 0.8505182864560707, 0.8090114250169129, 0.8090114250169129, 0.8090114250169129, 0.8007711957304533, 0.8007711957304533, 0.8007711957304533, 0.7208857413727613, 0.7208857413727613, 0.7208857413727613, 0.21029258831927378, 0.21029258831927378, 0.21029258831927378, 0.6998174660334777, 0.6998174660334777, 0.6998174660334777, 0.17926843945120985, 0.17926843945120985, 0.17926843945120985, 0.17910825555354526, 0.17910825555354526, 0.17910825555354526, 0.20122762875320288, 0.20122762875320288, 0.20122762875320288, 0.08835917882184618, 0.08835917882184618, 0.08835917882184618, 0.08757051723324272, 0.08757051723324272, 0.08757051723324272, 0.11773826435534263, 0.11773826435534263, 0.11773826435534263]}, "mutation_prompt": null}
{"id": "db2049f7-084a-4d56-8abc-97a6125346ea", "solution": "import numpy as np\n\nclass AdaptiveEnhancedHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 60  # Adjusted number of particles for better exploration\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.8\n        self.w_min = 0.2\n        self.c1_initial = 2.1\n        self.c2_initial = 1.7\n        self.c1_final = 1.6\n        self.c2_final = 2.6\n        self.velocity_clamp_initial = 1.0\n        self.velocity_clamp_final = 0.3\n        self.local_search_probability = 0.25  # Increased probability for local search\n        self.mutation_factor_min = 0.4  # Range for adaptive mutation factor\n        self.mutation_factor_max = 0.8\n        self.crossover_rate = 0.85\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            mutation_factor = self.mutation_factor_min + ((self.mutation_factor_max - self.mutation_factor_min) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "AdaptiveEnhancedHybridOptimization", "description": "Adaptive Enhanced Hybrid Optimization (AEHO) introduces dynamic local search strategies with variable dimensions to improve convergence and exploration.", "configspace": "", "generation": 94, "fitness": 0.3205535252200367, "feedback": "The algorithm AdaptiveEnhancedHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.32 with standard deviation 0.23.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7039591894188502, 0.7039591894188502, 0.7039591894188502, 0.7161516508447319, 0.7161516508447319, 0.7161516508447319, 0.6847028174995543, 0.6847028174995543, 0.6847028174995543, 0.42436735724218566, 0.42436735724218566, 0.42436735724218566, 0.40291771840269675, 0.40291771840269675, 0.40291771840269675, 0.43167868362026984, 0.43167868362026984, 0.43167868362026984, 0.2682632736976748, 0.2682632736976748, 0.2682632736976748, 0.2690751865602313, 0.2690751865602313, 0.2690751865602313, 0.2995549418135086, 0.2995549418135086, 0.2995549418135086, 0.11141476865856925, 0.11141476865856925, 0.11141476865856925, 0.12368142703300311, 0.12368142703300311, 0.12368142703300311, 0.15368460033103748, 0.15368460033103748, 0.15368460033103748, 0.915866446953006, 0.915866446953006, 0.915866446953006, 0.9227541102372707, 0.9227541102372707, 0.9227541102372707, 0.9193439252733421, 0.9193439252733421, 0.9193439252733421, 0.42480794012234235, 0.42480794012234235, 0.42480794012234235, 0.42019370659015154, 0.42019370659015154, 0.42019370659015154, 0.39342577637644693, 0.39342577637644693, 0.39342577637644693, 0.8129258302348119, 0.8129258302348119, 0.8129258302348119, 0.21730783978154822, 0.21730783978154822, 0.21730783978154822, 0.5286283560373077, 0.5286283560373077, 0.5286283560373077, 0.11870767569138119, 0.11870767569138119, 0.11870767569138119, 0.18361825407063215, 0.18361825407063215, 0.18361825407063215, 0.19923949823008957, 0.19923949823008957, 0.19923949823008957, 0.20441818529762568, 0.20441818529762568, 0.20441818529762568, 0.24008752245149256, 0.24008752245149256, 0.24008752245149256, 0.2051140347165913, 0.2051140347165913, 0.2051140347165913, 0.05356541359588485, 0.05356541359588485, 0.05356541359588485, 0.07131796240344157, 0.07131796240344157, 0.07131796240344157, 0.047501096462557735, 0.047501096462557735, 0.047501096462557735, 0.1532382689389611, 0.1532382689389611, 0.1532382689389611, 0.17939792334593185, 0.17939792334593185, 0.17939792334593185, 0.22173103320462384, 0.22173103320462384, 0.22173103320462384, 0.046812921389325135, 0.046812921389325135, 0.046812921389325135, 0.1169394872331142, 0.1169394872331142, 0.1169394872331142, 0.08661341534476596, 0.08661341534476596, 0.08661341534476596, 0.09921503856481939, 0.09921503856481939, 0.09921503856481939, 0.2092744601123112, 0.2092744601123112, 0.2092744601123112, 0.07798124668130202, 0.07798124668130202, 0.07798124668130202, 0.5069273682386521, 0.5069273682386521, 0.5069273682386521, 0.529251781024164, 0.529251781024164, 0.529251781024164, 0.5627797365592413, 0.5627797365592413, 0.5627797365592413, 0.13636460765680536, 0.13636460765680536, 0.13636460765680536, 0.10580261891735554, 0.10580261891735554, 0.10580261891735554, 0.09478876030637895, 0.09478876030637895, 0.09478876030637895, 0.2406665103894775, 0.2406665103894775, 0.2406665103894775, 0.24179875861234923, 0.24179875861234923, 0.24179875861234923, 0.36060568698404116, 0.36060568698404116, 0.36060568698404116, 0.37719563067325357, 0.37719563067325357, 0.37719563067325357, 0.3899155612369142, 0.3899155612369142, 0.3899155612369142, 0.3853197689955409, 0.3853197689955409, 0.3853197689955409, 0.3126616107572262, 0.3126616107572262, 0.3126616107572262, 0.2980184951825632, 0.2980184951825632, 0.2980184951825632, 0.33738280138520493, 0.33738280138520493, 0.33738280138520493, 0.23040734252652395, 0.23040734252652395, 0.23040734252652395, 0.22642657339820293, 0.22642657339820293, 0.22642657339820293, 0.25554422553091694, 0.25554422553091694, 0.25554422553091694, 0.23619167465817348, 0.23619167465817348, 0.23619167465817348, 0.24254933048922367, 0.24254933048922367, 0.24254933048922367, 0.19633385279644833, 0.19633385279644833, 0.19633385279644833, 0.7699039315188246, 0.7699039315188246, 0.7699039315188246, 0.843667002991035, 0.843667002991035, 0.843667002991035, 0.16923569360468538, 0.16923569360468538, 0.16923569360468538, 0.6033358319416999, 0.6033358319416999, 0.6033358319416999, 0.2100696636291215, 0.2100696636291215, 0.2100696636291215, 0.6055808281336255, 0.6055808281336255, 0.6055808281336255, 0.1972625164973527, 0.1972625164973527, 0.1972625164973527, 0.1958527704660008, 0.1958527704660008, 0.1958527704660008, 0.22722867077697761, 0.22722867077697761, 0.22722867077697761, 0.09558334512713229, 0.09558334512713229, 0.09558334512713229, 0.1001422585975229, 0.1001422585975229, 0.1001422585975229, 0.1355796217766121, 0.1355796217766121, 0.1355796217766121]}, "mutation_prompt": null}
{"id": "3f974877-185c-47ad-a3e7-8c25099eb120", "solution": "import numpy as np\n\nclass AdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles = 50\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_probability = 0.2\n        self.mutation_factor = 0.5  # Differential mutation factor\n        self.crossover_rate = 0.9  # Crossover rate for differential evolution\n\n    def __call__(self, func):\n        np.random.seed(0)\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (self.num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (self.num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(self.num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(self.num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n\n            for i in range(self.num_particles):\n                if np.random.rand() < self.local_search_probability:\n                    a, b, c = np.random.choice(self.num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "AdaptiveHybridOptimization", "description": "Adaptive Hybrid Optimization (AHO) combining particle swarm dynamics with differential evolution for enhanced diversity and convergence.", "configspace": "", "generation": 72, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7895836015197397, 0.7895836015197397, 0.7895836015197397, 0.7946939659872195, 0.7946939659872195, 0.7946939659872195, 0.7827185030060426, 0.7827185030060426, 0.7827185030060426, 0.5581754454568489, 0.5581754454568489, 0.5581754454568489, 0.574857286697678, 0.574857286697678, 0.574857286697678, 0.5566457282797854, 0.5566457282797854, 0.5566457282797854, 0.17464627716960057, 0.17464627716960057, 0.17464627716960057, 0.1166444184302361, 0.1166444184302361, 0.1166444184302361, 0.11687482365635138, 0.11687482365635138, 0.11687482365635138, 0.13365689645103163, 0.13365689645103163, 0.13365689645103163, 0.15728296835600997, 0.15728296835600997, 0.15728296835600997, 0.11315853967223444, 0.11315853967223444, 0.11315853967223444, 0.939123796775058, 0.939123796775058, 0.939123796775058, 0.9293789576951788, 0.9293789576951788, 0.9293789576951788, 0.928710751654857, 0.928710751654857, 0.928710751654857, 0.4894503000255258, 0.4894503000255258, 0.4894503000255258, 0.5103152794355856, 0.5103152794355856, 0.5103152794355856, 0.47916012461591806, 0.47916012461591806, 0.47916012461591806, 0.8545918793380147, 0.8545918793380147, 0.8545918793380147, 0.7546022019729164, 0.7546022019729164, 0.7546022019729164, 0.6982566528891132, 0.6982566528891132, 0.6982566528891132, 0.19614203018179022, 0.19614203018179022, 0.19614203018179022, 0.2168586275342569, 0.2168586275342569, 0.2168586275342569, 0.20369001311330848, 0.20369001311330848, 0.20369001311330848, 0.132991816190819, 0.132991816190819, 0.132991816190819, 0.2200528903526182, 0.2200528903526182, 0.2200528903526182, 0.2541679426183254, 0.2541679426183254, 0.2541679426183254, 0.05313909309388709, 0.05313909309388709, 0.05313909309388709, 0.0942862222464832, 0.0942862222464832, 0.0942862222464832, 0.05322492539476953, 0.05322492539476953, 0.05322492539476953, 0.20426992583527892, 0.20426992583527892, 0.20426992583527892, 0.1728343595006363, 0.1728343595006363, 0.1728343595006363, 0.15438215489718898, 0.15438215489718898, 0.15438215489718898, 0.07088574780650558, 0.07088574780650558, 0.07088574780650558, 0.15239007691748085, 0.15239007691748085, 0.15239007691748085, 0.09376040974467525, 0.09376040974467525, 0.09376040974467525, 0.1777896452539588, 0.1777896452539588, 0.1777896452539588, 0.1628951900566381, 0.1628951900566381, 0.1628951900566381, 0.07978427742195893, 0.07978427742195893, 0.07978427742195893, 0.5204904934952671, 0.5204904934952671, 0.5204904934952671, 0.5526658242353327, 0.5526658242353327, 0.5526658242353327, 0.5313657011976667, 0.5313657011976667, 0.5313657011976667, 0.09446891363605114, 0.09446891363605114, 0.09446891363605114, 0.10082884432785666, 0.10082884432785666, 0.10082884432785666, 0.15506941409652442, 0.15506941409652442, 0.15506941409652442, 0.2074271186152098, 0.2074271186152098, 0.2074271186152098, 0.2959668217386152, 0.2959668217386152, 0.2959668217386152, 0.3791244445331239, 0.3791244445331239, 0.3791244445331239, 0.40770683646633, 0.40770683646633, 0.40770683646633, 0.461536616982939, 0.461536616982939, 0.461536616982939, 0.46257700593028883, 0.46257700593028883, 0.46257700593028883, 0.21902107551280947, 0.21902107551280947, 0.21902107551280947, 0.3563258561221383, 0.3563258561221383, 0.3563258561221383, 0.2474680005978266, 0.2474680005978266, 0.2474680005978266, 0.20417258914390446, 0.20417258914390446, 0.20417258914390446, 0.22729678098722805, 0.22729678098722805, 0.22729678098722805, 0.22314842379469357, 0.22314842379469357, 0.22314842379469357, 0.21588487370922083, 0.21588487370922083, 0.21588487370922083, 0.22100840205041583, 0.22100840205041583, 0.22100840205041583, 0.24216124021531737, 0.24216124021531737, 0.24216124021531737, 0.8375012045719195, 0.8375012045719195, 0.8375012045719195, 0.9090806808219745, 0.9090806808219745, 0.9090806808219745, 0.1418618374584506, 0.1418618374584506, 0.1418618374584506, 0.7905978270547784, 0.7905978270547784, 0.7905978270547784, 0.7569990490845664, 0.7569990490845664, 0.7569990490845664, 0.21082535228295762, 0.21082535228295762, 0.21082535228295762, 0.1974656061574156, 0.1974656061574156, 0.1974656061574156, 0.1848299648349595, 0.1848299648349595, 0.1848299648349595, 0.18760627427163612, 0.18760627427163612, 0.18760627427163612, 0.08880660277206842, 0.08880660277206842, 0.08880660277206842, 0.10952451462961632, 0.10952451462961632, 0.10952451462961632, 0.08795370521342216, 0.08795370521342216, 0.08795370521342216]}, "mutation_prompt": null}
{"id": "b0b7acf9-24ef-4e3d-989f-a4a79c608817", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles_initial = 50\n        self.num_particles_final = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_min = 0.1\n        self.local_search_max = 0.4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(0)\n        num_particles = self.num_particles_initial\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n            local_search_probability = self.local_search_min + (\n                (self.local_search_max - self.local_search_min) * evaluations / self.budget)\n            num_particles = int(self.num_particles_initial - (self.num_particles_initial - self.num_particles_final) * evaluations / self.budget)\n\n            for i in range(num_particles):\n                if np.random.rand() < local_search_probability:\n                    a, b, c = np.random.choice(num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) introducing adaptive local search probability and dynamic particle count adjustment for improved convergence.", "configspace": "", "generation": 96, "fitness": 0.3643613924885481, "feedback": "The algorithm EnhancedAdaptiveHybridOptimization got an average Area over the convergence curve (AOCC, 1.0 is the best) score of 0.36 with standard deviation 0.26.", "error": "", "parent_id": "94f43f60-2a9f-475b-85b9-0c5eb521484b", "metadata": {"aucs": [0.7959217440159688, 0.7959217440159688, 0.7959217440159688, 0.8051046899257177, 0.8051046899257177, 0.8051046899257177, 0.7955161461591849, 0.7955161461591849, 0.7955161461591849, 0.5749978360860154, 0.5749978360860154, 0.5749978360860154, 0.5953020805287781, 0.5953020805287781, 0.5953020805287781, 0.55890832598391, 0.55890832598391, 0.55890832598391, 0.15233452720678142, 0.15233452720678142, 0.15233452720678142, 0.10642364712362473, 0.10642364712362473, 0.10642364712362473, 0.07278383300742663, 0.07278383300742663, 0.07278383300742663, 0.0858851007949617, 0.0858851007949617, 0.0858851007949617, 0.12152944602601734, 0.12152944602601734, 0.12152944602601734, 0.11028652566206543, 0.11028652566206543, 0.11028652566206543, 0.9454099143729239, 0.9454099143729239, 0.9454099143729239, 0.9338977318926898, 0.9338977318926898, 0.9338977318926898, 0.9325413910311635, 0.9325413910311635, 0.9325413910311635, 0.5068237378981142, 0.5068237378981142, 0.5068237378981142, 0.5719034593424615, 0.5719034593424615, 0.5719034593424615, 0.5253971905673466, 0.5253971905673466, 0.5253971905673466, 0.7778600996464233, 0.7778600996464233, 0.7778600996464233, 0.7547544111869094, 0.7547544111869094, 0.7547544111869094, 0.6277465823660509, 0.6277465823660509, 0.6277465823660509, 0.2666079937412563, 0.2666079937412563, 0.2666079937412563, 0.21013675617011163, 0.21013675617011163, 0.21013675617011163, 0.2858868683682585, 0.2858868683682585, 0.2858868683682585, 0.26891638014545827, 0.26891638014545827, 0.26891638014545827, 0.2868337031025311, 0.2868337031025311, 0.2868337031025311, 0.25730550133135, 0.25730550133135, 0.25730550133135, 0.08646553257621359, 0.08646553257621359, 0.08646553257621359, 0.08552270955350227, 0.08552270955350227, 0.08552270955350227, 0.12412478381751335, 0.12412478381751335, 0.12412478381751335, 0.2631116477940284, 0.2631116477940284, 0.2631116477940284, 0.15970032902695386, 0.15970032902695386, 0.15970032902695386, 0.23868498966641527, 0.23868498966641527, 0.23868498966641527, 0.20218014778794224, 0.20218014778794224, 0.20218014778794224, 0.20280468178438893, 0.20280468178438893, 0.20280468178438893, 0.08896643438289886, 0.08896643438289886, 0.08896643438289886, 0.26011240922462886, 0.26011240922462886, 0.26011240922462886, 0.20049084102576586, 0.20049084102576586, 0.20049084102576586, 0.24372045979438062, 0.24372045979438062, 0.24372045979438062, 0.5714898813503739, 0.5714898813503739, 0.5714898813503739, 0.5587511234493308, 0.5587511234493308, 0.5587511234493308, 0.6000371564159077, 0.6000371564159077, 0.6000371564159077, 0.0950934974749642, 0.0950934974749642, 0.0950934974749642, 0.12220195144917112, 0.12220195144917112, 0.12220195144917112, 0.07619893057879201, 0.07619893057879201, 0.07619893057879201, 0.2612566465328373, 0.2612566465328373, 0.2612566465328373, 0.5358390630681077, 0.5358390630681077, 0.5358390630681077, 0.4297398331001122, 0.4297398331001122, 0.4297398331001122, 0.4682681145316646, 0.4682681145316646, 0.4682681145316646, 0.5060778987059686, 0.5060778987059686, 0.5060778987059686, 0.2832669778085305, 0.2832669778085305, 0.2832669778085305, 0.34473549705757833, 0.34473549705757833, 0.34473549705757833, 0.1998509638125262, 0.1998509638125262, 0.1998509638125262, 0.2390105623590122, 0.2390105623590122, 0.2390105623590122, 0.21025426857153584, 0.21025426857153584, 0.21025426857153584, 0.25073242507243254, 0.25073242507243254, 0.25073242507243254, 0.27183225535423905, 0.27183225535423905, 0.27183225535423905, 0.20782600038706867, 0.20782600038706867, 0.20782600038706867, 0.20533790840958233, 0.20533790840958233, 0.20533790840958233, 0.21980512315496636, 0.21980512315496636, 0.21980512315496636, 0.15748921268789018, 0.15748921268789018, 0.15748921268789018, 0.8690233885767351, 0.8690233885767351, 0.8690233885767351, 0.8528460214103532, 0.8528460214103532, 0.8528460214103532, 0.8123635891546607, 0.8123635891546607, 0.8123635891546607, 0.20834636521587002, 0.20834636521587002, 0.20834636521587002, 0.6549628028127958, 0.6549628028127958, 0.6549628028127958, 0.20577642456536338, 0.20577642456536338, 0.20577642456536338, 0.21223883187653025, 0.21223883187653025, 0.21223883187653025, 0.19148905435785035, 0.19148905435785035, 0.19148905435785035, 0.15081889455801156, 0.15081889455801156, 0.15081889455801156, 0.08955619325834563, 0.08955619325834563, 0.08955619325834563, 0.08860281193821973, 0.08860281193821973, 0.08860281193821973]}, "mutation_prompt": null}
{"id": "3aff87e7-9ec0-4f72-b9be-1fd7c42ccf5d", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles_initial = 50\n        self.num_particles_final = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_min = 0.1\n        self.local_search_max = 0.4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(0)\n        num_particles = self.num_particles_initial\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n            local_search_probability = self.local_search_min + (\n                (self.local_search_max - self.local_search_min) * evaluations / self.budget)\n            num_particles = int(self.num_particles_initial - (self.num_particles_initial - self.num_particles_final) * evaluations / self.budget)\n\n            for i in range(num_particles):\n                if np.random.rand() < local_search_probability:\n                    a, b, c = np.random.choice(num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) introducing adaptive local search probability and dynamic particle count adjustment for improved convergence.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b0b7acf9-24ef-4e3d-989f-a4a79c608817", "metadata": {"aucs": [0.7959217440159688, 0.7959217440159688, 0.7959217440159688, 0.8051046899257177, 0.8051046899257177, 0.8051046899257177, 0.7955161461591849, 0.7955161461591849, 0.7955161461591849, 0.5749978360860154, 0.5749978360860154, 0.5749978360860154, 0.5953020805287781, 0.5953020805287781, 0.5953020805287781, 0.55890832598391, 0.55890832598391, 0.55890832598391, 0.15233452720678142, 0.15233452720678142, 0.15233452720678142, 0.10642364712362473, 0.10642364712362473, 0.10642364712362473, 0.07278383300742663, 0.07278383300742663, 0.07278383300742663, 0.0858851007949617, 0.0858851007949617, 0.0858851007949617, 0.12152944602601734, 0.12152944602601734, 0.12152944602601734, 0.11028652566206543, 0.11028652566206543, 0.11028652566206543, 0.9454099143729239, 0.9454099143729239, 0.9454099143729239, 0.9338977318926898, 0.9338977318926898, 0.9338977318926898, 0.9325413910311635, 0.9325413910311635, 0.9325413910311635, 0.5068237378981142, 0.5068237378981142, 0.5068237378981142, 0.5719034593424615, 0.5719034593424615, 0.5719034593424615, 0.5253971905673466, 0.5253971905673466, 0.5253971905673466, 0.7778600996464233, 0.7778600996464233, 0.7778600996464233, 0.7547544111869094, 0.7547544111869094, 0.7547544111869094, 0.6277465823660509, 0.6277465823660509, 0.6277465823660509, 0.2666079937412563, 0.2666079937412563, 0.2666079937412563, 0.21013675617011163, 0.21013675617011163, 0.21013675617011163, 0.2858868683682585, 0.2858868683682585, 0.2858868683682585, 0.26891638014545827, 0.26891638014545827, 0.26891638014545827, 0.2868337031025311, 0.2868337031025311, 0.2868337031025311, 0.25730550133135, 0.25730550133135, 0.25730550133135, 0.08646553257621359, 0.08646553257621359, 0.08646553257621359, 0.08552270955350227, 0.08552270955350227, 0.08552270955350227, 0.12412478381751335, 0.12412478381751335, 0.12412478381751335, 0.2631116477940284, 0.2631116477940284, 0.2631116477940284, 0.15970032902695386, 0.15970032902695386, 0.15970032902695386, 0.23868498966641527, 0.23868498966641527, 0.23868498966641527, 0.20218014778794224, 0.20218014778794224, 0.20218014778794224, 0.20280468178438893, 0.20280468178438893, 0.20280468178438893, 0.08896643438289886, 0.08896643438289886, 0.08896643438289886, 0.26011240922462886, 0.26011240922462886, 0.26011240922462886, 0.20049084102576586, 0.20049084102576586, 0.20049084102576586, 0.24372045979438062, 0.24372045979438062, 0.24372045979438062, 0.5714898813503739, 0.5714898813503739, 0.5714898813503739, 0.5587511234493308, 0.5587511234493308, 0.5587511234493308, 0.6000371564159077, 0.6000371564159077, 0.6000371564159077, 0.0950934974749642, 0.0950934974749642, 0.0950934974749642, 0.12220195144917112, 0.12220195144917112, 0.12220195144917112, 0.07619893057879201, 0.07619893057879201, 0.07619893057879201, 0.2612566465328373, 0.2612566465328373, 0.2612566465328373, 0.5358390630681077, 0.5358390630681077, 0.5358390630681077, 0.4297398331001122, 0.4297398331001122, 0.4297398331001122, 0.4682681145316646, 0.4682681145316646, 0.4682681145316646, 0.5060778987059686, 0.5060778987059686, 0.5060778987059686, 0.2832669778085305, 0.2832669778085305, 0.2832669778085305, 0.34473549705757833, 0.34473549705757833, 0.34473549705757833, 0.1998509638125262, 0.1998509638125262, 0.1998509638125262, 0.2390105623590122, 0.2390105623590122, 0.2390105623590122, 0.21025426857153584, 0.21025426857153584, 0.21025426857153584, 0.25073242507243254, 0.25073242507243254, 0.25073242507243254, 0.27183225535423905, 0.27183225535423905, 0.27183225535423905, 0.20782600038706867, 0.20782600038706867, 0.20782600038706867, 0.20533790840958233, 0.20533790840958233, 0.20533790840958233, 0.21980512315496636, 0.21980512315496636, 0.21980512315496636, 0.15748921268789018, 0.15748921268789018, 0.15748921268789018, 0.8690233885767351, 0.8690233885767351, 0.8690233885767351, 0.8528460214103532, 0.8528460214103532, 0.8528460214103532, 0.8123635891546607, 0.8123635891546607, 0.8123635891546607, 0.20834636521587002, 0.20834636521587002, 0.20834636521587002, 0.6549628028127958, 0.6549628028127958, 0.6549628028127958, 0.20577642456536338, 0.20577642456536338, 0.20577642456536338, 0.21223883187653025, 0.21223883187653025, 0.21223883187653025, 0.19148905435785035, 0.19148905435785035, 0.19148905435785035, 0.15081889455801156, 0.15081889455801156, 0.15081889455801156, 0.08955619325834563, 0.08955619325834563, 0.08955619325834563, 0.08860281193821973, 0.08860281193821973, 0.08860281193821973]}, "mutation_prompt": null}
{"id": "721b50ec-ef92-4ac4-917c-9efaa102a77e", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles_initial = 50\n        self.num_particles_final = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_min = 0.1\n        self.local_search_max = 0.4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(0)\n        num_particles = self.num_particles_initial\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n            local_search_probability = self.local_search_min + (\n                (self.local_search_max - self.local_search_min) * evaluations / self.budget)\n            num_particles = int(self.num_particles_initial - (self.num_particles_initial - self.num_particles_final) * evaluations / self.budget)\n\n            for i in range(num_particles):\n                if np.random.rand() < local_search_probability:\n                    a, b, c = np.random.choice(num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) introducing adaptive local search probability and dynamic particle count adjustment for improved convergence.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b0b7acf9-24ef-4e3d-989f-a4a79c608817", "metadata": {"aucs": [0.7959217440159688, 0.7959217440159688, 0.7959217440159688, 0.8051046899257177, 0.8051046899257177, 0.8051046899257177, 0.7955161461591849, 0.7955161461591849, 0.7955161461591849, 0.5749978360860154, 0.5749978360860154, 0.5749978360860154, 0.5953020805287781, 0.5953020805287781, 0.5953020805287781, 0.55890832598391, 0.55890832598391, 0.55890832598391, 0.15233452720678142, 0.15233452720678142, 0.15233452720678142, 0.10642364712362473, 0.10642364712362473, 0.10642364712362473, 0.07278383300742663, 0.07278383300742663, 0.07278383300742663, 0.0858851007949617, 0.0858851007949617, 0.0858851007949617, 0.12152944602601734, 0.12152944602601734, 0.12152944602601734, 0.11028652566206543, 0.11028652566206543, 0.11028652566206543, 0.9454099143729239, 0.9454099143729239, 0.9454099143729239, 0.9338977318926898, 0.9338977318926898, 0.9338977318926898, 0.9325413910311635, 0.9325413910311635, 0.9325413910311635, 0.5068237378981142, 0.5068237378981142, 0.5068237378981142, 0.5719034593424615, 0.5719034593424615, 0.5719034593424615, 0.5253971905673466, 0.5253971905673466, 0.5253971905673466, 0.7778600996464233, 0.7778600996464233, 0.7778600996464233, 0.7547544111869094, 0.7547544111869094, 0.7547544111869094, 0.6277465823660509, 0.6277465823660509, 0.6277465823660509, 0.2666079937412563, 0.2666079937412563, 0.2666079937412563, 0.21013675617011163, 0.21013675617011163, 0.21013675617011163, 0.2858868683682585, 0.2858868683682585, 0.2858868683682585, 0.26891638014545827, 0.26891638014545827, 0.26891638014545827, 0.2868337031025311, 0.2868337031025311, 0.2868337031025311, 0.25730550133135, 0.25730550133135, 0.25730550133135, 0.08646553257621359, 0.08646553257621359, 0.08646553257621359, 0.08552270955350227, 0.08552270955350227, 0.08552270955350227, 0.12412478381751335, 0.12412478381751335, 0.12412478381751335, 0.2631116477940284, 0.2631116477940284, 0.2631116477940284, 0.15970032902695386, 0.15970032902695386, 0.15970032902695386, 0.23868498966641527, 0.23868498966641527, 0.23868498966641527, 0.20218014778794224, 0.20218014778794224, 0.20218014778794224, 0.20280468178438893, 0.20280468178438893, 0.20280468178438893, 0.08896643438289886, 0.08896643438289886, 0.08896643438289886, 0.26011240922462886, 0.26011240922462886, 0.26011240922462886, 0.20049084102576586, 0.20049084102576586, 0.20049084102576586, 0.24372045979438062, 0.24372045979438062, 0.24372045979438062, 0.5714898813503739, 0.5714898813503739, 0.5714898813503739, 0.5587511234493308, 0.5587511234493308, 0.5587511234493308, 0.6000371564159077, 0.6000371564159077, 0.6000371564159077, 0.0950934974749642, 0.0950934974749642, 0.0950934974749642, 0.12220195144917112, 0.12220195144917112, 0.12220195144917112, 0.07619893057879201, 0.07619893057879201, 0.07619893057879201, 0.2612566465328373, 0.2612566465328373, 0.2612566465328373, 0.5358390630681077, 0.5358390630681077, 0.5358390630681077, 0.4297398331001122, 0.4297398331001122, 0.4297398331001122, 0.4682681145316646, 0.4682681145316646, 0.4682681145316646, 0.5060778987059686, 0.5060778987059686, 0.5060778987059686, 0.2832669778085305, 0.2832669778085305, 0.2832669778085305, 0.34473549705757833, 0.34473549705757833, 0.34473549705757833, 0.1998509638125262, 0.1998509638125262, 0.1998509638125262, 0.2390105623590122, 0.2390105623590122, 0.2390105623590122, 0.21025426857153584, 0.21025426857153584, 0.21025426857153584, 0.25073242507243254, 0.25073242507243254, 0.25073242507243254, 0.27183225535423905, 0.27183225535423905, 0.27183225535423905, 0.20782600038706867, 0.20782600038706867, 0.20782600038706867, 0.20533790840958233, 0.20533790840958233, 0.20533790840958233, 0.21980512315496636, 0.21980512315496636, 0.21980512315496636, 0.15748921268789018, 0.15748921268789018, 0.15748921268789018, 0.8690233885767351, 0.8690233885767351, 0.8690233885767351, 0.8528460214103532, 0.8528460214103532, 0.8528460214103532, 0.8123635891546607, 0.8123635891546607, 0.8123635891546607, 0.20834636521587002, 0.20834636521587002, 0.20834636521587002, 0.6549628028127958, 0.6549628028127958, 0.6549628028127958, 0.20577642456536338, 0.20577642456536338, 0.20577642456536338, 0.21223883187653025, 0.21223883187653025, 0.21223883187653025, 0.19148905435785035, 0.19148905435785035, 0.19148905435785035, 0.15081889455801156, 0.15081889455801156, 0.15081889455801156, 0.08955619325834563, 0.08955619325834563, 0.08955619325834563, 0.08860281193821973, 0.08860281193821973, 0.08860281193821973]}, "mutation_prompt": null}
{"id": "9fff341d-151b-42d5-bc24-bd6100fb5462", "solution": "import numpy as np\n\nclass EnhancedAdaptiveHybridOptimization:\n    def __init__(self, budget, dim):\n        self.budget = budget\n        self.dim = dim\n        self.num_particles_initial = 50\n        self.num_particles_final = 30\n        self.lower_bound = -5.0\n        self.upper_bound = 5.0\n        self.w_max = 0.7\n        self.w_min = 0.3\n        self.c1_initial = 2.0\n        self.c2_initial = 1.8\n        self.c1_final = 1.5\n        self.c2_final = 2.5\n        self.velocity_clamp_initial = 0.9\n        self.velocity_clamp_final = 0.25\n        self.local_search_min = 0.1\n        self.local_search_max = 0.4\n        self.mutation_factor = 0.5\n        self.crossover_rate = 0.9\n\n    def __call__(self, func):\n        np.random.seed(0)\n        num_particles = self.num_particles_initial\n        positions = np.random.uniform(self.lower_bound, self.upper_bound, (num_particles, self.dim))\n        velocities = np.random.uniform(-self.velocity_clamp_initial, self.velocity_clamp_initial, (num_particles, self.dim))\n        personal_best_positions = positions.copy()\n        personal_best_scores = np.full(num_particles, float('inf'))\n        global_best_position = None\n        global_best_score = float('inf')\n\n        evaluations = 0\n        while evaluations < self.budget:\n            for i in range(num_particles):\n                score = func(positions[i])\n                evaluations += 1\n                if score < personal_best_scores[i]:\n                    personal_best_scores[i] = score\n                    personal_best_positions[i] = positions[i].copy()\n                    if score < global_best_score:\n                        global_best_score = score\n                        global_best_position = positions[i].copy()\n\n                if evaluations >= self.budget:\n                    break\n\n            inertia_weight = self.w_max - ((self.w_max - self.w_min) * evaluations / self.budget)\n            c1 = self.c1_initial - ((self.c1_initial - self.c1_final) * evaluations / self.budget)\n            c2 = self.c2_initial + ((self.c2_final - self.c2_initial) * evaluations / self.budget)\n            velocity_clamp = self.velocity_clamp_initial - ((self.velocity_clamp_initial - self.velocity_clamp_final) * evaluations / self.budget)\n            local_search_probability = self.local_search_min + (\n                (self.local_search_max - self.local_search_min) * evaluations / self.budget)\n            num_particles = int(self.num_particles_initial - (self.num_particles_initial - self.num_particles_final) * evaluations / self.budget)\n\n            for i in range(num_particles):\n                if np.random.rand() < local_search_probability:\n                    a, b, c = np.random.choice(num_particles, 3, replace=False)\n                    mutant_vector = personal_best_positions[a] + self.mutation_factor * (personal_best_positions[b] - personal_best_positions[c])\n                    trial_vector = np.where(np.random.rand(self.dim) < self.crossover_rate, mutant_vector, positions[i])\n                    trial_vector = np.clip(trial_vector, self.lower_bound, self.upper_bound)\n                    trial_score = func(trial_vector)\n                    evaluations += 1\n                    if trial_score < personal_best_scores[i]:\n                        personal_best_scores[i] = trial_score\n                        personal_best_positions[i] = trial_vector.copy()\n                        if trial_score < global_best_score:\n                            global_best_score = trial_score\n                            global_best_position = trial_vector.copy()\n\n                cognitive_component = c1 * np.random.uniform(0, 1, self.dim) * (personal_best_positions[i] - positions[i])\n                social_component = c2 * np.random.uniform(0, 1, self.dim) * (global_best_position - positions[i])\n                velocities[i] = inertia_weight * velocities[i] + cognitive_component + social_component\n                \n                velocities[i] = np.clip(velocities[i], -velocity_clamp, velocity_clamp)\n                \n                positions[i] += velocities[i]\n                positions[i] = np.clip(positions[i], self.lower_bound, self.upper_bound)", "name": "EnhancedAdaptiveHybridOptimization", "description": "Enhanced Adaptive Hybrid Optimization (EAHO) introducing adaptive local search probability and dynamic particle count adjustment for improved convergence.", "configspace": "", "generation": 97, "fitness": -Infinity, "feedback": "No code was extracted. The code should be encapsulated with ``` in your response.", "error": "The code should be encapsulated with ``` in your response.", "parent_id": "b0b7acf9-24ef-4e3d-989f-a4a79c608817", "metadata": {"aucs": [0.7959217440159688, 0.7959217440159688, 0.7959217440159688, 0.8051046899257177, 0.8051046899257177, 0.8051046899257177, 0.7955161461591849, 0.7955161461591849, 0.7955161461591849, 0.5749978360860154, 0.5749978360860154, 0.5749978360860154, 0.5953020805287781, 0.5953020805287781, 0.5953020805287781, 0.55890832598391, 0.55890832598391, 0.55890832598391, 0.15233452720678142, 0.15233452720678142, 0.15233452720678142, 0.10642364712362473, 0.10642364712362473, 0.10642364712362473, 0.07278383300742663, 0.07278383300742663, 0.07278383300742663, 0.0858851007949617, 0.0858851007949617, 0.0858851007949617, 0.12152944602601734, 0.12152944602601734, 0.12152944602601734, 0.11028652566206543, 0.11028652566206543, 0.11028652566206543, 0.9454099143729239, 0.9454099143729239, 0.9454099143729239, 0.9338977318926898, 0.9338977318926898, 0.9338977318926898, 0.9325413910311635, 0.9325413910311635, 0.9325413910311635, 0.5068237378981142, 0.5068237378981142, 0.5068237378981142, 0.5719034593424615, 0.5719034593424615, 0.5719034593424615, 0.5253971905673466, 0.5253971905673466, 0.5253971905673466, 0.7778600996464233, 0.7778600996464233, 0.7778600996464233, 0.7547544111869094, 0.7547544111869094, 0.7547544111869094, 0.6277465823660509, 0.6277465823660509, 0.6277465823660509, 0.2666079937412563, 0.2666079937412563, 0.2666079937412563, 0.21013675617011163, 0.21013675617011163, 0.21013675617011163, 0.2858868683682585, 0.2858868683682585, 0.2858868683682585, 0.26891638014545827, 0.26891638014545827, 0.26891638014545827, 0.2868337031025311, 0.2868337031025311, 0.2868337031025311, 0.25730550133135, 0.25730550133135, 0.25730550133135, 0.08646553257621359, 0.08646553257621359, 0.08646553257621359, 0.08552270955350227, 0.08552270955350227, 0.08552270955350227, 0.12412478381751335, 0.12412478381751335, 0.12412478381751335, 0.2631116477940284, 0.2631116477940284, 0.2631116477940284, 0.15970032902695386, 0.15970032902695386, 0.15970032902695386, 0.23868498966641527, 0.23868498966641527, 0.23868498966641527, 0.20218014778794224, 0.20218014778794224, 0.20218014778794224, 0.20280468178438893, 0.20280468178438893, 0.20280468178438893, 0.08896643438289886, 0.08896643438289886, 0.08896643438289886, 0.26011240922462886, 0.26011240922462886, 0.26011240922462886, 0.20049084102576586, 0.20049084102576586, 0.20049084102576586, 0.24372045979438062, 0.24372045979438062, 0.24372045979438062, 0.5714898813503739, 0.5714898813503739, 0.5714898813503739, 0.5587511234493308, 0.5587511234493308, 0.5587511234493308, 0.6000371564159077, 0.6000371564159077, 0.6000371564159077, 0.0950934974749642, 0.0950934974749642, 0.0950934974749642, 0.12220195144917112, 0.12220195144917112, 0.12220195144917112, 0.07619893057879201, 0.07619893057879201, 0.07619893057879201, 0.2612566465328373, 0.2612566465328373, 0.2612566465328373, 0.5358390630681077, 0.5358390630681077, 0.5358390630681077, 0.4297398331001122, 0.4297398331001122, 0.4297398331001122, 0.4682681145316646, 0.4682681145316646, 0.4682681145316646, 0.5060778987059686, 0.5060778987059686, 0.5060778987059686, 0.2832669778085305, 0.2832669778085305, 0.2832669778085305, 0.34473549705757833, 0.34473549705757833, 0.34473549705757833, 0.1998509638125262, 0.1998509638125262, 0.1998509638125262, 0.2390105623590122, 0.2390105623590122, 0.2390105623590122, 0.21025426857153584, 0.21025426857153584, 0.21025426857153584, 0.25073242507243254, 0.25073242507243254, 0.25073242507243254, 0.27183225535423905, 0.27183225535423905, 0.27183225535423905, 0.20782600038706867, 0.20782600038706867, 0.20782600038706867, 0.20533790840958233, 0.20533790840958233, 0.20533790840958233, 0.21980512315496636, 0.21980512315496636, 0.21980512315496636, 0.15748921268789018, 0.15748921268789018, 0.15748921268789018, 0.8690233885767351, 0.8690233885767351, 0.8690233885767351, 0.8528460214103532, 0.8528460214103532, 0.8528460214103532, 0.8123635891546607, 0.8123635891546607, 0.8123635891546607, 0.20834636521587002, 0.20834636521587002, 0.20834636521587002, 0.6549628028127958, 0.6549628028127958, 0.6549628028127958, 0.20577642456536338, 0.20577642456536338, 0.20577642456536338, 0.21223883187653025, 0.21223883187653025, 0.21223883187653025, 0.19148905435785035, 0.19148905435785035, 0.19148905435785035, 0.15081889455801156, 0.15081889455801156, 0.15081889455801156, 0.08955619325834563, 0.08955619325834563, 0.08955619325834563, 0.08860281193821973, 0.08860281193821973, 0.08860281193821973]}, "mutation_prompt": null}
